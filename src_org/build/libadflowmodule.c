/* File: libadflowmodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Wed Nov 10 09:29:31 2021
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "Python.h"
#include <stdarg.h>
#include "fortranobject.h"
#include <string.h>
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *libadflow_error;
static PyObject *libadflow_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef char * string;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#define PRINTPYOBJERR(obj)\
    fprintf(stderr,"libadflow.error is related to ");\
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");

\
#define FAILNULL(p) do {                                            \
    if ((p) == NULL) {                                              \
        PyErr_SetString(PyExc_MemoryError, "NULL pointer found");   \
        goto capi_fail;                                             \
    }                                                               \
} while (0)

#define STRINGMALLOC(str,len)\
    if ((str = (string)malloc(sizeof(char)*(len+1))) == NULL) {\
        PyErr_SetString(PyExc_MemoryError, "out of memory");\
        goto capi_fail;\
    } else {\
        (str)[len] = '\0';\
    }

#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp)))
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim)
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#define CHECKSCALAR(check,tcheck,name,show,var)\
    if (!(check)) {\
        char errstring[256];\
        sprintf(errstring, "%s: "show, "("tcheck") failed for "name, var);\
        PyErr_SetString(libadflow_error,errstring);\
        /*goto capi_fail;*/\
    } else 
#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#define STRINGFREE(str) do {if (!(str == NULL)) free(str);} while (0)

#define STRINGCOPYN(to,from,buf_size)                           \
    do {                                                        \
        int _m = (buf_size);                                    \
        char *_to = (to);                                       \
        char *_from = (from);                                   \
        FAILNULL(_to); FAILNULL(_from);                         \
        (void)strncpy(_to, _from, sizeof(char)*_m);             \
        _to[_m-1] = '\0';                                      \
        /* Padding with spaces instead of nulls */              \
        for (_m -= 2; _m >= 0 && _to[_m] == '\0'; _m--) {      \
            _to[_m] = ' ';                                      \
        }                                                       \
    } while (0)


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int
int_from_pyobj(int* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;

    if (PyLong_Check(obj)) {
        *v = Npy__PyLong_AsInt(obj);
        return !(*v == -1 && PyErr_Occurred());
    }

    tmp = PyNumber_Long(obj);
    if (tmp) {
        *v = Npy__PyLong_AsInt(tmp);
        Py_DECREF(tmp);
        return !(*v == -1 && PyErr_Occurred());
    }

    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj, 0);
    if (tmp) {
        PyErr_Clear();
        if (int_from_pyobj(v, tmp, errmess)) {
            Py_DECREF(tmp);
            return 1;
        }
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err == NULL) {
            err = libadflow_error;
        }
        PyErr_SetString(err, errmess);
    }
    return 0;
}

static int
double_from_pyobj(double* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
        *v = PyFloat_AsDouble(obj);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    tmp = PyNumber_Float(obj);
    if (tmp) {
        *v = PyFloat_AsDouble(tmp);
        Py_DECREF(tmp);
        return !(*v == -1.0 && PyErr_Occurred());
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = libadflow_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int
string_from_pyobj(string *str,int *len,const string inistr,PyObject *obj,const char *errmess)
{
    PyArrayObject *arr = NULL;
    PyObject *tmp = NULL;
#ifdef DEBUGCFUNCS
fprintf(stderr,"string_from_pyobj(str='%s',len=%d,inistr='%s',obj=%p)\n",(char*)str,*len,(char *)inistr,obj);
#endif
    if (obj == Py_None) {
        if (*len == -1)
            *len = strlen(inistr); /* Will this cause problems? */
        STRINGMALLOC(*str,*len);
        STRINGCOPYN(*str,inistr,*len+1);
        return 1;
    }
    if (PyArray_Check(obj)) {
        if ((arr = (PyArrayObject *)obj) == NULL)
            goto capi_fail;
        if (!ISCONTIGUOUS(arr)) {
            PyErr_SetString(PyExc_ValueError,"array object is non-contiguous.");
            goto capi_fail;
        }
        if (*len == -1)
            *len = (PyArray_ITEMSIZE(arr))*PyArray_SIZE(arr);
        STRINGMALLOC(*str,*len);
        STRINGCOPYN(*str,PyArray_DATA(arr),*len+1);
        return 1;
    }
    if (PyBytes_Check(obj)) {
        tmp = obj;
        Py_INCREF(tmp);
    }
    else if (PyUnicode_Check(obj)) {
        tmp = PyUnicode_AsASCIIString(obj);
    }
    else {
        PyObject *tmp2;
        tmp2 = PyObject_Str(obj);
        if (tmp2) {
            tmp = PyUnicode_AsASCIIString(tmp2);
            Py_DECREF(tmp2);
        }
        else {
            tmp = NULL;
        }
    }
    if (tmp == NULL) goto capi_fail;
    if (*len == -1)
        *len = PyBytes_GET_SIZE(tmp);
    STRINGMALLOC(*str,*len);
    STRINGCOPYN(*str,PyBytes_AS_STRING(tmp),*len+1);
    Py_DECREF(tmp);
    return 1;
capi_fail:
    Py_XDECREF(tmp);
    {
        PyObject* err = PyErr_Occurred();
        if (err == NULL) {
            err = libadflow_error;
        }
        PyErr_SetString(err, errmess);
    }
    return 0;
}

static int try_pyarr_from_string(PyObject *obj,const string str) {
    PyArrayObject *arr = NULL;
    if (PyArray_Check(obj) && (!((arr = (PyArrayObject *)obj) == NULL)))
        { STRINGCOPYN(PyArray_DATA(arr),str,PyArray_NBYTES(arr)); }
    return 1;
capi_fail:
    PRINTPYOBJERR(obj);
    PyErr_SetString(libadflow_error,"try_pyarr_from_string failed");
    return 0;
}

static int
float_from_pyobj(float* v, PyObject *obj, const char *errmess)
{
    double d=0.0;
    if (double_from_pyobj(&d,obj,errmess)) {
        *v = (float)d;
        return 1;
    }
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
extern void F_FUNC(writesol,WRITESOL)(int*,int*);
extern void F_FUNC(getforces,GETFORCES)(double*,int*,int*);
extern void F_FUNC(getheatflux,GETHEATFLUX)(double*,int*,int*);
extern void F_FUNC(settnswall,SETTNSWALL)(double*,int*,int*);
extern void F_FUNC(gettnswall,GETTNSWALL)(double*,int*,int*);
extern void F_FUNC(setcptargets,SETCPTARGETS)(double*,int*,int*);
extern void F_FUNC(getcptargets,GETCPTARGETS)(double*,int*,int*);
extern void F_FUNC(getareas,GETAREAS)(double*,double*,int*,int*,double*);
extern void F_FUNC(getareasensitivity,GETAREASENSITIVITY)(double*,double*,int*,int*,double*);
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/********************************** writesol **********************************/
static char doc_f2py_rout_libadflow_writesol[] = "\
writesol(famlist,[nfamlist])\n\nWrapper for ``writesol``.\
\n\nParameters\n----------\n"
"famlist : input rank-1 array('i') with bounds (nfamlist)\n"
"\nOther Parameters\n----------------\n"
"nfamlist : input int, optional\n    Default: len(famlist)";
/* extern void F_FUNC(writesol,WRITESOL)(int*,int*); */
static PyObject *f2py_rout_libadflow_writesol(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int nfamlist = 0;
  PyObject *nfamlist_capi = Py_None;
    static char *capi_kwlist[] = {"famlist","nfamlist",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:libadflow.writesol",\
        capi_kwlist,&famlist_capi,&nfamlist_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `famlist' of libadflow.writesol to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable nfamlist */
  if (nfamlist_capi == Py_None) nfamlist = len(famlist); else
    f2py_success = int_from_pyobj(&nfamlist,nfamlist_capi,"libadflow.writesol() 1st keyword (nfamlist) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=nfamlist,"len(famlist)>=nfamlist","1st keyword nfamlist","writesol:nfamlist=%d",nfamlist) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(famlist,&nfamlist);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=nfamlist)*/
  } /*if (f2py_success) of nfamlist*/
  /* End of cleaning variable nfamlist */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of writesol ******************************/

/********************************* getforces *********************************/
static char doc_f2py_rout_libadflow_getforces[] = "\
getforces(forces,sps,[npts])\n\nWrapper for ``getforces``.\
\n\nParameters\n----------\n"
"forces : in/output rank-2 array('d') with bounds (3,npts)\n"
"sps : input int\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: shape(forces,1)";
/* extern void F_FUNC(getforces,GETFORCES)(double*,int*,int*); */
static PyObject *f2py_rout_libadflow_getforces(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *forces = NULL;
  npy_intp forces_Dims[2] = {-1, -1};
  const int forces_Rank = 2;
  PyArrayObject *capi_forces_tmp = NULL;
  int capi_forces_intent = 0;
  PyObject *forces_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps = 0;
  PyObject *sps_capi = Py_None;
    static char *capi_kwlist[] = {"forces","sps","npts",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.getforces",\
        capi_kwlist,&forces_capi,&sps_capi,&npts_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable forces */
  forces_Dims[0]=3;
  capi_forces_intent |= F2PY_INTENT_INOUT;
  capi_forces_tmp = array_from_pyobj(NPY_DOUBLE,forces_Dims,forces_Rank,capi_forces_intent,forces_capi);
  if (capi_forces_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `forces' of libadflow.getforces to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    forces = (double *)(PyArray_DATA(capi_forces_tmp));

  /* Processing variable sps */
    f2py_success = int_from_pyobj(&sps,sps_capi,"libadflow.getforces() 2nd argument (sps) can't be converted to int");
  if (f2py_success) {
  /* Processing variable npts */
  if (npts_capi == Py_None) npts = shape(forces,1); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.getforces() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(forces,1)==npts,"shape(forces,1)==npts","1st keyword npts","getforces:npts=%d",npts) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(forces,&npts,&sps);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(forces,1)==npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  } /*if (f2py_success) of sps*/
  /* End of cleaning variable sps */
  if((PyObject *)capi_forces_tmp!=forces_capi) {
    Py_XDECREF(capi_forces_tmp); }
  }  /*if (capi_forces_tmp == NULL) ... else of forces*/
  /* End of cleaning variable forces */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of getforces ******************************/

/******************************** getheatflux ********************************/
static char doc_f2py_rout_libadflow_getheatflux[] = "\
getheatflux(hflux,sps_in,[npts])\n\nWrapper for ``getheatflux``.\
\n\nParameters\n----------\n"
"hflux : in/output rank-1 array('d') with bounds (npts)\n"
"sps_in : input int\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: len(hflux)";
/* extern void F_FUNC(getheatflux,GETHEATFLUX)(double*,int*,int*); */
static PyObject *f2py_rout_libadflow_getheatflux(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *hflux = NULL;
  npy_intp hflux_Dims[1] = {-1};
  const int hflux_Rank = 1;
  PyArrayObject *capi_hflux_tmp = NULL;
  int capi_hflux_intent = 0;
  PyObject *hflux_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps_in = 0;
  PyObject *sps_in_capi = Py_None;
    static char *capi_kwlist[] = {"hflux","sps_in","npts",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.getheatflux",\
        capi_kwlist,&hflux_capi,&sps_in_capi,&npts_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable hflux */
  ;
  capi_hflux_intent |= F2PY_INTENT_INOUT;
  capi_hflux_tmp = array_from_pyobj(NPY_DOUBLE,hflux_Dims,hflux_Rank,capi_hflux_intent,hflux_capi);
  if (capi_hflux_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `hflux' of libadflow.getheatflux to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    hflux = (double *)(PyArray_DATA(capi_hflux_tmp));

  /* Processing variable sps_in */
    f2py_success = int_from_pyobj(&sps_in,sps_in_capi,"libadflow.getheatflux() 2nd argument (sps_in) can't be converted to int");
  if (f2py_success) {
  /* Processing variable npts */
  if (npts_capi == Py_None) npts = len(hflux); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.getheatflux() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(hflux,&npts,&sps_in);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  } /*if (f2py_success) of sps_in*/
  /* End of cleaning variable sps_in */
  if((PyObject *)capi_hflux_tmp!=hflux_capi) {
    Py_XDECREF(capi_hflux_tmp); }
  }  /*if (capi_hflux_tmp == NULL) ... else of hflux*/
  /* End of cleaning variable hflux */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of getheatflux *****************************/

/********************************* settnswall *********************************/
static char doc_f2py_rout_libadflow_settnswall[] = "\
settnswall(tnsw,sps_in,[npts])\n\nWrapper for ``settnswall``.\
\n\nParameters\n----------\n"
"tnsw : input rank-1 array('d') with bounds (npts)\n"
"sps_in : input int\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: len(tnsw)";
/* extern void F_FUNC(settnswall,SETTNSWALL)(double*,int*,int*); */
static PyObject *f2py_rout_libadflow_settnswall(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *tnsw = NULL;
  npy_intp tnsw_Dims[1] = {-1};
  const int tnsw_Rank = 1;
  PyArrayObject *capi_tnsw_tmp = NULL;
  int capi_tnsw_intent = 0;
  PyObject *tnsw_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps_in = 0;
  PyObject *sps_in_capi = Py_None;
    static char *capi_kwlist[] = {"tnsw","sps_in","npts",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.settnswall",\
        capi_kwlist,&tnsw_capi,&sps_in_capi,&npts_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable tnsw */
  ;
  capi_tnsw_intent |= F2PY_INTENT_IN;
  capi_tnsw_tmp = array_from_pyobj(NPY_DOUBLE,tnsw_Dims,tnsw_Rank,capi_tnsw_intent,tnsw_capi);
  if (capi_tnsw_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `tnsw' of libadflow.settnswall to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    tnsw = (double *)(PyArray_DATA(capi_tnsw_tmp));

  /* Processing variable sps_in */
    f2py_success = int_from_pyobj(&sps_in,sps_in_capi,"libadflow.settnswall() 2nd argument (sps_in) can't be converted to int");
  if (f2py_success) {
  /* Processing variable npts */
  if (npts_capi == Py_None) npts = len(tnsw); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.settnswall() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(tnsw)>=npts,"len(tnsw)>=npts","1st keyword npts","settnswall:npts=%d",npts) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(tnsw,&npts,&sps_in);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(tnsw)>=npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  } /*if (f2py_success) of sps_in*/
  /* End of cleaning variable sps_in */
  if((PyObject *)capi_tnsw_tmp!=tnsw_capi) {
    Py_XDECREF(capi_tnsw_tmp); }
  }  /*if (capi_tnsw_tmp == NULL) ... else of tnsw*/
  /* End of cleaning variable tnsw */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of settnswall *****************************/

/********************************* gettnswall *********************************/
static char doc_f2py_rout_libadflow_gettnswall[] = "\
tnsw = gettnswall(npts,sps)\n\nWrapper for ``gettnswall``.\
\n\nParameters\n----------\n"
"npts : input int\n"
"sps : input int\n"
"\nReturns\n-------\n"
"tnsw : rank-1 array('d') with bounds (npts)";
/* extern void F_FUNC(gettnswall,GETTNSWALL)(double*,int*,int*); */
static PyObject *f2py_rout_libadflow_gettnswall(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *tnsw = NULL;
  npy_intp tnsw_Dims[1] = {-1};
  const int tnsw_Rank = 1;
  PyArrayObject *capi_tnsw_tmp = NULL;
  int capi_tnsw_intent = 0;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps = 0;
  PyObject *sps_capi = Py_None;
    static char *capi_kwlist[] = {"npts","sps",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:libadflow.gettnswall",\
        capi_kwlist,&npts_capi,&sps_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable npts */
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.gettnswall() 1st argument (npts) can't be converted to int");
  if (f2py_success) {
  /* Processing variable sps */
    f2py_success = int_from_pyobj(&sps,sps_capi,"libadflow.gettnswall() 2nd argument (sps) can't be converted to int");
  if (f2py_success) {
  /* Processing variable tnsw */
  tnsw_Dims[0]=npts;
  capi_tnsw_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_tnsw_tmp = array_from_pyobj(NPY_DOUBLE,tnsw_Dims,tnsw_Rank,capi_tnsw_intent,Py_None);
  if (capi_tnsw_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `tnsw' of libadflow.gettnswall to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    tnsw = (double *)(PyArray_DATA(capi_tnsw_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(tnsw,&npts,&sps);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_tnsw_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_tnsw_tmp == NULL) ... else of tnsw*/
  /* End of cleaning variable tnsw */
  } /*if (f2py_success) of sps*/
  /* End of cleaning variable sps */
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of gettnswall *****************************/

/******************************** setcptargets ********************************/
static char doc_f2py_rout_libadflow_setcptargets[] = "\
setcptargets(cptarget,sps_in,[npts])\n\nWrapper for ``setcptargets``.\
\n\nParameters\n----------\n"
"cptarget : input rank-1 array('d') with bounds (npts)\n"
"sps_in : input int\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: len(cptarget)";
/* extern void F_FUNC(setcptargets,SETCPTARGETS)(double*,int*,int*); */
static PyObject *f2py_rout_libadflow_setcptargets(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *cptarget = NULL;
  npy_intp cptarget_Dims[1] = {-1};
  const int cptarget_Rank = 1;
  PyArrayObject *capi_cptarget_tmp = NULL;
  int capi_cptarget_intent = 0;
  PyObject *cptarget_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps_in = 0;
  PyObject *sps_in_capi = Py_None;
    static char *capi_kwlist[] = {"cptarget","sps_in","npts",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.setcptargets",\
        capi_kwlist,&cptarget_capi,&sps_in_capi,&npts_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable cptarget */
  ;
  capi_cptarget_intent |= F2PY_INTENT_IN;
  capi_cptarget_tmp = array_from_pyobj(NPY_DOUBLE,cptarget_Dims,cptarget_Rank,capi_cptarget_intent,cptarget_capi);
  if (capi_cptarget_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `cptarget' of libadflow.setcptargets to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    cptarget = (double *)(PyArray_DATA(capi_cptarget_tmp));

  /* Processing variable sps_in */
    f2py_success = int_from_pyobj(&sps_in,sps_in_capi,"libadflow.setcptargets() 2nd argument (sps_in) can't be converted to int");
  if (f2py_success) {
  /* Processing variable npts */
  if (npts_capi == Py_None) npts = len(cptarget); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.setcptargets() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(cptarget)>=npts,"len(cptarget)>=npts","1st keyword npts","setcptargets:npts=%d",npts) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(cptarget,&npts,&sps_in);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(cptarget)>=npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  } /*if (f2py_success) of sps_in*/
  /* End of cleaning variable sps_in */
  if((PyObject *)capi_cptarget_tmp!=cptarget_capi) {
    Py_XDECREF(capi_cptarget_tmp); }
  }  /*if (capi_cptarget_tmp == NULL) ... else of cptarget*/
  /* End of cleaning variable cptarget */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of setcptargets ****************************/

/******************************** getcptargets ********************************/
static char doc_f2py_rout_libadflow_getcptargets[] = "\
cptarget = getcptargets(npts,sps)\n\nWrapper for ``getcptargets``.\
\n\nParameters\n----------\n"
"npts : input int\n"
"sps : input int\n"
"\nReturns\n-------\n"
"cptarget : rank-1 array('d') with bounds (npts)";
/* extern void F_FUNC(getcptargets,GETCPTARGETS)(double*,int*,int*); */
static PyObject *f2py_rout_libadflow_getcptargets(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *cptarget = NULL;
  npy_intp cptarget_Dims[1] = {-1};
  const int cptarget_Rank = 1;
  PyArrayObject *capi_cptarget_tmp = NULL;
  int capi_cptarget_intent = 0;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps = 0;
  PyObject *sps_capi = Py_None;
    static char *capi_kwlist[] = {"npts","sps",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:libadflow.getcptargets",\
        capi_kwlist,&npts_capi,&sps_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable npts */
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.getcptargets() 1st argument (npts) can't be converted to int");
  if (f2py_success) {
  /* Processing variable sps */
    f2py_success = int_from_pyobj(&sps,sps_capi,"libadflow.getcptargets() 2nd argument (sps) can't be converted to int");
  if (f2py_success) {
  /* Processing variable cptarget */
  cptarget_Dims[0]=npts;
  capi_cptarget_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_cptarget_tmp = array_from_pyobj(NPY_DOUBLE,cptarget_Dims,cptarget_Rank,capi_cptarget_intent,Py_None);
  if (capi_cptarget_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `cptarget' of libadflow.getcptargets to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    cptarget = (double *)(PyArray_DATA(capi_cptarget_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(cptarget,&npts,&sps);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_cptarget_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_cptarget_tmp == NULL) ... else of cptarget*/
  /* End of cleaning variable cptarget */
  } /*if (f2py_success) of sps*/
  /* End of cleaning variable sps */
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of getcptargets ****************************/

/********************************** getareas **********************************/
static char doc_f2py_rout_libadflow_getareas[] = "\
areas = getareas(pts,sps_in,axis,[npts])\n\nWrapper for ``getareas``.\
\n\nParameters\n----------\n"
"pts : input rank-2 array('d') with bounds (3,npts)\n"
"sps_in : input int\n"
"axis : input rank-1 array('d') with bounds (3)\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: shape(pts,1)\n"
"\nReturns\n-------\n"
"areas : rank-2 array('d') with bounds (3,npts)";
/* extern void F_FUNC(getareas,GETAREAS)(double*,double*,int*,int*,double*); */
static PyObject *f2py_rout_libadflow_getareas(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *areas = NULL;
  npy_intp areas_Dims[2] = {-1, -1};
  const int areas_Rank = 2;
  PyArrayObject *capi_areas_tmp = NULL;
  int capi_areas_intent = 0;
  double *pts = NULL;
  npy_intp pts_Dims[2] = {-1, -1};
  const int pts_Rank = 2;
  PyArrayObject *capi_pts_tmp = NULL;
  int capi_pts_intent = 0;
  PyObject *pts_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps_in = 0;
  PyObject *sps_in_capi = Py_None;
  double *axis = NULL;
  npy_intp axis_Dims[1] = {-1};
  const int axis_Rank = 1;
  PyArrayObject *capi_axis_tmp = NULL;
  int capi_axis_intent = 0;
  PyObject *axis_capi = Py_None;
    static char *capi_kwlist[] = {"pts","sps_in","axis","npts",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|O:libadflow.getareas",\
        capi_kwlist,&pts_capi,&sps_in_capi,&axis_capi,&npts_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable pts */
  pts_Dims[0]=3;
  capi_pts_intent |= F2PY_INTENT_IN;
  capi_pts_tmp = array_from_pyobj(NPY_DOUBLE,pts_Dims,pts_Rank,capi_pts_intent,pts_capi);
  if (capi_pts_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `pts' of libadflow.getareas to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    pts = (double *)(PyArray_DATA(capi_pts_tmp));

  /* Processing variable sps_in */
    f2py_success = int_from_pyobj(&sps_in,sps_in_capi,"libadflow.getareas() 2nd argument (sps_in) can't be converted to int");
  if (f2py_success) {
  /* Processing variable axis */
  axis_Dims[0]=3;
  capi_axis_intent |= F2PY_INTENT_IN;
  capi_axis_tmp = array_from_pyobj(NPY_DOUBLE,axis_Dims,axis_Rank,capi_axis_intent,axis_capi);
  if (capi_axis_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `axis' of libadflow.getareas to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    axis = (double *)(PyArray_DATA(capi_axis_tmp));

  /* Processing variable npts */
  if (npts_capi == Py_None) npts = shape(pts,1); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.getareas() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(pts,1)==npts,"shape(pts,1)==npts","1st keyword npts","getareas:npts=%d",npts) {
  /* Processing variable areas */
  areas_Dims[0]=3,areas_Dims[1]=npts;
  capi_areas_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_areas_tmp = array_from_pyobj(NPY_DOUBLE,areas_Dims,areas_Rank,capi_areas_intent,Py_None);
  if (capi_areas_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `areas' of libadflow.getareas to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    areas = (double *)(PyArray_DATA(capi_areas_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(areas,pts,&npts,&sps_in,axis);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_areas_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_areas_tmp == NULL) ... else of areas*/
  /* End of cleaning variable areas */
  } /*CHECKSCALAR(shape(pts,1)==npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  if((PyObject *)capi_axis_tmp!=axis_capi) {
    Py_XDECREF(capi_axis_tmp); }
  }  /*if (capi_axis_tmp == NULL) ... else of axis*/
  /* End of cleaning variable axis */
  } /*if (f2py_success) of sps_in*/
  /* End of cleaning variable sps_in */
  if((PyObject *)capi_pts_tmp!=pts_capi) {
    Py_XDECREF(capi_pts_tmp); }
  }  /*if (capi_pts_tmp == NULL) ... else of pts*/
  /* End of cleaning variable pts */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of getareas ******************************/

/***************************** getareasensitivity *****************************/
static char doc_f2py_rout_libadflow_getareasensitivity[] = "\
darea = getareasensitivity(pts,sps_in,axis,[npts])\n\nWrapper for ``getareasensitivity``.\
\n\nParameters\n----------\n"
"pts : input rank-2 array('d') with bounds (3,npts)\n"
"sps_in : input int\n"
"axis : input rank-1 array('d') with bounds (3)\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: shape(pts,1)\n"
"\nReturns\n-------\n"
"darea : rank-2 array('d') with bounds (3,npts)";
/* extern void F_FUNC(getareasensitivity,GETAREASENSITIVITY)(double*,double*,int*,int*,double*); */
static PyObject *f2py_rout_libadflow_getareasensitivity(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *darea = NULL;
  npy_intp darea_Dims[2] = {-1, -1};
  const int darea_Rank = 2;
  PyArrayObject *capi_darea_tmp = NULL;
  int capi_darea_intent = 0;
  double *pts = NULL;
  npy_intp pts_Dims[2] = {-1, -1};
  const int pts_Rank = 2;
  PyArrayObject *capi_pts_tmp = NULL;
  int capi_pts_intent = 0;
  PyObject *pts_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps_in = 0;
  PyObject *sps_in_capi = Py_None;
  double *axis = NULL;
  npy_intp axis_Dims[1] = {-1};
  const int axis_Rank = 1;
  PyArrayObject *capi_axis_tmp = NULL;
  int capi_axis_intent = 0;
  PyObject *axis_capi = Py_None;
    static char *capi_kwlist[] = {"pts","sps_in","axis","npts",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|O:libadflow.getareasensitivity",\
        capi_kwlist,&pts_capi,&sps_in_capi,&axis_capi,&npts_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable pts */
  pts_Dims[0]=3;
  capi_pts_intent |= F2PY_INTENT_IN;
  capi_pts_tmp = array_from_pyobj(NPY_DOUBLE,pts_Dims,pts_Rank,capi_pts_intent,pts_capi);
  if (capi_pts_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `pts' of libadflow.getareasensitivity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    pts = (double *)(PyArray_DATA(capi_pts_tmp));

  /* Processing variable sps_in */
    f2py_success = int_from_pyobj(&sps_in,sps_in_capi,"libadflow.getareasensitivity() 2nd argument (sps_in) can't be converted to int");
  if (f2py_success) {
  /* Processing variable axis */
  axis_Dims[0]=3;
  capi_axis_intent |= F2PY_INTENT_IN;
  capi_axis_tmp = array_from_pyobj(NPY_DOUBLE,axis_Dims,axis_Rank,capi_axis_intent,axis_capi);
  if (capi_axis_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `axis' of libadflow.getareasensitivity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    axis = (double *)(PyArray_DATA(capi_axis_tmp));

  /* Processing variable npts */
  if (npts_capi == Py_None) npts = shape(pts,1); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.getareasensitivity() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(pts,1)==npts,"shape(pts,1)==npts","1st keyword npts","getareasensitivity:npts=%d",npts) {
  /* Processing variable darea */
  darea_Dims[0]=3,darea_Dims[1]=npts;
  capi_darea_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_darea_tmp = array_from_pyobj(NPY_DOUBLE,darea_Dims,darea_Rank,capi_darea_intent,Py_None);
  if (capi_darea_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `darea' of libadflow.getareasensitivity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    darea = (double *)(PyArray_DATA(capi_darea_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(darea,pts,&npts,&sps_in,axis);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_darea_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_darea_tmp == NULL) ... else of darea*/
  /* End of cleaning variable darea */
  } /*CHECKSCALAR(shape(pts,1)==npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  if((PyObject *)capi_axis_tmp!=axis_capi) {
    Py_XDECREF(capi_axis_tmp); }
  }  /*if (capi_axis_tmp == NULL) ... else of axis*/
  /* End of cleaning variable axis */
  } /*if (f2py_success) of sps_in*/
  /* End of cleaning variable sps_in */
  if((PyObject *)capi_pts_tmp!=pts_capi) {
    Py_XDECREF(capi_pts_tmp); }
  }  /*if (capi_pts_tmp == NULL) ... else of pts*/
  /* End of cleaning variable pts */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of getareasensitivity *************************/

/***************************** writeintromessage *****************************/
static char doc_f2py_rout_libadflow_utils_writeintromessage[] = "\
writeintromessage()\n\nWrapper for ``writeintromessage``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_utils_writeintromessage(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.utils.writeintromessage",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of writeintromessage **************************/

/*************************** getliftdirfromsymmetry ***************************/
static char doc_f2py_rout_libadflow_utils_getliftdirfromsymmetry[] = "\
liftdir = getliftdirfromsymmetry()\n\nWrapper for ``getliftdirfromsymmetry``.\
\n\nReturns\n-------\n"
"liftdir : int";
/*  */
static PyObject *f2py_rout_libadflow_utils_getliftdirfromsymmetry(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int liftdir = 0;
    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.utils.getliftdirfromsymmetry",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
  /* Processing variable liftdir */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&liftdir);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",liftdir);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable liftdir */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*********************** end of getliftdirfromsymmetry ***********************/

/****************************** allocconvarrays ******************************/
static char doc_f2py_rout_libadflow_utils_allocconvarrays[] = "\
allocconvarrays(nitertot)\n\nWrapper for ``allocconvarrays``.\
\n\nParameters\n----------\n"
"nitertot : input int";
/*  */
static PyObject *f2py_rout_libadflow_utils_allocconvarrays(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int nitertot = 0;
  PyObject *nitertot_capi = Py_None;
    static char *capi_kwlist[] = {"nitertot",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.utils.allocconvarrays",\
        capi_kwlist,&nitertot_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable nitertot */
    f2py_success = int_from_pyobj(&nitertot,nitertot_capi,"libadflow.utils.allocconvarrays() 1st argument (nitertot) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&nitertot);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of nitertot*/
  /* End of cleaning variable nitertot */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of allocconvarrays ***************************/

/****************************** alloctimearrays ******************************/
static char doc_f2py_rout_libadflow_utils_alloctimearrays[] = "\
alloctimearrays(nitertot)\n\nWrapper for ``alloctimearrays``.\
\n\nParameters\n----------\n"
"nitertot : input int";
/*  */
static PyObject *f2py_rout_libadflow_utils_alloctimearrays(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int nitertot = 0;
  PyObject *nitertot_capi = Py_None;
    static char *capi_kwlist[] = {"nitertot",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.utils.alloctimearrays",\
        capi_kwlist,&nitertot_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable nitertot */
    f2py_success = int_from_pyobj(&nitertot,nitertot_capi,"libadflow.utils.alloctimearrays() 1st argument (nitertot) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&nitertot);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of nitertot*/
  /* End of cleaning variable nitertot */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of alloctimearrays ***************************/

/******************************* unsteadyheader *******************************/
static char doc_f2py_rout_libadflow_utils_unsteadyheader[] = "\
unsteadyheader()\n\nWrapper for ``unsteadyheader``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_utils_unsteadyheader(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.utils.unsteadyheader",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of unsteadyheader ***************************/

/******************************** pointreduce ********************************/
static char doc_f2py_rout_libadflow_utils_pointreduce[] = "\
uniquepts,link,nunique = pointreduce(pts,tol,[n])\n\nWrapper for ``pointreduce``.\
\n\nParameters\n----------\n"
"pts : input rank-2 array('d') with bounds (3,n)\n"
"tol : input float\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: shape(pts,1)\n"
"\nReturns\n-------\n"
"uniquepts : rank-2 array('d') with bounds (3,n)\n"
"link : rank-1 array('i') with bounds (n)\n"
"nunique : int";
/*  */
static PyObject *f2py_rout_libadflow_utils_pointreduce(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *pts = NULL;
  npy_intp pts_Dims[2] = {-1, -1};
  const int pts_Rank = 2;
  PyArrayObject *capi_pts_tmp = NULL;
  int capi_pts_intent = 0;
  PyObject *pts_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  double tol = 0;
  PyObject *tol_capi = Py_None;
  double *uniquepts = NULL;
  npy_intp uniquepts_Dims[2] = {-1, -1};
  const int uniquepts_Rank = 2;
  PyArrayObject *capi_uniquepts_tmp = NULL;
  int capi_uniquepts_intent = 0;
  int *link = NULL;
  npy_intp link_Dims[1] = {-1};
  const int link_Rank = 1;
  PyArrayObject *capi_link_tmp = NULL;
  int capi_link_intent = 0;
  int nunique = 0;
    static char *capi_kwlist[] = {"pts","tol","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.utils.pointreduce",\
        capi_kwlist,&pts_capi,&tol_capi,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable pts */
  pts_Dims[0]=3;
  capi_pts_intent |= F2PY_INTENT_IN;
  capi_pts_tmp = array_from_pyobj(NPY_DOUBLE,pts_Dims,pts_Rank,capi_pts_intent,pts_capi);
  if (capi_pts_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `pts' of libadflow.utils.pointreduce to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    pts = (double *)(PyArray_DATA(capi_pts_tmp));

  /* Processing variable tol */
    f2py_success = double_from_pyobj(&tol,tol_capi,"libadflow.utils.pointreduce() 2nd argument (tol) can't be converted to double");
  if (f2py_success) {
  /* Processing variable nunique */
  /* Processing variable n */
  if (n_capi == Py_None) n = shape(pts,1); else
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.utils.pointreduce() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(pts,1)==n,"shape(pts,1)==n","1st keyword n","pointreduce:n=%d",n) {
  /* Processing variable uniquepts */
  uniquepts_Dims[0]=3,uniquepts_Dims[1]=n;
  capi_uniquepts_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_uniquepts_tmp = array_from_pyobj(NPY_DOUBLE,uniquepts_Dims,uniquepts_Rank,capi_uniquepts_intent,Py_None);
  if (capi_uniquepts_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `uniquepts' of libadflow.utils.pointreduce to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    uniquepts = (double *)(PyArray_DATA(capi_uniquepts_tmp));

  /* Processing variable link */
  link_Dims[0]=n;
  capi_link_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_link_tmp = array_from_pyobj(NPY_INT,link_Dims,link_Rank,capi_link_intent,Py_None);
  if (capi_link_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `link' of libadflow.utils.pointreduce to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    link = (int *)(PyArray_DATA(capi_link_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(pts,&n,&tol,uniquepts,link,&nunique);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("NNi",capi_uniquepts_tmp,capi_link_tmp,nunique);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_link_tmp == NULL) ... else of link*/
  /* End of cleaning variable link */
  }  /*if (capi_uniquepts_tmp == NULL) ... else of uniquepts*/
  /* End of cleaning variable uniquepts */
  } /*CHECKSCALAR(shape(pts,1)==n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  /* End of cleaning variable nunique */
  } /*if (f2py_success) of tol*/
  /* End of cleaning variable tol */
  if((PyObject *)capi_pts_tmp!=pts_capi) {
    Py_XDECREF(capi_pts_tmp); }
  }  /*if (capi_pts_tmp == NULL) ... else of pts*/
  /* End of cleaning variable pts */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of pointreduce *****************************/

/******************************* getcellcenters *******************************/
static char doc_f2py_rout_libadflow_utils_getcellcenters[] = "\
xcen = getcellcenters(level,n)\n\nWrapper for ``getcellcenters``.\
\n\nParameters\n----------\n"
"level : input int\n"
"n : input int\n"
"\nReturns\n-------\n"
"xcen : rank-2 array('d') with bounds (3,n)";
/*  */
static PyObject *f2py_rout_libadflow_utils_getcellcenters(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int level = 0;
  PyObject *level_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  double *xcen = NULL;
  npy_intp xcen_Dims[2] = {-1, -1};
  const int xcen_Rank = 2;
  PyArrayObject *capi_xcen_tmp = NULL;
  int capi_xcen_intent = 0;
    static char *capi_kwlist[] = {"level","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:libadflow.utils.getcellcenters",\
        capi_kwlist,&level_capi,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable level */
    f2py_success = int_from_pyobj(&level,level_capi,"libadflow.utils.getcellcenters() 1st argument (level) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.utils.getcellcenters() 2nd argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable xcen */
  xcen_Dims[0]=3,xcen_Dims[1]=n;
  capi_xcen_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_xcen_tmp = array_from_pyobj(NPY_DOUBLE,xcen_Dims,xcen_Rank,capi_xcen_intent,Py_None);
  if (capi_xcen_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `xcen' of libadflow.utils.getcellcenters to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    xcen = (double *)(PyArray_DATA(capi_xcen_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&level,&n,xcen);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_xcen_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_xcen_tmp == NULL) ... else of xcen*/
  /* End of cleaning variable xcen */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of level*/
  /* End of cleaning variable level */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of getcellcenters ***************************/

/**************************** getcellcgnsblockids ****************************/
static char doc_f2py_rout_libadflow_utils_getcellcgnsblockids[] = "\
cellid = getcellcgnsblockids(level,n)\n\nWrapper for ``getcellcgnsblockids``.\
\n\nParameters\n----------\n"
"level : input int\n"
"n : input int\n"
"\nReturns\n-------\n"
"cellid : rank-1 array('d') with bounds (n)";
/*  */
static PyObject *f2py_rout_libadflow_utils_getcellcgnsblockids(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int level = 0;
  PyObject *level_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  double *cellid = NULL;
  npy_intp cellid_Dims[1] = {-1};
  const int cellid_Rank = 1;
  PyArrayObject *capi_cellid_tmp = NULL;
  int capi_cellid_intent = 0;
    static char *capi_kwlist[] = {"level","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:libadflow.utils.getcellcgnsblockids",\
        capi_kwlist,&level_capi,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable level */
    f2py_success = int_from_pyobj(&level,level_capi,"libadflow.utils.getcellcgnsblockids() 1st argument (level) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.utils.getcellcgnsblockids() 2nd argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable cellid */
  cellid_Dims[0]=n;
  capi_cellid_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_cellid_tmp = array_from_pyobj(NPY_DOUBLE,cellid_Dims,cellid_Rank,capi_cellid_intent,Py_None);
  if (capi_cellid_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `cellid' of libadflow.utils.getcellcgnsblockids to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    cellid = (double *)(PyArray_DATA(capi_cellid_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&level,&n,cellid);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_cellid_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_cellid_tmp == NULL) ... else of cellid*/
  /* End of cleaning variable cellid */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of level*/
  /* End of cleaning variable level */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of getcellcgnsblockids *************************/

/******************************* getncgnszones *******************************/
static char doc_f2py_rout_libadflow_utils_getncgnszones[] = "\
nzones = getncgnszones()\n\nWrapper for ``getncgnszones``.\
\n\nReturns\n-------\n"
"nzones : int";
/*  */
static PyObject *f2py_rout_libadflow_utils_getncgnszones(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int nzones = 0;
    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.utils.getncgnszones",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
  /* Processing variable nzones */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&nzones);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",nzones);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable nzones */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of getncgnszones ****************************/

/****************************** getcgnszonename ******************************/
static char doc_f2py_rout_libadflow_utils_getcgnszonename[] = "\
zone = getcgnszonename(i)\n\nWrapper for ``getcgnszonename``.\
\n\nParameters\n----------\n"
"i : input int\n"
"\nReturns\n-------\n"
"zone : string(len=32)";
/*  */
static PyObject *f2py_rout_libadflow_utils_getcgnszonename(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int i = 0;
  PyObject *i_capi = Py_None;
  string zone = NULL;
  int slen(zone);
  PyObject *zone_capi = Py_None;
    static char *capi_kwlist[] = {"i",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.utils.getcgnszonename",\
        capi_kwlist,&i_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable i */
    f2py_success = int_from_pyobj(&i,i_capi,"libadflow.utils.getcgnszonename() 1st argument (i) can't be converted to int");
  if (f2py_success) {
  /* Processing variable zone */
  slen(zone) = 32;
  f2py_success = string_from_pyobj(&zone,&slen(zone),"",zone_capi,"string_from_pyobj failed in converting hidden `zone' of libadflow.utils.getcgnszonename to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&i,zone,slen(zone));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("y",zone);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(zone);
  }  /*if (f2py_success) of zone*/
  /* End of cleaning variable zone */
  } /*if (f2py_success) of i*/
  /* End of cleaning variable i */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of getcgnszonename ***************************/

/***************************** releasememorypart1 *****************************/
static char doc_f2py_rout_libadflow_utils_releasememorypart1[] = "\
releasememorypart1()\n\nWrapper for ``releasememorypart1``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_utils_releasememorypart1(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.utils.releasememorypart1",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of releasememorypart1 *************************/

/***************************** releasememorypart2 *****************************/
static char doc_f2py_rout_libadflow_utils_releasememorypart2[] = "\
releasememorypart2()\n\nWrapper for ``releasememorypart2``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_utils_releasememorypart2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.utils.releasememorypart2",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of releasememorypart2 *************************/

/************************ updatewalldistancealllevels ************************/
static char doc_f2py_rout_libadflow_walldistance_updatewalldistancealllevels[] = "\
updatewalldistancealllevels()\n\nWrapper for ``updatewalldistancealllevels``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_walldistance_updatewalldistancealllevels(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.walldistance.updatewalldistancealllevels",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************* end of updatewalldistancealllevels *********************/

/*************************** updatebcdataalllevels ***************************/
static char doc_f2py_rout_libadflow_initializeflow_updatebcdataalllevels[] = "\
updatebcdataalllevels()\n\nWrapper for ``updatebcdataalllevels``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_initializeflow_updatebcdataalllevels(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.initializeflow.updatebcdataalllevels",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of updatebcdataalllevels ************************/

/********************************** initflow **********************************/
static char doc_f2py_rout_libadflow_initializeflow_initflow[] = "\
initflow()\n\nWrapper for ``initflow``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_initializeflow_initflow(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.initializeflow.initflow",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of initflow ******************************/

/****************************** initflowrestart ******************************/
static char doc_f2py_rout_libadflow_initializeflow_initflowrestart[] = "\
initflowrestart()\n\nWrapper for ``initflowrestart``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_initializeflow_initflowrestart(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.initializeflow.initflowrestart",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of initflowrestart ***************************/

/******************************* setuniformflow *******************************/
static char doc_f2py_rout_libadflow_initializeflow_setuniformflow[] = "\
setuniformflow()\n\nWrapper for ``setuniformflow``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_initializeflow_setuniformflow(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.initializeflow.setuniformflow",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of setuniformflow ***************************/

/***************************** allocrestartfiles *****************************/
static char doc_f2py_rout_libadflow_initializeflow_allocrestartfiles[] = "\
allocrestartfiles(nfiles)\n\nWrapper for ``allocrestartfiles``.\
\n\nParameters\n----------\n"
"nfiles : input int";
/*  */
static PyObject *f2py_rout_libadflow_initializeflow_allocrestartfiles(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int nfiles = 0;
  PyObject *nfiles_capi = Py_None;
    static char *capi_kwlist[] = {"nfiles",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.initializeflow.allocrestartfiles",\
        capi_kwlist,&nfiles_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable nfiles */
    f2py_success = int_from_pyobj(&nfiles,nfiles_capi,"libadflow.initializeflow.allocrestartfiles() 1st argument (nfiles) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&nfiles);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of nfiles*/
  /* End of cleaning variable nfiles */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of allocrestartfiles **************************/

/****************************** setrestartfiles ******************************/
static char doc_f2py_rout_libadflow_initializeflow_setrestartfiles[] = "\
setrestartfiles(filename,i)\n\nWrapper for ``setrestartfiles``.\
\n\nParameters\n----------\n"
"filename : input string(len=-1)\n"
"i : input int";
/*  */
static PyObject *f2py_rout_libadflow_initializeflow_setrestartfiles(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
  int i = 0;
  PyObject *i_capi = Py_None;
    static char *capi_kwlist[] = {"filename","i",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:libadflow.initializeflow.setrestartfiles",\
        capi_kwlist,&filename_capi,&i_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 1st argument `filename' of libadflow.initializeflow.setrestartfiles to C string");
  if (f2py_success) {
  /* Processing variable i */
    f2py_success = int_from_pyobj(&i,i_capi,"libadflow.initializeflow.setrestartfiles() 2nd argument (i) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(filename,&i,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of i*/
  /* End of cleaning variable i */
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of setrestartfiles ***************************/

/**************************** infchangecorrection ****************************/
static char doc_f2py_rout_libadflow_initializeflow_infchangecorrection[] = "\
infchangecorrection(oldwinf)\n\nWrapper for ``infchangecorrection``.\
\n\nParameters\n----------\n"
"oldwinf : input rank-1 array('d') with bounds (5)";
/*  */
static PyObject *f2py_rout_libadflow_initializeflow_infchangecorrection(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *oldwinf = NULL;
  npy_intp oldwinf_Dims[1] = {-1};
  const int oldwinf_Rank = 1;
  PyArrayObject *capi_oldwinf_tmp = NULL;
  int capi_oldwinf_intent = 0;
  PyObject *oldwinf_capi = Py_None;
    static char *capi_kwlist[] = {"oldwinf",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.initializeflow.infchangecorrection",\
        capi_kwlist,&oldwinf_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable oldwinf */
  oldwinf_Dims[0]=5;
  capi_oldwinf_intent |= F2PY_INTENT_IN;
  capi_oldwinf_tmp = array_from_pyobj(NPY_DOUBLE,oldwinf_Dims,oldwinf_Rank,capi_oldwinf_intent,oldwinf_capi);
  if (capi_oldwinf_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `oldwinf' of libadflow.initializeflow.infchangecorrection to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    oldwinf = (double *)(PyArray_DATA(capi_oldwinf_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(oldwinf);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_oldwinf_tmp!=oldwinf_capi) {
    Py_XDECREF(capi_oldwinf_tmp); }
  }  /*if (capi_oldwinf_tmp == NULL) ... else of oldwinf*/
  /* End of cleaning variable oldwinf */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of infchangecorrection *************************/

/********************************* setbcdata *********************************/
static char doc_f2py_rout_libadflow_bcdata_setbcdata[] = "\
setbcdata(bcdatanamesin,bcdatain,famlists,sps,[nvar,nfammax])\n\nWrapper for ``setbcdata``.\
\n\nParameters\n----------\n"
"bcdatanamesin : input rank-2 array('S') with bounds (nvar,32)\n"
"bcdatain : input rank-1 array('d') with bounds (nvar)\n"
"famlists : input rank-2 array('i') with bounds (nvar,nfammax)\n"
"sps : input int\n"
"\nOther Parameters\n----------------\n"
"nvar : input int, optional\n    Default: shape(bcdatanamesin,0)\n"
"nfammax : input int, optional\n    Default: shape(famlists,1)";
/*  */
static PyObject *f2py_rout_libadflow_bcdata_setbcdata(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string*,double*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string *bcdatanamesin = NULL;
  npy_intp bcdatanamesin_Dims[2] = {-1, -1};
  const int bcdatanamesin_Rank = 2;
  PyArrayObject *capi_bcdatanamesin_tmp = NULL;
  int capi_bcdatanamesin_intent = 0;
  PyObject *bcdatanamesin_capi = Py_None;
  double *bcdatain = NULL;
  npy_intp bcdatain_Dims[1] = {-1};
  const int bcdatain_Rank = 1;
  PyArrayObject *capi_bcdatain_tmp = NULL;
  int capi_bcdatain_intent = 0;
  PyObject *bcdatain_capi = Py_None;
  int *famlists = NULL;
  npy_intp famlists_Dims[2] = {-1, -1};
  const int famlists_Rank = 2;
  PyArrayObject *capi_famlists_tmp = NULL;
  int capi_famlists_intent = 0;
  PyObject *famlists_capi = Py_None;
  int sps = 0;
  PyObject *sps_capi = Py_None;
  int nvar = 0;
  PyObject *nvar_capi = Py_None;
  int nfammax = 0;
  PyObject *nfammax_capi = Py_None;
    static char *capi_kwlist[] = {"bcdatanamesin","bcdatain","famlists","sps","nvar","nfammax",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|OO:libadflow.bcdata.setbcdata",\
        capi_kwlist,&bcdatanamesin_capi,&bcdatain_capi,&famlists_capi,&sps_capi,&nvar_capi,&nfammax_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable bcdatanamesin */
  bcdatanamesin_Dims[1]=32;
  capi_bcdatanamesin_intent |= F2PY_INTENT_IN;
  capi_bcdatanamesin_tmp = array_from_pyobj(NPY_STRING,bcdatanamesin_Dims,bcdatanamesin_Rank,capi_bcdatanamesin_intent,bcdatanamesin_capi);
  if (capi_bcdatanamesin_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `bcdatanamesin' of libadflow.bcdata.setbcdata to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatanamesin = (string *)(PyArray_DATA(capi_bcdatanamesin_tmp));

  /* Processing variable sps */
    f2py_success = int_from_pyobj(&sps,sps_capi,"libadflow.bcdata.setbcdata() 4th argument (sps) can't be converted to int");
  if (f2py_success) {
  /* Processing variable nvar */
  if (nvar_capi == Py_None) nvar = shape(bcdatanamesin,0); else
    f2py_success = int_from_pyobj(&nvar,nvar_capi,"libadflow.bcdata.setbcdata() 1st keyword (nvar) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(bcdatanamesin,0)==nvar,"shape(bcdatanamesin,0)==nvar","1st keyword nvar","setbcdata:nvar=%d",nvar) {
  /* Processing variable bcdatain */
  bcdatain_Dims[0]=nvar;
  capi_bcdatain_intent |= F2PY_INTENT_IN;
  capi_bcdatain_tmp = array_from_pyobj(NPY_DOUBLE,bcdatain_Dims,bcdatain_Rank,capi_bcdatain_intent,bcdatain_capi);
  if (capi_bcdatain_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `bcdatain' of libadflow.bcdata.setbcdata to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatain = (double *)(PyArray_DATA(capi_bcdatain_tmp));

  /* Processing variable famlists */
  famlists_Dims[0]=nvar;
  capi_famlists_intent |= F2PY_INTENT_IN;
  capi_famlists_tmp = array_from_pyobj(NPY_INT,famlists_Dims,famlists_Rank,capi_famlists_intent,famlists_capi);
  if (capi_famlists_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `famlists' of libadflow.bcdata.setbcdata to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlists = (int *)(PyArray_DATA(capi_famlists_tmp));

  /* Processing variable nfammax */
  if (nfammax_capi == Py_None) nfammax = shape(famlists,1); else
    f2py_success = int_from_pyobj(&nfammax,nfammax_capi,"libadflow.bcdata.setbcdata() 2nd keyword (nfammax) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(famlists,1)==nfammax,"shape(famlists,1)==nfammax","2nd keyword nfammax","setbcdata:nfammax=%d",nfammax) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(bcdatanamesin,bcdatain,famlists,&sps,&nvar,&nfammax);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(famlists,1)==nfammax)*/
  } /*if (f2py_success) of nfammax*/
  /* End of cleaning variable nfammax */
  if((PyObject *)capi_famlists_tmp!=famlists_capi) {
    Py_XDECREF(capi_famlists_tmp); }
  }  /*if (capi_famlists_tmp == NULL) ... else of famlists*/
  /* End of cleaning variable famlists */
  if((PyObject *)capi_bcdatain_tmp!=bcdatain_capi) {
    Py_XDECREF(capi_bcdatain_tmp); }
  }  /*if (capi_bcdatain_tmp == NULL) ... else of bcdatain*/
  /* End of cleaning variable bcdatain */
  } /*CHECKSCALAR(shape(bcdatanamesin,0)==nvar)*/
  } /*if (f2py_success) of nvar*/
  /* End of cleaning variable nvar */
  } /*if (f2py_success) of sps*/
  /* End of cleaning variable sps */
  if((PyObject *)capi_bcdatanamesin_tmp!=bcdatanamesin_capi) {
    Py_XDECREF(capi_bcdatanamesin_tmp); }
  }  /*if (capi_bcdatanamesin_tmp == NULL) ... else of bcdatanamesin*/
  /* End of cleaning variable bcdatanamesin */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of setbcdata ******************************/

/********************************* setupagmg *********************************/
static char doc_f2py_rout_libadflow_agmg_setupagmg[] = "\
setupagmg()\n\nWrapper for ``setupagmg``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_agmg_setupagmg(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.agmg.setupagmg",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of setupagmg ******************************/

/******************************** destroyagmg ********************************/
static char doc_f2py_rout_libadflow_agmg_destroyagmg[] = "\
destroyagmg()\n\nWrapper for ``destroyagmg``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_agmg_destroyagmg(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.agmg.destroyagmg",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of destroyagmg *****************************/

/******************************** updategamma ********************************/
static char doc_f2py_rout_libadflow_flowutils_updategamma[] = "\
updategamma()\n\nWrapper for ``updategamma``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_flowutils_updategamma(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.flowutils.updategamma",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of updategamma *****************************/

/***************************** adjustinflowangle *****************************/
static char doc_f2py_rout_libadflow_flowutils_adjustinflowangle[] = "\
adjustinflowangle()\n\nWrapper for ``adjustinflowangle``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_flowutils_adjustinflowangle(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.flowutils.adjustinflowangle",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of adjustinflowangle **************************/

/****************************** setdefaultvalues ******************************/
static char doc_f2py_rout_libadflow_inputparamroutines_setdefaultvalues[] = "\
setdefaultvalues()\n\nWrapper for ``setdefaultvalues``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_setdefaultvalues(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.inputparamroutines.setdefaultvalues",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of setdefaultvalues **************************/

/****************************** monitorvariables ******************************/
static char doc_f2py_rout_libadflow_inputparamroutines_monitorvariables[] = "\
monitorvariables(variables)\n\nWrapper for ``monitorvariables``.\
\n\nParameters\n----------\n"
"variables : in/output rank-0 array(string(len=-1),'c')";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_monitorvariables(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string variables = NULL;
  int slen(variables);
  PyObject *variables_capi = Py_None;
    static char *capi_kwlist[] = {"variables",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.inputparamroutines.monitorvariables",\
        capi_kwlist,&variables_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable variables */
  slen(variables) = -1;
  f2py_success = string_from_pyobj(&variables,&slen(variables),"",variables_capi,"string_from_pyobj failed in converting 1st argument `variables' of libadflow.inputparamroutines.monitorvariables to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(variables,slen(variables));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_string(variables_capi,variables);
  if (f2py_success) {
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
  } /*if (f2py_success) of variables pyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(variables);
  }  /*if (f2py_success) of variables*/
  /* End of cleaning variable variables */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of monitorvariables **************************/

/****************************** surfacevariables ******************************/
static char doc_f2py_rout_libadflow_inputparamroutines_surfacevariables[] = "\
surfacevariables(variables)\n\nWrapper for ``surfacevariables``.\
\n\nParameters\n----------\n"
"variables : in/output rank-0 array(string(len=-1),'c')";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_surfacevariables(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string variables = NULL;
  int slen(variables);
  PyObject *variables_capi = Py_None;
    static char *capi_kwlist[] = {"variables",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.inputparamroutines.surfacevariables",\
        capi_kwlist,&variables_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable variables */
  slen(variables) = -1;
  f2py_success = string_from_pyobj(&variables,&slen(variables),"",variables_capi,"string_from_pyobj failed in converting 1st argument `variables' of libadflow.inputparamroutines.surfacevariables to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(variables,slen(variables));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_string(variables_capi,variables);
  if (f2py_success) {
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
  } /*if (f2py_success) of variables pyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(variables);
  }  /*if (f2py_success) of variables*/
  /* End of cleaning variable variables */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of surfacevariables **************************/

/****************************** volumevariables ******************************/
static char doc_f2py_rout_libadflow_inputparamroutines_volumevariables[] = "\
volumevariables(variables)\n\nWrapper for ``volumevariables``.\
\n\nParameters\n----------\n"
"variables : in/output rank-0 array(string(len=-1),'c')";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_volumevariables(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string variables = NULL;
  int slen(variables);
  PyObject *variables_capi = Py_None;
    static char *capi_kwlist[] = {"variables",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.inputparamroutines.volumevariables",\
        capi_kwlist,&variables_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable variables */
  slen(variables) = -1;
  f2py_success = string_from_pyobj(&variables,&slen(variables),"",variables_capi,"string_from_pyobj failed in converting 1st argument `variables' of libadflow.inputparamroutines.volumevariables to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(variables,slen(variables));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_string(variables_capi,variables);
  if (f2py_success) {
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
  } /*if (f2py_success) of variables pyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(variables);
  }  /*if (f2py_success) of variables*/
  /* End of cleaning variable variables */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of volumevariables ***************************/

/******************************** isovariables ********************************/
static char doc_f2py_rout_libadflow_inputparamroutines_isovariables[] = "\
isovariables(variables)\n\nWrapper for ``isovariables``.\
\n\nParameters\n----------\n"
"variables : in/output rank-0 array(string(len=-1),'c')";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_isovariables(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string variables = NULL;
  int slen(variables);
  PyObject *variables_capi = Py_None;
    static char *capi_kwlist[] = {"variables",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.inputparamroutines.isovariables",\
        capi_kwlist,&variables_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable variables */
  slen(variables) = -1;
  f2py_success = string_from_pyobj(&variables,&slen(variables),"",variables_capi,"string_from_pyobj failed in converting 1st argument `variables' of libadflow.inputparamroutines.isovariables to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(variables,slen(variables));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_string(variables_capi,variables);
  if (f2py_success) {
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
  } /*if (f2py_success) of variables pyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(variables);
  }  /*if (f2py_success) of variables*/
  /* End of cleaning variable variables */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of isovariables ****************************/

/*********************** initializeisosurfacevariables ***********************/
static char doc_f2py_rout_libadflow_inputparamroutines_initializeisosurfacevariables[] = "\
initializeisosurfacevariables(values,[nvalues])\n\nWrapper for ``initializeisosurfacevariables``.\
\n\nParameters\n----------\n"
"values : input rank-1 array('d') with bounds (nvalues)\n"
"\nOther Parameters\n----------------\n"
"nvalues : input int, optional\n    Default: len(values)";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_initializeisosurfacevariables(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *values = NULL;
  npy_intp values_Dims[1] = {-1};
  const int values_Rank = 1;
  PyArrayObject *capi_values_tmp = NULL;
  int capi_values_intent = 0;
  PyObject *values_capi = Py_None;
  int nvalues = 0;
  PyObject *nvalues_capi = Py_None;
    static char *capi_kwlist[] = {"values","nvalues",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:libadflow.inputparamroutines.initializeisosurfacevariables",\
        capi_kwlist,&values_capi,&nvalues_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable values */
  ;
  capi_values_intent |= F2PY_INTENT_IN;
  capi_values_tmp = array_from_pyobj(NPY_DOUBLE,values_Dims,values_Rank,capi_values_intent,values_capi);
  if (capi_values_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `values' of libadflow.inputparamroutines.initializeisosurfacevariables to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    values = (double *)(PyArray_DATA(capi_values_tmp));

  /* Processing variable nvalues */
  if (nvalues_capi == Py_None) nvalues = len(values); else
    f2py_success = int_from_pyobj(&nvalues,nvalues_capi,"libadflow.inputparamroutines.initializeisosurfacevariables() 1st keyword (nvalues) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(values)>=nvalues,"len(values)>=nvalues","1st keyword nvalues","initializeisosurfacevariables:nvalues=%d",nvalues) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(values,&nvalues);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(values)>=nvalues)*/
  } /*if (f2py_success) of nvalues*/
  /* End of cleaning variable nvalues */
  if((PyObject *)capi_values_tmp!=values_capi) {
    Py_XDECREF(capi_values_tmp); }
  }  /*if (capi_values_tmp == NULL) ... else of values*/
  /* End of cleaning variable values */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************** end of initializeisosurfacevariables ********************/

/*************************** setisosurfacevariable ***************************/
static char doc_f2py_rout_libadflow_inputparamroutines_setisosurfacevariable[] = "\
setisosurfacevariable(variable,ivar)\n\nWrapper for ``setisosurfacevariable``.\
\n\nParameters\n----------\n"
"variable : input string(len=-1)\n"
"ivar : input int";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_setisosurfacevariable(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string variable = NULL;
  int slen(variable);
  PyObject *variable_capi = Py_None;
  int ivar = 0;
  PyObject *ivar_capi = Py_None;
    static char *capi_kwlist[] = {"variable","ivar",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:libadflow.inputparamroutines.setisosurfacevariable",\
        capi_kwlist,&variable_capi,&ivar_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable variable */
  slen(variable) = -1;
  f2py_success = string_from_pyobj(&variable,&slen(variable),"",variable_capi,"string_from_pyobj failed in converting 1st argument `variable' of libadflow.inputparamroutines.setisosurfacevariable to C string");
  if (f2py_success) {
  /* Processing variable ivar */
    f2py_success = int_from_pyobj(&ivar,ivar_capi,"libadflow.inputparamroutines.setisosurfacevariable() 2nd argument (ivar) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(variable,&ivar,slen(variable));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of ivar*/
  /* End of cleaning variable ivar */
    STRINGFREE(variable);
  }  /*if (f2py_success) of variable*/
  /* End of cleaning variable variable */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of setisosurfacevariable ************************/

/***************************** dummyreadparamfile *****************************/
static char doc_f2py_rout_libadflow_inputparamroutines_dummyreadparamfile[] = "\
dummyreadparamfile()\n\nWrapper for ``dummyreadparamfile``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_inputparamroutines_dummyreadparamfile(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.inputparamroutines.dummyreadparamfile",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of dummyreadparamfile *************************/

/********************************* getstates *********************************/
static char doc_f2py_rout_libadflow_nksolver_getstates[] = "\
states = getstates(ndimw)\n\nWrapper for ``getstates``.\
\n\nParameters\n----------\n"
"ndimw : input int\n"
"\nReturns\n-------\n"
"states : rank-1 array('d') with bounds (ndimw)";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_getstates(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *states = NULL;
  npy_intp states_Dims[1] = {-1};
  const int states_Rank = 1;
  PyArrayObject *capi_states_tmp = NULL;
  int capi_states_intent = 0;
  int ndimw = 0;
  PyObject *ndimw_capi = Py_None;
    static char *capi_kwlist[] = {"ndimw",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.nksolver.getstates",\
        capi_kwlist,&ndimw_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable ndimw */
    f2py_success = int_from_pyobj(&ndimw,ndimw_capi,"libadflow.nksolver.getstates() 1st argument (ndimw) can't be converted to int");
  if (f2py_success) {
  /* Processing variable states */
  states_Dims[0]=ndimw;
  capi_states_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_states_tmp = array_from_pyobj(NPY_DOUBLE,states_Dims,states_Rank,capi_states_intent,Py_None);
  if (capi_states_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `states' of libadflow.nksolver.getstates to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    states = (double *)(PyArray_DATA(capi_states_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(states,&ndimw);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_states_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_states_tmp == NULL) ... else of states*/
  /* End of cleaning variable states */
  } /*if (f2py_success) of ndimw*/
  /* End of cleaning variable ndimw */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of getstates ******************************/

/********************************* setstates *********************************/
static char doc_f2py_rout_libadflow_nksolver_setstates[] = "\
setstates(states,[ndimw])\n\nWrapper for ``setstates``.\
\n\nParameters\n----------\n"
"states : input rank-1 array('d') with bounds (ndimw)\n"
"\nOther Parameters\n----------------\n"
"ndimw : input int, optional\n    Default: len(states)";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_setstates(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *states = NULL;
  npy_intp states_Dims[1] = {-1};
  const int states_Rank = 1;
  PyArrayObject *capi_states_tmp = NULL;
  int capi_states_intent = 0;
  PyObject *states_capi = Py_None;
  int ndimw = 0;
  PyObject *ndimw_capi = Py_None;
    static char *capi_kwlist[] = {"states","ndimw",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:libadflow.nksolver.setstates",\
        capi_kwlist,&states_capi,&ndimw_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable states */
  ;
  capi_states_intent |= F2PY_INTENT_IN;
  capi_states_tmp = array_from_pyobj(NPY_DOUBLE,states_Dims,states_Rank,capi_states_intent,states_capi);
  if (capi_states_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `states' of libadflow.nksolver.setstates to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    states = (double *)(PyArray_DATA(capi_states_tmp));

  /* Processing variable ndimw */
  if (ndimw_capi == Py_None) ndimw = len(states); else
    f2py_success = int_from_pyobj(&ndimw,ndimw_capi,"libadflow.nksolver.setstates() 1st keyword (ndimw) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(states)>=ndimw,"len(states)>=ndimw","1st keyword ndimw","setstates:ndimw=%d",ndimw) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(states,&ndimw);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(states)>=ndimw)*/
  } /*if (f2py_success) of ndimw*/
  /* End of cleaning variable ndimw */
  if((PyObject *)capi_states_tmp!=states_capi) {
    Py_XDECREF(capi_states_tmp); }
  }  /*if (capi_states_tmp == NULL) ... else of states*/
  /* End of cleaning variable states */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of setstates ******************************/

/******************************** getinfosize ********************************/
static char doc_f2py_rout_libadflow_nksolver_getinfosize[] = "\
isize = getinfosize()\n\nWrapper for ``getinfosize``.\
\n\nReturns\n-------\n"
"isize : int";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_getinfosize(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int isize = 0;
    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.nksolver.getinfosize",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
  /* Processing variable isize */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&isize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",isize);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable isize */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of getinfosize *****************************/

/********************************** setinfo **********************************/
static char doc_f2py_rout_libadflow_nksolver_setinfo[] = "\
setinfo(info,[isize])\n\nWrapper for ``setinfo``.\
\n\nParameters\n----------\n"
"info : input rank-1 array('d') with bounds (isize)\n"
"\nOther Parameters\n----------------\n"
"isize : input int, optional\n    Default: len(info)";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_setinfo(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *info = NULL;
  npy_intp info_Dims[1] = {-1};
  const int info_Rank = 1;
  PyArrayObject *capi_info_tmp = NULL;
  int capi_info_intent = 0;
  PyObject *info_capi = Py_None;
  int isize = 0;
  PyObject *isize_capi = Py_None;
    static char *capi_kwlist[] = {"info","isize",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:libadflow.nksolver.setinfo",\
        capi_kwlist,&info_capi,&isize_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable info */
  ;
  capi_info_intent |= F2PY_INTENT_IN;
  capi_info_tmp = array_from_pyobj(NPY_DOUBLE,info_Dims,info_Rank,capi_info_intent,info_capi);
  if (capi_info_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `info' of libadflow.nksolver.setinfo to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    info = (double *)(PyArray_DATA(capi_info_tmp));

  /* Processing variable isize */
  if (isize_capi == Py_None) isize = len(info); else
    f2py_success = int_from_pyobj(&isize,isize_capi,"libadflow.nksolver.setinfo() 1st keyword (isize) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(info)>=isize,"len(info)>=isize","1st keyword isize","setinfo:isize=%d",isize) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(info,&isize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(info)>=isize)*/
  } /*if (f2py_success) of isize*/
  /* End of cleaning variable isize */
  if((PyObject *)capi_info_tmp!=info_capi) {
    Py_XDECREF(capi_info_tmp); }
  }  /*if (capi_info_tmp == NULL) ... else of info*/
  /* End of cleaning variable info */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of setinfo *******************************/

/********************************** getinfo **********************************/
static char doc_f2py_rout_libadflow_nksolver_getinfo[] = "\
info = getinfo(isize)\n\nWrapper for ``getinfo``.\
\n\nParameters\n----------\n"
"isize : input int\n"
"\nReturns\n-------\n"
"info : rank-1 array('d') with bounds (isize)";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_getinfo(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *info = NULL;
  npy_intp info_Dims[1] = {-1};
  const int info_Rank = 1;
  PyArrayObject *capi_info_tmp = NULL;
  int capi_info_intent = 0;
  int isize = 0;
  PyObject *isize_capi = Py_None;
    static char *capi_kwlist[] = {"isize",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.nksolver.getinfo",\
        capi_kwlist,&isize_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable isize */
    f2py_success = int_from_pyobj(&isize,isize_capi,"libadflow.nksolver.getinfo() 1st argument (isize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable info */
  info_Dims[0]=isize;
  capi_info_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_info_tmp = array_from_pyobj(NPY_DOUBLE,info_Dims,info_Rank,capi_info_intent,Py_None);
  if (capi_info_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `info' of libadflow.nksolver.getinfo to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    info = (double *)(PyArray_DATA(capi_info_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(info,&isize);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_info_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_info_tmp == NULL) ... else of info*/
  /* End of cleaning variable info */
  } /*if (f2py_success) of isize*/
  /* End of cleaning variable isize */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of getinfo *******************************/

/*********************************** getres ***********************************/
static char doc_f2py_rout_libadflow_nksolver_getres[] = "\
res = getres(res,[ndimw])\n\nWrapper for ``getres``.\
\n\nParameters\n----------\n"
"res : input rank-1 array('d') with bounds (ndimw)\n"
"\nOther Parameters\n----------------\n"
"ndimw : input int, optional\n    Default: len(res)\n"
"\nReturns\n-------\n"
"res : rank-1 array('d') with bounds (ndimw)";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_getres(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *res = NULL;
  npy_intp res_Dims[1] = {-1};
  const int res_Rank = 1;
  PyArrayObject *capi_res_tmp = NULL;
  int capi_res_intent = 0;
  PyObject *res_capi = Py_None;
  int ndimw = 0;
  PyObject *ndimw_capi = Py_None;
    static char *capi_kwlist[] = {"res","ndimw",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:libadflow.nksolver.getres",\
        capi_kwlist,&res_capi,&ndimw_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable res */
  ;
  capi_res_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT;
  capi_res_tmp = array_from_pyobj(NPY_DOUBLE,res_Dims,res_Rank,capi_res_intent,res_capi);
  if (capi_res_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `res' of libadflow.nksolver.getres to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    res = (double *)(PyArray_DATA(capi_res_tmp));

  /* Processing variable ndimw */
  if (ndimw_capi == Py_None) ndimw = len(res); else
    f2py_success = int_from_pyobj(&ndimw,ndimw_capi,"libadflow.nksolver.getres() 1st keyword (ndimw) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(res)>=ndimw,"len(res)>=ndimw","1st keyword ndimw","getres:ndimw=%d",ndimw) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(res,&ndimw);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_res_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(res)>=ndimw)*/
  } /*if (f2py_success) of ndimw*/
  /* End of cleaning variable ndimw */
  }  /*if (capi_res_tmp == NULL) ... else of res*/
  /* End of cleaning variable res */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of getres *******************************/

/********************************** applypc **********************************/
static char doc_f2py_rout_libadflow_nksolver_applypc[] = "\
out_vec = applypc(in_vec,out_vec,[ndof])\n\nWrapper for ``applypc``.\
\n\nParameters\n----------\n"
"in_vec : input rank-1 array('d') with bounds (ndof)\n"
"out_vec : input rank-1 array('d') with bounds (ndof)\n"
"\nOther Parameters\n----------------\n"
"ndof : input int, optional\n    Default: len(in_vec)\n"
"\nReturns\n-------\n"
"out_vec : rank-1 array('d') with bounds (ndof)";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_applypc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *in_vec = NULL;
  npy_intp in_vec_Dims[1] = {-1};
  const int in_vec_Rank = 1;
  PyArrayObject *capi_in_vec_tmp = NULL;
  int capi_in_vec_intent = 0;
  PyObject *in_vec_capi = Py_None;
  double *out_vec = NULL;
  npy_intp out_vec_Dims[1] = {-1};
  const int out_vec_Rank = 1;
  PyArrayObject *capi_out_vec_tmp = NULL;
  int capi_out_vec_intent = 0;
  PyObject *out_vec_capi = Py_None;
  int ndof = 0;
  PyObject *ndof_capi = Py_None;
    static char *capi_kwlist[] = {"in_vec","out_vec","ndof",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.nksolver.applypc",\
        capi_kwlist,&in_vec_capi,&out_vec_capi,&ndof_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable in_vec */
  ;
  capi_in_vec_intent |= F2PY_INTENT_IN;
  capi_in_vec_tmp = array_from_pyobj(NPY_DOUBLE,in_vec_Dims,in_vec_Rank,capi_in_vec_intent,in_vec_capi);
  if (capi_in_vec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `in_vec' of libadflow.nksolver.applypc to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    in_vec = (double *)(PyArray_DATA(capi_in_vec_tmp));

  /* Processing variable ndof */
  if (ndof_capi == Py_None) ndof = len(in_vec); else
    f2py_success = int_from_pyobj(&ndof,ndof_capi,"libadflow.nksolver.applypc() 1st keyword (ndof) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(in_vec)>=ndof,"len(in_vec)>=ndof","1st keyword ndof","applypc:ndof=%d",ndof) {
  /* Processing variable out_vec */
  out_vec_Dims[0]=ndof;
  capi_out_vec_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT;
  capi_out_vec_tmp = array_from_pyobj(NPY_DOUBLE,out_vec_Dims,out_vec_Rank,capi_out_vec_intent,out_vec_capi);
  if (capi_out_vec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `out_vec' of libadflow.nksolver.applypc to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    out_vec = (double *)(PyArray_DATA(capi_out_vec_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(in_vec,out_vec,&ndof);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_out_vec_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_out_vec_tmp == NULL) ... else of out_vec*/
  /* End of cleaning variable out_vec */
  } /*CHECKSCALAR(len(in_vec)>=ndof)*/
  } /*if (f2py_success) of ndof*/
  /* End of cleaning variable ndof */
  if((PyObject *)capi_in_vec_tmp!=in_vec_capi) {
    Py_XDECREF(capi_in_vec_tmp); }
  }  /*if (capi_in_vec_tmp == NULL) ... else of in_vec*/
  /* End of cleaning variable in_vec */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of applypc *******************************/

/******************************* applyadjointpc *******************************/
static char doc_f2py_rout_libadflow_nksolver_applyadjointpc[] = "\
out_vec = applyadjointpc(in_vec,out_vec,[ndof])\n\nWrapper for ``applyadjointpc``.\
\n\nParameters\n----------\n"
"in_vec : input rank-1 array('d') with bounds (ndof)\n"
"out_vec : input rank-1 array('d') with bounds (ndof)\n"
"\nOther Parameters\n----------------\n"
"ndof : input int, optional\n    Default: len(in_vec)\n"
"\nReturns\n-------\n"
"out_vec : rank-1 array('d') with bounds (ndof)";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_applyadjointpc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *in_vec = NULL;
  npy_intp in_vec_Dims[1] = {-1};
  const int in_vec_Rank = 1;
  PyArrayObject *capi_in_vec_tmp = NULL;
  int capi_in_vec_intent = 0;
  PyObject *in_vec_capi = Py_None;
  double *out_vec = NULL;
  npy_intp out_vec_Dims[1] = {-1};
  const int out_vec_Rank = 1;
  PyArrayObject *capi_out_vec_tmp = NULL;
  int capi_out_vec_intent = 0;
  PyObject *out_vec_capi = Py_None;
  int ndof = 0;
  PyObject *ndof_capi = Py_None;
    static char *capi_kwlist[] = {"in_vec","out_vec","ndof",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.nksolver.applyadjointpc",\
        capi_kwlist,&in_vec_capi,&out_vec_capi,&ndof_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable in_vec */
  ;
  capi_in_vec_intent |= F2PY_INTENT_IN;
  capi_in_vec_tmp = array_from_pyobj(NPY_DOUBLE,in_vec_Dims,in_vec_Rank,capi_in_vec_intent,in_vec_capi);
  if (capi_in_vec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `in_vec' of libadflow.nksolver.applyadjointpc to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    in_vec = (double *)(PyArray_DATA(capi_in_vec_tmp));

  /* Processing variable ndof */
  if (ndof_capi == Py_None) ndof = len(in_vec); else
    f2py_success = int_from_pyobj(&ndof,ndof_capi,"libadflow.nksolver.applyadjointpc() 1st keyword (ndof) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(in_vec)>=ndof,"len(in_vec)>=ndof","1st keyword ndof","applyadjointpc:ndof=%d",ndof) {
  /* Processing variable out_vec */
  out_vec_Dims[0]=ndof;
  capi_out_vec_intent |= F2PY_INTENT_IN|F2PY_INTENT_OUT;
  capi_out_vec_tmp = array_from_pyobj(NPY_DOUBLE,out_vec_Dims,out_vec_Rank,capi_out_vec_intent,out_vec_capi);
  if (capi_out_vec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `out_vec' of libadflow.nksolver.applyadjointpc to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    out_vec = (double *)(PyArray_DATA(capi_out_vec_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(in_vec,out_vec,&ndof);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_out_vec_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_out_vec_tmp == NULL) ... else of out_vec*/
  /* End of cleaning variable out_vec */
  } /*CHECKSCALAR(len(in_vec)>=ndof)*/
  } /*if (f2py_success) of ndof*/
  /* End of cleaning variable ndof */
  if((PyObject *)capi_in_vec_tmp!=in_vec_capi) {
    Py_XDECREF(capi_in_vec_tmp); }
  }  /*if (capi_in_vec_tmp == NULL) ... else of in_vec*/
  /* End of cleaning variable in_vec */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of applyadjointpc ***************************/

/****************************** destroynksolver ******************************/
static char doc_f2py_rout_libadflow_nksolver_destroynksolver[] = "\
destroynksolver()\n\nWrapper for ``destroynksolver``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_destroynksolver(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.nksolver.destroynksolver",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of destroynksolver ***************************/

/*************************** getfreestreamresidual ***************************/
static char doc_f2py_rout_libadflow_nksolver_getfreestreamresidual[] = "\
rhores,totalrres = getfreestreamresidual()\n\nWrapper for ``getfreestreamresidual``.\
\n\nReturns\n-------\n"
"rhores : float\n"
"totalrres : float";
/*  */
static PyObject *f2py_rout_libadflow_nksolver_getfreestreamresidual(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double rhores = 0;
  double totalrres = 0;
    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.nksolver.getfreestreamresidual",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
  /* Processing variable rhores */
  /* Processing variable totalrres */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&rhores,&totalrres);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("dd",rhores,totalrres);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable totalrres */
  /* End of cleaning variable rhores */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of getfreestreamresidual ************************/

/****************************** destroyanksolver ******************************/
static char doc_f2py_rout_libadflow_anksolver_destroyanksolver[] = "\
destroyanksolver()\n\nWrapper for ``destroyanksolver``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_anksolver_destroyanksolver(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.anksolver.destroyanksolver",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of destroyanksolver **************************/

/**************************** partitionandreadgrid ****************************/
static char doc_f2py_rout_libadflow_partitioning_partitionandreadgrid[] = "\
partitionandreadgrid(partitiononly)\n\nWrapper for ``partitionandreadgrid``.\
\n\nParameters\n----------\n"
"partitiononly : input int";
/*  */
static PyObject *f2py_rout_libadflow_partitioning_partitionandreadgrid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int partitiononly = 0;
  PyObject *partitiononly_capi = Py_None;
    static char *capi_kwlist[] = {"partitiononly",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.partitioning.partitionandreadgrid",\
        capi_kwlist,&partitiononly_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable partitiononly */
    partitiononly = (int)PyObject_IsTrue(partitiononly_capi);
    f2py_success = 1;
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&partitiononly);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of partitiononly*/
  /* End of cleaning variable partitiononly */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of partitionandreadgrid ************************/

/***************************** checkpartitioning *****************************/
static char doc_f2py_rout_libadflow_partitioning_checkpartitioning[] = "\
load_inbalance,face_inbalance = checkpartitioning(np)\n\nWrapper for ``checkpartitioning``.\
\n\nParameters\n----------\n"
"np : input int\n"
"\nReturns\n-------\n"
"load_inbalance : float\n"
"face_inbalance : float";
/*  */
static PyObject *f2py_rout_libadflow_partitioning_checkpartitioning(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int np = 0;
  PyObject *np_capi = Py_None;
  double load_inbalance = 0;
  double face_inbalance = 0;
    static char *capi_kwlist[] = {"np",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.partitioning.checkpartitioning",\
        capi_kwlist,&np_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable np */
    f2py_success = int_from_pyobj(&np,np_capi,"libadflow.partitioning.checkpartitioning() 1st argument (np) can't be converted to int");
  if (f2py_success) {
  /* Processing variable load_inbalance */
  /* Processing variable face_inbalance */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&np,&load_inbalance,&face_inbalance);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("dd",load_inbalance,face_inbalance);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable face_inbalance */
  /* End of cleaning variable load_inbalance */
  } /*if (f2py_success) of np*/
  /* End of cleaning variable np */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of checkpartitioning **************************/

/***************************** getcgnsmeshindices *****************************/
static char doc_f2py_rout_libadflow_warping_getcgnsmeshindices[] = "\
indices = getcgnsmeshindices(ndof)\n\nWrapper for ``getcgnsmeshindices``.\
\n\nParameters\n----------\n"
"ndof : input int\n"
"\nReturns\n-------\n"
"indices : rank-1 array('i') with bounds (ndof)";
/*  */
static PyObject *f2py_rout_libadflow_warping_getcgnsmeshindices(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int ndof = 0;
  PyObject *ndof_capi = Py_None;
  int *indices = NULL;
  npy_intp indices_Dims[1] = {-1};
  const int indices_Rank = 1;
  PyArrayObject *capi_indices_tmp = NULL;
  int capi_indices_intent = 0;
    static char *capi_kwlist[] = {"ndof",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.warping.getcgnsmeshindices",\
        capi_kwlist,&ndof_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable ndof */
    f2py_success = int_from_pyobj(&ndof,ndof_capi,"libadflow.warping.getcgnsmeshindices() 1st argument (ndof) can't be converted to int");
  if (f2py_success) {
  /* Processing variable indices */
  indices_Dims[0]=ndof;
  capi_indices_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_indices_tmp = array_from_pyobj(NPY_INT,indices_Dims,indices_Rank,capi_indices_intent,Py_None);
  if (capi_indices_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `indices' of libadflow.warping.getcgnsmeshindices to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    indices = (int *)(PyArray_DATA(capi_indices_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&ndof,indices);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_indices_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_indices_tmp == NULL) ... else of indices*/
  /* End of cleaning variable indices */
  } /*if (f2py_success) of ndof*/
  /* End of cleaning variable ndof */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of getcgnsmeshindices *************************/

/********************************** setgrid **********************************/
static char doc_f2py_rout_libadflow_warping_setgrid[] = "\
setgrid(grid,[ndof])\n\nWrapper for ``setgrid``.\
\n\nParameters\n----------\n"
"grid : input rank-1 array('d') with bounds (ndof)\n"
"\nOther Parameters\n----------------\n"
"ndof : input int, optional\n    Default: len(grid)";
/*  */
static PyObject *f2py_rout_libadflow_warping_setgrid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *grid = NULL;
  npy_intp grid_Dims[1] = {-1};
  const int grid_Rank = 1;
  PyArrayObject *capi_grid_tmp = NULL;
  int capi_grid_intent = 0;
  PyObject *grid_capi = Py_None;
  int ndof = 0;
  PyObject *ndof_capi = Py_None;
    static char *capi_kwlist[] = {"grid","ndof",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:libadflow.warping.setgrid",\
        capi_kwlist,&grid_capi,&ndof_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable grid */
  ;
  capi_grid_intent |= F2PY_INTENT_IN;
  capi_grid_tmp = array_from_pyobj(NPY_DOUBLE,grid_Dims,grid_Rank,capi_grid_intent,grid_capi);
  if (capi_grid_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `grid' of libadflow.warping.setgrid to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    grid = (double *)(PyArray_DATA(capi_grid_tmp));

  /* Processing variable ndof */
  if (ndof_capi == Py_None) ndof = len(grid); else
    f2py_success = int_from_pyobj(&ndof,ndof_capi,"libadflow.warping.setgrid() 1st keyword (ndof) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(grid)>=ndof,"len(grid)>=ndof","1st keyword ndof","setgrid:ndof=%d",ndof) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(grid,&ndof);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(grid)>=ndof)*/
  } /*if (f2py_success) of ndof*/
  /* End of cleaning variable ndof */
  if((PyObject *)capi_grid_tmp!=grid_capi) {
    Py_XDECREF(capi_grid_tmp); }
  }  /*if (capi_grid_tmp == NULL) ... else of grid*/
  /* End of cleaning variable grid */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of setgrid *******************************/

/********************************** getgrid **********************************/
static char doc_f2py_rout_libadflow_warping_getgrid[] = "\
grid = getgrid(ndof)\n\nWrapper for ``getgrid``.\
\n\nParameters\n----------\n"
"ndof : input int\n"
"\nReturns\n-------\n"
"grid : rank-1 array('d') with bounds (ndof)";
/*  */
static PyObject *f2py_rout_libadflow_warping_getgrid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *grid = NULL;
  npy_intp grid_Dims[1] = {-1};
  const int grid_Rank = 1;
  PyArrayObject *capi_grid_tmp = NULL;
  int capi_grid_intent = 0;
  int ndof = 0;
  PyObject *ndof_capi = Py_None;
    static char *capi_kwlist[] = {"ndof",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.warping.getgrid",\
        capi_kwlist,&ndof_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable ndof */
    f2py_success = int_from_pyobj(&ndof,ndof_capi,"libadflow.warping.getgrid() 1st argument (ndof) can't be converted to int");
  if (f2py_success) {
  /* Processing variable grid */
  grid_Dims[0]=ndof;
  capi_grid_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_grid_tmp = array_from_pyobj(NPY_DOUBLE,grid_Dims,grid_Rank,capi_grid_intent,Py_None);
  if (capi_grid_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `grid' of libadflow.warping.getgrid to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    grid = (double *)(PyArray_DATA(capi_grid_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(grid,&ndof);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_grid_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_grid_tmp == NULL) ... else of grid*/
  /* End of cleaning variable grid */
  } /*if (f2py_success) of ndof*/
  /* End of cleaning variable ndof */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of getgrid *******************************/

/**************************** getstateperturbation ****************************/
static char doc_f2py_rout_libadflow_warping_getstateperturbation[] = "\
randstate = getstateperturbation(randvec,nrandstate,[nrand])\n\nWrapper for ``getstateperturbation``.\
\n\nParameters\n----------\n"
"randvec : input rank-1 array('d') with bounds (nrand)\n"
"nrandstate : input int\n"
"\nOther Parameters\n----------------\n"
"nrand : input int, optional\n    Default: len(randvec)\n"
"\nReturns\n-------\n"
"randstate : rank-1 array('d') with bounds (nrandstate)";
/*  */
static PyObject *f2py_rout_libadflow_warping_getstateperturbation(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *randvec = NULL;
  npy_intp randvec_Dims[1] = {-1};
  const int randvec_Rank = 1;
  PyArrayObject *capi_randvec_tmp = NULL;
  int capi_randvec_intent = 0;
  PyObject *randvec_capi = Py_None;
  int nrand = 0;
  PyObject *nrand_capi = Py_None;
  double *randstate = NULL;
  npy_intp randstate_Dims[1] = {-1};
  const int randstate_Rank = 1;
  PyArrayObject *capi_randstate_tmp = NULL;
  int capi_randstate_intent = 0;
  int nrandstate = 0;
  PyObject *nrandstate_capi = Py_None;
    static char *capi_kwlist[] = {"randvec","nrandstate","nrand",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.warping.getstateperturbation",\
        capi_kwlist,&randvec_capi,&nrandstate_capi,&nrand_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable randvec */
  ;
  capi_randvec_intent |= F2PY_INTENT_IN;
  capi_randvec_tmp = array_from_pyobj(NPY_DOUBLE,randvec_Dims,randvec_Rank,capi_randvec_intent,randvec_capi);
  if (capi_randvec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `randvec' of libadflow.warping.getstateperturbation to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    randvec = (double *)(PyArray_DATA(capi_randvec_tmp));

  /* Processing variable nrandstate */
    f2py_success = int_from_pyobj(&nrandstate,nrandstate_capi,"libadflow.warping.getstateperturbation() 2nd argument (nrandstate) can't be converted to int");
  if (f2py_success) {
  /* Processing variable nrand */
  if (nrand_capi == Py_None) nrand = len(randvec); else
    f2py_success = int_from_pyobj(&nrand,nrand_capi,"libadflow.warping.getstateperturbation() 1st keyword (nrand) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(randvec)>=nrand,"len(randvec)>=nrand","1st keyword nrand","getstateperturbation:nrand=%d",nrand) {
  /* Processing variable randstate */
  randstate_Dims[0]=nrandstate;
  capi_randstate_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_randstate_tmp = array_from_pyobj(NPY_DOUBLE,randstate_Dims,randstate_Rank,capi_randstate_intent,Py_None);
  if (capi_randstate_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `randstate' of libadflow.warping.getstateperturbation to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    randstate = (double *)(PyArray_DATA(capi_randstate_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(randvec,&nrand,randstate,&nrandstate);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_randstate_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_randstate_tmp == NULL) ... else of randstate*/
  /* End of cleaning variable randstate */
  } /*CHECKSCALAR(len(randvec)>=nrand)*/
  } /*if (f2py_success) of nrand*/
  /* End of cleaning variable nrand */
  } /*if (f2py_success) of nrandstate*/
  /* End of cleaning variable nrandstate */
  if((PyObject *)capi_randvec_tmp!=randvec_capi) {
    Py_XDECREF(capi_randvec_tmp); }
  }  /*if (capi_randvec_tmp == NULL) ... else of randvec*/
  /* End of cleaning variable randvec */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of getstateperturbation ************************/

/*************************** getsurfaceperturbation ***************************/
static char doc_f2py_rout_libadflow_warping_getsurfaceperturbation[] = "\
getsurfaceperturbation(xrand,randsurface,famlist,sps,[nrand,nrandsurface,nfamlist])\n\nWrapper for ``getsurfaceperturbation``.\
\n\nParameters\n----------\n"
"xrand : input rank-1 array('d') with bounds (nrand)\n"
"randsurface : in/output rank-1 array('d') with bounds (3 * nrandsurface)\n"
"famlist : input rank-1 array('i') with bounds (nfamlist)\n"
"sps : input int\n"
"\nOther Parameters\n----------------\n"
"nrand : input int, optional\n    Default: len(xrand)\n"
"nrandsurface : input int, optional\n    Default: (len(randsurface))/(3)\n"
"nfamlist : input int, optional\n    Default: len(famlist)";
/*  */
static PyObject *f2py_rout_libadflow_warping_getsurfaceperturbation(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *xrand = NULL;
  npy_intp xrand_Dims[1] = {-1};
  const int xrand_Rank = 1;
  PyArrayObject *capi_xrand_tmp = NULL;
  int capi_xrand_intent = 0;
  PyObject *xrand_capi = Py_None;
  int nrand = 0;
  PyObject *nrand_capi = Py_None;
  double *randsurface = NULL;
  npy_intp randsurface_Dims[1] = {-1};
  const int randsurface_Rank = 1;
  PyArrayObject *capi_randsurface_tmp = NULL;
  int capi_randsurface_intent = 0;
  PyObject *randsurface_capi = Py_None;
  int nrandsurface = 0;
  PyObject *nrandsurface_capi = Py_None;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int nfamlist = 0;
  PyObject *nfamlist_capi = Py_None;
  int sps = 0;
  PyObject *sps_capi = Py_None;
    static char *capi_kwlist[] = {"xrand","randsurface","famlist","sps","nrand","nrandsurface","nfamlist",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|OOO:libadflow.warping.getsurfaceperturbation",\
        capi_kwlist,&xrand_capi,&randsurface_capi,&famlist_capi,&sps_capi,&nrand_capi,&nrandsurface_capi,&nfamlist_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable xrand */
  ;
  capi_xrand_intent |= F2PY_INTENT_IN;
  capi_xrand_tmp = array_from_pyobj(NPY_DOUBLE,xrand_Dims,xrand_Rank,capi_xrand_intent,xrand_capi);
  if (capi_xrand_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `xrand' of libadflow.warping.getsurfaceperturbation to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    xrand = (double *)(PyArray_DATA(capi_xrand_tmp));

  /* Processing variable randsurface */
  ;
  capi_randsurface_intent |= F2PY_INTENT_INOUT;
  capi_randsurface_tmp = array_from_pyobj(NPY_DOUBLE,randsurface_Dims,randsurface_Rank,capi_randsurface_intent,randsurface_capi);
  if (capi_randsurface_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `randsurface' of libadflow.warping.getsurfaceperturbation to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    randsurface = (double *)(PyArray_DATA(capi_randsurface_tmp));

  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `famlist' of libadflow.warping.getsurfaceperturbation to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable sps */
    f2py_success = int_from_pyobj(&sps,sps_capi,"libadflow.warping.getsurfaceperturbation() 4th argument (sps) can't be converted to int");
  if (f2py_success) {
  /* Processing variable nrand */
  if (nrand_capi == Py_None) nrand = len(xrand); else
    f2py_success = int_from_pyobj(&nrand,nrand_capi,"libadflow.warping.getsurfaceperturbation() 1st keyword (nrand) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(xrand)>=nrand,"len(xrand)>=nrand","1st keyword nrand","getsurfaceperturbation:nrand=%d",nrand) {
  /* Processing variable nrandsurface */
  if (nrandsurface_capi == Py_None) nrandsurface = (len(randsurface))/(3); else
    f2py_success = int_from_pyobj(&nrandsurface,nrandsurface_capi,"libadflow.warping.getsurfaceperturbation() 2nd keyword (nrandsurface) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR((len(randsurface))/(3)>=nrandsurface,"(len(randsurface))/(3)>=nrandsurface","2nd keyword nrandsurface","getsurfaceperturbation:nrandsurface=%d",nrandsurface) {
  /* Processing variable nfamlist */
  if (nfamlist_capi == Py_None) nfamlist = len(famlist); else
    f2py_success = int_from_pyobj(&nfamlist,nfamlist_capi,"libadflow.warping.getsurfaceperturbation() 3rd keyword (nfamlist) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=nfamlist,"len(famlist)>=nfamlist","3rd keyword nfamlist","getsurfaceperturbation:nfamlist=%d",nfamlist) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(xrand,&nrand,randsurface,&nrandsurface,famlist,&nfamlist,&sps);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=nfamlist)*/
  } /*if (f2py_success) of nfamlist*/
  /* End of cleaning variable nfamlist */
  } /*CHECKSCALAR((len(randsurface))/(3)>=nrandsurface)*/
  } /*if (f2py_success) of nrandsurface*/
  /* End of cleaning variable nrandsurface */
  } /*CHECKSCALAR(len(xrand)>=nrand)*/
  } /*if (f2py_success) of nrand*/
  /* End of cleaning variable nrand */
  } /*if (f2py_success) of sps*/
  /* End of cleaning variable sps */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
  if((PyObject *)capi_randsurface_tmp!=randsurface_capi) {
    Py_XDECREF(capi_randsurface_tmp); }
  }  /*if (capi_randsurface_tmp == NULL) ... else of randsurface*/
  /* End of cleaning variable randsurface */
  if((PyObject *)capi_xrand_tmp!=xrand_capi) {
    Py_XDECREF(capi_xrand_tmp); }
  }  /*if (capi_xrand_tmp == NULL) ... else of xrand*/
  /* End of cleaning variable xrand */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*********************** end of getsurfaceperturbation ***********************/

/******************************* getsurfacesize *******************************/
static char doc_f2py_rout_libadflow_surfaceutils_getsurfacesize[] = "\
size_bn,sizecell = getsurfacesize(famlist,includezipper,[n])\n\nWrapper for ``getsurfacesize``.\
\n\nParameters\n----------\n"
"famlist : input rank-1 array('i') with bounds (n)\n"
"includezipper : input int\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(famlist)\n"
"\nReturns\n-------\n"
"size_bn : int\n"
"sizecell : int";
/*  */
static PyObject *f2py_rout_libadflow_surfaceutils_getsurfacesize(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int size_bn = 0;
  int sizecell = 0;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int includezipper = 0;
  PyObject *includezipper_capi = Py_None;
    static char *capi_kwlist[] = {"famlist","includezipper","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.surfaceutils.getsurfacesize",\
        capi_kwlist,&famlist_capi,&includezipper_capi,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable size_bn */
  /* Processing variable sizecell */
  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `famlist' of libadflow.surfaceutils.getsurfacesize to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable includezipper */
    includezipper = (int)PyObject_IsTrue(includezipper_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable n */
  if (n_capi == Py_None) n = len(famlist); else
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.surfaceutils.getsurfacesize() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=n,"len(famlist)>=n","1st keyword n","getsurfacesize:n=%d",n) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&size_bn,&sizecell,famlist,&n,&includezipper);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("ii",size_bn,sizecell);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  } /*if (f2py_success) of includezipper*/
  /* End of cleaning variable includezipper */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
  /* End of cleaning variable sizecell */
  /* End of cleaning variable size_bn */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of getsurfacesize ***************************/

/*************************** getsurfaceconnectivity ***************************/
static char doc_f2py_rout_libadflow_surfaceutils_getsurfaceconnectivity[] = "\
getsurfaceconnectivity(conn,cgnsblockid,statecellid,famlist,includezipper,[ncell,nfamlist])\n\nWrapper for ``getsurfaceconnectivity``.\
\n\nParameters\n----------\n"
"conn : in/output rank-1 array('i') with bounds (4 * ncell)\n"
"cgnsblockid : in/output rank-1 array('i') with bounds (ncell)\n"
"statecellid : in/output rank-1 array('i') with bounds (ncell)\n"
"famlist : input rank-1 array('i') with bounds (nfamlist)\n"
"includezipper : input int\n"
"\nOther Parameters\n----------------\n"
"ncell : input int, optional\n    Default: (len(conn))/(4)\n"
"nfamlist : input int, optional\n    Default: len(famlist)";
/*  */
static PyObject *f2py_rout_libadflow_surfaceutils_getsurfaceconnectivity(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *conn = NULL;
  npy_intp conn_Dims[1] = {-1};
  const int conn_Rank = 1;
  PyArrayObject *capi_conn_tmp = NULL;
  int capi_conn_intent = 0;
  PyObject *conn_capi = Py_None;
  int *cgnsblockid = NULL;
  npy_intp cgnsblockid_Dims[1] = {-1};
  const int cgnsblockid_Rank = 1;
  PyArrayObject *capi_cgnsblockid_tmp = NULL;
  int capi_cgnsblockid_intent = 0;
  PyObject *cgnsblockid_capi = Py_None;
  int *statecellid = NULL;
  npy_intp statecellid_Dims[1] = {-1};
  const int statecellid_Rank = 1;
  PyArrayObject *capi_statecellid_tmp = NULL;
  int capi_statecellid_intent = 0;
  PyObject *statecellid_capi = Py_None;
  int ncell = 0;
  PyObject *ncell_capi = Py_None;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int nfamlist = 0;
  PyObject *nfamlist_capi = Py_None;
  int includezipper = 0;
  PyObject *includezipper_capi = Py_None;
    static char *capi_kwlist[] = {"conn","cgnsblockid","statecellid","famlist","includezipper","ncell","nfamlist",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOO|OO:libadflow.surfaceutils.getsurfaceconnectivity",\
        capi_kwlist,&conn_capi,&cgnsblockid_capi,&statecellid_capi,&famlist_capi,&includezipper_capi,&ncell_capi,&nfamlist_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable conn */
  ;
  capi_conn_intent |= F2PY_INTENT_INOUT;
  capi_conn_tmp = array_from_pyobj(NPY_INT,conn_Dims,conn_Rank,capi_conn_intent,conn_capi);
  if (capi_conn_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `conn' of libadflow.surfaceutils.getsurfaceconnectivity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    conn = (int *)(PyArray_DATA(capi_conn_tmp));

  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 4th argument `famlist' of libadflow.surfaceutils.getsurfaceconnectivity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable includezipper */
    includezipper = (int)PyObject_IsTrue(includezipper_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable ncell */
  if (ncell_capi == Py_None) ncell = (len(conn))/(4); else
    f2py_success = int_from_pyobj(&ncell,ncell_capi,"libadflow.surfaceutils.getsurfaceconnectivity() 1st keyword (ncell) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR((len(conn))/(4)>=ncell,"(len(conn))/(4)>=ncell","1st keyword ncell","getsurfaceconnectivity:ncell=%d",ncell) {
  /* Processing variable nfamlist */
  if (nfamlist_capi == Py_None) nfamlist = len(famlist); else
    f2py_success = int_from_pyobj(&nfamlist,nfamlist_capi,"libadflow.surfaceutils.getsurfaceconnectivity() 2nd keyword (nfamlist) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=nfamlist,"len(famlist)>=nfamlist","2nd keyword nfamlist","getsurfaceconnectivity:nfamlist=%d",nfamlist) {
  /* Processing variable cgnsblockid */
  cgnsblockid_Dims[0]=ncell;
  capi_cgnsblockid_intent |= F2PY_INTENT_INOUT;
  capi_cgnsblockid_tmp = array_from_pyobj(NPY_INT,cgnsblockid_Dims,cgnsblockid_Rank,capi_cgnsblockid_intent,cgnsblockid_capi);
  if (capi_cgnsblockid_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `cgnsblockid' of libadflow.surfaceutils.getsurfaceconnectivity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    cgnsblockid = (int *)(PyArray_DATA(capi_cgnsblockid_tmp));

  /* Processing variable statecellid */
  statecellid_Dims[0]=ncell;
  capi_statecellid_intent |= F2PY_INTENT_INOUT;
  capi_statecellid_tmp = array_from_pyobj(NPY_INT,statecellid_Dims,statecellid_Rank,capi_statecellid_intent,statecellid_capi);
  if (capi_statecellid_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `statecellid' of libadflow.surfaceutils.getsurfaceconnectivity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    statecellid = (int *)(PyArray_DATA(capi_statecellid_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(conn,cgnsblockid,statecellid,&ncell,famlist,&nfamlist,&includezipper);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_statecellid_tmp!=statecellid_capi) {
    Py_XDECREF(capi_statecellid_tmp); }
  }  /*if (capi_statecellid_tmp == NULL) ... else of statecellid*/
  /* End of cleaning variable statecellid */
  if((PyObject *)capi_cgnsblockid_tmp!=cgnsblockid_capi) {
    Py_XDECREF(capi_cgnsblockid_tmp); }
  }  /*if (capi_cgnsblockid_tmp == NULL) ... else of cgnsblockid*/
  /* End of cleaning variable cgnsblockid */
  } /*CHECKSCALAR(len(famlist)>=nfamlist)*/
  } /*if (f2py_success) of nfamlist*/
  /* End of cleaning variable nfamlist */
  } /*CHECKSCALAR((len(conn))/(4)>=ncell)*/
  } /*if (f2py_success) of ncell*/
  /* End of cleaning variable ncell */
  } /*if (f2py_success) of includezipper*/
  /* End of cleaning variable includezipper */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
  if((PyObject *)capi_conn_tmp!=conn_capi) {
    Py_XDECREF(capi_conn_tmp); }
  }  /*if (capi_conn_tmp == NULL) ... else of conn*/
  /* End of cleaning variable conn */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*********************** end of getsurfaceconnectivity ***********************/

/****************************** getsurfacepoints ******************************/
static char doc_f2py_rout_libadflow_surfaceutils_getsurfacepoints[] = "\
getsurfacepoints(points,sps_in,famlist,includezipper,[npts,nfamlist])\n\nWrapper for ``getsurfacepoints``.\
\n\nParameters\n----------\n"
"points : in/output rank-2 array('d') with bounds (3,npts)\n"
"sps_in : input int\n"
"famlist : input rank-1 array('i') with bounds (nfamlist)\n"
"includezipper : input int\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: shape(points,1)\n"
"nfamlist : input int, optional\n    Default: len(famlist)";
/*  */
static PyObject *f2py_rout_libadflow_surfaceutils_getsurfacepoints(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *points = NULL;
  npy_intp points_Dims[2] = {-1, -1};
  const int points_Rank = 2;
  PyArrayObject *capi_points_tmp = NULL;
  int capi_points_intent = 0;
  PyObject *points_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int sps_in = 0;
  PyObject *sps_in_capi = Py_None;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int nfamlist = 0;
  PyObject *nfamlist_capi = Py_None;
  int includezipper = 0;
  PyObject *includezipper_capi = Py_None;
    static char *capi_kwlist[] = {"points","sps_in","famlist","includezipper","npts","nfamlist",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|OO:libadflow.surfaceutils.getsurfacepoints",\
        capi_kwlist,&points_capi,&sps_in_capi,&famlist_capi,&includezipper_capi,&npts_capi,&nfamlist_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable points */
  points_Dims[0]=3;
  capi_points_intent |= F2PY_INTENT_INOUT;
  capi_points_tmp = array_from_pyobj(NPY_DOUBLE,points_Dims,points_Rank,capi_points_intent,points_capi);
  if (capi_points_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `points' of libadflow.surfaceutils.getsurfacepoints to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    points = (double *)(PyArray_DATA(capi_points_tmp));

  /* Processing variable sps_in */
    f2py_success = int_from_pyobj(&sps_in,sps_in_capi,"libadflow.surfaceutils.getsurfacepoints() 2nd argument (sps_in) can't be converted to int");
  if (f2py_success) {
  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `famlist' of libadflow.surfaceutils.getsurfacepoints to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable includezipper */
    includezipper = (int)PyObject_IsTrue(includezipper_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable npts */
  if (npts_capi == Py_None) npts = shape(points,1); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.surfaceutils.getsurfacepoints() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(points,1)==npts,"shape(points,1)==npts","1st keyword npts","getsurfacepoints:npts=%d",npts) {
  /* Processing variable nfamlist */
  if (nfamlist_capi == Py_None) nfamlist = len(famlist); else
    f2py_success = int_from_pyobj(&nfamlist,nfamlist_capi,"libadflow.surfaceutils.getsurfacepoints() 2nd keyword (nfamlist) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=nfamlist,"len(famlist)>=nfamlist","2nd keyword nfamlist","getsurfacepoints:nfamlist=%d",nfamlist) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(points,&npts,&sps_in,famlist,&nfamlist,&includezipper);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=nfamlist)*/
  } /*if (f2py_success) of nfamlist*/
  /* End of cleaning variable nfamlist */
  } /*CHECKSCALAR(shape(points,1)==npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  } /*if (f2py_success) of includezipper*/
  /* End of cleaning variable includezipper */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
  } /*if (f2py_success) of sps_in*/
  /* End of cleaning variable sps_in */
  if((PyObject *)capi_points_tmp!=points_capi) {
    Py_XDECREF(capi_points_tmp); }
  }  /*if (capi_points_tmp == NULL) ... else of points*/
  /* End of cleaning variable points */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of getsurfacepoints **************************/

/********************************* mapvector *********************************/
static char doc_f2py_rout_libadflow_surfaceutils_mapvector[] = "\
mapvector(vec1,famlist1,vec2,famlist2,includezipper,[n1,nf1,n2,nf2,ndim])\n\nWrapper for ``mapvector``.\
\n\nParameters\n----------\n"
"vec1 : input rank-2 array('d') with bounds (ndim,n1)\n"
"famlist1 : input rank-1 array('i') with bounds (nf1)\n"
"vec2 : in/output rank-2 array('d') with bounds (ndim,n2)\n"
"famlist2 : input rank-1 array('i') with bounds (nf2)\n"
"includezipper : input int\n"
"\nOther Parameters\n----------------\n"
"n1 : input int, optional\n    Default: shape(vec1,1)\n"
"nf1 : input int, optional\n    Default: len(famlist1)\n"
"n2 : input int, optional\n    Default: shape(vec2,1)\n"
"nf2 : input int, optional\n    Default: len(famlist2)\n"
"ndim : input int, optional\n    Default: shape(vec1,0)";
/*  */
static PyObject *f2py_rout_libadflow_surfaceutils_mapvector(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,int*,double*,int*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *vec1 = NULL;
  npy_intp vec1_Dims[2] = {-1, -1};
  const int vec1_Rank = 2;
  PyArrayObject *capi_vec1_tmp = NULL;
  int capi_vec1_intent = 0;
  PyObject *vec1_capi = Py_None;
  int n1 = 0;
  PyObject *n1_capi = Py_None;
  int *famlist1 = NULL;
  npy_intp famlist1_Dims[1] = {-1};
  const int famlist1_Rank = 1;
  PyArrayObject *capi_famlist1_tmp = NULL;
  int capi_famlist1_intent = 0;
  PyObject *famlist1_capi = Py_None;
  int nf1 = 0;
  PyObject *nf1_capi = Py_None;
  double *vec2 = NULL;
  npy_intp vec2_Dims[2] = {-1, -1};
  const int vec2_Rank = 2;
  PyArrayObject *capi_vec2_tmp = NULL;
  int capi_vec2_intent = 0;
  PyObject *vec2_capi = Py_None;
  int n2 = 0;
  PyObject *n2_capi = Py_None;
  int *famlist2 = NULL;
  npy_intp famlist2_Dims[1] = {-1};
  const int famlist2_Rank = 1;
  PyArrayObject *capi_famlist2_tmp = NULL;
  int capi_famlist2_intent = 0;
  PyObject *famlist2_capi = Py_None;
  int nf2 = 0;
  PyObject *nf2_capi = Py_None;
  int includezipper = 0;
  PyObject *includezipper_capi = Py_None;
  int ndim = 0;
  PyObject *ndim_capi = Py_None;
    static char *capi_kwlist[] = {"vec1","famlist1","vec2","famlist2","includezipper","n1","nf1","n2","nf2","ndim",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOO|OOOOO:libadflow.surfaceutils.mapvector",\
        capi_kwlist,&vec1_capi,&famlist1_capi,&vec2_capi,&famlist2_capi,&includezipper_capi,&n1_capi,&nf1_capi,&n2_capi,&nf2_capi,&ndim_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable vec1 */
  ;
  capi_vec1_intent |= F2PY_INTENT_IN;
  capi_vec1_tmp = array_from_pyobj(NPY_DOUBLE,vec1_Dims,vec1_Rank,capi_vec1_intent,vec1_capi);
  if (capi_vec1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `vec1' of libadflow.surfaceutils.mapvector to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    vec1 = (double *)(PyArray_DATA(capi_vec1_tmp));

  /* Processing variable famlist1 */
  ;
  capi_famlist1_intent |= F2PY_INTENT_IN;
  capi_famlist1_tmp = array_from_pyobj(NPY_INT,famlist1_Dims,famlist1_Rank,capi_famlist1_intent,famlist1_capi);
  if (capi_famlist1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `famlist1' of libadflow.surfaceutils.mapvector to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist1 = (int *)(PyArray_DATA(capi_famlist1_tmp));

  /* Processing variable famlist2 */
  ;
  capi_famlist2_intent |= F2PY_INTENT_IN;
  capi_famlist2_tmp = array_from_pyobj(NPY_INT,famlist2_Dims,famlist2_Rank,capi_famlist2_intent,famlist2_capi);
  if (capi_famlist2_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 4th argument `famlist2' of libadflow.surfaceutils.mapvector to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist2 = (int *)(PyArray_DATA(capi_famlist2_tmp));

  /* Processing variable includezipper */
    includezipper = (int)PyObject_IsTrue(includezipper_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable n1 */
  if (n1_capi == Py_None) n1 = shape(vec1,1); else
    f2py_success = int_from_pyobj(&n1,n1_capi,"libadflow.surfaceutils.mapvector() 1st keyword (n1) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(vec1,1)==n1,"shape(vec1,1)==n1","1st keyword n1","mapvector:n1=%d",n1) {
  /* Processing variable nf1 */
  if (nf1_capi == Py_None) nf1 = len(famlist1); else
    f2py_success = int_from_pyobj(&nf1,nf1_capi,"libadflow.surfaceutils.mapvector() 2nd keyword (nf1) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist1)>=nf1,"len(famlist1)>=nf1","2nd keyword nf1","mapvector:nf1=%d",nf1) {
  /* Processing variable nf2 */
  if (nf2_capi == Py_None) nf2 = len(famlist2); else
    f2py_success = int_from_pyobj(&nf2,nf2_capi,"libadflow.surfaceutils.mapvector() 4th keyword (nf2) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist2)>=nf2,"len(famlist2)>=nf2","4th keyword nf2","mapvector:nf2=%d",nf2) {
  /* Processing variable ndim */
  if (ndim_capi == Py_None) ndim = shape(vec1,0); else
    f2py_success = int_from_pyobj(&ndim,ndim_capi,"libadflow.surfaceutils.mapvector() 5th keyword (ndim) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(vec1,0)==ndim,"shape(vec1,0)==ndim","5th keyword ndim","mapvector:ndim=%d",ndim) {
  /* Processing variable vec2 */
  vec2_Dims[0]=ndim;
  capi_vec2_intent |= F2PY_INTENT_INOUT;
  capi_vec2_tmp = array_from_pyobj(NPY_DOUBLE,vec2_Dims,vec2_Rank,capi_vec2_intent,vec2_capi);
  if (capi_vec2_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `vec2' of libadflow.surfaceutils.mapvector to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    vec2 = (double *)(PyArray_DATA(capi_vec2_tmp));

  /* Processing variable n2 */
  if (n2_capi == Py_None) n2 = shape(vec2,1); else
    f2py_success = int_from_pyobj(&n2,n2_capi,"libadflow.surfaceutils.mapvector() 3rd keyword (n2) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(vec2,1)==n2,"shape(vec2,1)==n2","3rd keyword n2","mapvector:n2=%d",n2) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(vec1,&n1,famlist1,&nf1,vec2,&n2,famlist2,&nf2,&includezipper,&ndim);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(vec2,1)==n2)*/
  } /*if (f2py_success) of n2*/
  /* End of cleaning variable n2 */
  if((PyObject *)capi_vec2_tmp!=vec2_capi) {
    Py_XDECREF(capi_vec2_tmp); }
  }  /*if (capi_vec2_tmp == NULL) ... else of vec2*/
  /* End of cleaning variable vec2 */
  } /*CHECKSCALAR(shape(vec1,0)==ndim)*/
  } /*if (f2py_success) of ndim*/
  /* End of cleaning variable ndim */
  } /*CHECKSCALAR(len(famlist2)>=nf2)*/
  } /*if (f2py_success) of nf2*/
  /* End of cleaning variable nf2 */
  } /*CHECKSCALAR(len(famlist1)>=nf1)*/
  } /*if (f2py_success) of nf1*/
  /* End of cleaning variable nf1 */
  } /*CHECKSCALAR(shape(vec1,1)==n1)*/
  } /*if (f2py_success) of n1*/
  /* End of cleaning variable n1 */
  } /*if (f2py_success) of includezipper*/
  /* End of cleaning variable includezipper */
  if((PyObject *)capi_famlist2_tmp!=famlist2_capi) {
    Py_XDECREF(capi_famlist2_tmp); }
  }  /*if (capi_famlist2_tmp == NULL) ... else of famlist2*/
  /* End of cleaning variable famlist2 */
  if((PyObject *)capi_famlist1_tmp!=famlist1_capi) {
    Py_XDECREF(capi_famlist1_tmp); }
  }  /*if (capi_famlist1_tmp == NULL) ... else of famlist1*/
  /* End of cleaning variable famlist1 */
  if((PyObject *)capi_vec1_tmp!=vec1_capi) {
    Py_XDECREF(capi_vec1_tmp); }
  }  /*if (capi_vec1_tmp == NULL) ... else of vec1*/
  /* End of cleaning variable vec1 */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of mapvector ******************************/

/******************************** getwalllist ********************************/
static char doc_f2py_rout_libadflow_surfaceutils_getwalllist[] = "\
walllist,nwalllist = getwalllist(nfamtotal)\n\nWrapper for ``getwalllist``.\
\n\nParameters\n----------\n"
"nfamtotal : input int\n"
"\nReturns\n-------\n"
"walllist : rank-1 array('i') with bounds (nfamtotal)\n"
"nwalllist : int";
/*  */
static PyObject *f2py_rout_libadflow_surfaceutils_getwalllist(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *walllist = NULL;
  npy_intp walllist_Dims[1] = {-1};
  const int walllist_Rank = 1;
  PyArrayObject *capi_walllist_tmp = NULL;
  int capi_walllist_intent = 0;
  int nwalllist = 0;
  int nfamtotal = 0;
  PyObject *nfamtotal_capi = Py_None;
    static char *capi_kwlist[] = {"nfamtotal",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.surfaceutils.getwalllist",\
        capi_kwlist,&nfamtotal_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable nwalllist */
  /* Processing variable nfamtotal */
    f2py_success = int_from_pyobj(&nfamtotal,nfamtotal_capi,"libadflow.surfaceutils.getwalllist() 1st argument (nfamtotal) can't be converted to int");
  if (f2py_success) {
  /* Processing variable walllist */
  walllist_Dims[0]=nfamtotal;
  capi_walllist_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_walllist_tmp = array_from_pyobj(NPY_INT,walllist_Dims,walllist_Rank,capi_walllist_intent,Py_None);
  if (capi_walllist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `walllist' of libadflow.surfaceutils.getwalllist to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    walllist = (int *)(PyArray_DATA(capi_walllist_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(walllist,&nwalllist,&nfamtotal);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("Ni",capi_walllist_tmp,nwalllist);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_walllist_tmp == NULL) ... else of walllist*/
  /* End of cleaning variable walllist */
  } /*if (f2py_success) of nfamtotal*/
  /* End of cleaning variable nfamtotal */
  /* End of cleaning variable nwalllist */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of getwalllist *****************************/

/******************************** addparaslice ********************************/
static char doc_f2py_rout_libadflow_tecplotio_addparaslice[] = "\
addparaslice(slicename,pt,direction,famlist,[n])\n\nWrapper for ``addparaslice``.\
\n\nParameters\n----------\n"
"slicename : input string(len=-1)\n"
"pt : input rank-1 array('d') with bounds (3)\n"
"direction : input rank-1 array('d') with bounds (3)\n"
"famlist : input rank-1 array('i') with bounds (n)\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(famlist)";
/*  */
static PyObject *f2py_rout_libadflow_tecplotio_addparaslice(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,double*,int*,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string slicename = NULL;
  int slen(slicename);
  PyObject *slicename_capi = Py_None;
  double *pt = NULL;
  npy_intp pt_Dims[1] = {-1};
  const int pt_Rank = 1;
  PyArrayObject *capi_pt_tmp = NULL;
  int capi_pt_intent = 0;
  PyObject *pt_capi = Py_None;
  double *direction = NULL;
  npy_intp direction_Dims[1] = {-1};
  const int direction_Rank = 1;
  PyArrayObject *capi_direction_tmp = NULL;
  int capi_direction_intent = 0;
  PyObject *direction_capi = Py_None;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
    static char *capi_kwlist[] = {"slicename","pt","direction","famlist","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|O:libadflow.tecplotio.addparaslice",\
        capi_kwlist,&slicename_capi,&pt_capi,&direction_capi,&famlist_capi,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable slicename */
  slen(slicename) = -1;
  f2py_success = string_from_pyobj(&slicename,&slen(slicename),"",slicename_capi,"string_from_pyobj failed in converting 1st argument `slicename' of libadflow.tecplotio.addparaslice to C string");
  if (f2py_success) {
  /* Processing variable pt */
  pt_Dims[0]=3;
  capi_pt_intent |= F2PY_INTENT_IN;
  capi_pt_tmp = array_from_pyobj(NPY_DOUBLE,pt_Dims,pt_Rank,capi_pt_intent,pt_capi);
  if (capi_pt_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `pt' of libadflow.tecplotio.addparaslice to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    pt = (double *)(PyArray_DATA(capi_pt_tmp));

  /* Processing variable direction */
  direction_Dims[0]=3;
  capi_direction_intent |= F2PY_INTENT_IN;
  capi_direction_tmp = array_from_pyobj(NPY_DOUBLE,direction_Dims,direction_Rank,capi_direction_intent,direction_capi);
  if (capi_direction_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `direction' of libadflow.tecplotio.addparaslice to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    direction = (double *)(PyArray_DATA(capi_direction_tmp));

  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 4th argument `famlist' of libadflow.tecplotio.addparaslice to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable n */
  if (n_capi == Py_None) n = len(famlist); else
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.tecplotio.addparaslice() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=n,"len(famlist)>=n","1st keyword n","addparaslice:n=%d",n) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(slicename,pt,direction,famlist,&n,slen(slicename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
  if((PyObject *)capi_direction_tmp!=direction_capi) {
    Py_XDECREF(capi_direction_tmp); }
  }  /*if (capi_direction_tmp == NULL) ... else of direction*/
  /* End of cleaning variable direction */
  if((PyObject *)capi_pt_tmp!=pt_capi) {
    Py_XDECREF(capi_pt_tmp); }
  }  /*if (capi_pt_tmp == NULL) ... else of pt*/
  /* End of cleaning variable pt */
    STRINGFREE(slicename);
  }  /*if (f2py_success) of slicename*/
  /* End of cleaning variable slicename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of addparaslice ****************************/

/******************************** addabsslice ********************************/
static char doc_f2py_rout_libadflow_tecplotio_addabsslice[] = "\
addabsslice(slicename,pt,direction,famlist,[n])\n\nWrapper for ``addabsslice``.\
\n\nParameters\n----------\n"
"slicename : input string(len=-1)\n"
"pt : input rank-1 array('d') with bounds (3)\n"
"direction : input rank-1 array('d') with bounds (3)\n"
"famlist : input rank-1 array('i') with bounds (n)\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(famlist)";
/*  */
static PyObject *f2py_rout_libadflow_tecplotio_addabsslice(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,double*,int*,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string slicename = NULL;
  int slen(slicename);
  PyObject *slicename_capi = Py_None;
  double *pt = NULL;
  npy_intp pt_Dims[1] = {-1};
  const int pt_Rank = 1;
  PyArrayObject *capi_pt_tmp = NULL;
  int capi_pt_intent = 0;
  PyObject *pt_capi = Py_None;
  double *direction = NULL;
  npy_intp direction_Dims[1] = {-1};
  const int direction_Rank = 1;
  PyArrayObject *capi_direction_tmp = NULL;
  int capi_direction_intent = 0;
  PyObject *direction_capi = Py_None;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
    static char *capi_kwlist[] = {"slicename","pt","direction","famlist","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|O:libadflow.tecplotio.addabsslice",\
        capi_kwlist,&slicename_capi,&pt_capi,&direction_capi,&famlist_capi,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable slicename */
  slen(slicename) = -1;
  f2py_success = string_from_pyobj(&slicename,&slen(slicename),"",slicename_capi,"string_from_pyobj failed in converting 1st argument `slicename' of libadflow.tecplotio.addabsslice to C string");
  if (f2py_success) {
  /* Processing variable pt */
  pt_Dims[0]=3;
  capi_pt_intent |= F2PY_INTENT_IN;
  capi_pt_tmp = array_from_pyobj(NPY_DOUBLE,pt_Dims,pt_Rank,capi_pt_intent,pt_capi);
  if (capi_pt_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `pt' of libadflow.tecplotio.addabsslice to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    pt = (double *)(PyArray_DATA(capi_pt_tmp));

  /* Processing variable direction */
  direction_Dims[0]=3;
  capi_direction_intent |= F2PY_INTENT_IN;
  capi_direction_tmp = array_from_pyobj(NPY_DOUBLE,direction_Dims,direction_Rank,capi_direction_intent,direction_capi);
  if (capi_direction_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `direction' of libadflow.tecplotio.addabsslice to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    direction = (double *)(PyArray_DATA(capi_direction_tmp));

  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 4th argument `famlist' of libadflow.tecplotio.addabsslice to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable n */
  if (n_capi == Py_None) n = len(famlist); else
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.tecplotio.addabsslice() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=n,"len(famlist)>=n","1st keyword n","addabsslice:n=%d",n) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(slicename,pt,direction,famlist,&n,slen(slicename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
  if((PyObject *)capi_direction_tmp!=direction_capi) {
    Py_XDECREF(capi_direction_tmp); }
  }  /*if (capi_direction_tmp == NULL) ... else of direction*/
  /* End of cleaning variable direction */
  if((PyObject *)capi_pt_tmp!=pt_capi) {
    Py_XDECREF(capi_pt_tmp); }
  }  /*if (capi_pt_tmp == NULL) ... else of pt*/
  /* End of cleaning variable pt */
    STRINGFREE(slicename);
  }  /*if (f2py_success) of slicename*/
  /* End of cleaning variable slicename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of addabsslice *****************************/

/**************************** addliftdistribution ****************************/
static char doc_f2py_rout_libadflow_tecplotio_addliftdistribution[] = "\
addliftdistribution(nsegments,dir_vec,dir_ind,distname,famlist,[n])\n\nWrapper for ``addliftdistribution``.\
\n\nParameters\n----------\n"
"nsegments : input int\n"
"dir_vec : input rank-1 array('d') with bounds (3)\n"
"dir_ind : input int\n"
"distname : input string(len=-1)\n"
"famlist : input rank-1 array('i') with bounds (n)\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(famlist)";
/*  */
static PyObject *f2py_rout_libadflow_tecplotio_addliftdistribution(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,int*,string,int*,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int nsegments = 0;
  PyObject *nsegments_capi = Py_None;
  double *dir_vec = NULL;
  npy_intp dir_vec_Dims[1] = {-1};
  const int dir_vec_Rank = 1;
  PyArrayObject *capi_dir_vec_tmp = NULL;
  int capi_dir_vec_intent = 0;
  PyObject *dir_vec_capi = Py_None;
  int dir_ind = 0;
  PyObject *dir_ind_capi = Py_None;
  string distname = NULL;
  int slen(distname);
  PyObject *distname_capi = Py_None;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
    static char *capi_kwlist[] = {"nsegments","dir_vec","dir_ind","distname","famlist","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOO|O:libadflow.tecplotio.addliftdistribution",\
        capi_kwlist,&nsegments_capi,&dir_vec_capi,&dir_ind_capi,&distname_capi,&famlist_capi,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable nsegments */
    f2py_success = int_from_pyobj(&nsegments,nsegments_capi,"libadflow.tecplotio.addliftdistribution() 1st argument (nsegments) can't be converted to int");
  if (f2py_success) {
  /* Processing variable dir_vec */
  dir_vec_Dims[0]=3;
  capi_dir_vec_intent |= F2PY_INTENT_IN;
  capi_dir_vec_tmp = array_from_pyobj(NPY_DOUBLE,dir_vec_Dims,dir_vec_Rank,capi_dir_vec_intent,dir_vec_capi);
  if (capi_dir_vec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `dir_vec' of libadflow.tecplotio.addliftdistribution to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dir_vec = (double *)(PyArray_DATA(capi_dir_vec_tmp));

  /* Processing variable dir_ind */
    f2py_success = int_from_pyobj(&dir_ind,dir_ind_capi,"libadflow.tecplotio.addliftdistribution() 3rd argument (dir_ind) can't be converted to int");
  if (f2py_success) {
  /* Processing variable distname */
  slen(distname) = -1;
  f2py_success = string_from_pyobj(&distname,&slen(distname),"",distname_capi,"string_from_pyobj failed in converting 4th argument `distname' of libadflow.tecplotio.addliftdistribution to C string");
  if (f2py_success) {
  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 5th argument `famlist' of libadflow.tecplotio.addliftdistribution to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable n */
  if (n_capi == Py_None) n = len(famlist); else
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.tecplotio.addliftdistribution() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=n,"len(famlist)>=n","1st keyword n","addliftdistribution:n=%d",n) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&nsegments,dir_vec,&dir_ind,distname,famlist,&n,slen(distname));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
    STRINGFREE(distname);
  }  /*if (f2py_success) of distname*/
  /* End of cleaning variable distname */
  } /*if (f2py_success) of dir_ind*/
  /* End of cleaning variable dir_ind */
  if((PyObject *)capi_dir_vec_tmp!=dir_vec_capi) {
    Py_XDECREF(capi_dir_vec_tmp); }
  }  /*if (capi_dir_vec_tmp == NULL) ... else of dir_vec*/
  /* End of cleaning variable dir_vec */
  } /*if (f2py_success) of nsegments*/
  /* End of cleaning variable nsegments */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of addliftdistribution *************************/

/******************************** writetecplot ********************************/
static char doc_f2py_rout_libadflow_tecplotio_writetecplot[] = "\
writetecplot(slicefile,writeslices,liftfile,writelift,surffile,writesurf,famlist,[nfamlist])\n\nWrapper for ``writetecplot``.\
\n\nParameters\n----------\n"
"slicefile : input string(len=-1)\n"
"writeslices : input int\n"
"liftfile : input string(len=-1)\n"
"writelift : input int\n"
"surffile : input string(len=-1)\n"
"writesurf : input int\n"
"famlist : input rank-1 array('i') with bounds (nfamlist)\n"
"\nOther Parameters\n----------------\n"
"nfamlist : input int, optional\n    Default: len(famlist)";
/*  */
static PyObject *f2py_rout_libadflow_tecplotio_writetecplot(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,string,int*,string,int*,int*,int*,size_t,size_t,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string slicefile = NULL;
  int slen(slicefile);
  PyObject *slicefile_capi = Py_None;
  int writeslices = 0;
  PyObject *writeslices_capi = Py_None;
  string liftfile = NULL;
  int slen(liftfile);
  PyObject *liftfile_capi = Py_None;
  int writelift = 0;
  PyObject *writelift_capi = Py_None;
  string surffile = NULL;
  int slen(surffile);
  PyObject *surffile_capi = Py_None;
  int writesurf = 0;
  PyObject *writesurf_capi = Py_None;
  int *famlist = NULL;
  npy_intp famlist_Dims[1] = {-1};
  const int famlist_Rank = 1;
  PyArrayObject *capi_famlist_tmp = NULL;
  int capi_famlist_intent = 0;
  PyObject *famlist_capi = Py_None;
  int nfamlist = 0;
  PyObject *nfamlist_capi = Py_None;
    static char *capi_kwlist[] = {"slicefile","writeslices","liftfile","writelift","surffile","writesurf","famlist","nfamlist",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOO|O:libadflow.tecplotio.writetecplot",\
        capi_kwlist,&slicefile_capi,&writeslices_capi,&liftfile_capi,&writelift_capi,&surffile_capi,&writesurf_capi,&famlist_capi,&nfamlist_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable slicefile */
  slen(slicefile) = -1;
  f2py_success = string_from_pyobj(&slicefile,&slen(slicefile),"",slicefile_capi,"string_from_pyobj failed in converting 1st argument `slicefile' of libadflow.tecplotio.writetecplot to C string");
  if (f2py_success) {
  /* Processing variable writeslices */
    writeslices = (int)PyObject_IsTrue(writeslices_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable liftfile */
  slen(liftfile) = -1;
  f2py_success = string_from_pyobj(&liftfile,&slen(liftfile),"",liftfile_capi,"string_from_pyobj failed in converting 3rd argument `liftfile' of libadflow.tecplotio.writetecplot to C string");
  if (f2py_success) {
  /* Processing variable writelift */
    writelift = (int)PyObject_IsTrue(writelift_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable surffile */
  slen(surffile) = -1;
  f2py_success = string_from_pyobj(&surffile,&slen(surffile),"",surffile_capi,"string_from_pyobj failed in converting 5th argument `surffile' of libadflow.tecplotio.writetecplot to C string");
  if (f2py_success) {
  /* Processing variable writesurf */
    writesurf = (int)PyObject_IsTrue(writesurf_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable famlist */
  ;
  capi_famlist_intent |= F2PY_INTENT_IN;
  capi_famlist_tmp = array_from_pyobj(NPY_INT,famlist_Dims,famlist_Rank,capi_famlist_intent,famlist_capi);
  if (capi_famlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 7th argument `famlist' of libadflow.tecplotio.writetecplot to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlist = (int *)(PyArray_DATA(capi_famlist_tmp));

  /* Processing variable nfamlist */
  if (nfamlist_capi == Py_None) nfamlist = len(famlist); else
    f2py_success = int_from_pyobj(&nfamlist,nfamlist_capi,"libadflow.tecplotio.writetecplot() 1st keyword (nfamlist) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(famlist)>=nfamlist,"len(famlist)>=nfamlist","1st keyword nfamlist","writetecplot:nfamlist=%d",nfamlist) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(slicefile,&writeslices,liftfile,&writelift,surffile,&writesurf,famlist,&nfamlist,slen(slicefile),slen(liftfile),slen(surffile));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(famlist)>=nfamlist)*/
  } /*if (f2py_success) of nfamlist*/
  /* End of cleaning variable nfamlist */
  if((PyObject *)capi_famlist_tmp!=famlist_capi) {
    Py_XDECREF(capi_famlist_tmp); }
  }  /*if (capi_famlist_tmp == NULL) ... else of famlist*/
  /* End of cleaning variable famlist */
  } /*if (f2py_success) of writesurf*/
  /* End of cleaning variable writesurf */
    STRINGFREE(surffile);
  }  /*if (f2py_success) of surffile*/
  /* End of cleaning variable surffile */
  } /*if (f2py_success) of writelift*/
  /* End of cleaning variable writelift */
    STRINGFREE(liftfile);
  }  /*if (f2py_success) of liftfile*/
  /* End of cleaning variable liftfile */
  } /*if (f2py_success) of writeslices*/
  /* End of cleaning variable writeslices */
    STRINGFREE(slicefile);
  }  /*if (f2py_success) of slicefile*/
  /* End of cleaning variable slicefile */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of writetecplot ****************************/

/*********************** initializeliftdistributiondata ***********************/
static char doc_f2py_rout_libadflow_tecplotio_initializeliftdistributiondata[] = "\
initializeliftdistributiondata()\n\nWrapper for ``initializeliftdistributiondata``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_tecplotio_initializeliftdistributiondata(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.tecplotio.initializeliftdistributiondata",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************* end of initializeliftdistributiondata *******************/

/****************************** getsolutionwrap ******************************/
static char doc_f2py_rout_libadflow_surfaceintegrations_getsolutionwrap[] = "\
funcvalues = getsolutionwrap(famlists,ncost,[ngroups,nfammax])\n\nWrapper for ``getsolutionwrap``.\
\n\nParameters\n----------\n"
"famlists : input rank-2 array('i') with bounds (ngroups,nfammax)\n"
"ncost : input int\n"
"\nOther Parameters\n----------------\n"
"ngroups : input int, optional\n    Default: shape(famlists,0)\n"
"nfammax : input int, optional\n    Default: shape(famlists,1)\n"
"\nReturns\n-------\n"
"funcvalues : rank-2 array('d') with bounds (ncost,ngroups)";
/*  */
static PyObject *f2py_rout_libadflow_surfaceintegrations_getsolutionwrap(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *famlists = NULL;
  npy_intp famlists_Dims[2] = {-1, -1};
  const int famlists_Rank = 2;
  PyArrayObject *capi_famlists_tmp = NULL;
  int capi_famlists_intent = 0;
  PyObject *famlists_capi = Py_None;
  double *funcvalues = NULL;
  npy_intp funcvalues_Dims[2] = {-1, -1};
  const int funcvalues_Rank = 2;
  PyArrayObject *capi_funcvalues_tmp = NULL;
  int capi_funcvalues_intent = 0;
  int ncost = 0;
  PyObject *ncost_capi = Py_None;
  int ngroups = 0;
  PyObject *ngroups_capi = Py_None;
  int nfammax = 0;
  PyObject *nfammax_capi = Py_None;
    static char *capi_kwlist[] = {"famlists","ncost","ngroups","nfammax",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|OO:libadflow.surfaceintegrations.getsolutionwrap",\
        capi_kwlist,&famlists_capi,&ncost_capi,&ngroups_capi,&nfammax_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable famlists */
  ;
  capi_famlists_intent |= F2PY_INTENT_IN;
  capi_famlists_tmp = array_from_pyobj(NPY_INT,famlists_Dims,famlists_Rank,capi_famlists_intent,famlists_capi);
  if (capi_famlists_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `famlists' of libadflow.surfaceintegrations.getsolutionwrap to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlists = (int *)(PyArray_DATA(capi_famlists_tmp));

  /* Processing variable ncost */
    f2py_success = int_from_pyobj(&ncost,ncost_capi,"libadflow.surfaceintegrations.getsolutionwrap() 2nd argument (ncost) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ngroups */
  if (ngroups_capi == Py_None) ngroups = shape(famlists,0); else
    f2py_success = int_from_pyobj(&ngroups,ngroups_capi,"libadflow.surfaceintegrations.getsolutionwrap() 1st keyword (ngroups) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(famlists,0)==ngroups,"shape(famlists,0)==ngroups","1st keyword ngroups","getsolutionwrap:ngroups=%d",ngroups) {
  /* Processing variable nfammax */
  if (nfammax_capi == Py_None) nfammax = shape(famlists,1); else
    f2py_success = int_from_pyobj(&nfammax,nfammax_capi,"libadflow.surfaceintegrations.getsolutionwrap() 2nd keyword (nfammax) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(famlists,1)==nfammax,"shape(famlists,1)==nfammax","2nd keyword nfammax","getsolutionwrap:nfammax=%d",nfammax) {
  /* Processing variable funcvalues */
  funcvalues_Dims[0]=ncost,funcvalues_Dims[1]=ngroups;
  capi_funcvalues_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_funcvalues_tmp = array_from_pyobj(NPY_DOUBLE,funcvalues_Dims,funcvalues_Rank,capi_funcvalues_intent,Py_None);
  if (capi_funcvalues_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `funcvalues' of libadflow.surfaceintegrations.getsolutionwrap to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    funcvalues = (double *)(PyArray_DATA(capi_funcvalues_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(famlists,funcvalues,&ncost,&ngroups,&nfammax);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_funcvalues_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_funcvalues_tmp == NULL) ... else of funcvalues*/
  /* End of cleaning variable funcvalues */
  } /*CHECKSCALAR(shape(famlists,1)==nfammax)*/
  } /*if (f2py_success) of nfammax*/
  /* End of cleaning variable nfammax */
  } /*CHECKSCALAR(shape(famlists,0)==ngroups)*/
  } /*if (f2py_success) of ngroups*/
  /* End of cleaning variable ngroups */
  } /*if (f2py_success) of ncost*/
  /* End of cleaning variable ncost */
  if((PyObject *)capi_famlists_tmp!=famlists_capi) {
    Py_XDECREF(capi_famlists_tmp); }
  }  /*if (capi_famlists_tmp == NULL) ... else of famlists*/
  /* End of cleaning variable famlists */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of getsolutionwrap ***************************/

/*************************** addintegrationsurface ***************************/
static char doc_f2py_rout_libadflow_usersurfaceintegrations_addintegrationsurface[] = "\
addintegrationsurface(pts,conn,famname,famid,isinflow,[npts,nconn])\n\nWrapper for ``addintegrationsurface``.\
\n\nParameters\n----------\n"
"pts : input rank-2 array('d') with bounds (3,npts)\n"
"conn : input rank-2 array('i') with bounds (3,nconn)\n"
"famname : input string(len=1)\n"
"famid : input int\n"
"isinflow : input int\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: shape(pts,1)\n"
"nconn : input int, optional\n    Default: shape(conn,1)";
/*  */
static PyObject *f2py_rout_libadflow_usersurfaceintegrations_addintegrationsurface(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,string,int*,int*,int*,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *pts = NULL;
  npy_intp pts_Dims[2] = {-1, -1};
  const int pts_Rank = 2;
  PyArrayObject *capi_pts_tmp = NULL;
  int capi_pts_intent = 0;
  PyObject *pts_capi = Py_None;
  int *conn = NULL;
  npy_intp conn_Dims[2] = {-1, -1};
  const int conn_Rank = 2;
  PyArrayObject *capi_conn_tmp = NULL;
  int capi_conn_intent = 0;
  PyObject *conn_capi = Py_None;
  string famname = NULL;
  int slen(famname);
  PyObject *famname_capi = Py_None;
  int famid = 0;
  PyObject *famid_capi = Py_None;
  int isinflow = 0;
  PyObject *isinflow_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int nconn = 0;
  PyObject *nconn_capi = Py_None;
    static char *capi_kwlist[] = {"pts","conn","famname","famid","isinflow","npts","nconn",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOO|OO:libadflow.usersurfaceintegrations.addintegrationsurface",\
        capi_kwlist,&pts_capi,&conn_capi,&famname_capi,&famid_capi,&isinflow_capi,&npts_capi,&nconn_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable pts */
  pts_Dims[0]=3;
  capi_pts_intent |= F2PY_INTENT_IN;
  capi_pts_tmp = array_from_pyobj(NPY_DOUBLE,pts_Dims,pts_Rank,capi_pts_intent,pts_capi);
  if (capi_pts_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `pts' of libadflow.usersurfaceintegrations.addintegrationsurface to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    pts = (double *)(PyArray_DATA(capi_pts_tmp));

  /* Processing variable conn */
  conn_Dims[0]=3;
  capi_conn_intent |= F2PY_INTENT_IN;
  capi_conn_tmp = array_from_pyobj(NPY_INT,conn_Dims,conn_Rank,capi_conn_intent,conn_capi);
  if (capi_conn_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `conn' of libadflow.usersurfaceintegrations.addintegrationsurface to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    conn = (int *)(PyArray_DATA(capi_conn_tmp));

  /* Processing variable famname */
  slen(famname) = 1;
  f2py_success = string_from_pyobj(&famname,&slen(famname),"",famname_capi,"string_from_pyobj failed in converting 3rd argument `famname' of libadflow.usersurfaceintegrations.addintegrationsurface to C string");
  if (f2py_success) {
  /* Processing variable famid */
    f2py_success = int_from_pyobj(&famid,famid_capi,"libadflow.usersurfaceintegrations.addintegrationsurface() 4th argument (famid) can't be converted to int");
  if (f2py_success) {
  /* Processing variable isinflow */
    isinflow = (int)PyObject_IsTrue(isinflow_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable npts */
  if (npts_capi == Py_None) npts = shape(pts,1); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.usersurfaceintegrations.addintegrationsurface() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(pts,1)==npts,"shape(pts,1)==npts","1st keyword npts","addintegrationsurface:npts=%d",npts) {
  /* Processing variable nconn */
  if (nconn_capi == Py_None) nconn = shape(conn,1); else
    f2py_success = int_from_pyobj(&nconn,nconn_capi,"libadflow.usersurfaceintegrations.addintegrationsurface() 2nd keyword (nconn) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(conn,1)==nconn,"shape(conn,1)==nconn","2nd keyword nconn","addintegrationsurface:nconn=%d",nconn) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(pts,conn,famname,&famid,&isinflow,&npts,&nconn,slen(famname));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(conn,1)==nconn)*/
  } /*if (f2py_success) of nconn*/
  /* End of cleaning variable nconn */
  } /*CHECKSCALAR(shape(pts,1)==npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  } /*if (f2py_success) of isinflow*/
  /* End of cleaning variable isinflow */
  } /*if (f2py_success) of famid*/
  /* End of cleaning variable famid */
    STRINGFREE(famname);
  }  /*if (f2py_success) of famname*/
  /* End of cleaning variable famname */
  if((PyObject *)capi_conn_tmp!=conn_capi) {
    Py_XDECREF(capi_conn_tmp); }
  }  /*if (capi_conn_tmp == NULL) ... else of conn*/
  /* End of cleaning variable conn */
  if((PyObject *)capi_pts_tmp!=pts_capi) {
    Py_XDECREF(capi_pts_tmp); }
  }  /*if (capi_pts_tmp == NULL) ... else of pts*/
  /* End of cleaning variable pts */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of addintegrationsurface ************************/

/*********************** interpolateintegrationsurfaces ***********************/
static char doc_f2py_rout_libadflow_usersurfaceintegrations_interpolateintegrationsurfaces[] = "\
interpolateintegrationsurfaces()\n\nWrapper for ``interpolateintegrationsurfaces``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_usersurfaceintegrations_interpolateintegrationsurfaces(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.usersurfaceintegrations.interpolateintegrationsurfaces",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************* end of interpolateintegrationsurfaces *******************/

/***************************** addactuatorregion *****************************/
static char doc_f2py_rout_libadflow_actuatorregion_addactuatorregion[] = "\
addactuatorregion(pts,conn,axis1,axis2,famname,famid,thrust,torque,heat,relaxstart,relaxend,[npts,nconn])\n\nWrapper for ``addactuatorregion``.\
\n\nParameters\n----------\n"
"pts : input rank-2 array('d') with bounds (3,npts)\n"
"conn : input rank-2 array('i') with bounds (4,nconn)\n"
"axis1 : input rank-1 array('d') with bounds (3)\n"
"axis2 : input rank-1 array('d') with bounds (3)\n"
"famname : input string(len=-1)\n"
"famid : input int\n"
"thrust : input float\n"
"torque : input float\n"
"heat : input float\n"
"relaxstart : input float\n"
"relaxend : input float\n"
"\nOther Parameters\n----------------\n"
"npts : input int, optional\n    Default: shape(pts,1)\n"
"nconn : input int, optional\n    Default: shape(conn,1)";
/*  */
static PyObject *f2py_rout_libadflow_actuatorregion_addactuatorregion(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,double*,string,int*,double*,double*,double*,double*,double*,int*,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *pts = NULL;
  npy_intp pts_Dims[2] = {-1, -1};
  const int pts_Rank = 2;
  PyArrayObject *capi_pts_tmp = NULL;
  int capi_pts_intent = 0;
  PyObject *pts_capi = Py_None;
  int *conn = NULL;
  npy_intp conn_Dims[2] = {-1, -1};
  const int conn_Rank = 2;
  PyArrayObject *capi_conn_tmp = NULL;
  int capi_conn_intent = 0;
  PyObject *conn_capi = Py_None;
  double *axis1 = NULL;
  npy_intp axis1_Dims[1] = {-1};
  const int axis1_Rank = 1;
  PyArrayObject *capi_axis1_tmp = NULL;
  int capi_axis1_intent = 0;
  PyObject *axis1_capi = Py_None;
  double *axis2 = NULL;
  npy_intp axis2_Dims[1] = {-1};
  const int axis2_Rank = 1;
  PyArrayObject *capi_axis2_tmp = NULL;
  int capi_axis2_intent = 0;
  PyObject *axis2_capi = Py_None;
  string famname = NULL;
  int slen(famname);
  PyObject *famname_capi = Py_None;
  int famid = 0;
  PyObject *famid_capi = Py_None;
  double thrust = 0;
  PyObject *thrust_capi = Py_None;
  double torque = 0;
  PyObject *torque_capi = Py_None;
  double heat = 0;
  PyObject *heat_capi = Py_None;
  double relaxstart = 0;
  PyObject *relaxstart_capi = Py_None;
  double relaxend = 0;
  PyObject *relaxend_capi = Py_None;
  int npts = 0;
  PyObject *npts_capi = Py_None;
  int nconn = 0;
  PyObject *nconn_capi = Py_None;
    static char *capi_kwlist[] = {"pts","conn","axis1","axis2","famname","famid","thrust","torque","heat","relaxstart","relaxend","npts","nconn",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOOOOOO|OO:libadflow.actuatorregion.addactuatorregion",\
        capi_kwlist,&pts_capi,&conn_capi,&axis1_capi,&axis2_capi,&famname_capi,&famid_capi,&thrust_capi,&torque_capi,&heat_capi,&relaxstart_capi,&relaxend_capi,&npts_capi,&nconn_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable pts */
  pts_Dims[0]=3;
  capi_pts_intent |= F2PY_INTENT_IN;
  capi_pts_tmp = array_from_pyobj(NPY_DOUBLE,pts_Dims,pts_Rank,capi_pts_intent,pts_capi);
  if (capi_pts_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `pts' of libadflow.actuatorregion.addactuatorregion to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    pts = (double *)(PyArray_DATA(capi_pts_tmp));

  /* Processing variable conn */
  conn_Dims[0]=4;
  capi_conn_intent |= F2PY_INTENT_IN;
  capi_conn_tmp = array_from_pyobj(NPY_INT,conn_Dims,conn_Rank,capi_conn_intent,conn_capi);
  if (capi_conn_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `conn' of libadflow.actuatorregion.addactuatorregion to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    conn = (int *)(PyArray_DATA(capi_conn_tmp));

  /* Processing variable axis1 */
  axis1_Dims[0]=3;
  capi_axis1_intent |= F2PY_INTENT_IN;
  capi_axis1_tmp = array_from_pyobj(NPY_DOUBLE,axis1_Dims,axis1_Rank,capi_axis1_intent,axis1_capi);
  if (capi_axis1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `axis1' of libadflow.actuatorregion.addactuatorregion to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    axis1 = (double *)(PyArray_DATA(capi_axis1_tmp));

  /* Processing variable axis2 */
  axis2_Dims[0]=3;
  capi_axis2_intent |= F2PY_INTENT_IN;
  capi_axis2_tmp = array_from_pyobj(NPY_DOUBLE,axis2_Dims,axis2_Rank,capi_axis2_intent,axis2_capi);
  if (capi_axis2_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 4th argument `axis2' of libadflow.actuatorregion.addactuatorregion to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    axis2 = (double *)(PyArray_DATA(capi_axis2_tmp));

  /* Processing variable famname */
  slen(famname) = -1;
  f2py_success = string_from_pyobj(&famname,&slen(famname),"",famname_capi,"string_from_pyobj failed in converting 5th argument `famname' of libadflow.actuatorregion.addactuatorregion to C string");
  if (f2py_success) {
  /* Processing variable famid */
    f2py_success = int_from_pyobj(&famid,famid_capi,"libadflow.actuatorregion.addactuatorregion() 6th argument (famid) can't be converted to int");
  if (f2py_success) {
  /* Processing variable thrust */
    f2py_success = double_from_pyobj(&thrust,thrust_capi,"libadflow.actuatorregion.addactuatorregion() 7th argument (thrust) can't be converted to double");
  if (f2py_success) {
  /* Processing variable torque */
    f2py_success = double_from_pyobj(&torque,torque_capi,"libadflow.actuatorregion.addactuatorregion() 8th argument (torque) can't be converted to double");
  if (f2py_success) {
  /* Processing variable heat */
    f2py_success = double_from_pyobj(&heat,heat_capi,"libadflow.actuatorregion.addactuatorregion() 9th argument (heat) can't be converted to double");
  if (f2py_success) {
  /* Processing variable relaxstart */
    f2py_success = double_from_pyobj(&relaxstart,relaxstart_capi,"libadflow.actuatorregion.addactuatorregion() 10th argument (relaxstart) can't be converted to double");
  if (f2py_success) {
  /* Processing variable relaxend */
    f2py_success = double_from_pyobj(&relaxend,relaxend_capi,"libadflow.actuatorregion.addactuatorregion() 11st argument (relaxend) can't be converted to double");
  if (f2py_success) {
  /* Processing variable npts */
  if (npts_capi == Py_None) npts = shape(pts,1); else
    f2py_success = int_from_pyobj(&npts,npts_capi,"libadflow.actuatorregion.addactuatorregion() 1st keyword (npts) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(pts,1)==npts,"shape(pts,1)==npts","1st keyword npts","addactuatorregion:npts=%d",npts) {
  /* Processing variable nconn */
  if (nconn_capi == Py_None) nconn = shape(conn,1); else
    f2py_success = int_from_pyobj(&nconn,nconn_capi,"libadflow.actuatorregion.addactuatorregion() 2nd keyword (nconn) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(conn,1)==nconn,"shape(conn,1)==nconn","2nd keyword nconn","addactuatorregion:nconn=%d",nconn) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(pts,conn,axis1,axis2,famname,&famid,&thrust,&torque,&heat,&relaxstart,&relaxend,&npts,&nconn,slen(famname));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(conn,1)==nconn)*/
  } /*if (f2py_success) of nconn*/
  /* End of cleaning variable nconn */
  } /*CHECKSCALAR(shape(pts,1)==npts)*/
  } /*if (f2py_success) of npts*/
  /* End of cleaning variable npts */
  } /*if (f2py_success) of relaxend*/
  /* End of cleaning variable relaxend */
  } /*if (f2py_success) of relaxstart*/
  /* End of cleaning variable relaxstart */
  } /*if (f2py_success) of heat*/
  /* End of cleaning variable heat */
  } /*if (f2py_success) of torque*/
  /* End of cleaning variable torque */
  } /*if (f2py_success) of thrust*/
  /* End of cleaning variable thrust */
  } /*if (f2py_success) of famid*/
  /* End of cleaning variable famid */
    STRINGFREE(famname);
  }  /*if (f2py_success) of famname*/
  /* End of cleaning variable famname */
  if((PyObject *)capi_axis2_tmp!=axis2_capi) {
    Py_XDECREF(capi_axis2_tmp); }
  }  /*if (capi_axis2_tmp == NULL) ... else of axis2*/
  /* End of cleaning variable axis2 */
  if((PyObject *)capi_axis1_tmp!=axis1_capi) {
    Py_XDECREF(capi_axis1_tmp); }
  }  /*if (capi_axis1_tmp == NULL) ... else of axis1*/
  /* End of cleaning variable axis1 */
  if((PyObject *)capi_conn_tmp!=conn_capi) {
    Py_XDECREF(capi_conn_tmp); }
  }  /*if (capi_conn_tmp == NULL) ... else of conn*/
  /* End of cleaning variable conn */
  if((PyObject *)capi_pts_tmp!=pts_capi) {
    Py_XDECREF(capi_pts_tmp); }
  }  /*if (capi_pts_tmp == NULL) ... else of pts*/
  /* End of cleaning variable pts */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of addactuatorregion **************************/

/**************************** writeactuatorregions ****************************/
static char doc_f2py_rout_libadflow_actuatorregion_writeactuatorregions[] = "\
writeactuatorregions(filename)\n\nWrapper for ``writeactuatorregions``.\
\n\nParameters\n----------\n"
"filename : input string(len=-1)";
/*  */
static PyObject *f2py_rout_libadflow_actuatorregion_writeactuatorregions(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
    static char *capi_kwlist[] = {"filename",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.actuatorregion.writeactuatorregions",\
        capi_kwlist,&filename_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 1st argument `filename' of libadflow.actuatorregion.writeactuatorregions to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(filename,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of writeactuatorregions ************************/

/*********************************** solver ***********************************/
static char doc_f2py_rout_libadflow_solvers_solver[] = "\
solver()\n\nWrapper for ``solver``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_solvers_solver(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.solvers.solver",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of solver *******************************/

/***************************** solverunsteadyinit *****************************/
static char doc_f2py_rout_libadflow_solvers_solverunsteadyinit[] = "\
solverunsteadyinit()\n\nWrapper for ``solverunsteadyinit``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_solvers_solverunsteadyinit(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.solvers.solverunsteadyinit",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of solverunsteadyinit *************************/

/*************************** updateunsteadygeometry ***************************/
static char doc_f2py_rout_libadflow_solvers_updateunsteadygeometry[] = "\
updateunsteadygeometry()\n\nWrapper for ``updateunsteadygeometry``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_solvers_updateunsteadygeometry(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.solvers.updateunsteadygeometry",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*********************** end of updateunsteadygeometry ***********************/

/***************************** solverunsteadystep *****************************/
static char doc_f2py_rout_libadflow_solvers_solverunsteadystep[] = "\
solverunsteadystep()\n\nWrapper for ``solverunsteadystep``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_solvers_solverunsteadystep(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.solvers.solverunsteadystep",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of solverunsteadystep *************************/

/******************************* shiftlevelale *******************************/
static char doc_f2py_rout_libadflow_aleutils_shiftlevelale[] = "\
shiftlevelale()\n\nWrapper for ``shiftlevelale``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_aleutils_shiftlevelale(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.aleutils.shiftlevelale",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of shiftlevelale ****************************/

/******************************* preprocessing *******************************/
static char doc_f2py_rout_libadflow_preprocessingapi_preprocessing[] = "\
preprocessing()\n\nWrapper for ``preprocessing``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_preprocessing(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.preprocessingapi.preprocessing",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of preprocessing ****************************/

/************************* updatecoordinatesalllevels *************************/
static char doc_f2py_rout_libadflow_preprocessingapi_updatecoordinatesalllevels[] = "\
updatecoordinatesalllevels()\n\nWrapper for ``updatecoordinatesalllevels``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_updatecoordinatesalllevels(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.preprocessingapi.updatecoordinatesalllevels",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************* end of updatecoordinatesalllevels *********************/

/*************************** updatemetricsalllevels ***************************/
static char doc_f2py_rout_libadflow_preprocessingapi_updatemetricsalllevels[] = "\
updatemetricsalllevels()\n\nWrapper for ``updatemetricsalllevels``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_updatemetricsalllevels(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.preprocessingapi.updatemetricsalllevels",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*********************** end of updatemetricsalllevels ***********************/

/*********************** updategridvelocitiesalllevels ***********************/
static char doc_f2py_rout_libadflow_preprocessingapi_updategridvelocitiesalllevels[] = "\
updategridvelocitiesalllevels()\n\nWrapper for ``updategridvelocitiesalllevels``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_updategridvelocitiesalllevels(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.preprocessingapi.updategridvelocitiesalllevels",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************** end of updategridvelocitiesalllevels ********************/

/************************ updateperiodicinfoalllevels ************************/
static char doc_f2py_rout_libadflow_preprocessingapi_updateperiodicinfoalllevels[] = "\
updateperiodicinfoalllevels()\n\nWrapper for ``updateperiodicinfoalllevels``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_updateperiodicinfoalllevels(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.preprocessingapi.updateperiodicinfoalllevels",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************* end of updateperiodicinfoalllevels *********************/

/**************************** shiftcoorandvolumes ****************************/
static char doc_f2py_rout_libadflow_preprocessingapi_shiftcoorandvolumes[] = "\
shiftcoorandvolumes()\n\nWrapper for ``shiftcoorandvolumes``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_shiftcoorandvolumes(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.preprocessingapi.shiftcoorandvolumes",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of shiftcoorandvolumes *************************/

/**************************** updatereferencepoint ****************************/
static char doc_f2py_rout_libadflow_preprocessingapi_updatereferencepoint[] = "\
updatereferencepoint()\n\nWrapper for ``updatereferencepoint``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_updatereferencepoint(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.preprocessingapi.updatereferencepoint",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of updatereferencepoint ************************/

/***************************** updaterotationrate *****************************/
static char doc_f2py_rout_libadflow_preprocessingapi_updaterotationrate[] = "\
updaterotationrate(rotcenter,rotrate,blocks,[nblocks])\n\nWrapper for ``updaterotationrate``.\
\n\nParameters\n----------\n"
"rotcenter : input rank-1 array('d') with bounds (3)\n"
"rotrate : input rank-1 array('d') with bounds (3)\n"
"blocks : input rank-1 array('i') with bounds (nblocks)\n"
"\nOther Parameters\n----------------\n"
"nblocks : input int, optional\n    Default: len(blocks)";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_updaterotationrate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *rotcenter = NULL;
  npy_intp rotcenter_Dims[1] = {-1};
  const int rotcenter_Rank = 1;
  PyArrayObject *capi_rotcenter_tmp = NULL;
  int capi_rotcenter_intent = 0;
  PyObject *rotcenter_capi = Py_None;
  double *rotrate = NULL;
  npy_intp rotrate_Dims[1] = {-1};
  const int rotrate_Rank = 1;
  PyArrayObject *capi_rotrate_tmp = NULL;
  int capi_rotrate_intent = 0;
  PyObject *rotrate_capi = Py_None;
  int *blocks = NULL;
  npy_intp blocks_Dims[1] = {-1};
  const int blocks_Rank = 1;
  PyArrayObject *capi_blocks_tmp = NULL;
  int capi_blocks_intent = 0;
  PyObject *blocks_capi = Py_None;
  int nblocks = 0;
  PyObject *nblocks_capi = Py_None;
    static char *capi_kwlist[] = {"rotcenter","rotrate","blocks","nblocks",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|O:libadflow.preprocessingapi.updaterotationrate",\
        capi_kwlist,&rotcenter_capi,&rotrate_capi,&blocks_capi,&nblocks_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable rotcenter */
  rotcenter_Dims[0]=3;
  capi_rotcenter_intent |= F2PY_INTENT_IN;
  capi_rotcenter_tmp = array_from_pyobj(NPY_DOUBLE,rotcenter_Dims,rotcenter_Rank,capi_rotcenter_intent,rotcenter_capi);
  if (capi_rotcenter_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `rotcenter' of libadflow.preprocessingapi.updaterotationrate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    rotcenter = (double *)(PyArray_DATA(capi_rotcenter_tmp));

  /* Processing variable rotrate */
  rotrate_Dims[0]=3;
  capi_rotrate_intent |= F2PY_INTENT_IN;
  capi_rotrate_tmp = array_from_pyobj(NPY_DOUBLE,rotrate_Dims,rotrate_Rank,capi_rotrate_intent,rotrate_capi);
  if (capi_rotrate_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `rotrate' of libadflow.preprocessingapi.updaterotationrate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    rotrate = (double *)(PyArray_DATA(capi_rotrate_tmp));

  /* Processing variable blocks */
  ;
  capi_blocks_intent |= F2PY_INTENT_IN;
  capi_blocks_tmp = array_from_pyobj(NPY_INT,blocks_Dims,blocks_Rank,capi_blocks_intent,blocks_capi);
  if (capi_blocks_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `blocks' of libadflow.preprocessingapi.updaterotationrate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    blocks = (int *)(PyArray_DATA(capi_blocks_tmp));

  /* Processing variable nblocks */
  if (nblocks_capi == Py_None) nblocks = len(blocks); else
    f2py_success = int_from_pyobj(&nblocks,nblocks_capi,"libadflow.preprocessingapi.updaterotationrate() 1st keyword (nblocks) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(blocks)>=nblocks,"len(blocks)>=nblocks","1st keyword nblocks","updaterotationrate:nblocks=%d",nblocks) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(rotcenter,rotrate,blocks,&nblocks);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(blocks)>=nblocks)*/
  } /*if (f2py_success) of nblocks*/
  /* End of cleaning variable nblocks */
  if((PyObject *)capi_blocks_tmp!=blocks_capi) {
    Py_XDECREF(capi_blocks_tmp); }
  }  /*if (capi_blocks_tmp == NULL) ... else of blocks*/
  /* End of cleaning variable blocks */
  if((PyObject *)capi_rotrate_tmp!=rotrate_capi) {
    Py_XDECREF(capi_rotrate_tmp); }
  }  /*if (capi_rotrate_tmp == NULL) ... else of rotrate*/
  /* End of cleaning variable rotrate */
  if((PyObject *)capi_rotcenter_tmp!=rotcenter_capi) {
    Py_XDECREF(capi_rotcenter_tmp); }
  }  /*if (capi_rotcenter_tmp == NULL) ... else of rotcenter*/
  /* End of cleaning variable rotcenter */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of updaterotationrate *************************/

/**************************** preprocessingoverset ****************************/
static char doc_f2py_rout_libadflow_preprocessingapi_preprocessingoverset[] = "\
preprocessingoverset(flag,closedfamlist,[n,nfam])\n\nWrapper for ``preprocessingoverset``.\
\n\nParameters\n----------\n"
"flag : input rank-1 array('i') with bounds (n)\n"
"closedfamlist : input rank-1 array('i') with bounds (nfam)\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(flag)\n"
"nfam : input int, optional\n    Default: len(closedfamlist)";
/*  */
static PyObject *f2py_rout_libadflow_preprocessingapi_preprocessingoverset(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *flag = NULL;
  npy_intp flag_Dims[1] = {-1};
  const int flag_Rank = 1;
  PyArrayObject *capi_flag_tmp = NULL;
  int capi_flag_intent = 0;
  PyObject *flag_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int *closedfamlist = NULL;
  npy_intp closedfamlist_Dims[1] = {-1};
  const int closedfamlist_Rank = 1;
  PyArrayObject *capi_closedfamlist_tmp = NULL;
  int capi_closedfamlist_intent = 0;
  PyObject *closedfamlist_capi = Py_None;
  int nfam = 0;
  PyObject *nfam_capi = Py_None;
    static char *capi_kwlist[] = {"flag","closedfamlist","n","nfam",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|OO:libadflow.preprocessingapi.preprocessingoverset",\
        capi_kwlist,&flag_capi,&closedfamlist_capi,&n_capi,&nfam_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable flag */
  ;
  capi_flag_intent |= F2PY_INTENT_IN;
  capi_flag_tmp = array_from_pyobj(NPY_INT,flag_Dims,flag_Rank,capi_flag_intent,flag_capi);
  if (capi_flag_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `flag' of libadflow.preprocessingapi.preprocessingoverset to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    flag = (int *)(PyArray_DATA(capi_flag_tmp));

  /* Processing variable closedfamlist */
  ;
  capi_closedfamlist_intent |= F2PY_INTENT_IN;
  capi_closedfamlist_tmp = array_from_pyobj(NPY_INT,closedfamlist_Dims,closedfamlist_Rank,capi_closedfamlist_intent,closedfamlist_capi);
  if (capi_closedfamlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `closedfamlist' of libadflow.preprocessingapi.preprocessingoverset to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    closedfamlist = (int *)(PyArray_DATA(capi_closedfamlist_tmp));

  /* Processing variable n */
  if (n_capi == Py_None) n = len(flag); else
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.preprocessingapi.preprocessingoverset() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(flag)>=n,"len(flag)>=n","1st keyword n","preprocessingoverset:n=%d",n) {
  /* Processing variable nfam */
  if (nfam_capi == Py_None) nfam = len(closedfamlist); else
    f2py_success = int_from_pyobj(&nfam,nfam_capi,"libadflow.preprocessingapi.preprocessingoverset() 2nd keyword (nfam) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(closedfamlist)>=nfam,"len(closedfamlist)>=nfam","2nd keyword nfam","preprocessingoverset:nfam=%d",nfam) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(flag,&n,closedfamlist,&nfam);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(closedfamlist)>=nfam)*/
  } /*if (f2py_success) of nfam*/
  /* End of cleaning variable nfam */
  } /*CHECKSCALAR(len(flag)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_closedfamlist_tmp!=closedfamlist_capi) {
    Py_XDECREF(capi_closedfamlist_tmp); }
  }  /*if (capi_closedfamlist_tmp == NULL) ... else of closedfamlist*/
  /* End of cleaning variable closedfamlist */
  if((PyObject *)capi_flag_tmp!=flag_capi) {
    Py_XDECREF(capi_flag_tmp); }
  }  /*if (capi_flag_tmp == NULL) ... else of flag*/
  /* End of cleaning variable flag */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of preprocessingoverset ************************/

/******************************* updateoverset *******************************/
static char doc_f2py_rout_libadflow_oversetapi_updateoverset[] = "\
updateoverset(flag,closedfamlist,[n,nfam])\n\nWrapper for ``updateoverset``.\
\n\nParameters\n----------\n"
"flag : input rank-1 array('i') with bounds (n)\n"
"closedfamlist : input rank-1 array('i') with bounds (nfam)\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(flag)\n"
"nfam : input int, optional\n    Default: len(closedfamlist)";
/*  */
static PyObject *f2py_rout_libadflow_oversetapi_updateoverset(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *flag = NULL;
  npy_intp flag_Dims[1] = {-1};
  const int flag_Rank = 1;
  PyArrayObject *capi_flag_tmp = NULL;
  int capi_flag_intent = 0;
  PyObject *flag_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  int *closedfamlist = NULL;
  npy_intp closedfamlist_Dims[1] = {-1};
  const int closedfamlist_Rank = 1;
  PyArrayObject *capi_closedfamlist_tmp = NULL;
  int capi_closedfamlist_intent = 0;
  PyObject *closedfamlist_capi = Py_None;
  int nfam = 0;
  PyObject *nfam_capi = Py_None;
    static char *capi_kwlist[] = {"flag","closedfamlist","n","nfam",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|OO:libadflow.oversetapi.updateoverset",\
        capi_kwlist,&flag_capi,&closedfamlist_capi,&n_capi,&nfam_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable flag */
  ;
  capi_flag_intent |= F2PY_INTENT_IN;
  capi_flag_tmp = array_from_pyobj(NPY_INT,flag_Dims,flag_Rank,capi_flag_intent,flag_capi);
  if (capi_flag_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `flag' of libadflow.oversetapi.updateoverset to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    flag = (int *)(PyArray_DATA(capi_flag_tmp));

  /* Processing variable closedfamlist */
  ;
  capi_closedfamlist_intent |= F2PY_INTENT_IN;
  capi_closedfamlist_tmp = array_from_pyobj(NPY_INT,closedfamlist_Dims,closedfamlist_Rank,capi_closedfamlist_intent,closedfamlist_capi);
  if (capi_closedfamlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `closedfamlist' of libadflow.oversetapi.updateoverset to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    closedfamlist = (int *)(PyArray_DATA(capi_closedfamlist_tmp));

  /* Processing variable n */
  if (n_capi == Py_None) n = len(flag); else
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.oversetapi.updateoverset() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(flag)>=n,"len(flag)>=n","1st keyword n","updateoverset:n=%d",n) {
  /* Processing variable nfam */
  if (nfam_capi == Py_None) nfam = len(closedfamlist); else
    f2py_success = int_from_pyobj(&nfam,nfam_capi,"libadflow.oversetapi.updateoverset() 2nd keyword (nfam) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(closedfamlist)>=nfam,"len(closedfamlist)>=nfam","2nd keyword nfam","updateoverset:nfam=%d",nfam) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(flag,&n,closedfamlist,&nfam);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(closedfamlist)>=nfam)*/
  } /*if (f2py_success) of nfam*/
  /* End of cleaning variable nfam */
  } /*CHECKSCALAR(len(flag)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_closedfamlist_tmp!=closedfamlist_capi) {
    Py_XDECREF(capi_closedfamlist_tmp); }
  }  /*if (capi_closedfamlist_tmp == NULL) ... else of closedfamlist*/
  /* End of cleaning variable closedfamlist */
  if((PyObject *)capi_flag_tmp!=flag_capi) {
    Py_XDECREF(capi_flag_tmp); }
  }  /*if (capi_flag_tmp == NULL) ... else of flag*/
  /* End of cleaning variable flag */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of updateoverset ****************************/

/**************************** writepartitionedmesh ****************************/
static char doc_f2py_rout_libadflow_oversetapi_writepartitionedmesh[] = "\
writepartitionedmesh(filename)\n\nWrapper for ``writepartitionedmesh``.\
\n\nParameters\n----------\n"
"filename : input string(len=-1)";
/*  */
static PyObject *f2py_rout_libadflow_oversetapi_writepartitionedmesh(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
    static char *capi_kwlist[] = {"filename",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.oversetapi.writepartitionedmesh",\
        capi_kwlist,&filename_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 1st argument `filename' of libadflow.oversetapi.writepartitionedmesh to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(filename,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************ end of writepartitionedmesh ************************/

/******************************** oversetcomm ********************************/
static char doc_f2py_rout_libadflow_oversetapi_oversetcomm[] = "\
oversetcomm(level,firstime,coarselevel)\n\nWrapper for ``oversetcomm``.\
\n\nParameters\n----------\n"
"level : input int\n"
"firstime : input float\n"
"coarselevel : input int";
/*  */
static PyObject *f2py_rout_libadflow_oversetapi_oversetcomm(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,float*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int level = 0;
  PyObject *level_capi = Py_None;
  float firstime = 0;
  PyObject *firstime_capi = Py_None;
  int coarselevel = 0;
  PyObject *coarselevel_capi = Py_None;
    static char *capi_kwlist[] = {"level","firstime","coarselevel",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|:libadflow.oversetapi.oversetcomm",\
        capi_kwlist,&level_capi,&firstime_capi,&coarselevel_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable level */
    f2py_success = int_from_pyobj(&level,level_capi,"libadflow.oversetapi.oversetcomm() 1st argument (level) can't be converted to int");
  if (f2py_success) {
  /* Processing variable coarselevel */
    coarselevel = (int)PyObject_IsTrue(coarselevel_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable firstime */
    f2py_success = float_from_pyobj(&firstime,firstime_capi,"libadflow.oversetapi.oversetcomm() 2nd argument (firstime) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&level,&firstime,&coarselevel);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of firstime*/
  /* End of cleaning variable firstime */
  } /*if (f2py_success) of coarselevel*/
  /* End of cleaning variable coarselevel */
  } /*if (f2py_success) of level*/
  /* End of cleaning variable level */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of oversetcomm *****************************/

/****************************** setblockpriority ******************************/
static char doc_f2py_rout_libadflow_oversetapi_setblockpriority[] = "\
setvalue = setblockpriority(blkname,value)\n\nWrapper for ``setblockpriority``.\
\n\nParameters\n----------\n"
"blkname : input string(len=-1)\n"
"value : input float\n"
"\nReturns\n-------\n"
"setvalue : int";
/*  */
static PyObject *f2py_rout_libadflow_oversetapi_setblockpriority(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,double*,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string blkname = NULL;
  int slen(blkname);
  PyObject *blkname_capi = Py_None;
  double value = 0;
  PyObject *value_capi = Py_None;
  int setvalue = 0;
    static char *capi_kwlist[] = {"blkname","value",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:libadflow.oversetapi.setblockpriority",\
        capi_kwlist,&blkname_capi,&value_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable blkname */
  slen(blkname) = -1;
  f2py_success = string_from_pyobj(&blkname,&slen(blkname),"",blkname_capi,"string_from_pyobj failed in converting 1st argument `blkname' of libadflow.oversetapi.setblockpriority to C string");
  if (f2py_success) {
  /* Processing variable value */
    f2py_success = double_from_pyobj(&value,value_capi,"libadflow.oversetapi.setblockpriority() 2nd argument (value) can't be converted to double");
  if (f2py_success) {
  /* Processing variable setvalue */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(blkname,&value,&setvalue,slen(blkname));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",setvalue);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable setvalue */
  } /*if (f2py_success) of value*/
  /* End of cleaning variable value */
    STRINGFREE(blkname);
  }  /*if (f2py_success) of blkname*/
  /* End of cleaning variable blkname */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of setblockpriority **************************/

/****************************** getoversetiblank ******************************/
static char doc_f2py_rout_libadflow_oversetutilities_getoversetiblank[] = "\
blklist = getoversetiblank(n)\n\nWrapper for ``getoversetiblank``.\
\n\nParameters\n----------\n"
"n : input int\n"
"\nReturns\n-------\n"
"blklist : rank-1 array('i') with bounds (n)";
/*  */
static PyObject *f2py_rout_libadflow_oversetutilities_getoversetiblank(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *blklist = NULL;
  npy_intp blklist_Dims[1] = {-1};
  const int blklist_Rank = 1;
  PyArrayObject *capi_blklist_tmp = NULL;
  int capi_blklist_intent = 0;
  int n = 0;
  PyObject *n_capi = Py_None;
    static char *capi_kwlist[] = {"n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.oversetutilities.getoversetiblank",\
        capi_kwlist,&n_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable n */
    f2py_success = int_from_pyobj(&n,n_capi,"libadflow.oversetutilities.getoversetiblank() 1st argument (n) can't be converted to int");
  if (f2py_success) {
  /* Processing variable blklist */
  blklist_Dims[0]=n;
  capi_blklist_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_blklist_tmp = array_from_pyobj(NPY_INT,blklist_Dims,blklist_Rank,capi_blklist_intent,Py_None);
  if (capi_blklist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `blklist' of libadflow.oversetutilities.getoversetiblank to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    blklist = (int *)(PyArray_DATA(capi_blklist_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(blklist,&n);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_blklist_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_blklist_tmp == NULL) ... else of blklist*/
  /* End of cleaning variable blklist */
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of getoversetiblank **************************/

/******************************* setuppetscksp *******************************/
static char doc_f2py_rout_libadflow_adjointapi_setuppetscksp[] = "\
setuppetscksp()\n\nWrapper for ``setuppetscksp``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_setuppetscksp(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.adjointapi.setuppetscksp",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of setuppetscksp ****************************/

/************************ setupallresidualmatricesfwd ************************/
static char doc_f2py_rout_libadflow_adjointapi_setupallresidualmatricesfwd[] = "\
setupallresidualmatricesfwd()\n\nWrapper for ``setupallresidualmatricesfwd``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_setupallresidualmatricesfwd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.adjointapi.setupallresidualmatricesfwd",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************* end of setupallresidualmatricesfwd *********************/

/******************************** solveadjoint ********************************/
static char doc_f2py_rout_libadflow_adjointapi_solveadjoint[] = "\
solveadjoint(rhs,psi,checksolution,[nstate])\n\nWrapper for ``solveadjoint``.\
\n\nParameters\n----------\n"
"rhs : input rank-1 array('d') with bounds (nstate)\n"
"psi : input rank-1 array('d') with bounds (nstate)\n"
"checksolution : input int\n"
"\nOther Parameters\n----------------\n"
"nstate : input int, optional\n    Default: len(rhs)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_solveadjoint(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *rhs = NULL;
  npy_intp rhs_Dims[1] = {-1};
  const int rhs_Rank = 1;
  PyArrayObject *capi_rhs_tmp = NULL;
  int capi_rhs_intent = 0;
  PyObject *rhs_capi = Py_None;
  double *psi = NULL;
  npy_intp psi_Dims[1] = {-1};
  const int psi_Rank = 1;
  PyArrayObject *capi_psi_tmp = NULL;
  int capi_psi_intent = 0;
  PyObject *psi_capi = Py_None;
  int checksolution = 0;
  PyObject *checksolution_capi = Py_None;
  int nstate = 0;
  PyObject *nstate_capi = Py_None;
    static char *capi_kwlist[] = {"rhs","psi","checksolution","nstate",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOO|O:libadflow.adjointapi.solveadjoint",\
        capi_kwlist,&rhs_capi,&psi_capi,&checksolution_capi,&nstate_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable rhs */
  ;
  capi_rhs_intent |= F2PY_INTENT_IN;
  capi_rhs_tmp = array_from_pyobj(NPY_DOUBLE,rhs_Dims,rhs_Rank,capi_rhs_intent,rhs_capi);
  if (capi_rhs_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `rhs' of libadflow.adjointapi.solveadjoint to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    rhs = (double *)(PyArray_DATA(capi_rhs_tmp));

  /* Processing variable checksolution */
    checksolution = (int)PyObject_IsTrue(checksolution_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable nstate */
  if (nstate_capi == Py_None) nstate = len(rhs); else
    f2py_success = int_from_pyobj(&nstate,nstate_capi,"libadflow.adjointapi.solveadjoint() 1st keyword (nstate) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(rhs)>=nstate,"len(rhs)>=nstate","1st keyword nstate","solveadjoint:nstate=%d",nstate) {
  /* Processing variable psi */
  psi_Dims[0]=nstate;
  capi_psi_intent |= F2PY_INTENT_IN;
  capi_psi_tmp = array_from_pyobj(NPY_DOUBLE,psi_Dims,psi_Rank,capi_psi_intent,psi_capi);
  if (capi_psi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `psi' of libadflow.adjointapi.solveadjoint to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    psi = (double *)(PyArray_DATA(capi_psi_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(rhs,psi,&checksolution,&nstate);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_psi_tmp!=psi_capi) {
    Py_XDECREF(capi_psi_tmp); }
  }  /*if (capi_psi_tmp == NULL) ... else of psi*/
  /* End of cleaning variable psi */
  } /*CHECKSCALAR(len(rhs)>=nstate)*/
  } /*if (f2py_success) of nstate*/
  /* End of cleaning variable nstate */
  } /*if (f2py_success) of checksolution*/
  /* End of cleaning variable checksolution */
  if((PyObject *)capi_rhs_tmp!=rhs_capi) {
    Py_XDECREF(capi_rhs_tmp); }
  }  /*if (capi_rhs_tmp == NULL) ... else of rhs*/
  /* End of cleaning variable rhs */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of solveadjoint ****************************/

/***************************** solveadjointforrhs *****************************/
static char doc_f2py_rout_libadflow_adjointapi_solveadjointforrhs[] = "\
outvec = solveadjointforrhs(invec,relativetolerance,[ndof])\n\nWrapper for ``solveadjointforrhs``.\
\n\nParameters\n----------\n"
"invec : input rank-1 array('d') with bounds (ndof)\n"
"relativetolerance : input float\n"
"\nOther Parameters\n----------------\n"
"ndof : input int, optional\n    Default: len(invec)\n"
"\nReturns\n-------\n"
"outvec : rank-1 array('d') with bounds (ndof)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_solveadjointforrhs(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *invec = NULL;
  npy_intp invec_Dims[1] = {-1};
  const int invec_Rank = 1;
  PyArrayObject *capi_invec_tmp = NULL;
  int capi_invec_intent = 0;
  PyObject *invec_capi = Py_None;
  double *outvec = NULL;
  npy_intp outvec_Dims[1] = {-1};
  const int outvec_Rank = 1;
  PyArrayObject *capi_outvec_tmp = NULL;
  int capi_outvec_intent = 0;
  int ndof = 0;
  PyObject *ndof_capi = Py_None;
  double relativetolerance = 0;
  PyObject *relativetolerance_capi = Py_None;
    static char *capi_kwlist[] = {"invec","relativetolerance","ndof",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.adjointapi.solveadjointforrhs",\
        capi_kwlist,&invec_capi,&relativetolerance_capi,&ndof_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable invec */
  ;
  capi_invec_intent |= F2PY_INTENT_IN;
  capi_invec_tmp = array_from_pyobj(NPY_DOUBLE,invec_Dims,invec_Rank,capi_invec_intent,invec_capi);
  if (capi_invec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `invec' of libadflow.adjointapi.solveadjointforrhs to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    invec = (double *)(PyArray_DATA(capi_invec_tmp));

  /* Processing variable relativetolerance */
    f2py_success = double_from_pyobj(&relativetolerance,relativetolerance_capi,"libadflow.adjointapi.solveadjointforrhs() 2nd argument (relativetolerance) can't be converted to double");
  if (f2py_success) {
  /* Processing variable ndof */
  if (ndof_capi == Py_None) ndof = len(invec); else
    f2py_success = int_from_pyobj(&ndof,ndof_capi,"libadflow.adjointapi.solveadjointforrhs() 1st keyword (ndof) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(invec)>=ndof,"len(invec)>=ndof","1st keyword ndof","solveadjointforrhs:ndof=%d",ndof) {
  /* Processing variable outvec */
  outvec_Dims[0]=ndof;
  capi_outvec_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_outvec_tmp = array_from_pyobj(NPY_DOUBLE,outvec_Dims,outvec_Rank,capi_outvec_intent,Py_None);
  if (capi_outvec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `outvec' of libadflow.adjointapi.solveadjointforrhs to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    outvec = (double *)(PyArray_DATA(capi_outvec_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(invec,outvec,&ndof,&relativetolerance);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_outvec_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_outvec_tmp == NULL) ... else of outvec*/
  /* End of cleaning variable outvec */
  } /*CHECKSCALAR(len(invec)>=ndof)*/
  } /*if (f2py_success) of ndof*/
  /* End of cleaning variable ndof */
  } /*if (f2py_success) of relativetolerance*/
  /* End of cleaning variable relativetolerance */
  if((PyObject *)capi_invec_tmp!=invec_capi) {
    Py_XDECREF(capi_invec_tmp); }
  }  /*if (capi_invec_tmp == NULL) ... else of invec*/
  /* End of cleaning variable invec */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************* end of solveadjointforrhs *************************/

/***************************** solvedirectforrhs *****************************/
static char doc_f2py_rout_libadflow_adjointapi_solvedirectforrhs[] = "\
outvec = solvedirectforrhs(invec,relativetolerance,[ndof])\n\nWrapper for ``solvedirectforrhs``.\
\n\nParameters\n----------\n"
"invec : input rank-1 array('d') with bounds (ndof)\n"
"relativetolerance : input float\n"
"\nOther Parameters\n----------------\n"
"ndof : input int, optional\n    Default: len(invec)\n"
"\nReturns\n-------\n"
"outvec : rank-1 array('d') with bounds (ndof)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_solvedirectforrhs(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *invec = NULL;
  npy_intp invec_Dims[1] = {-1};
  const int invec_Rank = 1;
  PyArrayObject *capi_invec_tmp = NULL;
  int capi_invec_intent = 0;
  PyObject *invec_capi = Py_None;
  double *outvec = NULL;
  npy_intp outvec_Dims[1] = {-1};
  const int outvec_Rank = 1;
  PyArrayObject *capi_outvec_tmp = NULL;
  int capi_outvec_intent = 0;
  int ndof = 0;
  PyObject *ndof_capi = Py_None;
  double relativetolerance = 0;
  PyObject *relativetolerance_capi = Py_None;
    static char *capi_kwlist[] = {"invec","relativetolerance","ndof",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.adjointapi.solvedirectforrhs",\
        capi_kwlist,&invec_capi,&relativetolerance_capi,&ndof_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable invec */
  ;
  capi_invec_intent |= F2PY_INTENT_IN;
  capi_invec_tmp = array_from_pyobj(NPY_DOUBLE,invec_Dims,invec_Rank,capi_invec_intent,invec_capi);
  if (capi_invec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `invec' of libadflow.adjointapi.solvedirectforrhs to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    invec = (double *)(PyArray_DATA(capi_invec_tmp));

  /* Processing variable relativetolerance */
    f2py_success = double_from_pyobj(&relativetolerance,relativetolerance_capi,"libadflow.adjointapi.solvedirectforrhs() 2nd argument (relativetolerance) can't be converted to double");
  if (f2py_success) {
  /* Processing variable ndof */
  if (ndof_capi == Py_None) ndof = len(invec); else
    f2py_success = int_from_pyobj(&ndof,ndof_capi,"libadflow.adjointapi.solvedirectforrhs() 1st keyword (ndof) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(invec)>=ndof,"len(invec)>=ndof","1st keyword ndof","solvedirectforrhs:ndof=%d",ndof) {
  /* Processing variable outvec */
  outvec_Dims[0]=ndof;
  capi_outvec_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_outvec_tmp = array_from_pyobj(NPY_DOUBLE,outvec_Dims,outvec_Rank,capi_outvec_intent,Py_None);
  if (capi_outvec_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `outvec' of libadflow.adjointapi.solvedirectforrhs to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    outvec = (double *)(PyArray_DATA(capi_outvec_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(invec,outvec,&ndof,&relativetolerance);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_outvec_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_outvec_tmp == NULL) ... else of outvec*/
  /* End of cleaning variable outvec */
  } /*CHECKSCALAR(len(invec)>=ndof)*/
  } /*if (f2py_success) of ndof*/
  /* End of cleaning variable ndof */
  } /*if (f2py_success) of relativetolerance*/
  /* End of cleaning variable relativetolerance */
  if((PyObject *)capi_invec_tmp!=invec_capi) {
    Py_XDECREF(capi_invec_tmp); }
  }  /*if (capi_invec_tmp == NULL) ... else of invec*/
  /* End of cleaning variable invec */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of solvedirectforrhs **************************/

/***************************** saveadjointmatrix *****************************/
static char doc_f2py_rout_libadflow_adjointapi_saveadjointmatrix[] = "\
saveadjointmatrix(filename)\n\nWrapper for ``saveadjointmatrix``.\
\n\nParameters\n----------\n"
"filename : input string(len=-1)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_saveadjointmatrix(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
    static char *capi_kwlist[] = {"filename",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.adjointapi.saveadjointmatrix",\
        capi_kwlist,&filename_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 1st argument `filename' of libadflow.adjointapi.saveadjointmatrix to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(filename,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of saveadjointmatrix **************************/

/******************************* saveadjointpc *******************************/
static char doc_f2py_rout_libadflow_adjointapi_saveadjointpc[] = "\
saveadjointpc(filename)\n\nWrapper for ``saveadjointpc``.\
\n\nParameters\n----------\n"
"filename : input string(len=-1)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_saveadjointpc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
    static char *capi_kwlist[] = {"filename",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.adjointapi.saveadjointpc",\
        capi_kwlist,&filename_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 1st argument `filename' of libadflow.adjointapi.saveadjointpc to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(filename,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of saveadjointpc ****************************/

/******************************* saveadjointrhs *******************************/
static char doc_f2py_rout_libadflow_adjointapi_saveadjointrhs[] = "\
saveadjointrhs(rhs,filename,[nstate])\n\nWrapper for ``saveadjointrhs``.\
\n\nParameters\n----------\n"
"rhs : input rank-1 array('d') with bounds (nstate)\n"
"filename : input string(len=-1)\n"
"\nOther Parameters\n----------------\n"
"nstate : input int, optional\n    Default: len(rhs)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_saveadjointrhs(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,string,int*,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *rhs = NULL;
  npy_intp rhs_Dims[1] = {-1};
  const int rhs_Rank = 1;
  PyArrayObject *capi_rhs_tmp = NULL;
  int capi_rhs_intent = 0;
  PyObject *rhs_capi = Py_None;
  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
  int nstate = 0;
  PyObject *nstate_capi = Py_None;
    static char *capi_kwlist[] = {"rhs","filename","nstate",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.adjointapi.saveadjointrhs",\
        capi_kwlist,&rhs_capi,&filename_capi,&nstate_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable rhs */
  ;
  capi_rhs_intent |= F2PY_INTENT_IN;
  capi_rhs_tmp = array_from_pyobj(NPY_DOUBLE,rhs_Dims,rhs_Rank,capi_rhs_intent,rhs_capi);
  if (capi_rhs_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `rhs' of libadflow.adjointapi.saveadjointrhs to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    rhs = (double *)(PyArray_DATA(capi_rhs_tmp));

  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 2nd argument `filename' of libadflow.adjointapi.saveadjointrhs to C string");
  if (f2py_success) {
  /* Processing variable nstate */
  if (nstate_capi == Py_None) nstate = len(rhs); else
    f2py_success = int_from_pyobj(&nstate,nstate_capi,"libadflow.adjointapi.saveadjointrhs() 1st keyword (nstate) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(rhs)>=nstate,"len(rhs)>=nstate","1st keyword nstate","saveadjointrhs:nstate=%d",nstate) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(rhs,filename,&nstate,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(rhs)>=nstate)*/
  } /*if (f2py_success) of nstate*/
  /* End of cleaning variable nstate */
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
  if((PyObject *)capi_rhs_tmp!=rhs_capi) {
    Py_XDECREF(capi_rhs_tmp); }
  }  /*if (capi_rhs_tmp == NULL) ... else of rhs*/
  /* End of cleaning variable rhs */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of saveadjointrhs ***************************/

/****************************** savecellcenters ******************************/
static char doc_f2py_rout_libadflow_adjointapi_savecellcenters[] = "\
savecellcenters(filename)\n\nWrapper for ``savecellcenters``.\
\n\nParameters\n----------\n"
"filename : input string(len=-1)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_savecellcenters(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
    static char *capi_kwlist[] = {"filename",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.adjointapi.savecellcenters",\
        capi_kwlist,&filename_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 1st argument `filename' of libadflow.adjointapi.savecellcenters to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(filename,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of savecellcenters ***************************/

/************************* spectralprecscribedmotion *************************/
static char doc_f2py_rout_libadflow_adjointapi_spectralprecscribedmotion[] = "\
dxv = spectralprecscribedmotion(input,nout,[nin])\n\nWrapper for ``spectralprecscribedmotion``.\
\n\nParameters\n----------\n"
"input : input rank-1 array('d') with bounds (nin)\n"
"nout : input int\n"
"\nOther Parameters\n----------------\n"
"nin : input int, optional\n    Default: len(input)\n"
"\nReturns\n-------\n"
"dxv : rank-1 array('d') with bounds (nout)";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_spectralprecscribedmotion(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *input = NULL;
  npy_intp input_Dims[1] = {-1};
  const int input_Rank = 1;
  PyArrayObject *capi_input_tmp = NULL;
  int capi_input_intent = 0;
  PyObject *input_capi = Py_None;
  int nin = 0;
  PyObject *nin_capi = Py_None;
  double *dxv = NULL;
  npy_intp dxv_Dims[1] = {-1};
  const int dxv_Rank = 1;
  PyArrayObject *capi_dxv_tmp = NULL;
  int capi_dxv_intent = 0;
  int nout = 0;
  PyObject *nout_capi = Py_None;
    static char *capi_kwlist[] = {"input","nout","nin",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|O:libadflow.adjointapi.spectralprecscribedmotion",\
        capi_kwlist,&input_capi,&nout_capi,&nin_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable input */
  ;
  capi_input_intent |= F2PY_INTENT_IN;
  capi_input_tmp = array_from_pyobj(NPY_DOUBLE,input_Dims,input_Rank,capi_input_intent,input_capi);
  if (capi_input_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `input' of libadflow.adjointapi.spectralprecscribedmotion to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    input = (double *)(PyArray_DATA(capi_input_tmp));

  /* Processing variable nout */
    f2py_success = int_from_pyobj(&nout,nout_capi,"libadflow.adjointapi.spectralprecscribedmotion() 2nd argument (nout) can't be converted to int");
  if (f2py_success) {
  /* Processing variable nin */
  if (nin_capi == Py_None) nin = len(input); else
    f2py_success = int_from_pyobj(&nin,nin_capi,"libadflow.adjointapi.spectralprecscribedmotion() 1st keyword (nin) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(input)>=nin,"len(input)>=nin","1st keyword nin","spectralprecscribedmotion:nin=%d",nin) {
  /* Processing variable dxv */
  dxv_Dims[0]=nout;
  capi_dxv_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_dxv_tmp = array_from_pyobj(NPY_DOUBLE,dxv_Dims,dxv_Rank,capi_dxv_intent,Py_None);
  if (capi_dxv_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `dxv' of libadflow.adjointapi.spectralprecscribedmotion to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxv = (double *)(PyArray_DATA(capi_dxv_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(input,&nin,dxv,&nout);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_dxv_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_dxv_tmp == NULL) ... else of dxv*/
  /* End of cleaning variable dxv */
  } /*CHECKSCALAR(len(input)>=nin)*/
  } /*if (f2py_success) of nin*/
  /* End of cleaning variable nin */
  } /*if (f2py_success) of nout*/
  /* End of cleaning variable nout */
  if((PyObject *)capi_input_tmp!=input_capi) {
    Py_XDECREF(capi_input_tmp); }
  }  /*if (capi_input_tmp == NULL) ... else of input*/
  /* End of cleaning variable input */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************** end of spectralprecscribedmotion **********************/

/****************************** createpetscvars ******************************/
static char doc_f2py_rout_libadflow_adjointapi_createpetscvars[] = "\
createpetscvars()\n\nWrapper for ``createpetscvars``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_adjointapi_createpetscvars(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.adjointapi.createpetscvars",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of createpetscvars ***************************/

/************************ computematrixfreeproductfwd ************************/
static char doc_f2py_rout_libadflow_adjointapi_computematrixfreeproductfwd[] = "\
dwdot,funcsdot,fdot = computematrixfreeproductfwd(xvdot,extradot,wdot,bcdatavaluesdot,usespatial,usestate,famlists,bcdatanames,bcdatavalues,bcdatafamlists,bcvarsempty,costsize,fsize,ntime)\n\nWrapper for ``computematrixfreeproductfwd``.\
\n\nParameters\n----------\n"
"xvdot : input rank-1 array('d') with bounds (f2py_xvdot_d0)\n"
"extradot : input rank-1 array('d') with bounds (f2py_extradot_d0)\n"
"wdot : input rank-1 array('d') with bounds (f2py_wdot_d0)\n"
"bcdatavaluesdot : input rank-1 array('d') with bounds (f2py_bcdatavaluesdot_d0)\n"
"usespatial : input int\n"
"usestate : input int\n"
"famlists : input rank-2 array('i') with bounds (f2py_famlists_d0,f2py_famlists_d1)\n"
"bcdatanames : input rank-2 array('S') with bounds (f2py_bcdatanames_d0,f2py_bcdatanames_d1)\n"
"bcdatavalues : input rank-1 array('d') with bounds (f2py_bcdatavalues_d0)\n"
"bcdatafamlists : input rank-2 array('i') with bounds (f2py_bcdatafamlists_d0,f2py_bcdatafamlists_d1)\n"
"bcvarsempty : input int\n"
"costsize : input int\n"
"fsize : input int\n"
"ntime : input int\n"
"\nReturns\n-------\n"
"dwdot : rank-1 array('d') with bounds (size(wdot))\n"
"funcsdot : rank-2 array('d') with bounds (costsize,size(famlists,1))\n"
"fdot : rank-3 array('d') with bounds (3,fsize,ntime)";
/* #declfortranroutine# */
static PyObject *f2py_rout_libadflow_adjointapi_computematrixfreeproductfwd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,int*,int*,int*,string*,double*,int*,int*,double*,double*,double*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *xvdot = NULL;
  npy_intp xvdot_Dims[1] = {-1};
  const int xvdot_Rank = 1;
  PyArrayObject *capi_xvdot_tmp = NULL;
  int capi_xvdot_intent = 0;
  PyObject *xvdot_capi = Py_None;
  double *extradot = NULL;
  npy_intp extradot_Dims[1] = {-1};
  const int extradot_Rank = 1;
  PyArrayObject *capi_extradot_tmp = NULL;
  int capi_extradot_intent = 0;
  PyObject *extradot_capi = Py_None;
  double *wdot = NULL;
  npy_intp wdot_Dims[1] = {-1};
  const int wdot_Rank = 1;
  PyArrayObject *capi_wdot_tmp = NULL;
  int capi_wdot_intent = 0;
  PyObject *wdot_capi = Py_None;
  double *bcdatavaluesdot = NULL;
  npy_intp bcdatavaluesdot_Dims[1] = {-1};
  const int bcdatavaluesdot_Rank = 1;
  PyArrayObject *capi_bcdatavaluesdot_tmp = NULL;
  int capi_bcdatavaluesdot_intent = 0;
  PyObject *bcdatavaluesdot_capi = Py_None;
  int usespatial = 0;
  PyObject *usespatial_capi = Py_None;
  int usestate = 0;
  PyObject *usestate_capi = Py_None;
  int *famlists = NULL;
  npy_intp famlists_Dims[2] = {-1, -1};
  const int famlists_Rank = 2;
  PyArrayObject *capi_famlists_tmp = NULL;
  int capi_famlists_intent = 0;
  PyObject *famlists_capi = Py_None;
  string *bcdatanames = NULL;
  npy_intp bcdatanames_Dims[2] = {-1, -1};
  const int bcdatanames_Rank = 2;
  PyArrayObject *capi_bcdatanames_tmp = NULL;
  int capi_bcdatanames_intent = 0;
  PyObject *bcdatanames_capi = Py_None;
  double *bcdatavalues = NULL;
  npy_intp bcdatavalues_Dims[1] = {-1};
  const int bcdatavalues_Rank = 1;
  PyArrayObject *capi_bcdatavalues_tmp = NULL;
  int capi_bcdatavalues_intent = 0;
  PyObject *bcdatavalues_capi = Py_None;
  int *bcdatafamlists = NULL;
  npy_intp bcdatafamlists_Dims[2] = {-1, -1};
  const int bcdatafamlists_Rank = 2;
  PyArrayObject *capi_bcdatafamlists_tmp = NULL;
  int capi_bcdatafamlists_intent = 0;
  PyObject *bcdatafamlists_capi = Py_None;
  int bcvarsempty = 0;
  PyObject *bcvarsempty_capi = Py_None;
  double *dwdot = NULL;
  npy_intp dwdot_Dims[1] = {-1};
  const int dwdot_Rank = 1;
  PyArrayObject *capi_dwdot_tmp = NULL;
  int capi_dwdot_intent = 0;
  double *funcsdot = NULL;
  npy_intp funcsdot_Dims[2] = {-1, -1};
  const int funcsdot_Rank = 2;
  PyArrayObject *capi_funcsdot_tmp = NULL;
  int capi_funcsdot_intent = 0;
  double *fdot = NULL;
  npy_intp fdot_Dims[3] = {-1, -1, -1};
  const int fdot_Rank = 3;
  PyArrayObject *capi_fdot_tmp = NULL;
  int capi_fdot_intent = 0;
  int costsize = 0;
  PyObject *costsize_capi = Py_None;
  int fsize = 0;
  PyObject *fsize_capi = Py_None;
  int ntime = 0;
  PyObject *ntime_capi = Py_None;
  int f2py_xvdot_d0 = 0;
  int f2py_extradot_d0 = 0;
  int f2py_wdot_d0 = 0;
  int f2py_bcdatavaluesdot_d0 = 0;
  int f2py_famlists_d0 = 0;
  int f2py_famlists_d1 = 0;
  int f2py_bcdatanames_d0 = 0;
  int f2py_bcdatanames_d1 = 0;
  int f2py_bcdatavalues_d0 = 0;
  int f2py_bcdatafamlists_d0 = 0;
  int f2py_bcdatafamlists_d1 = 0;
    static char *capi_kwlist[] = {"xvdot","extradot","wdot","bcdatavaluesdot","usespatial","usestate","famlists","bcdatanames","bcdatavalues","bcdatafamlists","bcvarsempty","costsize","fsize","ntime",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOOOOOOOOO|:libadflow.adjointapi.computematrixfreeproductfwd",\
        capi_kwlist,&xvdot_capi,&extradot_capi,&wdot_capi,&bcdatavaluesdot_capi,&usespatial_capi,&usestate_capi,&famlists_capi,&bcdatanames_capi,&bcdatavalues_capi,&bcdatafamlists_capi,&bcvarsempty_capi,&costsize_capi,&fsize_capi,&ntime_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable xvdot */
  ;
  capi_xvdot_intent |= F2PY_INTENT_IN;
  capi_xvdot_tmp = array_from_pyobj(NPY_DOUBLE,xvdot_Dims,xvdot_Rank,capi_xvdot_intent,xvdot_capi);
  if (capi_xvdot_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `xvdot' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    xvdot = (double *)(PyArray_DATA(capi_xvdot_tmp));

  /* Processing variable extradot */
  ;
  capi_extradot_intent |= F2PY_INTENT_IN;
  capi_extradot_tmp = array_from_pyobj(NPY_DOUBLE,extradot_Dims,extradot_Rank,capi_extradot_intent,extradot_capi);
  if (capi_extradot_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `extradot' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    extradot = (double *)(PyArray_DATA(capi_extradot_tmp));

  /* Processing variable wdot */
  ;
  capi_wdot_intent |= F2PY_INTENT_IN;
  capi_wdot_tmp = array_from_pyobj(NPY_DOUBLE,wdot_Dims,wdot_Rank,capi_wdot_intent,wdot_capi);
  if (capi_wdot_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `wdot' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    wdot = (double *)(PyArray_DATA(capi_wdot_tmp));

  /* Processing variable bcdatavaluesdot */
  ;
  capi_bcdatavaluesdot_intent |= F2PY_INTENT_IN;
  capi_bcdatavaluesdot_tmp = array_from_pyobj(NPY_DOUBLE,bcdatavaluesdot_Dims,bcdatavaluesdot_Rank,capi_bcdatavaluesdot_intent,bcdatavaluesdot_capi);
  if (capi_bcdatavaluesdot_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 4th argument `bcdatavaluesdot' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatavaluesdot = (double *)(PyArray_DATA(capi_bcdatavaluesdot_tmp));

  /* Processing variable usespatial */
    usespatial = (int)PyObject_IsTrue(usespatial_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable usestate */
    usestate = (int)PyObject_IsTrue(usestate_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable famlists */
  ;
  capi_famlists_intent |= F2PY_INTENT_IN;
  capi_famlists_tmp = array_from_pyobj(NPY_INT,famlists_Dims,famlists_Rank,capi_famlists_intent,famlists_capi);
  if (capi_famlists_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 7th argument `famlists' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlists = (int *)(PyArray_DATA(capi_famlists_tmp));

  /* Processing variable bcdatanames */
  ;
  capi_bcdatanames_intent |= F2PY_INTENT_IN;
  capi_bcdatanames_tmp = array_from_pyobj(NPY_STRING,bcdatanames_Dims,bcdatanames_Rank,capi_bcdatanames_intent,bcdatanames_capi);
  if (capi_bcdatanames_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 8th argument `bcdatanames' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatanames = (string *)(PyArray_DATA(capi_bcdatanames_tmp));

  /* Processing variable bcdatavalues */
  ;
  capi_bcdatavalues_intent |= F2PY_INTENT_IN;
  capi_bcdatavalues_tmp = array_from_pyobj(NPY_DOUBLE,bcdatavalues_Dims,bcdatavalues_Rank,capi_bcdatavalues_intent,bcdatavalues_capi);
  if (capi_bcdatavalues_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 9th argument `bcdatavalues' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatavalues = (double *)(PyArray_DATA(capi_bcdatavalues_tmp));

  /* Processing variable bcdatafamlists */
  ;
  capi_bcdatafamlists_intent |= F2PY_INTENT_IN;
  capi_bcdatafamlists_tmp = array_from_pyobj(NPY_INT,bcdatafamlists_Dims,bcdatafamlists_Rank,capi_bcdatafamlists_intent,bcdatafamlists_capi);
  if (capi_bcdatafamlists_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 10th argument `bcdatafamlists' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatafamlists = (int *)(PyArray_DATA(capi_bcdatafamlists_tmp));

  /* Processing variable bcvarsempty */
    bcvarsempty = (int)PyObject_IsTrue(bcvarsempty_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable costsize */
    f2py_success = int_from_pyobj(&costsize,costsize_capi,"libadflow.adjointapi.computematrixfreeproductfwd() 12nd argument (costsize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable fsize */
    f2py_success = int_from_pyobj(&fsize,fsize_capi,"libadflow.adjointapi.computematrixfreeproductfwd() 13rd argument (fsize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ntime */
    f2py_success = int_from_pyobj(&ntime,ntime_capi,"libadflow.adjointapi.computematrixfreeproductfwd() 14th argument (ntime) can't be converted to int");
  if (f2py_success) {
  /* Processing variable dwdot */
  dwdot_Dims[0]=size(wdot);
  capi_dwdot_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_dwdot_tmp = array_from_pyobj(NPY_DOUBLE,dwdot_Dims,dwdot_Rank,capi_dwdot_intent,Py_None);
  if (capi_dwdot_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `dwdot' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dwdot = (double *)(PyArray_DATA(capi_dwdot_tmp));

  /* Processing variable funcsdot */
  funcsdot_Dims[0]=costsize,funcsdot_Dims[1]=size(famlists,1);
  capi_funcsdot_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_funcsdot_tmp = array_from_pyobj(NPY_DOUBLE,funcsdot_Dims,funcsdot_Rank,capi_funcsdot_intent,Py_None);
  if (capi_funcsdot_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `funcsdot' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    funcsdot = (double *)(PyArray_DATA(capi_funcsdot_tmp));

  /* Processing variable fdot */
  fdot_Dims[0]=3,fdot_Dims[1]=fsize,fdot_Dims[2]=ntime;
  capi_fdot_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_fdot_tmp = array_from_pyobj(NPY_DOUBLE,fdot_Dims,fdot_Rank,capi_fdot_intent,Py_None);
  if (capi_fdot_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `fdot' of libadflow.adjointapi.computematrixfreeproductfwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    fdot = (double *)(PyArray_DATA(capi_fdot_tmp));

  /* Processing variable f2py_xvdot_d0 */
  f2py_xvdot_d0 = shape(xvdot, 0);
  /* Processing variable f2py_extradot_d0 */
  f2py_extradot_d0 = shape(extradot, 0);
  /* Processing variable f2py_wdot_d0 */
  f2py_wdot_d0 = shape(wdot, 0);
  /* Processing variable f2py_bcdatavaluesdot_d0 */
  f2py_bcdatavaluesdot_d0 = shape(bcdatavaluesdot, 0);
  /* Processing variable f2py_famlists_d0 */
  f2py_famlists_d0 = shape(famlists, 0);
  /* Processing variable f2py_famlists_d1 */
  f2py_famlists_d1 = shape(famlists, 1);
  /* Processing variable f2py_bcdatanames_d0 */
  f2py_bcdatanames_d0 = shape(bcdatanames, 0);
  /* Processing variable f2py_bcdatanames_d1 */
  f2py_bcdatanames_d1 = shape(bcdatanames, 1);
  /* Processing variable f2py_bcdatavalues_d0 */
  f2py_bcdatavalues_d0 = shape(bcdatavalues, 0);
  /* Processing variable f2py_bcdatafamlists_d0 */
  f2py_bcdatafamlists_d0 = shape(bcdatafamlists, 0);
  /* Processing variable f2py_bcdatafamlists_d1 */
  f2py_bcdatafamlists_d1 = shape(bcdatafamlists, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(xvdot,extradot,wdot,bcdatavaluesdot,&usespatial,&usestate,famlists,bcdatanames,bcdatavalues,bcdatafamlists,&bcvarsempty,dwdot,funcsdot,fdot,&costsize,&fsize,&ntime,&f2py_xvdot_d0,&f2py_extradot_d0,&f2py_wdot_d0,&f2py_bcdatavaluesdot_d0,&f2py_famlists_d0,&f2py_famlists_d1,&f2py_bcdatanames_d0,&f2py_bcdatanames_d1,&f2py_bcdatavalues_d0,&f2py_bcdatafamlists_d0,&f2py_bcdatafamlists_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("NNN",capi_dwdot_tmp,capi_funcsdot_tmp,capi_fdot_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_bcdatafamlists_d1 */
  /* End of cleaning variable f2py_bcdatafamlists_d0 */
  /* End of cleaning variable f2py_bcdatavalues_d0 */
  /* End of cleaning variable f2py_bcdatanames_d1 */
  /* End of cleaning variable f2py_bcdatanames_d0 */
  /* End of cleaning variable f2py_famlists_d1 */
  /* End of cleaning variable f2py_famlists_d0 */
  /* End of cleaning variable f2py_bcdatavaluesdot_d0 */
  /* End of cleaning variable f2py_wdot_d0 */
  /* End of cleaning variable f2py_extradot_d0 */
  /* End of cleaning variable f2py_xvdot_d0 */
  }  /*if (capi_fdot_tmp == NULL) ... else of fdot*/
  /* End of cleaning variable fdot */
  }  /*if (capi_funcsdot_tmp == NULL) ... else of funcsdot*/
  /* End of cleaning variable funcsdot */
  }  /*if (capi_dwdot_tmp == NULL) ... else of dwdot*/
  /* End of cleaning variable dwdot */
  } /*if (f2py_success) of ntime*/
  /* End of cleaning variable ntime */
  } /*if (f2py_success) of fsize*/
  /* End of cleaning variable fsize */
  } /*if (f2py_success) of costsize*/
  /* End of cleaning variable costsize */
  } /*if (f2py_success) of bcvarsempty*/
  /* End of cleaning variable bcvarsempty */
  if((PyObject *)capi_bcdatafamlists_tmp!=bcdatafamlists_capi) {
    Py_XDECREF(capi_bcdatafamlists_tmp); }
  }  /*if (capi_bcdatafamlists_tmp == NULL) ... else of bcdatafamlists*/
  /* End of cleaning variable bcdatafamlists */
  if((PyObject *)capi_bcdatavalues_tmp!=bcdatavalues_capi) {
    Py_XDECREF(capi_bcdatavalues_tmp); }
  }  /*if (capi_bcdatavalues_tmp == NULL) ... else of bcdatavalues*/
  /* End of cleaning variable bcdatavalues */
  if((PyObject *)capi_bcdatanames_tmp!=bcdatanames_capi) {
    Py_XDECREF(capi_bcdatanames_tmp); }
  }  /*if (capi_bcdatanames_tmp == NULL) ... else of bcdatanames*/
  /* End of cleaning variable bcdatanames */
  if((PyObject *)capi_famlists_tmp!=famlists_capi) {
    Py_XDECREF(capi_famlists_tmp); }
  }  /*if (capi_famlists_tmp == NULL) ... else of famlists*/
  /* End of cleaning variable famlists */
  } /*if (f2py_success) of usestate*/
  /* End of cleaning variable usestate */
  } /*if (f2py_success) of usespatial*/
  /* End of cleaning variable usespatial */
  if((PyObject *)capi_bcdatavaluesdot_tmp!=bcdatavaluesdot_capi) {
    Py_XDECREF(capi_bcdatavaluesdot_tmp); }
  }  /*if (capi_bcdatavaluesdot_tmp == NULL) ... else of bcdatavaluesdot*/
  /* End of cleaning variable bcdatavaluesdot */
  if((PyObject *)capi_wdot_tmp!=wdot_capi) {
    Py_XDECREF(capi_wdot_tmp); }
  }  /*if (capi_wdot_tmp == NULL) ... else of wdot*/
  /* End of cleaning variable wdot */
  if((PyObject *)capi_extradot_tmp!=extradot_capi) {
    Py_XDECREF(capi_extradot_tmp); }
  }  /*if (capi_extradot_tmp == NULL) ... else of extradot*/
  /* End of cleaning variable extradot */
  if((PyObject *)capi_xvdot_tmp!=xvdot_capi) {
    Py_XDECREF(capi_xvdot_tmp); }
  }  /*if (capi_xvdot_tmp == NULL) ... else of xvdot*/
  /* End of cleaning variable xvdot */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************* end of computematrixfreeproductfwd *********************/

/************************ computematrixfreeproductbwd ************************/
static char doc_f2py_rout_libadflow_adjointapi_computematrixfreeproductbwd[] = "\
xvbar,extrabar,wbar,bcdatavaluesbar = computematrixfreeproductbwd(dwbar,funcsbar,fbar,usespatial,usestate,spatialsize,extrasize,statesize,famlists,bcdatanames,bcdatavalues,bcdatafamlists,bcvarsempty)\n\nWrapper for ``computematrixfreeproductbwd``.\
\n\nParameters\n----------\n"
"dwbar : input rank-1 array('d') with bounds (f2py_dwbar_d0)\n"
"funcsbar : input rank-2 array('d') with bounds (f2py_funcsbar_d0,f2py_funcsbar_d1)\n"
"fbar : input rank-3 array('d') with bounds (f2py_fbar_d0,f2py_fbar_d1,f2py_fbar_d2)\n"
"usespatial : input int\n"
"usestate : input int\n"
"spatialsize : input int\n"
"extrasize : input int\n"
"statesize : input int\n"
"famlists : input rank-2 array('i') with bounds (f2py_famlists_d0,f2py_famlists_d1)\n"
"bcdatanames : input rank-2 array('S') with bounds (f2py_bcdatanames_d0,f2py_bcdatanames_d1)\n"
"bcdatavalues : input rank-1 array('d') with bounds (f2py_bcdatavalues_d0)\n"
"bcdatafamlists : input rank-2 array('i') with bounds (f2py_bcdatafamlists_d0,f2py_bcdatafamlists_d1)\n"
"bcvarsempty : input int\n"
"\nReturns\n-------\n"
"xvbar : rank-1 array('d') with bounds (spatialsize)\n"
"extrabar : rank-1 array('d') with bounds (extrasize)\n"
"wbar : rank-1 array('d') with bounds (statesize)\n"
"bcdatavaluesbar : rank-1 array('d') with bounds (size(bcdatavalues))";
/* #declfortranroutine# */
static PyObject *f2py_rout_libadflow_adjointapi_computematrixfreeproductbwd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*,double*,double*,double*,int*,int*,int*,int*,string*,double*,double*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *dwbar = NULL;
  npy_intp dwbar_Dims[1] = {-1};
  const int dwbar_Rank = 1;
  PyArrayObject *capi_dwbar_tmp = NULL;
  int capi_dwbar_intent = 0;
  PyObject *dwbar_capi = Py_None;
  double *funcsbar = NULL;
  npy_intp funcsbar_Dims[2] = {-1, -1};
  const int funcsbar_Rank = 2;
  PyArrayObject *capi_funcsbar_tmp = NULL;
  int capi_funcsbar_intent = 0;
  PyObject *funcsbar_capi = Py_None;
  double *fbar = NULL;
  npy_intp fbar_Dims[3] = {-1, -1, -1};
  const int fbar_Rank = 3;
  PyArrayObject *capi_fbar_tmp = NULL;
  int capi_fbar_intent = 0;
  PyObject *fbar_capi = Py_None;
  int usespatial = 0;
  PyObject *usespatial_capi = Py_None;
  int usestate = 0;
  PyObject *usestate_capi = Py_None;
  double *xvbar = NULL;
  npy_intp xvbar_Dims[1] = {-1};
  const int xvbar_Rank = 1;
  PyArrayObject *capi_xvbar_tmp = NULL;
  int capi_xvbar_intent = 0;
  double *extrabar = NULL;
  npy_intp extrabar_Dims[1] = {-1};
  const int extrabar_Rank = 1;
  PyArrayObject *capi_extrabar_tmp = NULL;
  int capi_extrabar_intent = 0;
  double *wbar = NULL;
  npy_intp wbar_Dims[1] = {-1};
  const int wbar_Rank = 1;
  PyArrayObject *capi_wbar_tmp = NULL;
  int capi_wbar_intent = 0;
  int spatialsize = 0;
  PyObject *spatialsize_capi = Py_None;
  int extrasize = 0;
  PyObject *extrasize_capi = Py_None;
  int statesize = 0;
  PyObject *statesize_capi = Py_None;
  int *famlists = NULL;
  npy_intp famlists_Dims[2] = {-1, -1};
  const int famlists_Rank = 2;
  PyArrayObject *capi_famlists_tmp = NULL;
  int capi_famlists_intent = 0;
  PyObject *famlists_capi = Py_None;
  string *bcdatanames = NULL;
  npy_intp bcdatanames_Dims[2] = {-1, -1};
  const int bcdatanames_Rank = 2;
  PyArrayObject *capi_bcdatanames_tmp = NULL;
  int capi_bcdatanames_intent = 0;
  PyObject *bcdatanames_capi = Py_None;
  double *bcdatavalues = NULL;
  npy_intp bcdatavalues_Dims[1] = {-1};
  const int bcdatavalues_Rank = 1;
  PyArrayObject *capi_bcdatavalues_tmp = NULL;
  int capi_bcdatavalues_intent = 0;
  PyObject *bcdatavalues_capi = Py_None;
  double *bcdatavaluesbar = NULL;
  npy_intp bcdatavaluesbar_Dims[1] = {-1};
  const int bcdatavaluesbar_Rank = 1;
  PyArrayObject *capi_bcdatavaluesbar_tmp = NULL;
  int capi_bcdatavaluesbar_intent = 0;
  int *bcdatafamlists = NULL;
  npy_intp bcdatafamlists_Dims[2] = {-1, -1};
  const int bcdatafamlists_Rank = 2;
  PyArrayObject *capi_bcdatafamlists_tmp = NULL;
  int capi_bcdatafamlists_intent = 0;
  PyObject *bcdatafamlists_capi = Py_None;
  int bcvarsempty = 0;
  PyObject *bcvarsempty_capi = Py_None;
  int f2py_dwbar_d0 = 0;
  int f2py_funcsbar_d0 = 0;
  int f2py_funcsbar_d1 = 0;
  int f2py_fbar_d0 = 0;
  int f2py_fbar_d1 = 0;
  int f2py_fbar_d2 = 0;
  int f2py_famlists_d0 = 0;
  int f2py_famlists_d1 = 0;
  int f2py_bcdatanames_d0 = 0;
  int f2py_bcdatanames_d1 = 0;
  int f2py_bcdatavalues_d0 = 0;
  int f2py_bcdatafamlists_d0 = 0;
  int f2py_bcdatafamlists_d1 = 0;
    static char *capi_kwlist[] = {"dwbar","funcsbar","fbar","usespatial","usestate","spatialsize","extrasize","statesize","famlists","bcdatanames","bcdatavalues","bcdatafamlists","bcvarsempty",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOOOOOOOO|:libadflow.adjointapi.computematrixfreeproductbwd",\
        capi_kwlist,&dwbar_capi,&funcsbar_capi,&fbar_capi,&usespatial_capi,&usestate_capi,&spatialsize_capi,&extrasize_capi,&statesize_capi,&famlists_capi,&bcdatanames_capi,&bcdatavalues_capi,&bcdatafamlists_capi,&bcvarsempty_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable dwbar */
  ;
  capi_dwbar_intent |= F2PY_INTENT_IN;
  capi_dwbar_tmp = array_from_pyobj(NPY_DOUBLE,dwbar_Dims,dwbar_Rank,capi_dwbar_intent,dwbar_capi);
  if (capi_dwbar_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `dwbar' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dwbar = (double *)(PyArray_DATA(capi_dwbar_tmp));

  /* Processing variable funcsbar */
  ;
  capi_funcsbar_intent |= F2PY_INTENT_IN;
  capi_funcsbar_tmp = array_from_pyobj(NPY_DOUBLE,funcsbar_Dims,funcsbar_Rank,capi_funcsbar_intent,funcsbar_capi);
  if (capi_funcsbar_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 2nd argument `funcsbar' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    funcsbar = (double *)(PyArray_DATA(capi_funcsbar_tmp));

  /* Processing variable fbar */
  ;
  capi_fbar_intent |= F2PY_INTENT_IN;
  capi_fbar_tmp = array_from_pyobj(NPY_DOUBLE,fbar_Dims,fbar_Rank,capi_fbar_intent,fbar_capi);
  if (capi_fbar_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 3rd argument `fbar' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    fbar = (double *)(PyArray_DATA(capi_fbar_tmp));

  /* Processing variable usespatial */
    usespatial = (int)PyObject_IsTrue(usespatial_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable usestate */
    usestate = (int)PyObject_IsTrue(usestate_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable spatialsize */
    f2py_success = int_from_pyobj(&spatialsize,spatialsize_capi,"libadflow.adjointapi.computematrixfreeproductbwd() 6th argument (spatialsize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable extrasize */
    f2py_success = int_from_pyobj(&extrasize,extrasize_capi,"libadflow.adjointapi.computematrixfreeproductbwd() 7th argument (extrasize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable statesize */
    f2py_success = int_from_pyobj(&statesize,statesize_capi,"libadflow.adjointapi.computematrixfreeproductbwd() 8th argument (statesize) can't be converted to int");
  if (f2py_success) {
  /* Processing variable famlists */
  ;
  capi_famlists_intent |= F2PY_INTENT_IN;
  capi_famlists_tmp = array_from_pyobj(NPY_INT,famlists_Dims,famlists_Rank,capi_famlists_intent,famlists_capi);
  if (capi_famlists_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 9th argument `famlists' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    famlists = (int *)(PyArray_DATA(capi_famlists_tmp));

  /* Processing variable bcdatanames */
  ;
  capi_bcdatanames_intent |= F2PY_INTENT_IN;
  capi_bcdatanames_tmp = array_from_pyobj(NPY_STRING,bcdatanames_Dims,bcdatanames_Rank,capi_bcdatanames_intent,bcdatanames_capi);
  if (capi_bcdatanames_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 10th argument `bcdatanames' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatanames = (string *)(PyArray_DATA(capi_bcdatanames_tmp));

  /* Processing variable bcdatavalues */
  ;
  capi_bcdatavalues_intent |= F2PY_INTENT_IN;
  capi_bcdatavalues_tmp = array_from_pyobj(NPY_DOUBLE,bcdatavalues_Dims,bcdatavalues_Rank,capi_bcdatavalues_intent,bcdatavalues_capi);
  if (capi_bcdatavalues_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 11st argument `bcdatavalues' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatavalues = (double *)(PyArray_DATA(capi_bcdatavalues_tmp));

  /* Processing variable bcdatafamlists */
  ;
  capi_bcdatafamlists_intent |= F2PY_INTENT_IN;
  capi_bcdatafamlists_tmp = array_from_pyobj(NPY_INT,bcdatafamlists_Dims,bcdatafamlists_Rank,capi_bcdatafamlists_intent,bcdatafamlists_capi);
  if (capi_bcdatafamlists_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 12nd argument `bcdatafamlists' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatafamlists = (int *)(PyArray_DATA(capi_bcdatafamlists_tmp));

  /* Processing variable bcvarsempty */
    bcvarsempty = (int)PyObject_IsTrue(bcvarsempty_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable xvbar */
  xvbar_Dims[0]=spatialsize;
  capi_xvbar_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_xvbar_tmp = array_from_pyobj(NPY_DOUBLE,xvbar_Dims,xvbar_Rank,capi_xvbar_intent,Py_None);
  if (capi_xvbar_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `xvbar' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    xvbar = (double *)(PyArray_DATA(capi_xvbar_tmp));

  /* Processing variable extrabar */
  extrabar_Dims[0]=extrasize;
  capi_extrabar_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_extrabar_tmp = array_from_pyobj(NPY_DOUBLE,extrabar_Dims,extrabar_Rank,capi_extrabar_intent,Py_None);
  if (capi_extrabar_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `extrabar' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    extrabar = (double *)(PyArray_DATA(capi_extrabar_tmp));

  /* Processing variable wbar */
  wbar_Dims[0]=statesize;
  capi_wbar_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_wbar_tmp = array_from_pyobj(NPY_DOUBLE,wbar_Dims,wbar_Rank,capi_wbar_intent,Py_None);
  if (capi_wbar_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `wbar' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    wbar = (double *)(PyArray_DATA(capi_wbar_tmp));

  /* Processing variable bcdatavaluesbar */
  bcdatavaluesbar_Dims[0]=size(bcdatavalues);
  capi_bcdatavaluesbar_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_bcdatavaluesbar_tmp = array_from_pyobj(NPY_DOUBLE,bcdatavaluesbar_Dims,bcdatavaluesbar_Rank,capi_bcdatavaluesbar_intent,Py_None);
  if (capi_bcdatavaluesbar_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting hidden `bcdatavaluesbar' of libadflow.adjointapi.computematrixfreeproductbwd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    bcdatavaluesbar = (double *)(PyArray_DATA(capi_bcdatavaluesbar_tmp));

  /* Processing variable f2py_dwbar_d0 */
  f2py_dwbar_d0 = shape(dwbar, 0);
  /* Processing variable f2py_funcsbar_d0 */
  f2py_funcsbar_d0 = shape(funcsbar, 0);
  /* Processing variable f2py_funcsbar_d1 */
  f2py_funcsbar_d1 = shape(funcsbar, 1);
  /* Processing variable f2py_fbar_d0 */
  f2py_fbar_d0 = shape(fbar, 0);
  /* Processing variable f2py_fbar_d1 */
  f2py_fbar_d1 = shape(fbar, 1);
  /* Processing variable f2py_fbar_d2 */
  f2py_fbar_d2 = shape(fbar, 2);
  /* Processing variable f2py_famlists_d0 */
  f2py_famlists_d0 = shape(famlists, 0);
  /* Processing variable f2py_famlists_d1 */
  f2py_famlists_d1 = shape(famlists, 1);
  /* Processing variable f2py_bcdatanames_d0 */
  f2py_bcdatanames_d0 = shape(bcdatanames, 0);
  /* Processing variable f2py_bcdatanames_d1 */
  f2py_bcdatanames_d1 = shape(bcdatanames, 1);
  /* Processing variable f2py_bcdatavalues_d0 */
  f2py_bcdatavalues_d0 = shape(bcdatavalues, 0);
  /* Processing variable f2py_bcdatafamlists_d0 */
  f2py_bcdatafamlists_d0 = shape(bcdatafamlists, 0);
  /* Processing variable f2py_bcdatafamlists_d1 */
  f2py_bcdatafamlists_d1 = shape(bcdatafamlists, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(dwbar,funcsbar,fbar,&usespatial,&usestate,xvbar,extrabar,wbar,&spatialsize,&extrasize,&statesize,famlists,bcdatanames,bcdatavalues,bcdatavaluesbar,bcdatafamlists,&bcvarsempty,&f2py_dwbar_d0,&f2py_funcsbar_d0,&f2py_funcsbar_d1,&f2py_fbar_d0,&f2py_fbar_d1,&f2py_fbar_d2,&f2py_famlists_d0,&f2py_famlists_d1,&f2py_bcdatanames_d0,&f2py_bcdatanames_d1,&f2py_bcdatavalues_d0,&f2py_bcdatafamlists_d0,&f2py_bcdatafamlists_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("NNNN",capi_xvbar_tmp,capi_extrabar_tmp,capi_wbar_tmp,capi_bcdatavaluesbar_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_bcdatafamlists_d1 */
  /* End of cleaning variable f2py_bcdatafamlists_d0 */
  /* End of cleaning variable f2py_bcdatavalues_d0 */
  /* End of cleaning variable f2py_bcdatanames_d1 */
  /* End of cleaning variable f2py_bcdatanames_d0 */
  /* End of cleaning variable f2py_famlists_d1 */
  /* End of cleaning variable f2py_famlists_d0 */
  /* End of cleaning variable f2py_fbar_d2 */
  /* End of cleaning variable f2py_fbar_d1 */
  /* End of cleaning variable f2py_fbar_d0 */
  /* End of cleaning variable f2py_funcsbar_d1 */
  /* End of cleaning variable f2py_funcsbar_d0 */
  /* End of cleaning variable f2py_dwbar_d0 */
  }  /*if (capi_bcdatavaluesbar_tmp == NULL) ... else of bcdatavaluesbar*/
  /* End of cleaning variable bcdatavaluesbar */
  }  /*if (capi_wbar_tmp == NULL) ... else of wbar*/
  /* End of cleaning variable wbar */
  }  /*if (capi_extrabar_tmp == NULL) ... else of extrabar*/
  /* End of cleaning variable extrabar */
  }  /*if (capi_xvbar_tmp == NULL) ... else of xvbar*/
  /* End of cleaning variable xvbar */
  } /*if (f2py_success) of bcvarsempty*/
  /* End of cleaning variable bcvarsempty */
  if((PyObject *)capi_bcdatafamlists_tmp!=bcdatafamlists_capi) {
    Py_XDECREF(capi_bcdatafamlists_tmp); }
  }  /*if (capi_bcdatafamlists_tmp == NULL) ... else of bcdatafamlists*/
  /* End of cleaning variable bcdatafamlists */
  if((PyObject *)capi_bcdatavalues_tmp!=bcdatavalues_capi) {
    Py_XDECREF(capi_bcdatavalues_tmp); }
  }  /*if (capi_bcdatavalues_tmp == NULL) ... else of bcdatavalues*/
  /* End of cleaning variable bcdatavalues */
  if((PyObject *)capi_bcdatanames_tmp!=bcdatanames_capi) {
    Py_XDECREF(capi_bcdatanames_tmp); }
  }  /*if (capi_bcdatanames_tmp == NULL) ... else of bcdatanames*/
  /* End of cleaning variable bcdatanames */
  if((PyObject *)capi_famlists_tmp!=famlists_capi) {
    Py_XDECREF(capi_famlists_tmp); }
  }  /*if (capi_famlists_tmp == NULL) ... else of famlists*/
  /* End of cleaning variable famlists */
  } /*if (f2py_success) of statesize*/
  /* End of cleaning variable statesize */
  } /*if (f2py_success) of extrasize*/
  /* End of cleaning variable extrasize */
  } /*if (f2py_success) of spatialsize*/
  /* End of cleaning variable spatialsize */
  } /*if (f2py_success) of usestate*/
  /* End of cleaning variable usestate */
  } /*if (f2py_success) of usespatial*/
  /* End of cleaning variable usespatial */
  if((PyObject *)capi_fbar_tmp!=fbar_capi) {
    Py_XDECREF(capi_fbar_tmp); }
  }  /*if (capi_fbar_tmp == NULL) ... else of fbar*/
  /* End of cleaning variable fbar */
  if((PyObject *)capi_funcsbar_tmp!=funcsbar_capi) {
    Py_XDECREF(capi_funcsbar_tmp); }
  }  /*if (capi_funcsbar_tmp == NULL) ... else of funcsbar*/
  /* End of cleaning variable funcsbar */
  if((PyObject *)capi_dwbar_tmp!=dwbar_capi) {
    Py_XDECREF(capi_dwbar_tmp); }
  }  /*if (capi_dwbar_tmp == NULL) ... else of dwbar*/
  /* End of cleaning variable dwbar */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************* end of computematrixfreeproductbwd *********************/

/****************************** initializepetsc ******************************/
static char doc_f2py_rout_libadflow_adjointutils_initializepetsc[] = "\
initializepetsc()\n\nWrapper for ``initializepetsc``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_adjointutils_initializepetsc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.adjointutils.initializepetsc",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of initializepetsc ***************************/

/****************************** destroypetscvars ******************************/
static char doc_f2py_rout_libadflow_adjointutils_destroypetscvars[] = "\
destroypetscvars()\n\nWrapper for ``destroypetscvars``.\
\n";
/*  */
static PyObject *f2py_rout_libadflow_adjointutils_destroypetscvars(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.adjointutils.destroypetscvars",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of destroypetscvars **************************/

/****************************** createzippermesh ******************************/
static char doc_f2py_rout_libadflow_zippermesh_createzippermesh[] = "\
createzippermesh(zipperfamlist,[nzipfam])\n\nWrapper for ``createzippermesh``.\
\n\nParameters\n----------\n"
"zipperfamlist : input rank-1 array('i') with bounds (nzipfam)\n"
"\nOther Parameters\n----------------\n"
"nzipfam : input int, optional\n    Default: len(zipperfamlist)";
/*  */
static PyObject *f2py_rout_libadflow_zippermesh_createzippermesh(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int *zipperfamlist = NULL;
  npy_intp zipperfamlist_Dims[1] = {-1};
  const int zipperfamlist_Rank = 1;
  PyArrayObject *capi_zipperfamlist_tmp = NULL;
  int capi_zipperfamlist_intent = 0;
  PyObject *zipperfamlist_capi = Py_None;
  int nzipfam = 0;
  PyObject *nzipfam_capi = Py_None;
    static char *capi_kwlist[] = {"zipperfamlist","nzipfam",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|O:libadflow.zippermesh.createzippermesh",\
        capi_kwlist,&zipperfamlist_capi,&nzipfam_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable zipperfamlist */
  ;
  capi_zipperfamlist_intent |= F2PY_INTENT_IN;
  capi_zipperfamlist_tmp = array_from_pyobj(NPY_INT,zipperfamlist_Dims,zipperfamlist_Rank,capi_zipperfamlist_intent,zipperfamlist_capi);
  if (capi_zipperfamlist_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : libadflow_error,"failed in converting 1st argument `zipperfamlist' of libadflow.zippermesh.createzippermesh to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    zipperfamlist = (int *)(PyArray_DATA(capi_zipperfamlist_tmp));

  /* Processing variable nzipfam */
  if (nzipfam_capi == Py_None) nzipfam = len(zipperfamlist); else
    f2py_success = int_from_pyobj(&nzipfam,nzipfam_capi,"libadflow.zippermesh.createzippermesh() 1st keyword (nzipfam) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(zipperfamlist)>=nzipfam,"len(zipperfamlist)>=nzipfam","1st keyword nzipfam","createzippermesh:nzipfam=%d",nzipfam) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(zipperfamlist,&nzipfam);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(zipperfamlist)>=nzipfam)*/
  } /*if (f2py_success) of nzipfam*/
  /* End of cleaning variable nzipfam */
  if((PyObject *)capi_zipperfamlist_tmp!=zipperfamlist_capi) {
    Py_XDECREF(capi_zipperfamlist_tmp); }
  }  /*if (capi_zipperfamlist_tmp == NULL) ... else of zipperfamlist*/
  /* End of cleaning variable zipperfamlist */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/************************** end of createzippermesh **************************/

/******************************** checkzipper ********************************/
static char doc_f2py_rout_libadflow_zippermesh_checkzipper[] = "\
checkzipper(filename)\n\nWrapper for ``checkzipper``.\
\n\nParameters\n----------\n"
"filename : input string(len=-1)";
/*  */
static PyObject *f2py_rout_libadflow_zippermesh_checkzipper(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  string filename = NULL;
  int slen(filename);
  PyObject *filename_capi = Py_None;
    static char *capi_kwlist[] = {"filename",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.zippermesh.checkzipper",\
        capi_kwlist,&filename_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable filename */
  slen(filename) = -1;
  f2py_success = string_from_pyobj(&filename,&slen(filename),"",filename_capi,"string_from_pyobj failed in converting 1st argument `filename' of libadflow.zippermesh.checkzipper to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(filename,slen(filename));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(filename);
  }  /*if (f2py_success) of filename*/
  /* End of cleaning variable filename */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of checkzipper *****************************/

/********************************** getnfam **********************************/
static char doc_f2py_rout_libadflow_surfacefamilies_getnfam[] = "\
nfam = getnfam()\n\nWrapper for ``getnfam``.\
\n\nReturns\n-------\n"
"nfam : int";
/*  */
static PyObject *f2py_rout_libadflow_surfacefamilies_getnfam(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int nfam = 0;
    static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "|:libadflow.surfacefamilies.getnfam",\
        capi_kwlist))
        return NULL;
/*frompyobj*/
  /* Processing variable nfam */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&nfam);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",nfam);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable nfam */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of getnfam *******************************/

/*********************************** getfam ***********************************/
static char doc_f2py_rout_libadflow_surfacefamilies_getfam[] = "\
fam = getfam(i)\n\nWrapper for ``getfam``.\
\n\nParameters\n----------\n"
"i : input int\n"
"\nReturns\n-------\n"
"fam : string(len=32)";
/*  */
static PyObject *f2py_rout_libadflow_surfacefamilies_getfam(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,string,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int i = 0;
  PyObject *i_capi = Py_None;
  string fam = NULL;
  int slen(fam);
  PyObject *fam_capi = Py_None;
    static char *capi_kwlist[] = {"i",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:libadflow.surfacefamilies.getfam",\
        capi_kwlist,&i_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable i */
    f2py_success = int_from_pyobj(&i,i_capi,"libadflow.surfacefamilies.getfam() 1st argument (i) can't be converted to int");
  if (f2py_success) {
  /* Processing variable fam */
  slen(fam) = 32;
  f2py_success = string_from_pyobj(&fam,&slen(fam),"",fam_capi,"string_from_pyobj failed in converting hidden `fam' of libadflow.surfacefamilies.getfam to C string");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&i,fam,slen(fam));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("y",fam);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    STRINGFREE(fam);
  }  /*if (f2py_success) of fam*/
  /* End of cleaning variable fam */
  } /*if (f2py_success) of i*/
  /* End of cleaning variable i */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************* end of getfam *******************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_utils_def[] = {
  {"writeintromessage",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_writeintromessage,doc_f2py_rout_libadflow_utils_writeintromessage},
  {"getliftdirfromsymmetry",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_getliftdirfromsymmetry,doc_f2py_rout_libadflow_utils_getliftdirfromsymmetry},
  {"allocconvarrays",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_allocconvarrays,doc_f2py_rout_libadflow_utils_allocconvarrays},
  {"alloctimearrays",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_alloctimearrays,doc_f2py_rout_libadflow_utils_alloctimearrays},
  {"unsteadyheader",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_unsteadyheader,doc_f2py_rout_libadflow_utils_unsteadyheader},
  {"pointreduce",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_pointreduce,doc_f2py_rout_libadflow_utils_pointreduce},
  {"getcellcenters",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_getcellcenters,doc_f2py_rout_libadflow_utils_getcellcenters},
  {"getcellcgnsblockids",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_getcellcgnsblockids,doc_f2py_rout_libadflow_utils_getcellcgnsblockids},
  {"getncgnszones",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_getncgnszones,doc_f2py_rout_libadflow_utils_getncgnszones},
  {"getcgnszonename",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_getcgnszonename,doc_f2py_rout_libadflow_utils_getcgnszonename},
  {"releasememorypart1",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_releasememorypart1,doc_f2py_rout_libadflow_utils_releasememorypart1},
  {"releasememorypart2",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_utils_releasememorypart2,doc_f2py_rout_libadflow_utils_releasememorypart2},
  {NULL}
};

static void f2py_setup_utils(char *writeintromessage,char *getliftdirfromsymmetry,char *allocconvarrays,char *alloctimearrays,char *unsteadyheader,char *pointreduce,char *getcellcenters,char *getcellcgnsblockids,char *getncgnszones,char *getcgnszonename,char *releasememorypart1,char *releasememorypart2) {
  int i_f2py=0;
  f2py_utils_def[i_f2py++].data = writeintromessage;
  f2py_utils_def[i_f2py++].data = getliftdirfromsymmetry;
  f2py_utils_def[i_f2py++].data = allocconvarrays;
  f2py_utils_def[i_f2py++].data = alloctimearrays;
  f2py_utils_def[i_f2py++].data = unsteadyheader;
  f2py_utils_def[i_f2py++].data = pointreduce;
  f2py_utils_def[i_f2py++].data = getcellcenters;
  f2py_utils_def[i_f2py++].data = getcellcgnsblockids;
  f2py_utils_def[i_f2py++].data = getncgnszones;
  f2py_utils_def[i_f2py++].data = getcgnszonename;
  f2py_utils_def[i_f2py++].data = releasememorypart1;
  f2py_utils_def[i_f2py++].data = releasememorypart2;
}
extern void F_FUNC(f2pyinitutils,F2PYINITUTILS)(void (*)(char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_utils(void) {
  F_FUNC(f2pyinitutils,F2PYINITUTILS)(f2py_setup_utils);
}


static FortranDataDef f2py_walldistance_def[] = {
  {"updatewalldistancealllevels",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_walldistance_updatewalldistancealllevels,doc_f2py_rout_libadflow_walldistance_updatewalldistancealllevels},
  {NULL}
};

static void f2py_setup_walldistance(char *updatewalldistancealllevels) {
  int i_f2py=0;
  f2py_walldistance_def[i_f2py++].data = updatewalldistancealllevels;
}
extern void F_FUNC(f2pyinitwalldistance,F2PYINITWALLDISTANCE)(void (*)(char *));
static void f2py_init_walldistance(void) {
  F_FUNC(f2pyinitwalldistance,F2PYINITWALLDISTANCE)(f2py_setup_walldistance);
}


static FortranDataDef f2py_initializeflow_def[] = {
  {"updatebcdataalllevels",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_initializeflow_updatebcdataalllevels,doc_f2py_rout_libadflow_initializeflow_updatebcdataalllevels},
  {"initflow",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_initializeflow_initflow,doc_f2py_rout_libadflow_initializeflow_initflow},
  {"initflowrestart",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_initializeflow_initflowrestart,doc_f2py_rout_libadflow_initializeflow_initflowrestart},
  {"setuniformflow",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_initializeflow_setuniformflow,doc_f2py_rout_libadflow_initializeflow_setuniformflow},
  {"allocrestartfiles",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_initializeflow_allocrestartfiles,doc_f2py_rout_libadflow_initializeflow_allocrestartfiles},
  {"setrestartfiles",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_initializeflow_setrestartfiles,doc_f2py_rout_libadflow_initializeflow_setrestartfiles},
  {"infchangecorrection",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_initializeflow_infchangecorrection,doc_f2py_rout_libadflow_initializeflow_infchangecorrection},
  {NULL}
};

static void f2py_setup_initializeflow(char *updatebcdataalllevels,char *initflow,char *initflowrestart,char *setuniformflow,char *allocrestartfiles,char *setrestartfiles,char *infchangecorrection) {
  int i_f2py=0;
  f2py_initializeflow_def[i_f2py++].data = updatebcdataalllevels;
  f2py_initializeflow_def[i_f2py++].data = initflow;
  f2py_initializeflow_def[i_f2py++].data = initflowrestart;
  f2py_initializeflow_def[i_f2py++].data = setuniformflow;
  f2py_initializeflow_def[i_f2py++].data = allocrestartfiles;
  f2py_initializeflow_def[i_f2py++].data = setrestartfiles;
  f2py_initializeflow_def[i_f2py++].data = infchangecorrection;
}
extern void F_FUNC(f2pyinitinitializeflow,F2PYINITINITIALIZEFLOW)(void (*)(char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_initializeflow(void) {
  F_FUNC(f2pyinitinitializeflow,F2PYINITINITIALIZEFLOW)(f2py_setup_initializeflow);
}


static FortranDataDef f2py_bcdata_def[] = {
  {"setbcdata",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_bcdata_setbcdata,doc_f2py_rout_libadflow_bcdata_setbcdata},
  {NULL}
};

static void f2py_setup_bcdata(char *setbcdata) {
  int i_f2py=0;
  f2py_bcdata_def[i_f2py++].data = setbcdata;
}
extern void F_FUNC(f2pyinitbcdata,F2PYINITBCDATA)(void (*)(char *));
static void f2py_init_bcdata(void) {
  F_FUNC(f2pyinitbcdata,F2PYINITBCDATA)(f2py_setup_bcdata);
}


static FortranDataDef f2py_agmg_def[] = {
  {"agmglevels",0,{{-1}},NPY_INT},
  {"agmgnsmooth",0,{{-1}},NPY_INT},
  {"setupagmg",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_agmg_setupagmg,doc_f2py_rout_libadflow_agmg_setupagmg},
  {"destroyagmg",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_agmg_destroyagmg,doc_f2py_rout_libadflow_agmg_destroyagmg},
  {NULL}
};

static void f2py_setup_agmg(char *agmglevels,char *agmgnsmooth,char *setupagmg,char *destroyagmg) {
  int i_f2py=0;
  f2py_agmg_def[i_f2py++].data = agmglevels;
  f2py_agmg_def[i_f2py++].data = agmgnsmooth;
  f2py_agmg_def[i_f2py++].data = setupagmg;
  f2py_agmg_def[i_f2py++].data = destroyagmg;
}
extern void F_FUNC(f2pyinitagmg,F2PYINITAGMG)(void (*)(char*,char*,char *,char *));
static void f2py_init_agmg(void) {
  F_FUNC(f2pyinitagmg,F2PYINITAGMG)(f2py_setup_agmg);
}


static FortranDataDef f2py_flowutils_def[] = {
  {"updategamma",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_flowutils_updategamma,doc_f2py_rout_libadflow_flowutils_updategamma},
  {"adjustinflowangle",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_flowutils_adjustinflowangle,doc_f2py_rout_libadflow_flowutils_adjustinflowangle},
  {NULL}
};

static void f2py_setup_flowutils(char *updategamma,char *adjustinflowangle) {
  int i_f2py=0;
  f2py_flowutils_def[i_f2py++].data = updategamma;
  f2py_flowutils_def[i_f2py++].data = adjustinflowangle;
}
extern void F_FUNC(f2pyinitflowutils,F2PYINITFLOWUTILS)(void (*)(char *,char *));
static void f2py_init_flowutils(void) {
  F_FUNC(f2pyinitflowutils,F2PYINITFLOWUTILS)(f2py_setup_flowutils);
}


static FortranDataDef f2py_inputparamroutines_def[] = {
  {"setdefaultvalues",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_setdefaultvalues,doc_f2py_rout_libadflow_inputparamroutines_setdefaultvalues},
  {"monitorvariables",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_monitorvariables,doc_f2py_rout_libadflow_inputparamroutines_monitorvariables},
  {"surfacevariables",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_surfacevariables,doc_f2py_rout_libadflow_inputparamroutines_surfacevariables},
  {"volumevariables",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_volumevariables,doc_f2py_rout_libadflow_inputparamroutines_volumevariables},
  {"isovariables",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_isovariables,doc_f2py_rout_libadflow_inputparamroutines_isovariables},
  {"initializeisosurfacevariables",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_initializeisosurfacevariables,doc_f2py_rout_libadflow_inputparamroutines_initializeisosurfacevariables},
  {"setisosurfacevariable",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_setisosurfacevariable,doc_f2py_rout_libadflow_inputparamroutines_setisosurfacevariable},
  {"dummyreadparamfile",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_inputparamroutines_dummyreadparamfile,doc_f2py_rout_libadflow_inputparamroutines_dummyreadparamfile},
  {NULL}
};

static void f2py_setup_inputparamroutines(char *setdefaultvalues,char *monitorvariables,char *surfacevariables,char *volumevariables,char *isovariables,char *initializeisosurfacevariables,char *setisosurfacevariable,char *dummyreadparamfile) {
  int i_f2py=0;
  f2py_inputparamroutines_def[i_f2py++].data = setdefaultvalues;
  f2py_inputparamroutines_def[i_f2py++].data = monitorvariables;
  f2py_inputparamroutines_def[i_f2py++].data = surfacevariables;
  f2py_inputparamroutines_def[i_f2py++].data = volumevariables;
  f2py_inputparamroutines_def[i_f2py++].data = isovariables;
  f2py_inputparamroutines_def[i_f2py++].data = initializeisosurfacevariables;
  f2py_inputparamroutines_def[i_f2py++].data = setisosurfacevariable;
  f2py_inputparamroutines_def[i_f2py++].data = dummyreadparamfile;
}
extern void F_FUNC(f2pyinitinputparamroutines,F2PYINITINPUTPARAMROUTINES)(void (*)(char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_inputparamroutines(void) {
  F_FUNC(f2pyinitinputparamroutines,F2PYINITINPUTPARAMROUTINES)(f2py_setup_inputparamroutines);
}


static FortranDataDef f2py_nksolver_def[] = {
  {"nk_innerpreconits",0,{{-1}},NPY_INT},
  {"nk_outerpreconits",0,{{-1}},NPY_INT},
  {"nk_jacobianlag",0,{{-1}},NPY_INT},
  {"usenksolver",0,{{-1}},NPY_INT},
  {"nk_adpc",0,{{-1}},NPY_INT},
  {"nk_useew",0,{{-1}},NPY_INT},
  {"nk_viscpc",0,{{-1}},NPY_INT},
  {"nk_ls",0,{{-1}},NPY_INT},
  {"nk_subspace",0,{{-1}},NPY_INT},
  {"nk_asmoverlap",0,{{-1}},NPY_INT},
  {"nk_rtolinit",0,{{-1}},NPY_DOUBLE},
  {"nk_ilufill",0,{{-1}},NPY_INT},
  {"nk_switchtol",0,{{-1}},NPY_DOUBLE},
  {"nk_cfl0",0,{{-1}},NPY_DOUBLE},
  {"nk_fixedstep",0,{{-1}},NPY_DOUBLE},
  {"applypcsubspacesize",0,{{-1}},NPY_INT},
  {"freestreamresset",0,{{-1}},NPY_INT},
  {"getstates",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_getstates,doc_f2py_rout_libadflow_nksolver_getstates},
  {"setstates",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_setstates,doc_f2py_rout_libadflow_nksolver_setstates},
  {"getinfosize",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_getinfosize,doc_f2py_rout_libadflow_nksolver_getinfosize},
  {"setinfo",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_setinfo,doc_f2py_rout_libadflow_nksolver_setinfo},
  {"getinfo",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_getinfo,doc_f2py_rout_libadflow_nksolver_getinfo},
  {"getres",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_getres,doc_f2py_rout_libadflow_nksolver_getres},
  {"applypc",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_applypc,doc_f2py_rout_libadflow_nksolver_applypc},
  {"applyadjointpc",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_applyadjointpc,doc_f2py_rout_libadflow_nksolver_applyadjointpc},
  {"destroynksolver",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_destroynksolver,doc_f2py_rout_libadflow_nksolver_destroynksolver},
  {"getfreestreamresidual",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_nksolver_getfreestreamresidual,doc_f2py_rout_libadflow_nksolver_getfreestreamresidual},
  {NULL}
};

static void f2py_setup_nksolver(char *nk_innerpreconits,char *nk_outerpreconits,char *nk_jacobianlag,char *usenksolver,char *nk_adpc,char *nk_useew,char *nk_viscpc,char *nk_ls,char *nk_subspace,char *nk_asmoverlap,char *nk_rtolinit,char *nk_ilufill,char *nk_switchtol,char *nk_cfl0,char *nk_fixedstep,char *applypcsubspacesize,char *freestreamresset,char *getstates,char *setstates,char *getinfosize,char *setinfo,char *getinfo,char *getres,char *applypc,char *applyadjointpc,char *destroynksolver,char *getfreestreamresidual) {
  int i_f2py=0;
  f2py_nksolver_def[i_f2py++].data = nk_innerpreconits;
  f2py_nksolver_def[i_f2py++].data = nk_outerpreconits;
  f2py_nksolver_def[i_f2py++].data = nk_jacobianlag;
  f2py_nksolver_def[i_f2py++].data = usenksolver;
  f2py_nksolver_def[i_f2py++].data = nk_adpc;
  f2py_nksolver_def[i_f2py++].data = nk_useew;
  f2py_nksolver_def[i_f2py++].data = nk_viscpc;
  f2py_nksolver_def[i_f2py++].data = nk_ls;
  f2py_nksolver_def[i_f2py++].data = nk_subspace;
  f2py_nksolver_def[i_f2py++].data = nk_asmoverlap;
  f2py_nksolver_def[i_f2py++].data = nk_rtolinit;
  f2py_nksolver_def[i_f2py++].data = nk_ilufill;
  f2py_nksolver_def[i_f2py++].data = nk_switchtol;
  f2py_nksolver_def[i_f2py++].data = nk_cfl0;
  f2py_nksolver_def[i_f2py++].data = nk_fixedstep;
  f2py_nksolver_def[i_f2py++].data = applypcsubspacesize;
  f2py_nksolver_def[i_f2py++].data = freestreamresset;
  f2py_nksolver_def[i_f2py++].data = getstates;
  f2py_nksolver_def[i_f2py++].data = setstates;
  f2py_nksolver_def[i_f2py++].data = getinfosize;
  f2py_nksolver_def[i_f2py++].data = setinfo;
  f2py_nksolver_def[i_f2py++].data = getinfo;
  f2py_nksolver_def[i_f2py++].data = getres;
  f2py_nksolver_def[i_f2py++].data = applypc;
  f2py_nksolver_def[i_f2py++].data = applyadjointpc;
  f2py_nksolver_def[i_f2py++].data = destroynksolver;
  f2py_nksolver_def[i_f2py++].data = getfreestreamresidual;
}
extern void F_FUNC(f2pyinitnksolver,F2PYINITNKSOLVER)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_nksolver(void) {
  F_FUNC(f2pyinitnksolver,F2PYINITNKSOLVER)(f2py_setup_nksolver);
}


static FortranDataDef f2py_anksolver_def[] = {
  {"ank_innerpreconits",0,{{-1}},NPY_INT},
  {"ank_outerpreconits",0,{{-1}},NPY_INT},
  {"ank_jacobianlag",0,{{-1}},NPY_INT},
  {"useanksolver",0,{{-1}},NPY_INT},
  {"ank_useturbdadi",0,{{-1}},NPY_INT},
  {"ank_subspace",0,{{-1}},NPY_INT},
  {"ank_maxiter",0,{{-1}},NPY_INT},
  {"ank_asmoverlap",0,{{-1}},NPY_INT},
  {"ank_rtol",0,{{-1}},NPY_DOUBLE},
  {"ank_linresmax",0,{{-1}},NPY_DOUBLE},
  {"ank_ilufill",0,{{-1}},NPY_INT},
  {"ank_switchtol",0,{{-1}},NPY_DOUBLE},
  {"ank_cfl0",0,{{-1}},NPY_DOUBLE},
  {"ank_cflmin0",0,{{-1}},NPY_DOUBLE},
  {"ank_cfllimit",0,{{-1}},NPY_DOUBLE},
  {"ank_cflfactor",0,{{-1}},NPY_DOUBLE},
  {"ank_cflexponent",0,{{-1}},NPY_DOUBLE},
  {"ank_cflcutback",0,{{-1}},NPY_DOUBLE},
  {"ank_stepfactor",0,{{-1}},NPY_DOUBLE},
  {"ank_stepmin",0,{{-1}},NPY_DOUBLE},
  {"ank_constcflstep",0,{{-1}},NPY_DOUBLE},
  {"ank_physlstol",0,{{-1}},NPY_DOUBLE},
  {"ank_physlstolturb",0,{{-1}},NPY_DOUBLE},
  {"ank_unstdylstol",0,{{-1}},NPY_DOUBLE},
  {"ank_secondordswitchtol",0,{{-1}},NPY_DOUBLE},
  {"ank_coupledswitchtol",0,{{-1}},NPY_DOUBLE},
  {"ank_turbcflscale",0,{{-1}},NPY_DOUBLE},
  {"ank_usefullvisc",0,{{-1}},NPY_INT},
  {"ank_pcupdatetol",0,{{-1}},NPY_DOUBLE},
  {"ank_adpc",0,{{-1}},NPY_INT},
  {"ank_nsubiterturb",0,{{-1}},NPY_INT},
  {"ank_turbdebug",0,{{-1}},NPY_INT},
  {"ank_usematrixfree",0,{{-1}},NPY_INT},
  {"destroyanksolver",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_anksolver_destroyanksolver,doc_f2py_rout_libadflow_anksolver_destroyanksolver},
  {NULL}
};

static void f2py_setup_anksolver(char *ank_innerpreconits,char *ank_outerpreconits,char *ank_jacobianlag,char *useanksolver,char *ank_useturbdadi,char *ank_subspace,char *ank_maxiter,char *ank_asmoverlap,char *ank_rtol,char *ank_linresmax,char *ank_ilufill,char *ank_switchtol,char *ank_cfl0,char *ank_cflmin0,char *ank_cfllimit,char *ank_cflfactor,char *ank_cflexponent,char *ank_cflcutback,char *ank_stepfactor,char *ank_stepmin,char *ank_constcflstep,char *ank_physlstol,char *ank_physlstolturb,char *ank_unstdylstol,char *ank_secondordswitchtol,char *ank_coupledswitchtol,char *ank_turbcflscale,char *ank_usefullvisc,char *ank_pcupdatetol,char *ank_adpc,char *ank_nsubiterturb,char *ank_turbdebug,char *ank_usematrixfree,char *destroyanksolver) {
  int i_f2py=0;
  f2py_anksolver_def[i_f2py++].data = ank_innerpreconits;
  f2py_anksolver_def[i_f2py++].data = ank_outerpreconits;
  f2py_anksolver_def[i_f2py++].data = ank_jacobianlag;
  f2py_anksolver_def[i_f2py++].data = useanksolver;
  f2py_anksolver_def[i_f2py++].data = ank_useturbdadi;
  f2py_anksolver_def[i_f2py++].data = ank_subspace;
  f2py_anksolver_def[i_f2py++].data = ank_maxiter;
  f2py_anksolver_def[i_f2py++].data = ank_asmoverlap;
  f2py_anksolver_def[i_f2py++].data = ank_rtol;
  f2py_anksolver_def[i_f2py++].data = ank_linresmax;
  f2py_anksolver_def[i_f2py++].data = ank_ilufill;
  f2py_anksolver_def[i_f2py++].data = ank_switchtol;
  f2py_anksolver_def[i_f2py++].data = ank_cfl0;
  f2py_anksolver_def[i_f2py++].data = ank_cflmin0;
  f2py_anksolver_def[i_f2py++].data = ank_cfllimit;
  f2py_anksolver_def[i_f2py++].data = ank_cflfactor;
  f2py_anksolver_def[i_f2py++].data = ank_cflexponent;
  f2py_anksolver_def[i_f2py++].data = ank_cflcutback;
  f2py_anksolver_def[i_f2py++].data = ank_stepfactor;
  f2py_anksolver_def[i_f2py++].data = ank_stepmin;
  f2py_anksolver_def[i_f2py++].data = ank_constcflstep;
  f2py_anksolver_def[i_f2py++].data = ank_physlstol;
  f2py_anksolver_def[i_f2py++].data = ank_physlstolturb;
  f2py_anksolver_def[i_f2py++].data = ank_unstdylstol;
  f2py_anksolver_def[i_f2py++].data = ank_secondordswitchtol;
  f2py_anksolver_def[i_f2py++].data = ank_coupledswitchtol;
  f2py_anksolver_def[i_f2py++].data = ank_turbcflscale;
  f2py_anksolver_def[i_f2py++].data = ank_usefullvisc;
  f2py_anksolver_def[i_f2py++].data = ank_pcupdatetol;
  f2py_anksolver_def[i_f2py++].data = ank_adpc;
  f2py_anksolver_def[i_f2py++].data = ank_nsubiterturb;
  f2py_anksolver_def[i_f2py++].data = ank_turbdebug;
  f2py_anksolver_def[i_f2py++].data = ank_usematrixfree;
  f2py_anksolver_def[i_f2py++].data = destroyanksolver;
}
extern void F_FUNC(f2pyinitanksolver,F2PYINITANKSOLVER)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char *));
static void f2py_init_anksolver(void) {
  F_FUNC(f2pyinitanksolver,F2PYINITANKSOLVER)(f2py_setup_anksolver);
}


static FortranDataDef f2py_partitioning_def[] = {
  {"partitionandreadgrid",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_partitioning_partitionandreadgrid,doc_f2py_rout_libadflow_partitioning_partitionandreadgrid},
  {"checkpartitioning",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_partitioning_checkpartitioning,doc_f2py_rout_libadflow_partitioning_checkpartitioning},
  {NULL}
};

static void f2py_setup_partitioning(char *partitionandreadgrid,char *checkpartitioning) {
  int i_f2py=0;
  f2py_partitioning_def[i_f2py++].data = partitionandreadgrid;
  f2py_partitioning_def[i_f2py++].data = checkpartitioning;
}
extern void F_FUNC(f2pyinitpartitioning,F2PYINITPARTITIONING)(void (*)(char *,char *));
static void f2py_init_partitioning(void) {
  F_FUNC(f2pyinitpartitioning,F2PYINITPARTITIONING)(f2py_setup_partitioning);
}


static FortranDataDef f2py_warping_def[] = {
  {"getcgnsmeshindices",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_warping_getcgnsmeshindices,doc_f2py_rout_libadflow_warping_getcgnsmeshindices},
  {"setgrid",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_warping_setgrid,doc_f2py_rout_libadflow_warping_setgrid},
  {"getgrid",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_warping_getgrid,doc_f2py_rout_libadflow_warping_getgrid},
  {"getstateperturbation",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_warping_getstateperturbation,doc_f2py_rout_libadflow_warping_getstateperturbation},
  {"getsurfaceperturbation",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_warping_getsurfaceperturbation,doc_f2py_rout_libadflow_warping_getsurfaceperturbation},
  {NULL}
};

static void f2py_setup_warping(char *getcgnsmeshindices,char *setgrid,char *getgrid,char *getstateperturbation,char *getsurfaceperturbation) {
  int i_f2py=0;
  f2py_warping_def[i_f2py++].data = getcgnsmeshindices;
  f2py_warping_def[i_f2py++].data = setgrid;
  f2py_warping_def[i_f2py++].data = getgrid;
  f2py_warping_def[i_f2py++].data = getstateperturbation;
  f2py_warping_def[i_f2py++].data = getsurfaceperturbation;
}
extern void F_FUNC(f2pyinitwarping,F2PYINITWARPING)(void (*)(char *,char *,char *,char *,char *));
static void f2py_init_warping(void) {
  F_FUNC(f2pyinitwarping,F2PYINITWARPING)(f2py_setup_warping);
}


static FortranDataDef f2py_surfaceutils_def[] = {
  {"getsurfacesize",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfaceutils_getsurfacesize,doc_f2py_rout_libadflow_surfaceutils_getsurfacesize},
  {"getsurfaceconnectivity",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfaceutils_getsurfaceconnectivity,doc_f2py_rout_libadflow_surfaceutils_getsurfaceconnectivity},
  {"getsurfacepoints",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfaceutils_getsurfacepoints,doc_f2py_rout_libadflow_surfaceutils_getsurfacepoints},
  {"mapvector",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfaceutils_mapvector,doc_f2py_rout_libadflow_surfaceutils_mapvector},
  {"getwalllist",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfaceutils_getwalllist,doc_f2py_rout_libadflow_surfaceutils_getwalllist},
  {NULL}
};

static void f2py_setup_surfaceutils(char *getsurfacesize,char *getsurfaceconnectivity,char *getsurfacepoints,char *mapvector,char *getwalllist) {
  int i_f2py=0;
  f2py_surfaceutils_def[i_f2py++].data = getsurfacesize;
  f2py_surfaceutils_def[i_f2py++].data = getsurfaceconnectivity;
  f2py_surfaceutils_def[i_f2py++].data = getsurfacepoints;
  f2py_surfaceutils_def[i_f2py++].data = mapvector;
  f2py_surfaceutils_def[i_f2py++].data = getwalllist;
}
extern void F_FUNC(f2pyinitsurfaceutils,F2PYINITSURFACEUTILS)(void (*)(char *,char *,char *,char *,char *));
static void f2py_init_surfaceutils(void) {
  F_FUNC(f2pyinitsurfaceutils,F2PYINITSURFACEUTILS)(f2py_setup_surfaceutils);
}


static FortranDataDef f2py_tecplotio_def[] = {
  {"addparaslice",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_tecplotio_addparaslice,doc_f2py_rout_libadflow_tecplotio_addparaslice},
  {"addabsslice",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_tecplotio_addabsslice,doc_f2py_rout_libadflow_tecplotio_addabsslice},
  {"addliftdistribution",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_tecplotio_addliftdistribution,doc_f2py_rout_libadflow_tecplotio_addliftdistribution},
  {"writetecplot",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_tecplotio_writetecplot,doc_f2py_rout_libadflow_tecplotio_writetecplot},
  {"initializeliftdistributiondata",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_tecplotio_initializeliftdistributiondata,doc_f2py_rout_libadflow_tecplotio_initializeliftdistributiondata},
  {NULL}
};

static void f2py_setup_tecplotio(char *addparaslice,char *addabsslice,char *addliftdistribution,char *writetecplot,char *initializeliftdistributiondata) {
  int i_f2py=0;
  f2py_tecplotio_def[i_f2py++].data = addparaslice;
  f2py_tecplotio_def[i_f2py++].data = addabsslice;
  f2py_tecplotio_def[i_f2py++].data = addliftdistribution;
  f2py_tecplotio_def[i_f2py++].data = writetecplot;
  f2py_tecplotio_def[i_f2py++].data = initializeliftdistributiondata;
}
extern void F_FUNC(f2pyinittecplotio,F2PYINITTECPLOTIO)(void (*)(char *,char *,char *,char *,char *));
static void f2py_init_tecplotio(void) {
  F_FUNC(f2pyinittecplotio,F2PYINITTECPLOTIO)(f2py_setup_tecplotio);
}


static FortranDataDef f2py_surfaceintegrations_def[] = {
  {"getsolutionwrap",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfaceintegrations_getsolutionwrap,doc_f2py_rout_libadflow_surfaceintegrations_getsolutionwrap},
  {NULL}
};

static void f2py_setup_surfaceintegrations(char *getsolutionwrap) {
  int i_f2py=0;
  f2py_surfaceintegrations_def[i_f2py++].data = getsolutionwrap;
}
extern void F_FUNC(f2pyinitsurfaceintegrations,F2PYINITSURFACEINTEGRATIONS)(void (*)(char *));
static void f2py_init_surfaceintegrations(void) {
  F_FUNC(f2pyinitsurfaceintegrations,F2PYINITSURFACEINTEGRATIONS)(f2py_setup_surfaceintegrations);
}


static FortranDataDef f2py_usersurfaceintegrations_def[] = {
  {"addintegrationsurface",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_usersurfaceintegrations_addintegrationsurface,doc_f2py_rout_libadflow_usersurfaceintegrations_addintegrationsurface},
  {"interpolateintegrationsurfaces",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_usersurfaceintegrations_interpolateintegrationsurfaces,doc_f2py_rout_libadflow_usersurfaceintegrations_interpolateintegrationsurfaces},
  {NULL}
};

static void f2py_setup_usersurfaceintegrations(char *addintegrationsurface,char *interpolateintegrationsurfaces) {
  int i_f2py=0;
  f2py_usersurfaceintegrations_def[i_f2py++].data = addintegrationsurface;
  f2py_usersurfaceintegrations_def[i_f2py++].data = interpolateintegrationsurfaces;
}
extern void F_FUNC(f2pyinitusersurfaceintegrations,F2PYINITUSERSURFACEINTEGRATIONS)(void (*)(char *,char *));
static void f2py_init_usersurfaceintegrations(void) {
  F_FUNC(f2pyinitusersurfaceintegrations,F2PYINITUSERSURFACEINTEGRATIONS)(f2py_setup_usersurfaceintegrations);
}


static FortranDataDef f2py_actuatorregion_def[] = {
  {"addactuatorregion",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_actuatorregion_addactuatorregion,doc_f2py_rout_libadflow_actuatorregion_addactuatorregion},
  {"writeactuatorregions",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_actuatorregion_writeactuatorregions,doc_f2py_rout_libadflow_actuatorregion_writeactuatorregions},
  {NULL}
};

static void f2py_setup_actuatorregion(char *addactuatorregion,char *writeactuatorregions) {
  int i_f2py=0;
  f2py_actuatorregion_def[i_f2py++].data = addactuatorregion;
  f2py_actuatorregion_def[i_f2py++].data = writeactuatorregions;
}
extern void F_FUNC(f2pyinitactuatorregion,F2PYINITACTUATORREGION)(void (*)(char *,char *));
static void f2py_init_actuatorregion(void) {
  F_FUNC(f2pyinitactuatorregion,F2PYINITACTUATORREGION)(f2py_setup_actuatorregion);
}


static FortranDataDef f2py_solvers_def[] = {
  {"solver",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_solvers_solver,doc_f2py_rout_libadflow_solvers_solver},
  {"solverunsteadyinit",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_solvers_solverunsteadyinit,doc_f2py_rout_libadflow_solvers_solverunsteadyinit},
  {"updateunsteadygeometry",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_solvers_updateunsteadygeometry,doc_f2py_rout_libadflow_solvers_updateunsteadygeometry},
  {"solverunsteadystep",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_solvers_solverunsteadystep,doc_f2py_rout_libadflow_solvers_solverunsteadystep},
  {NULL}
};

static void f2py_setup_solvers(char *solver,char *solverunsteadyinit,char *updateunsteadygeometry,char *solverunsteadystep) {
  int i_f2py=0;
  f2py_solvers_def[i_f2py++].data = solver;
  f2py_solvers_def[i_f2py++].data = solverunsteadyinit;
  f2py_solvers_def[i_f2py++].data = updateunsteadygeometry;
  f2py_solvers_def[i_f2py++].data = solverunsteadystep;
}
extern void F_FUNC(f2pyinitsolvers,F2PYINITSOLVERS)(void (*)(char *,char *,char *,char *));
static void f2py_init_solvers(void) {
  F_FUNC(f2pyinitsolvers,F2PYINITSOLVERS)(f2py_setup_solvers);
}


static FortranDataDef f2py_aleutils_def[] = {
  {"shiftlevelale",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_aleutils_shiftlevelale,doc_f2py_rout_libadflow_aleutils_shiftlevelale},
  {NULL}
};

static void f2py_setup_aleutils(char *shiftlevelale) {
  int i_f2py=0;
  f2py_aleutils_def[i_f2py++].data = shiftlevelale;
}
extern void F_FUNC(f2pyinitaleutils,F2PYINITALEUTILS)(void (*)(char *));
static void f2py_init_aleutils(void) {
  F_FUNC(f2pyinitaleutils,F2PYINITALEUTILS)(f2py_setup_aleutils);
}


static FortranDataDef f2py_preprocessingapi_def[] = {
  {"preprocessing",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_preprocessing,doc_f2py_rout_libadflow_preprocessingapi_preprocessing},
  {"updatecoordinatesalllevels",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_updatecoordinatesalllevels,doc_f2py_rout_libadflow_preprocessingapi_updatecoordinatesalllevels},
  {"updatemetricsalllevels",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_updatemetricsalllevels,doc_f2py_rout_libadflow_preprocessingapi_updatemetricsalllevels},
  {"updategridvelocitiesalllevels",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_updategridvelocitiesalllevels,doc_f2py_rout_libadflow_preprocessingapi_updategridvelocitiesalllevels},
  {"updateperiodicinfoalllevels",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_updateperiodicinfoalllevels,doc_f2py_rout_libadflow_preprocessingapi_updateperiodicinfoalllevels},
  {"shiftcoorandvolumes",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_shiftcoorandvolumes,doc_f2py_rout_libadflow_preprocessingapi_shiftcoorandvolumes},
  {"updatereferencepoint",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_updatereferencepoint,doc_f2py_rout_libadflow_preprocessingapi_updatereferencepoint},
  {"updaterotationrate",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_updaterotationrate,doc_f2py_rout_libadflow_preprocessingapi_updaterotationrate},
  {"preprocessingoverset",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_preprocessingapi_preprocessingoverset,doc_f2py_rout_libadflow_preprocessingapi_preprocessingoverset},
  {NULL}
};

static void f2py_setup_preprocessingapi(char *preprocessing,char *updatecoordinatesalllevels,char *updatemetricsalllevels,char *updategridvelocitiesalllevels,char *updateperiodicinfoalllevels,char *shiftcoorandvolumes,char *updatereferencepoint,char *updaterotationrate,char *preprocessingoverset) {
  int i_f2py=0;
  f2py_preprocessingapi_def[i_f2py++].data = preprocessing;
  f2py_preprocessingapi_def[i_f2py++].data = updatecoordinatesalllevels;
  f2py_preprocessingapi_def[i_f2py++].data = updatemetricsalllevels;
  f2py_preprocessingapi_def[i_f2py++].data = updategridvelocitiesalllevels;
  f2py_preprocessingapi_def[i_f2py++].data = updateperiodicinfoalllevels;
  f2py_preprocessingapi_def[i_f2py++].data = shiftcoorandvolumes;
  f2py_preprocessingapi_def[i_f2py++].data = updatereferencepoint;
  f2py_preprocessingapi_def[i_f2py++].data = updaterotationrate;
  f2py_preprocessingapi_def[i_f2py++].data = preprocessingoverset;
}
extern void F_FUNC(f2pyinitpreprocessingapi,F2PYINITPREPROCESSINGAPI)(void (*)(char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_preprocessingapi(void) {
  F_FUNC(f2pyinitpreprocessingapi,F2PYINITPREPROCESSINGAPI)(f2py_setup_preprocessingapi);
}


static FortranDataDef f2py_oversetapi_def[] = {
  {"updateoverset",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_oversetapi_updateoverset,doc_f2py_rout_libadflow_oversetapi_updateoverset},
  {"writepartitionedmesh",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_oversetapi_writepartitionedmesh,doc_f2py_rout_libadflow_oversetapi_writepartitionedmesh},
  {"oversetcomm",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_oversetapi_oversetcomm,doc_f2py_rout_libadflow_oversetapi_oversetcomm},
  {"setblockpriority",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_oversetapi_setblockpriority,doc_f2py_rout_libadflow_oversetapi_setblockpriority},
  {NULL}
};

static void f2py_setup_oversetapi(char *updateoverset,char *writepartitionedmesh,char *oversetcomm,char *setblockpriority) {
  int i_f2py=0;
  f2py_oversetapi_def[i_f2py++].data = updateoverset;
  f2py_oversetapi_def[i_f2py++].data = writepartitionedmesh;
  f2py_oversetapi_def[i_f2py++].data = oversetcomm;
  f2py_oversetapi_def[i_f2py++].data = setblockpriority;
}
extern void F_FUNC(f2pyinitoversetapi,F2PYINITOVERSETAPI)(void (*)(char *,char *,char *,char *));
static void f2py_init_oversetapi(void) {
  F_FUNC(f2pyinitoversetapi,F2PYINITOVERSETAPI)(f2py_setup_oversetapi);
}


static FortranDataDef f2py_oversetutilities_def[] = {
  {"getoversetiblank",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_oversetutilities_getoversetiblank,doc_f2py_rout_libadflow_oversetutilities_getoversetiblank},
  {NULL}
};

static void f2py_setup_oversetutilities(char *getoversetiblank) {
  int i_f2py=0;
  f2py_oversetutilities_def[i_f2py++].data = getoversetiblank;
}
extern void F_FUNC(f2pyinitoversetutilities,F2PYINITOVERSETUTILITIES)(void (*)(char *));
static void f2py_init_oversetutilities(void) {
  F_FUNC(f2pyinitoversetutilities,F2PYINITOVERSETUTILITIES)(f2py_setup_oversetutilities);
}


static FortranDataDef f2py_adjointapi_def[] = {
  {"setuppetscksp",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_setuppetscksp,doc_f2py_rout_libadflow_adjointapi_setuppetscksp},
  {"setupallresidualmatricesfwd",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_setupallresidualmatricesfwd,doc_f2py_rout_libadflow_adjointapi_setupallresidualmatricesfwd},
  {"solveadjoint",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_solveadjoint,doc_f2py_rout_libadflow_adjointapi_solveadjoint},
  {"solveadjointforrhs",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_solveadjointforrhs,doc_f2py_rout_libadflow_adjointapi_solveadjointforrhs},
  {"solvedirectforrhs",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_solvedirectforrhs,doc_f2py_rout_libadflow_adjointapi_solvedirectforrhs},
  {"saveadjointmatrix",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_saveadjointmatrix,doc_f2py_rout_libadflow_adjointapi_saveadjointmatrix},
  {"saveadjointpc",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_saveadjointpc,doc_f2py_rout_libadflow_adjointapi_saveadjointpc},
  {"saveadjointrhs",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_saveadjointrhs,doc_f2py_rout_libadflow_adjointapi_saveadjointrhs},
  {"savecellcenters",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_savecellcenters,doc_f2py_rout_libadflow_adjointapi_savecellcenters},
  {"spectralprecscribedmotion",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_spectralprecscribedmotion,doc_f2py_rout_libadflow_adjointapi_spectralprecscribedmotion},
  {"createpetscvars",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_createpetscvars,doc_f2py_rout_libadflow_adjointapi_createpetscvars},
  {"computematrixfreeproductfwd",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_computematrixfreeproductfwd,doc_f2py_rout_libadflow_adjointapi_computematrixfreeproductfwd},
  {"computematrixfreeproductbwd",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointapi_computematrixfreeproductbwd,doc_f2py_rout_libadflow_adjointapi_computematrixfreeproductbwd},
  {NULL}
};

static void f2py_setup_adjointapi(char *setuppetscksp,char *setupallresidualmatricesfwd,char *solveadjoint,char *solveadjointforrhs,char *solvedirectforrhs,char *saveadjointmatrix,char *saveadjointpc,char *saveadjointrhs,char *savecellcenters,char *spectralprecscribedmotion,char *createpetscvars,char *computematrixfreeproductfwd,char *computematrixfreeproductbwd) {
  int i_f2py=0;
  f2py_adjointapi_def[i_f2py++].data = setuppetscksp;
  f2py_adjointapi_def[i_f2py++].data = setupallresidualmatricesfwd;
  f2py_adjointapi_def[i_f2py++].data = solveadjoint;
  f2py_adjointapi_def[i_f2py++].data = solveadjointforrhs;
  f2py_adjointapi_def[i_f2py++].data = solvedirectforrhs;
  f2py_adjointapi_def[i_f2py++].data = saveadjointmatrix;
  f2py_adjointapi_def[i_f2py++].data = saveadjointpc;
  f2py_adjointapi_def[i_f2py++].data = saveadjointrhs;
  f2py_adjointapi_def[i_f2py++].data = savecellcenters;
  f2py_adjointapi_def[i_f2py++].data = spectralprecscribedmotion;
  f2py_adjointapi_def[i_f2py++].data = createpetscvars;
  f2py_adjointapi_def[i_f2py++].data = computematrixfreeproductfwd;
  f2py_adjointapi_def[i_f2py++].data = computematrixfreeproductbwd;
}
extern void F_FUNC(f2pyinitadjointapi,F2PYINITADJOINTAPI)(void (*)(char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_adjointapi(void) {
  F_FUNC(f2pyinitadjointapi,F2PYINITADJOINTAPI)(f2py_setup_adjointapi);
}


static FortranDataDef f2py_adjointutils_def[] = {
  {"initializepetsc",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointutils_initializepetsc,doc_f2py_rout_libadflow_adjointutils_initializepetsc},
  {"destroypetscvars",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_adjointutils_destroypetscvars,doc_f2py_rout_libadflow_adjointutils_destroypetscvars},
  {NULL}
};

static void f2py_setup_adjointutils(char *initializepetsc,char *destroypetscvars) {
  int i_f2py=0;
  f2py_adjointutils_def[i_f2py++].data = initializepetsc;
  f2py_adjointutils_def[i_f2py++].data = destroypetscvars;
}
extern void F_FUNC(f2pyinitadjointutils,F2PYINITADJOINTUTILS)(void (*)(char *,char *));
static void f2py_init_adjointutils(void) {
  F_FUNC(f2pyinitadjointutils,F2PYINITADJOINTUTILS)(f2py_setup_adjointutils);
}


static FortranDataDef f2py_zippermesh_def[] = {
  {"createzippermesh",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_zippermesh_createzippermesh,doc_f2py_rout_libadflow_zippermesh_createzippermesh},
  {"checkzipper",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_zippermesh_checkzipper,doc_f2py_rout_libadflow_zippermesh_checkzipper},
  {NULL}
};

static void f2py_setup_zippermesh(char *createzippermesh,char *checkzipper) {
  int i_f2py=0;
  f2py_zippermesh_def[i_f2py++].data = createzippermesh;
  f2py_zippermesh_def[i_f2py++].data = checkzipper;
}
extern void F_FUNC(f2pyinitzippermesh,F2PYINITZIPPERMESH)(void (*)(char *,char *));
static void f2py_init_zippermesh(void) {
  F_FUNC(f2pyinitzippermesh,F2PYINITZIPPERMESH)(f2py_setup_zippermesh);
}


static FortranDataDef f2py_oversetdata_def[] = {
  {"oversettimes",1,{{16}},NPY_DOUBLE},
  {NULL}
};

static void f2py_setup_oversetdata(char *oversettimes) {
  int i_f2py=0;
  f2py_oversetdata_def[i_f2py++].data = oversettimes;
}
extern void F_FUNC(f2pyinitoversetdata,F2PYINITOVERSETDATA)(void (*)(char*));
static void f2py_init_oversetdata(void) {
  F_FUNC(f2pyinitoversetdata,F2PYINITOVERSETDATA)(f2py_setup_oversetdata);
}


static FortranDataDef f2py_constants_def[] = {
  {"maxstringlen",0,{{-1}},NPY_INT},
  {"maxcgnsnamelen",0,{{-1}},NPY_INT},
  {"eulerequations",0,{{-1}},NPY_INT},
  {"nsequations",0,{{-1}},NPY_INT},
  {"ransequations",0,{{-1}},NPY_INT},
  {"steady",0,{{-1}},NPY_INT},
  {"unsteady",0,{{-1}},NPY_INT},
  {"timespectral",0,{{-1}},NPY_INT},
  {"internalflow",0,{{-1}},NPY_INT},
  {"externalflow",0,{{-1}},NPY_INT},
  {"cpconstant",0,{{-1}},NPY_INT},
  {"cptempcurvefits",0,{{-1}},NPY_INT},
  {"spalartallmaras",0,{{-1}},NPY_INT},
  {"spalartallmarasedwards",0,{{-1}},NPY_INT},
  {"komegawilcox",0,{{-1}},NPY_INT},
  {"komegamodified",0,{{-1}},NPY_INT},
  {"ktau",0,{{-1}},NPY_INT},
  {"mentersst",0,{{-1}},NPY_INT},
  {"v2f",0,{{-1}},NPY_INT},
  {"strain",0,{{-1}},NPY_INT},
  {"vorticity",0,{{-1}},NPY_INT},
  {"katolaunder",0,{{-1}},NPY_INT},
  {"dissscalar",0,{{-1}},NPY_INT},
  {"dissmatrix",0,{{-1}},NPY_INT},
  {"disscusp",0,{{-1}},NPY_INT},
  {"upwind",0,{{-1}},NPY_INT},
  {"roe",0,{{-1}},NPY_INT},
  {"vanleer",0,{{-1}},NPY_INT},
  {"ausmdv",0,{{-1}},NPY_INT},
  {"nolimiter",0,{{-1}},NPY_INT},
  {"vanalbeda",0,{{-1}},NPY_INT},
  {"minmod",0,{{-1}},NPY_INT},
  {"noprecond",0,{{-1}},NPY_INT},
  {"turkel",0,{{-1}},NPY_INT},
  {"choimerkle",0,{{-1}},NPY_INT},
  {"constantpressure",0,{{-1}},NPY_INT},
  {"linextrapolpressure",0,{{-1}},NPY_INT},
  {"quadextrapolpressure",0,{{-1}},NPY_INT},
  {"normalmomentum",0,{{-1}},NPY_INT},
  {"constantextrapol",0,{{-1}},NPY_INT},
  {"linextrapol",0,{{-1}},NPY_INT},
  {"rungekutta",0,{{-1}},NPY_INT},
  {"dadi",0,{{-1}},NPY_INT},
  {"nllusgs",0,{{-1}},NPY_INT},
  {"nllusgsline",0,{{-1}},NPY_INT},
  {"decoupled",0,{{-1}},NPY_INT},
  {"coupled",0,{{-1}},NPY_INT},
  {"gmres",0,{{-1}},NPY_INT},
  {"adi",0,{{-1}},NPY_INT},
  {"bcdirichlet0",0,{{-1}},NPY_INT},
  {"bcneumann0",0,{{-1}},NPY_INT},
  {"noresaveraging",0,{{-1}},NPY_INT},
  {"alwaysresaveraging",0,{{-1}},NPY_INT},
  {"alternateresaveraging",0,{{-1}},NPY_INT},
  {"turbrelaxnotdefined",0,{{-1}},NPY_INT},
  {"turbrelaxexplicit",0,{{-1}},NPY_INT},
  {"turbrelaximplicit",0,{{-1}},NPY_INT},
  {"precisionsingle",0,{{-1}},NPY_INT},
  {"precisiondouble",0,{{-1}},NPY_INT},
  {"bdf",0,{{-1}},NPY_INT},
  {"explicitrk",0,{{-1}},NPY_INT},
  {"implicitrk",0,{{-1}},NPY_INT},
  {"md",0,{{-1}},NPY_INT},
  {"nolinesearch",0,{{-1}},NPY_INT},
  {"cubiclinesearch",0,{{-1}},NPY_INT},
  {"nonmonotonelinesearch",0,{{-1}},NPY_INT},
  {"updatefrozen",0,{{-1}},NPY_INT},
  {"updatefast",0,{{-1}},NPY_INT},
  {"updatefull",0,{{-1}},NPY_INT},
  {"ncostfunction",0,{{-1}},NPY_INT},
  {"costfunccdq",0,{{-1}},NPY_INT},
  {"costfuncforcezcoef",0,{{-1}},NPY_INT},
  {"costfuncmomzcoef",0,{{-1}},NPY_INT},
  {"costfunccm0",0,{{-1}},NPY_INT},
  {"costfuncforcex",0,{{-1}},NPY_INT},
  {"costfuncclq",0,{{-1}},NPY_INT},
  {"costfuncdrag",0,{{-1}},NPY_INT},
  {"costfunccl0",0,{{-1}},NPY_INT},
  {"costfunccmzqdot",0,{{-1}},NPY_INT},
  {"costfuncforcexcoef",0,{{-1}},NPY_INT},
  {"costfunccmzq",0,{{-1}},NPY_INT},
  {"costfunccmzalphadot",0,{{-1}},NPY_INT},
  {"costfunclift",0,{{-1}},NPY_INT},
  {"costfunccd0",0,{{-1}},NPY_INT},
  {"costfuncclqdot",0,{{-1}},NPY_INT},
  {"costfuncforcey",0,{{-1}},NPY_INT},
  {"costfuncforcez",0,{{-1}},NPY_INT},
  {"costfuncmomz",0,{{-1}},NPY_INT},
  {"costfunccdqdot",0,{{-1}},NPY_INT},
  {"costfuncmomx",0,{{-1}},NPY_INT},
  {"costfuncmomy",0,{{-1}},NPY_INT},
  {"costfunccdalphadot",0,{{-1}},NPY_INT},
  {"costfuncmomxcoef",0,{{-1}},NPY_INT},
  {"costfunccdalpha",0,{{-1}},NPY_INT},
  {"costfuncliftcoef",0,{{-1}},NPY_INT},
  {"costfunccmzalpha",0,{{-1}},NPY_INT},
  {"costfuncdragcoef",0,{{-1}},NPY_INT},
  {"costfuncclalphadot",0,{{-1}},NPY_INT},
  {"costfuncforceycoef",0,{{-1}},NPY_INT},
  {"costfuncclalpha",0,{{-1}},NPY_INT},
  {"costfuncmomycoef",0,{{-1}},NPY_INT},
  {"costfunccfy0",0,{{-1}},NPY_INT},
  {"costfunccfyalpha",0,{{-1}},NPY_INT},
  {"costfunccfyalphadot",0,{{-1}},NPY_INT},
  {"costfunccfyq",0,{{-1}},NPY_INT},
  {"costfunccfyqdot",0,{{-1}},NPY_INT},
  {"costfuncbendingcoef",0,{{-1}},NPY_INT},
  {"costfuncsepsensor",0,{{-1}},NPY_INT},
  {"costfuncsepsensoravgx",0,{{-1}},NPY_INT},
  {"costfuncsepsensoravgy",0,{{-1}},NPY_INT},
  {"costfuncsepsensoravgz",0,{{-1}},NPY_INT},
  {"costfunccavitation",0,{{-1}},NPY_INT},
  {"costfuncmdot",0,{{-1}},NPY_INT},
  {"costfuncmavgptot",0,{{-1}},NPY_INT},
  {"costfuncmavgttot",0,{{-1}},NPY_INT},
  {"costfuncmavgrho",0,{{-1}},NPY_INT},
  {"costfuncmavgps",0,{{-1}},NPY_INT},
  {"costfuncmavgmn",0,{{-1}},NPY_INT},
  {"costfuncmavga",0,{{-1}},NPY_INT},
  {"costfuncarea",0,{{-1}},NPY_INT},
  {"costfuncaxismoment",0,{{-1}},NPY_INT},
  {"costfuncflowpower",0,{{-1}},NPY_INT},
  {"costfuncforcexpressure",0,{{-1}},NPY_INT},
  {"costfuncforceypressure",0,{{-1}},NPY_INT},
  {"costfuncforcezpressure",0,{{-1}},NPY_INT},
  {"costfuncforcexviscous",0,{{-1}},NPY_INT},
  {"costfuncforceyviscous",0,{{-1}},NPY_INT},
  {"costfuncforcezviscous",0,{{-1}},NPY_INT},
  {"costfuncforcexmomentum",0,{{-1}},NPY_INT},
  {"costfuncforceymomentum",0,{{-1}},NPY_INT},
  {"costfuncforcezmomentum",0,{{-1}},NPY_INT},
  {"costfuncdragpressure",0,{{-1}},NPY_INT},
  {"costfuncdragviscous",0,{{-1}},NPY_INT},
  {"costfuncdragmomentum",0,{{-1}},NPY_INT},
  {"costfuncliftpressure",0,{{-1}},NPY_INT},
  {"costfuncliftviscous",0,{{-1}},NPY_INT},
  {"costfuncliftmomentum",0,{{-1}},NPY_INT},
  {"costfuncforcexcoefpressure",0,{{-1}},NPY_INT},
  {"costfuncforcexcoefviscous",0,{{-1}},NPY_INT},
  {"costfuncforcexcoefmomentum",0,{{-1}},NPY_INT},
  {"costfuncforceycoefpressure",0,{{-1}},NPY_INT},
  {"costfuncforceycoefviscous",0,{{-1}},NPY_INT},
  {"costfuncforceycoefmomentum",0,{{-1}},NPY_INT},
  {"costfuncforcezcoefpressure",0,{{-1}},NPY_INT},
  {"costfuncforcezcoefviscous",0,{{-1}},NPY_INT},
  {"costfuncforcezcoefmomentum",0,{{-1}},NPY_INT},
  {"costfuncliftcoefpressure",0,{{-1}},NPY_INT},
  {"costfuncliftcoefviscous",0,{{-1}},NPY_INT},
  {"costfuncliftcoefmomentum",0,{{-1}},NPY_INT},
  {"costfuncdragcoefpressure",0,{{-1}},NPY_INT},
  {"costfuncdragcoefviscous",0,{{-1}},NPY_INT},
  {"costfuncdragcoefmomentum",0,{{-1}},NPY_INT},
  {"costfuncmavgvx",0,{{-1}},NPY_INT},
  {"costfuncmavgvy",0,{{-1}},NPY_INT},
  {"costfuncmavgvz",0,{{-1}},NPY_INT},
  {"costfunccperror2",0,{{-1}},NPY_INT},
  {"costfuncaavgptot",0,{{-1}},NPY_INT},
  {"costfuncaavgps",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_constants(char *maxstringlen,char *maxcgnsnamelen,char *eulerequations,char *nsequations,char *ransequations,char *steady,char *unsteady,char *timespectral,char *internalflow,char *externalflow,char *cpconstant,char *cptempcurvefits,char *spalartallmaras,char *spalartallmarasedwards,char *komegawilcox,char *komegamodified,char *ktau,char *mentersst,char *v2f,char *strain,char *vorticity,char *katolaunder,char *dissscalar,char *dissmatrix,char *disscusp,char *upwind,char *roe,char *vanleer,char *ausmdv,char *nolimiter,char *vanalbeda,char *minmod,char *noprecond,char *turkel,char *choimerkle,char *constantpressure,char *linextrapolpressure,char *quadextrapolpressure,char *normalmomentum,char *constantextrapol,char *linextrapol,char *rungekutta,char *dadi,char *nllusgs,char *nllusgsline,char *decoupled,char *coupled,char *gmres,char *adi,char *bcdirichlet0,char *bcneumann0,char *noresaveraging,char *alwaysresaveraging,char *alternateresaveraging,char *turbrelaxnotdefined,char *turbrelaxexplicit,char *turbrelaximplicit,char *precisionsingle,char *precisiondouble,char *bdf,char *explicitrk,char *implicitrk,char *md,char *nolinesearch,char *cubiclinesearch,char *nonmonotonelinesearch,char *updatefrozen,char *updatefast,char *updatefull,char *ncostfunction,char *costfunccdq,char *costfuncforcezcoef,char *costfuncmomzcoef,char *costfunccm0,char *costfuncforcex,char *costfuncclq,char *costfuncdrag,char *costfunccl0,char *costfunccmzqdot,char *costfuncforcexcoef,char *costfunccmzq,char *costfunccmzalphadot,char *costfunclift,char *costfunccd0,char *costfuncclqdot,char *costfuncforcey,char *costfuncforcez,char *costfuncmomz,char *costfunccdqdot,char *costfuncmomx,char *costfuncmomy,char *costfunccdalphadot,char *costfuncmomxcoef,char *costfunccdalpha,char *costfuncliftcoef,char *costfunccmzalpha,char *costfuncdragcoef,char *costfuncclalphadot,char *costfuncforceycoef,char *costfuncclalpha,char *costfuncmomycoef,char *costfunccfy0,char *costfunccfyalpha,char *costfunccfyalphadot,char *costfunccfyq,char *costfunccfyqdot,char *costfuncbendingcoef,char *costfuncsepsensor,char *costfuncsepsensoravgx,char *costfuncsepsensoravgy,char *costfuncsepsensoravgz,char *costfunccavitation,char *costfuncmdot,char *costfuncmavgptot,char *costfuncmavgttot,char *costfuncmavgrho,char *costfuncmavgps,char *costfuncmavgmn,char *costfuncmavga,char *costfuncarea,char *costfuncaxismoment,char *costfuncflowpower,char *costfuncforcexpressure,char *costfuncforceypressure,char *costfuncforcezpressure,char *costfuncforcexviscous,char *costfuncforceyviscous,char *costfuncforcezviscous,char *costfuncforcexmomentum,char *costfuncforceymomentum,char *costfuncforcezmomentum,char *costfuncdragpressure,char *costfuncdragviscous,char *costfuncdragmomentum,char *costfuncliftpressure,char *costfuncliftviscous,char *costfuncliftmomentum,char *costfuncforcexcoefpressure,char *costfuncforcexcoefviscous,char *costfuncforcexcoefmomentum,char *costfuncforceycoefpressure,char *costfuncforceycoefviscous,char *costfuncforceycoefmomentum,char *costfuncforcezcoefpressure,char *costfuncforcezcoefviscous,char *costfuncforcezcoefmomentum,char *costfuncliftcoefpressure,char *costfuncliftcoefviscous,char *costfuncliftcoefmomentum,char *costfuncdragcoefpressure,char *costfuncdragcoefviscous,char *costfuncdragcoefmomentum,char *costfuncmavgvx,char *costfuncmavgvy,char *costfuncmavgvz,char *costfunccperror2,char *costfuncaavgptot,char *costfuncaavgps) {
  int i_f2py=0;
  f2py_constants_def[i_f2py++].data = maxstringlen;
  f2py_constants_def[i_f2py++].data = maxcgnsnamelen;
  f2py_constants_def[i_f2py++].data = eulerequations;
  f2py_constants_def[i_f2py++].data = nsequations;
  f2py_constants_def[i_f2py++].data = ransequations;
  f2py_constants_def[i_f2py++].data = steady;
  f2py_constants_def[i_f2py++].data = unsteady;
  f2py_constants_def[i_f2py++].data = timespectral;
  f2py_constants_def[i_f2py++].data = internalflow;
  f2py_constants_def[i_f2py++].data = externalflow;
  f2py_constants_def[i_f2py++].data = cpconstant;
  f2py_constants_def[i_f2py++].data = cptempcurvefits;
  f2py_constants_def[i_f2py++].data = spalartallmaras;
  f2py_constants_def[i_f2py++].data = spalartallmarasedwards;
  f2py_constants_def[i_f2py++].data = komegawilcox;
  f2py_constants_def[i_f2py++].data = komegamodified;
  f2py_constants_def[i_f2py++].data = ktau;
  f2py_constants_def[i_f2py++].data = mentersst;
  f2py_constants_def[i_f2py++].data = v2f;
  f2py_constants_def[i_f2py++].data = strain;
  f2py_constants_def[i_f2py++].data = vorticity;
  f2py_constants_def[i_f2py++].data = katolaunder;
  f2py_constants_def[i_f2py++].data = dissscalar;
  f2py_constants_def[i_f2py++].data = dissmatrix;
  f2py_constants_def[i_f2py++].data = disscusp;
  f2py_constants_def[i_f2py++].data = upwind;
  f2py_constants_def[i_f2py++].data = roe;
  f2py_constants_def[i_f2py++].data = vanleer;
  f2py_constants_def[i_f2py++].data = ausmdv;
  f2py_constants_def[i_f2py++].data = nolimiter;
  f2py_constants_def[i_f2py++].data = vanalbeda;
  f2py_constants_def[i_f2py++].data = minmod;
  f2py_constants_def[i_f2py++].data = noprecond;
  f2py_constants_def[i_f2py++].data = turkel;
  f2py_constants_def[i_f2py++].data = choimerkle;
  f2py_constants_def[i_f2py++].data = constantpressure;
  f2py_constants_def[i_f2py++].data = linextrapolpressure;
  f2py_constants_def[i_f2py++].data = quadextrapolpressure;
  f2py_constants_def[i_f2py++].data = normalmomentum;
  f2py_constants_def[i_f2py++].data = constantextrapol;
  f2py_constants_def[i_f2py++].data = linextrapol;
  f2py_constants_def[i_f2py++].data = rungekutta;
  f2py_constants_def[i_f2py++].data = dadi;
  f2py_constants_def[i_f2py++].data = nllusgs;
  f2py_constants_def[i_f2py++].data = nllusgsline;
  f2py_constants_def[i_f2py++].data = decoupled;
  f2py_constants_def[i_f2py++].data = coupled;
  f2py_constants_def[i_f2py++].data = gmres;
  f2py_constants_def[i_f2py++].data = adi;
  f2py_constants_def[i_f2py++].data = bcdirichlet0;
  f2py_constants_def[i_f2py++].data = bcneumann0;
  f2py_constants_def[i_f2py++].data = noresaveraging;
  f2py_constants_def[i_f2py++].data = alwaysresaveraging;
  f2py_constants_def[i_f2py++].data = alternateresaveraging;
  f2py_constants_def[i_f2py++].data = turbrelaxnotdefined;
  f2py_constants_def[i_f2py++].data = turbrelaxexplicit;
  f2py_constants_def[i_f2py++].data = turbrelaximplicit;
  f2py_constants_def[i_f2py++].data = precisionsingle;
  f2py_constants_def[i_f2py++].data = precisiondouble;
  f2py_constants_def[i_f2py++].data = bdf;
  f2py_constants_def[i_f2py++].data = explicitrk;
  f2py_constants_def[i_f2py++].data = implicitrk;
  f2py_constants_def[i_f2py++].data = md;
  f2py_constants_def[i_f2py++].data = nolinesearch;
  f2py_constants_def[i_f2py++].data = cubiclinesearch;
  f2py_constants_def[i_f2py++].data = nonmonotonelinesearch;
  f2py_constants_def[i_f2py++].data = updatefrozen;
  f2py_constants_def[i_f2py++].data = updatefast;
  f2py_constants_def[i_f2py++].data = updatefull;
  f2py_constants_def[i_f2py++].data = ncostfunction;
  f2py_constants_def[i_f2py++].data = costfunccdq;
  f2py_constants_def[i_f2py++].data = costfuncforcezcoef;
  f2py_constants_def[i_f2py++].data = costfuncmomzcoef;
  f2py_constants_def[i_f2py++].data = costfunccm0;
  f2py_constants_def[i_f2py++].data = costfuncforcex;
  f2py_constants_def[i_f2py++].data = costfuncclq;
  f2py_constants_def[i_f2py++].data = costfuncdrag;
  f2py_constants_def[i_f2py++].data = costfunccl0;
  f2py_constants_def[i_f2py++].data = costfunccmzqdot;
  f2py_constants_def[i_f2py++].data = costfuncforcexcoef;
  f2py_constants_def[i_f2py++].data = costfunccmzq;
  f2py_constants_def[i_f2py++].data = costfunccmzalphadot;
  f2py_constants_def[i_f2py++].data = costfunclift;
  f2py_constants_def[i_f2py++].data = costfunccd0;
  f2py_constants_def[i_f2py++].data = costfuncclqdot;
  f2py_constants_def[i_f2py++].data = costfuncforcey;
  f2py_constants_def[i_f2py++].data = costfuncforcez;
  f2py_constants_def[i_f2py++].data = costfuncmomz;
  f2py_constants_def[i_f2py++].data = costfunccdqdot;
  f2py_constants_def[i_f2py++].data = costfuncmomx;
  f2py_constants_def[i_f2py++].data = costfuncmomy;
  f2py_constants_def[i_f2py++].data = costfunccdalphadot;
  f2py_constants_def[i_f2py++].data = costfuncmomxcoef;
  f2py_constants_def[i_f2py++].data = costfunccdalpha;
  f2py_constants_def[i_f2py++].data = costfuncliftcoef;
  f2py_constants_def[i_f2py++].data = costfunccmzalpha;
  f2py_constants_def[i_f2py++].data = costfuncdragcoef;
  f2py_constants_def[i_f2py++].data = costfuncclalphadot;
  f2py_constants_def[i_f2py++].data = costfuncforceycoef;
  f2py_constants_def[i_f2py++].data = costfuncclalpha;
  f2py_constants_def[i_f2py++].data = costfuncmomycoef;
  f2py_constants_def[i_f2py++].data = costfunccfy0;
  f2py_constants_def[i_f2py++].data = costfunccfyalpha;
  f2py_constants_def[i_f2py++].data = costfunccfyalphadot;
  f2py_constants_def[i_f2py++].data = costfunccfyq;
  f2py_constants_def[i_f2py++].data = costfunccfyqdot;
  f2py_constants_def[i_f2py++].data = costfuncbendingcoef;
  f2py_constants_def[i_f2py++].data = costfuncsepsensor;
  f2py_constants_def[i_f2py++].data = costfuncsepsensoravgx;
  f2py_constants_def[i_f2py++].data = costfuncsepsensoravgy;
  f2py_constants_def[i_f2py++].data = costfuncsepsensoravgz;
  f2py_constants_def[i_f2py++].data = costfunccavitation;
  f2py_constants_def[i_f2py++].data = costfuncmdot;
  f2py_constants_def[i_f2py++].data = costfuncmavgptot;
  f2py_constants_def[i_f2py++].data = costfuncmavgttot;
  f2py_constants_def[i_f2py++].data = costfuncmavgrho;
  f2py_constants_def[i_f2py++].data = costfuncmavgps;
  f2py_constants_def[i_f2py++].data = costfuncmavgmn;
  f2py_constants_def[i_f2py++].data = costfuncmavga;
  f2py_constants_def[i_f2py++].data = costfuncarea;
  f2py_constants_def[i_f2py++].data = costfuncaxismoment;
  f2py_constants_def[i_f2py++].data = costfuncflowpower;
  f2py_constants_def[i_f2py++].data = costfuncforcexpressure;
  f2py_constants_def[i_f2py++].data = costfuncforceypressure;
  f2py_constants_def[i_f2py++].data = costfuncforcezpressure;
  f2py_constants_def[i_f2py++].data = costfuncforcexviscous;
  f2py_constants_def[i_f2py++].data = costfuncforceyviscous;
  f2py_constants_def[i_f2py++].data = costfuncforcezviscous;
  f2py_constants_def[i_f2py++].data = costfuncforcexmomentum;
  f2py_constants_def[i_f2py++].data = costfuncforceymomentum;
  f2py_constants_def[i_f2py++].data = costfuncforcezmomentum;
  f2py_constants_def[i_f2py++].data = costfuncdragpressure;
  f2py_constants_def[i_f2py++].data = costfuncdragviscous;
  f2py_constants_def[i_f2py++].data = costfuncdragmomentum;
  f2py_constants_def[i_f2py++].data = costfuncliftpressure;
  f2py_constants_def[i_f2py++].data = costfuncliftviscous;
  f2py_constants_def[i_f2py++].data = costfuncliftmomentum;
  f2py_constants_def[i_f2py++].data = costfuncforcexcoefpressure;
  f2py_constants_def[i_f2py++].data = costfuncforcexcoefviscous;
  f2py_constants_def[i_f2py++].data = costfuncforcexcoefmomentum;
  f2py_constants_def[i_f2py++].data = costfuncforceycoefpressure;
  f2py_constants_def[i_f2py++].data = costfuncforceycoefviscous;
  f2py_constants_def[i_f2py++].data = costfuncforceycoefmomentum;
  f2py_constants_def[i_f2py++].data = costfuncforcezcoefpressure;
  f2py_constants_def[i_f2py++].data = costfuncforcezcoefviscous;
  f2py_constants_def[i_f2py++].data = costfuncforcezcoefmomentum;
  f2py_constants_def[i_f2py++].data = costfuncliftcoefpressure;
  f2py_constants_def[i_f2py++].data = costfuncliftcoefviscous;
  f2py_constants_def[i_f2py++].data = costfuncliftcoefmomentum;
  f2py_constants_def[i_f2py++].data = costfuncdragcoefpressure;
  f2py_constants_def[i_f2py++].data = costfuncdragcoefviscous;
  f2py_constants_def[i_f2py++].data = costfuncdragcoefmomentum;
  f2py_constants_def[i_f2py++].data = costfuncmavgvx;
  f2py_constants_def[i_f2py++].data = costfuncmavgvy;
  f2py_constants_def[i_f2py++].data = costfuncmavgvz;
  f2py_constants_def[i_f2py++].data = costfunccperror2;
  f2py_constants_def[i_f2py++].data = costfuncaavgptot;
  f2py_constants_def[i_f2py++].data = costfuncaavgps;
}
extern void F_FUNC(f2pyinitconstants,F2PYINITCONSTANTS)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_constants(void) {
  F_FUNC(f2pyinitconstants,F2PYINITCONSTANTS)(f2py_setup_constants);
}


static FortranDataDef f2py_communication_def[] = {
  {"adflow_comm_world",0,{{-1}},NPY_INT},
  {"myid",0,{{-1}},NPY_INT},
  {"nproc",0,{{-1}},NPY_INT},
  {"sendrequests",1,{{-1}},NPY_INT},
  {"recvrequests",1,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_communication(char *adflow_comm_world,char *myid,char *nproc,void (*sendrequests)(int*,int*,void(*)(char*,int*),int*),void (*recvrequests)(int*,int*,void(*)(char*,int*),int*)) {
  int i_f2py=0;
  f2py_communication_def[i_f2py++].data = adflow_comm_world;
  f2py_communication_def[i_f2py++].data = myid;
  f2py_communication_def[i_f2py++].data = nproc;
  f2py_communication_def[i_f2py++].func = sendrequests;
  f2py_communication_def[i_f2py++].func = recvrequests;
}
extern void F_FUNC(f2pyinitcommunication,F2PYINITCOMMUNICATION)(void (*)(char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*)));
static void f2py_init_communication(void) {
  F_FUNC(f2pyinitcommunication,F2PYINITCOMMUNICATION)(f2py_setup_communication);
}


static FortranDataDef f2py_inputdiscretization_def[] = {
  {"spacediscr",0,{{-1}},NPY_INT},
  {"spacediscrcoarse",0,{{-1}},NPY_INT},
  {"orderturb",0,{{-1}},NPY_INT},
  {"limiter",0,{{-1}},NPY_INT},
  {"riemann",0,{{-1}},NPY_INT},
  {"riemanncoarse",0,{{-1}},NPY_INT},
  {"precond",0,{{-1}},NPY_INT},
  {"eulerwallbctreatment",0,{{-1}},NPY_INT},
  {"viscwallbctreatment",0,{{-1}},NPY_INT},
  {"outflowtreatment",0,{{-1}},NPY_INT},
  {"vis2",0,{{-1}},NPY_DOUBLE},
  {"vis4",0,{{-1}},NPY_DOUBLE},
  {"vis2coarse",0,{{-1}},NPY_DOUBLE},
  {"adis",0,{{-1}},NPY_DOUBLE},
  {"kappacoef",0,{{-1}},NPY_DOUBLE},
  {"vortexcorr",0,{{-1}},NPY_INT},
  {"dirscaling",0,{{-1}},NPY_INT},
  {"radiineededfine",0,{{-1}},NPY_INT},
  {"radiineededcoarse",0,{{-1}},NPY_INT},
  {"lumpeddiss",0,{{-1}},NPY_INT},
  {"sigma",0,{{-1}},NPY_DOUBLE},
  {"useapproxwalldistance",0,{{-1}},NPY_INT},
  {"lowspeedpreconditioner",0,{{-1}},NPY_INT},
  {"useblockettes",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_inputdiscretization(char *spacediscr,char *spacediscrcoarse,char *orderturb,char *limiter,char *riemann,char *riemanncoarse,char *precond,char *eulerwallbctreatment,char *viscwallbctreatment,char *outflowtreatment,char *vis2,char *vis4,char *vis2coarse,char *adis,char *kappacoef,char *vortexcorr,char *dirscaling,char *radiineededfine,char *radiineededcoarse,char *lumpeddiss,char *sigma,char *useapproxwalldistance,char *lowspeedpreconditioner,char *useblockettes) {
  int i_f2py=0;
  f2py_inputdiscretization_def[i_f2py++].data = spacediscr;
  f2py_inputdiscretization_def[i_f2py++].data = spacediscrcoarse;
  f2py_inputdiscretization_def[i_f2py++].data = orderturb;
  f2py_inputdiscretization_def[i_f2py++].data = limiter;
  f2py_inputdiscretization_def[i_f2py++].data = riemann;
  f2py_inputdiscretization_def[i_f2py++].data = riemanncoarse;
  f2py_inputdiscretization_def[i_f2py++].data = precond;
  f2py_inputdiscretization_def[i_f2py++].data = eulerwallbctreatment;
  f2py_inputdiscretization_def[i_f2py++].data = viscwallbctreatment;
  f2py_inputdiscretization_def[i_f2py++].data = outflowtreatment;
  f2py_inputdiscretization_def[i_f2py++].data = vis2;
  f2py_inputdiscretization_def[i_f2py++].data = vis4;
  f2py_inputdiscretization_def[i_f2py++].data = vis2coarse;
  f2py_inputdiscretization_def[i_f2py++].data = adis;
  f2py_inputdiscretization_def[i_f2py++].data = kappacoef;
  f2py_inputdiscretization_def[i_f2py++].data = vortexcorr;
  f2py_inputdiscretization_def[i_f2py++].data = dirscaling;
  f2py_inputdiscretization_def[i_f2py++].data = radiineededfine;
  f2py_inputdiscretization_def[i_f2py++].data = radiineededcoarse;
  f2py_inputdiscretization_def[i_f2py++].data = lumpeddiss;
  f2py_inputdiscretization_def[i_f2py++].data = sigma;
  f2py_inputdiscretization_def[i_f2py++].data = useapproxwalldistance;
  f2py_inputdiscretization_def[i_f2py++].data = lowspeedpreconditioner;
  f2py_inputdiscretization_def[i_f2py++].data = useblockettes;
}
extern void F_FUNC(f2pyinitinputdiscretization,F2PYINITINPUTDISCRETIZATION)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_inputdiscretization(void) {
  F_FUNC(f2pyinitinputdiscretization,F2PYINITINPUTDISCRETIZATION)(f2py_setup_inputdiscretization);
}


static FortranDataDef f2py_cgnsgrid_def[] = {
  {"cgnsndom",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_cgnsgrid(char *cgnsndom) {
  int i_f2py=0;
  f2py_cgnsgrid_def[i_f2py++].data = cgnsndom;
}
extern void F_FUNC(f2pyinitcgnsgrid,F2PYINITCGNSGRID)(void (*)(char*));
static void f2py_init_cgnsgrid(void) {
  F_FUNC(f2pyinitcgnsgrid,F2PYINITCGNSGRID)(f2py_setup_cgnsgrid);
}


static FortranDataDef f2py_inputio_def[] = {
  {"solfile",1,{{256}},NPY_STRING},
  {"surfacesolfile",1,{{256}},NPY_STRING},
  {"slicesolfile",1,{{256}},NPY_STRING},
  {"liftdistributionfile",1,{{256}},NPY_STRING},
  {"cpfile",1,{{256}},NPY_STRING},
  {"writecoormeter",0,{{-1}},NPY_INT},
  {"precisionsol",0,{{-1}},NPY_INT},
  {"precisiongrid",0,{{-1}},NPY_INT},
  {"precisionsurfsol",0,{{-1}},NPY_INT},
  {"precisionsurfgrid",0,{{-1}},NPY_INT},
  {"newgridfile",1,{{256}},NPY_STRING},
  {"gridfile",1,{{256}},NPY_STRING},
  {"storeconvinneriter",0,{{-1}},NPY_INT},
  {"storerindlayer",0,{{-1}},NPY_INT},
  {"checkrestartsol",0,{{-1}},NPY_INT},
  {"autoparameterupdate",0,{{-1}},NPY_INT},
  {"viscoussurfacevelocities",0,{{-1}},NPY_INT},
  {"firstwrite",0,{{-1}},NPY_INT},
  {"paramfile",1,{{256}},NPY_STRING},
  {"forcedvolumefile",1,{{256}},NPY_STRING},
  {"forcedsurfacefile",1,{{256}},NPY_STRING},
  {"forcedliftfile",1,{{256}},NPY_STRING},
  {"forcedslicefile",1,{{256}},NPY_STRING},
  {NULL}
};

static void f2py_setup_inputio(char *solfile,char *surfacesolfile,char *slicesolfile,char *liftdistributionfile,char *cpfile,char *writecoormeter,char *precisionsol,char *precisiongrid,char *precisionsurfsol,char *precisionsurfgrid,char *newgridfile,char *gridfile,char *storeconvinneriter,char *storerindlayer,char *checkrestartsol,char *autoparameterupdate,char *viscoussurfacevelocities,char *firstwrite,char *paramfile,char *forcedvolumefile,char *forcedsurfacefile,char *forcedliftfile,char *forcedslicefile) {
  int i_f2py=0;
  f2py_inputio_def[i_f2py++].data = solfile;
  f2py_inputio_def[i_f2py++].data = surfacesolfile;
  f2py_inputio_def[i_f2py++].data = slicesolfile;
  f2py_inputio_def[i_f2py++].data = liftdistributionfile;
  f2py_inputio_def[i_f2py++].data = cpfile;
  f2py_inputio_def[i_f2py++].data = writecoormeter;
  f2py_inputio_def[i_f2py++].data = precisionsol;
  f2py_inputio_def[i_f2py++].data = precisiongrid;
  f2py_inputio_def[i_f2py++].data = precisionsurfsol;
  f2py_inputio_def[i_f2py++].data = precisionsurfgrid;
  f2py_inputio_def[i_f2py++].data = newgridfile;
  f2py_inputio_def[i_f2py++].data = gridfile;
  f2py_inputio_def[i_f2py++].data = storeconvinneriter;
  f2py_inputio_def[i_f2py++].data = storerindlayer;
  f2py_inputio_def[i_f2py++].data = checkrestartsol;
  f2py_inputio_def[i_f2py++].data = autoparameterupdate;
  f2py_inputio_def[i_f2py++].data = viscoussurfacevelocities;
  f2py_inputio_def[i_f2py++].data = firstwrite;
  f2py_inputio_def[i_f2py++].data = paramfile;
  f2py_inputio_def[i_f2py++].data = forcedvolumefile;
  f2py_inputio_def[i_f2py++].data = forcedsurfacefile;
  f2py_inputio_def[i_f2py++].data = forcedliftfile;
  f2py_inputio_def[i_f2py++].data = forcedslicefile;
}
extern void F_FUNC(f2pyinitinputio,F2PYINITINPUTIO)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_inputio(void) {
  F_FUNC(f2pyinitinputio,F2PYINITINPUTIO)(f2py_setup_inputio);
}


static FortranDataDef f2py_inputiteration_def[] = {
  {"rkreset",0,{{-1}},NPY_INT},
  {"mgdescription",1,{{256}},NPY_STRING},
  {"ncycles",0,{{-1}},NPY_INT},
  {"timelimit",0,{{-1}},NPY_DOUBLE},
  {"ncyclescoarse",0,{{-1}},NPY_INT},
  {"nsavevolume",0,{{-1}},NPY_INT},
  {"nsavesurface",0,{{-1}},NPY_INT},
  {"nsgstartup",0,{{-1}},NPY_INT},
  {"smoother",0,{{-1}},NPY_INT},
  {"nrkstages",0,{{-1}},NPY_INT},
  {"resaveraging",0,{{-1}},NPY_INT},
  {"cfllimit",0,{{-1}},NPY_DOUBLE},
  {"turbtreatment",0,{{-1}},NPY_INT},
  {"nsubiterturb",0,{{-1}},NPY_INT},
  {"nsubiterations",0,{{-1}},NPY_INT},
  {"turbsmoother",0,{{-1}},NPY_INT},
  {"turbrelax",0,{{-1}},NPY_INT},
  {"mgboundcorr",0,{{-1}},NPY_INT},
  {"mgstartlevel",0,{{-1}},NPY_INT},
  {"nmgsteps",0,{{-1}},NPY_INT},
  {"nmglevels",0,{{-1}},NPY_INT},
  {"miniternum",0,{{-1}},NPY_INT},
  {"convcheckwindowsize",0,{{-1}},NPY_INT},
  {"cyclestrategy",1,{{-1}},NPY_INT},
  {"cfl",0,{{-1}},NPY_DOUBLE},
  {"cflcoarse",0,{{-1}},NPY_DOUBLE},
  {"fcoll",0,{{-1}},NPY_DOUBLE},
  {"smoop",0,{{-1}},NPY_DOUBLE},
  {"alfaturb",0,{{-1}},NPY_DOUBLE},
  {"betaturb",0,{{-1}},NPY_DOUBLE},
  {"l2conv",0,{{-1}},NPY_DOUBLE},
  {"l2convcoarse",0,{{-1}},NPY_DOUBLE},
  {"l2convrel",0,{{-1}},NPY_DOUBLE},
  {"epscoefconv",0,{{-1}},NPY_DOUBLE},
  {"etark",1,{{-1}},NPY_DOUBLE},
  {"cdisrk",1,{{-1}},NPY_DOUBLE},
  {"turbresscale",1,{{4}},NPY_DOUBLE},
  {"freezeturbsource",0,{{-1}},NPY_INT},
  {"printiterations",0,{{-1}},NPY_INT},
  {"printwarnings",0,{{-1}},NPY_INT},
  {"maxl2deviationfactor",0,{{-1}},NPY_DOUBLE},
  {"uselinresmonitor",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_inputiteration(char *rkreset,char *mgdescription,char *ncycles,char *timelimit,char *ncyclescoarse,char *nsavevolume,char *nsavesurface,char *nsgstartup,char *smoother,char *nrkstages,char *resaveraging,char *cfllimit,char *turbtreatment,char *nsubiterturb,char *nsubiterations,char *turbsmoother,char *turbrelax,char *mgboundcorr,char *mgstartlevel,char *nmgsteps,char *nmglevels,char *miniternum,char *convcheckwindowsize,void (*cyclestrategy)(int*,int*,void(*)(char*,int*),int*),char *cfl,char *cflcoarse,char *fcoll,char *smoop,char *alfaturb,char *betaturb,char *l2conv,char *l2convcoarse,char *l2convrel,char *epscoefconv,void (*etark)(int*,int*,void(*)(char*,int*),int*),void (*cdisrk)(int*,int*,void(*)(char*,int*),int*),char *turbresscale,char *freezeturbsource,char *printiterations,char *printwarnings,char *maxl2deviationfactor,char *uselinresmonitor) {
  int i_f2py=0;
  f2py_inputiteration_def[i_f2py++].data = rkreset;
  f2py_inputiteration_def[i_f2py++].data = mgdescription;
  f2py_inputiteration_def[i_f2py++].data = ncycles;
  f2py_inputiteration_def[i_f2py++].data = timelimit;
  f2py_inputiteration_def[i_f2py++].data = ncyclescoarse;
  f2py_inputiteration_def[i_f2py++].data = nsavevolume;
  f2py_inputiteration_def[i_f2py++].data = nsavesurface;
  f2py_inputiteration_def[i_f2py++].data = nsgstartup;
  f2py_inputiteration_def[i_f2py++].data = smoother;
  f2py_inputiteration_def[i_f2py++].data = nrkstages;
  f2py_inputiteration_def[i_f2py++].data = resaveraging;
  f2py_inputiteration_def[i_f2py++].data = cfllimit;
  f2py_inputiteration_def[i_f2py++].data = turbtreatment;
  f2py_inputiteration_def[i_f2py++].data = nsubiterturb;
  f2py_inputiteration_def[i_f2py++].data = nsubiterations;
  f2py_inputiteration_def[i_f2py++].data = turbsmoother;
  f2py_inputiteration_def[i_f2py++].data = turbrelax;
  f2py_inputiteration_def[i_f2py++].data = mgboundcorr;
  f2py_inputiteration_def[i_f2py++].data = mgstartlevel;
  f2py_inputiteration_def[i_f2py++].data = nmgsteps;
  f2py_inputiteration_def[i_f2py++].data = nmglevels;
  f2py_inputiteration_def[i_f2py++].data = miniternum;
  f2py_inputiteration_def[i_f2py++].data = convcheckwindowsize;
  f2py_inputiteration_def[i_f2py++].func = cyclestrategy;
  f2py_inputiteration_def[i_f2py++].data = cfl;
  f2py_inputiteration_def[i_f2py++].data = cflcoarse;
  f2py_inputiteration_def[i_f2py++].data = fcoll;
  f2py_inputiteration_def[i_f2py++].data = smoop;
  f2py_inputiteration_def[i_f2py++].data = alfaturb;
  f2py_inputiteration_def[i_f2py++].data = betaturb;
  f2py_inputiteration_def[i_f2py++].data = l2conv;
  f2py_inputiteration_def[i_f2py++].data = l2convcoarse;
  f2py_inputiteration_def[i_f2py++].data = l2convrel;
  f2py_inputiteration_def[i_f2py++].data = epscoefconv;
  f2py_inputiteration_def[i_f2py++].func = etark;
  f2py_inputiteration_def[i_f2py++].func = cdisrk;
  f2py_inputiteration_def[i_f2py++].data = turbresscale;
  f2py_inputiteration_def[i_f2py++].data = freezeturbsource;
  f2py_inputiteration_def[i_f2py++].data = printiterations;
  f2py_inputiteration_def[i_f2py++].data = printwarnings;
  f2py_inputiteration_def[i_f2py++].data = maxl2deviationfactor;
  f2py_inputiteration_def[i_f2py++].data = uselinresmonitor;
}
extern void F_FUNC(f2pyinitinputiteration,F2PYINITINPUTITERATION)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,char*));
static void f2py_init_inputiteration(void) {
  F_FUNC(f2pyinitinputiteration,F2PYINITINPUTITERATION)(f2py_setup_inputiteration);
}


static FortranDataDef f2py_inputmotion_def[] = {
  {"rotpoint",1,{{3}},NPY_DOUBLE},
  {"coscoeffouryrot",1,{{-1}},NPY_DOUBLE},
  {"coscoeffourxrot",1,{{-1}},NPY_DOUBLE},
  {"degreefourxrot",0,{{-1}},NPY_INT},
  {"sincoeffouralpha",1,{{-1}},NPY_DOUBLE},
  {"omegafourbeta",0,{{-1}},NPY_DOUBLE},
  {"coscoeffourbeta",1,{{-1}},NPY_DOUBLE},
  {"sincoeffourbeta",1,{{-1}},NPY_DOUBLE},
  {"degreepolbeta",0,{{-1}},NPY_INT},
  {"sincoeffourmach",1,{{-1}},NPY_DOUBLE},
  {"degreepolmach",0,{{-1}},NPY_INT},
  {"omegafourmach",0,{{-1}},NPY_DOUBLE},
  {"degreepolalpha",0,{{-1}},NPY_INT},
  {"coefpolmach",1,{{-1}},NPY_DOUBLE},
  {"coscoeffouralpha",1,{{-1}},NPY_DOUBLE},
  {"coscoeffourmach",1,{{-1}},NPY_DOUBLE},
  {"coefpolzrot",1,{{-1}},NPY_DOUBLE},
  {"gridmotionspecified",0,{{-1}},NPY_INT},
  {"omegafourzrot",0,{{-1}},NPY_DOUBLE},
  {"degreefouryrot",0,{{-1}},NPY_INT},
  {"coefpolyrot",1,{{-1}},NPY_DOUBLE},
  {"degreefourbeta",0,{{-1}},NPY_INT},
  {"omegafouralpha",0,{{-1}},NPY_DOUBLE},
  {"coscoeffourzrot",1,{{-1}},NPY_DOUBLE},
  {"degreepolzrot",0,{{-1}},NPY_INT},
  {"sincoeffourzrot",1,{{-1}},NPY_DOUBLE},
  {"omegafouryrot",0,{{-1}},NPY_DOUBLE},
  {"degreefourzrot",0,{{-1}},NPY_INT},
  {"degreefourmach",0,{{-1}},NPY_INT},
  {"degreefouralpha",0,{{-1}},NPY_INT},
  {"coefpolalpha",1,{{-1}},NPY_DOUBLE},
  {"omegafourxrot",0,{{-1}},NPY_DOUBLE},
  {"degreepolyrot",0,{{-1}},NPY_INT},
  {"sincoeffourxrot",1,{{-1}},NPY_DOUBLE},
  {"sincoeffouryrot",1,{{-1}},NPY_DOUBLE},
  {"degreepolxrot",0,{{-1}},NPY_INT},
  {"coefpolxrot",1,{{-1}},NPY_DOUBLE},
  {"coefpolbeta",1,{{-1}},NPY_DOUBLE},
  {NULL}
};

static void f2py_setup_inputmotion(char *rotpoint,void (*coscoeffouryrot)(int*,int*,void(*)(char*,int*),int*),void (*coscoeffourxrot)(int*,int*,void(*)(char*,int*),int*),char *degreefourxrot,void (*sincoeffouralpha)(int*,int*,void(*)(char*,int*),int*),char *omegafourbeta,void (*coscoeffourbeta)(int*,int*,void(*)(char*,int*),int*),void (*sincoeffourbeta)(int*,int*,void(*)(char*,int*),int*),char *degreepolbeta,void (*sincoeffourmach)(int*,int*,void(*)(char*,int*),int*),char *degreepolmach,char *omegafourmach,char *degreepolalpha,void (*coefpolmach)(int*,int*,void(*)(char*,int*),int*),void (*coscoeffouralpha)(int*,int*,void(*)(char*,int*),int*),void (*coscoeffourmach)(int*,int*,void(*)(char*,int*),int*),void (*coefpolzrot)(int*,int*,void(*)(char*,int*),int*),char *gridmotionspecified,char *omegafourzrot,char *degreefouryrot,void (*coefpolyrot)(int*,int*,void(*)(char*,int*),int*),char *degreefourbeta,char *omegafouralpha,void (*coscoeffourzrot)(int*,int*,void(*)(char*,int*),int*),char *degreepolzrot,void (*sincoeffourzrot)(int*,int*,void(*)(char*,int*),int*),char *omegafouryrot,char *degreefourzrot,char *degreefourmach,char *degreefouralpha,void (*coefpolalpha)(int*,int*,void(*)(char*,int*),int*),char *omegafourxrot,char *degreepolyrot,void (*sincoeffourxrot)(int*,int*,void(*)(char*,int*),int*),void (*sincoeffouryrot)(int*,int*,void(*)(char*,int*),int*),char *degreepolxrot,void (*coefpolxrot)(int*,int*,void(*)(char*,int*),int*),void (*coefpolbeta)(int*,int*,void(*)(char*,int*),int*)) {
  int i_f2py=0;
  f2py_inputmotion_def[i_f2py++].data = rotpoint;
  f2py_inputmotion_def[i_f2py++].func = coscoeffouryrot;
  f2py_inputmotion_def[i_f2py++].func = coscoeffourxrot;
  f2py_inputmotion_def[i_f2py++].data = degreefourxrot;
  f2py_inputmotion_def[i_f2py++].func = sincoeffouralpha;
  f2py_inputmotion_def[i_f2py++].data = omegafourbeta;
  f2py_inputmotion_def[i_f2py++].func = coscoeffourbeta;
  f2py_inputmotion_def[i_f2py++].func = sincoeffourbeta;
  f2py_inputmotion_def[i_f2py++].data = degreepolbeta;
  f2py_inputmotion_def[i_f2py++].func = sincoeffourmach;
  f2py_inputmotion_def[i_f2py++].data = degreepolmach;
  f2py_inputmotion_def[i_f2py++].data = omegafourmach;
  f2py_inputmotion_def[i_f2py++].data = degreepolalpha;
  f2py_inputmotion_def[i_f2py++].func = coefpolmach;
  f2py_inputmotion_def[i_f2py++].func = coscoeffouralpha;
  f2py_inputmotion_def[i_f2py++].func = coscoeffourmach;
  f2py_inputmotion_def[i_f2py++].func = coefpolzrot;
  f2py_inputmotion_def[i_f2py++].data = gridmotionspecified;
  f2py_inputmotion_def[i_f2py++].data = omegafourzrot;
  f2py_inputmotion_def[i_f2py++].data = degreefouryrot;
  f2py_inputmotion_def[i_f2py++].func = coefpolyrot;
  f2py_inputmotion_def[i_f2py++].data = degreefourbeta;
  f2py_inputmotion_def[i_f2py++].data = omegafouralpha;
  f2py_inputmotion_def[i_f2py++].func = coscoeffourzrot;
  f2py_inputmotion_def[i_f2py++].data = degreepolzrot;
  f2py_inputmotion_def[i_f2py++].func = sincoeffourzrot;
  f2py_inputmotion_def[i_f2py++].data = omegafouryrot;
  f2py_inputmotion_def[i_f2py++].data = degreefourzrot;
  f2py_inputmotion_def[i_f2py++].data = degreefourmach;
  f2py_inputmotion_def[i_f2py++].data = degreefouralpha;
  f2py_inputmotion_def[i_f2py++].func = coefpolalpha;
  f2py_inputmotion_def[i_f2py++].data = omegafourxrot;
  f2py_inputmotion_def[i_f2py++].data = degreepolyrot;
  f2py_inputmotion_def[i_f2py++].func = sincoeffourxrot;
  f2py_inputmotion_def[i_f2py++].func = sincoeffouryrot;
  f2py_inputmotion_def[i_f2py++].data = degreepolxrot;
  f2py_inputmotion_def[i_f2py++].func = coefpolxrot;
  f2py_inputmotion_def[i_f2py++].func = coefpolbeta;
}
extern void F_FUNC(f2pyinitinputmotion,F2PYINITINPUTMOTION)(void (*)(char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*)));
static void f2py_init_inputmotion(void) {
  F_FUNC(f2pyinitinputmotion,F2PYINITINPUTMOTION)(f2py_setup_inputmotion);
}


static FortranDataDef f2py_inputparallel_def[] = {
  {"loadimbalance",0,{{-1}},NPY_DOUBLE},
  {"splitblocks",0,{{-1}},NPY_INT},
  {"loadbalanceiter",0,{{-1}},NPY_INT},
  {"partitionlikenproc",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_inputparallel(char *loadimbalance,char *splitblocks,char *loadbalanceiter,char *partitionlikenproc) {
  int i_f2py=0;
  f2py_inputparallel_def[i_f2py++].data = loadimbalance;
  f2py_inputparallel_def[i_f2py++].data = splitblocks;
  f2py_inputparallel_def[i_f2py++].data = loadbalanceiter;
  f2py_inputparallel_def[i_f2py++].data = partitionlikenproc;
}
extern void F_FUNC(f2pyinitinputparallel,F2PYINITINPUTPARALLEL)(void (*)(char*,char*,char*,char*));
static void f2py_init_inputparallel(void) {
  F_FUNC(f2pyinitinputparallel,F2PYINITINPUTPARALLEL)(f2py_setup_inputparallel);
}


static FortranDataDef f2py_inputphysics_def[] = {
  {"equations",0,{{-1}},NPY_INT},
  {"equationmode",0,{{-1}},NPY_INT},
  {"flowtype",0,{{-1}},NPY_INT},
  {"turbmodel",0,{{-1}},NPY_INT},
  {"cpmodel",0,{{-1}},NPY_INT},
  {"turbprod",0,{{-1}},NPY_INT},
  {"rvfn",0,{{-1}},NPY_INT},
  {"rvfb",0,{{-1}},NPY_INT},
  {"useqcr",0,{{-1}},NPY_INT},
  {"userotationsa",0,{{-1}},NPY_INT},
  {"useft2sa",0,{{-1}},NPY_INT},
  {"wallfunctions",0,{{-1}},NPY_INT},
  {"mach",0,{{-1}},NPY_DOUBLE},
  {"machcoef",0,{{-1}},NPY_DOUBLE},
  {"machgrid",0,{{-1}},NPY_DOUBLE},
  {"reynolds",0,{{-1}},NPY_DOUBLE},
  {"reynoldslength",0,{{-1}},NPY_DOUBLE},
  {"gammaconstant",0,{{-1}},NPY_DOUBLE},
  {"rgasdim",0,{{-1}},NPY_DOUBLE},
  {"prandtl",0,{{-1}},NPY_DOUBLE},
  {"prandtlturb",0,{{-1}},NPY_DOUBLE},
  {"pklim",0,{{-1}},NPY_DOUBLE},
  {"walloffset",0,{{-1}},NPY_DOUBLE},
  {"eddyvisinfratio",0,{{-1}},NPY_DOUBLE},
  {"turbintensityinf",0,{{-1}},NPY_DOUBLE},
  {"surfaceref",0,{{-1}},NPY_DOUBLE},
  {"lengthref",0,{{-1}},NPY_DOUBLE},
  {"veldirfreestream",1,{{3}},NPY_DOUBLE},
  {"liftdirection",1,{{3}},NPY_DOUBLE},
  {"dragdirection",1,{{3}},NPY_DOUBLE},
  {"pointref",1,{{3}},NPY_DOUBLE},
  {"pointrefec",1,{{3}},NPY_DOUBLE},
  {"momentaxis",2,{{3,2}},NPY_DOUBLE},
  {"forcesastractions",0,{{-1}},NPY_INT},
  {"ssuthdim",0,{{-1}},NPY_DOUBLE},
  {"musuthdim",0,{{-1}},NPY_DOUBLE},
  {"tsuthdim",0,{{-1}},NPY_DOUBLE},
  {"walldistcutoff",0,{{-1}},NPY_DOUBLE},
  {"alpha",0,{{-1}},NPY_DOUBLE},
  {"beta",0,{{-1}},NPY_DOUBLE},
  {"liftindex",0,{{-1}},NPY_INT},
  {"cavitationnumber",0,{{-1}},NPY_DOUBLE},
  {NULL}
};

static void f2py_setup_inputphysics(char *equations,char *equationmode,char *flowtype,char *turbmodel,char *cpmodel,char *turbprod,char *rvfn,char *rvfb,char *useqcr,char *userotationsa,char *useft2sa,char *wallfunctions,char *mach,char *machcoef,char *machgrid,char *reynolds,char *reynoldslength,char *gammaconstant,char *rgasdim,char *prandtl,char *prandtlturb,char *pklim,char *walloffset,char *eddyvisinfratio,char *turbintensityinf,char *surfaceref,char *lengthref,char *veldirfreestream,char *liftdirection,char *dragdirection,char *pointref,char *pointrefec,char *momentaxis,char *forcesastractions,char *ssuthdim,char *musuthdim,char *tsuthdim,char *walldistcutoff,char *alpha,char *beta,char *liftindex,char *cavitationnumber) {
  int i_f2py=0;
  f2py_inputphysics_def[i_f2py++].data = equations;
  f2py_inputphysics_def[i_f2py++].data = equationmode;
  f2py_inputphysics_def[i_f2py++].data = flowtype;
  f2py_inputphysics_def[i_f2py++].data = turbmodel;
  f2py_inputphysics_def[i_f2py++].data = cpmodel;
  f2py_inputphysics_def[i_f2py++].data = turbprod;
  f2py_inputphysics_def[i_f2py++].data = rvfn;
  f2py_inputphysics_def[i_f2py++].data = rvfb;
  f2py_inputphysics_def[i_f2py++].data = useqcr;
  f2py_inputphysics_def[i_f2py++].data = userotationsa;
  f2py_inputphysics_def[i_f2py++].data = useft2sa;
  f2py_inputphysics_def[i_f2py++].data = wallfunctions;
  f2py_inputphysics_def[i_f2py++].data = mach;
  f2py_inputphysics_def[i_f2py++].data = machcoef;
  f2py_inputphysics_def[i_f2py++].data = machgrid;
  f2py_inputphysics_def[i_f2py++].data = reynolds;
  f2py_inputphysics_def[i_f2py++].data = reynoldslength;
  f2py_inputphysics_def[i_f2py++].data = gammaconstant;
  f2py_inputphysics_def[i_f2py++].data = rgasdim;
  f2py_inputphysics_def[i_f2py++].data = prandtl;
  f2py_inputphysics_def[i_f2py++].data = prandtlturb;
  f2py_inputphysics_def[i_f2py++].data = pklim;
  f2py_inputphysics_def[i_f2py++].data = walloffset;
  f2py_inputphysics_def[i_f2py++].data = eddyvisinfratio;
  f2py_inputphysics_def[i_f2py++].data = turbintensityinf;
  f2py_inputphysics_def[i_f2py++].data = surfaceref;
  f2py_inputphysics_def[i_f2py++].data = lengthref;
  f2py_inputphysics_def[i_f2py++].data = veldirfreestream;
  f2py_inputphysics_def[i_f2py++].data = liftdirection;
  f2py_inputphysics_def[i_f2py++].data = dragdirection;
  f2py_inputphysics_def[i_f2py++].data = pointref;
  f2py_inputphysics_def[i_f2py++].data = pointrefec;
  f2py_inputphysics_def[i_f2py++].data = momentaxis;
  f2py_inputphysics_def[i_f2py++].data = forcesastractions;
  f2py_inputphysics_def[i_f2py++].data = ssuthdim;
  f2py_inputphysics_def[i_f2py++].data = musuthdim;
  f2py_inputphysics_def[i_f2py++].data = tsuthdim;
  f2py_inputphysics_def[i_f2py++].data = walldistcutoff;
  f2py_inputphysics_def[i_f2py++].data = alpha;
  f2py_inputphysics_def[i_f2py++].data = beta;
  f2py_inputphysics_def[i_f2py++].data = liftindex;
  f2py_inputphysics_def[i_f2py++].data = cavitationnumber;
}
extern void F_FUNC(f2pyinitinputphysics,F2PYINITINPUTPHYSICS)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_inputphysics(void) {
  F_FUNC(f2pyinitinputphysics,F2PYINITINPUTPHYSICS)(f2py_setup_inputphysics);
}


static FortranDataDef f2py_inputadjoint_def[] = {
  {"adjointpcside",1,{{256}},NPY_STRING},
  {"matrixordering",1,{{256}},NPY_STRING},
  {"adjointsolvertype",1,{{256}},NPY_STRING},
  {"localpctype",1,{{256}},NPY_STRING},
  {"precondtype",1,{{256}},NPY_STRING},
  {"adjabstol",0,{{-1}},NPY_DOUBLE},
  {"adjdivtol",0,{{-1}},NPY_DOUBLE},
  {"adjreltol",0,{{-1}},NPY_DOUBLE},
  {"adjreltolrel",0,{{-1}},NPY_DOUBLE},
  {"overlap",0,{{-1}},NPY_INT},
  {"adjmonstep",0,{{-1}},NPY_INT},
  {"filllevel",0,{{-1}},NPY_INT},
  {"adjmaxiter",0,{{-1}},NPY_INT},
  {"adjrestart",0,{{-1}},NPY_INT},
  {"innerpreconits",0,{{-1}},NPY_INT},
  {"outerpreconits",0,{{-1}},NPY_INT},
  {"approxpc",0,{{-1}},NPY_INT},
  {"adpc",0,{{-1}},NPY_INT},
  {"viscpc",0,{{-1}},NPY_INT},
  {"frozenturbulence",0,{{-1}},NPY_INT},
  {"usediagtspc",0,{{-1}},NPY_INT},
  {"restartadjoint",0,{{-1}},NPY_INT},
  {"setmonitor",0,{{-1}},NPY_INT},
  {"printtiming",0,{{-1}},NPY_INT},
  {"firstrun",0,{{-1}},NPY_INT},
  {"verifystate",0,{{-1}},NPY_INT},
  {"verifyspatial",0,{{-1}},NPY_INT},
  {"verifyextra",0,{{-1}},NPY_INT},
  {"usematrixfreedrdw",0,{{-1}},NPY_INT},
  {"applyadjointpcsubspacesize",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_inputadjoint(char *adjointpcside,char *matrixordering,char *adjointsolvertype,char *localpctype,char *precondtype,char *adjabstol,char *adjdivtol,char *adjreltol,char *adjreltolrel,char *overlap,char *adjmonstep,char *filllevel,char *adjmaxiter,char *adjrestart,char *innerpreconits,char *outerpreconits,char *approxpc,char *adpc,char *viscpc,char *frozenturbulence,char *usediagtspc,char *restartadjoint,char *setmonitor,char *printtiming,char *firstrun,char *verifystate,char *verifyspatial,char *verifyextra,char *usematrixfreedrdw,char *applyadjointpcsubspacesize) {
  int i_f2py=0;
  f2py_inputadjoint_def[i_f2py++].data = adjointpcside;
  f2py_inputadjoint_def[i_f2py++].data = matrixordering;
  f2py_inputadjoint_def[i_f2py++].data = adjointsolvertype;
  f2py_inputadjoint_def[i_f2py++].data = localpctype;
  f2py_inputadjoint_def[i_f2py++].data = precondtype;
  f2py_inputadjoint_def[i_f2py++].data = adjabstol;
  f2py_inputadjoint_def[i_f2py++].data = adjdivtol;
  f2py_inputadjoint_def[i_f2py++].data = adjreltol;
  f2py_inputadjoint_def[i_f2py++].data = adjreltolrel;
  f2py_inputadjoint_def[i_f2py++].data = overlap;
  f2py_inputadjoint_def[i_f2py++].data = adjmonstep;
  f2py_inputadjoint_def[i_f2py++].data = filllevel;
  f2py_inputadjoint_def[i_f2py++].data = adjmaxiter;
  f2py_inputadjoint_def[i_f2py++].data = adjrestart;
  f2py_inputadjoint_def[i_f2py++].data = innerpreconits;
  f2py_inputadjoint_def[i_f2py++].data = outerpreconits;
  f2py_inputadjoint_def[i_f2py++].data = approxpc;
  f2py_inputadjoint_def[i_f2py++].data = adpc;
  f2py_inputadjoint_def[i_f2py++].data = viscpc;
  f2py_inputadjoint_def[i_f2py++].data = frozenturbulence;
  f2py_inputadjoint_def[i_f2py++].data = usediagtspc;
  f2py_inputadjoint_def[i_f2py++].data = restartadjoint;
  f2py_inputadjoint_def[i_f2py++].data = setmonitor;
  f2py_inputadjoint_def[i_f2py++].data = printtiming;
  f2py_inputadjoint_def[i_f2py++].data = firstrun;
  f2py_inputadjoint_def[i_f2py++].data = verifystate;
  f2py_inputadjoint_def[i_f2py++].data = verifyspatial;
  f2py_inputadjoint_def[i_f2py++].data = verifyextra;
  f2py_inputadjoint_def[i_f2py++].data = usematrixfreedrdw;
  f2py_inputadjoint_def[i_f2py++].data = applyadjointpcsubspacesize;
}
extern void F_FUNC(f2pyinitinputadjoint,F2PYINITINPUTADJOINT)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_inputadjoint(void) {
  F_FUNC(f2pyinitinputadjoint,F2PYINITINPUTADJOINT)(f2py_setup_inputadjoint);
}


static FortranDataDef f2py_inputtimespectral_def[] = {
  {"ntimeintervalsspectral",0,{{-1}},NPY_INT},
  {"dscalar",3,{{-1,-1,-1}},NPY_DOUBLE},
  {"dvector",3,{{-1,-1,-1}},NPY_DOUBLE},
  {"dtunsteadyrestartspectral",0,{{-1}},NPY_DOUBLE},
  {"writeunsteadyrestartspectral",0,{{-1}},NPY_INT},
  {"nunsteadysolspectral",0,{{-1}},NPY_INT},
  {"writeunsteadyvolspectral",0,{{-1}},NPY_INT},
  {"writeunsteadysurfspectral",0,{{-1}},NPY_INT},
  {"rotmatrixspectral",3,{{-1,-1,-1}},NPY_DOUBLE},
  {NULL}
};

static void f2py_setup_inputtimespectral(char *ntimeintervalsspectral,void (*dscalar)(int*,int*,void(*)(char*,int*),int*),void (*dvector)(int*,int*,void(*)(char*,int*),int*),char *dtunsteadyrestartspectral,char *writeunsteadyrestartspectral,char *nunsteadysolspectral,char *writeunsteadyvolspectral,char *writeunsteadysurfspectral,void (*rotmatrixspectral)(int*,int*,void(*)(char*,int*),int*)) {
  int i_f2py=0;
  f2py_inputtimespectral_def[i_f2py++].data = ntimeintervalsspectral;
  f2py_inputtimespectral_def[i_f2py++].func = dscalar;
  f2py_inputtimespectral_def[i_f2py++].func = dvector;
  f2py_inputtimespectral_def[i_f2py++].data = dtunsteadyrestartspectral;
  f2py_inputtimespectral_def[i_f2py++].data = writeunsteadyrestartspectral;
  f2py_inputtimespectral_def[i_f2py++].data = nunsteadysolspectral;
  f2py_inputtimespectral_def[i_f2py++].data = writeunsteadyvolspectral;
  f2py_inputtimespectral_def[i_f2py++].data = writeunsteadysurfspectral;
  f2py_inputtimespectral_def[i_f2py++].func = rotmatrixspectral;
}
extern void F_FUNC(f2pyinitinputtimespectral,F2PYINITINPUTTIMESPECTRAL)(void (*)(char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*)));
static void f2py_init_inputtimespectral(void) {
  F_FUNC(f2pyinitinputtimespectral,F2PYINITINPUTTIMESPECTRAL)(f2py_setup_inputtimespectral);
}


static FortranDataDef f2py_inputoverset_def[] = {
  {"useoversetloadbalance",0,{{-1}},NPY_INT},
  {"nearwalldist",0,{{-1}},NPY_DOUBLE},
  {"backgroundvolscale",0,{{-1}},NPY_DOUBLE},
  {"oversetprojtol",0,{{-1}},NPY_DOUBLE},
  {"overlapfactor",0,{{-1}},NPY_DOUBLE},
  {"oversetupdatemode",0,{{-1}},NPY_INT},
  {"nrefine",0,{{-1}},NPY_INT},
  {"nflooditer",0,{{-1}},NPY_INT},
  {"debugzipper",0,{{-1}},NPY_INT},
  {"usezippermesh",0,{{-1}},NPY_INT},
  {"useoversetwallscaling",0,{{-1}},NPY_INT},
  {"selfzipcutoff",0,{{-1}},NPY_DOUBLE},
  {NULL}
};

static void f2py_setup_inputoverset(char *useoversetloadbalance,char *nearwalldist,char *backgroundvolscale,char *oversetprojtol,char *overlapfactor,char *oversetupdatemode,char *nrefine,char *nflooditer,char *debugzipper,char *usezippermesh,char *useoversetwallscaling,char *selfzipcutoff) {
  int i_f2py=0;
  f2py_inputoverset_def[i_f2py++].data = useoversetloadbalance;
  f2py_inputoverset_def[i_f2py++].data = nearwalldist;
  f2py_inputoverset_def[i_f2py++].data = backgroundvolscale;
  f2py_inputoverset_def[i_f2py++].data = oversetprojtol;
  f2py_inputoverset_def[i_f2py++].data = overlapfactor;
  f2py_inputoverset_def[i_f2py++].data = oversetupdatemode;
  f2py_inputoverset_def[i_f2py++].data = nrefine;
  f2py_inputoverset_def[i_f2py++].data = nflooditer;
  f2py_inputoverset_def[i_f2py++].data = debugzipper;
  f2py_inputoverset_def[i_f2py++].data = usezippermesh;
  f2py_inputoverset_def[i_f2py++].data = useoversetwallscaling;
  f2py_inputoverset_def[i_f2py++].data = selfzipcutoff;
}
extern void F_FUNC(f2pyinitinputoverset,F2PYINITINPUTOVERSET)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_inputoverset(void) {
  F_FUNC(f2pyinitinputoverset,F2PYINITINPUTOVERSET)(f2py_setup_inputoverset);
}


static FortranDataDef f2py_inputunsteady_def[] = {
  {"deltat",0,{{-1}},NPY_DOUBLE},
  {"useale",0,{{-1}},NPY_INT},
  {"timeintegrationscheme",0,{{-1}},NPY_INT},
  {"updatewalldistanceunsteady",0,{{-1}},NPY_INT},
  {"timeaccuracy",0,{{-1}},NPY_INT},
  {"ntimestepsfine",0,{{-1}},NPY_INT},
  {"ntimestepscoarse",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_inputunsteady(char *deltat,char *useale,char *timeintegrationscheme,char *updatewalldistanceunsteady,char *timeaccuracy,char *ntimestepsfine,char *ntimestepscoarse) {
  int i_f2py=0;
  f2py_inputunsteady_def[i_f2py++].data = deltat;
  f2py_inputunsteady_def[i_f2py++].data = useale;
  f2py_inputunsteady_def[i_f2py++].data = timeintegrationscheme;
  f2py_inputunsteady_def[i_f2py++].data = updatewalldistanceunsteady;
  f2py_inputunsteady_def[i_f2py++].data = timeaccuracy;
  f2py_inputunsteady_def[i_f2py++].data = ntimestepsfine;
  f2py_inputunsteady_def[i_f2py++].data = ntimestepscoarse;
}
extern void F_FUNC(f2pyinitinputunsteady,F2PYINITINPUTUNSTEADY)(void (*)(char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_inputunsteady(void) {
  F_FUNC(f2pyinitinputunsteady,F2PYINITINPUTUNSTEADY)(f2py_setup_inputunsteady);
}


static FortranDataDef f2py_iteration_def[] = {
  {"groundlevel",0,{{-1}},NPY_INT},
  {"currentlevel",0,{{-1}},NPY_INT},
  {"rkstage",0,{{-1}},NPY_INT},
  {"nstepscycling",0,{{-1}},NPY_INT},
  {"cycling",1,{{-1}},NPY_INT},
  {"itertot",0,{{-1}},NPY_INT},
  {"rfil",0,{{-1}},NPY_DOUBLE},
  {"t0solver",0,{{-1}},NPY_DOUBLE},
  {"converged",0,{{-1}},NPY_INT},
  {"exchangepressureearly",0,{{-1}},NPY_INT},
  {"standalonemode",0,{{-1}},NPY_INT},
  {"changing_grid",0,{{-1}},NPY_INT},
  {"deforming_grid",0,{{-1}},NPY_INT},
  {"changingoverset",0,{{-1}},NPY_INT},
  {"noldsolavail",0,{{-1}},NPY_INT},
  {"noldlevels",0,{{-1}},NPY_INT},
  {"coeftime",1,{{-1}},NPY_DOUBLE},
  {"timespectralgridsnotwritten",0,{{-1}},NPY_INT},
  {"oldsolwritten",1,{{-1}},NPY_INT},
  {"totalr0",0,{{-1}},NPY_DOUBLE},
  {"totalrstart",0,{{-1}},NPY_DOUBLE},
  {"totalrfinal",0,{{-1}},NPY_DOUBLE},
  {NULL}
};

static void f2py_setup_iteration(char *groundlevel,char *currentlevel,char *rkstage,char *nstepscycling,void (*cycling)(int*,int*,void(*)(char*,int*),int*),char *itertot,char *rfil,char *t0solver,char *converged,char *exchangepressureearly,char *standalonemode,char *changing_grid,char *deforming_grid,char *changingoverset,char *noldsolavail,char *noldlevels,void (*coeftime)(int*,int*,void(*)(char*,int*),int*),char *timespectralgridsnotwritten,void (*oldsolwritten)(int*,int*,void(*)(char*,int*),int*),char *totalr0,char *totalrstart,char *totalrfinal) {
  int i_f2py=0;
  f2py_iteration_def[i_f2py++].data = groundlevel;
  f2py_iteration_def[i_f2py++].data = currentlevel;
  f2py_iteration_def[i_f2py++].data = rkstage;
  f2py_iteration_def[i_f2py++].data = nstepscycling;
  f2py_iteration_def[i_f2py++].func = cycling;
  f2py_iteration_def[i_f2py++].data = itertot;
  f2py_iteration_def[i_f2py++].data = rfil;
  f2py_iteration_def[i_f2py++].data = t0solver;
  f2py_iteration_def[i_f2py++].data = converged;
  f2py_iteration_def[i_f2py++].data = exchangepressureearly;
  f2py_iteration_def[i_f2py++].data = standalonemode;
  f2py_iteration_def[i_f2py++].data = changing_grid;
  f2py_iteration_def[i_f2py++].data = deforming_grid;
  f2py_iteration_def[i_f2py++].data = changingoverset;
  f2py_iteration_def[i_f2py++].data = noldsolavail;
  f2py_iteration_def[i_f2py++].data = noldlevels;
  f2py_iteration_def[i_f2py++].func = coeftime;
  f2py_iteration_def[i_f2py++].data = timespectralgridsnotwritten;
  f2py_iteration_def[i_f2py++].func = oldsolwritten;
  f2py_iteration_def[i_f2py++].data = totalr0;
  f2py_iteration_def[i_f2py++].data = totalrstart;
  f2py_iteration_def[i_f2py++].data = totalrfinal;
}
extern void F_FUNC(f2pyinititeration,F2PYINITITERATION)(void (*)(char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*));
static void f2py_init_iteration(void) {
  F_FUNC(f2pyinititeration,F2PYINITITERATION)(f2py_setup_iteration);
}


static FortranDataDef f2py_monitor_def[] = {
  {"nmonsum",0,{{-1}},NPY_INT},
  {"nmonmax",0,{{-1}},NPY_INT},
  {"nmon",0,{{-1}},NPY_INT},
  {"monloc",1,{{-1}},NPY_DOUBLE},
  {"monglob",1,{{-1}},NPY_DOUBLE},
  {"monref",1,{{-1}},NPY_DOUBLE},
  {"monnames",1,{{-1,32}},NPY_STRING},
  {"monmachorhmax",0,{{-1}},NPY_INT},
  {"showcpu",0,{{-1}},NPY_INT},
  {"monmasssliding",0,{{-1}},NPY_INT},
  {"monmassfamilies",0,{{-1}},NPY_INT},
  {"nitercur",0,{{-1}},NPY_INT},
  {"convarray",3,{{-1,-1,-1}},NPY_DOUBLE},
  {"ntimestepsrestart",0,{{-1}},NPY_INT},
  {"timestepunsteady",0,{{-1}},NPY_INT},
  {"timeunsteady",0,{{-1}},NPY_DOUBLE},
  {"timeunsteadyrestart",0,{{-1}},NPY_DOUBLE},
  {"timearray",1,{{-1}},NPY_DOUBLE},
  {"timedataarray",2,{{-1,-1}},NPY_DOUBLE},
  {"writegrid",0,{{-1}},NPY_INT},
  {"writevolume",0,{{-1}},NPY_INT},
  {"writesurface",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_monitor(char *nmonsum,char *nmonmax,char *nmon,void (*monloc)(int*,int*,void(*)(char*,int*),int*),void (*monglob)(int*,int*,void(*)(char*,int*),int*),void (*monref)(int*,int*,void(*)(char*,int*),int*),void (*monnames)(int*,int*,void(*)(char*,int*),int*),char *monmachorhmax,char *showcpu,char *monmasssliding,char *monmassfamilies,char *nitercur,void (*convarray)(int*,int*,void(*)(char*,int*),int*),char *ntimestepsrestart,char *timestepunsteady,char *timeunsteady,char *timeunsteadyrestart,void (*timearray)(int*,int*,void(*)(char*,int*),int*),void (*timedataarray)(int*,int*,void(*)(char*,int*),int*),char *writegrid,char *writevolume,char *writesurface) {
  int i_f2py=0;
  f2py_monitor_def[i_f2py++].data = nmonsum;
  f2py_monitor_def[i_f2py++].data = nmonmax;
  f2py_monitor_def[i_f2py++].data = nmon;
  f2py_monitor_def[i_f2py++].func = monloc;
  f2py_monitor_def[i_f2py++].func = monglob;
  f2py_monitor_def[i_f2py++].func = monref;
  f2py_monitor_def[i_f2py++].func = monnames;
  f2py_monitor_def[i_f2py++].data = monmachorhmax;
  f2py_monitor_def[i_f2py++].data = showcpu;
  f2py_monitor_def[i_f2py++].data = monmasssliding;
  f2py_monitor_def[i_f2py++].data = monmassfamilies;
  f2py_monitor_def[i_f2py++].data = nitercur;
  f2py_monitor_def[i_f2py++].func = convarray;
  f2py_monitor_def[i_f2py++].data = ntimestepsrestart;
  f2py_monitor_def[i_f2py++].data = timestepunsteady;
  f2py_monitor_def[i_f2py++].data = timeunsteady;
  f2py_monitor_def[i_f2py++].data = timeunsteadyrestart;
  f2py_monitor_def[i_f2py++].func = timearray;
  f2py_monitor_def[i_f2py++].func = timedataarray;
  f2py_monitor_def[i_f2py++].data = writegrid;
  f2py_monitor_def[i_f2py++].data = writevolume;
  f2py_monitor_def[i_f2py++].data = writesurface;
}
extern void F_FUNC(f2pyinitmonitor,F2PYINITMONITOR)(void (*)(char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*));
static void f2py_init_monitor(void) {
  F_FUNC(f2pyinitmonitor,F2PYINITMONITOR)(f2py_setup_monitor);
}


static FortranDataDef f2py_block_def[] = {
  {"ndom",0,{{-1}},NPY_INT},
  {"ncellglobal",1,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_block(char *ndom,void (*ncellglobal)(int*,int*,void(*)(char*,int*),int*)) {
  int i_f2py=0;
  f2py_block_def[i_f2py++].data = ndom;
  f2py_block_def[i_f2py++].func = ncellglobal;
}
extern void F_FUNC(f2pyinitblock,F2PYINITBLOCK)(void (*)(char*,void (*)(int*,int*,void(*)(char*,int*),int*)));
static void f2py_init_block(void) {
  F_FUNC(f2pyinitblock,F2PYINITBLOCK)(f2py_setup_block);
}


static FortranDataDef f2py_flowvarrefstate_def[] = {
  {"nw",0,{{-1}},NPY_INT},
  {"nwf",0,{{-1}},NPY_INT},
  {"nwt",0,{{-1}},NPY_INT},
  {"nt1",0,{{-1}},NPY_INT},
  {"nt2",0,{{-1}},NPY_INT},
  {"pref",0,{{-1}},NPY_DOUBLE},
  {"rhoref",0,{{-1}},NPY_DOUBLE},
  {"tref",0,{{-1}},NPY_DOUBLE},
  {"muref",0,{{-1}},NPY_DOUBLE},
  {"timeref",0,{{-1}},NPY_DOUBLE},
  {"lref",0,{{-1}},NPY_DOUBLE},
  {"lrefspecified",0,{{-1}},NPY_INT},
  {"pinfdim",0,{{-1}},NPY_DOUBLE},
  {"rhoinfdim",0,{{-1}},NPY_DOUBLE},
  {"tinfdim",0,{{-1}},NPY_DOUBLE},
  {"mudim",0,{{-1}},NPY_DOUBLE},
  {"rhoinf",0,{{-1}},NPY_DOUBLE},
  {"uinf",0,{{-1}},NPY_DOUBLE},
  {"pinf",0,{{-1}},NPY_DOUBLE},
  {"pinfcorr",0,{{-1}},NPY_DOUBLE},
  {"rgas",0,{{-1}},NPY_DOUBLE},
  {"muinf",0,{{-1}},NPY_DOUBLE},
  {"gammainf",0,{{-1}},NPY_DOUBLE},
  {"winf",1,{{-1}},NPY_DOUBLE},
  {"kpresent",0,{{-1}},NPY_INT},
  {"eddymodel",0,{{-1}},NPY_INT},
  {"viscous",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_flowvarrefstate(char *nw,char *nwf,char *nwt,char *nt1,char *nt2,char *pref,char *rhoref,char *tref,char *muref,char *timeref,char *lref,char *lrefspecified,char *pinfdim,char *rhoinfdim,char *tinfdim,char *mudim,char *rhoinf,char *uinf,char *pinf,char *pinfcorr,char *rgas,char *muinf,char *gammainf,void (*winf)(int*,int*,void(*)(char*,int*),int*),char *kpresent,char *eddymodel,char *viscous) {
  int i_f2py=0;
  f2py_flowvarrefstate_def[i_f2py++].data = nw;
  f2py_flowvarrefstate_def[i_f2py++].data = nwf;
  f2py_flowvarrefstate_def[i_f2py++].data = nwt;
  f2py_flowvarrefstate_def[i_f2py++].data = nt1;
  f2py_flowvarrefstate_def[i_f2py++].data = nt2;
  f2py_flowvarrefstate_def[i_f2py++].data = pref;
  f2py_flowvarrefstate_def[i_f2py++].data = rhoref;
  f2py_flowvarrefstate_def[i_f2py++].data = tref;
  f2py_flowvarrefstate_def[i_f2py++].data = muref;
  f2py_flowvarrefstate_def[i_f2py++].data = timeref;
  f2py_flowvarrefstate_def[i_f2py++].data = lref;
  f2py_flowvarrefstate_def[i_f2py++].data = lrefspecified;
  f2py_flowvarrefstate_def[i_f2py++].data = pinfdim;
  f2py_flowvarrefstate_def[i_f2py++].data = rhoinfdim;
  f2py_flowvarrefstate_def[i_f2py++].data = tinfdim;
  f2py_flowvarrefstate_def[i_f2py++].data = mudim;
  f2py_flowvarrefstate_def[i_f2py++].data = rhoinf;
  f2py_flowvarrefstate_def[i_f2py++].data = uinf;
  f2py_flowvarrefstate_def[i_f2py++].data = pinf;
  f2py_flowvarrefstate_def[i_f2py++].data = pinfcorr;
  f2py_flowvarrefstate_def[i_f2py++].data = rgas;
  f2py_flowvarrefstate_def[i_f2py++].data = muinf;
  f2py_flowvarrefstate_def[i_f2py++].data = gammainf;
  f2py_flowvarrefstate_def[i_f2py++].func = winf;
  f2py_flowvarrefstate_def[i_f2py++].data = kpresent;
  f2py_flowvarrefstate_def[i_f2py++].data = eddymodel;
  f2py_flowvarrefstate_def[i_f2py++].data = viscous;
}
extern void F_FUNC(f2pyinitflowvarrefstate,F2PYINITFLOWVARREFSTATE)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*));
static void f2py_init_flowvarrefstate(void) {
  F_FUNC(f2pyinitflowvarrefstate,F2PYINITFLOWVARREFSTATE)(f2py_setup_flowvarrefstate);
}


static FortranDataDef f2py_killsignals_def[] = {
  {"frompython",0,{{-1}},NPY_INT},
  {"routinefailed",0,{{-1}},NPY_INT},
  {"fatalfail",0,{{-1}},NPY_INT},
  {"adjointfailed",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_killsignals(char *frompython,char *routinefailed,char *fatalfail,char *adjointfailed) {
  int i_f2py=0;
  f2py_killsignals_def[i_f2py++].data = frompython;
  f2py_killsignals_def[i_f2py++].data = routinefailed;
  f2py_killsignals_def[i_f2py++].data = fatalfail;
  f2py_killsignals_def[i_f2py++].data = adjointfailed;
}
extern void F_FUNC(f2pyinitkillsignals,F2PYINITKILLSIGNALS)(void (*)(char*,char*,char*,char*));
static void f2py_init_killsignals(void) {
  F_FUNC(f2pyinitkillsignals,F2PYINITKILLSIGNALS)(f2py_setup_killsignals);
}


static FortranDataDef f2py_inputcostfunctions_def[] = {
  {"sepsensoroffset",0,{{-1}},NPY_DOUBLE},
  {"sepsensorsharpness",0,{{-1}},NPY_DOUBLE},
  {"computecavitation",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_inputcostfunctions(char *sepsensoroffset,char *sepsensorsharpness,char *computecavitation) {
  int i_f2py=0;
  f2py_inputcostfunctions_def[i_f2py++].data = sepsensoroffset;
  f2py_inputcostfunctions_def[i_f2py++].data = sepsensorsharpness;
  f2py_inputcostfunctions_def[i_f2py++].data = computecavitation;
}
extern void F_FUNC(f2pyinitinputcostfunctions,F2PYINITINPUTCOSTFUNCTIONS)(void (*)(char*,char*,char*));
static void f2py_init_inputcostfunctions(void) {
  F_FUNC(f2pyinitinputcostfunctions,F2PYINITINPUTCOSTFUNCTIONS)(f2py_setup_inputcostfunctions);
}


static FortranDataDef f2py_adjointvars_def[] = {
  {"ncellslocal",1,{{20}},NPY_INT},
  {"nnodeslocal",1,{{20}},NPY_INT},
  {"ialpha",0,{{-1}},NPY_INT},
  {"ibeta",0,{{-1}},NPY_INT},
  {"imach",0,{{-1}},NPY_INT},
  {"imachgrid",0,{{-1}},NPY_INT},
  {"irotx",0,{{-1}},NPY_INT},
  {"iroty",0,{{-1}},NPY_INT},
  {"irotz",0,{{-1}},NPY_INT},
  {"irotcenx",0,{{-1}},NPY_INT},
  {"irotceny",0,{{-1}},NPY_INT},
  {"irotcenz",0,{{-1}},NPY_INT},
  {"ipointrefx",0,{{-1}},NPY_INT},
  {"ipointrefy",0,{{-1}},NPY_INT},
  {"ipointrefz",0,{{-1}},NPY_INT},
  {"ipressure",0,{{-1}},NPY_INT},
  {"itemperature",0,{{-1}},NPY_INT},
  {"idensity",0,{{-1}},NPY_INT},
  {"iaxisx1",0,{{-1}},NPY_INT},
  {"iaxisx2",0,{{-1}},NPY_INT},
  {"iaxisy1",0,{{-1}},NPY_INT},
  {"iaxisy2",0,{{-1}},NPY_INT},
  {"iaxisz1",0,{{-1}},NPY_INT},
  {"iaxisz2",0,{{-1}},NPY_INT},
  {"ndesignextra",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_adjointvars(char *ncellslocal,char *nnodeslocal,char *ialpha,char *ibeta,char *imach,char *imachgrid,char *irotx,char *iroty,char *irotz,char *irotcenx,char *irotceny,char *irotcenz,char *ipointrefx,char *ipointrefy,char *ipointrefz,char *ipressure,char *itemperature,char *idensity,char *iaxisx1,char *iaxisx2,char *iaxisy1,char *iaxisy2,char *iaxisz1,char *iaxisz2,char *ndesignextra) {
  int i_f2py=0;
  f2py_adjointvars_def[i_f2py++].data = ncellslocal;
  f2py_adjointvars_def[i_f2py++].data = nnodeslocal;
  f2py_adjointvars_def[i_f2py++].data = ialpha;
  f2py_adjointvars_def[i_f2py++].data = ibeta;
  f2py_adjointvars_def[i_f2py++].data = imach;
  f2py_adjointvars_def[i_f2py++].data = imachgrid;
  f2py_adjointvars_def[i_f2py++].data = irotx;
  f2py_adjointvars_def[i_f2py++].data = iroty;
  f2py_adjointvars_def[i_f2py++].data = irotz;
  f2py_adjointvars_def[i_f2py++].data = irotcenx;
  f2py_adjointvars_def[i_f2py++].data = irotceny;
  f2py_adjointvars_def[i_f2py++].data = irotcenz;
  f2py_adjointvars_def[i_f2py++].data = ipointrefx;
  f2py_adjointvars_def[i_f2py++].data = ipointrefy;
  f2py_adjointvars_def[i_f2py++].data = ipointrefz;
  f2py_adjointvars_def[i_f2py++].data = ipressure;
  f2py_adjointvars_def[i_f2py++].data = itemperature;
  f2py_adjointvars_def[i_f2py++].data = idensity;
  f2py_adjointvars_def[i_f2py++].data = iaxisx1;
  f2py_adjointvars_def[i_f2py++].data = iaxisx2;
  f2py_adjointvars_def[i_f2py++].data = iaxisy1;
  f2py_adjointvars_def[i_f2py++].data = iaxisy2;
  f2py_adjointvars_def[i_f2py++].data = iaxisz1;
  f2py_adjointvars_def[i_f2py++].data = iaxisz2;
  f2py_adjointvars_def[i_f2py++].data = ndesignextra;
}
extern void F_FUNC(f2pyinitadjointvars,F2PYINITADJOINTVARS)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_adjointvars(void) {
  F_FUNC(f2pyinitadjointvars,F2PYINITADJOINTVARS)(f2py_setup_adjointvars);
}


static FortranDataDef f2py_adjointpetsc_def[] = {
  {"adjresinit",0,{{-1}},NPY_DOUBLE},
  {"adjresstart",0,{{-1}},NPY_DOUBLE},
  {"adjresfinal",0,{{-1}},NPY_DOUBLE},
  {NULL}
};

static void f2py_setup_adjointpetsc(char *adjresinit,char *adjresstart,char *adjresfinal) {
  int i_f2py=0;
  f2py_adjointpetsc_def[i_f2py++].data = adjresinit;
  f2py_adjointpetsc_def[i_f2py++].data = adjresstart;
  f2py_adjointpetsc_def[i_f2py++].data = adjresfinal;
}
extern void F_FUNC(f2pyinitadjointpetsc,F2PYINITADJOINTPETSC)(void (*)(char*,char*,char*));
static void f2py_init_adjointpetsc(void) {
  F_FUNC(f2pyinitadjointpetsc,F2PYINITADJOINTPETSC)(f2py_setup_adjointpetsc);
}


static FortranDataDef f2py_inputtsstabderiv_def[] = {
  {"usewindaxis",0,{{-1}},NPY_INT},
  {"tsrmode",0,{{-1}},NPY_INT},
  {"tsstability",0,{{-1}},NPY_INT},
  {"tsbetamode",0,{{-1}},NPY_INT},
  {"tsmachmode",0,{{-1}},NPY_INT},
  {"tsaltitudemode",0,{{-1}},NPY_INT},
  {"tspmode",0,{{-1}},NPY_INT},
  {"tsqmode",0,{{-1}},NPY_INT},
  {"tsalphamode",0,{{-1}},NPY_INT},
  {"tsalphafollowing",0,{{-1}},NPY_INT},
  {NULL}
};

static void f2py_setup_inputtsstabderiv(char *usewindaxis,char *tsrmode,char *tsstability,char *tsbetamode,char *tsmachmode,char *tsaltitudemode,char *tspmode,char *tsqmode,char *tsalphamode,char *tsalphafollowing) {
  int i_f2py=0;
  f2py_inputtsstabderiv_def[i_f2py++].data = usewindaxis;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsrmode;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsstability;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsbetamode;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsmachmode;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsaltitudemode;
  f2py_inputtsstabderiv_def[i_f2py++].data = tspmode;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsqmode;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsalphamode;
  f2py_inputtsstabderiv_def[i_f2py++].data = tsalphafollowing;
}
extern void F_FUNC(f2pyinitinputtsstabderiv,F2PYINITINPUTTSSTABDERIV)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_inputtsstabderiv(void) {
  F_FUNC(f2pyinitinputtsstabderiv,F2PYINITINPUTTSSTABDERIV)(f2py_setup_inputtsstabderiv);
}


static FortranDataDef f2py_surfacefamilies_def[] = {
  {"getnfam",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfacefamilies_getnfam,doc_f2py_rout_libadflow_surfacefamilies_getnfam},
  {"getfam",-1,{{-1}},0,NULL,(void *)f2py_rout_libadflow_surfacefamilies_getfam,doc_f2py_rout_libadflow_surfacefamilies_getfam},
  {NULL}
};

static void f2py_setup_surfacefamilies(char *getnfam,char *getfam) {
  int i_f2py=0;
  f2py_surfacefamilies_def[i_f2py++].data = getnfam;
  f2py_surfacefamilies_def[i_f2py++].data = getfam;
}
extern void F_FUNC(f2pyinitsurfacefamilies,F2PYINITSURFACEFAMILIES)(void (*)(char *,char *));
static void f2py_init_surfacefamilies(void) {
  F_FUNC(f2pyinitsurfacefamilies,F2PYINITSURFACEFAMILIES)(f2py_setup_surfacefamilies);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {
  {"writesol",-1,{{-1}},0,(char *)F_FUNC(writesol,WRITESOL),(f2py_init_func)f2py_rout_libadflow_writesol,doc_f2py_rout_libadflow_writesol},
  {"getforces",-1,{{-1}},0,(char *)F_FUNC(getforces,GETFORCES),(f2py_init_func)f2py_rout_libadflow_getforces,doc_f2py_rout_libadflow_getforces},
  {"getheatflux",-1,{{-1}},0,(char *)F_FUNC(getheatflux,GETHEATFLUX),(f2py_init_func)f2py_rout_libadflow_getheatflux,doc_f2py_rout_libadflow_getheatflux},
  {"settnswall",-1,{{-1}},0,(char *)F_FUNC(settnswall,SETTNSWALL),(f2py_init_func)f2py_rout_libadflow_settnswall,doc_f2py_rout_libadflow_settnswall},
  {"gettnswall",-1,{{-1}},0,(char *)F_FUNC(gettnswall,GETTNSWALL),(f2py_init_func)f2py_rout_libadflow_gettnswall,doc_f2py_rout_libadflow_gettnswall},
  {"setcptargets",-1,{{-1}},0,(char *)F_FUNC(setcptargets,SETCPTARGETS),(f2py_init_func)f2py_rout_libadflow_setcptargets,doc_f2py_rout_libadflow_setcptargets},
  {"getcptargets",-1,{{-1}},0,(char *)F_FUNC(getcptargets,GETCPTARGETS),(f2py_init_func)f2py_rout_libadflow_getcptargets,doc_f2py_rout_libadflow_getcptargets},
  {"getareas",-1,{{-1}},0,(char *)F_FUNC(getareas,GETAREAS),(f2py_init_func)f2py_rout_libadflow_getareas,doc_f2py_rout_libadflow_getareas},
  {"getareasensitivity",-1,{{-1}},0,(char *)F_FUNC(getareasensitivity,GETAREASENSITIVITY),(f2py_init_func)f2py_rout_libadflow_getareasensitivity,doc_f2py_rout_libadflow_getareasensitivity},

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "libadflow",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};

PyMODINIT_FUNC PyInit_libadflow(void) {
  int i;
  PyObject *m,*d, *s, *tmp;
  m = libadflow_module = PyModule_Create(&moduledef);
  Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module libadflow (failed to import numpy)"); return m;}
  d = PyModule_GetDict(m);
  s = PyUnicode_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
  Py_DECREF(s);
  s = PyUnicode_FromString(
    "This module 'libadflow' is auto-generated with f2py (version:2).\nFunctions:\n"
"  writesol(famlist,nfamlist=len(famlist))\n"
"  getforces(forces,sps,npts=shape(forces,1))\n"
"  getheatflux(hflux,sps_in,npts=len(hflux))\n"
"  settnswall(tnsw,sps_in,npts=len(tnsw))\n"
"  tnsw = gettnswall(npts,sps)\n"
"  setcptargets(cptarget,sps_in,npts=len(cptarget))\n"
"  cptarget = getcptargets(npts,sps)\n"
"  areas = getareas(pts,sps_in,axis,npts=shape(pts,1))\n"
"  darea = getareasensitivity(pts,sps_in,axis,npts=shape(pts,1))\n"
"Fortran 90/95 modules:\n""  utils --- writeintromessage(),getliftdirfromsymmetry(),allocconvarrays(),alloctimearrays(),unsteadyheader(),pointreduce(),getcellcenters(),getcellcgnsblockids(),getncgnszones(),getcgnszonename(),releasememorypart1(),releasememorypart2()""  walldistance --- updatewalldistancealllevels()""  initializeflow --- updatebcdataalllevels(),initflow(),initflowrestart(),setuniformflow(),allocrestartfiles(),setrestartfiles(),infchangecorrection()""  bcdata --- setbcdata()""  agmg --- agmglevels,agmgnsmooth,setupagmg(),destroyagmg()""  flowutils --- updategamma(),adjustinflowangle()""  inputparamroutines --- setdefaultvalues(),monitorvariables(),surfacevariables(),volumevariables(),isovariables(),initializeisosurfacevariables(),setisosurfacevariable(),dummyreadparamfile()""  nksolver --- nk_innerpreconits,nk_outerpreconits,nk_jacobianlag,usenksolver,nk_adpc,nk_useew,nk_viscpc,nk_ls,nk_subspace,nk_asmoverlap,nk_rtolinit,nk_ilufill,nk_switchtol,nk_cfl0,nk_fixedstep,applypcsubspacesize,freestreamresset,getstates(),setstates(),getinfosize(),setinfo(),getinfo(),getres(),applypc(),applyadjointpc(),destroynksolver(),getfreestreamresidual()""  anksolver --- ank_innerpreconits,ank_outerpreconits,ank_jacobianlag,useanksolver,ank_useturbdadi,ank_subspace,ank_maxiter,ank_asmoverlap,ank_rtol,ank_linresmax,ank_ilufill,ank_switchtol,ank_cfl0,ank_cflmin0,ank_cfllimit,ank_cflfactor,ank_cflexponent,ank_cflcutback,ank_stepfactor,ank_stepmin,ank_constcflstep,ank_physlstol,ank_physlstolturb,ank_unstdylstol,ank_secondordswitchtol,ank_coupledswitchtol,ank_turbcflscale,ank_usefullvisc,ank_pcupdatetol,ank_adpc,ank_nsubiterturb,ank_turbdebug,ank_usematrixfree,destroyanksolver()""  partitioning --- partitionandreadgrid(),checkpartitioning()""  warping --- getcgnsmeshindices(),setgrid(),getgrid(),getstateperturbation(),getsurfaceperturbation()""  surfaceutils --- getsurfacesize(),getsurfaceconnectivity(),getsurfacepoints(),mapvector(),getwalllist()""  tecplotio --- addparaslice(),addabsslice(),addliftdistribution(),writetecplot(),initializeliftdistributiondata()""  surfaceintegrations --- getsolutionwrap()""  usersurfaceintegrations --- addintegrationsurface(),interpolateintegrationsurfaces()""  actuatorregion --- addactuatorregion(),writeactuatorregions()""  solvers --- solver(),solverunsteadyinit(),updateunsteadygeometry(),solverunsteadystep()""  aleutils --- shiftlevelale()""  preprocessingapi --- preprocessing(),updatecoordinatesalllevels(),updatemetricsalllevels(),updategridvelocitiesalllevels(),updateperiodicinfoalllevels(),shiftcoorandvolumes(),updatereferencepoint(),updaterotationrate(),preprocessingoverset()""  oversetapi --- updateoverset(),writepartitionedmesh(),oversetcomm(),setblockpriority()""  oversetutilities --- getoversetiblank()""  adjointapi --- setuppetscksp(),setupallresidualmatricesfwd(),solveadjoint(),solveadjointforrhs(),solvedirectforrhs(),saveadjointmatrix(),saveadjointpc(),saveadjointrhs(),savecellcenters(),spectralprecscribedmotion(),createpetscvars(),computematrixfreeproductfwd(),computematrixfreeproductbwd()""  adjointutils --- initializepetsc(),destroypetscvars()""  zippermesh --- createzippermesh(),checkzipper()""  oversetdata --- oversettimes""  constants --- maxstringlen,maxcgnsnamelen,eulerequations,nsequations,ransequations,steady,unsteady,timespectral,internalflow,externalflow,cpconstant,cptempcurvefits,spalartallmaras,spalartallmarasedwards,komegawilcox,komegamodified,ktau,mentersst,v2f,strain,vorticity,katolaunder,dissscalar,dissmatrix,disscusp,upwind,roe,vanleer,ausmdv,nolimiter,vanalbeda,minmod,noprecond,turkel,choimerkle,constantpressure,linextrapolpressure,quadextrapolpressure,normalmomentum,constantextrapol,linextrapol,rungekutta,dadi,nllusgs,nllusgsline,decoupled,coupled,gmres,adi,bcdirichlet0,bcneumann0,noresaveraging,alwaysresaveraging,alternateresaveraging,turbrelaxnotdefined,turbrelaxexplicit,turbrelaximplicit,precisionsingle,precisiondouble,bdf,explicitrk,implicitrk,md,nolinesearch,cubiclinesearch,nonmonotonelinesearch,updatefrozen,updatefast,updatefull,ncostfunction,costfunccdq,costfuncforcezcoef,costfuncmomzcoef,costfunccm0,costfuncforcex,costfuncclq,costfuncdrag,costfunccl0,costfunccmzqdot,costfuncforcexcoef,costfunccmzq,costfunccmzalphadot,costfunclift,costfunccd0,costfuncclqdot,costfuncforcey,costfuncforcez,costfuncmomz,costfunccdqdot,costfuncmomx,costfuncmomy,costfunccdalphadot,costfuncmomxcoef,costfunccdalpha,costfuncliftcoef,costfunccmzalpha,costfuncdragcoef,costfuncclalphadot,costfuncforceycoef,costfuncclalpha,costfuncmomycoef,costfunccfy0,costfunccfyalpha,costfunccfyalphadot,costfunccfyq,costfunccfyqdot,costfuncbendingcoef,costfuncsepsensor,costfuncsepsensoravgx,costfuncsepsensoravgy,costfuncsepsensoravgz,costfunccavitation,costfuncmdot,costfuncmavgptot,costfuncmavgttot,costfuncmavgrho,costfuncmavgps,costfuncmavgmn,costfuncmavga,costfuncarea,costfuncaxismoment,costfuncflowpower,costfuncforcexpressure,costfuncforceypressure,costfuncforcezpressure,costfuncforcexviscous,costfuncforceyviscous,costfuncforcezviscous,costfuncforcexmomentum,costfuncforceymomentum,costfuncforcezmomentum,costfuncdragpressure,costfuncdragviscous,costfuncdragmomentum,costfuncliftpressure,costfuncliftviscous,costfuncliftmomentum,costfuncforcexcoefpressure,costfuncforcexcoefviscous,costfuncforcexcoefmomentum,costfuncforceycoefpressure,costfuncforceycoefviscous,costfuncforceycoefmomentum,costfuncforcezcoefpressure,costfuncforcezcoefviscous,costfuncforcezcoefmomentum,costfuncliftcoefpressure,costfuncliftcoefviscous,costfuncliftcoefmomentum,costfuncdragcoefpressure,costfuncdragcoefviscous,costfuncdragcoefmomentum,costfuncmavgvx,costfuncmavgvy,costfuncmavgvz,costfunccperror2,costfuncaavgptot,costfuncaavgps""  communication --- adflow_comm_world,myid,nproc,sendrequests,recvrequests""  inputdiscretization --- spacediscr,spacediscrcoarse,orderturb,limiter,riemann,riemanncoarse,precond,eulerwallbctreatment,viscwallbctreatment,outflowtreatment,vis2,vis4,vis2coarse,adis,kappacoef,vortexcorr,dirscaling,radiineededfine,radiineededcoarse,lumpeddiss,sigma,useapproxwalldistance,lowspeedpreconditioner,useblockettes""  cgnsgrid --- cgnsndom""  inputio --- solfile,surfacesolfile,slicesolfile,liftdistributionfile,cpfile,writecoormeter,precisionsol,precisiongrid,precisionsurfsol,precisionsurfgrid,newgridfile,gridfile,storeconvinneriter,storerindlayer,checkrestartsol,autoparameterupdate,viscoussurfacevelocities,firstwrite,paramfile,forcedvolumefile,forcedsurfacefile,forcedliftfile,forcedslicefile""  inputiteration --- rkreset,mgdescription,ncycles,timelimit,ncyclescoarse,nsavevolume,nsavesurface,nsgstartup,smoother,nrkstages,resaveraging,cfllimit,turbtreatment,nsubiterturb,nsubiterations,turbsmoother,turbrelax,mgboundcorr,mgstartlevel,nmgsteps,nmglevels,miniternum,convcheckwindowsize,cyclestrategy,cfl,cflcoarse,fcoll,smoop,alfaturb,betaturb,l2conv,l2convcoarse,l2convrel,epscoefconv,etark,cdisrk,turbresscale,freezeturbsource,printiterations,printwarnings,maxl2deviationfactor,uselinresmonitor""  inputmotion --- rotpoint,coscoeffouryrot,coscoeffourxrot,degreefourxrot,sincoeffouralpha,omegafourbeta,coscoeffourbeta,sincoeffourbeta,degreepolbeta,sincoeffourmach,degreepolmach,omegafourmach,degreepolalpha,coefpolmach,coscoeffouralpha,coscoeffourmach,coefpolzrot,gridmotionspecified,omegafourzrot,degreefouryrot,coefpolyrot,degreefourbeta,omegafouralpha,coscoeffourzrot,degreepolzrot,sincoeffourzrot,omegafouryrot,degreefourzrot,degreefourmach,degreefouralpha,coefpolalpha,omegafourxrot,degreepolyrot,sincoeffourxrot,sincoeffouryrot,degreepolxrot,coefpolxrot,coefpolbeta""  inputparallel --- loadimbalance,splitblocks,loadbalanceiter,partitionlikenproc""  inputphysics --- equations,equationmode,flowtype,turbmodel,cpmodel,turbprod,rvfn,rvfb,useqcr,userotationsa,useft2sa,wallfunctions,mach,machcoef,machgrid,reynolds,reynoldslength,gammaconstant,rgasdim,prandtl,prandtlturb,pklim,walloffset,eddyvisinfratio,turbintensityinf,surfaceref,lengthref,veldirfreestream,liftdirection,dragdirection,pointref,pointrefec,momentaxis,forcesastractions,ssuthdim,musuthdim,tsuthdim,walldistcutoff,alpha,beta,liftindex,cavitationnumber""  inputadjoint --- adjointpcside,matrixordering,adjointsolvertype,localpctype,precondtype,adjabstol,adjdivtol,adjreltol,adjreltolrel,overlap,adjmonstep,filllevel,adjmaxiter,adjrestart,innerpreconits,outerpreconits,approxpc,adpc,viscpc,frozenturbulence,usediagtspc,restartadjoint,setmonitor,printtiming,firstrun,verifystate,verifyspatial,verifyextra,usematrixfreedrdw,applyadjointpcsubspacesize""  inputtimespectral --- ntimeintervalsspectral,dscalar,dvector,dtunsteadyrestartspectral,writeunsteadyrestartspectral,nunsteadysolspectral,writeunsteadyvolspectral,writeunsteadysurfspectral,rotmatrixspectral""  inputoverset --- useoversetloadbalance,nearwalldist,backgroundvolscale,oversetprojtol,overlapfactor,oversetupdatemode,nrefine,nflooditer,debugzipper,usezippermesh,useoversetwallscaling,selfzipcutoff""  inputunsteady --- deltat,useale,timeintegrationscheme,updatewalldistanceunsteady,timeaccuracy,ntimestepsfine,ntimestepscoarse""  iteration --- groundlevel,currentlevel,rkstage,nstepscycling,cycling,itertot,rfil,t0solver,converged,exchangepressureearly,standalonemode,changing_grid,deforming_grid,changingoverset,noldsolavail,noldlevels,coeftime,timespectralgridsnotwritten,oldsolwritten,totalr0,totalrstart,totalrfinal""  monitor --- nmonsum,nmonmax,nmon,monloc,monglob,monref,monnames,monmachorhmax,showcpu,monmasssliding,monmassfamilies,nitercur,convarray,ntimestepsrestart,timestepunsteady,timeunsteady,timeunsteadyrestart,timearray,timedataarray,writegrid,writevolume,writesurface""  block --- ndom,ncellglobal""  flowvarrefstate --- nw,nwf,nwt,nt1,nt2,pref,rhoref,tref,muref,timeref,lref,lrefspecified,pinfdim,rhoinfdim,tinfdim,mudim,rhoinf,uinf,pinf,pinfcorr,rgas,muinf,gammainf,winf,kpresent,eddymodel,viscous""  killsignals --- frompython,routinefailed,fatalfail,adjointfailed""  inputcostfunctions --- sepsensoroffset,sepsensorsharpness,computecavitation""  adjointvars --- ncellslocal,nnodeslocal,ialpha,ibeta,imach,imachgrid,irotx,iroty,irotz,irotcenx,irotceny,irotcenz,ipointrefx,ipointrefy,ipointrefz,ipressure,itemperature,idensity,iaxisx1,iaxisx2,iaxisy1,iaxisy2,iaxisz1,iaxisz2,ndesignextra""  adjointpetsc --- adjresinit,adjresstart,adjresfinal""  inputtsstabderiv --- usewindaxis,tsrmode,tsstability,tsbetamode,tsmachmode,tsaltitudemode,tspmode,tsqmode,tsalphamode,tsalphafollowing""  surfacefamilies --- getnfam(),getfam()"".");
  PyDict_SetItemString(d, "__doc__", s);
  Py_DECREF(s);
  s = PyUnicode_FromString("1.20.1");
  PyDict_SetItemString(d, "__f2py_numpy_version__", s);
  Py_DECREF(s);
  libadflow_error = PyErr_NewException ("libadflow.error", NULL, NULL);
  /*
   * Store the error object inside the dict, so that it could get deallocated.
   * (in practice, this is a module, so it likely will not and cannot.)
   */
  PyDict_SetItemString(d, "_libadflow_error", libadflow_error);
  Py_DECREF(libadflow_error);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
    tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
    PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
    Py_DECREF(tmp);
  }

















































































































/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "surfacefamilies", PyFortranObject_New(f2py_surfacefamilies_def,f2py_init_surfacefamilies));
  PyDict_SetItemString(d, "inputtsstabderiv", PyFortranObject_New(f2py_inputtsstabderiv_def,f2py_init_inputtsstabderiv));
  PyDict_SetItemString(d, "adjointpetsc", PyFortranObject_New(f2py_adjointpetsc_def,f2py_init_adjointpetsc));
  PyDict_SetItemString(d, "adjointvars", PyFortranObject_New(f2py_adjointvars_def,f2py_init_adjointvars));
  PyDict_SetItemString(d, "inputcostfunctions", PyFortranObject_New(f2py_inputcostfunctions_def,f2py_init_inputcostfunctions));
  PyDict_SetItemString(d, "killsignals", PyFortranObject_New(f2py_killsignals_def,f2py_init_killsignals));
  PyDict_SetItemString(d, "flowvarrefstate", PyFortranObject_New(f2py_flowvarrefstate_def,f2py_init_flowvarrefstate));
  PyDict_SetItemString(d, "block", PyFortranObject_New(f2py_block_def,f2py_init_block));
  PyDict_SetItemString(d, "monitor", PyFortranObject_New(f2py_monitor_def,f2py_init_monitor));
  PyDict_SetItemString(d, "iteration", PyFortranObject_New(f2py_iteration_def,f2py_init_iteration));
  PyDict_SetItemString(d, "inputunsteady", PyFortranObject_New(f2py_inputunsteady_def,f2py_init_inputunsteady));
  PyDict_SetItemString(d, "inputoverset", PyFortranObject_New(f2py_inputoverset_def,f2py_init_inputoverset));
  PyDict_SetItemString(d, "inputtimespectral", PyFortranObject_New(f2py_inputtimespectral_def,f2py_init_inputtimespectral));
  PyDict_SetItemString(d, "inputadjoint", PyFortranObject_New(f2py_inputadjoint_def,f2py_init_inputadjoint));
  PyDict_SetItemString(d, "inputphysics", PyFortranObject_New(f2py_inputphysics_def,f2py_init_inputphysics));
  PyDict_SetItemString(d, "inputparallel", PyFortranObject_New(f2py_inputparallel_def,f2py_init_inputparallel));
  PyDict_SetItemString(d, "inputmotion", PyFortranObject_New(f2py_inputmotion_def,f2py_init_inputmotion));
  PyDict_SetItemString(d, "inputiteration", PyFortranObject_New(f2py_inputiteration_def,f2py_init_inputiteration));
  PyDict_SetItemString(d, "inputio", PyFortranObject_New(f2py_inputio_def,f2py_init_inputio));
  PyDict_SetItemString(d, "cgnsgrid", PyFortranObject_New(f2py_cgnsgrid_def,f2py_init_cgnsgrid));
  PyDict_SetItemString(d, "inputdiscretization", PyFortranObject_New(f2py_inputdiscretization_def,f2py_init_inputdiscretization));
  PyDict_SetItemString(d, "communication", PyFortranObject_New(f2py_communication_def,f2py_init_communication));
  PyDict_SetItemString(d, "constants", PyFortranObject_New(f2py_constants_def,f2py_init_constants));
  PyDict_SetItemString(d, "oversetdata", PyFortranObject_New(f2py_oversetdata_def,f2py_init_oversetdata));
  PyDict_SetItemString(d, "zippermesh", PyFortranObject_New(f2py_zippermesh_def,f2py_init_zippermesh));
  PyDict_SetItemString(d, "adjointutils", PyFortranObject_New(f2py_adjointutils_def,f2py_init_adjointutils));
  PyDict_SetItemString(d, "adjointapi", PyFortranObject_New(f2py_adjointapi_def,f2py_init_adjointapi));
  PyDict_SetItemString(d, "oversetutilities", PyFortranObject_New(f2py_oversetutilities_def,f2py_init_oversetutilities));
  PyDict_SetItemString(d, "oversetapi", PyFortranObject_New(f2py_oversetapi_def,f2py_init_oversetapi));
  PyDict_SetItemString(d, "preprocessingapi", PyFortranObject_New(f2py_preprocessingapi_def,f2py_init_preprocessingapi));
  PyDict_SetItemString(d, "aleutils", PyFortranObject_New(f2py_aleutils_def,f2py_init_aleutils));
  PyDict_SetItemString(d, "solvers", PyFortranObject_New(f2py_solvers_def,f2py_init_solvers));
  PyDict_SetItemString(d, "actuatorregion", PyFortranObject_New(f2py_actuatorregion_def,f2py_init_actuatorregion));
  PyDict_SetItemString(d, "usersurfaceintegrations", PyFortranObject_New(f2py_usersurfaceintegrations_def,f2py_init_usersurfaceintegrations));
  PyDict_SetItemString(d, "surfaceintegrations", PyFortranObject_New(f2py_surfaceintegrations_def,f2py_init_surfaceintegrations));
  PyDict_SetItemString(d, "tecplotio", PyFortranObject_New(f2py_tecplotio_def,f2py_init_tecplotio));
  PyDict_SetItemString(d, "surfaceutils", PyFortranObject_New(f2py_surfaceutils_def,f2py_init_surfaceutils));
  PyDict_SetItemString(d, "warping", PyFortranObject_New(f2py_warping_def,f2py_init_warping));
  PyDict_SetItemString(d, "partitioning", PyFortranObject_New(f2py_partitioning_def,f2py_init_partitioning));
  PyDict_SetItemString(d, "anksolver", PyFortranObject_New(f2py_anksolver_def,f2py_init_anksolver));
  PyDict_SetItemString(d, "nksolver", PyFortranObject_New(f2py_nksolver_def,f2py_init_nksolver));
  PyDict_SetItemString(d, "inputparamroutines", PyFortranObject_New(f2py_inputparamroutines_def,f2py_init_inputparamroutines));
  PyDict_SetItemString(d, "flowutils", PyFortranObject_New(f2py_flowutils_def,f2py_init_flowutils));
  PyDict_SetItemString(d, "agmg", PyFortranObject_New(f2py_agmg_def,f2py_init_agmg));
  PyDict_SetItemString(d, "bcdata", PyFortranObject_New(f2py_bcdata_def,f2py_init_bcdata));
  PyDict_SetItemString(d, "initializeflow", PyFortranObject_New(f2py_initializeflow_def,f2py_init_initializeflow));
  PyDict_SetItemString(d, "walldistance", PyFortranObject_New(f2py_walldistance_def,f2py_init_walldistance));
  PyDict_SetItemString(d, "utils", PyFortranObject_New(f2py_utils_def,f2py_init_utils));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"libadflow");
#endif
  return m;
}
#ifdef __cplusplus
}
#endif

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
! this module contains routines used for applying *all* boundary
! conditions for navier stokes part of the code. boundary conditions
! pointers from the bcpointers modules are used. the utilty routine
! setbcpointers are employed.
module bcroutines_d
  implicit none
  save 

contains
  subroutine applyallbc_block(secondhalo)
! apply bc's for a single block
    use constants
    use blockpointers, only : nbocos, bctype, nviscbocos, w, dw, x, &
&   vol, il, jl, kl, sectionid, wold, volold, bcdata, si, sj, sk, sfacei&
&   , sfacej, sfacek, rlv, gamma, p, rev, bmtj1, bmtj2, scratch, bmtk2, &
&   bmtk1, fw, aa, d2wall, bmti1, bmti2, s
    use utils_d, only : setbcpointers, getcorrectfork
    use bcpointers_d
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
! local variables.
    logical :: correctfork
    integer(kind=inttype) :: nn
!
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    correctfork = getcorrectfork()
! apply all the boundary conditions. the order is important!  only
! some of them have been ad'ed
! ------------------------------------
!  symmetry boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers(nn, .false.)
        call bcsymm1sthalo(nn)
      end if
    end do
    if (secondhalo) then
      do nn=1,nbocos
        if (bctype(nn) .eq. symm) then
          call setbcpointers(nn, .false.)
          call bcsymm2ndhalo(nn)
        end if
      end do
    end if
! ------------------------------------
!  symmetry polar boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symmpolar) then
        call setbcpointers(nn, .true.)
        call bcsymmpolar1sthalo(nn)
      end if
    end do
    if (secondhalo) then
      do nn=1,nbocos
        if (bctype(nn) .eq. symmpolar) then
          call setbcpointers(nn, .true.)
          call bcsymmpolar2ndhalo(nn)
        end if
      end do
    end if
! ------------------------------------
!  adibatic wall boundary condition
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers(nn, .false.)
        call bcnswalladiabatic(nn, secondhalo, correctfork)
      end if
    end do
! ------------------------------------
!  isotermal wall boundary condition
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers(nn, .false.)
        call bcnswallisothermal(nn, secondhalo, correctfork)
      end if
    end do
! ------------------------------------
!  farfield boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers(nn, .false.)
        call bcfarfield(nn, secondhalo, correctfork)
      end if
    end do
! ------------------------------------
!  subsonic outflow boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. subsonicoutflow .or. bctype(nn) .eq. &
&         massbleedoutflow) then
        call setbcpointers(nn, .false.)
        call bcsubsonicoutflow(nn, secondhalo, correctfork)
      end if
    end do
! ------------------------------------
!  subsonic inflow boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. subsonicinflow) then
        call setbcpointers(nn, .false.)
        call bcsubsonicinflow(nn, secondhalo, correctfork)
      end if
    end do
! ------------------------------------
!  extrapolation boundary condition
! ------------------------------------
! extrapolation boundary conditions; this also includes
! the supersonic outflow boundary conditions. the difference
! between the two is that the extrap boundary conditions
! correspond to singular lines and supersonic outflow
! boundaries to physical boundaries. the treatment however
! is identical.
    do nn=1,nbocos
      if (bctype(nn) .eq. extrap .or. bctype(nn) .eq. supersonicoutflow&
&     ) then
        call setbcpointers(nn, .false.)
        call bcextrap(nn, secondhalo, correctfork)
      end if
    end do
! ------------------------------------
!  euler wall boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. eulerwall) then
        call setbcpointers(nn, .true.)
        call bceulerwall(nn, secondhalo, correctfork)
      end if
    end do
! ------------------------------------
!  supersonic inflow condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. supersonicinflow) then
        call setbcpointers(nn, .false.)
        call bcsupersonicinflow(nn, secondhalo, correctfork)
      end if
    end do
  end subroutine applyallbc_block
!  differentiation of bcsymm1sthalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev1 *pp1 *rlv1 *ww1
!   with respect to varying inputs: *rev1 *rev2 *pp1 *pp2 *rlv1
!                *rlv2 *ww1 *ww2 *(*bcdata.norm)
!   rw status of diff variables: *rev1:in-out *rev2:in *pp1:in-out
!                *pp2:in *rlv1:in-out *rlv2:in *ww1:in-out *ww2:in
!                *(*bcdata.norm):in
!   plus diff mem management of: rev1:in rev2:in pp1:in pp2:in
!                rlv1:in rlv2:in ww1:in ww2:in bcdata:in *bcdata.norm:in
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm1sthalo_d(nn)
!  bcsymm1sthalo applies the symmetry boundary conditions to a
!  block.  * it is assumed that the pointers in blockpointers are
!  already set to the correct block on the correct grid level.
!
!  in case also the second halo must be set, a second loop is
!  execulted calling bcsymm2ndhalo. this is the only correct way
!  in case the block contains only 1 cell between two symmetry
!  planes, i.e. a 2d problem.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_d, only : gamma1, gamma2, ww1, ww1d, ww2, ww2d, pp1, &
&   pp1d, pp2, pp2d, rlv1, rlv1d, rlv2, rlv2d, istart, jstart, isize, &
&   jsize, rev1, rev1d, rev2, rev2d
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vnd = two*(ww2d(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivx)&
&       *bcdatad(nn)%norm(i, j, 1)+ww2d(i, j, ivy)*bcdata(nn)%norm(i, j&
&       , 2)+ww2(i, j, ivy)*bcdatad(nn)%norm(i, j, 2)+ww2d(i, j, ivz)*&
&       bcdata(nn)%norm(i, j, 3)+ww2(i, j, ivz)*bcdatad(nn)%norm(i, j, 3&
&       ))
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww1d(i, j, irho) = ww2d(i, j, irho)
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1d(i, j, ivx) = ww2d(i, j, ivx) - vnd*bcdata(nn)%norm(i, j, 1) -&
&       vn*bcdatad(nn)%norm(i, j, 1)
      ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww1d(i, j, ivy) = ww2d(i, j, ivy) - vnd*bcdata(nn)%norm(i, j, 2) -&
&       vn*bcdatad(nn)%norm(i, j, 2)
      ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww1d(i, j, ivz) = ww2d(i, j, ivz) - vnd*bcdata(nn)%norm(i, j, 3) -&
&       vn*bcdatad(nn)%norm(i, j, 3)
      ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww1d(i, j, irhoe) = ww2d(i, j, irhoe)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma1(i, j) = gamma2(i, j)
      pp1d(i, j) = pp2d(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) then
        rlv1d(i, j) = rlv2d(i, j)
        rlv1(i, j) = rlv2(i, j)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev2d(i, j)
        rev1(i, j) = rev2(i, j)
      end if
    end do
  end subroutine bcsymm1sthalo_d
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm1sthalo(nn)
!  bcsymm1sthalo applies the symmetry boundary conditions to a
!  block.  * it is assumed that the pointers in blockpointers are
!  already set to the correct block on the correct grid level.
!
!  in case also the second halo must be set, a second loop is
!  execulted calling bcsymm2ndhalo. this is the only correct way
!  in case the block contains only 1 cell between two symmetry
!  planes, i.e. a 2d problem.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_d, only : gamma1, gamma2, ww1, ww2, pp1, pp2, rlv1, &
&   rlv2, istart, jstart, isize, jsize, rev1, rev2
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma1(i, j) = gamma2(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
  end subroutine bcsymm1sthalo
!  differentiation of bcsymm2ndhalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *pp0 *rlv0 *ww0
!   with respect to varying inputs: *rev0 *rev3 *pp0 *pp3 *rlv0
!                *rlv3 *ww0 *ww3 *(*bcdata.norm)
!   rw status of diff variables: *rev0:in-out *rev3:in *pp0:in-out
!                *pp3:in *rlv0:in-out *rlv3:in *ww0:in-out *ww3:in
!                *(*bcdata.norm):in
!   plus diff mem management of: rev0:in rev3:in pp0:in pp3:in
!                rlv0:in rlv3:in ww0:in ww3:in bcdata:in *bcdata.norm:in
  subroutine bcsymm2ndhalo_d(nn)
!  bcsymm2ndhalo applies the symmetry boundary conditions to a
!  block for the 2nd halo. this routine is separate as it makes
!  ad slightly easier.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_d, only : gamma0, gamma3, ww0, ww0d, ww3, ww3d, pp0, &
&   pp0d, pp3, pp3d, rlv0, rlv0d, rlv3, rlv3d, rev0, rev0d, rev3, rev3d,&
&   istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
! if we need the second halo, do everything again, but using ww0,
! ww3 etc instead of ww2 and ww1.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      vnd = two*(ww3d(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivx)&
&       *bcdatad(nn)%norm(i, j, 1)+ww3d(i, j, ivy)*bcdata(nn)%norm(i, j&
&       , 2)+ww3(i, j, ivy)*bcdatad(nn)%norm(i, j, 2)+ww3d(i, j, ivz)*&
&       bcdata(nn)%norm(i, j, 3)+ww3(i, j, ivz)*bcdatad(nn)%norm(i, j, 3&
&       ))
      vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww0d(i, j, irho) = ww3d(i, j, irho)
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0d(i, j, ivx) = ww3d(i, j, ivx) - vnd*bcdata(nn)%norm(i, j, 1) -&
&       vn*bcdatad(nn)%norm(i, j, 1)
      ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww0d(i, j, ivy) = ww3d(i, j, ivy) - vnd*bcdata(nn)%norm(i, j, 2) -&
&       vn*bcdatad(nn)%norm(i, j, 2)
      ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww0d(i, j, ivz) = ww3d(i, j, ivz) - vnd*bcdata(nn)%norm(i, j, 3) -&
&       vn*bcdatad(nn)%norm(i, j, 3)
      ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww0d(i, j, irhoe) = ww3d(i, j, irhoe)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma0(i, j) = gamma3(i, j)
      pp0d(i, j) = pp3d(i, j)
      pp0(i, j) = pp3(i, j)
      if (viscous) then
        rlv0d(i, j) = rlv3d(i, j)
        rlv0(i, j) = rlv3(i, j)
      end if
      if (eddymodel) then
        rev0d(i, j) = rev3d(i, j)
        rev0(i, j) = rev3(i, j)
      end if
    end do
  end subroutine bcsymm2ndhalo_d
  subroutine bcsymm2ndhalo(nn)
!  bcsymm2ndhalo applies the symmetry boundary conditions to a
!  block for the 2nd halo. this routine is separate as it makes
!  ad slightly easier.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_d, only : gamma0, gamma3, ww0, ww3, pp0, pp3, rlv0, &
&   rlv3, rev0, rev3, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! if we need the second halo, do everything again, but using ww0,
! ww3 etc instead of ww2 and ww1.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma0(i, j) = gamma3(i, j)
      pp0(i, j) = pp3(i, j)
      if (viscous) rlv0(i, j) = rlv3(i, j)
      if (eddymodel) rev0(i, j) = rev3(i, j)
    end do
  end subroutine bcsymm2ndhalo
!  differentiation of bcsymmpolar1sthalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev1 *pp1 *rlv1 *ww1
!   with respect to varying inputs: *xx *rev1 *rev2 *pp1 *pp2 *rlv1
!                *rlv2 *ww1 *ww2
!   rw status of diff variables: *xx:in *rev1:in-out *rev2:in *pp1:in-out
!                *pp2:in *rlv1:in-out *rlv2:in *ww1:in-out *ww2:in
!   plus diff mem management of: xx:in rev1:in rev2:in pp1:in pp2:in
!                rlv1:in rlv2:in ww1:in ww2:in
  subroutine bcsymmpolar1sthalo_d(nn)
! bcsymmpolar applies the polar symmetry boundary conditions to a
! singular line of a block. it is assumed that the pointers in
! blockpointers are already set to the correct block on the
! correct grid level.  the polar symmetry condition is a special
! case of a degenerate line, as this line is the axi-symmetric
! centerline. this routine does just the 1st level halo.
    use constants
    use bcpointers_d, only : ww1, ww1d, ww2, ww2d, pp1, pp1d, pp2, pp2d,&
&   rlv1, rlv1d, rlv2, rlv2d, rev1, rev1d, rev2, rev2d, xx, xxd, istart,&
&   jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii, mm
    real(kind=realtype) :: nnx, nny, nnz, tmp, vtx, vty, vtz
    real(kind=realtype) :: nnxd, nnyd, nnzd, tmpd, vtxd, vtyd, vtzd
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine the unit vector along the degenerated face.
! however it is not known which is the singular
! direction and therefore determine the direction along
! the diagonal (i,j) -- (i-1,j-1), which is correct for
! both singular i and j-direction. note that due to the
! usage of the pointer xx there is an offset of +1
! in the indices and therefore (i+1,j+1) - (i,j) must
! be used to determine this vector.
      nnxd = xxd(i+1, j+1, 1) - xxd(i, j, 1)
      nnx = xx(i+1, j+1, 1) - xx(i, j, 1)
      nnyd = xxd(i+1, j+1, 2) - xxd(i, j, 2)
      nny = xx(i+1, j+1, 2) - xx(i, j, 2)
      nnzd = xxd(i+1, j+1, 3) - xxd(i, j, 3)
      nnz = xx(i+1, j+1, 3) - xx(i, j, 3)
! determine the unit vector in this direction.
      arg1d = nnxd*nnx + nnx*nnxd + nnyd*nny + nny*nnyd + nnzd*nnz + nnz&
&       *nnzd
      arg1 = nnx*nnx + nny*nny + nnz*nnz
      if (arg1 .eq. 0.0_8) then
        result1d = 0.0_8
      else
        result1d = arg1d/(2.0*sqrt(arg1))
      end if
      result1 = sqrt(arg1)
      tmpd = -(one*result1d/result1**2)
      tmp = one/result1
      nnxd = nnxd*tmp + nnx*tmpd
      nnx = nnx*tmp
      nnyd = nnyd*tmp + nny*tmpd
      nny = nny*tmp
      nnzd = nnzd*tmp + nnz*tmpd
      nnz = nnz*tmp
! determine twice the tangential velocity vector of the
! internal cell.
      tmpd = two*(ww2d(i, j, ivx)*nnx+ww2(i, j, ivx)*nnxd+ww2d(i, j, ivy&
&       )*nny+ww2(i, j, ivy)*nnyd+ww2d(i, j, ivz)*nnz+ww2(i, j, ivz)*&
&       nnzd)
      tmp = two*(ww2(i, j, ivx)*nnx+ww2(i, j, ivy)*nny+ww2(i, j, ivz)*&
&       nnz)
      vtxd = tmpd*nnx + tmp*nnxd
      vtx = tmp*nnx
      vtyd = tmpd*nny + tmp*nnyd
      vty = tmp*nny
      vtzd = tmpd*nnz + tmp*nnzd
      vtz = tmp*nnz
! determine the flow variables in the halo cell. the
! velocity is constructed such that the average of the
! internal and the halo cell is along the centerline.
! note that the magnitude of the velocity does not
! change and thus the energy is identical.
      ww1d(i, j, irho) = ww2d(i, j, irho)
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1d(i, j, ivx) = vtxd - ww2d(i, j, ivx)
      ww1(i, j, ivx) = vtx - ww2(i, j, ivx)
      ww1d(i, j, ivy) = vtyd - ww2d(i, j, ivy)
      ww1(i, j, ivy) = vty - ww2(i, j, ivy)
      ww1d(i, j, ivz) = vtzd - ww2d(i, j, ivz)
      ww1(i, j, ivz) = vtz - ww2(i, j, ivz)
      ww1d(i, j, irhoe) = ww2d(i, j, irhoe)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! set the pressure and possibly the laminar and
! eddy viscosity in the halo.
      pp1d(i, j) = pp2d(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) then
        rlv1d(i, j) = rlv2d(i, j)
        rlv1(i, j) = rlv2(i, j)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev2d(i, j)
        rev1(i, j) = rev2(i, j)
      end if
    end do
  end subroutine bcsymmpolar1sthalo_d
  subroutine bcsymmpolar1sthalo(nn)
! bcsymmpolar applies the polar symmetry boundary conditions to a
! singular line of a block. it is assumed that the pointers in
! blockpointers are already set to the correct block on the
! correct grid level.  the polar symmetry condition is a special
! case of a degenerate line, as this line is the axi-symmetric
! centerline. this routine does just the 1st level halo.
    use constants
    use bcpointers_d, only : ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, rev2,&
&   xx, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii, mm
    real(kind=realtype) :: nnx, nny, nnz, tmp, vtx, vty, vtz
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine the unit vector along the degenerated face.
! however it is not known which is the singular
! direction and therefore determine the direction along
! the diagonal (i,j) -- (i-1,j-1), which is correct for
! both singular i and j-direction. note that due to the
! usage of the pointer xx there is an offset of +1
! in the indices and therefore (i+1,j+1) - (i,j) must
! be used to determine this vector.
      nnx = xx(i+1, j+1, 1) - xx(i, j, 1)
      nny = xx(i+1, j+1, 2) - xx(i, j, 2)
      nnz = xx(i+1, j+1, 3) - xx(i, j, 3)
! determine the unit vector in this direction.
      arg1 = nnx*nnx + nny*nny + nnz*nnz
      result1 = sqrt(arg1)
      tmp = one/result1
      nnx = nnx*tmp
      nny = nny*tmp
      nnz = nnz*tmp
! determine twice the tangential velocity vector of the
! internal cell.
      tmp = two*(ww2(i, j, ivx)*nnx+ww2(i, j, ivy)*nny+ww2(i, j, ivz)*&
&       nnz)
      vtx = tmp*nnx
      vty = tmp*nny
      vtz = tmp*nnz
! determine the flow variables in the halo cell. the
! velocity is constructed such that the average of the
! internal and the halo cell is along the centerline.
! note that the magnitude of the velocity does not
! change and thus the energy is identical.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = vtx - ww2(i, j, ivx)
      ww1(i, j, ivy) = vty - ww2(i, j, ivy)
      ww1(i, j, ivz) = vtz - ww2(i, j, ivz)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! set the pressure and possibly the laminar and
! eddy viscosity in the halo.
      pp1(i, j) = pp2(i, j)
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
  end subroutine bcsymmpolar1sthalo
!  differentiation of bcsymmpolar2ndhalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *pp0 *rlv0 *ww0
!   with respect to varying inputs: *xx *rev0 *rev3 *pp0 *pp3 *rlv0
!                *rlv3 *ww0 *ww3
!   rw status of diff variables: *xx:in *rev0:in-out *rev3:in *pp0:in-out
!                *pp3:in *rlv0:in-out *rlv3:in *ww0:in-out *ww3:in
!   plus diff mem management of: xx:in rev0:in rev3:in pp0:in pp3:in
!                rlv0:in rlv3:in ww0:in ww3:in
  subroutine bcsymmpolar2ndhalo_d(nn)
! bcsymmpolar applies the polar symmetry boundary conditions to a
! singular line of a block. it is assumed that the pointers in
! blockpointers are already set to the correct block on the
! correct grid level.  the polar symmetry condition is a special
! case of a degenerate line, as this line is the axi-symmetric
! centerline. this routine does just the 2nd level halo.
    use constants
    use bcpointers_d, only : ww0, ww0d, ww3, ww3d, pp0, pp0d, pp3, pp3d,&
&   rlv0, rlv0d, rlv3, rlv3d, rev0, rev0d, rev3, rev3d, xx, xxd, istart,&
&   jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii, mm
    real(kind=realtype) :: nnx, nny, nnz, tmp, vtx, vty, vtz
    real(kind=realtype) :: nnxd, nnyd, nnzd, tmpd, vtxd, vtyd, vtzd
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine the unit vector along the degenerated face.
! however it is not known which is the singular
! direction and therefore determine the direction along
! the diagonal (i,j) -- (i-1,j-1), which is correct for
! both singular i and j-direction. note that due to the
! usage of the pointer xx there is an offset of +1
! in the indices and therefore (i+1,j+1) - (i,j) must
! be used to determine this vector.
      nnxd = xxd(i+1, j+1, 1) - xxd(i, j, 1)
      nnx = xx(i+1, j+1, 1) - xx(i, j, 1)
      nnyd = xxd(i+1, j+1, 2) - xxd(i, j, 2)
      nny = xx(i+1, j+1, 2) - xx(i, j, 2)
      nnzd = xxd(i+1, j+1, 3) - xxd(i, j, 3)
      nnz = xx(i+1, j+1, 3) - xx(i, j, 3)
! determine the unit vector in this direction.
      arg1d = nnxd*nnx + nnx*nnxd + nnyd*nny + nny*nnyd + nnzd*nnz + nnz&
&       *nnzd
      arg1 = nnx*nnx + nny*nny + nnz*nnz
      if (arg1 .eq. 0.0_8) then
        result1d = 0.0_8
      else
        result1d = arg1d/(2.0*sqrt(arg1))
      end if
      result1 = sqrt(arg1)
      tmpd = -(one*result1d/result1**2)
      tmp = one/result1
      nnxd = nnxd*tmp + nnx*tmpd
      nnx = nnx*tmp
      nnyd = nnyd*tmp + nny*tmpd
      nny = nny*tmp
      nnzd = nnzd*tmp + nnz*tmpd
      nnz = nnz*tmp
! determine twice the tangential velocity vector of the
! internal cell.
      tmpd = two*(ww3d(i, j, ivx)*nnx+ww3(i, j, ivx)*nnxd+ww3d(i, j, ivy&
&       )*nny+ww3(i, j, ivy)*nnyd+ww3d(i, j, ivz)*nnz+ww3(i, j, ivz)*&
&       nnzd)
      tmp = two*(ww3(i, j, ivx)*nnx+ww3(i, j, ivy)*nny+ww3(i, j, ivz)*&
&       nnz)
      vtxd = tmpd*nnx + tmp*nnxd
      vtx = tmp*nnx
      vtyd = tmpd*nny + tmp*nnyd
      vty = tmp*nny
      vtzd = tmpd*nnz + tmp*nnzd
      vtz = tmp*nnz
! determine the flow variables in the halo cell. the
! velocity is constructed such that the average of the
! internal and the halo cell is along the centerline.
! note that the magnitude of the velocity does not
! change and thus the energy is identical.
      ww0d(i, j, irho) = ww3d(i, j, irho)
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0d(i, j, ivx) = vtxd - ww3d(i, j, ivx)
      ww0(i, j, ivx) = vtx - ww3(i, j, ivx)
      ww0d(i, j, ivy) = vtyd - ww3d(i, j, ivy)
      ww0(i, j, ivy) = vty - ww3(i, j, ivy)
      ww0d(i, j, ivz) = vtzd - ww3d(i, j, ivz)
      ww0(i, j, ivz) = vtz - ww3(i, j, ivz)
      ww0d(i, j, irhoe) = ww3d(i, j, irhoe)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
! set the pressure and possibly the laminar and
! eddy viscosity in the halo.
      pp0d(i, j) = pp3d(i, j)
      pp0(i, j) = pp3(i, j)
      if (viscous) then
        rlv0d(i, j) = rlv3d(i, j)
        rlv0(i, j) = rlv3(i, j)
      end if
      if (eddymodel) then
        rev0d(i, j) = rev3d(i, j)
        rev0(i, j) = rev3(i, j)
      end if
    end do
  end subroutine bcsymmpolar2ndhalo_d
  subroutine bcsymmpolar2ndhalo(nn)
! bcsymmpolar applies the polar symmetry boundary conditions to a
! singular line of a block. it is assumed that the pointers in
! blockpointers are already set to the correct block on the
! correct grid level.  the polar symmetry condition is a special
! case of a degenerate line, as this line is the axi-symmetric
! centerline. this routine does just the 2nd level halo.
    use constants
    use bcpointers_d, only : ww0, ww3, pp0, pp3, rlv0, rlv3, rev0, rev3,&
&   xx, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii, mm
    real(kind=realtype) :: nnx, nny, nnz, tmp, vtx, vty, vtz
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine the unit vector along the degenerated face.
! however it is not known which is the singular
! direction and therefore determine the direction along
! the diagonal (i,j) -- (i-1,j-1), which is correct for
! both singular i and j-direction. note that due to the
! usage of the pointer xx there is an offset of +1
! in the indices and therefore (i+1,j+1) - (i,j) must
! be used to determine this vector.
      nnx = xx(i+1, j+1, 1) - xx(i, j, 1)
      nny = xx(i+1, j+1, 2) - xx(i, j, 2)
      nnz = xx(i+1, j+1, 3) - xx(i, j, 3)
! determine the unit vector in this direction.
      arg1 = nnx*nnx + nny*nny + nnz*nnz
      result1 = sqrt(arg1)
      tmp = one/result1
      nnx = nnx*tmp
      nny = nny*tmp
      nnz = nnz*tmp
! determine twice the tangential velocity vector of the
! internal cell.
      tmp = two*(ww3(i, j, ivx)*nnx+ww3(i, j, ivy)*nny+ww3(i, j, ivz)*&
&       nnz)
      vtx = tmp*nnx
      vty = tmp*nny
      vtz = tmp*nnz
! determine the flow variables in the halo cell. the
! velocity is constructed such that the average of the
! internal and the halo cell is along the centerline.
! note that the magnitude of the velocity does not
! change and thus the energy is identical.
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0(i, j, ivx) = vtx - ww3(i, j, ivx)
      ww0(i, j, ivy) = vty - ww3(i, j, ivy)
      ww0(i, j, ivz) = vtz - ww3(i, j, ivz)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
! set the pressure and possibly the laminar and
! eddy viscosity in the halo.
      pp0(i, j) = pp3(i, j)
      if (viscous) rlv0(i, j) = rlv3(i, j)
      if (eddymodel) rev0(i, j) = rev3(i, j)
    end do
  end subroutine bcsymmpolar2ndhalo
!  differentiation of bcnswalladiabatic in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:in
!                *pp0:in-out *pp1:in-out *pp2:in *rlv0:in-out *rlv1:in-out
!                *rlv2:in *ww0:in-out *ww1:in-out *ww2:in
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in
  subroutine bcnswalladiabatic_d(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous adiabatic wall boundary
! condition the pointers already defined.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, rlv0, &
&   rlv0d, rlv1, rlv1d, rlv2, rlv2d, pp0, pp0d, pp1, pp1d, pp2, pp2d, &
&   pp3, pp3d, rev0, rev0d, rev1, rev1d, rev2, rev2d, istart, jstart, &
&   isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    use iteration, only : currentlevel, groundlevel
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    real(kind=realtype) :: rhokd
    integer(kind=inttype) :: walltreatment
    intrinsic mod
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
    rhokd = 0.0_8
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        rhokd = ww2d(i, j, irho)*ww2(i, j, itu1) + ww2(i, j, irho)*ww2d(&
&         i, j, itu1)
        rhok = ww2(i, j, irho)*ww2(i, j, itu1)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1d(i, j, irho) = ww2d(i, j, irho)
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1d(i, j, ivx) = -ww2d(i, j, ivx)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1d(i, j, ivy) = -ww2d(i, j, ivy)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1d(i, j, ivz) = -ww2d(i, j, ivz)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1d(i, j) = rlv2d(i, j)
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) then
        rev1d(i, j) = -rev2d(i, j)
        rev1(i, j) = -rev2(i, j)
      end if
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1d(i, j) = pp2d(i, j) - four*third*rhokd
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
        pp1d(i, j) = 2*pp2d(i, j)
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) then
          pp1d(i, j) = pp2d(i, j)
          pp1(i, j) = pp2(i, j)
        end if
      end select
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcnswalladiabatic_d
  subroutine bcnswalladiabatic(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous adiabatic wall boundary
! condition the pointers already defined.
    use constants
    use blockpointers, only : bcdata
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_d, only : ww0, ww1, ww2, rlv0, rlv1, rlv2, pp0, pp1, &
&   pp2, pp3, rev0, rev1, rev2, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    use iteration, only : currentlevel, groundlevel
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    integer(kind=inttype) :: walltreatment
    intrinsic mod
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) pp1(i, j) = pp2(i, j)
      end select
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswalladiabatic
!  differentiation of bcnswallisothermal in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: rgas *rev0 *rev1 *rev2 *pp0
!                *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2 *(*bcdata.tns_wall)
!   rw status of diff variables: rgas:in *rev0:in-out *rev1:in-out
!                *rev2:in *pp0:in-out *pp1:in-out *pp2:in *rlv0:in-out
!                *rlv1:in-out *rlv2:in *ww0:in-out *ww1:in-out
!                *ww2:in *(*bcdata.tns_wall):in
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in bcdata:in *bcdata.tns_wall:in
  subroutine bcnswallisothermal_d(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous isothermal wall boundary
! condition to a block. it is assumed that the bcpointers are
! already set
    use constants
    use blockpointers, only : bcdata, bcdatad
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, rlv0, &
&   rlv0d, rlv1, rlv1d, rlv2, rlv2d, pp0, pp0d, pp1, pp1d, pp2, pp2d, &
&   pp3, pp3d, rev0, rev0d, rev1, rev1d, rev2, rev2d, istart, jstart, &
&   isize, jsize
    use flowvarrefstate, only : viscous, eddymodel, rgas, rgasd
    use iteration, only : currentlevel, groundlevel
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: rhok, t2, t1
    real(kind=realtype) :: rhokd, t2d, t1d
    intrinsic mod
    intrinsic max
    intrinsic min
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
    rhokd = 0.0_8
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        rhokd = ww2d(i, j, irho)*ww2(i, j, itu1) + ww2(i, j, irho)*ww2d(&
&         i, j, itu1)
        rhok = ww2(i, j, irho)*ww2(i, j, itu1)
      end if
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2d = (pp2d(i, j)*rgas*ww2(i, j, irho)-pp2(i, j)*(rgasd*ww2(i, j, &
&       irho)+rgas*ww2d(i, j, irho)))/(rgas*ww2(i, j, irho))**2
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1d = two*bcdatad(nn)%tns_wall(i, j) - t2d
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1d = half*bcdatad(nn)%tns_wall(i, j)
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1d = two*bcdatad(nn)%tns_wall(i, j)
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! pressure extrapolation
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1d(i, j) = pp2d(i, j) - four*third*rhokd
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
! linear extrapolation.
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        pp1d(i, j) = 2*pp2d(i, j)
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) then
          pp1d(i, j) = pp2d(i, j)
          pp1(i, j) = pp2(i, j)
        end if
      end select
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1d(i, j, irho) = (pp1d(i, j)*rgas*t1-pp1(i, j)*(rgasd*t1+rgas*&
&       t1d))/(rgas*t1)**2
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1d(i, j, ivx) = -ww2d(i, j, ivx)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1d(i, j, ivy) = -ww2d(i, j, ivy)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1d(i, j, ivz) = -ww2d(i, j, ivz)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1d(i, j) = rlv2d(i, j)
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) then
        rev1d(i, j) = -rev2d(i, j)
        rev1(i, j) = -rev2(i, j)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcnswallisothermal_d
  subroutine bcnswallisothermal(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous isothermal wall boundary
! condition to a block. it is assumed that the bcpointers are
! already set
    use constants
    use blockpointers, only : bcdata
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_d, only : ww0, ww1, ww2, rlv0, rlv1, rlv2, pp0, pp1, &
&   pp2, pp3, rev0, rev1, rev2, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel, rgas
    use iteration, only : currentlevel, groundlevel
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: rhok, t2, t1
    intrinsic mod
    intrinsic max
    intrinsic min
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! pressure extrapolation
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
! linear extrapolation.
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) pp1(i, j) = pp2(i, j)
      end select
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswallisothermal
!  differentiation of bcsubsonicoutflow in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2 *(*bcdata.norm)
!                *(*bcdata.ps)
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:in
!                *pp0:in-out *pp1:in-out *pp2:in *rlv0:in-out *rlv1:in-out
!                *rlv2:in *ww0:in-out *ww1:in-out *ww2:in *(*bcdata.norm):in
!                *(*bcdata.ps):in
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in bcdata:in *bcdata.norm:in *bcdata.ps:in
  subroutine bcsubsonicoutflow_d(nn, secondhalo, correctfork)
!  bcsubsonicoutflow applies the subsonic outflow boundary
!  condition, static pressure prescribed, to a block. it is
!  assumed that the pointers in blockpointers are already set to
!  the correct block on the correct grid level.  exactly the same
!  boundary condition is also applied for an outflow mass
!  bleed. therefore the test is for both a subsonic outflow and an
!  bleed outflow.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, rlv0, rlv0d, rlv1, rlv1d, rlv2, rlv2d, rev0, &
&   rev0d, rev1, rev1d, rev2, rev2d, gamma2, isize, jsize, istart, &
&   jstart
    use flowvarrefstate, only : eddymodel, viscous
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype) :: ovg, ovgm1, nnx, nny, nnz
    real(kind=realtype) :: nnxd, nnyd, nnzd
    real(kind=realtype) :: pexit, pint, r, a2, a, ac, ss
    real(kind=realtype) :: pexitd, pintd, rd, a2d, ad, acd, ssd
    real(kind=realtype) :: ue, ve, we, qne, qnh
    real(kind=realtype) :: ued, ved, wed, qned, qnhd
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwr1d
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: pwx1d
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! store a couple of variables, such as the static
! pressure and grid unit outward normal, a bit easier.
      pexitd = bcdatad(nn)%ps(i, j)
      pexit = bcdata(nn)%ps(i, j)
      nnxd = bcdatad(nn)%norm(i, j, 1)
      nnx = bcdata(nn)%norm(i, j, 1)
      nnyd = bcdatad(nn)%norm(i, j, 2)
      nny = bcdata(nn)%norm(i, j, 2)
      nnzd = bcdatad(nn)%norm(i, j, 3)
      nnz = bcdata(nn)%norm(i, j, 3)
! abbreviate 1/gamma and 1/(gamma -1) a bit easier.
      ovg = one/gamma2(i, j)
      ovgm1 = one/(gamma2(i, j)-one)
! store the internal pressure and correct for the
! possible presence of a k-equation.
      pintd = pp2d(i, j)
      pint = pp2(i, j)
      if (correctfork) then
        pintd = pintd - twothird*(ww2d(i, j, irho)*ww2(i, j, itu1)+ww2(i&
&         , j, irho)*ww2d(i, j, itu1))
        pint = pint - twothird*ww2(i, j, irho)*ww2(i, j, itu1)
      end if
! compute the velocity components, the normal velocity
! and the speed of sound for the internal cell.
      rd = -(one*ww2d(i, j, irho)/ww2(i, j, irho)**2)
      r = one/ww2(i, j, irho)
      a2d = gamma2(i, j)*(pintd*r+pint*rd)
      a2 = gamma2(i, j)*pint*r
      if (a2 .eq. 0.0_8) then
        ad = 0.0_8
      else
        ad = a2d/(2.0*sqrt(a2))
      end if
      a = sqrt(a2)
      ued = ww2d(i, j, ivx)
      ue = ww2(i, j, ivx)
      ved = ww2d(i, j, ivy)
      ve = ww2(i, j, ivy)
      wed = ww2d(i, j, ivz)
      we = ww2(i, j, ivz)
      qned = ued*nnx + ue*nnxd + ved*nny + ve*nnyd + wed*nnz + we*nnzd
      qne = ue*nnx + ve*nny + we*nnz
! compute the entropy and the acoustic variable.
! these riemann invariants, as well as the tangential
! velocity components, are extrapolated.
      if (r .gt. 0.0_8 .or. (r .lt. 0.0_8 .and. gamma2(i, j) .eq. int(&
&         gamma2(i, j)))) then
        pwr1d = gamma2(i, j)*r**(gamma2(i, j)-1)*rd
      else if (r .eq. 0.0_8 .and. gamma2(i, j) .eq. 1.0) then
        pwr1d = rd
      else
        pwr1d = 0.0_8
      end if
      pwr1 = r**gamma2(i, j)
      ssd = pintd*pwr1 + pint*pwr1d
      ss = pint*pwr1
      acd = qned + two*ovgm1*ad
      ac = qne + two*a*ovgm1
! compute the state in the halo.
      pwx1d = (pexitd*ss-pexit*ssd)/ss**2
      pwx1 = pexit/ss
      if (pwx1 .gt. 0.0_8 .or. (pwx1 .lt. 0.0_8 .and. ovg .eq. int(ovg))&
&     ) then
        ww1d(i, j, irho) = ovg*pwx1**(ovg-1)*pwx1d
      else if (pwx1 .eq. 0.0_8 .and. ovg .eq. 1.0) then
        ww1d(i, j, irho) = pwx1d
      else
        ww1d(i, j, irho) = 0.0_8
      end if
      ww1(i, j, irho) = pwx1**ovg
      pp1d(i, j) = pexitd
      pp1(i, j) = pexit
      arg1d = (gamma2(i, j)*pexitd*ww1(i, j, irho)-gamma2(i, j)*pexit*&
&       ww1d(i, j, irho))/ww1(i, j, irho)**2
      arg1 = gamma2(i, j)*pexit/ww1(i, j, irho)
      if (arg1 .eq. 0.0_8) then
        ad = 0.0_8
      else
        ad = arg1d/(2.0*sqrt(arg1))
      end if
      a = sqrt(arg1)
      qnhd = acd - two*ovgm1*ad
      qnh = ac - two*a*ovgm1
      ww1d(i, j, ivx) = ued + (qnhd-qned)*nnx + (qnh-qne)*nnxd
      ww1(i, j, ivx) = ue + (qnh-qne)*nnx
      ww1d(i, j, ivy) = ved + (qnhd-qned)*nny + (qnh-qne)*nnyd
      ww1(i, j, ivy) = ve + (qnh-qne)*nny
      ww1d(i, j, ivz) = wed + (qnhd-qned)*nnz + (qnh-qne)*nnzd
      ww1(i, j, ivz) = we + (qnh-qne)*nnz
! correct the pressure if a k-equation is present.
      if (correctfork) then
        pp1d(i, j) = pp1d(i, j) + twothird*(ww1d(i, j, irho)*ww1(i, j, &
&         itu1)+ww1(i, j, irho)*ww1d(i, j, itu1))
        pp1(i, j) = pp1(i, j) + twothird*ww1(i, j, irho)*ww1(i, j, itu1)
      end if
! set the viscosities in the halo to the viscosities
! in the donor cell.
      if (viscous) then
        rlv1d(i, j) = rlv2d(i, j)
        rlv1(i, j) = rlv2(i, j)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev2d(i, j)
        rev1(i, j) = rev2(i, j)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcsubsonicoutflow_d
  subroutine bcsubsonicoutflow(nn, secondhalo, correctfork)
!  bcsubsonicoutflow applies the subsonic outflow boundary
!  condition, static pressure prescribed, to a block. it is
!  assumed that the pointers in blockpointers are already set to
!  the correct block on the correct grid level.  exactly the same
!  boundary condition is also applied for an outflow mass
!  bleed. therefore the test is for both a subsonic outflow and an
!  bleed outflow.
    use constants
    use blockpointers, only : bcdata
    use bcpointers_d, only : ww0, ww1, ww2, pp0, pp1, pp2, rlv0, rlv1, &
&   rlv2, rev0, rev1, rev2, gamma2, isize, jsize, istart, jstart
    use flowvarrefstate, only : eddymodel, viscous
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype) :: ovg, ovgm1, nnx, nny, nnz
    real(kind=realtype) :: pexit, pint, r, a2, a, ac, ss
    real(kind=realtype) :: ue, ve, we, qne, qnh
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: arg1
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! store a couple of variables, such as the static
! pressure and grid unit outward normal, a bit easier.
      pexit = bcdata(nn)%ps(i, j)
      nnx = bcdata(nn)%norm(i, j, 1)
      nny = bcdata(nn)%norm(i, j, 2)
      nnz = bcdata(nn)%norm(i, j, 3)
! abbreviate 1/gamma and 1/(gamma -1) a bit easier.
      ovg = one/gamma2(i, j)
      ovgm1 = one/(gamma2(i, j)-one)
! store the internal pressure and correct for the
! possible presence of a k-equation.
      pint = pp2(i, j)
      if (correctfork) pint = pint - twothird*ww2(i, j, irho)*ww2(i, j, &
&         itu1)
! compute the velocity components, the normal velocity
! and the speed of sound for the internal cell.
      r = one/ww2(i, j, irho)
      a2 = gamma2(i, j)*pint*r
      a = sqrt(a2)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*nnx + ve*nny + we*nnz
! compute the entropy and the acoustic variable.
! these riemann invariants, as well as the tangential
! velocity components, are extrapolated.
      pwr1 = r**gamma2(i, j)
      ss = pint*pwr1
      ac = qne + two*a*ovgm1
! compute the state in the halo.
      pwx1 = pexit/ss
      ww1(i, j, irho) = pwx1**ovg
      pp1(i, j) = pexit
      arg1 = gamma2(i, j)*pexit/ww1(i, j, irho)
      a = sqrt(arg1)
      qnh = ac - two*a*ovgm1
      ww1(i, j, ivx) = ue + (qnh-qne)*nnx
      ww1(i, j, ivy) = ve + (qnh-qne)*nny
      ww1(i, j, ivz) = we + (qnh-qne)*nnz
! correct the pressure if a k-equation is present.
      if (correctfork) pp1(i, j) = pp1(i, j) + twothird*ww1(i, j, irho)*&
&         ww1(i, j, itu1)
! set the viscosities in the halo to the viscosities
! in the donor cell.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcsubsonicoutflow
!  differentiation of bcsubsonicinflow in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2 *(*bcdata.norm)
!                *(*bcdata.ptinlet) *(*bcdata.ttinlet) *(*bcdata.htinlet)
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:in
!                *pp0:in-out *pp1:in-out *pp2:in *rlv0:in-out *rlv1:in-out
!                *rlv2:in *ww0:in-out *ww1:in-out *ww2:in *(*bcdata.norm):in
!                *(*bcdata.ptinlet):in *(*bcdata.ttinlet):in *(*bcdata.htinlet):in
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in bcdata:in *bcdata.norm:in *bcdata.ptinlet:in
!                *bcdata.ttinlet:in *bcdata.htinlet:in
  subroutine bcsubsonicinflow_d(nn, secondhalo, correctfork)
!  bcsubsonicinflow applies the subsonic outflow boundary
!  condition, total pressure, total density and flow direction
!  prescribed, to a block. it is assumed that the pointers in
!  blockpointers are already set to the correct block on the
!  correct grid level.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use flowvarrefstate, only : viscous, eddymodel, rgas, rgasd
    use inputdiscretization, only : hscalinginlet
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, rlv0, rlv0d, rlv1, rlv1d, rlv2, rlv2d, rev0, &
&   rev0d, rev1, rev1d, rev2, rev2d, gamma2, isize, jsize, istart, &
&   jstart
    use inputphysics, only : cpmodel, gammaconstant
    use utils_d, only : terminate
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype) :: gm1, ovgm1
    real(kind=realtype) :: ptot, ttot, htot, a2tot, r, alpha, beta
    real(kind=realtype) :: ptotd, ttotd, htotd, a2totd, rd, alphad, &
&   betad
    real(kind=realtype) :: aa2, bb, cc, dd, q, q2, a2, m2, scalefact
    real(kind=realtype) :: aa2d, bbd, ccd, ddd, qd, q2d, a2d, m2d, &
&   scalefactd
    real(kind=realtype) :: ssx, ssy, ssz, nnx, nny, nnz
    real(kind=realtype) :: nnxd, nnyd, nnzd
    real(kind=realtype) :: rho, velx, vely, velz, ratio, ts, govgm1
    real(kind=realtype) :: ratiod, tsd
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic min
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: pwx1d
    real(kind=realtype) :: max1d
    real(kind=realtype) :: max1
! determine the boundary treatment to be used.
    govgm1 = gammaconstant/(gammaconstant-one)
    select case  (bcdata(nn)%subsonicinlettreatment) 
    case (totalconditions) 
! the total conditions have been prescribed.
! loop over the generic subface to set the state in the
! halo cells.
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store a couple of variables, such as the total
! pressure, total temperature, total enthalpy, flow
! direction and grid unit outward normal, a bit easier.
        ptotd = bcdatad(nn)%ptinlet(i, j)
        ptot = bcdata(nn)%ptinlet(i, j)
        ttotd = bcdatad(nn)%ttinlet(i, j)
        ttot = bcdata(nn)%ttinlet(i, j)
        htotd = bcdatad(nn)%htinlet(i, j)
        htot = bcdata(nn)%htinlet(i, j)
        ssx = bcdata(nn)%flowxdirinlet(i, j)
        ssy = bcdata(nn)%flowydirinlet(i, j)
        ssz = bcdata(nn)%flowzdirinlet(i, j)
        nnxd = bcdatad(nn)%norm(i, j, 1)
        nnx = bcdata(nn)%norm(i, j, 1)
        nnyd = bcdatad(nn)%norm(i, j, 2)
        nny = bcdata(nn)%norm(i, j, 2)
        nnzd = bcdatad(nn)%norm(i, j, 3)
        nnz = bcdata(nn)%norm(i, j, 3)
! some abbreviations in which gamma occurs.
        gm1 = gamma2(i, j) - one
        ovgm1 = one/gm1
! determine the acoustic riemann variable that must be
! extrapolated from the domain.
        rd = -(one*ww2d(i, j, irho)/ww2(i, j, irho)**2)
        r = one/ww2(i, j, irho)
        a2d = gamma2(i, j)*(pp2d(i, j)*r+pp2(i, j)*rd)
        a2 = gamma2(i, j)*pp2(i, j)*r
        if (a2 .eq. 0.0_8) then
          result1d = 0.0_8
        else
          result1d = a2d/(2.0*sqrt(a2))
        end if
        result1 = sqrt(a2)
        betad = ww2d(i, j, ivx)*nnx + ww2(i, j, ivx)*nnxd + ww2d(i, j, &
&         ivy)*nny + ww2(i, j, ivy)*nnyd + ww2d(i, j, ivz)*nnz + ww2(i, &
&         j, ivz)*nnzd + two*ovgm1*result1d
        beta = ww2(i, j, ivx)*nnx + ww2(i, j, ivy)*nny + ww2(i, j, ivz)*&
&         nnz + two*ovgm1*result1
! correct the value of the riemann invariant if total
! enthalpy scaling must be applied. this scaling may
! be needed for stability if large gradients of the
! total temperature are prescribed.
        scalefact = one
        if (hscalinginlet) then
          arg1d = (htotd*r*(ww2(i, j, irhoe)+pp2(i, j))-htot*(rd*(ww2(i&
&           , j, irhoe)+pp2(i, j))+r*(ww2d(i, j, irhoe)+pp2d(i, j))))/(r&
&           *(ww2(i, j, irhoe)+pp2(i, j)))**2
          arg1 = htot/(r*(ww2(i, j, irhoe)+pp2(i, j)))
          if (arg1 .eq. 0.0_8) then
            scalefactd = 0.0_8
          else
            scalefactd = arg1d/(2.0*sqrt(arg1))
          end if
          scalefact = sqrt(arg1)
        else
          scalefactd = 0.0_8
        end if
        betad = betad*scalefact + beta*scalefactd
        beta = beta*scalefact
! compute the value of a2 + 0.5*gm1*q2, which is the
! total speed of sound for constant cp. however, the
! expression below is also valid for variable cp,
! although a linearization around the value of the
! internal cell is performed.
        q2d = 2*ww2(i, j, ivx)*ww2d(i, j, ivx) + 2*ww2(i, j, ivy)*ww2d(i&
&         , j, ivy) + 2*ww2(i, j, ivz)*ww2d(i, j, ivz)
        q2 = ww2(i, j, ivx)**2 + ww2(i, j, ivy)**2 + ww2(i, j, ivz)**2
        a2totd = gm1*(htotd-rd*(ww2(i, j, irhoe)+pp2(i, j))-r*(ww2d(i, j&
&         , irhoe)+pp2d(i, j))+half*q2d) + a2d
        a2tot = gm1*(htot-r*(ww2(i, j, irhoe)+pp2(i, j))+half*q2) + a2
! compute the dot product between the normal and the
! velocity direction. this value should be negative.
        alphad = ssx*nnxd + ssy*nnyd + ssz*nnzd
        alpha = nnx*ssx + nny*ssy + nnz*ssz
! compute the coefficients in the quadratic equation
! for the magnitude of the velocity.
        aa2d = half*gm1*(alphad*alpha+alpha*alphad)
        aa2 = half*gm1*alpha*alpha + one
        bbd = -(gm1*(alphad*beta+alpha*betad))
        bb = -(gm1*alpha*beta)
        ccd = half*gm1*(betad*beta+beta*betad) - two*ovgm1*a2totd
        cc = half*gm1*beta*beta - two*ovgm1*a2tot
! solve the equation for the magnitude of the
! velocity. as this value must be positive and both aa2
! and bb are positive (alpha is negative and beta is
! positive up till mach = 5.0 or so, which is not
! really subsonic anymore), it is clear which of the
! two possible solutions must be taken. some clipping
! is present, but this is normally not active.
        ddd = bbd*bb + bb*bbd - four*(aa2d*cc+aa2*ccd)
        dd = bb*bb - four*aa2*cc
        if (zero .lt. dd) then
          max1d = ddd
          max1 = dd
        else
          max1 = zero
          max1d = 0.0_8
        end if
        if (max1 .eq. 0.0_8) then
          ddd = 0.0_8
        else
          ddd = max1d/(2.0*sqrt(max1))
        end if
        dd = sqrt(max1)
        qd = ((ddd-bbd)*two*aa2-(-bb+dd)*two*aa2d)/(two*aa2)**2
        q = (-bb+dd)/(two*aa2)
        if (zero .lt. q) then
          q = q
        else
          q = zero
          qd = 0.0_8
        end if
        q2d = qd*q + q*qd
        q2 = q*q
! compute the speed of sound squared from the total
! speed of sound equation (== total enthalpy equation
! for constant cp).
        a2d = a2totd - half*gm1*q2d
        a2 = a2tot - half*gm1*q2
! compute the mach number squared and cut it between
! 0.0 and 1.0. adapt the velocity and speed of sound
! squared accordingly.
        m2d = (q2d*a2-q2*a2d)/a2**2
        m2 = q2/a2
        if (one .gt. m2) then
          m2 = m2
        else
          m2 = one
          m2d = 0.0_8
        end if
        q2d = m2d*a2 + m2*a2d
        q2 = m2*a2
        if (q2 .eq. 0.0_8) then
          qd = 0.0_8
        else
          qd = q2d/(2.0*sqrt(q2))
        end if
        q = sqrt(q2)
        a2d = a2totd - half*gm1*q2d
        a2 = a2tot - half*gm1*q2
! compute the velocities in the halo cell and use rho,
! rhoe and p as temporary buffers to store the total
! temperature, total pressure and static temperature.
        ww1d(i, j, ivx) = ssx*qd
        ww1(i, j, ivx) = q*ssx
        ww1d(i, j, ivy) = ssy*qd
        ww1(i, j, ivy) = q*ssy
        ww1d(i, j, ivz) = ssz*qd
        ww1(i, j, ivz) = q*ssz
! this should call prhosubsonicinlet, but it doesnt' ad
! correctly, so just the constant cp model is used here.
! compute the pressure and density for these halo's.
        select case  (cpmodel) 
        case (cpconstant) 
! compute the static pressure from the total pressure
! and the temperature ratio. compute the density using
! the gas law.
          tsd = a2d/(gamma2(i, j)*rgas)
          ts = a2/(gamma2(i, j)*rgas)
          pwx1d = (tsd*ttot-ts*ttotd)/ttot**2
          pwx1 = ts/ttot
          if (pwx1 .gt. 0.0_8 .or. (pwx1 .lt. 0.0_8 .and. govgm1 .eq. &
&             int(govgm1))) then
            ratiod = govgm1*pwx1**(govgm1-1)*pwx1d
          else if (pwx1 .eq. 0.0_8 .and. govgm1 .eq. 1.0) then
            ratiod = pwx1d
          else
            ratiod = 0.0_8
          end if
          ratio = pwx1**govgm1
          pp1d(i, j) = ptotd*ratio + ptot*ratiod
          pp1(i, j) = ptot*ratio
          ww1d(i, j, irho) = ((ptotd*ratio+ptot*ratiod)*rgas*ts-ptot*&
&           ratio*rgas*tsd)/(rgas*ts)**2
          ww1(i, j, irho) = ptot*ratio/(rgas*ts)
          if (correctfork) then
            pp1d(i, j) = pp1d(i, j) + twothird*(ww1d(i, j, irho)*ww1(i, &
&             j, itu1)+ww1(i, j, irho)*ww1d(i, j, itu1))
            pp1(i, j) = pp1(i, j) + twothird*ww1(i, j, irho)*ww1(i, j, &
&             itu1)
          end if
        case (cptempcurvefits) 
          call terminate('bcroutines', 'not curve fits not implemented')
        end select
! set the viscosities in the halo to the viscosities
! in the donor cell.
        if (viscous) then
          rlv1d(i, j) = rlv2d(i, j)
          rlv1(i, j) = rlv2(i, j)
        end if
        if (eddymodel) then
          rev1d(i, j) = rev2d(i, j)
          rev1(i, j) = rev2(i, j)
        end if
      end do
    case (massflow) 
!===========================================================
! density and velocity vector prescribed.
! loop over the generic subface to set the state in the
! halo cells.
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store a couple of variables, such as the density,
! velocity and grid unit outward normal, a bit easier.
        rho = bcdata(nn)%rho(i, j)
        velx = bcdata(nn)%velx(i, j)
        vely = bcdata(nn)%vely(i, j)
        velz = bcdata(nn)%velz(i, j)
        nnxd = bcdatad(nn)%norm(i, j, 1)
        nnx = bcdata(nn)%norm(i, j, 1)
        nnyd = bcdatad(nn)%norm(i, j, 2)
        nny = bcdata(nn)%norm(i, j, 2)
        nnzd = bcdatad(nn)%norm(i, j, 3)
        nnz = bcdata(nn)%norm(i, j, 3)
! some abbreviations in which gamma occurs.
        gm1 = gamma2(i, j) - one
        ovgm1 = one/gm1
! determine the acoustic riemann variable that must be
! extrapolated from the domain.
        rd = -(one*ww2d(i, j, irho)/ww2(i, j, irho)**2)
        r = one/ww2(i, j, irho)
        a2d = gamma2(i, j)*(pp2d(i, j)*r+pp2(i, j)*rd)
        a2 = gamma2(i, j)*pp2(i, j)*r
        if (a2 .eq. 0.0_8) then
          result1d = 0.0_8
        else
          result1d = a2d/(2.0*sqrt(a2))
        end if
        result1 = sqrt(a2)
        betad = ww2d(i, j, ivx)*nnx + ww2(i, j, ivx)*nnxd + ww2d(i, j, &
&         ivy)*nny + ww2(i, j, ivy)*nnyd + ww2d(i, j, ivz)*nnz + ww2(i, &
&         j, ivz)*nnzd + two*ovgm1*result1d
        beta = ww2(i, j, ivx)*nnx + ww2(i, j, ivy)*nny + ww2(i, j, ivz)*&
&         nnz + two*ovgm1*result1
! compute the speed of sound squared in the halo.
        a2d = half*gm1*(betad-velx*nnxd-vely*nnyd-velz*nnzd)
        a2 = half*gm1*(beta-velx*nnx-vely*nny-velz*nnz)
        if (zero .lt. a2) then
          a2 = a2
        else
          a2 = zero
          a2d = 0.0_8
        end if
        a2d = a2d*a2 + a2*a2d
        a2 = a2*a2
! compute the pressure in the halo, assuming a
! constant value of gamma.
        pp1d(i, j) = rho*a2d/gamma2(i, j)
        pp1(i, j) = rho*a2/gamma2(i, j)
! simply copy the density and velocities.
        ww1d(i, j, irho) = 0.0_8
        ww1(i, j, irho) = rho
        ww1d(i, j, ivx) = 0.0_8
        ww1(i, j, ivx) = velx
        ww1d(i, j, ivy) = 0.0_8
        ww1(i, j, ivy) = vely
        ww1d(i, j, ivz) = 0.0_8
        ww1(i, j, ivz) = velz
! set the viscosities in the halo to the viscosities
! in the donor cell.
        if (viscous) then
          rlv1d(i, j) = rlv2d(i, j)
          rlv1(i, j) = rlv2(i, j)
        end if
        if (eddymodel) then
          rev1d(i, j) = rev2d(i, j)
          rev1(i, j) = rev2(i, j)
        end if
      end do
    end select
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcsubsonicinflow_d
  subroutine bcsubsonicinflow(nn, secondhalo, correctfork)
!  bcsubsonicinflow applies the subsonic outflow boundary
!  condition, total pressure, total density and flow direction
!  prescribed, to a block. it is assumed that the pointers in
!  blockpointers are already set to the correct block on the
!  correct grid level.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : viscous, eddymodel, rgas
    use inputdiscretization, only : hscalinginlet
    use bcpointers_d, only : ww0, ww1, ww2, pp0, pp1, pp2, rlv0, rlv1, &
&   rlv2, rev0, rev1, rev2, gamma2, isize, jsize, istart, jstart
    use inputphysics, only : cpmodel, gammaconstant
    use utils_d, only : terminate
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype) :: gm1, ovgm1
    real(kind=realtype) :: ptot, ttot, htot, a2tot, r, alpha, beta
    real(kind=realtype) :: aa2, bb, cc, dd, q, q2, a2, m2, scalefact
    real(kind=realtype) :: ssx, ssy, ssz, nnx, nny, nnz
    real(kind=realtype) :: rho, velx, vely, velz, ratio, ts, govgm1
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic min
    real(kind=realtype) :: result1
    real(kind=realtype) :: arg1
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: max1
! determine the boundary treatment to be used.
    govgm1 = gammaconstant/(gammaconstant-one)
    select case  (bcdata(nn)%subsonicinlettreatment) 
    case (totalconditions) 
! the total conditions have been prescribed.
! loop over the generic subface to set the state in the
! halo cells.
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store a couple of variables, such as the total
! pressure, total temperature, total enthalpy, flow
! direction and grid unit outward normal, a bit easier.
        ptot = bcdata(nn)%ptinlet(i, j)
        ttot = bcdata(nn)%ttinlet(i, j)
        htot = bcdata(nn)%htinlet(i, j)
        ssx = bcdata(nn)%flowxdirinlet(i, j)
        ssy = bcdata(nn)%flowydirinlet(i, j)
        ssz = bcdata(nn)%flowzdirinlet(i, j)
        nnx = bcdata(nn)%norm(i, j, 1)
        nny = bcdata(nn)%norm(i, j, 2)
        nnz = bcdata(nn)%norm(i, j, 3)
! some abbreviations in which gamma occurs.
        gm1 = gamma2(i, j) - one
        ovgm1 = one/gm1
! determine the acoustic riemann variable that must be
! extrapolated from the domain.
        r = one/ww2(i, j, irho)
        a2 = gamma2(i, j)*pp2(i, j)*r
        result1 = sqrt(a2)
        beta = ww2(i, j, ivx)*nnx + ww2(i, j, ivy)*nny + ww2(i, j, ivz)*&
&         nnz + two*ovgm1*result1
! correct the value of the riemann invariant if total
! enthalpy scaling must be applied. this scaling may
! be needed for stability if large gradients of the
! total temperature are prescribed.
        scalefact = one
        if (hscalinginlet) then
          arg1 = htot/(r*(ww2(i, j, irhoe)+pp2(i, j)))
          scalefact = sqrt(arg1)
        end if
        beta = beta*scalefact
! compute the value of a2 + 0.5*gm1*q2, which is the
! total speed of sound for constant cp. however, the
! expression below is also valid for variable cp,
! although a linearization around the value of the
! internal cell is performed.
        q2 = ww2(i, j, ivx)**2 + ww2(i, j, ivy)**2 + ww2(i, j, ivz)**2
        a2tot = gm1*(htot-r*(ww2(i, j, irhoe)+pp2(i, j))+half*q2) + a2
! compute the dot product between the normal and the
! velocity direction. this value should be negative.
        alpha = nnx*ssx + nny*ssy + nnz*ssz
! compute the coefficients in the quadratic equation
! for the magnitude of the velocity.
        aa2 = half*gm1*alpha*alpha + one
        bb = -(gm1*alpha*beta)
        cc = half*gm1*beta*beta - two*ovgm1*a2tot
! solve the equation for the magnitude of the
! velocity. as this value must be positive and both aa2
! and bb are positive (alpha is negative and beta is
! positive up till mach = 5.0 or so, which is not
! really subsonic anymore), it is clear which of the
! two possible solutions must be taken. some clipping
! is present, but this is normally not active.
        dd = bb*bb - four*aa2*cc
        if (zero .lt. dd) then
          max1 = dd
        else
          max1 = zero
        end if
        dd = sqrt(max1)
        q = (-bb+dd)/(two*aa2)
        if (zero .lt. q) then
          q = q
        else
          q = zero
        end if
        q2 = q*q
! compute the speed of sound squared from the total
! speed of sound equation (== total enthalpy equation
! for constant cp).
        a2 = a2tot - half*gm1*q2
! compute the mach number squared and cut it between
! 0.0 and 1.0. adapt the velocity and speed of sound
! squared accordingly.
        m2 = q2/a2
        if (one .gt. m2) then
          m2 = m2
        else
          m2 = one
        end if
        q2 = m2*a2
        q = sqrt(q2)
        a2 = a2tot - half*gm1*q2
! compute the velocities in the halo cell and use rho,
! rhoe and p as temporary buffers to store the total
! temperature, total pressure and static temperature.
        ww1(i, j, ivx) = q*ssx
        ww1(i, j, ivy) = q*ssy
        ww1(i, j, ivz) = q*ssz
! this should call prhosubsonicinlet, but it doesnt' ad
! correctly, so just the constant cp model is used here.
! compute the pressure and density for these halo's.
        select case  (cpmodel) 
        case (cpconstant) 
! compute the static pressure from the total pressure
! and the temperature ratio. compute the density using
! the gas law.
          ts = a2/(gamma2(i, j)*rgas)
          pwx1 = ts/ttot
          ratio = pwx1**govgm1
          pp1(i, j) = ptot*ratio
          ww1(i, j, irho) = ptot*ratio/(rgas*ts)
          if (correctfork) pp1(i, j) = pp1(i, j) + twothird*ww1(i, j, &
&             irho)*ww1(i, j, itu1)
        case (cptempcurvefits) 
          call terminate('bcroutines', 'not curve fits not implemented')
        end select
! set the viscosities in the halo to the viscosities
! in the donor cell.
        if (viscous) rlv1(i, j) = rlv2(i, j)
        if (eddymodel) rev1(i, j) = rev2(i, j)
      end do
    case (massflow) 
!===========================================================
! density and velocity vector prescribed.
! loop over the generic subface to set the state in the
! halo cells.
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store a couple of variables, such as the density,
! velocity and grid unit outward normal, a bit easier.
        rho = bcdata(nn)%rho(i, j)
        velx = bcdata(nn)%velx(i, j)
        vely = bcdata(nn)%vely(i, j)
        velz = bcdata(nn)%velz(i, j)
        nnx = bcdata(nn)%norm(i, j, 1)
        nny = bcdata(nn)%norm(i, j, 2)
        nnz = bcdata(nn)%norm(i, j, 3)
! some abbreviations in which gamma occurs.
        gm1 = gamma2(i, j) - one
        ovgm1 = one/gm1
! determine the acoustic riemann variable that must be
! extrapolated from the domain.
        r = one/ww2(i, j, irho)
        a2 = gamma2(i, j)*pp2(i, j)*r
        result1 = sqrt(a2)
        beta = ww2(i, j, ivx)*nnx + ww2(i, j, ivy)*nny + ww2(i, j, ivz)*&
&         nnz + two*ovgm1*result1
! compute the speed of sound squared in the halo.
        a2 = half*gm1*(beta-velx*nnx-vely*nny-velz*nnz)
        if (zero .lt. a2) then
          a2 = a2
        else
          a2 = zero
        end if
        a2 = a2*a2
! compute the pressure in the halo, assuming a
! constant value of gamma.
        pp1(i, j) = rho*a2/gamma2(i, j)
! simply copy the density and velocities.
        ww1(i, j, irho) = rho
        ww1(i, j, ivx) = velx
        ww1(i, j, ivy) = vely
        ww1(i, j, ivz) = velz
! set the viscosities in the halo to the viscosities
! in the donor cell.
        if (viscous) rlv1(i, j) = rlv2(i, j)
        if (eddymodel) rev1(i, j) = rev2(i, j)
      end do
    end select
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcsubsonicinflow
!  differentiation of bceulerwall in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ss *ssi *ssj *ssk
!                *ww0 *ww1 *ww2 *(*bcdata.norm)
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:in
!                *pp0:in-out *pp1:in-out *pp2:in *pp3:in *rlv0:in-out
!                *rlv1:in-out *rlv2:in *ss:in *ssi:in *ssj:in *ssk:in
!                *ww0:in-out *ww1:in-out *ww2:in *(*bcdata.norm):in
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in pp3:in rlv0:in rlv1:in rlv2:in ss:in
!                ssi:in ssj:in ssk:in ww0:in ww1:in ww2:in bcdata:in
!                *bcdata.norm:in
  subroutine bceulerwall_d(nn, secondhalo, correctfork)
!  bceulerwall applies the inviscid wall boundary condition to a
!  block. it is assumed that the bcpointers are already set to the
!  correct block on the correct grid level.
    use constants
    use blockpointers, only : bcdata, bcdatad, addgridvelocities
    use flowvarrefstate, only : viscous, eddymodel, rgas, rgasd
    use inputdiscretization, only : eulerwallbctreatment
    use iteration, only : currentlevel, groundlevel
    use utils_d, only : mydim, mydim_d
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, pp3, pp3d, rlv0, rlv0d, rlv1, rlv1d, rlv2, &
&   rlv2d, rev0, rev0d, rev1, rev1d, rev2, rev2d, ss, ssd, ssi, ssid, &
&   ssj, ssjd, ssk, sskd, istart, isize, jstart, jsize, iend, jend
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: sixad, siyad, sizad, sjxad, sjyad, sjzad
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: skxad, skyad, skzad
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: rxjd, ryjd, rzjd, rxkd, rykd, rzkd
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: dpjd, dpkd, rid, rjd, rkd, qjd, qkd, vnd
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype) :: uuxd, uuyd, uuzd
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: gradd
    intrinsic mod
    intrinsic max
    intrinsic min
    integer(kind=inttype) :: max2
    integer(kind=inttype) :: max1
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = eulerwallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
!  determine the boundary condition treatment and compute the
!  undivided pressure gradient accordingly. this gradient is
!  temporarily stored in the halo pressure.
!
    select case  (walltreatment) 
    case (constantpressure) 
! constant pressure. set the gradient to zero.
      grad = zero
      gradd = 0.0_8
    case (linextrapolpressure) 
      gradd = 0.0_8
! linear extrapolation.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        gradd(j, k) = pp3d(j, k) - pp2d(j, k)
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
    case (normalmomentum) 
      gradd = 0.0_8
! pressure gradient is computed using the normal momentum
! equation. first set a couple of additional variables for
! the normals, depending on the block face. note that the
! construction 1: should not be used in these pointers,
! because element 0 is needed. consequently there will be
! an offset of 1 for these normals. this is commented in
! the code. for moving faces also the grid velocity of
! the 1st cell center from the wall is needed.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
! store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        if (jstart .lt. km1) then
          km1 = km1
        else
          km1 = jstart
        end if
        kp1 = k + 1
        if (jend .gt. kp1) then
          kp1 = kp1
        else
          kp1 = jend
        end if
        if (1_inttype .lt. kp1 - km1) then
          max1 = kp1 - km1
        else
          max1 = 1_inttype
        end if
! compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
! the indices j+1 and j-1. make sure that they
! do not exceed the range of the arrays.
        jm1 = j - 1
        if (istart .lt. jm1) then
          jm1 = jm1
        else
          jm1 = istart
        end if
        jp1 = j + 1
        if (iend .gt. jp1) then
          jp1 = jp1
        else
          jp1 = iend
        end if
        if (1_inttype .lt. jp1 - jm1) then
          max2 = jp1 - jm1
        else
          max2 = 1_inttype
        end if
! compute the scaling factor for the central
! difference in the j-direction.
        a1 = one/max2
! compute (twice) the average normal in the generic i,
! j and k-direction. note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). however due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
        sixad = two*ssid(j, k, 1)
        sixa = two*ssi(j, k, 1)
        siyad = two*ssid(j, k, 2)
        siya = two*ssi(j, k, 2)
        sizad = two*ssid(j, k, 3)
        siza = two*ssi(j, k, 3)
        sjxad = ssjd(j, k, 1) + ssjd(j+1, k, 1)
        sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
        sjyad = ssjd(j, k, 2) + ssjd(j+1, k, 2)
        sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
        sjzad = ssjd(j, k, 3) + ssjd(j+1, k, 3)
        sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
        skxad = sskd(j, k, 1) + sskd(j, k+1, 1)
        skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
        skyad = sskd(j, k, 2) + sskd(j, k+1, 2)
        skya = ssk(j, k, 2) + ssk(j, k+1, 2)
        skzad = sskd(j, k, 3) + sskd(j, k+1, 3)
        skza = ssk(j, k, 3) + ssk(j, k+1, 3)
! compute the difference of the normal vector and
! pressure in j and k-direction. as the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
        rxjd = a1*(bcdatad(nn)%norm(jp1, k, 1)-bcdatad(nn)%norm(jm1, k, &
&         1))
        rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
        ryjd = a1*(bcdatad(nn)%norm(jp1, k, 2)-bcdatad(nn)%norm(jm1, k, &
&         2))
        ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
        rzjd = a1*(bcdatad(nn)%norm(jp1, k, 3)-bcdatad(nn)%norm(jm1, k, &
&         3))
        rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
        dpjd = a1*(pp2d(jp1, k)-pp2d(jm1, k))
        dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
        rxkd = b1*(bcdatad(nn)%norm(j, kp1, 1)-bcdatad(nn)%norm(j, km1, &
&         1))
        rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
        rykd = b1*(bcdatad(nn)%norm(j, kp1, 2)-bcdatad(nn)%norm(j, km1, &
&         2))
        ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
        rzkd = b1*(bcdatad(nn)%norm(j, kp1, 3)-bcdatad(nn)%norm(j, km1, &
&         3))
        rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
        dpkd = b1*(pp2d(j, kp1)-pp2d(j, km1))
        dpk = b1*(pp2(j, kp1)-pp2(j, km1))
! compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
        rid = bcdatad(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 1)*&
&         sixad + bcdatad(nn)%norm(j, k, 2)*siya + bcdata(nn)%norm(j, k&
&         , 2)*siyad + bcdatad(nn)%norm(j, k, 3)*siza + bcdata(nn)%norm(&
&         j, k, 3)*sizad
        ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
&         siya + bcdata(nn)%norm(j, k, 3)*siza
        rjd = bcdatad(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 1)*&
&         sjxad + bcdatad(nn)%norm(j, k, 2)*sjya + bcdata(nn)%norm(j, k&
&         , 2)*sjyad + bcdatad(nn)%norm(j, k, 3)*sjza + bcdata(nn)%norm(&
&         j, k, 3)*sjzad
        rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
&         sjya + bcdata(nn)%norm(j, k, 3)*sjza
        rkd = bcdatad(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 1)*&
&         skxad + bcdatad(nn)%norm(j, k, 2)*skya + bcdata(nn)%norm(j, k&
&         , 2)*skyad + bcdatad(nn)%norm(j, k, 3)*skza + bcdata(nn)%norm(&
&         j, k, 3)*skzad
        rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
&         skya + bcdata(nn)%norm(j, k, 3)*skza
! store the velocity components in uux, uuy and uuz and
! subtract the mesh velocity if the face is moving.
        uuxd = ww2d(j, k, ivx)
        uux = ww2(j, k, ivx)
        uuyd = ww2d(j, k, ivy)
        uuy = ww2(j, k, ivy)
        uuzd = ww2d(j, k, ivz)
        uuz = ww2(j, k, ivz)
        if (addgridvelocities) then
          uuxd = uuxd - ssd(j, k, 1)
          uux = uux - ss(j, k, 1)
          uuyd = uuyd - ssd(j, k, 2)
          uuy = uuy - ss(j, k, 2)
          uuzd = uuzd - ssd(j, k, 3)
          uuz = uuz - ss(j, k, 3)
        end if
! compute the velocity components in j and
! k-direction.
        qjd = uuxd*sjxa + uux*sjxad + uuyd*sjya + uuy*sjyad + uuzd*sjza &
&         + uuz*sjzad
        qj = uux*sjxa + uuy*sjya + uuz*sjza
        qkd = uuxd*skxa + uux*skxad + uuyd*skya + uuy*skyad + uuzd*skza &
&         + uuz*skzad
        qk = uux*skxa + uuy*skya + uuz*skza
! compute the pressure gradient, which is stored
! in pp1. i'm not entirely sure whether this
! formulation is correct for moving meshes. it could
! be that an additional term is needed there.
        gradd(j, k) = (((qjd*(uux*rxj+uuy*ryj+uuz*rzj)+qj*(uuxd*rxj+uux*&
&         rxjd+uuyd*ryj+uuy*ryjd+uuzd*rzj+uuz*rzjd)+qkd*(uux*rxk+uuy*ryk&
&         +uuz*rzk)+qk*(uuxd*rxk+uux*rxkd+uuyd*ryk+uuy*rykd+uuzd*rzk+uuz&
&         *rzkd))*ww2(j, k, irho)+(qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*&
&         rxk+uuy*ryk+uuz*rzk))*ww2d(j, k, irho)-rjd*dpj-rj*dpjd-rkd*dpk&
&         -rk*dpkd)*ri-((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*&
&         ryk+uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)*rid)/ri**2
        grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
&         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
      end do
    case default
      gradd = 0.0_8
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1d(j, k) = mydim_d(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k&
&       ), pp1(j, k))
      vnd = two*(-(ww2d(j, k, ivx)*bcdata(nn)%norm(j, k, 1))-ww2(j, k, &
&       ivx)*bcdatad(nn)%norm(j, k, 1)-ww2d(j, k, ivy)*bcdata(nn)%norm(j&
&       , k, 2)-ww2(j, k, ivy)*bcdatad(nn)%norm(j, k, 2)-ww2d(j, k, ivz)&
&       *bcdata(nn)%norm(j, k, 3)-ww2(j, k, ivz)*bcdatad(nn)%norm(j, k, &
&       3))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1d(j, k, irho) = ww2d(j, k, irho)
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1d(j, k, ivx) = ww2d(j, k, ivx) + vnd*bcdata(nn)%norm(j, k, 1) +&
&       vn*bcdatad(nn)%norm(j, k, 1)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1d(j, k, ivy) = ww2d(j, k, ivy) + vnd*bcdata(nn)%norm(j, k, 2) +&
&       vn*bcdatad(nn)%norm(j, k, 2)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1d(j, k, ivz) = ww2d(j, k, ivz) + vnd*bcdata(nn)%norm(j, k, 3) +&
&       vn*bcdatad(nn)%norm(j, k, 3)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! the laminar and eddy viscosity, if present.
      if (viscous) then
        rlv1d(j, k) = rlv2d(j, k)
        rlv1(j, k) = rlv2(j, k)
      end if
      if (eddymodel) then
        rev1d(j, k) = rev2d(j, k)
        rev1(j, k) = rev2(j, k)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bceulerwall_d
  subroutine bceulerwall(nn, secondhalo, correctfork)
!  bceulerwall applies the inviscid wall boundary condition to a
!  block. it is assumed that the bcpointers are already set to the
!  correct block on the correct grid level.
    use constants
    use blockpointers, only : bcdata, addgridvelocities
    use flowvarrefstate, only : viscous, eddymodel, rgas
    use inputdiscretization, only : eulerwallbctreatment
    use iteration, only : currentlevel, groundlevel
    use utils_d, only : mydim
    use bcpointers_d, only : ww0, ww1, ww2, pp0, pp1, pp2, pp3, rlv0, &
&   rlv1, rlv2, rev0, rev1, rev2, ss, ssi, ssj, ssk, istart, isize, &
&   jstart, jsize, iend, jend
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    intrinsic mod
    intrinsic max
    intrinsic min
    integer(kind=inttype) :: max2
    integer(kind=inttype) :: max1
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = eulerwallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
!  determine the boundary condition treatment and compute the
!  undivided pressure gradient accordingly. this gradient is
!  temporarily stored in the halo pressure.
!
    select case  (walltreatment) 
    case (constantpressure) 
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
    case (normalmomentum) 
! pressure gradient is computed using the normal momentum
! equation. first set a couple of additional variables for
! the normals, depending on the block face. note that the
! construction 1: should not be used in these pointers,
! because element 0 is needed. consequently there will be
! an offset of 1 for these normals. this is commented in
! the code. for moving faces also the grid velocity of
! the 1st cell center from the wall is needed.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
! store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        if (jstart .lt. km1) then
          km1 = km1
        else
          km1 = jstart
        end if
        kp1 = k + 1
        if (jend .gt. kp1) then
          kp1 = kp1
        else
          kp1 = jend
        end if
        if (1_inttype .lt. kp1 - km1) then
          max1 = kp1 - km1
        else
          max1 = 1_inttype
        end if
! compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
! the indices j+1 and j-1. make sure that they
! do not exceed the range of the arrays.
        jm1 = j - 1
        if (istart .lt. jm1) then
          jm1 = jm1
        else
          jm1 = istart
        end if
        jp1 = j + 1
        if (iend .gt. jp1) then
          jp1 = jp1
        else
          jp1 = iend
        end if
        if (1_inttype .lt. jp1 - jm1) then
          max2 = jp1 - jm1
        else
          max2 = 1_inttype
        end if
! compute the scaling factor for the central
! difference in the j-direction.
        a1 = one/max2
! compute (twice) the average normal in the generic i,
! j and k-direction. note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). however due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
        sixa = two*ssi(j, k, 1)
        siya = two*ssi(j, k, 2)
        siza = two*ssi(j, k, 3)
        sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
        sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
        sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
        skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
        skya = ssk(j, k, 2) + ssk(j, k+1, 2)
        skza = ssk(j, k, 3) + ssk(j, k+1, 3)
! compute the difference of the normal vector and
! pressure in j and k-direction. as the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
        rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
        ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
        rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
        dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
        rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
        ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
        rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
        dpk = b1*(pp2(j, kp1)-pp2(j, km1))
! compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
        ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
&         siya + bcdata(nn)%norm(j, k, 3)*siza
        rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
&         sjya + bcdata(nn)%norm(j, k, 3)*sjza
        rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
&         skya + bcdata(nn)%norm(j, k, 3)*skza
! store the velocity components in uux, uuy and uuz and
! subtract the mesh velocity if the face is moving.
        uux = ww2(j, k, ivx)
        uuy = ww2(j, k, ivy)
        uuz = ww2(j, k, ivz)
        if (addgridvelocities) then
          uux = uux - ss(j, k, 1)
          uuy = uuy - ss(j, k, 2)
          uuz = uuz - ss(j, k, 3)
        end if
! compute the velocity components in j and
! k-direction.
        qj = uux*sjxa + uuy*sjya + uuz*sjza
        qk = uux*skxa + uuy*skya + uuz*skza
! compute the pressure gradient, which is stored
! in pp1. i'm not entirely sure whether this
! formulation is correct for moving meshes. it could
! be that an additional term is needed there.
        grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
&         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
      end do
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = mydim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bceulerwall
!  differentiation of bcfarfield in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: winf pinfcorr *rev0 *rev1 *rev2
!                *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!                *(*bcdata.norm)
!   rw status of diff variables: winf:in pinfcorr:in *rev0:in-out
!                *rev1:in-out *rev2:in *pp0:in-out *pp1:in-out
!                *pp2:in *rlv0:in-out *rlv1:in-out *rlv2:in *ww0:in-out
!                *ww1:in-out *ww2:in *(*bcdata.norm):in
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in bcdata:in *bcdata.norm:in
  subroutine bcfarfield_d(nn, secondhalo, correctfork)
! bcfarfield applies the farfield boundary condition to a block.
! it is assumed that the bcpointers are already set *
    use constants
    use blockpointers, only : bcdata, bcdatad
    use flowvarrefstate, only : eddymodel, viscous, gammainf, winf, &
&   winfd, pinfcorr, pinfcorrd
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, rlv0, rlv0d, rlv1, rlv1d, rlv2, rlv2d, rev0, &
&   rev0d, rev1, rev1d, rev2, rev2d, gamma2, istart, jstart, isize, &
&   jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: ac1d, ac2d
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: r0d, u0d, v0d, w0d, qn0d, c0d, s0d
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: red, ued, ved, wed, qned, ced
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    real(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
    intrinsic sqrt
    intrinsic mod
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwr1d
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: pwx1d
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0d = -(one*winfd(irho)/winf(irho)**2)
    r0 = one/winf(irho)
    u0d = winfd(ivx)
    u0 = winf(ivx)
    v0d = winfd(ivy)
    v0 = winf(ivy)
    w0d = winfd(ivz)
    w0 = winf(ivz)
    arg1d = gammainf*(pinfcorrd*r0+pinfcorr*r0d)
    arg1 = gammainf*pinfcorr*r0
    if (arg1 .eq. 0.0_8) then
      c0d = 0.0_8
    else
      c0d = arg1d/(2.0*sqrt(arg1))
    end if
    c0 = sqrt(arg1)
    if (winf(irho) .gt. 0.0_8 .or. (winf(irho) .lt. 0.0_8 .and. gammainf&
&       .eq. int(gammainf))) then
      pwr1d = gammainf*winf(irho)**(gammainf-1)*winfd(irho)
    else if (winf(irho) .eq. 0.0_8 .and. gammainf .eq. 1.0) then
      pwr1d = winfd(irho)
    else
      pwr1d = 0.0_8
    end if
    pwr1 = winf(irho)**gammainf
    s0d = (pwr1d*pinfcorr-pwr1*pinfcorrd)/pinfcorr**2
    s0 = pwr1/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0d = u0d*bcdata(nn)%norm(i, j, 1) + u0*bcdatad(nn)%norm(i, j, 1)&
&       + v0d*bcdata(nn)%norm(i, j, 2) + v0*bcdatad(nn)%norm(i, j, 2) + &
&       w0d*bcdata(nn)%norm(i, j, 3) + w0*bcdatad(nn)%norm(i, j, 3)
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      red = -(one*ww2d(i, j, irho)/ww2(i, j, irho)**2)
      re = one/ww2(i, j, irho)
      ued = ww2d(i, j, ivx)
      ue = ww2(i, j, ivx)
      ved = ww2d(i, j, ivy)
      ve = ww2(i, j, ivy)
      wed = ww2d(i, j, ivz)
      we = ww2(i, j, ivz)
      qned = ued*bcdata(nn)%norm(i, j, 1) + ue*bcdatad(nn)%norm(i, j, 1)&
&       + ved*bcdata(nn)%norm(i, j, 2) + ve*bcdatad(nn)%norm(i, j, 2) + &
&       wed*bcdata(nn)%norm(i, j, 3) + we*bcdatad(nn)%norm(i, j, 3)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      arg1d = gamma2(i, j)*(pp2d(i, j)*re+pp2(i, j)*red)
      arg1 = gamma2(i, j)*pp2(i, j)*re
      if (arg1 .eq. 0.0_8) then
        ced = 0.0_8
      else
        ced = arg1d/(2.0*sqrt(arg1))
      end if
      ce = sqrt(arg1)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1d = qned + two*ovgm1*ced
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1d = qn0d + two*ovgm1*c0d
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2d = qned - two*ovgm1*ced
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2d = qn0d - two*ovgm1*c0d
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnfd = half*(ac1d+ac2d)
      qnf = half*(ac1+ac2)
      cfd = fourth*gm1*(ac1d-ac2d)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        ufd = ued + (qnfd-qned)*bcdata(nn)%norm(i, j, 1) + (qnf-qne)*&
&         bcdatad(nn)%norm(i, j, 1)
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vfd = ved + (qnfd-qned)*bcdata(nn)%norm(i, j, 2) + (qnf-qne)*&
&         bcdatad(nn)%norm(i, j, 2)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wfd = wed + (qnfd-qned)*bcdata(nn)%norm(i, j, 3) + (qnf-qne)*&
&         bcdatad(nn)%norm(i, j, 3)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        if (ww2(i, j, irho) .gt. 0.0_8 .or. (ww2(i, j, irho) .lt. 0.0_8 &
&           .and. gamma2(i, j) .eq. int(gamma2(i, j)))) then
          pwr1d = gamma2(i, j)*ww2(i, j, irho)**(gamma2(i, j)-1)*ww2d(i&
&           , j, irho)
        else if (ww2(i, j, irho) .eq. 0.0_8 .and. gamma2(i, j) .eq. 1.0&
&       ) then
          pwr1d = ww2d(i, j, irho)
        else
          pwr1d = 0.0_8
        end if
        pwr1 = ww2(i, j, irho)**gamma2(i, j)
        sfd = (pwr1d*pp2(i, j)-pwr1*pp2d(i, j))/pp2(i, j)**2
        sf = pwr1/pp2(i, j)
      else
! inflow
        ufd = u0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 1) + (qnf-qn0)*&
&         bcdatad(nn)%norm(i, j, 1)
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vfd = v0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 2) + (qnf-qn0)*&
&         bcdatad(nn)%norm(i, j, 2)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wfd = w0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 3) + (qnf-qn0)*&
&         bcdatad(nn)%norm(i, j, 3)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sfd = s0d
        sf = s0
      end if
! compute the density, velocity and pressure in the
! halo cell.
      ccd = (cfd*cf+cf*cfd)/gamma2(i, j)
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      pwx1d = sfd*cc + sf*ccd
      pwx1 = sf*cc
      if (pwx1 .gt. 0.0_8 .or. (pwx1 .lt. 0.0_8 .and. ovgm1 .eq. int(&
&         ovgm1))) then
        ww1d(i, j, irho) = ovgm1*pwx1**(ovgm1-1)*pwx1d
      else if (pwx1 .eq. 0.0_8 .and. ovgm1 .eq. 1.0) then
        ww1d(i, j, irho) = pwx1d
      else
        ww1d(i, j, irho) = 0.0_8
      end if
      ww1(i, j, irho) = pwx1**ovgm1
      ww1d(i, j, ivx) = ufd
      ww1(i, j, ivx) = uf
      ww1d(i, j, ivy) = vfd
      ww1(i, j, ivy) = vf
      ww1d(i, j, ivz) = wfd
      ww1(i, j, ivz) = wf
      pp1d(i, j) = ww1d(i, j, irho)*cc + ww1(i, j, irho)*ccd
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) then
        rlv1d(i, j) = rlv2d(i, j)
        rlv1(i, j) = rlv2(i, j)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev2d(i, j)
        rev1(i, j) = rev2(i, j)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcfarfield_d
  subroutine bcfarfield(nn, secondhalo, correctfork)
! bcfarfield applies the farfield boundary condition to a block.
! it is assumed that the bcpointers are already set *
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : eddymodel, viscous, gammainf, winf, &
&   pinfcorr
    use bcpointers_d, only : ww0, ww1, ww2, pp0, pp1, pp2, rlv0, rlv1, &
&   rlv2, rev0, rev1, rev2, gamma2, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    intrinsic sqrt
    intrinsic mod
    real(kind=realtype) :: arg1
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwx1
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    arg1 = gammainf*pinfcorr*r0
    c0 = sqrt(arg1)
    pwr1 = winf(irho)**gammainf
    s0 = pwr1/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      arg1 = gamma2(i, j)*pp2(i, j)*re
      ce = sqrt(arg1)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        pwr1 = ww2(i, j, irho)**gamma2(i, j)
        sf = pwr1/pp2(i, j)
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      pwx1 = sf*cc
      ww1(i, j, irho) = pwx1**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcfarfield
  subroutine bcsupersonicinflow(nn, secondhalo, correctfork)
! bcsupersonicinflow applies the supersonic inflow boundary
! conditions, entire state vector is prescribed, to a block. it is
! assumed that the pointers in blockpointers are already set to
! the correct block on the correct grid level.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : eddymodel, viscous
    use bcpointers_d, only : ww0, ww1, pp0, pp1, rlv0, rlv1, rlv2, rev0,&
&   rev1, rev2, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, kk, mm, ii
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, kbeg, kend
    intrinsic mod
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      ww1(i, j, irho) = bcdata(nn)%rho(i, j)
      ww1(i, j, ivx) = bcdata(nn)%velx(i, j)
      ww1(i, j, ivy) = bcdata(nn)%vely(i, j)
      ww1(i, j, ivz) = bcdata(nn)%velz(i, j)
      pp1(i, j) = bcdata(nn)%ps(i, j)
! set the laminar and eddy viscosity in the halo
! if needed.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
    call computeetot(ww1, pp1, correctfork)
    if (secondhalo) then
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        ww0(i, j, irho) = bcdata(nn)%rho(i, j)
        ww0(i, j, ivx) = bcdata(nn)%velx(i, j)
        ww0(i, j, ivy) = bcdata(nn)%vely(i, j)
        ww0(i, j, ivz) = bcdata(nn)%velz(i, j)
        pp0(i, j) = bcdata(nn)%ps(i, j)
! set the laminar and eddy viscosity in the halo
! if needed.
        if (viscous) rlv0(i, j) = rlv1(i, j)
        if (eddymodel) rev0(i, j) = rev1(i, j)
      end do
      call computeetot(ww0, pp0, correctfork)
    end if
  end subroutine bcsupersonicinflow
  subroutine bcextrap(nn, secondhalo, correctfork)
!
!  ccextrap applies the extrapolation boundary condition to a
!  block. it is assumed that the pointers in blockpointers are
!  already set to the correct block on the correct grid level.
!  extrapolation boundaries are applied to both singular lines or
!  points of a block face and to supersonic outlets. they are
!  marked differently because of postprocessing reasons, but
!  their numerical treatment is identical.
!
    use constants
    use blockpointers, only : bctype
    use flowvarrefstate, only : viscous, eddymodel
    use inputdiscretization, only : outflowtreatment
!use inputphysics
    use bcpointers_d, only : ww1, ww2, ww3, pp1, pp2, pp3, rlv1, rlv2, &
&   rev1, rev2, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local parameter.
    real(kind=realtype), parameter :: factor=0.5
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: fw2, fw3
    intrinsic mod
    intrinsic max
! set the extrapolation weights, depending on the situation.
    if (bctype(nn) .eq. supersonicoutflow) then
! a physical outflow face. set the weights depending
! on the input parameter.
      select case  (outflowtreatment) 
      case (constantextrapol) 
        fw2 = one
        fw3 = zero
      case (linextrapol) 
        fw2 = two
        fw3 = -one
      end select
    else
! singular block boundary. use linear extrapolation.
      fw2 = two
      fw3 = -one
    end if
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, velocities and pressure.
! make sure that a certain threshold is kept for the
! density and pressure.
      ww1(i, j, irho) = fw2*ww2(i, j, irho) + fw3*ww3(i, j, irho)
      if (factor*ww2(i, j, irho) .lt. ww1(i, j, irho)) then
        ww1(i, j, irho) = ww1(i, j, irho)
      else
        ww1(i, j, irho) = factor*ww2(i, j, irho)
      end if
      ww1(i, j, ivx) = fw2*ww2(i, j, ivx) + fw3*ww3(i, j, ivx)
      ww1(i, j, ivy) = fw2*ww2(i, j, ivy) + fw3*ww3(i, j, ivy)
      ww1(i, j, ivz) = fw2*ww2(i, j, ivz) + fw3*ww3(i, j, ivz)
      pp1(i, j) = fw2*pp2(i, j) + fw3*pp3(i, j)
      if (factor*pp2(i, j) .lt. pp1(i, j)) then
        pp1(i, j) = pp1(i, j)
      else
        pp1(i, j) = factor*pp2(i, j)
      end if
! the laminar and eddy viscosity, if present. these
! values are simply taken constant. their values do
! not really matter.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcextrap
  subroutine prhosubsonicinlet(ww, pp, correctfork)
!  prhosubsonicinlet computes the pressure and density for the
!  given range of the block to which the pointers in blockpointers
!  currently point.
    use constants
    use cpcurvefits
    use flowvarrefstate, only : rgas, tref
    use inputphysics, only : cpmodel, gammaconstant
    use bcpointers_d, only : isize, jsize, istart, jstart
    implicit none
! local parameter.
    real(kind=realtype), parameter :: twothird=two*third
! subroutine arguments.
    real(kind=realtype), dimension(:, :, :) :: ww
    real(kind=realtype), dimension(:, :) :: pp
    logical, intent(in) :: correctfork
! local variables.
    integer(kind=inttype) :: i, j, ii, mm, nns, nnt, iii
    real(kind=realtype) :: govgm1, tt, ts, pt, ratio
    real(kind=realtype) :: intts, inttt, val
    intrinsic mod
    real(kind=realtype) :: pwx1
! determine the cp model used in the computation.
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma. compute the coefficient
! gamma/(gamma-1), which occurs in the isentropic expression
! for the total pressure.
      govgm1 = gammaconstant/(gammaconstant-one)
! loop over the pointer range
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store the total temperature, total pressure and
! static temperature a bit easier.
        tt = ww(i, j, irho)
        pt = pp(i, j)
        ts = ww(i, j, irhoe)
! compute the static pressure from the total pressure
! and the temperature ratio. compute the density using
! the gas law.
        pwx1 = ts/tt
        ratio = pwx1**govgm1
        pp(i, j) = pt*ratio
        ww(i, j, irho) = pp(i, j)/(rgas*ts)
      end do
    end select
! add 2*rho*k/3 to the pressure if a k-equation is present.
    if (correctfork) then
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        pp(i, j) = pp(i, j) + twothird*ww(i, j, irho)*ww(i, j, itu1)
      end do
    end if

  contains
    subroutine cportintegrant(t, nn, int)
      implicit none
! subroutine arguments.
      integer(kind=inttype), intent(out) :: nn
      real(kind=realtype), intent(in) :: t
      real(kind=realtype), intent(out) :: int
! local variables.
      integer(kind=inttype) :: mm, ii, start
      real(kind=realtype) :: t2
      intrinsic log
! determine the situation we are having here for the temperature.
      if (t .le. cptrange(0)) then
! temperature is less than the smallest temperature of the
! curve fits. use extrapolation using constant cp.
! set nn to 0 to indicate this.
        nn = 0
        int = (cv0+one)*log(t)
      else if (t .ge. cptrange(cpnparts)) then
! temperature is larger than the largest temperature of the
! curve fits. use extrapolation using constant cp.
! set nn to cpnparts+1 to indicate this.
        nn = cpnparts + 1
        int = (cvn+one)*log(t)
      else
! temperature is within the curve fit range. determine
! the correct interval.
        ii = cpnparts
        start = 1
interval:do 
! next guess for the interval.
          nn = start + ii/2
! determine the situation we are having here.
          if (t .gt. cptrange(nn)) then
! temperature is larger than the upper boundary of
! the current interval. update the lower boundary.
            start = nn + 1
            ii = ii - 1
          else if (t .ge. cptrange(nn-1)) then
! nn contains the correct curve fit interval.
! compute the value of the integrant.
            int = zero
            do ii=1,cptempfit(nn)%nterm
              mm = cptempfit(nn)%exponents(ii)
              if (mm .eq. 0_inttype) then
                int = int + cptempfit(nn)%constants(ii)*log(t)
              else
                t2 = t**mm
                int = int + cptempfit(nn)%constants(ii)*t2/mm
              end if
            end do
            goto 100
          end if
! this is the correct range. exit the do-loop.
! modify ii for the next branch to search.
          ii = ii/2
        end do interval
      end if
 100  continue
    end subroutine cportintegrant
  end subroutine prhosubsonicinlet
!  differentiation of extrapolate2ndhalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *pp0 *rlv0 *ww0
!   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
!                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
  subroutine extrapolate2ndhalo_d(correctfork)
! extrapolate2ndhalo determines the states of the second layer
! halo cells for the given subface of the block. it is assumed
! that the appropriate bcpointers are already set
    use constants
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, rlv0, rlv0d, rlv1, rlv1d, rlv2, rlv2d, rev0, &
&   rev0d, rev1, rev1d, rev2, rev2d, isize, jsize, istart, jstart
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! input variables
    logical, intent(in) :: correctfork
! working variables
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0d(i, j, irho) = two*ww1d(i, j, irho) - ww2d(i, j, irho)
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0d(i, j, irho) = factor*ww1d(i, j, irho)
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0d(i, j, ivx) = two*ww1d(i, j, ivx) - ww2d(i, j, ivx)
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0d(i, j, ivy) = two*ww1d(i, j, ivy) - ww2d(i, j, ivy)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0d(i, j, ivz) = two*ww1d(i, j, ivz) - ww2d(i, j, ivz)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0d(i, j) = two*pp1d(i, j) - pp2d(i, j)
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0d(i, j) = factor*pp1d(i, j)
        pp0(i, j) = factor*pp1(i, j)
      end if
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) then
        rlv0d(i, j) = rlv1d(i, j)
        rlv0(i, j) = rlv1(i, j)
      end if
      if (eddymodel) then
        rev0d(i, j) = rev1d(i, j)
        rev0(i, j) = rev1(i, j)
      end if
    end do
! compute the energy for this halo range.
    call computeetot_d(ww0, ww0d, pp0, pp0d, correctfork)
  end subroutine extrapolate2ndhalo_d
!  differentiation of computeetot in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: ww
!   with respect to varying inputs: ww pp
  subroutine computeetot_d(ww, wwd, pp, ppd, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use inputphysics, only : gammaconstant, cpmodel
    use utils_d, only : terminate
    use bcpointers_d, only : isize, jsize, istart, jstart
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :) :: ppd
    real(kind=realtype), dimension(:, :, :) :: ww
    real(kind=realtype), dimension(:, :, :) :: wwd
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
! loop over the given array and compute the energy, possibly
! correcting for k
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          wwd(i, j, irhoe) = ovgm1*ppd(i, j) + half*(wwd(i, j, irho)*(ww&
&           (i, j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)+ww(i, j, &
&           irho)*(2*ww(i, j, ivx)*wwd(i, j, ivx)+2*ww(i, j, ivy)*wwd(i&
&           , j, ivy)+2*ww(i, j, ivz)*wwd(i, j, ivz)))
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
        else
          wwd(i, j, irhoe) = ovgm1*ppd(i, j) + half*(wwd(i, j, irho)*(ww&
&           (i, j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)+ww(i, j, &
&           irho)*(2*ww(i, j, ivx)*wwd(i, j, ivx)+2*ww(i, j, ivy)*wwd(i&
&           , j, ivy)+2*ww(i, j, ivz)*wwd(i, j, ivz))) - factk*(wwd(i, j&
&           , irho)*ww(i, j, itu1)+ww(i, j, irho)*wwd(i, j, itu1))
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
&           j, irho)*ww(i, j, itu1)
        end if
      end do
    case (cptempcurvefits) 
      call terminate('bcroutines', &
&              'cptempcurvefits not implemented yet.')
    end select
  end subroutine computeetot_d
  subroutine extrapolate2ndhalo(correctfork)
! extrapolate2ndhalo determines the states of the second layer
! halo cells for the given subface of the block. it is assumed
! that the appropriate bcpointers are already set
    use constants
    use bcpointers_d, only : ww0, ww1, ww2, pp0, pp1, pp2, rlv0, rlv1, &
&   rlv2, rev0, rev1, rev2, isize, jsize, istart, jstart
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! input variables
    logical, intent(in) :: correctfork
! working variables
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
! compute the energy for this halo range.
    call computeetot(ww0, pp0, correctfork)
  end subroutine extrapolate2ndhalo
  subroutine computeetot(ww, pp, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use inputphysics, only : gammaconstant, cpmodel
    use utils_d, only : terminate
    use bcpointers_d, only : isize, jsize, istart, jstart
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :, :) :: ww
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
! loop over the given array and compute the energy, possibly
! correcting for k
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
        else
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
&           j, irho)*ww(i, j, itu1)
        end if
      end do
    case (cptempcurvefits) 
      call terminate('bcroutines', &
&              'cptempcurvefits not implemented yet.')
    end select
  end subroutine computeetot
end module bcroutines_d

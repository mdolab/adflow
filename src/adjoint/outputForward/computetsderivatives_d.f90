!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of computetsderivatives in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: dcdalphadot coef0 dcdalpha
!   with respect to varying inputs: gammainf pinf rhoinfdim pinfdim
!                pref machgrid lengthref machcoef dragdirection
!                liftdirection moment force
!
!     ******************************************************************
!     *                                                                *
!     * file:          computetsderivatives.f90                        *
!     * author:        c.a.(sandy) mader, g. kenway                    *
!     * starting date: 11-25-2009                                      *
!     * last modified: 11-26-2009                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine computetsderivatives_d(force, forced, moment, momentd, &
& liftindex, coef0, coef0d, dcdalpha, dcdalphad, dcdalphadot, &
& dcdalphadotd, dcdq, dcdqdot)
!
!     ******************************************************************
!     *                                                                *
!     * computes the stability derivatives based on the time spectral  *
!     * solution of a given mesh. takes in the force coefficients at   *
!     * all time instantces and computes the agregate parameters       *
!     *                                                                *
!     ******************************************************************
!
  use communication
  use inputphysics
  use inputtimespectral
  use inputtsstabderiv
  use flowvarrefstate
  use monitor
  use section
  use inputmotion
  implicit none
!
!     subroutine arguments.
!
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
& moment
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced, &
& momentd
  real(kind=realtype), dimension(8) :: dcdq, dcdqdot
  real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
  real(kind=realtype), dimension(8) :: dcdalphad, dcdalphadotd
  real(kind=realtype), dimension(8) :: coef0
  real(kind=realtype), dimension(8) :: coef0d
  integer(kind=inttype) :: liftindex
! working variables
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: basecoef
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: basecoefd
  real(kind=realtype), dimension(8) :: coef0dot
  real(kind=realtype), dimension(8) :: coef0dotd
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
& resbasecoef
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
& resbasecoefd
  real(kind=realtype), dimension(ntimeintervalsspectral) :: &
& intervalalpha, intervalalphadot
  real(kind=realtype), dimension(ntimeintervalsspectral) :: intervalmach&
& , intervalmachdot
  real(kind=realtype), dimension(nsections) :: t
  real(kind=realtype) :: alpha, beta
  integer(kind=inttype) :: i, sps, nn
!speed of sound: for normalization of q derivatives
  real(kind=realtype) :: a
  real(kind=realtype) :: ad
  real(kind=realtype) :: scaledim, fact, factmoment
  real(kind=realtype) :: scaledimd, factd, factmomentd
! functions
  real(kind=realtype), dimension(ntimeintervalsspectral) :: dphix, dphiy&
& , dphiz
  real(kind=realtype), dimension(ntimeintervalsspectral) :: dphixdot, &
& dphiydot, dphizdot
  real(kind=realtype) :: derivativerigidrotangle, &
& secondderivativerigidrotangle
  real(kind=realtype) :: derivativerigidrotangle_d
  real(kind=realtype) :: tsalpha, tsalphadot
  intrinsic sqrt
  real(kind=realtype) :: arg1
  real(kind=realtype) :: arg1d
!
!     ******************************************************************
!     *                                                                *
!     * begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
  scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
  scaledim = pref/pinf
  factd = -(two*surfaceref*lref**2*((gammainfd*pinf+gammainf*pinfd)*&
&   machcoef**2*scaledim+gammainf*pinf*(2*machcoef*machcoefd*scaledim+&
&   machcoef**2*scaledimd))/(gammainf*pinf*machcoef**2*surfaceref*lref**&
&   2*scaledim)**2)
  fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
  factmomentd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*&
&   lref)**2
  factmoment = fact/(lengthref*lref)
  call getdirangle(veldirfreestream, liftdirection, liftindex, alpha&
&               , beta)
  if (tsqmode) then
    print*, &
&   'ts q mode code needs to be updated in computetsderivatives!'
    stop
! !q is pitch
! do sps =1,ntimeintervalsspectral
!    !compute the time of this intervavc
!    t = timeunsteadyrestart
!    if(equationmode == timespectral) then
!       do nn=1,nsections
!          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod &
!               /         (ntimeintervalsspectral*1.0)
!       enddo
!    endif
!    ! compute the time derivative of the rotation angles around the
!    ! z-axis. i.e. compute q
!    dphiz(sps) = derivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
!    ! add in q_dot computation
!    dphizdot(sps) = secondderivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
! end do
! !now compute dcl/dq
! do i =1,8
!    call computeleastsquaresregression(basecoef(:,i),dphiz,ntimeintervalsspectral,dcdq(i),coef0(i))
! end do
! ! now subtract off estimated cl,cmz and use remainder to compute 
! ! clqdot and cmzqdot.
! do i = 1,8
!    do sps = 1,ntimeintervalsspectral
!       resbasecoef(sps,i) = basecoef(sps,i)-(dcdq(i)*dphiz(sps)+coef0(i))
!    enddo
! enddo
! !now normalize the results...
! a  = sqrt(gammainf*pinfdim/rhoinfdim)
! dcdq = dcdq*timeref*2*(machgrid*a)/lengthref
! !now compute dcl/dpdot
! do i = 1,8
!    call computeleastsquaresregression(resbasecoef(:,i),dphizdot,ntimeintervalsspectral,dcdqdot(i),coef0dot(i))
! enddo
  else if (tsalphamode) then
    basecoefd = 0.0_8
    do sps=1,ntimeintervalsspectral
!compute the time of this interval
      t = timeunsteadyrestart
      if (equationmode .eq. timespectral) then
        do nn=1,nsections
          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&           ntimeintervalsspectral*1.0)
        end do
      end if
      intervalalpha(sps) = tsalpha(degreepolalpha, coefpolalpha, &
&       degreefouralpha, omegafouralpha, coscoeffouralpha, &
&       sincoeffouralpha, t)
      intervalalphadot(sps) = tsalphadot(degreepolalpha, coefpolalpha&
&       , degreefouralpha, omegafouralpha, coscoeffouralpha, &
&       sincoeffouralpha, t)
      call getdirangle(veldirfreestream, liftdirection, liftindex, &
&                   alpha + intervalalpha(sps), beta)
      basecoefd(sps, 1) = factd*(force(1, sps)*liftdirection(1)+force(2&
&       , sps)*liftdirection(2)+force(3, sps)*liftdirection(3)) + fact*(&
&       forced(1, sps)*liftdirection(1)+force(1, sps)*liftdirectiond(1)+&
&       forced(2, sps)*liftdirection(2)+force(2, sps)*liftdirectiond(2)+&
&       forced(3, sps)*liftdirection(3)+force(3, sps)*liftdirectiond(3))
      basecoef(sps, 1) = fact*(force(1, sps)*liftdirection(1)+force(2, &
&       sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
      basecoefd(sps, 2) = factd*(force(1, sps)*dragdirection(1)+force(2&
&       , sps)*dragdirection(2)+force(3, sps)*dragdirection(3)) + fact*(&
&       forced(1, sps)*dragdirection(1)+force(1, sps)*dragdirectiond(1)+&
&       forced(2, sps)*dragdirection(2)+force(2, sps)*dragdirectiond(2)+&
&       forced(3, sps)*dragdirection(3)+force(3, sps)*dragdirectiond(3))
      basecoef(sps, 2) = fact*(force(1, sps)*dragdirection(1)+force(2, &
&       sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
      basecoefd(sps, 3) = forced(1, sps)*fact + force(1, sps)*factd
      basecoef(sps, 3) = force(1, sps)*fact
      basecoefd(sps, 4) = forced(2, sps)*fact + force(2, sps)*factd
      basecoef(sps, 4) = force(2, sps)*fact
      basecoefd(sps, 5) = forced(3, sps)*fact + force(3, sps)*factd
      basecoef(sps, 5) = force(3, sps)*fact
      basecoefd(sps, 6) = momentd(1, sps)*factmoment + moment(1, sps)*&
&       factmomentd
      basecoef(sps, 6) = moment(1, sps)*factmoment
      basecoefd(sps, 7) = momentd(2, sps)*factmoment + moment(2, sps)*&
&       factmomentd
      basecoef(sps, 7) = moment(2, sps)*factmoment
      basecoefd(sps, 8) = momentd(3, sps)*factmoment + moment(3, sps)*&
&       factmomentd
      basecoef(sps, 8) = moment(3, sps)*factmoment
    end do
    coef0d = 0.0_8
    dcdalphad = 0.0_8
!now compute dcl/dalpha
    do i=1,8
      call computeleastsquaresregression_d(basecoef(:, i), basecoefd(:, &
&                                    i), intervalalpha, &
&                                    ntimeintervalsspectral, dcdalpha(i)&
&                                    , dcdalphad(i), coef0(i), coef0d(i)&
&                                   )
    end do
    resbasecoefd = 0.0_8
! now subtract off estimated cl,cmz and use remainder to compute 
! clalphadot and cmzalphadot.
    do i=1,8
      do sps=1,ntimeintervalsspectral
        resbasecoefd(sps, i) = basecoefd(sps, i) - intervalalpha(sps)*&
&         dcdalphad(i) - coef0d(i)
        resbasecoef(sps, i) = basecoef(sps, i) - (dcdalpha(i)*&
&         intervalalpha(sps)+coef0(i))
      end do
    end do
    dcdalphadotd = 0.0_8
!now compute dci/dalphadot
    do i=1,8
      call computeleastsquaresregression_d(resbasecoef(:, i), &
&                                    resbasecoefd(:, i), &
&                                    intervalalphadot, &
&                                    ntimeintervalsspectral, dcdalphadot&
&                                    (i), dcdalphadotd(i), coef0dot(i), &
&                                    coef0dotd(i))
    end do
    arg1d = ((gammainfd*pinfdim+gammainf*pinfdimd)*rhoinfdim-gammainf*&
&     pinfdim*rhoinfdimd)/rhoinfdim**2
    arg1 = gammainf*pinfdim/rhoinfdim
    if (arg1 .eq. 0.0_8) then
      ad = 0.0_8
    else
      ad = arg1d/(2.0*sqrt(arg1))
    end if
    a = sqrt(arg1)
    dcdalphadotd = (2*((dcdalphadotd*machgrid+dcdalphadot*machgridd)*a+&
&     dcdalphadot*machgrid*ad)*lengthref-dcdalphadot*2*machgrid*a*&
&     lengthrefd)/lengthref**2
    dcdalphadot = dcdalphadot*2*(machgrid*a)/lengthref
  else
    call returnfail('computetsderivatives', &
&                'not a valid stability motion')
    dcdalphadotd = 0.0_8
    coef0d = 0.0_8
    dcdalphad = 0.0_8
  end if
end subroutine computetsderivatives_d

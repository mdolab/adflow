!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of inviscidcentralflux in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: timeref *p *sfacei *sfacej
!                sfacek *dw *w *vol *si *sj 
!   plus diff mem management of: p:in sfacei:in sfacej:in sfacek:in
!                dw:in w:in vol:in si:in sj:in sk:in
!
!       file:          inviscidcentralflux.f90                         
!       author:        edwin van der weide                             
!       starting date: 03-24-2003                                      
!       last modified: 10-29-2007                                      
!
subroutine inviscidcentralflux_d()
!
!       inviscidcentralflux computes the euler fluxes using a central  
!       discretization for a given block. therefore it is assumed that 
!       the pointers in block pointer already point to the correct     
!       block on the correct multigrid level.                          
!
  use blockpointers
  use cgnsgrid
  use constants
  use flowvarrefstate
  use inputphysics
  implicit none
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ind, ii
  real(kind=realtype) :: qsp, qsm, rqsp, rqsm, porvel, porflux
  real(kind=realtype) :: qspd, qsmd, rqspd, rqsmd
  real(kind=realtype) :: pa, fs, sface, vnp, vnm
  real(kind=realtype) :: pad, fsd, sfaced, vnpd, vnmd
  real(kind=realtype) :: wwx, wwy, wwz, rvol
  real(kind=realtype) :: wwxd, wwyd, wwzd, rvold
  intrinsic mod
!
!       begin execution                                                
!
! initialize sface to zero. this value will be used if the
! block is not moving.
  sface = zero
  sfaced = 0.0_8
!
!       advective fluxes in the i-direction.                           
!
  do k=2,kl
    do j=2,jl
      do i=1,il
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
        if (addgridvelocities) then
          sfaced = sfaceid(i, j, k)
          sface = sfacei(i, j, k)
        end if
! compute the normal velocities of the left and right state.
        vnpd = wd(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivx)*sid&
&         (i, j, k, 1) + wd(i+1, j, k, ivy)*si(i, j, k, 2) + w(i+1, j, k&
&         , ivy)*sid(i, j, k, 2) + wd(i+1, j, k, ivz)*si(i, j, k, 3) + w&
&         (i+1, j, k, ivz)*sid(i, j, k, 3)
        vnp = w(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivy)*si(i&
&         , j, k, 2) + w(i+1, j, k, ivz)*si(i, j, k, 3)
        vnmd = wd(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivx)*sid(i, &
&         j, k, 1) + wd(i, j, k, ivy)*si(i, j, k, 2) + w(i, j, k, ivy)*&
&         sid(i, j, k, 2) + wd(i, j, k, ivz)*si(i, j, k, 3) + w(i, j, k&
&         , ivz)*sid(i, j, k, 3)
        vnm = w(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivy)*si(i, j, &
&         k, 2) + w(i, j, k, ivz)*si(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
        porvel = one
        porflux = half
        if (pori(i, j, k) .eq. noflux) porflux = zero
        if (pori(i, j, k) .eq. boundflux) then
          porvel = zero
          vnpd = sfaced
          vnp = sface
          vnmd = sfaced
          vnm = sface
        end if
! incorporate porflux in porvel.
        porvel = porvel*porflux
! compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
        qspd = porvel*(vnpd-sfaced)
        qsp = (vnp-sface)*porvel
        qsmd = porvel*(vnmd-sfaced)
        qsm = (vnm-sface)*porvel
        rqspd = qspd*w(i+1, j, k, irho) + qsp*wd(i+1, j, k, irho)
        rqsp = qsp*w(i+1, j, k, irho)
        rqsmd = qsmd*w(i, j, k, irho) + qsm*wd(i, j, k, irho)
        rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
        pad = porflux*(pd(i+1, j, k)+pd(i, j, k))
        pa = porflux*(p(i+1, j, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i+1,j,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
        fsd = rqspd + rqsmd
        fs = rqsp + rqsm
        dwd(i+1, j, k, irho) = dwd(i+1, j, k, irho) - fsd
        dw(i+1, j, k, irho) = dw(i+1, j, k, irho) - fs
        dwd(i, j, k, irho) = dwd(i, j, k, irho) + fsd
        dw(i, j, k, irho) = dw(i, j, k, irho) + fs
        fsd = rqspd*w(i+1, j, k, ivx) + rqsp*wd(i+1, j, k, ivx) + rqsmd*&
&         w(i, j, k, ivx) + rqsm*wd(i, j, k, ivx) + pad*si(i, j, k, 1) +&
&         pa*sid(i, j, k, 1)
        fs = rqsp*w(i+1, j, k, ivx) + rqsm*w(i, j, k, ivx) + pa*si(i, j&
&         , k, 1)
        dwd(i+1, j, k, imx) = dwd(i+1, j, k, imx) - fsd
        dw(i+1, j, k, imx) = dw(i+1, j, k, imx) - fs
        dwd(i, j, k, imx) = dwd(i, j, k, imx) + fsd
        dw(i, j, k, imx) = dw(i, j, k, imx) + fs
        fsd = rqspd*w(i+1, j, k, ivy) + rqsp*wd(i+1, j, k, ivy) + rqsmd*&
&         w(i, j, k, ivy) + rqsm*wd(i, j, k, ivy) + pad*si(i, j, k, 2) +&
&         pa*sid(i, j, k, 2)
        fs = rqsp*w(i+1, j, k, ivy) + rqsm*w(i, j, k, ivy) + pa*si(i, j&
&         , k, 2)
        dwd(i+1, j, k, imy) = dwd(i+1, j, k, imy) - fsd
        dw(i+1, j, k, imy) = dw(i+1, j, k, imy) - fs
        dwd(i, j, k, imy) = dwd(i, j, k, imy) + fsd
        dw(i, j, k, imy) = dw(i, j, k, imy) + fs
        fsd = rqspd*w(i+1, j, k, ivz) + rqsp*wd(i+1, j, k, ivz) + rqsmd*&
&         w(i, j, k, ivz) + rqsm*wd(i, j, k, ivz) + pad*si(i, j, k, 3) +&
&         pa*sid(i, j, k, 3)
        fs = rqsp*w(i+1, j, k, ivz) + rqsm*w(i, j, k, ivz) + pa*si(i, j&
&         , k, 3)
        dwd(i+1, j, k, imz) = dwd(i+1, j, k, imz) - fsd
        dw(i+1, j, k, imz) = dw(i+1, j, k, imz) - fs
        dwd(i, j, k, imz) = dwd(i, j, k, imz) + fsd
        dw(i, j, k, imz) = dw(i, j, k, imz) + fs
        fsd = qspd*w(i+1, j, k, irhoe) + qsp*wd(i+1, j, k, irhoe) + qsmd&
&         *w(i, j, k, irhoe) + qsm*wd(i, j, k, irhoe) + porflux*(vnpd*p(&
&         i+1, j, k)+vnp*pd(i+1, j, k)+vnmd*p(i, j, k)+vnm*pd(i, j, k))
        fs = qsp*w(i+1, j, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&         vnp*p(i+1, j, k)+vnm*p(i, j, k))
        dwd(i+1, j, k, irhoe) = dwd(i+1, j, k, irhoe) - fsd
        dw(i+1, j, k, irhoe) = dw(i+1, j, k, irhoe) - fs
        dwd(i, j, k, irhoe) = dwd(i, j, k, irhoe) + fsd
        dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
      end do
    end do
  end do
!
!       advective fluxes in the j-direction.                           
!
  sface = zero
  sfaced = 0.0_8
  do k=2,kl
    do j=1,jl
      do i=2,il
! set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
        if (addgridvelocities) then
          sfaced = sfacejd(i, j, k)
          sface = sfacej(i, j, k)
        end if
! compute the normal velocities of the left and right state.
        vnpd = wd(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivx)*sjd&
&         (i, j, k, 1) + wd(i, j+1, k, ivy)*sj(i, j, k, 2) + w(i, j+1, k&
&         , ivy)*sjd(i, j, k, 2) + wd(i, j+1, k, ivz)*sj(i, j, k, 3) + w&
&         (i, j+1, k, ivz)*sjd(i, j, k, 3)
        vnp = w(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivy)*sj(i&
&         , j, k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 3)
        vnmd = wd(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivx)*sjd(i, &
&         j, k, 1) + wd(i, j, k, ivy)*sj(i, j, k, 2) + w(i, j, k, ivy)*&
&         sjd(i, j, k, 2) + wd(i, j, k, ivz)*sj(i, j, k, 3) + w(i, j, k&
&         , ivz)*sjd(i, j, k, 3)
        vnm = w(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivy)*sj(i, j, &
&         k, 2) + w(i, j, k, ivz)*sj(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
        porvel = one
        porflux = half
        if (porj(i, j, k) .eq. noflux) porflux = zero
        if (porj(i, j, k) .eq. boundflux) then
          porvel = zero
          vnpd = sfaced
          vnp = sface
          vnmd = sfaced
          vnm = sface
        end if
! incorporate porflux in porvel.
        porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
        qspd = porvel*(vnpd-sfaced)
        qsp = (vnp-sface)*porvel
        qsmd = porvel*(vnmd-sfaced)
        qsm = (vnm-sface)*porvel
        rqspd = qspd*w(i, j+1, k, irho) + qsp*wd(i, j+1, k, irho)
        rqsp = qsp*w(i, j+1, k, irho)
        rqsmd = qsmd*w(i, j, k, irho) + qsm*wd(i, j, k, irho)
        rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
        pad = porflux*(pd(i, j+1, k)+pd(i, j, k))
        pa = porflux*(p(i, j+1, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j+1,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
        fsd = rqspd + rqsmd
        fs = rqsp + rqsm
        dwd(i, j+1, k, irho) = dwd(i, j+1, k, irho) - fsd
        dw(i, j+1, k, irho) = dw(i, j+1, k, irho) - fs
        dwd(i, j, k, irho) = dwd(i, j, k, irho) + fsd
        dw(i, j, k, irho) = dw(i, j, k, irho) + fs
        fsd = rqspd*w(i, j+1, k, ivx) + rqsp*wd(i, j+1, k, ivx) + rqsmd*&
&         w(i, j, k, ivx) + rqsm*wd(i, j, k, ivx) + pad*sj(i, j, k, 1) +&
&         pa*sjd(i, j, k, 1)
        fs = rqsp*w(i, j+1, k, ivx) + rqsm*w(i, j, k, ivx) + pa*sj(i, j&
&         , k, 1)
        dwd(i, j+1, k, imx) = dwd(i, j+1, k, imx) - fsd
        dw(i, j+1, k, imx) = dw(i, j+1, k, imx) - fs
        dwd(i, j, k, imx) = dwd(i, j, k, imx) + fsd
        dw(i, j, k, imx) = dw(i, j, k, imx) + fs
        fsd = rqspd*w(i, j+1, k, ivy) + rqsp*wd(i, j+1, k, ivy) + rqsmd*&
&         w(i, j, k, ivy) + rqsm*wd(i, j, k, ivy) + pad*sj(i, j, k, 2) +&
&         pa*sjd(i, j, k, 2)
        fs = rqsp*w(i, j+1, k, ivy) + rqsm*w(i, j, k, ivy) + pa*sj(i, j&
&         , k, 2)
        dwd(i, j+1, k, imy) = dwd(i, j+1, k, imy) - fsd
        dw(i, j+1, k, imy) = dw(i, j+1, k, imy) - fs
        dwd(i, j, k, imy) = dwd(i, j, k, imy) + fsd
        dw(i, j, k, imy) = dw(i, j, k, imy) + fs
        fsd = rqspd*w(i, j+1, k, ivz) + rqsp*wd(i, j+1, k, ivz) + rqsmd*&
&         w(i, j, k, ivz) + rqsm*wd(i, j, k, ivz) + pad*sj(i, j, k, 3) +&
&         pa*sjd(i, j, k, 3)
        fs = rqsp*w(i, j+1, k, ivz) + rqsm*w(i, j, k, ivz) + pa*sj(i, j&
&         , k, 3)
        dwd(i, j+1, k, imz) = dwd(i, j+1, k, imz) - fsd
        dw(i, j+1, k, imz) = dw(i, j+1, k, imz) - fs
        dwd(i, j, k, imz) = dwd(i, j, k, imz) + fsd
        dw(i, j, k, imz) = dw(i, j, k, imz) + fs
        fsd = qspd*w(i, j+1, k, irhoe) + qsp*wd(i, j+1, k, irhoe) + qsmd&
&         *w(i, j, k, irhoe) + qsm*wd(i, j, k, irhoe) + porflux*(vnpd*p(&
&         i, j+1, k)+vnp*pd(i, j+1, k)+vnmd*p(i, j, k)+vnm*pd(i, j, k))
        fs = qsp*w(i, j+1, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&         vnp*p(i, j+1, k)+vnm*p(i, j, k))
        dwd(i, j+1, k, irhoe) = dwd(i, j+1, k, irhoe) - fsd
        dw(i, j+1, k, irhoe) = dw(i, j+1, k, irhoe) - fs
        dwd(i, j, k, irhoe) = dwd(i, j, k, irhoe) + fsd
        dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
      end do
    end do
  end do
!
!       advective fluxes in the k-direction.                           
  sface = zero
  sfaced = 0.0_8
  do k=1,kl
    do j=2,jl
      do i=2,il
! set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
        if (addgridvelocities) then
          sfaced = sfacekd(i, j, k)
          sface = sfacek(i, j, k)
        end if
! compute the normal velocities of the left and right state.
        vnpd = wd(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivx)*skd&
&         (i, j, k, 1) + wd(i, j, k+1, ivy)*sk(i, j, k, 2) + w(i, j, k+1&
&         , ivy)*skd(i, j, k, 2) + wd(i, j, k+1, ivz)*sk(i, j, k, 3) + w&
&         (i, j, k+1, ivz)*skd(i, j, k, 3)
        vnp = w(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivy)*sk(i&
&         , j, k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 3)
        vnmd = wd(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivx)*skd(i, &
&         j, k, 1) + wd(i, j, k, ivy)*sk(i, j, k, 2) + w(i, j, k, ivy)*&
&         skd(i, j, k, 2) + wd(i, j, k, ivz)*sk(i, j, k, 3) + w(i, j, k&
&         , ivz)*skd(i, j, k, 3)
        vnm = w(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivy)*sk(i, j, &
&         k, 2) + w(i, j, k, ivz)*sk(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! block boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
        porvel = one
        porflux = half
        if (pork(i, j, k) .eq. noflux) porflux = zero
        if (pork(i, j, k) .eq. boundflux) then
          porvel = zero
          vnpd = sfaced
          vnp = sface
          vnmd = sfaced
          vnm = sface
        end if
! incorporate porflux in porvel.
        porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
        qspd = porvel*(vnpd-sfaced)
        qsp = (vnp-sface)*porvel
        qsmd = porvel*(vnmd-sfaced)
        qsm = (vnm-sface)*porvel
        rqspd = qspd*w(i, j, k+1, irho) + qsp*wd(i, j, k+1, irho)
        rqsp = qsp*w(i, j, k+1, irho)
        rqsmd = qsmd*w(i, j, k, irho) + qsm*wd(i, j, k, irho)
        rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
        pad = porflux*(pd(i, j, k+1)+pd(i, j, k))
        pa = porflux*(p(i, j, k+1)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j,k+1. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
        fsd = rqspd + rqsmd
        fs = rqsp + rqsm
        dwd(i, j, k+1, irho) = dwd(i, j, k+1, irho) - fsd
        dw(i, j, k+1, irho) = dw(i, j, k+1, irho) - fs
        dwd(i, j, k, irho) = dwd(i, j, k, irho) + fsd
        dw(i, j, k, irho) = dw(i, j, k, irho) + fs
        fsd = rqspd*w(i, j, k+1, ivx) + rqsp*wd(i, j, k+1, ivx) + rqsmd*&
&         w(i, j, k, ivx) + rqsm*wd(i, j, k, ivx) + pad*sk(i, j, k, 1) +&
&         pa*skd(i, j, k, 1)
        fs = rqsp*w(i, j, k+1, ivx) + rqsm*w(i, j, k, ivx) + pa*sk(i, j&
&         , k, 1)
        dwd(i, j, k+1, imx) = dwd(i, j, k+1, imx) - fsd
        dw(i, j, k+1, imx) = dw(i, j, k+1, imx) - fs
        dwd(i, j, k, imx) = dwd(i, j, k, imx) + fsd
        dw(i, j, k, imx) = dw(i, j, k, imx) + fs
        fsd = rqspd*w(i, j, k+1, ivy) + rqsp*wd(i, j, k+1, ivy) + rqsmd*&
&         w(i, j, k, ivy) + rqsm*wd(i, j, k, ivy) + pad*sk(i, j, k, 2) +&
&         pa*skd(i, j, k, 2)
        fs = rqsp*w(i, j, k+1, ivy) + rqsm*w(i, j, k, ivy) + pa*sk(i, j&
&         , k, 2)
        dwd(i, j, k+1, imy) = dwd(i, j, k+1, imy) - fsd
        dw(i, j, k+1, imy) = dw(i, j, k+1, imy) - fs
        dwd(i, j, k, imy) = dwd(i, j, k, imy) + fsd
        dw(i, j, k, imy) = dw(i, j, k, imy) + fs
        fsd = rqspd*w(i, j, k+1, ivz) + rqsp*wd(i, j, k+1, ivz) + rqsmd*&
&         w(i, j, k, ivz) + rqsm*wd(i, j, k, ivz) + pad*sk(i, j, k, 3) +&
&         pa*skd(i, j, k, 3)
        fs = rqsp*w(i, j, k+1, ivz) + rqsm*w(i, j, k, ivz) + pa*sk(i, j&
&         , k, 3)
        dwd(i, j, k+1, imz) = dwd(i, j, k+1, imz) - fsd
        dw(i, j, k+1, imz) = dw(i, j, k+1, imz) - fs
        dwd(i, j, k, imz) = dwd(i, j, k, imz) + fsd
        dw(i, j, k, imz) = dw(i, j, k, imz) + fs
        fsd = qspd*w(i, j, k+1, irhoe) + qsp*wd(i, j, k+1, irhoe) + qsmd&
&         *w(i, j, k, irhoe) + qsm*wd(i, j, k, irhoe) + porflux*(vnpd*p(&
&         i, j, k+1)+vnp*pd(i, j, k+1)+vnmd*p(i, j, k)+vnm*pd(i, j, k))
        fs = qsp*w(i, j, k+1, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&         vnp*p(i, j, k+1)+vnm*p(i, j, k))
        dwd(i, j, k+1, irhoe) = dwd(i, j, k+1, irhoe) - fsd
        dw(i, j, k+1, irhoe) = dw(i, j, k+1, irhoe) - fs
        dwd(i, j, k, irhoe) = dwd(i, j, k, irhoe) + fsd
        dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
      end do
    end do
  end do
! add the rotational source terms for a moving block in a
! steady state computation. these source terms account for the
! centrifugal acceleration and the coriolis term. however, as
! the the equations are solved in the inertial frame and not
! in the moving frame, the form is different than what you
! normally find in a text book.
  if (blockismoving .and. equationmode .eq. steady) then
! compute the three nondimensional angular velocities.
    wwxd = cgnsdoms(nbkglobal)%rotrate(1)*timerefd
    wwx = timeref*cgnsdoms(nbkglobal)%rotrate(1)
    wwyd = cgnsdoms(nbkglobal)%rotrate(2)*timerefd
    wwy = timeref*cgnsdoms(nbkglobal)%rotrate(2)
    wwzd = cgnsdoms(nbkglobal)%rotrate(3)*timerefd
    wwz = timeref*cgnsdoms(nbkglobal)%rotrate(3)
! loop over the internal cells of this block to compute the
! rotational terms for the momentum equations.
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rvold = wd(i, j, k, irho)*vol(i, j, k) + w(i, j, k, irho)*vold(i, &
&       j, k)
      rvol = w(i, j, k, irho)*vol(i, j, k)
      dwd(i, j, k, imx) = dwd(i, j, k, imx) + rvold*(wwy*w(i, j, k, ivz)&
&       -wwz*w(i, j, k, ivy)) + rvol*(wwyd*w(i, j, k, ivz)+wwy*wd(i, j, &
&       k, ivz)-wwzd*w(i, j, k, ivy)-wwz*wd(i, j, k, ivy))
      dw(i, j, k, imx) = dw(i, j, k, imx) + rvol*(wwy*w(i, j, k, ivz)-&
&       wwz*w(i, j, k, ivy))
      dwd(i, j, k, imy) = dwd(i, j, k, imy) + rvold*(wwz*w(i, j, k, ivx)&
&       -wwx*w(i, j, k, ivz)) + rvol*(wwzd*w(i, j, k, ivx)+wwz*wd(i, j, &
&       k, ivx)-wwxd*w(i, j, k, ivz)-wwx*wd(i, j, k, ivz))
      dw(i, j, k, imy) = dw(i, j, k, imy) + rvol*(wwz*w(i, j, k, ivx)-&
&       wwx*w(i, j, k, ivz))
      dwd(i, j, k, imz) = dwd(i, j, k, imz) + rvold*(wwx*w(i, j, k, ivy)&
&       -wwy*w(i, j, k, ivx)) + rvol*(wwxd*w(i, j, k, ivy)+wwx*wd(i, j, &
&       k, ivy)-wwyd*w(i, j, k, ivx)-wwy*wd(i, j, k, ivx))
      dw(i, j, k, imz) = dw(i, j, k, imz) + rvol*(wwx*w(i, j, k, ivy)-&
&       wwy*w(i, j, k, ivx))
    end do
  end if
end subroutine inviscidcentralflux_d

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of block_res in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(flowdoms.w) *(flowdoms.dw)
!                *(*bcdata.fv) *(*bcdata.fp) *(*bcdata.area) *rev0
!                *rev1 *pp0 *pp1 *rlv0 *rlv1 *ww0 *ww1 funcvalues
!   with respect to varying inputs: *(flowdoms.x) *(flowdoms.w)
!                mach machgrid rgasdim lengthref machcoef pointref
!                tinfdim rhoinfdim pinfdim *xx *rev0 *rev1 *rev2
!                *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3
!                *ss *ssi *ssj *ssk *ww0 *ww1 *ww2 *ww3 alpha beta
!   rw status of diff variables: *(flowdoms.x):in *(flowdoms.vol):(loc)
!                *(flowdoms.w):in-out *(flowdoms.dw):out *rev:(loc)
!                *aa:(loc) *bvtj1:(loc) *bvtj2:(loc) *wx:(loc)
!                *wy:(loc) *wz:(loc) *p:(loc) *sfacei:(loc) *sfacej:(loc)
!                *s:(loc) *sfacek:(loc) *rlv:(loc) *qx:(loc) *qy:(loc)
!                *qz:(loc) *scratch:(loc) *bvtk1:(loc) *bvtk2:(loc)
!                *ux:(loc) *uy:(loc) *uz:(loc) *si:(loc) *sj:(loc)
!                *sk:(loc) *bvti1:(loc) *bvti2:(loc) *vx:(loc)
!                *vy:(loc) *vz:(loc) *fw:(loc) *(*viscsubface.tau):(loc)
!                *(*bcdata.norm):(loc) *(*bcdata.rface):(loc) *(*bcdata.fv):out
!                *(*bcdata.fp):out *(*bcdata.area):out *(*bcdata.uslip):(loc)
!                *radi:(loc) *radj:(loc) *radk:(loc) mach:in veldirfreestream:(loc)
!                machgrid:in rgasdim:in lengthref:in machcoef:in
!                dragdirection:(loc) liftdirection:(loc) pointref:in
!                gammainf:(loc) tinfdim:in pinf:(loc) timeref:(loc)
!                rhoinf:(loc) muref:(loc) rhoinfdim:in tref:(loc)
!                winf:(loc) muinf:(loc) uinf:(loc) pinfcorr:(loc)
!                rgas:(loc) muinfdim:(loc) pinfdim:in pref:(loc)
!                rhoref:(loc) *xx:in *rev0:in-out *rev1:in-out
!                *rev2:in *rev3:in *pp0:in-out *pp1:in-out *pp2:in
!                *pp3:in *rlv0:in-out *rlv1:in-out *rlv2:in *rlv3:in
!                *ss:in *ssi:in *ssj:in *ssk:in *ww0:in-out *ww1:in-out
!                *ww2:in *ww3:in funcvalues:out alpha:in beta:in
!   plus diff mem management of: flowdoms.x:in flowdoms.vol:in
!                flowdoms.w:in flowdoms.dw:in rev:in aa:in bvtj1:in
!                bvtj2:in wx:in wy:in wz:in p:in sfacei:in sfacej:in
!                s:in sfacek:in rlv:in qx:in qy:in qz:in scratch:in
!                bvtk1:in bvtk2:in ux:in uy:in uz:in si:in sj:in
!                sk:in bvti1:in bvti2:in vx:in vy:in vz:in fw:in
!                viscsubface:in *viscsubface.tau:in bcdata:in *bcdata.norm:in
!                *bcdata.rface:in *bcdata.fv:in *bcdata.fp:in *bcdata.area:in
!                *bcdata.uslip:in radi:in radj:in radk:in xx:in-out
!                rev0:in-out rev1:in-out rev2:in-out rev3:in-out
!                pp0:in-out pp1:in-out pp2:in-out pp3:in-out rlv0:in-out
!                rlv1:in-out rlv2:in-out rlv3:in-out ss:in-out
!                ssi:in-out ssj:in-out ssk:in-out ww0:in-out ww1:in-out
!                ww2:in-out ww3:in-out
! this is a super-combined function that combines the original
! functionality of: 
! pressure computation
! timestep
! applyallbcs
! initres
! residual 
! the real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the nominal
! block/sps loop is outside the calculation. this routine is suitable
! for forward mode ad with tapenade
subroutine block_res_d(nn, sps, usespatial, alpha, alphad, beta, betad, &
& liftindex, frozenturb)
! note that we import all the pointers from block res that will be
! used in any routine. otherwise, tapenade gives warnings about
! saving a hidden variable. 
  use constants
  use block, only : flowdoms, flowdomsd
  use bcroutines_d
  use bcpointers_d
  use blockpointers, only : w, wd, dw, dwd, x, xd, vol, vold, il, jl, &
& kl, sectionid, wold, volold, bcdata, bcdatad, si, sid, sj, sjd, sk, &
& skd, sfacei, sfaceid, sfacej, sfacejd, sfacek, sfacekd, rlv, rlvd, &
& gamma, p, pd, rev, revd, bmtj1, bmtj2, scratch, scratchd, bmtk2, bmtk1&
& , fw, fwd, aa, aad, d2wall, bmti1, bmti2, s, sd
  use flowvarrefstate
  use inputphysics
  use inputiteration
  use inputtimespectral
  use section
  use monitor
  use iteration
  use diffsizes
  use costfunctions
  use initializeflow_d, only : referencestate, referencestate_d
  use walldistance_d, only : updatewalldistancesquickly, xsurf
  use inputdiscretization
  use sa_d
  use inputunsteady
  use turbbcroutines_d
  use turbutils_d
  use utils_d, only : terminate
  use flowutils_d, only : adjustinflowangle, adjustinflowangle_d, &
& computepressuresimple, computepressuresimple_d, computelamviscosity, &
& computelamviscosity_d
  use solverutils_d, only : gridvelocitiesfinelevel_block, &
& gridvelocitiesfinelevel_block_d, normalvelocities_block, &
& normalvelocities_block_d, slipvelocitiesfinelevel_block, &
& slipvelocitiesfinelevel_block_d, timestep_block, timestep_block_d
  use residuals_d, only : residual_block, residual_block_d
  use surfaceintegrations_d, only : forcesandmoments, forcesandmoments_d
  use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
  implicit none
! input arguments:
  integer(kind=inttype), intent(in) :: nn, sps
  logical, intent(in) :: usespatial, frozenturb
  real(kind=realtype), intent(in) :: alpha, beta
  real(kind=realtype), intent(in) :: alphad, betad
  integer(kind=inttype), intent(in) :: liftindex
! output variables
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
& moment
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced, &
& momentd
  real(kind=realtype) :: sepsensor, cavitation, sepsensoravg(3)
  real(kind=realtype) :: sepsensord, cavitationd, sepsensoravgd(3)
! working variables
  real(kind=realtype) :: gm1, v2, fact, tmp
  real(kind=realtype) :: factd, tmpd
  integer(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj, m
  integer(kind=inttype) :: nstate
  real(kind=realtype), dimension(nsections) :: t
  logical :: useoldcoor
  real(kind=realtype), dimension(3) :: cfp, cfv, cmp, cmv
  real(kind=realtype), dimension(3) :: cfpd, cfvd, cmpd, cmvd
  real(kind=realtype) :: yplusmax, scaledim, oneoverdt
  real(kind=realtype) :: scaledimd, oneoverdtd
  intrinsic real
  integer :: ii3
  integer :: ii2
  integer :: ii1
  useoldcoor = .false.
! setup number of state variable based on turbulence assumption
  if (frozenturb) then
    nstate = nwf
  else
    nstate = nw
  end if
! set pointers to input/output variables
  wd => flowdomsd(nn, currentlevel, sps)%w
  w => flowdoms(nn, currentlevel, sps)%w
  dwd => flowdomsd(nn, 1, sps)%dw
  dw => flowdoms(nn, 1, sps)%dw
  xd => flowdomsd(nn, currentlevel, sps)%x
  x => flowdoms(nn, currentlevel, sps)%x
  vold => flowdomsd(nn, currentlevel, sps)%vol
  vol => flowdoms(nn, currentlevel, sps)%vol
! ------------------------------------------------
!        additional 'extra' components
! ------------------------------------------------ 
  call adjustinflowangle_d(alpha, alphad, beta, betad, liftindex)
  call referencestate_d()
! ------------------------------------------------
!        additional spatial components
! ------------------------------------------------
  if (usespatial) then
    call volume_block_d()
    call metric_block_d()
    call boundarynormals_d()
! -------------------------------------
! these functions are required for ts
! --------------------------------------
    t = timeunsteadyrestart
    if (equationmode .eq. timespectral) then
      do mm=1,nsections
        t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/real(&
&         ntimeintervalsspectral, realtype)
      end do
    end if
    call gridvelocitiesfinelevel_block_d(useoldcoor, t, sps)
! required for ts
    call normalvelocities_block_d(sps)
! required for ts
    call slipvelocitiesfinelevel_block_d(useoldcoor, t, sps)
  else
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          flowdomsd(ii3, ii2, ii1)%vol = 0.0_8
        end do
      end do
    end do
    sfaceid = 0.0_8
    sfacejd = 0.0_8
    sd = 0.0_8
    sfacekd = 0.0_8
    sid = 0.0_8
    sjd = 0.0_8
    skd = 0.0_8
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%norm = 0.0_8
    end do
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%rface = 0.0_8
    end do
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%uslip = 0.0_8
    end do
  end if
! ------------------------------------------------
!        normal residual computation
! ------------------------------------------------
! compute the pressures
  call computepressuresimple_d()
! compute laminar/eddy viscosity if required
  call computelamviscosity_d()
  call computeeddyviscosity_d()
  call applyallbc_block_d(.true.)
  if (equations .eq. ransequations) then
    call bcturbtreatment_d()
    call applyallturbbcthisblock_d(.true.)
  end if
! compute skin_friction velocity (only for wall functions)
! #ifndef tapenade_reverse
!   call computeutau_block
! #endif
! compute time step and spectral radius
  call timestep_block_d(.false.)
spectralloop0:do sps2=1,ntimeintervalsspectral
    flowdomsd(nn, 1, sps2)%dw(:, :, :, :) = 0.0_8
    flowdoms(nn, 1, sps2)%dw(:, :, :, :) = zero
  end do spectralloop0
! -------------------------------
! compute turbulence residual for rans equations
  if (equations .eq. ransequations) then
! ! initialize only the turblent variables
! call unsteadyturbspectral_block(itu1, itu1, nn, sps)
    select case  (turbmodel) 
    case (spalartallmaras) 
      call sa_block_d(.true.)
    case default
!case (mentersst)
! not implemented yet
!call sst_block(.true.)
      call terminate('turbresidual', &
&              'only sa turbulence adjoint implemented')
      do ii1=1,ntimeintervalsspectral
        do ii2=1,1
          do ii3=nn,nn
            flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
          end do
        end do
      end do
    end select
  else
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
        end do
      end do
    end do
  end if
! -------------------------------  
! next initialize residual for flow variables. the is the only place
! where there is an n^2 dependance. there are issues with
! initres. so only the necesary timespectral code has been copied
! here. see initres for more information and comments.
!call initres_block(1, nwf, nn, sps)
  if (equationmode .eq. steady) then
    dwd(:, :, :, 1:nwf) = 0.0_8
    dw(:, :, :, 1:nwf) = zero
  else if (equationmode .eq. timespectral) then
! zero dw on all spectral instances
spectralloop1:do sps2=1,ntimeintervalsspectral
      flowdomsd(nn, 1, sps2)%dw(:, :, :, 1:nwf) = 0.0_8
      flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
    end do spectralloop1
spectralloop2:do sps2=1,ntimeintervalsspectral
      jj = sectionid
timeloopfine:do mm=1,ntimeintervalsspectral
        ii = 3*(mm-1)
varloopfine:do l=1,nwf
          if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
            if (l .eq. ivx) ll = 3*sps2 - 2
            if (l .eq. ivy) ll = 3*sps2 - 1
            if (l .eq. ivz) ll = 3*sps2
            do k=2,kl
              do j=2,jl
                do i=2,il
                  tmpd = dvector(jj, ll, ii+1)*flowdomsd(nn, 1, mm)%w(i&
&                   , j, k, ivx) + dvector(jj, ll, ii+2)*flowdomsd(nn, 1&
&                   , mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
&                   flowdomsd(nn, 1, mm)%w(i, j, k, ivz)
                  tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i, j&
&                   , k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, 1, mm&
&                   )%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*flowdoms(&
&                   nn, 1, mm)%w(i, j, k, ivz)
                  flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
&                   1, sps2)%dw(i, j, k, l) + (tmpd*flowdoms(nn, 1, mm)%&
&                   vol(i, j, k)+tmp*flowdomsd(nn, 1, mm)%vol(i, j, k))*&
&                   flowdoms(nn, 1, mm)%w(i, j, k, irho) + tmp*flowdoms(&
&                   nn, 1, mm)%vol(i, j, k)*flowdomsd(nn, 1, mm)%w(i, j&
&                   , k, irho)
                  flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
&                   , sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%vol&
&                   (i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
                end do
              end do
            end do
          else
            do k=2,kl
              do j=2,jl
                do i=2,il
! this is: dw = dw + dscalar*vol*w
                  flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
&                   1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*(&
&                   flowdomsd(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm&
&                   )%w(i, j, k, l)+flowdoms(nn, 1, mm)%vol(i, j, k)*&
&                   flowdomsd(nn, 1, mm)%w(i, j, k, l))
                  flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
&                   , sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
&                   flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm)&
&                   %w(i, j, k, l)
                end do
              end do
            end do
          end if
        end do varloopfine
      end do timeloopfine
    end do spectralloop2
  else if (equationmode .eq. unsteady) then
! assume only md or bdf types
! store the inverse of the physical nondimensional
! time step a bit easier.
    oneoverdtd = timerefd/deltat
    oneoverdt = timeref/deltat
! ground level of the multigrid cycle. initialize the
! owned cells to the unsteady source term. first the
! term for the current time level. note that in w the
! velocities are stored and not the momentum variables.
! therefore the if-statement is present to correct this.
    do l=1,nw
      if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
! momentum variables.
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdomsd(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*((vold(&
&               i, j, k)*w(i, j, k, l)+vol(i, j, k)*wd(i, j, k, l))*w(i&
&               , j, k, irho)+vol(i, j, k)*w(i, j, k, l)*wd(i, j, k, &
&               irho))
              flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i, j&
&               , k)*w(i, j, k, l)*w(i, j, k, irho)
            end do
          end do
        end do
      else
! non-momentum variables, for which the variable
! to be solved is stored; for the flow equations this
! is the conservative variable, for the turbulent
! equations the primitive variable.
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdomsd(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*(vold(i&
&               , j, k)*w(i, j, k, l)+vol(i, j, k)*wd(i, j, k, l))
              flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i, j&
&               , k)*w(i, j, k, l)
            end do
          end do
        end do
      end if
    end do
! the terms from the older time levels. here the
! conservative variables are stored. in case of a
! deforming mesh, also the old volumes must be taken.
    if (deforming_grid) then
! mesh is deforming and thus the volumes can change.
! use the old volumes as well.
      do m=1,noldlevels
        do l=1,nw
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                 sps)%dw(i, j, k, l) + coeftime(m)*volold(m, i, j, k)*&
&                 wold(m, i, j, k, l)
              end do
            end do
          end do
        end do
      end do
    else
! rigid mesh. the volumes remain constant.
      do m=1,noldlevels
        do l=1,nw
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdomsd(nn, 1, sps)%dw(i, j, k, l) = flowdomsd(nn, 1, &
&                 sps)%dw(i, j, k, l) + coeftime(m)*wold(m, i, j, k, l)*&
&                 vold(i, j, k)
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                 sps)%dw(i, j, k, l) + coeftime(m)*vol(i, j, k)*wold(m&
&                 , i, j, k, l)
              end do
            end do
          end do
        end do
      end do
    end if
! multiply the time derivative by the inverse of the
! time step to obtain the true time derivative.
! this is done after the summation has been done, because
! otherwise you run into finite accuracy problems for
! very small time steps.
    do l=1,nw
      do k=2,kl
        do j=2,jl
          do i=2,il
            flowdomsd(nn, 1, sps)%dw(i, j, k, l) = oneoverdtd*flowdoms(&
&             nn, 1, sps)%dw(i, j, k, l) + oneoverdt*flowdomsd(nn, 1, &
&             sps)%dw(i, j, k, l)
            flowdoms(nn, 1, sps)%dw(i, j, k, l) = oneoverdt*flowdoms(nn&
&             , 1, sps)%dw(i, j, k, l)
          end do
        end do
      end do
    end do
  end if
!  actual residual calc
  call residual_block_d()
! divide through by the reference volume
  do sps2=1,ntimeintervalsspectral
    do l=1,nwf
      do k=2,kl
        do j=2,jl
          do i=2,il
            flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, 1, &
&             sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&             volref(i, j, k)
            flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, sps2)&
&             %dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%volref(i&
&             , j, k)
          end do
        end do
      end do
    end do
! treat the turblent residual with the scaling factor on the
! residual
    do l=nt1,nstate
      do k=2,kl
        do j=2,jl
          do i=2,il
            flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = turbresscale(l-nt1+1&
&             )*flowdomsd(nn, 1, sps2)%dw(i, j, k, l)/flowdoms(nn, &
&             currentlevel, sps2)%volref(i, j, k)
            flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, sps2)&
&             %dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%volref(i&
&             , j, k)*turbresscale(l-nt1+1)
          end do
        end do
      end do
    end do
  end do
  call forcesandmoments_d(cfp, cfpd, cfv, cfvd, cmp, cmpd, cmv, cmvd, &
&                   yplusmax, sepsensor, sepsensord, sepsensoravg, &
&                   sepsensoravgd, cavitation, cavitationd)
! convert back to actual forces. note that even though we use
! machcoef, lref, and surfaceref here, they are not differented,
! since f doesn't actually depend on them. ideally we would just get
! the raw forces and moment form forcesandmoments. 
  force = zero
  moment = zero
  scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
  scaledim = pref/pinf
  factd = -(two*surfaceref*lref**2*(((gammainfd*pinf+gammainf*pinfd)*&
&   scaledim+gammainf*pinf*scaledimd)*machcoef**2+gammainf*pinf*scaledim&
&   *(machcoefd*machcoef+machcoef*machcoefd))/(gammainf*pinf*machcoef*&
&   machcoef*surfaceref*lref*lref*scaledim)**2)
  fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
&   scaledim)
  forced = 0.0_8
  do sps2=1,ntimeintervalsspectral
    forced(:, sps2) = ((cfpd+cfvd)*fact-(cfp+cfv)*factd)/fact**2
    force(:, sps2) = (cfp+cfv)/fact
  end do
  factd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*lref)**&
&   2
  fact = fact/(lengthref*lref)
  momentd = 0.0_8
  do sps2=1,ntimeintervalsspectral
    momentd(:, sps2) = ((cmpd+cmvd)*fact-(cmp+cmv)*factd)/fact**2
    moment(:, sps2) = (cmp+cmv)/fact
  end do
  call getcostfunction2_d(force, forced, moment, momentd, sepsensor, &
&                   sepsensord, sepsensoravg, sepsensoravgd, cavitation&
&                   , cavitationd, alpha, beta, liftindex)
end subroutine block_res_d

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module fluxes_d
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
!  differentiation of inviscidcentralflux in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: timeref *p *dw *w *vol *si
!                *sj *sk
!   rw status of diff variables: timeref:in *p:in *dw:in-out *w:in
!                *vol:in *si:in *sj:in *sk:in
!   plus diff mem management of: p:in dw:in w:in vol:in si:in sj:in
!                sk:in
  subroutine inviscidcentralflux_d()
!
!       inviscidcentralflux computes the euler fluxes using a central  
!       discretization for a given block. therefore it is assumed that 
!       the pointers in block pointer already point to the correct     
!       block on the correct multigrid level.                          
!
    use constants
    use blockpointers, only : nx, il, ie, ny, jl, je, nz, kl, ke, &
&   spectralsol, w, wd, si, sid, sj, sjd, sk, skd, dw, dwd, pori, porj, &
&   pork, indfamilyi, indfamilyj, indfamilyk, p, pd, sfacei, sfacej, &
&   sfacek, nbkglobal, addgridvelocities, blockismoving, vol, vold, &
&   factfamilyi, factfamilyj, factfamilyk
    use cgnsgrid, only : cgnsdoms, massflowfamilyinv
    use flowvarrefstate, only : timeref, timerefd
    use inputphysics, only : equationmode
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: qsp, qsm, rqsp, rqsm, porvel, porflux
    real(kind=realtype) :: qspd, qsmd, rqspd, rqsmd
    real(kind=realtype) :: pa, fs, sface, vnp, vnm
    real(kind=realtype) :: pad, fsd, vnpd, vnmd
    real(kind=realtype) :: wwx, wwy, wwz, rvol
    real(kind=realtype) :: wwxd, wwyd, wwzd, rvold
    intrinsic mod
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
!
!       advective fluxes in the i-direction.                           
!
    do k=2,kl
      do j=2,jl
        do i=1,il
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
          if (addgridvelocities) sface = sfacei(i, j, k)
! compute the normal velocities of the left and right state.
          vnpd = wd(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivx)*&
&           sid(i, j, k, 1) + wd(i+1, j, k, ivy)*si(i, j, k, 2) + w(i+1&
&           , j, k, ivy)*sid(i, j, k, 2) + wd(i+1, j, k, ivz)*si(i, j, k&
&           , 3) + w(i+1, j, k, ivz)*sid(i, j, k, 3)
          vnp = w(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivy)*si(&
&           i, j, k, 2) + w(i+1, j, k, ivz)*si(i, j, k, 3)
          vnmd = wd(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivx)*sid(i&
&           , j, k, 1) + wd(i, j, k, ivy)*si(i, j, k, 2) + w(i, j, k, &
&           ivy)*sid(i, j, k, 2) + wd(i, j, k, ivz)*si(i, j, k, 3) + w(i&
&           , j, k, ivz)*sid(i, j, k, 3)
          vnm = w(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivy)*si(i, j&
&           , k, 2) + w(i, j, k, ivz)*si(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
          porvel = one
          porflux = half
          if (pori(i, j, k) .eq. noflux) porflux = zero
          if (pori(i, j, k) .eq. boundflux) then
            porvel = zero
            vnp = sface
            vnm = sface
            vnmd = 0.0_8
            vnpd = 0.0_8
          end if
! incorporate porflux in porvel.
          porvel = porvel*porflux
! compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
          qspd = porvel*vnpd
          qsp = (vnp-sface)*porvel
          qsmd = porvel*vnmd
          qsm = (vnm-sface)*porvel
          rqspd = qspd*w(i+1, j, k, irho) + qsp*wd(i+1, j, k, irho)
          rqsp = qsp*w(i+1, j, k, irho)
          rqsmd = qsmd*w(i, j, k, irho) + qsm*wd(i, j, k, irho)
          rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
          pad = porflux*(pd(i+1, j, k)+pd(i, j, k))
          pa = porflux*(p(i+1, j, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i+1,j,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
          fsd = rqspd + rqsmd
          fs = rqsp + rqsm
          dwd(i+1, j, k, irho) = dwd(i+1, j, k, irho) - fsd
          dw(i+1, j, k, irho) = dw(i+1, j, k, irho) - fs
          dwd(i, j, k, irho) = dwd(i, j, k, irho) + fsd
          dw(i, j, k, irho) = dw(i, j, k, irho) + fs
          fsd = rqspd*w(i+1, j, k, ivx) + rqsp*wd(i+1, j, k, ivx) + &
&           rqsmd*w(i, j, k, ivx) + rqsm*wd(i, j, k, ivx) + pad*si(i, j&
&           , k, 1) + pa*sid(i, j, k, 1)
          fs = rqsp*w(i+1, j, k, ivx) + rqsm*w(i, j, k, ivx) + pa*si(i, &
&           j, k, 1)
          dwd(i+1, j, k, imx) = dwd(i+1, j, k, imx) - fsd
          dw(i+1, j, k, imx) = dw(i+1, j, k, imx) - fs
          dwd(i, j, k, imx) = dwd(i, j, k, imx) + fsd
          dw(i, j, k, imx) = dw(i, j, k, imx) + fs
          fsd = rqspd*w(i+1, j, k, ivy) + rqsp*wd(i+1, j, k, ivy) + &
&           rqsmd*w(i, j, k, ivy) + rqsm*wd(i, j, k, ivy) + pad*si(i, j&
&           , k, 2) + pa*sid(i, j, k, 2)
          fs = rqsp*w(i+1, j, k, ivy) + rqsm*w(i, j, k, ivy) + pa*si(i, &
&           j, k, 2)
          dwd(i+1, j, k, imy) = dwd(i+1, j, k, imy) - fsd
          dw(i+1, j, k, imy) = dw(i+1, j, k, imy) - fs
          dwd(i, j, k, imy) = dwd(i, j, k, imy) + fsd
          dw(i, j, k, imy) = dw(i, j, k, imy) + fs
          fsd = rqspd*w(i+1, j, k, ivz) + rqsp*wd(i+1, j, k, ivz) + &
&           rqsmd*w(i, j, k, ivz) + rqsm*wd(i, j, k, ivz) + pad*si(i, j&
&           , k, 3) + pa*sid(i, j, k, 3)
          fs = rqsp*w(i+1, j, k, ivz) + rqsm*w(i, j, k, ivz) + pa*si(i, &
&           j, k, 3)
          dwd(i+1, j, k, imz) = dwd(i+1, j, k, imz) - fsd
          dw(i+1, j, k, imz) = dw(i+1, j, k, imz) - fs
          dwd(i, j, k, imz) = dwd(i, j, k, imz) + fsd
          dw(i, j, k, imz) = dw(i, j, k, imz) + fs
          fsd = qspd*w(i+1, j, k, irhoe) + qsp*wd(i+1, j, k, irhoe) + &
&           qsmd*w(i, j, k, irhoe) + qsm*wd(i, j, k, irhoe) + porflux*(&
&           vnpd*p(i+1, j, k)+vnp*pd(i+1, j, k)+vnmd*p(i, j, k)+vnm*pd(i&
&           , j, k))
          fs = qsp*w(i+1, j, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux&
&           *(vnp*p(i+1, j, k)+vnm*p(i, j, k))
          dwd(i+1, j, k, irhoe) = dwd(i+1, j, k, irhoe) - fsd
          dw(i+1, j, k, irhoe) = dw(i+1, j, k, irhoe) - fs
          dwd(i, j, k, irhoe) = dwd(i, j, k, irhoe) + fsd
          dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
        end do
      end do
    end do
!
!       advective fluxes in the j-direction.                           
!
    sface = zero
    do k=2,kl
      do j=1,jl
        do i=2,il
! set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
          if (addgridvelocities) sface = sfacej(i, j, k)
! compute the normal velocities of the left and right state.
          vnpd = wd(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivx)*&
&           sjd(i, j, k, 1) + wd(i, j+1, k, ivy)*sj(i, j, k, 2) + w(i, j&
&           +1, k, ivy)*sjd(i, j, k, 2) + wd(i, j+1, k, ivz)*sj(i, j, k&
&           , 3) + w(i, j+1, k, ivz)*sjd(i, j, k, 3)
          vnp = w(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivy)*sj(&
&           i, j, k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 3)
          vnmd = wd(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivx)*sjd(i&
&           , j, k, 1) + wd(i, j, k, ivy)*sj(i, j, k, 2) + w(i, j, k, &
&           ivy)*sjd(i, j, k, 2) + wd(i, j, k, ivz)*sj(i, j, k, 3) + w(i&
&           , j, k, ivz)*sjd(i, j, k, 3)
          vnm = w(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivy)*sj(i, j&
&           , k, 2) + w(i, j, k, ivz)*sj(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
          porvel = one
          porflux = half
          if (porj(i, j, k) .eq. noflux) porflux = zero
          if (porj(i, j, k) .eq. boundflux) then
            porvel = zero
            vnp = sface
            vnm = sface
            vnmd = 0.0_8
            vnpd = 0.0_8
          end if
! incorporate porflux in porvel.
          porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
          qspd = porvel*vnpd
          qsp = (vnp-sface)*porvel
          qsmd = porvel*vnmd
          qsm = (vnm-sface)*porvel
          rqspd = qspd*w(i, j+1, k, irho) + qsp*wd(i, j+1, k, irho)
          rqsp = qsp*w(i, j+1, k, irho)
          rqsmd = qsmd*w(i, j, k, irho) + qsm*wd(i, j, k, irho)
          rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
          pad = porflux*(pd(i, j+1, k)+pd(i, j, k))
          pa = porflux*(p(i, j+1, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j+1,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
          fsd = rqspd + rqsmd
          fs = rqsp + rqsm
          dwd(i, j+1, k, irho) = dwd(i, j+1, k, irho) - fsd
          dw(i, j+1, k, irho) = dw(i, j+1, k, irho) - fs
          dwd(i, j, k, irho) = dwd(i, j, k, irho) + fsd
          dw(i, j, k, irho) = dw(i, j, k, irho) + fs
          fsd = rqspd*w(i, j+1, k, ivx) + rqsp*wd(i, j+1, k, ivx) + &
&           rqsmd*w(i, j, k, ivx) + rqsm*wd(i, j, k, ivx) + pad*sj(i, j&
&           , k, 1) + pa*sjd(i, j, k, 1)
          fs = rqsp*w(i, j+1, k, ivx) + rqsm*w(i, j, k, ivx) + pa*sj(i, &
&           j, k, 1)
          dwd(i, j+1, k, imx) = dwd(i, j+1, k, imx) - fsd
          dw(i, j+1, k, imx) = dw(i, j+1, k, imx) - fs
          dwd(i, j, k, imx) = dwd(i, j, k, imx) + fsd
          dw(i, j, k, imx) = dw(i, j, k, imx) + fs
          fsd = rqspd*w(i, j+1, k, ivy) + rqsp*wd(i, j+1, k, ivy) + &
&           rqsmd*w(i, j, k, ivy) + rqsm*wd(i, j, k, ivy) + pad*sj(i, j&
&           , k, 2) + pa*sjd(i, j, k, 2)
          fs = rqsp*w(i, j+1, k, ivy) + rqsm*w(i, j, k, ivy) + pa*sj(i, &
&           j, k, 2)
          dwd(i, j+1, k, imy) = dwd(i, j+1, k, imy) - fsd
          dw(i, j+1, k, imy) = dw(i, j+1, k, imy) - fs
          dwd(i, j, k, imy) = dwd(i, j, k, imy) + fsd
          dw(i, j, k, imy) = dw(i, j, k, imy) + fs
          fsd = rqspd*w(i, j+1, k, ivz) + rqsp*wd(i, j+1, k, ivz) + &
&           rqsmd*w(i, j, k, ivz) + rqsm*wd(i, j, k, ivz) + pad*sj(i, j&
&           , k, 3) + pa*sjd(i, j, k, 3)
          fs = rqsp*w(i, j+1, k, ivz) + rqsm*w(i, j, k, ivz) + pa*sj(i, &
&           j, k, 3)
          dwd(i, j+1, k, imz) = dwd(i, j+1, k, imz) - fsd
          dw(i, j+1, k, imz) = dw(i, j+1, k, imz) - fs
          dwd(i, j, k, imz) = dwd(i, j, k, imz) + fsd
          dw(i, j, k, imz) = dw(i, j, k, imz) + fs
          fsd = qspd*w(i, j+1, k, irhoe) + qsp*wd(i, j+1, k, irhoe) + &
&           qsmd*w(i, j, k, irhoe) + qsm*wd(i, j, k, irhoe) + porflux*(&
&           vnpd*p(i, j+1, k)+vnp*pd(i, j+1, k)+vnmd*p(i, j, k)+vnm*pd(i&
&           , j, k))
          fs = qsp*w(i, j+1, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux&
&           *(vnp*p(i, j+1, k)+vnm*p(i, j, k))
          dwd(i, j+1, k, irhoe) = dwd(i, j+1, k, irhoe) - fsd
          dw(i, j+1, k, irhoe) = dw(i, j+1, k, irhoe) - fs
          dwd(i, j, k, irhoe) = dwd(i, j, k, irhoe) + fsd
          dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
        end do
      end do
    end do
!
!       advective fluxes in the k-direction.                           
    sface = zero
    do k=1,kl
      do j=2,jl
        do i=2,il
! set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
          if (addgridvelocities) sface = sfacek(i, j, k)
! compute the normal velocities of the left and right state.
          vnpd = wd(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivx)*&
&           skd(i, j, k, 1) + wd(i, j, k+1, ivy)*sk(i, j, k, 2) + w(i, j&
&           , k+1, ivy)*skd(i, j, k, 2) + wd(i, j, k+1, ivz)*sk(i, j, k&
&           , 3) + w(i, j, k+1, ivz)*skd(i, j, k, 3)
          vnp = w(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivy)*sk(&
&           i, j, k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 3)
          vnmd = wd(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivx)*skd(i&
&           , j, k, 1) + wd(i, j, k, ivy)*sk(i, j, k, 2) + w(i, j, k, &
&           ivy)*skd(i, j, k, 2) + wd(i, j, k, ivz)*sk(i, j, k, 3) + w(i&
&           , j, k, ivz)*skd(i, j, k, 3)
          vnm = w(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivy)*sk(i, j&
&           , k, 2) + w(i, j, k, ivz)*sk(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! block boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
          porvel = one
          porflux = half
          if (pork(i, j, k) .eq. noflux) porflux = zero
          if (pork(i, j, k) .eq. boundflux) then
            porvel = zero
            vnp = sface
            vnm = sface
            vnmd = 0.0_8
            vnpd = 0.0_8
          end if
! incorporate porflux in porvel.
          porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
          qspd = porvel*vnpd
          qsp = (vnp-sface)*porvel
          qsmd = porvel*vnmd
          qsm = (vnm-sface)*porvel
          rqspd = qspd*w(i, j, k+1, irho) + qsp*wd(i, j, k+1, irho)
          rqsp = qsp*w(i, j, k+1, irho)
          rqsmd = qsmd*w(i, j, k, irho) + qsm*wd(i, j, k, irho)
          rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
          pad = porflux*(pd(i, j, k+1)+pd(i, j, k))
          pa = porflux*(p(i, j, k+1)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j,k+1. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
          fsd = rqspd + rqsmd
          fs = rqsp + rqsm
          dwd(i, j, k+1, irho) = dwd(i, j, k+1, irho) - fsd
          dw(i, j, k+1, irho) = dw(i, j, k+1, irho) - fs
          dwd(i, j, k, irho) = dwd(i, j, k, irho) + fsd
          dw(i, j, k, irho) = dw(i, j, k, irho) + fs
          fsd = rqspd*w(i, j, k+1, ivx) + rqsp*wd(i, j, k+1, ivx) + &
&           rqsmd*w(i, j, k, ivx) + rqsm*wd(i, j, k, ivx) + pad*sk(i, j&
&           , k, 1) + pa*skd(i, j, k, 1)
          fs = rqsp*w(i, j, k+1, ivx) + rqsm*w(i, j, k, ivx) + pa*sk(i, &
&           j, k, 1)
          dwd(i, j, k+1, imx) = dwd(i, j, k+1, imx) - fsd
          dw(i, j, k+1, imx) = dw(i, j, k+1, imx) - fs
          dwd(i, j, k, imx) = dwd(i, j, k, imx) + fsd
          dw(i, j, k, imx) = dw(i, j, k, imx) + fs
          fsd = rqspd*w(i, j, k+1, ivy) + rqsp*wd(i, j, k+1, ivy) + &
&           rqsmd*w(i, j, k, ivy) + rqsm*wd(i, j, k, ivy) + pad*sk(i, j&
&           , k, 2) + pa*skd(i, j, k, 2)
          fs = rqsp*w(i, j, k+1, ivy) + rqsm*w(i, j, k, ivy) + pa*sk(i, &
&           j, k, 2)
          dwd(i, j, k+1, imy) = dwd(i, j, k+1, imy) - fsd
          dw(i, j, k+1, imy) = dw(i, j, k+1, imy) - fs
          dwd(i, j, k, imy) = dwd(i, j, k, imy) + fsd
          dw(i, j, k, imy) = dw(i, j, k, imy) + fs
          fsd = rqspd*w(i, j, k+1, ivz) + rqsp*wd(i, j, k+1, ivz) + &
&           rqsmd*w(i, j, k, ivz) + rqsm*wd(i, j, k, ivz) + pad*sk(i, j&
&           , k, 3) + pa*skd(i, j, k, 3)
          fs = rqsp*w(i, j, k+1, ivz) + rqsm*w(i, j, k, ivz) + pa*sk(i, &
&           j, k, 3)
          dwd(i, j, k+1, imz) = dwd(i, j, k+1, imz) - fsd
          dw(i, j, k+1, imz) = dw(i, j, k+1, imz) - fs
          dwd(i, j, k, imz) = dwd(i, j, k, imz) + fsd
          dw(i, j, k, imz) = dw(i, j, k, imz) + fs
          fsd = qspd*w(i, j, k+1, irhoe) + qsp*wd(i, j, k+1, irhoe) + &
&           qsmd*w(i, j, k, irhoe) + qsm*wd(i, j, k, irhoe) + porflux*(&
&           vnpd*p(i, j, k+1)+vnp*pd(i, j, k+1)+vnmd*p(i, j, k)+vnm*pd(i&
&           , j, k))
          fs = qsp*w(i, j, k+1, irhoe) + qsm*w(i, j, k, irhoe) + porflux&
&           *(vnp*p(i, j, k+1)+vnm*p(i, j, k))
          dwd(i, j, k+1, irhoe) = dwd(i, j, k+1, irhoe) - fsd
          dw(i, j, k+1, irhoe) = dw(i, j, k+1, irhoe) - fs
          dwd(i, j, k, irhoe) = dwd(i, j, k, irhoe) + fsd
          dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
        end do
      end do
    end do
! add the rotational source terms for a moving block in a
! steady state computation. these source terms account for the
! centrifugal acceleration and the coriolis term. however, as
! the the equations are solved in the inertial frame and not
! in the moving frame, the form is different than what you
! normally find in a text book.
    if (blockismoving .and. equationmode .eq. steady) then
! compute the three nondimensional angular velocities.
      wwxd = cgnsdoms(nbkglobal)%rotrate(1)*timerefd
      wwx = timeref*cgnsdoms(nbkglobal)%rotrate(1)
      wwyd = cgnsdoms(nbkglobal)%rotrate(2)*timerefd
      wwy = timeref*cgnsdoms(nbkglobal)%rotrate(2)
      wwzd = cgnsdoms(nbkglobal)%rotrate(3)*timerefd
      wwz = timeref*cgnsdoms(nbkglobal)%rotrate(3)
! loop over the internal cells of this block to compute the
! rotational terms for the momentum equations.
      do ii=0,nx*ny*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 2
        rvold = wd(i, j, k, irho)*vol(i, j, k) + w(i, j, k, irho)*vold(i&
&         , j, k)
        rvol = w(i, j, k, irho)*vol(i, j, k)
        dwd(i, j, k, imx) = dwd(i, j, k, imx) + rvold*(wwy*w(i, j, k, &
&         ivz)-wwz*w(i, j, k, ivy)) + rvol*(wwyd*w(i, j, k, ivz)+wwy*wd(&
&         i, j, k, ivz)-wwzd*w(i, j, k, ivy)-wwz*wd(i, j, k, ivy))
        dw(i, j, k, imx) = dw(i, j, k, imx) + rvol*(wwy*w(i, j, k, ivz)-&
&         wwz*w(i, j, k, ivy))
        dwd(i, j, k, imy) = dwd(i, j, k, imy) + rvold*(wwz*w(i, j, k, &
&         ivx)-wwx*w(i, j, k, ivz)) + rvol*(wwzd*w(i, j, k, ivx)+wwz*wd(&
&         i, j, k, ivx)-wwxd*w(i, j, k, ivz)-wwx*wd(i, j, k, ivz))
        dw(i, j, k, imy) = dw(i, j, k, imy) + rvol*(wwz*w(i, j, k, ivx)-&
&         wwx*w(i, j, k, ivz))
        dwd(i, j, k, imz) = dwd(i, j, k, imz) + rvold*(wwx*w(i, j, k, &
&         ivy)-wwy*w(i, j, k, ivx)) + rvol*(wwxd*w(i, j, k, ivy)+wwx*wd(&
&         i, j, k, ivy)-wwyd*w(i, j, k, ivx)-wwy*wd(i, j, k, ivx))
        dw(i, j, k, imz) = dw(i, j, k, imz) + rvol*(wwx*w(i, j, k, ivy)-&
&         wwy*w(i, j, k, ivx))
      end do
    end if
  end subroutine inviscidcentralflux_d
  subroutine inviscidcentralflux()
!
!       inviscidcentralflux computes the euler fluxes using a central  
!       discretization for a given block. therefore it is assumed that 
!       the pointers in block pointer already point to the correct     
!       block on the correct multigrid level.                          
!
    use constants
    use blockpointers, only : nx, il, ie, ny, jl, je, nz, kl, ke, &
&   spectralsol, w, si, sj, sk, dw, pori, porj, pork, indfamilyi, &
&   indfamilyj, indfamilyk, p, sfacei, sfacej, sfacek, nbkglobal, &
&   addgridvelocities, blockismoving, vol, factfamilyi, factfamilyj, &
&   factfamilyk
    use cgnsgrid, only : cgnsdoms, massflowfamilyinv
    use flowvarrefstate, only : timeref
    use inputphysics, only : equationmode
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: qsp, qsm, rqsp, rqsm, porvel, porflux
    real(kind=realtype) :: pa, fs, sface, vnp, vnm
    real(kind=realtype) :: wwx, wwy, wwz, rvol
    intrinsic mod
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
!
!       advective fluxes in the i-direction.                           
!
    do k=2,kl
      do j=2,jl
        do i=1,il
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
          if (addgridvelocities) sface = sfacei(i, j, k)
! compute the normal velocities of the left and right state.
          vnp = w(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivy)*si(&
&           i, j, k, 2) + w(i+1, j, k, ivz)*si(i, j, k, 3)
          vnm = w(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivy)*si(i, j&
&           , k, 2) + w(i, j, k, ivz)*si(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
          porvel = one
          porflux = half
          if (pori(i, j, k) .eq. noflux) porflux = zero
          if (pori(i, j, k) .eq. boundflux) then
            porvel = zero
            vnp = sface
            vnm = sface
          end if
! incorporate porflux in porvel.
          porvel = porvel*porflux
! compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
          qsp = (vnp-sface)*porvel
          qsm = (vnm-sface)*porvel
          rqsp = qsp*w(i+1, j, k, irho)
          rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
          pa = porflux*(p(i+1, j, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i+1,j,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
          fs = rqsp + rqsm
          dw(i+1, j, k, irho) = dw(i+1, j, k, irho) - fs
          dw(i, j, k, irho) = dw(i, j, k, irho) + fs
          fs = rqsp*w(i+1, j, k, ivx) + rqsm*w(i, j, k, ivx) + pa*si(i, &
&           j, k, 1)
          dw(i+1, j, k, imx) = dw(i+1, j, k, imx) - fs
          dw(i, j, k, imx) = dw(i, j, k, imx) + fs
          fs = rqsp*w(i+1, j, k, ivy) + rqsm*w(i, j, k, ivy) + pa*si(i, &
&           j, k, 2)
          dw(i+1, j, k, imy) = dw(i+1, j, k, imy) - fs
          dw(i, j, k, imy) = dw(i, j, k, imy) + fs
          fs = rqsp*w(i+1, j, k, ivz) + rqsm*w(i, j, k, ivz) + pa*si(i, &
&           j, k, 3)
          dw(i+1, j, k, imz) = dw(i+1, j, k, imz) - fs
          dw(i, j, k, imz) = dw(i, j, k, imz) + fs
          fs = qsp*w(i+1, j, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux&
&           *(vnp*p(i+1, j, k)+vnm*p(i, j, k))
          dw(i+1, j, k, irhoe) = dw(i+1, j, k, irhoe) - fs
          dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
        end do
      end do
    end do
!
!       advective fluxes in the j-direction.                           
!
    continue
    sface = zero
    do k=2,kl
      do j=1,jl
        do i=2,il
! set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
          if (addgridvelocities) sface = sfacej(i, j, k)
! compute the normal velocities of the left and right state.
          vnp = w(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivy)*sj(&
&           i, j, k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 3)
          vnm = w(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivy)*sj(i, j&
&           , k, 2) + w(i, j, k, ivz)*sj(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
          porvel = one
          porflux = half
          if (porj(i, j, k) .eq. noflux) porflux = zero
          if (porj(i, j, k) .eq. boundflux) then
            porvel = zero
            vnp = sface
            vnm = sface
          end if
! incorporate porflux in porvel.
          porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
          qsp = (vnp-sface)*porvel
          qsm = (vnm-sface)*porvel
          rqsp = qsp*w(i, j+1, k, irho)
          rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
          pa = porflux*(p(i, j+1, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j+1,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
          fs = rqsp + rqsm
          dw(i, j+1, k, irho) = dw(i, j+1, k, irho) - fs
          dw(i, j, k, irho) = dw(i, j, k, irho) + fs
          fs = rqsp*w(i, j+1, k, ivx) + rqsm*w(i, j, k, ivx) + pa*sj(i, &
&           j, k, 1)
          dw(i, j+1, k, imx) = dw(i, j+1, k, imx) - fs
          dw(i, j, k, imx) = dw(i, j, k, imx) + fs
          fs = rqsp*w(i, j+1, k, ivy) + rqsm*w(i, j, k, ivy) + pa*sj(i, &
&           j, k, 2)
          dw(i, j+1, k, imy) = dw(i, j+1, k, imy) - fs
          dw(i, j, k, imy) = dw(i, j, k, imy) + fs
          fs = rqsp*w(i, j+1, k, ivz) + rqsm*w(i, j, k, ivz) + pa*sj(i, &
&           j, k, 3)
          dw(i, j+1, k, imz) = dw(i, j+1, k, imz) - fs
          dw(i, j, k, imz) = dw(i, j, k, imz) + fs
          fs = qsp*w(i, j+1, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux&
&           *(vnp*p(i, j+1, k)+vnm*p(i, j, k))
          dw(i, j+1, k, irhoe) = dw(i, j+1, k, irhoe) - fs
          dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
        end do
      end do
    end do
!
!       advective fluxes in the k-direction.                           
    continue
    sface = zero
    do k=1,kl
      do j=2,jl
        do i=2,il
! set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
          if (addgridvelocities) sface = sfacek(i, j, k)
! compute the normal velocities of the left and right state.
          vnp = w(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivy)*sk(&
&           i, j, k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 3)
          vnm = w(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivy)*sk(i, j&
&           , k, 2) + w(i, j, k, ivz)*sk(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! block boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
          porvel = one
          porflux = half
          if (pork(i, j, k) .eq. noflux) porflux = zero
          if (pork(i, j, k) .eq. boundflux) then
            porvel = zero
            vnp = sface
            vnm = sface
          end if
! incorporate porflux in porvel.
          porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
          qsp = (vnp-sface)*porvel
          qsm = (vnm-sface)*porvel
          rqsp = qsp*w(i, j, k+1, irho)
          rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
          pa = porflux*(p(i, j, k+1)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j,k+1. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
          fs = rqsp + rqsm
          dw(i, j, k+1, irho) = dw(i, j, k+1, irho) - fs
          dw(i, j, k, irho) = dw(i, j, k, irho) + fs
          fs = rqsp*w(i, j, k+1, ivx) + rqsm*w(i, j, k, ivx) + pa*sk(i, &
&           j, k, 1)
          dw(i, j, k+1, imx) = dw(i, j, k+1, imx) - fs
          dw(i, j, k, imx) = dw(i, j, k, imx) + fs
          fs = rqsp*w(i, j, k+1, ivy) + rqsm*w(i, j, k, ivy) + pa*sk(i, &
&           j, k, 2)
          dw(i, j, k+1, imy) = dw(i, j, k+1, imy) - fs
          dw(i, j, k, imy) = dw(i, j, k, imy) + fs
          fs = rqsp*w(i, j, k+1, ivz) + rqsm*w(i, j, k, ivz) + pa*sk(i, &
&           j, k, 3)
          dw(i, j, k+1, imz) = dw(i, j, k+1, imz) - fs
          dw(i, j, k, imz) = dw(i, j, k, imz) + fs
          fs = qsp*w(i, j, k+1, irhoe) + qsm*w(i, j, k, irhoe) + porflux&
&           *(vnp*p(i, j, k+1)+vnm*p(i, j, k))
          dw(i, j, k+1, irhoe) = dw(i, j, k+1, irhoe) - fs
          dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
        end do
      end do
    end do
! add the rotational source terms for a moving block in a
! steady state computation. these source terms account for the
! centrifugal acceleration and the coriolis term. however, as
! the the equations are solved in the inertial frame and not
! in the moving frame, the form is different than what you
! normally find in a text book.
    continue
    if (blockismoving .and. equationmode .eq. steady) then
! compute the three nondimensional angular velocities.
      wwx = timeref*cgnsdoms(nbkglobal)%rotrate(1)
      wwy = timeref*cgnsdoms(nbkglobal)%rotrate(2)
      wwz = timeref*cgnsdoms(nbkglobal)%rotrate(3)
! loop over the internal cells of this block to compute the
! rotational terms for the momentum equations.
      do ii=0,nx*ny*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 2
        rvol = w(i, j, k, irho)*vol(i, j, k)
        dw(i, j, k, imx) = dw(i, j, k, imx) + rvol*(wwy*w(i, j, k, ivz)-&
&         wwz*w(i, j, k, ivy))
        dw(i, j, k, imy) = dw(i, j, k, imy) + rvol*(wwz*w(i, j, k, ivx)-&
&         wwx*w(i, j, k, ivz))
        dw(i, j, k, imz) = dw(i, j, k, imz) + rvol*(wwx*w(i, j, k, ivy)-&
&         wwy*w(i, j, k, ivx))
      end do
    end if
  end subroutine inviscidcentralflux
!  differentiation of invisciddissfluxmatrix in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw
!   with respect to varying inputs: pinfcorr *p *w *si *sj *sk
!                *fw
!   rw status of diff variables: pinfcorr:in *p:in *w:in *si:in
!                *sj:in *sk:in *fw:in-out
!   plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
  subroutine invisciddissfluxmatrix_d()
!
!       invisciddissfluxmatrix computes the matrix artificial          
!       dissipation term. instead of the spectral radius, as used in   
!       the scalar dissipation scheme, the absolute value of the flux  
!       jacobian is used. this leads to a less diffusive and           
!       consequently more accurate scheme. it is assumed that the      
!       pointers in blockpointers already point to the correct block.  
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, wd, p, pd, pori, porj, pork, fw, fwd, gamma, si, sid, sj,&
&   sjd, sk, skd, indfamilyi, indfamilyj, indfamilyk, spectralsol, &
&   addgridvelocities, sfacei, sfacej, sfacek, factfamilyi, factfamilyj,&
&   factfamilyk
    use flowvarrefstate, only : pinfcorr, pinfcorrd
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use cgnsgrid, only : massflowfamilydiss
    use utils_d, only : getcorrectfork, mydim, mydim_d
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: plimd, sfaced
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: rradd, dis2d, dis4d
    real(kind=realtype) :: dp1, dp2, tmp, fs
    real(kind=realtype) :: tmpd, fsd
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, ddw6
    real(kind=realtype) :: ddw1d, ddw2d, ddw3d, ddw4d, ddw5d, ddw6d
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd, sxd, syd, &
&   szd
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d, aread
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
&   abv7d
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    real(kind=realtype), dimension(ie, je, ke, 3) :: dssd
    logical :: correctfork
    intrinsic abs
    intrinsic max
    intrinsic min
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: max10d
    real(kind=realtype) :: abs1d
    real(kind=realtype) :: max2d
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: abs4d
    real(kind=realtype) :: max5d
    real(kind=realtype) :: min1d
    real(kind=realtype) :: max8d
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x1
    real(kind=realtype) :: y3d
    real(kind=realtype) :: max12d
    real(kind=realtype) :: max1d
    real(kind=realtype) :: abs3d
    real(kind=realtype) :: max4d
    real(kind=realtype) :: abs6d
    real(kind=realtype) :: max7d
    real(kind=realtype) :: x1d
    real(kind=realtype) :: min3d
    real(kind=realtype) :: y2d
    real(kind=realtype) :: max11d
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs2d
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max3d
    real(kind=realtype) :: max9
    real(kind=realtype) :: abs5d
    real(kind=realtype) :: max8
    real(kind=realtype) :: max7
    real(kind=realtype) :: max6
    real(kind=realtype) :: max6d
    real(kind=realtype) :: max5
    real(kind=realtype) :: max4
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: max12
    real(kind=realtype) :: max11
    real(kind=realtype) :: min2d
    real(kind=realtype) :: max10
    real(kind=realtype) :: max9d
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: x3d
    real(kind=realtype) :: y1
    real(kind=realtype) :: y1d
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plimd = 0.001_realtype*pinfcorrd
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. 
      fwd = sfil*fwd
      fw = sfil*fw
      dssd = 0.0_8
! compute the pressure sensor for each cell, in each direction:
      do k=1,ke
        do j=1,je
          do i=1,ie
            if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
              abs1d = pd(i+1, j, k) - pd(i, j, k)
              abs1 = p(i+1, j, k) - p(i, j, k)
            else
              abs1d = -(pd(i+1, j, k)-pd(i, j, k))
              abs1 = -(p(i+1, j, k)-p(i, j, k))
            end if
            if (p(i, j, k) - p(i-1, j, k) .ge. 0.) then
              abs4d = pd(i, j, k) - pd(i-1, j, k)
              abs4 = p(i, j, k) - p(i-1, j, k)
            else
              abs4d = -(pd(i, j, k)-pd(i-1, j, k))
              abs4 = -(p(i, j, k)-p(i-1, j, k))
            end if
            x1d = ((pd(i+1, j, k)-two*pd(i, j, k)+pd(i-1, j, k))*(omega*&
&             (p(i+1, j, k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(&
&             abs1+abs4)+plim)-(p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k)&
&             )*(omega*(pd(i+1, j, k)+two*pd(i, j, k)+pd(i-1, j, k))+&
&             oneminomega*(abs1d+abs4d)+plimd))/(omega*(p(i+1, j, k)+two&
&             *p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+abs4)+plim)**2
            x1 = (p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))/(omega*(p(i+&
&             1, j, k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+&
&             abs4)+plim)
            if (x1 .ge. 0.) then
              dssd(i, j, k, 1) = x1d
              dss(i, j, k, 1) = x1
            else
              dssd(i, j, k, 1) = -x1d
              dss(i, j, k, 1) = -x1
            end if
            if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
              abs2d = pd(i, j+1, k) - pd(i, j, k)
              abs2 = p(i, j+1, k) - p(i, j, k)
            else
              abs2d = -(pd(i, j+1, k)-pd(i, j, k))
              abs2 = -(p(i, j+1, k)-p(i, j, k))
            end if
            if (p(i, j, k) - p(i, j-1, k) .ge. 0.) then
              abs5d = pd(i, j, k) - pd(i, j-1, k)
              abs5 = p(i, j, k) - p(i, j-1, k)
            else
              abs5d = -(pd(i, j, k)-pd(i, j-1, k))
              abs5 = -(p(i, j, k)-p(i, j-1, k))
            end if
            x2d = ((pd(i, j+1, k)-two*pd(i, j, k)+pd(i, j-1, k))*(omega*&
&             (p(i, j+1, k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(&
&             abs2+abs5)+plim)-(p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k)&
&             )*(omega*(pd(i, j+1, k)+two*pd(i, j, k)+pd(i, j-1, k))+&
&             oneminomega*(abs2d+abs5d)+plimd))/(omega*(p(i, j+1, k)+two&
&             *p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+abs5)+plim)**2
            x2 = (p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))/(omega*(p(i&
&             , j+1, k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+&
&             abs5)+plim)
            if (x2 .ge. 0.) then
              dssd(i, j, k, 2) = x2d
              dss(i, j, k, 2) = x2
            else
              dssd(i, j, k, 2) = -x2d
              dss(i, j, k, 2) = -x2
            end if
            if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
              abs3d = pd(i, j, k+1) - pd(i, j, k)
              abs3 = p(i, j, k+1) - p(i, j, k)
            else
              abs3d = -(pd(i, j, k+1)-pd(i, j, k))
              abs3 = -(p(i, j, k+1)-p(i, j, k))
            end if
            if (p(i, j, k) - p(i, j, k-1) .ge. 0.) then
              abs6d = pd(i, j, k) - pd(i, j, k-1)
              abs6 = p(i, j, k) - p(i, j, k-1)
            else
              abs6d = -(pd(i, j, k)-pd(i, j, k-1))
              abs6 = -(p(i, j, k)-p(i, j, k-1))
            end if
            x3d = ((pd(i, j, k+1)-two*pd(i, j, k)+pd(i, j, k-1))*(omega*&
&             (p(i, j, k+1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(&
&             abs3+abs6)+plim)-(p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1)&
&             )*(omega*(pd(i, j, k+1)+two*pd(i, j, k)+pd(i, j, k-1))+&
&             oneminomega*(abs3d+abs6d)+plimd))/(omega*(p(i, j, k+1)+two&
&             *p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+abs6)+plim)**2
            x3 = (p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))/(omega*(p(i&
&             , j, k+1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+&
&             abs6)+plim)
            if (x3 .ge. 0.) then
              dssd(i, j, k, 3) = x3d
              dss(i, j, k, 3) = x3
            else
              dssd(i, j, k, 3) = -x3d
              dss(i, j, k, 3) = -x3
            end if
          end do
        end do
      end do
      sfaced = 0.0_8
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          do i=1,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = one
            if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
              y1d = dssd(i+1, j, k, 1)
              y1 = dss(i+1, j, k, 1)
            else
              y1d = dssd(i, j, k, 1)
              y1 = dss(i, j, k, 1)
            end if
            if (dpmax .gt. y1) then
              min1d = y1d
              min1 = y1
            else
              min1 = dpmax
              min1d = 0.0_8
            end if
            dis2d = ppor*fis2*min1d
            dis2 = ppor*fis2*min1
            dis4d = mydim_d(ppor*fis4, 0.0_8, dis2, dis2d, dis4)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw1d = wd(i+1, j, k, irho) - wd(i, j, k, irho)
            ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
            drd = dis2d*ddw1 + dis2*ddw1d - dis4d*(w(i+2, j, k, irho)-w(&
&             i-1, j, k, irho)-three*ddw1) - dis4*(wd(i+2, j, k, irho)-&
&             wd(i-1, j, k, irho)-three*ddw1d)
            dr = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)&
&             -three*ddw1)
            ddw2d = wd(i+1, j, k, irho)*w(i+1, j, k, ivx) + w(i+1, j, k&
&             , irho)*wd(i+1, j, k, ivx) - wd(i, j, k, irho)*w(i, j, k, &
&             ivx) - w(i, j, k, irho)*wd(i, j, k, ivx)
            ddw2 = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, &
&             irho)*w(i, j, k, ivx)
            drud = dis2d*ddw2 + dis2*ddw2d - dis4d*(w(i+2, j, k, irho)*w&
&             (i+2, j, k, ivx)-w(i-1, j, k, irho)*w(i-1, j, k, ivx)-&
&             three*ddw2) - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, ivx)+&
&             w(i+2, j, k, irho)*wd(i+2, j, k, ivx)-wd(i-1, j, k, irho)*&
&             w(i-1, j, k, ivx)-w(i-1, j, k, irho)*wd(i-1, j, k, ivx)-&
&             three*ddw2d)
            dru = dis2*ddw2 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw2)
            ddw3d = wd(i+1, j, k, irho)*w(i+1, j, k, ivy) + w(i+1, j, k&
&             , irho)*wd(i+1, j, k, ivy) - wd(i, j, k, irho)*w(i, j, k, &
&             ivy) - w(i, j, k, irho)*wd(i, j, k, ivy)
            ddw3 = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, &
&             irho)*w(i, j, k, ivy)
            drvd = dis2d*ddw3 + dis2*ddw3d - dis4d*(w(i+2, j, k, irho)*w&
&             (i+2, j, k, ivy)-w(i-1, j, k, irho)*w(i-1, j, k, ivy)-&
&             three*ddw3) - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, ivy)+&
&             w(i+2, j, k, irho)*wd(i+2, j, k, ivy)-wd(i-1, j, k, irho)*&
&             w(i-1, j, k, ivy)-w(i-1, j, k, irho)*wd(i-1, j, k, ivy)-&
&             three*ddw3d)
            drv = dis2*ddw3 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw3)
            ddw4d = wd(i+1, j, k, irho)*w(i+1, j, k, ivz) + w(i+1, j, k&
&             , irho)*wd(i+1, j, k, ivz) - wd(i, j, k, irho)*w(i, j, k, &
&             ivz) - w(i, j, k, irho)*wd(i, j, k, ivz)
            ddw4 = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, &
&             irho)*w(i, j, k, ivz)
            drwd = dis2d*ddw4 + dis2*ddw4d - dis4d*(w(i+2, j, k, irho)*w&
&             (i+2, j, k, ivz)-w(i-1, j, k, irho)*w(i-1, j, k, ivz)-&
&             three*ddw4) - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, ivz)+&
&             w(i+2, j, k, irho)*wd(i+2, j, k, ivz)-wd(i-1, j, k, irho)*&
&             w(i-1, j, k, ivz)-w(i-1, j, k, irho)*wd(i-1, j, k, ivz)-&
&             three*ddw4d)
            drw = dis2*ddw4 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw4)
            ddw5d = wd(i+1, j, k, irhoe) - wd(i, j, k, irhoe)
            ddw5 = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            dred = dis2d*ddw5 + dis2*ddw5d - dis4d*(w(i+2, j, k, irhoe)-&
&             w(i-1, j, k, irhoe)-three*ddw5) - dis4*(wd(i+2, j, k, &
&             irhoe)-wd(i-1, j, k, irhoe)-three*ddw5d)
            dre = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, &
&             irhoe)-three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw6d = wd(i+1, j, k, irho)*w(i+1, j, k, itu1) + w(i+1, j&
&               , k, irho)*wd(i+1, j, k, itu1) - wd(i, j, k, irho)*w(i, &
&               j, k, itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
              ddw6 = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drkd = dis2d*ddw6 + dis2*ddw6d - dis4d*(w(i+2, j, k, irho)&
&               *w(i+2, j, k, itu1)-w(i-1, j, k, irho)*w(i-1, j, k, itu1&
&               )-three*ddw6) - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, &
&               itu1)+w(i+2, j, k, irho)*wd(i+2, j, k, itu1)-wd(i-1, j, &
&               k, irho)*w(i-1, j, k, itu1)-w(i-1, j, k, irho)*wd(i-1, j&
&               , k, itu1)-three*ddw6d)
              drk = dis2*ddw6 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, &
&               itu1)-w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw6)
              kavgd = half*(wd(i, j, k, itu1)+wd(i+1, j, k, itu1))
              kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
            else
              drk = zero
              kavg = zero
              kavgd = 0.0_8
              drkd = 0.0_8
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavgd = half*(wd(i+1, j, k, ivx)+wd(i, j, k, ivx))
            uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
            vavgd = half*(wd(i+1, j, k, ivy)+wd(i, j, k, ivy))
            vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
            wavgd = half*(wd(i+1, j, k, ivz)+wd(i, j, k, ivz))
            wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
            a2avgd = half*((gamma(i+1, j, k)*pd(i+1, j, k)*w(i+1, j, k, &
&             irho)-gamma(i+1, j, k)*p(i+1, j, k)*wd(i+1, j, k, irho))/w&
&             (i+1, j, k, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k&
&             , irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, &
&             j, k, irho)**2)
            a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            arg1d = 2*si(i, j, k, 1)*sid(i, j, k, 1) + 2*si(i, j, k, 2)*&
&             sid(i, j, k, 2) + 2*si(i, j, k, 3)*sid(i, j, k, 3)
            arg1 = si(i, j, k, 1)**2 + si(i, j, k, 2)**2 + si(i, j, k, 3&
&             )**2
            if (arg1 .eq. 0.0_8) then
              aread = 0.0_8
            else
              aread = arg1d/(2.0*sqrt(arg1))
            end if
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max1d = aread
              max1 = area
            else
              max1 = 1.e-25_realtype
              max1d = 0.0_8
            end if
            tmpd = -(one*max1d/max1**2)
            tmp = one/max1
            sxd = sid(i, j, k, 1)*tmp + si(i, j, k, 1)*tmpd
            sx = si(i, j, k, 1)*tmp
            syd = sid(i, j, k, 2)*tmp + si(i, j, k, 2)*tmpd
            sy = si(i, j, k, 2)*tmp
            szd = sid(i, j, k, 3)*tmp + si(i, j, k, 3)*tmpd
            sz = si(i, j, k, 3)*tmp
            alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            if (a2avg .eq. 0.0_8) then
              aavgd = 0.0_8
            else
              aavgd = a2avgd/(2.0*sqrt(a2avg))
            end if
            aavg = sqrt(a2avg)
            unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*&
&             sz + wavg*szd
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavgd = -(one*aavgd/aavg**2)
            ovaavg = one/aavg
            ova2avgd = -(one*a2avgd/a2avg**2)
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) then
              sfaced = sfacei(i, j, k)*tmpd
              sface = sfacei(i, j, k)*tmp
            end if
            if (unavg - sface + aavg .ge. 0.) then
              lam1d = unavgd - sfaced + aavgd
              lam1 = unavg - sface + aavg
            else
              lam1d = -(unavgd-sfaced+aavgd)
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2d = unavgd - sfaced - aavgd
              lam2 = unavg - sface - aavg
            else
              lam2d = -(unavgd-sfaced-aavgd)
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3d = unavgd - sfaced
              lam3 = unavg - sface
            else
              lam3d = -(unavgd-sfaced)
              lam3 = -(unavg-sface)
            end if
            rradd = lam3d + aavgd
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              max2d = epsacoustic*rradd
              max2 = epsacoustic*rrad
            else
              max2d = lam1d
              max2 = lam1
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1d = max2d*area + max2*aread
            lam1 = max2*area
            if (lam2 .lt. epsacoustic*rrad) then
              max3d = epsacoustic*rradd
              max3 = epsacoustic*rrad
            else
              max3d = lam2d
              max3 = lam2
            end if
            lam2d = max3d*area + max3*aread
            lam2 = max3*area
            if (lam3 .lt. epsshear*rrad) then
              max4d = epsshear*rradd
              max4 = epsshear*rrad
            else
              max4d = lam3d
              max4 = lam3
            end if
            lam3d = max4d*area + max4*aread
            lam3 = max4*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1d = half*(lam1d+lam2d)
            abv1 = half*(lam1+lam2)
            abv2d = half*(lam1d-lam2d)
            abv2 = half*(lam1-lam2)
            abv3d = abv1d - lam3d
            abv3 = abv1 - lam3
            abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&             vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz&
&             *drwd - unavgd*dr - unavg*drd
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd&
&             + (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd +&
&             abv3d*abv5 + abv3*abv5d
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fsd = lam3d*dr + lam3*drd + abv6d
            fs = lam3*dr + abv6
            fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) + fsd
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sxd*&
&             abv7 + sx*abv7d
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fsd
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + syd*&
&             abv7 + sy*abv7d
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fsd
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + szd*&
&             abv7 + sz*abv7d
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fsd
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + &
&             unavgd*abv7 + unavg*abv7d
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + fsd
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do j=1,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = one
            if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
              y2d = dssd(i, j+1, k, 2)
              y2 = dss(i, j+1, k, 2)
            else
              y2d = dssd(i, j, k, 2)
              y2 = dss(i, j, k, 2)
            end if
            if (dpmax .gt. y2) then
              min2d = y2d
              min2 = y2
            else
              min2 = dpmax
              min2d = 0.0_8
            end if
            dis2d = ppor*fis2*min2d
            dis2 = ppor*fis2*min2
            dis4d = mydim_d(ppor*fis4, 0.0_8, dis2, dis2d, dis4)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw1d = wd(i, j+1, k, irho) - wd(i, j, k, irho)
            ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
            drd = dis2d*ddw1 + dis2*ddw1d - dis4d*(w(i, j+2, k, irho)-w(&
&             i, j-1, k, irho)-three*ddw1) - dis4*(wd(i, j+2, k, irho)-&
&             wd(i, j-1, k, irho)-three*ddw1d)
            dr = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)&
&             -three*ddw1)
            ddw2d = wd(i, j+1, k, irho)*w(i, j+1, k, ivx) + w(i, j+1, k&
&             , irho)*wd(i, j+1, k, ivx) - wd(i, j, k, irho)*w(i, j, k, &
&             ivx) - w(i, j, k, irho)*wd(i, j, k, ivx)
            ddw2 = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, &
&             irho)*w(i, j, k, ivx)
            drud = dis2d*ddw2 + dis2*ddw2d - dis4d*(w(i, j+2, k, irho)*w&
&             (i, j+2, k, ivx)-w(i, j-1, k, irho)*w(i, j-1, k, ivx)-&
&             three*ddw2) - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, ivx)+&
&             w(i, j+2, k, irho)*wd(i, j+2, k, ivx)-wd(i, j-1, k, irho)*&
&             w(i, j-1, k, ivx)-w(i, j-1, k, irho)*wd(i, j-1, k, ivx)-&
&             three*ddw2d)
            dru = dis2*ddw2 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw2)
            ddw3d = wd(i, j+1, k, irho)*w(i, j+1, k, ivy) + w(i, j+1, k&
&             , irho)*wd(i, j+1, k, ivy) - wd(i, j, k, irho)*w(i, j, k, &
&             ivy) - w(i, j, k, irho)*wd(i, j, k, ivy)
            ddw3 = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, &
&             irho)*w(i, j, k, ivy)
            drvd = dis2d*ddw3 + dis2*ddw3d - dis4d*(w(i, j+2, k, irho)*w&
&             (i, j+2, k, ivy)-w(i, j-1, k, irho)*w(i, j-1, k, ivy)-&
&             three*ddw3) - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, ivy)+&
&             w(i, j+2, k, irho)*wd(i, j+2, k, ivy)-wd(i, j-1, k, irho)*&
&             w(i, j-1, k, ivy)-w(i, j-1, k, irho)*wd(i, j-1, k, ivy)-&
&             three*ddw3d)
            drv = dis2*ddw3 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw3)
            ddw4d = wd(i, j+1, k, irho)*w(i, j+1, k, ivz) + w(i, j+1, k&
&             , irho)*wd(i, j+1, k, ivz) - wd(i, j, k, irho)*w(i, j, k, &
&             ivz) - w(i, j, k, irho)*wd(i, j, k, ivz)
            ddw4 = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, &
&             irho)*w(i, j, k, ivz)
            drwd = dis2d*ddw4 + dis2*ddw4d - dis4d*(w(i, j+2, k, irho)*w&
&             (i, j+2, k, ivz)-w(i, j-1, k, irho)*w(i, j-1, k, ivz)-&
&             three*ddw4) - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, ivz)+&
&             w(i, j+2, k, irho)*wd(i, j+2, k, ivz)-wd(i, j-1, k, irho)*&
&             w(i, j-1, k, ivz)-w(i, j-1, k, irho)*wd(i, j-1, k, ivz)-&
&             three*ddw4d)
            drw = dis2*ddw4 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw4)
            ddw5d = wd(i, j+1, k, irhoe) - wd(i, j, k, irhoe)
            ddw5 = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            dred = dis2d*ddw5 + dis2*ddw5d - dis4d*(w(i, j+2, k, irhoe)-&
&             w(i, j-1, k, irhoe)-three*ddw5) - dis4*(wd(i, j+2, k, &
&             irhoe)-wd(i, j-1, k, irhoe)-three*ddw5d)
            dre = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, &
&             irhoe)-three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw6d = wd(i, j+1, k, irho)*w(i, j+1, k, itu1) + w(i, j+1&
&               , k, irho)*wd(i, j+1, k, itu1) - wd(i, j, k, irho)*w(i, &
&               j, k, itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
              ddw6 = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drkd = dis2d*ddw6 + dis2*ddw6d - dis4d*(w(i, j+2, k, irho)&
&               *w(i, j+2, k, itu1)-w(i, j-1, k, irho)*w(i, j-1, k, itu1&
&               )-three*ddw6) - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, &
&               itu1)+w(i, j+2, k, irho)*wd(i, j+2, k, itu1)-wd(i, j-1, &
&               k, irho)*w(i, j-1, k, itu1)-w(i, j-1, k, irho)*wd(i, j-1&
&               , k, itu1)-three*ddw6d)
              drk = dis2*ddw6 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, &
&               itu1)-w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw6)
              kavgd = half*(wd(i, j, k, itu1)+wd(i, j+1, k, itu1))
              kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
            else
              drk = zero
              kavg = zero
              kavgd = 0.0_8
              drkd = 0.0_8
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavgd = half*(wd(i, j+1, k, ivx)+wd(i, j, k, ivx))
            uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
            vavgd = half*(wd(i, j+1, k, ivy)+wd(i, j, k, ivy))
            vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
            wavgd = half*(wd(i, j+1, k, ivz)+wd(i, j, k, ivz))
            wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
            a2avgd = half*((gamma(i, j+1, k)*pd(i, j+1, k)*w(i, j+1, k, &
&             irho)-gamma(i, j+1, k)*p(i, j+1, k)*wd(i, j+1, k, irho))/w&
&             (i, j+1, k, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k&
&             , irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, &
&             j, k, irho)**2)
            a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            arg1d = 2*sj(i, j, k, 1)*sjd(i, j, k, 1) + 2*sj(i, j, k, 2)*&
&             sjd(i, j, k, 2) + 2*sj(i, j, k, 3)*sjd(i, j, k, 3)
            arg1 = sj(i, j, k, 1)**2 + sj(i, j, k, 2)**2 + sj(i, j, k, 3&
&             )**2
            if (arg1 .eq. 0.0_8) then
              aread = 0.0_8
            else
              aread = arg1d/(2.0*sqrt(arg1))
            end if
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max5d = aread
              max5 = area
            else
              max5 = 1.e-25_realtype
              max5d = 0.0_8
            end if
            tmpd = -(one*max5d/max5**2)
            tmp = one/max5
            sxd = sjd(i, j, k, 1)*tmp + sj(i, j, k, 1)*tmpd
            sx = sj(i, j, k, 1)*tmp
            syd = sjd(i, j, k, 2)*tmp + sj(i, j, k, 2)*tmpd
            sy = sj(i, j, k, 2)*tmp
            szd = sjd(i, j, k, 3)*tmp + sj(i, j, k, 3)*tmpd
            sz = sj(i, j, k, 3)*tmp
            alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            if (a2avg .eq. 0.0_8) then
              aavgd = 0.0_8
            else
              aavgd = a2avgd/(2.0*sqrt(a2avg))
            end if
            aavg = sqrt(a2avg)
            unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*&
&             sz + wavg*szd
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavgd = -(one*aavgd/aavg**2)
            ovaavg = one/aavg
            ova2avgd = -(one*a2avgd/a2avg**2)
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) then
              sfaced = sfacej(i, j, k)*tmpd
              sface = sfacej(i, j, k)*tmp
            end if
            if (unavg - sface + aavg .ge. 0.) then
              lam1d = unavgd - sfaced + aavgd
              lam1 = unavg - sface + aavg
            else
              lam1d = -(unavgd-sfaced+aavgd)
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2d = unavgd - sfaced - aavgd
              lam2 = unavg - sface - aavg
            else
              lam2d = -(unavgd-sfaced-aavgd)
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3d = unavgd - sfaced
              lam3 = unavg - sface
            else
              lam3d = -(unavgd-sfaced)
              lam3 = -(unavg-sface)
            end if
            rradd = lam3d + aavgd
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              max6d = epsacoustic*rradd
              max6 = epsacoustic*rrad
            else
              max6d = lam1d
              max6 = lam1
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1d = max6d*area + max6*aread
            lam1 = max6*area
            if (lam2 .lt. epsacoustic*rrad) then
              max7d = epsacoustic*rradd
              max7 = epsacoustic*rrad
            else
              max7d = lam2d
              max7 = lam2
            end if
            lam2d = max7d*area + max7*aread
            lam2 = max7*area
            if (lam3 .lt. epsshear*rrad) then
              max8d = epsshear*rradd
              max8 = epsshear*rrad
            else
              max8d = lam3d
              max8 = lam3
            end if
            lam3d = max8d*area + max8*aread
            lam3 = max8*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1d = half*(lam1d+lam2d)
            abv1 = half*(lam1+lam2)
            abv2d = half*(lam1d-lam2d)
            abv2 = half*(lam1-lam2)
            abv3d = abv1d - lam3d
            abv3 = abv1 - lam3
            abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&             vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz&
&             *drwd - unavgd*dr - unavg*drd
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd&
&             + (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd +&
&             abv3d*abv5 + abv3*abv5d
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fsd = lam3d*dr + lam3*drd + abv6d
            fs = lam3*dr + abv6
            fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) + fsd
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sxd*&
&             abv7 + sx*abv7d
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fsd
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + syd*&
&             abv7 + sy*abv7d
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fsd
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + szd*&
&             abv7 + sz*abv7d
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fsd
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + &
&             unavgd*abv7 + unavg*abv7d
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + fsd
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do k=1,kl
        do j=2,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = one
            if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
              y3d = dssd(i, j, k+1, 3)
              y3 = dss(i, j, k+1, 3)
            else
              y3d = dssd(i, j, k, 3)
              y3 = dss(i, j, k, 3)
            end if
            if (dpmax .gt. y3) then
              min3d = y3d
              min3 = y3
            else
              min3 = dpmax
              min3d = 0.0_8
            end if
            dis2d = ppor*fis2*min3d
            dis2 = ppor*fis2*min3
            dis4d = mydim_d(ppor*fis4, 0.0_8, dis2, dis2d, dis4)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw1d = wd(i, j, k+1, irho) - wd(i, j, k, irho)
            ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
            drd = dis2d*ddw1 + dis2*ddw1d - dis4d*(w(i, j, k+2, irho)-w(&
&             i, j, k-1, irho)-three*ddw1) - dis4*(wd(i, j, k+2, irho)-&
&             wd(i, j, k-1, irho)-three*ddw1d)
            dr = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)&
&             -three*ddw1)
            ddw2d = wd(i, j, k+1, irho)*w(i, j, k+1, ivx) + w(i, j, k+1&
&             , irho)*wd(i, j, k+1, ivx) - wd(i, j, k, irho)*w(i, j, k, &
&             ivx) - w(i, j, k, irho)*wd(i, j, k, ivx)
            ddw2 = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, &
&             irho)*w(i, j, k, ivx)
            drud = dis2d*ddw2 + dis2*ddw2d - dis4d*(w(i, j, k+2, irho)*w&
&             (i, j, k+2, ivx)-w(i, j, k-1, irho)*w(i, j, k-1, ivx)-&
&             three*ddw2) - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, ivx)+&
&             w(i, j, k+2, irho)*wd(i, j, k+2, ivx)-wd(i, j, k-1, irho)*&
&             w(i, j, k-1, ivx)-w(i, j, k-1, irho)*wd(i, j, k-1, ivx)-&
&             three*ddw2d)
            dru = dis2*ddw2 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw2)
            ddw3d = wd(i, j, k+1, irho)*w(i, j, k+1, ivy) + w(i, j, k+1&
&             , irho)*wd(i, j, k+1, ivy) - wd(i, j, k, irho)*w(i, j, k, &
&             ivy) - w(i, j, k, irho)*wd(i, j, k, ivy)
            ddw3 = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, &
&             irho)*w(i, j, k, ivy)
            drvd = dis2d*ddw3 + dis2*ddw3d - dis4d*(w(i, j, k+2, irho)*w&
&             (i, j, k+2, ivy)-w(i, j, k-1, irho)*w(i, j, k-1, ivy)-&
&             three*ddw3) - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, ivy)+&
&             w(i, j, k+2, irho)*wd(i, j, k+2, ivy)-wd(i, j, k-1, irho)*&
&             w(i, j, k-1, ivy)-w(i, j, k-1, irho)*wd(i, j, k-1, ivy)-&
&             three*ddw3d)
            drv = dis2*ddw3 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw3)
            ddw4d = wd(i, j, k+1, irho)*w(i, j, k+1, ivz) + w(i, j, k+1&
&             , irho)*wd(i, j, k+1, ivz) - wd(i, j, k, irho)*w(i, j, k, &
&             ivz) - w(i, j, k, irho)*wd(i, j, k, ivz)
            ddw4 = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, &
&             irho)*w(i, j, k, ivz)
            drwd = dis2d*ddw4 + dis2*ddw4d - dis4d*(w(i, j, k+2, irho)*w&
&             (i, j, k+2, ivz)-w(i, j, k-1, irho)*w(i, j, k-1, ivz)-&
&             three*ddw4) - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, ivz)+&
&             w(i, j, k+2, irho)*wd(i, j, k+2, ivz)-wd(i, j, k-1, irho)*&
&             w(i, j, k-1, ivz)-w(i, j, k-1, irho)*wd(i, j, k-1, ivz)-&
&             three*ddw4d)
            drw = dis2*ddw4 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw4)
            ddw5d = wd(i, j, k+1, irhoe) - wd(i, j, k, irhoe)
            ddw5 = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            dred = dis2d*ddw5 + dis2*ddw5d - dis4d*(w(i, j, k+2, irhoe)-&
&             w(i, j, k-1, irhoe)-three*ddw5) - dis4*(wd(i, j, k+2, &
&             irhoe)-wd(i, j, k-1, irhoe)-three*ddw5d)
            dre = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, &
&             irhoe)-three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw6d = wd(i, j, k+1, irho)*w(i, j, k+1, itu1) + w(i, j, k&
&               +1, irho)*wd(i, j, k+1, itu1) - wd(i, j, k, irho)*w(i, j&
&               , k, itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
              ddw6 = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drkd = dis2d*ddw6 + dis2*ddw6d - dis4d*(w(i, j, k+2, irho)&
&               *w(i, j, k+2, itu1)-w(i, j, k-1, irho)*w(i, j, k-1, itu1&
&               )-three*ddw6) - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, &
&               itu1)+w(i, j, k+2, irho)*wd(i, j, k+2, itu1)-wd(i, j, k-&
&               1, irho)*w(i, j, k-1, itu1)-w(i, j, k-1, irho)*wd(i, j, &
&               k-1, itu1)-three*ddw6d)
              drk = dis2*ddw6 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, &
&               itu1)-w(i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw6)
              kavgd = half*(wd(i, j, k+1, itu1)+wd(i, j, k, itu1))
              kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
            else
              drk = zero
              kavg = zero
              kavgd = 0.0_8
              drkd = 0.0_8
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavgd = half*(wd(i, j, k+1, ivx)+wd(i, j, k, ivx))
            uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
            vavgd = half*(wd(i, j, k+1, ivy)+wd(i, j, k, ivy))
            vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
            wavgd = half*(wd(i, j, k+1, ivz)+wd(i, j, k, ivz))
            wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
            a2avgd = half*((gamma(i, j, k+1)*pd(i, j, k+1)*w(i, j, k+1, &
&             irho)-gamma(i, j, k+1)*p(i, j, k+1)*wd(i, j, k+1, irho))/w&
&             (i, j, k+1, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k&
&             , irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, &
&             j, k, irho)**2)
            a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            arg1d = 2*sk(i, j, k, 1)*skd(i, j, k, 1) + 2*sk(i, j, k, 2)*&
&             skd(i, j, k, 2) + 2*sk(i, j, k, 3)*skd(i, j, k, 3)
            arg1 = sk(i, j, k, 1)**2 + sk(i, j, k, 2)**2 + sk(i, j, k, 3&
&             )**2
            if (arg1 .eq. 0.0_8) then
              aread = 0.0_8
            else
              aread = arg1d/(2.0*sqrt(arg1))
            end if
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max9d = aread
              max9 = area
            else
              max9 = 1.e-25_realtype
              max9d = 0.0_8
            end if
            tmpd = -(one*max9d/max9**2)
            tmp = one/max9
            sxd = skd(i, j, k, 1)*tmp + sk(i, j, k, 1)*tmpd
            sx = sk(i, j, k, 1)*tmp
            syd = skd(i, j, k, 2)*tmp + sk(i, j, k, 2)*tmpd
            sy = sk(i, j, k, 2)*tmp
            szd = skd(i, j, k, 3)*tmp + sk(i, j, k, 3)*tmpd
            sz = sk(i, j, k, 3)*tmp
            alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            if (a2avg .eq. 0.0_8) then
              aavgd = 0.0_8
            else
              aavgd = a2avgd/(2.0*sqrt(a2avg))
            end if
            aavg = sqrt(a2avg)
            unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*&
&             sz + wavg*szd
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavgd = -(one*aavgd/aavg**2)
            ovaavg = one/aavg
            ova2avgd = -(one*a2avgd/a2avg**2)
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) then
              sfaced = sfacek(i, j, k)*tmpd
              sface = sfacek(i, j, k)*tmp
            end if
            if (unavg - sface + aavg .ge. 0.) then
              lam1d = unavgd - sfaced + aavgd
              lam1 = unavg - sface + aavg
            else
              lam1d = -(unavgd-sfaced+aavgd)
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2d = unavgd - sfaced - aavgd
              lam2 = unavg - sface - aavg
            else
              lam2d = -(unavgd-sfaced-aavgd)
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3d = unavgd - sfaced
              lam3 = unavg - sface
            else
              lam3d = -(unavgd-sfaced)
              lam3 = -(unavg-sface)
            end if
            rradd = lam3d + aavgd
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              max10d = epsacoustic*rradd
              max10 = epsacoustic*rrad
            else
              max10d = lam1d
              max10 = lam1
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1d = max10d*area + max10*aread
            lam1 = max10*area
            if (lam2 .lt. epsacoustic*rrad) then
              max11d = epsacoustic*rradd
              max11 = epsacoustic*rrad
            else
              max11d = lam2d
              max11 = lam2
            end if
            lam2d = max11d*area + max11*aread
            lam2 = max11*area
            if (lam3 .lt. epsshear*rrad) then
              max12d = epsshear*rradd
              max12 = epsshear*rrad
            else
              max12d = lam3d
              max12 = lam3
            end if
            lam3d = max12d*area + max12*aread
            lam3 = max12*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1d = half*(lam1d+lam2d)
            abv1 = half*(lam1+lam2)
            abv2d = half*(lam1d-lam2d)
            abv2 = half*(lam1-lam2)
            abv3d = abv1d - lam3d
            abv3 = abv1 - lam3
            abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&             vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz&
&             *drwd - unavgd*dr - unavg*drd
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd&
&             + (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd +&
&             abv3d*abv5 + abv3*abv5d
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fsd = lam3d*dr + lam3*drd + abv6d
            fs = lam3*dr + abv6
            fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) + fsd
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sxd*&
&             abv7 + sx*abv7d
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fsd
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + syd*&
&             abv7 + sy*abv7d
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fsd
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + szd*&
&             abv7 + sz*abv7d
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fsd
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + &
&             unavgd*abv7 + unavg*abv7d
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + fsd
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxmatrix_d
  subroutine invisciddissfluxmatrix()
!
!       invisciddissfluxmatrix computes the matrix artificial          
!       dissipation term. instead of the spectral radius, as used in   
!       the scalar dissipation scheme, the absolute value of the flux  
!       jacobian is used. this leads to a less diffusive and           
!       consequently more accurate scheme. it is assumed that the      
!       pointers in blockpointers already point to the correct block.  
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, p, pori, porj, pork, fw, gamma, si, sj, sk, indfamilyi, &
&   indfamilyj, indfamilyk, spectralsol, addgridvelocities, sfacei, &
&   sfacej, sfacek, factfamilyi, factfamilyj, factfamilyk
    use flowvarrefstate, only : pinfcorr
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use cgnsgrid, only : massflowfamilydiss
    use utils_d, only : getcorrectfork, mydim
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: dp1, dp2, tmp, fs
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, ddw6
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    logical :: correctfork
    intrinsic abs
    intrinsic max
    intrinsic min
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max9
    real(kind=realtype) :: max8
    real(kind=realtype) :: max7
    real(kind=realtype) :: max6
    real(kind=realtype) :: max5
    real(kind=realtype) :: max4
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: max12
    real(kind=realtype) :: max11
    real(kind=realtype) :: max10
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. 
      fw = sfil*fw
! compute the pressure sensor for each cell, in each direction:
      do k=1,ke
        do j=1,je
          do i=1,ie
            if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
              abs1 = p(i+1, j, k) - p(i, j, k)
            else
              abs1 = -(p(i+1, j, k)-p(i, j, k))
            end if
            if (p(i, j, k) - p(i-1, j, k) .ge. 0.) then
              abs4 = p(i, j, k) - p(i-1, j, k)
            else
              abs4 = -(p(i, j, k)-p(i-1, j, k))
            end if
            x1 = (p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))/(omega*(p(i+&
&             1, j, k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+&
&             abs4)+plim)
            if (x1 .ge. 0.) then
              dss(i, j, k, 1) = x1
            else
              dss(i, j, k, 1) = -x1
            end if
            if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
              abs2 = p(i, j+1, k) - p(i, j, k)
            else
              abs2 = -(p(i, j+1, k)-p(i, j, k))
            end if
            if (p(i, j, k) - p(i, j-1, k) .ge. 0.) then
              abs5 = p(i, j, k) - p(i, j-1, k)
            else
              abs5 = -(p(i, j, k)-p(i, j-1, k))
            end if
            x2 = (p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))/(omega*(p(i&
&             , j+1, k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+&
&             abs5)+plim)
            if (x2 .ge. 0.) then
              dss(i, j, k, 2) = x2
            else
              dss(i, j, k, 2) = -x2
            end if
            if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
              abs3 = p(i, j, k+1) - p(i, j, k)
            else
              abs3 = -(p(i, j, k+1)-p(i, j, k))
            end if
            if (p(i, j, k) - p(i, j, k-1) .ge. 0.) then
              abs6 = p(i, j, k) - p(i, j, k-1)
            else
              abs6 = -(p(i, j, k)-p(i, j, k-1))
            end if
            x3 = (p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))/(omega*(p(i&
&             , j, k+1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+&
&             abs6)+plim)
            if (x3 .ge. 0.) then
              dss(i, j, k, 3) = x3
            else
              dss(i, j, k, 3) = -x3
            end if
          end do
        end do
      end do
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          do i=1,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = one
            if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
              y1 = dss(i+1, j, k, 1)
            else
              y1 = dss(i, j, k, 1)
            end if
            if (dpmax .gt. y1) then
              min1 = y1
            else
              min1 = dpmax
            end if
            dis2 = ppor*fis2*min1
            dis4 = mydim(ppor*fis4, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
            dr = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)&
&             -three*ddw1)
            ddw2 = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, &
&             irho)*w(i, j, k, ivx)
            dru = dis2*ddw2 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw2)
            ddw3 = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, &
&             irho)*w(i, j, k, ivy)
            drv = dis2*ddw3 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw3)
            ddw4 = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, &
&             irho)*w(i, j, k, ivz)
            drw = dis2*ddw4 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw4)
            ddw5 = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, &
&             irhoe)-three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw6 = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw6 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, &
&               itu1)-w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw6)
              kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            arg1 = si(i, j, k, 1)**2 + si(i, j, k, 2)**2 + si(i, j, k, 3&
&             )**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max1 = area
            else
              max1 = 1.e-25_realtype
            end if
            tmp = one/max1
            sx = si(i, j, k, 1)*tmp
            sy = si(i, j, k, 2)*tmp
            sz = si(i, j, k, 3)*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacei(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              max2 = epsacoustic*rrad
            else
              max2 = lam1
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = max2*area
            if (lam2 .lt. epsacoustic*rrad) then
              max3 = epsacoustic*rrad
            else
              max3 = lam2
            end if
            lam2 = max3*area
            if (lam3 .lt. epsshear*rrad) then
              max4 = epsshear*rrad
            else
              max4 = lam3
            end if
            lam3 = max4*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do j=1,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = one
            if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
              y2 = dss(i, j+1, k, 2)
            else
              y2 = dss(i, j, k, 2)
            end if
            if (dpmax .gt. y2) then
              min2 = y2
            else
              min2 = dpmax
            end if
            dis2 = ppor*fis2*min2
            dis4 = mydim(ppor*fis4, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
            dr = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)&
&             -three*ddw1)
            ddw2 = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, &
&             irho)*w(i, j, k, ivx)
            dru = dis2*ddw2 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw2)
            ddw3 = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, &
&             irho)*w(i, j, k, ivy)
            drv = dis2*ddw3 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw3)
            ddw4 = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, &
&             irho)*w(i, j, k, ivz)
            drw = dis2*ddw4 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw4)
            ddw5 = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, &
&             irhoe)-three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw6 = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw6 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, &
&               itu1)-w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw6)
              kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            arg1 = sj(i, j, k, 1)**2 + sj(i, j, k, 2)**2 + sj(i, j, k, 3&
&             )**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max5 = area
            else
              max5 = 1.e-25_realtype
            end if
            tmp = one/max5
            sx = sj(i, j, k, 1)*tmp
            sy = sj(i, j, k, 2)*tmp
            sz = sj(i, j, k, 3)*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacej(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              max6 = epsacoustic*rrad
            else
              max6 = lam1
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = max6*area
            if (lam2 .lt. epsacoustic*rrad) then
              max7 = epsacoustic*rrad
            else
              max7 = lam2
            end if
            lam2 = max7*area
            if (lam3 .lt. epsshear*rrad) then
              max8 = epsshear*rrad
            else
              max8 = lam3
            end if
            lam3 = max8*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do k=1,kl
        do j=2,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = one
            if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
              y3 = dss(i, j, k+1, 3)
            else
              y3 = dss(i, j, k, 3)
            end if
            if (dpmax .gt. y3) then
              min3 = y3
            else
              min3 = dpmax
            end if
            dis2 = ppor*fis2*min3
            dis4 = mydim(ppor*fis4, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
            dr = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)&
&             -three*ddw1)
            ddw2 = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, &
&             irho)*w(i, j, k, ivx)
            dru = dis2*ddw2 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw2)
            ddw3 = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, &
&             irho)*w(i, j, k, ivy)
            drv = dis2*ddw3 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw3)
            ddw4 = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, &
&             irho)*w(i, j, k, ivz)
            drw = dis2*ddw4 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw4)
            ddw5 = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, &
&             irhoe)-three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw6 = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw6 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, &
&               itu1)-w(i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw6)
              kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            arg1 = sk(i, j, k, 1)**2 + sk(i, j, k, 2)**2 + sk(i, j, k, 3&
&             )**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max9 = area
            else
              max9 = 1.e-25_realtype
            end if
            tmp = one/max9
            sx = sk(i, j, k, 1)*tmp
            sy = sk(i, j, k, 2)*tmp
            sz = sk(i, j, k, 3)*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacek(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              max10 = epsacoustic*rrad
            else
              max10 = lam1
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = max10*area
            if (lam2 .lt. epsacoustic*rrad) then
              max11 = epsacoustic*rrad
            else
              max11 = lam2
            end if
            lam2 = max11*area
            if (lam3 .lt. epsshear*rrad) then
              max12 = epsshear*rrad
            else
              max12 = lam3
            end if
            lam3 = max12*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxmatrix
!  differentiation of invisciddissfluxscalar in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw
!   with respect to varying inputs: rhoinf pinfcorr *p *w *fw *radi
!                *radj *radk
!   rw status of diff variables: rhoinf:in pinfcorr:in *p:in *w:in
!                *fw:in-out *radi:in *radj:in *radk:in
!   plus diff mem management of: p:in w:in fw:in radi:in radj:in
!                radk:in
  subroutine invisciddissfluxscalar_d()
!
!       invisciddissfluxscalar computes the scalar artificial          
!       dissipation, see aiaa paper 81-1259, for a given block.        
!       therefore it is assumed that the pointers in  blockpointers    
!       already point to the correct block.                            
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, wd, p, pd, pori, porj, pork, fw, fwd, radi, radid, radj, &
&   radjd, radk, radkd, gamma
    use flowvarrefstate, only : gammainf, pinfcorr, pinfcorrd, rhoinf,&
&   rhoinfd
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use utils_d, only : mydim, mydim_d
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: sslimd
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: rradd, dis2d, dis4d
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, fs
    real(kind=realtype) :: ddw1d, ddw2d, ddw3d, ddw4d, ddw5d, fsd
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    real(kind=realtype), dimension(ie, je, ke, 3) :: dssd
    real(kind=realtype), dimension(0:ib, 0:jb, 0:kb) :: ss
    real(kind=realtype), dimension(0:ib, 0:jb, 0:kb) :: ssd
    intrinsic abs
    intrinsic max
    intrinsic min
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwr1d
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: min1d
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x1
    real(kind=realtype) :: y3d
    real(kind=realtype) :: x1d
    real(kind=realtype) :: min3d
    real(kind=realtype) :: y2d
    real(kind=realtype) :: abs0
    real(kind=realtype) :: min2d
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: x3d
    real(kind=realtype) :: y1
    real(kind=realtype) :: y1d
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations) 
      case (eulerequations) 
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslimd = 0.001_realtype*pinfcorrd
        sslim = 0.001_realtype*pinfcorr
! copy the pressure in ss. only need the entries used in the
! discretization, i.e. not including the corner halo's, but we'll
! just copy all anyway. 
        ssd = pd
        ss = p
        dssd = 0.0_8
      case (nsequations, ransequations) 
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        if (rhoinf .gt. 0.0_8 .or. (rhoinf .lt. 0.0_8 .and. gammainf &
&           .eq. int(gammainf))) then
          pwr1d = gammainf*rhoinf**(gammainf-1)*rhoinfd
        else if (rhoinf .eq. 0.0_8 .and. gammainf .eq. 1.0) then
          pwr1d = rhoinfd
        else
          pwr1d = 0.0_8
        end if
        pwr1 = rhoinf**gammainf
        sslimd = (0.001_realtype*pinfcorrd*pwr1-0.001_realtype*pinfcorr*&
&         pwr1d)/pwr1**2
        sslim = 0.001_realtype*pinfcorr/pwr1
        ssd = 0.0_8
! store the entropy in ss. see above. 
        do k=0,kb
          do j=0,jb
            do i=0,ib
              if (w(i, j, k, irho) .gt. 0.0_8 .or. (w(i, j, k, irho) &
&                 .lt. 0.0_8 .and. gamma(i, j, k) .eq. int(gamma(i, j, k&
&                 )))) then
                pwr1d = gamma(i, j, k)*w(i, j, k, irho)**(gamma(i, j, k)&
&                 -1)*wd(i, j, k, irho)
              else if (w(i, j, k, irho) .eq. 0.0_8 .and. gamma(i, j, k) &
&                 .eq. 1.0) then
                pwr1d = wd(i, j, k, irho)
              else
                pwr1d = 0.0_8
              end if
              pwr1 = w(i, j, k, irho)**gamma(i, j, k)
              ssd(i, j, k) = (pd(i, j, k)*pwr1-p(i, j, k)*pwr1d)/pwr1**2
              ss(i, j, k) = p(i, j, k)/pwr1
            end do
          end do
        end do
        dssd = 0.0_8
      case default
        sslimd = 0.0_8
        ssd = 0.0_8
        dssd = 0.0_8
      end select
! compute the pressure sensor for each cell, in each direction:
      do k=1,ke
        do j=1,je
          do i=1,ie
            x1d = ((ssd(i+1, j, k)-two*ssd(i, j, k)+ssd(i-1, j, k))*(ss(&
&             i+1, j, k)+two*ss(i, j, k)+ss(i-1, j, k)+sslim)-(ss(i+1, j&
&             , k)-two*ss(i, j, k)+ss(i-1, j, k))*(ssd(i+1, j, k)+two*&
&             ssd(i, j, k)+ssd(i-1, j, k)+sslimd))/(ss(i+1, j, k)+two*ss&
&             (i, j, k)+ss(i-1, j, k)+sslim)**2
            x1 = (ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))/(ss(i+1, &
&             j, k)+two*ss(i, j, k)+ss(i-1, j, k)+sslim)
            if (x1 .ge. 0.) then
              dssd(i, j, k, 1) = x1d
              dss(i, j, k, 1) = x1
            else
              dssd(i, j, k, 1) = -x1d
              dss(i, j, k, 1) = -x1
            end if
            x2d = ((ssd(i, j+1, k)-two*ssd(i, j, k)+ssd(i, j-1, k))*(ss(&
&             i, j+1, k)+two*ss(i, j, k)+ss(i, j-1, k)+sslim)-(ss(i, j+1&
&             , k)-two*ss(i, j, k)+ss(i, j-1, k))*(ssd(i, j+1, k)+two*&
&             ssd(i, j, k)+ssd(i, j-1, k)+sslimd))/(ss(i, j+1, k)+two*ss&
&             (i, j, k)+ss(i, j-1, k)+sslim)**2
            x2 = (ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))/(ss(i, j+&
&             1, k)+two*ss(i, j, k)+ss(i, j-1, k)+sslim)
            if (x2 .ge. 0.) then
              dssd(i, j, k, 2) = x2d
              dss(i, j, k, 2) = x2
            else
              dssd(i, j, k, 2) = -x2d
              dss(i, j, k, 2) = -x2
            end if
            x3d = ((ssd(i, j, k+1)-two*ssd(i, j, k)+ssd(i, j, k-1))*(ss(&
&             i, j, k+1)+two*ss(i, j, k)+ss(i, j, k-1)+sslim)-(ss(i, j, &
&             k+1)-two*ss(i, j, k)+ss(i, j, k-1))*(ssd(i, j, k+1)+two*&
&             ssd(i, j, k)+ssd(i, j, k-1)+sslimd))/(ss(i, j, k+1)+two*ss&
&             (i, j, k)+ss(i, j, k-1)+sslim)**2
            x3 = (ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))/(ss(i, j&
&             , k+1)+two*ss(i, j, k)+ss(i, j, k-1)+sslim)
            if (x3 .ge. 0.) then
              dssd(i, j, k, 3) = x3d
              dss(i, j, k, 3) = x3
            else
              dssd(i, j, k, 3) = -x3d
              dss(i, j, k, 3) = -x3
            end if
          end do
        end do
      end do
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      fwd = sfil*fwd
      fw = sfil*fw
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          do i=1,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = half
            rradd = ppor*(radid(i, j, k)+radid(i+1, j, k))
            rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
            if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
              y1d = dssd(i+1, j, k, 1)
              y1 = dss(i+1, j, k, 1)
            else
              y1d = dssd(i, j, k, 1)
              y1 = dss(i, j, k, 1)
            end if
            if (dssmax .gt. y1) then
              min1d = y1d
              min1 = y1
            else
              min1 = dssmax
              min1d = 0.0_8
            end if
            dis2d = fis2*(rradd*min1+rrad*min1d)
            dis2 = fis2*rrad*min1
            dis4d = mydim_d(fis4*rrad, fis4*rradd, dis2, dis2d, dis4)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw1d = wd(i+1, j, k, irho) - wd(i, j, k, irho)
            ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
            fsd = dis2d*ddw1 + dis2*ddw1d - dis4d*(w(i+2, j, k, irho)-w(&
&             i-1, j, k, irho)-three*ddw1) - dis4*(wd(i+2, j, k, irho)-&
&             wd(i-1, j, k, irho)-three*ddw1d)
            fs = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)&
&             -three*ddw1)
            fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) + fsd
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw2d = wd(i+1, j, k, ivx)*w(i+1, j, k, irho) + w(i+1, j, k&
&             , ivx)*wd(i+1, j, k, irho) - wd(i, j, k, ivx)*w(i, j, k, &
&             irho) - w(i, j, k, ivx)*wd(i, j, k, irho)
            ddw2 = w(i+1, j, k, ivx)*w(i+1, j, k, irho) - w(i, j, k, ivx&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw2 + dis2*ddw2d - dis4d*(w(i+2, j, k, ivx)*w(i&
&             +2, j, k, irho)-w(i-1, j, k, ivx)*w(i-1, j, k, irho)-three&
&             *ddw2) - dis4*(wd(i+2, j, k, ivx)*w(i+2, j, k, irho)+w(i+2&
&             , j, k, ivx)*wd(i+2, j, k, irho)-wd(i-1, j, k, ivx)*w(i-1&
&             , j, k, irho)-w(i-1, j, k, ivx)*wd(i-1, j, k, irho)-three*&
&             ddw2d)
            fs = dis2*ddw2 - dis4*(w(i+2, j, k, ivx)*w(i+2, j, k, irho)-&
&             w(i-1, j, k, ivx)*w(i-1, j, k, irho)-three*ddw2)
            fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fsd
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw3d = wd(i+1, j, k, ivy)*w(i+1, j, k, irho) + w(i+1, j, k&
&             , ivy)*wd(i+1, j, k, irho) - wd(i, j, k, ivy)*w(i, j, k, &
&             irho) - w(i, j, k, ivy)*wd(i, j, k, irho)
            ddw3 = w(i+1, j, k, ivy)*w(i+1, j, k, irho) - w(i, j, k, ivy&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw3 + dis2*ddw3d - dis4d*(w(i+2, j, k, ivy)*w(i&
&             +2, j, k, irho)-w(i-1, j, k, ivy)*w(i-1, j, k, irho)-three&
&             *ddw3) - dis4*(wd(i+2, j, k, ivy)*w(i+2, j, k, irho)+w(i+2&
&             , j, k, ivy)*wd(i+2, j, k, irho)-wd(i-1, j, k, ivy)*w(i-1&
&             , j, k, irho)-w(i-1, j, k, ivy)*wd(i-1, j, k, irho)-three*&
&             ddw3d)
            fs = dis2*ddw3 - dis4*(w(i+2, j, k, ivy)*w(i+2, j, k, irho)-&
&             w(i-1, j, k, ivy)*w(i-1, j, k, irho)-three*ddw3)
            fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fsd
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw4d = wd(i+1, j, k, ivz)*w(i+1, j, k, irho) + w(i+1, j, k&
&             , ivz)*wd(i+1, j, k, irho) - wd(i, j, k, ivz)*w(i, j, k, &
&             irho) - w(i, j, k, ivz)*wd(i, j, k, irho)
            ddw4 = w(i+1, j, k, ivz)*w(i+1, j, k, irho) - w(i, j, k, ivz&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw4 + dis2*ddw4d - dis4d*(w(i+2, j, k, ivz)*w(i&
&             +2, j, k, irho)-w(i-1, j, k, ivz)*w(i-1, j, k, irho)-three&
&             *ddw4) - dis4*(wd(i+2, j, k, ivz)*w(i+2, j, k, irho)+w(i+2&
&             , j, k, ivz)*wd(i+2, j, k, irho)-wd(i-1, j, k, ivz)*w(i-1&
&             , j, k, irho)-w(i-1, j, k, ivz)*wd(i-1, j, k, irho)-three*&
&             ddw4d)
            fs = dis2*ddw4 - dis4*(w(i+2, j, k, ivz)*w(i+2, j, k, irho)-&
&             w(i-1, j, k, ivz)*w(i-1, j, k, irho)-three*ddw4)
            fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fsd
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw5d = wd(i+1, j, k, irhoe) + pd(i+1, j, k) - wd(i, j, k, &
&             irhoe) - pd(i, j, k)
            ddw5 = w(i+1, j, k, irhoe) + p(i+1, j, k) - (w(i, j, k, &
&             irhoe)+p(i, j, k))
            fsd = dis2d*ddw5 + dis2*ddw5d - dis4d*(w(i+2, j, k, irhoe)+p&
&             (i+2, j, k)-(w(i-1, j, k, irhoe)+p(i-1, j, k))-three*ddw5)&
&             - dis4*(wd(i+2, j, k, irhoe)+pd(i+2, j, k)-wd(i-1, j, k, &
&             irhoe)-pd(i-1, j, k)-three*ddw5d)
            fs = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)+p(i+2, j, k)-(w(i&
&             -1, j, k, irhoe)+p(i-1, j, k))-three*ddw5)
            fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + fsd
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do j=1,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = half
            rradd = ppor*(radjd(i, j, k)+radjd(i, j+1, k))
            rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
            if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
              y2d = dssd(i, j+1, k, 2)
              y2 = dss(i, j+1, k, 2)
            else
              y2d = dssd(i, j, k, 2)
              y2 = dss(i, j, k, 2)
            end if
            if (dssmax .gt. y2) then
              min2d = y2d
              min2 = y2
            else
              min2 = dssmax
              min2d = 0.0_8
            end if
            dis2d = fis2*(rradd*min2+rrad*min2d)
            dis2 = fis2*rrad*min2
            dis4d = mydim_d(fis4*rrad, fis4*rradd, dis2, dis2d, dis4)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw1d = wd(i, j+1, k, irho) - wd(i, j, k, irho)
            ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
            fsd = dis2d*ddw1 + dis2*ddw1d - dis4d*(w(i, j+2, k, irho)-w(&
&             i, j-1, k, irho)-three*ddw1) - dis4*(wd(i, j+2, k, irho)-&
&             wd(i, j-1, k, irho)-three*ddw1d)
            fs = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)&
&             -three*ddw1)
            fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) + fsd
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw2d = wd(i, j+1, k, ivx)*w(i, j+1, k, irho) + w(i, j+1, k&
&             , ivx)*wd(i, j+1, k, irho) - wd(i, j, k, ivx)*w(i, j, k, &
&             irho) - w(i, j, k, ivx)*wd(i, j, k, irho)
            ddw2 = w(i, j+1, k, ivx)*w(i, j+1, k, irho) - w(i, j, k, ivx&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw2 + dis2*ddw2d - dis4d*(w(i, j+2, k, ivx)*w(i&
&             , j+2, k, irho)-w(i, j-1, k, ivx)*w(i, j-1, k, irho)-three&
&             *ddw2) - dis4*(wd(i, j+2, k, ivx)*w(i, j+2, k, irho)+w(i, &
&             j+2, k, ivx)*wd(i, j+2, k, irho)-wd(i, j-1, k, ivx)*w(i, j&
&             -1, k, irho)-w(i, j-1, k, ivx)*wd(i, j-1, k, irho)-three*&
&             ddw2d)
            fs = dis2*ddw2 - dis4*(w(i, j+2, k, ivx)*w(i, j+2, k, irho)-&
&             w(i, j-1, k, ivx)*w(i, j-1, k, irho)-three*ddw2)
            fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fsd
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw3d = wd(i, j+1, k, ivy)*w(i, j+1, k, irho) + w(i, j+1, k&
&             , ivy)*wd(i, j+1, k, irho) - wd(i, j, k, ivy)*w(i, j, k, &
&             irho) - w(i, j, k, ivy)*wd(i, j, k, irho)
            ddw3 = w(i, j+1, k, ivy)*w(i, j+1, k, irho) - w(i, j, k, ivy&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw3 + dis2*ddw3d - dis4d*(w(i, j+2, k, ivy)*w(i&
&             , j+2, k, irho)-w(i, j-1, k, ivy)*w(i, j-1, k, irho)-three&
&             *ddw3) - dis4*(wd(i, j+2, k, ivy)*w(i, j+2, k, irho)+w(i, &
&             j+2, k, ivy)*wd(i, j+2, k, irho)-wd(i, j-1, k, ivy)*w(i, j&
&             -1, k, irho)-w(i, j-1, k, ivy)*wd(i, j-1, k, irho)-three*&
&             ddw3d)
            fs = dis2*ddw3 - dis4*(w(i, j+2, k, ivy)*w(i, j+2, k, irho)-&
&             w(i, j-1, k, ivy)*w(i, j-1, k, irho)-three*ddw3)
            fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fsd
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw4d = wd(i, j+1, k, ivz)*w(i, j+1, k, irho) + w(i, j+1, k&
&             , ivz)*wd(i, j+1, k, irho) - wd(i, j, k, ivz)*w(i, j, k, &
&             irho) - w(i, j, k, ivz)*wd(i, j, k, irho)
            ddw4 = w(i, j+1, k, ivz)*w(i, j+1, k, irho) - w(i, j, k, ivz&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw4 + dis2*ddw4d - dis4d*(w(i, j+2, k, ivz)*w(i&
&             , j+2, k, irho)-w(i, j-1, k, ivz)*w(i, j-1, k, irho)-three&
&             *ddw4) - dis4*(wd(i, j+2, k, ivz)*w(i, j+2, k, irho)+w(i, &
&             j+2, k, ivz)*wd(i, j+2, k, irho)-wd(i, j-1, k, ivz)*w(i, j&
&             -1, k, irho)-w(i, j-1, k, ivz)*wd(i, j-1, k, irho)-three*&
&             ddw4d)
            fs = dis2*ddw4 - dis4*(w(i, j+2, k, ivz)*w(i, j+2, k, irho)-&
&             w(i, j-1, k, ivz)*w(i, j-1, k, irho)-three*ddw4)
            fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fsd
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw5d = wd(i, j+1, k, irhoe) + pd(i, j+1, k) - wd(i, j, k, &
&             irhoe) - pd(i, j, k)
            ddw5 = w(i, j+1, k, irhoe) + p(i, j+1, k) - (w(i, j, k, &
&             irhoe)+p(i, j, k))
            fsd = dis2d*ddw5 + dis2*ddw5d - dis4d*(w(i, j+2, k, irhoe)+p&
&             (i, j+2, k)-(w(i, j-1, k, irhoe)+p(i, j-1, k))-three*ddw5)&
&             - dis4*(wd(i, j+2, k, irhoe)+pd(i, j+2, k)-wd(i, j-1, k, &
&             irhoe)-pd(i, j-1, k)-three*ddw5d)
            fs = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)+p(i, j+2, k)-(w(i&
&             , j-1, k, irhoe)+p(i, j-1, k))-three*ddw5)
            fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + fsd
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do k=1,kl
        do j=2,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = half
            rradd = ppor*(radkd(i, j, k)+radkd(i, j, k+1))
            rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
            if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
              y3d = dssd(i, j, k+1, 3)
              y3 = dss(i, j, k+1, 3)
            else
              y3d = dssd(i, j, k, 3)
              y3 = dss(i, j, k, 3)
            end if
            if (dssmax .gt. y3) then
              min3d = y3d
              min3 = y3
            else
              min3 = dssmax
              min3d = 0.0_8
            end if
            dis2d = fis2*(rradd*min3+rrad*min3d)
            dis2 = fis2*rrad*min3
            dis4d = mydim_d(fis4*rrad, fis4*rradd, dis2, dis2d, dis4)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw1d = wd(i, j, k+1, irho) - wd(i, j, k, irho)
            ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
            fsd = dis2d*ddw1 + dis2*ddw1d - dis4d*(w(i, j, k+2, irho)-w(&
&             i, j, k-1, irho)-three*ddw1) - dis4*(wd(i, j, k+2, irho)-&
&             wd(i, j, k-1, irho)-three*ddw1d)
            fs = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)&
&             -three*ddw1)
            fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) + fsd
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw2d = wd(i, j, k+1, ivx)*w(i, j, k+1, irho) + w(i, j, k+1&
&             , ivx)*wd(i, j, k+1, irho) - wd(i, j, k, ivx)*w(i, j, k, &
&             irho) - w(i, j, k, ivx)*wd(i, j, k, irho)
            ddw2 = w(i, j, k+1, ivx)*w(i, j, k+1, irho) - w(i, j, k, ivx&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw2 + dis2*ddw2d - dis4d*(w(i, j, k+2, ivx)*w(i&
&             , j, k+2, irho)-w(i, j, k-1, ivx)*w(i, j, k-1, irho)-three&
&             *ddw2) - dis4*(wd(i, j, k+2, ivx)*w(i, j, k+2, irho)+w(i, &
&             j, k+2, ivx)*wd(i, j, k+2, irho)-wd(i, j, k-1, ivx)*w(i, j&
&             , k-1, irho)-w(i, j, k-1, ivx)*wd(i, j, k-1, irho)-three*&
&             ddw2d)
            fs = dis2*ddw2 - dis4*(w(i, j, k+2, ivx)*w(i, j, k+2, irho)-&
&             w(i, j, k-1, ivx)*w(i, j, k-1, irho)-three*ddw2)
            fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fsd
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw3d = wd(i, j, k+1, ivy)*w(i, j, k+1, irho) + w(i, j, k+1&
&             , ivy)*wd(i, j, k+1, irho) - wd(i, j, k, ivy)*w(i, j, k, &
&             irho) - w(i, j, k, ivy)*wd(i, j, k, irho)
            ddw3 = w(i, j, k+1, ivy)*w(i, j, k+1, irho) - w(i, j, k, ivy&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw3 + dis2*ddw3d - dis4d*(w(i, j, k+2, ivy)*w(i&
&             , j, k+2, irho)-w(i, j, k-1, ivy)*w(i, j, k-1, irho)-three&
&             *ddw3) - dis4*(wd(i, j, k+2, ivy)*w(i, j, k+2, irho)+w(i, &
&             j, k+2, ivy)*wd(i, j, k+2, irho)-wd(i, j, k-1, ivy)*w(i, j&
&             , k-1, irho)-w(i, j, k-1, ivy)*wd(i, j, k-1, irho)-three*&
&             ddw3d)
            fs = dis2*ddw3 - dis4*(w(i, j, k+2, ivy)*w(i, j, k+2, irho)-&
&             w(i, j, k-1, ivy)*w(i, j, k-1, irho)-three*ddw3)
            fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fsd
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw4d = wd(i, j, k+1, ivz)*w(i, j, k+1, irho) + w(i, j, k+1&
&             , ivz)*wd(i, j, k+1, irho) - wd(i, j, k, ivz)*w(i, j, k, &
&             irho) - w(i, j, k, ivz)*wd(i, j, k, irho)
            ddw4 = w(i, j, k+1, ivz)*w(i, j, k+1, irho) - w(i, j, k, ivz&
&             )*w(i, j, k, irho)
            fsd = dis2d*ddw4 + dis2*ddw4d - dis4d*(w(i, j, k+2, ivz)*w(i&
&             , j, k+2, irho)-w(i, j, k-1, ivz)*w(i, j, k-1, irho)-three&
&             *ddw4) - dis4*(wd(i, j, k+2, ivz)*w(i, j, k+2, irho)+w(i, &
&             j, k+2, ivz)*wd(i, j, k+2, irho)-wd(i, j, k-1, ivz)*w(i, j&
&             , k-1, irho)-w(i, j, k-1, ivz)*wd(i, j, k-1, irho)-three*&
&             ddw4d)
            fs = dis2*ddw4 - dis4*(w(i, j, k+2, ivz)*w(i, j, k+2, irho)-&
&             w(i, j, k-1, ivz)*w(i, j, k-1, irho)-three*ddw4)
            fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fsd
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw5d = wd(i, j, k+1, irhoe) + pd(i, j, k+1) - wd(i, j, k, &
&             irhoe) - pd(i, j, k)
            ddw5 = w(i, j, k+1, irhoe) + p(i, j, k+1) - (w(i, j, k, &
&             irhoe)+p(i, j, k))
            fsd = dis2d*ddw5 + dis2*ddw5d - dis4d*(w(i, j, k+2, irhoe)+p&
&             (i, j, k+2)-(w(i, j, k-1, irhoe)+p(i, j, k-1))-three*ddw5)&
&             - dis4*(wd(i, j, k+2, irhoe)+pd(i, j, k+2)-wd(i, j, k-1, &
&             irhoe)-pd(i, j, k-1)-three*ddw5d)
            fs = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)+p(i, j, k+2)-(w(i&
&             , j, k-1, irhoe)+p(i, j, k-1))-three*ddw5)
            fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + fsd
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxscalar_d
  subroutine invisciddissfluxscalar()
!
!       invisciddissfluxscalar computes the scalar artificial          
!       dissipation, see aiaa paper 81-1259, for a given block.        
!       therefore it is assumed that the pointers in  blockpointers    
!       already point to the correct block.                            
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, p, pori, porj, pork, fw, radi, radj, radk, gamma
    use flowvarrefstate, only : gammainf, pinfcorr, rhoinf
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use utils_d, only : mydim
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, fs
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    real(kind=realtype), dimension(0:ib, 0:jb, 0:kb) :: ss
    intrinsic abs
    intrinsic max
    intrinsic min
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations) 
      case (eulerequations) 
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr
! copy the pressure in ss. only need the entries used in the
! discretization, i.e. not including the corner halo's, but we'll
! just copy all anyway. 
        ss = p
      case (nsequations, ransequations) 
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        pwr1 = rhoinf**gammainf
        sslim = 0.001_realtype*pinfcorr/pwr1
! store the entropy in ss. see above. 
        do k=0,kb
          do j=0,jb
            do i=0,ib
              pwr1 = w(i, j, k, irho)**gamma(i, j, k)
              ss(i, j, k) = p(i, j, k)/pwr1
            end do
          end do
        end do
      end select
! compute the pressure sensor for each cell, in each direction:
      do k=1,ke
        do j=1,je
          do i=1,ie
            x1 = (ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))/(ss(i+1, &
&             j, k)+two*ss(i, j, k)+ss(i-1, j, k)+sslim)
            if (x1 .ge. 0.) then
              dss(i, j, k, 1) = x1
            else
              dss(i, j, k, 1) = -x1
            end if
            x2 = (ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))/(ss(i, j+&
&             1, k)+two*ss(i, j, k)+ss(i, j-1, k)+sslim)
            if (x2 .ge. 0.) then
              dss(i, j, k, 2) = x2
            else
              dss(i, j, k, 2) = -x2
            end if
            x3 = (ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))/(ss(i, j&
&             , k+1)+two*ss(i, j, k)+ss(i, j, k-1)+sslim)
            if (x3 .ge. 0.) then
              dss(i, j, k, 3) = x3
            else
              dss(i, j, k, 3) = -x3
            end if
          end do
        end do
      end do
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      fw = sfil*fw
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          do i=1,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
            if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
              y1 = dss(i+1, j, k, 1)
            else
              y1 = dss(i, j, k, 1)
            end if
            if (dssmax .gt. y1) then
              min1 = y1
            else
              min1 = dssmax
            end if
            dis2 = fis2*rrad*min1
            dis4 = mydim(fis4*rrad, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
            fs = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)&
&             -three*ddw1)
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw2 = w(i+1, j, k, ivx)*w(i+1, j, k, irho) - w(i, j, k, ivx&
&             )*w(i, j, k, irho)
            fs = dis2*ddw2 - dis4*(w(i+2, j, k, ivx)*w(i+2, j, k, irho)-&
&             w(i-1, j, k, ivx)*w(i-1, j, k, irho)-three*ddw2)
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw3 = w(i+1, j, k, ivy)*w(i+1, j, k, irho) - w(i, j, k, ivy&
&             )*w(i, j, k, irho)
            fs = dis2*ddw3 - dis4*(w(i+2, j, k, ivy)*w(i+2, j, k, irho)-&
&             w(i-1, j, k, ivy)*w(i-1, j, k, irho)-three*ddw3)
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw4 = w(i+1, j, k, ivz)*w(i+1, j, k, irho) - w(i, j, k, ivz&
&             )*w(i, j, k, irho)
            fs = dis2*ddw4 - dis4*(w(i+2, j, k, ivz)*w(i+2, j, k, irho)-&
&             w(i-1, j, k, ivz)*w(i-1, j, k, irho)-three*ddw4)
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw5 = w(i+1, j, k, irhoe) + p(i+1, j, k) - (w(i, j, k, &
&             irhoe)+p(i, j, k))
            fs = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)+p(i+2, j, k)-(w(i&
&             -1, j, k, irhoe)+p(i-1, j, k))-three*ddw5)
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do j=1,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
            if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
              y2 = dss(i, j+1, k, 2)
            else
              y2 = dss(i, j, k, 2)
            end if
            if (dssmax .gt. y2) then
              min2 = y2
            else
              min2 = dssmax
            end if
            dis2 = fis2*rrad*min2
            dis4 = mydim(fis4*rrad, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
            fs = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)&
&             -three*ddw1)
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw2 = w(i, j+1, k, ivx)*w(i, j+1, k, irho) - w(i, j, k, ivx&
&             )*w(i, j, k, irho)
            fs = dis2*ddw2 - dis4*(w(i, j+2, k, ivx)*w(i, j+2, k, irho)-&
&             w(i, j-1, k, ivx)*w(i, j-1, k, irho)-three*ddw2)
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw3 = w(i, j+1, k, ivy)*w(i, j+1, k, irho) - w(i, j, k, ivy&
&             )*w(i, j, k, irho)
            fs = dis2*ddw3 - dis4*(w(i, j+2, k, ivy)*w(i, j+2, k, irho)-&
&             w(i, j-1, k, ivy)*w(i, j-1, k, irho)-three*ddw3)
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw4 = w(i, j+1, k, ivz)*w(i, j+1, k, irho) - w(i, j, k, ivz&
&             )*w(i, j, k, irho)
            fs = dis2*ddw4 - dis4*(w(i, j+2, k, ivz)*w(i, j+2, k, irho)-&
&             w(i, j-1, k, ivz)*w(i, j-1, k, irho)-three*ddw4)
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw5 = w(i, j+1, k, irhoe) + p(i, j+1, k) - (w(i, j, k, &
&             irhoe)+p(i, j, k))
            fs = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)+p(i, j+2, k)-(w(i&
&             , j-1, k, irhoe)+p(i, j-1, k))-three*ddw5)
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do k=1,kl
        do j=2,jl
          do i=2,il
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
            if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
              y3 = dss(i, j, k+1, 3)
            else
              y3 = dss(i, j, k, 3)
            end if
            if (dssmax .gt. y3) then
              min3 = y3
            else
              min3 = dssmax
            end if
            dis2 = fis2*rrad*min3
            dis4 = mydim(fis4*rrad, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
            fs = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)&
&             -three*ddw1)
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw2 = w(i, j, k+1, ivx)*w(i, j, k+1, irho) - w(i, j, k, ivx&
&             )*w(i, j, k, irho)
            fs = dis2*ddw2 - dis4*(w(i, j, k+2, ivx)*w(i, j, k+2, irho)-&
&             w(i, j, k-1, ivx)*w(i, j, k-1, irho)-three*ddw2)
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw3 = w(i, j, k+1, ivy)*w(i, j, k+1, irho) - w(i, j, k, ivy&
&             )*w(i, j, k, irho)
            fs = dis2*ddw3 - dis4*(w(i, j, k+2, ivy)*w(i, j, k+2, irho)-&
&             w(i, j, k-1, ivy)*w(i, j, k-1, irho)-three*ddw3)
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw4 = w(i, j, k+1, ivz)*w(i, j, k+1, irho) - w(i, j, k, ivz&
&             )*w(i, j, k, irho)
            fs = dis2*ddw4 - dis4*(w(i, j, k+2, ivz)*w(i, j, k+2, irho)-&
&             w(i, j, k-1, ivz)*w(i, j, k-1, irho)-three*ddw4)
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw5 = w(i, j, k+1, irhoe) + p(i, j, k+1) - (w(i, j, k, &
&             irhoe)+p(i, j, k))
            fs = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)+p(i, j, k+2)-(w(i&
&             , j, k-1, irhoe)+p(i, j, k-1))-three*ddw5)
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxscalar
  subroutine inviscidupwindflux(finegrid)
!
!       inviscidupwindflux computes the artificial dissipation part of 
!       the euler fluxes by means of an approximate solution of the 1d 
!       riemann problem on the face. for first order schemes,          
!       finegrid == .false., the states in the cells are assumed to    
!       be constant; for the second order schemes on the fine grid a   
!       nonlinear reconstruction of the left and right state is done   
!       for which several options exist.                               
!       it is assumed that the pointers in blockpointers already       
!       point to the correct block.                                    
!
    use constants
    use blockpointers, only : il, jl, kl, ie, je, ke, ib, jb, kb, w, p&
&   , pori, porj, pork, fw, gamma, si, sj, sk, indfamilyi, indfamilyj, &
&   indfamilyk, spectralsol, addgridvelocities, sfacei, sfacej, sfacek, &
&   rotmatrixi, rotmatrixj, rotmatrixk, factfamilyi, factfamilyj, &
&   factfamilyk
    use flowvarrefstate, only : kpresent, nw, nwf, rgas, tref
    use inputdiscretization, only : limiter, lumpeddiss, precond, &
&   riemann, riemanncoarse, orderturb, kappacoef
    use inputphysics, only : equations
    use iteration, only : rfil, currentlevel, groundlevel
    use cgnsgrid, only : massflowfamilydiss
    use utils_d, only : getcorrectfork, terminate
    use flowutils_d, only : etot
    implicit none
!
!      subroutine arguments.
!
    logical, intent(in) :: finegrid
!
!      local variables.
!
    integer(kind=portype) :: por
    integer(kind=inttype) :: nwint
    integer(kind=inttype) :: i, j, k, ind
    integer(kind=inttype) :: limused, riemannused
    real(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
    real(kind=realtype) :: factminmod, sface
    real(kind=realtype), dimension(nw) :: left, right
    real(kind=realtype), dimension(nw) :: du1, du2, du3
    real(kind=realtype), dimension(nwf) :: flux
    logical :: firstorderk, correctfork, rotationalperiodic
    intrinsic abs
    intrinsic associated
    intrinsic max
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! check if the formulation for rotational periodic problems
! must be used.
      if (associated(rotmatrixi)) then
        rotationalperiodic = .true.
      else
        rotationalperiodic = .false.
      end if
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      sfil = one - rfil
      do k=2,kl
        do j=2,jl
          do i=2,il
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
      if (1.e-10_realtype .lt. one - kappacoef) then
        max1 = one - kappacoef
      else
        max1 = 1.e-10_realtype
      end if
! compute the factor used in the minmod limiter.
      factminmod = (three-kappacoef)/max1
! determine the limiter scheme to be used. on the fine grid the
! user specified scheme is used; on the coarse grid a first order
! scheme is computed.
      limused = firstorder
      if (finegrid) limused = limiter
! lumped diss is true for doing approx pc
      if (lumpeddiss) limused = firstorder
! determine the riemann solver which must be used.
      riemannused = riemanncoarse
      if (finegrid) riemannused = riemann
! store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
      omk = fourth*(one-kappacoef)
      opk = fourth*(one+kappacoef)
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set the number of variables to be interpolated depending
! whether or not a k-equation is present. if a k-equation is
! present also set the logical firstorderk. this indicates
! whether or not only a first order approximation is to be used
! for the turbulent kinetic energy.
      if (correctfork) then
        if (orderturb .eq. firstorder) then
          nwint = nwf
          firstorderk = .true.
        else
          nwint = itu1
          firstorderk = .false.
        end if
      else
        nwint = nwf
        firstorderk = .false.
      end if
!
!       flux computation. a distinction is made between first and      
!       second order schemes to avoid the overhead for the first order 
!       scheme.                                                        
!
      if (limused .eq. firstorder) then
!
!         first order reconstruction. the states in the cells are      
!         constant. the left and right states are constructed easily.  
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = si(i, j, k, 1)
              sy = si(i, j, k, 2)
              sz = si(i, j, k, 3)
              por = pori(i, j, k)
              if (addgridvelocities) sface = sfacei(i, j, k)
! determine the left and right state.
              left(irho) = w(i, j, k, irho)
              left(ivx) = w(i, j, k, ivx)
              left(ivy) = w(i, j, k, ivy)
              left(ivz) = w(i, j, k, ivz)
              left(irhoe) = p(i, j, k)
              if (correctfork) left(itu1) = w(i, j, k, itu1)
              right(irho) = w(i+1, j, k, irho)
              right(ivx) = w(i+1, j, k, ivx)
              right(ivy) = w(i+1, j, k, ivy)
              right(ivz) = w(i+1, j, k, ivz)
              right(irhoe) = p(i+1, j, k)
              if (correctfork) right(itu1) = w(i+1, j, k, itu1)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
              fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
              fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
              fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
              fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sj(i, j, k, 1)
              sy = sj(i, j, k, 2)
              sz = sj(i, j, k, 3)
              por = porj(i, j, k)
              if (addgridvelocities) sface = sfacej(i, j, k)
! determine the left and right state.
              left(irho) = w(i, j, k, irho)
              left(ivx) = w(i, j, k, ivx)
              left(ivy) = w(i, j, k, ivy)
              left(ivz) = w(i, j, k, ivz)
              left(irhoe) = p(i, j, k)
              if (correctfork) left(itu1) = w(i, j, k, itu1)
              right(irho) = w(i, j+1, k, irho)
              right(ivx) = w(i, j+1, k, ivx)
              right(ivy) = w(i, j+1, k, ivy)
              right(ivz) = w(i, j+1, k, ivz)
              right(irhoe) = p(i, j+1, k)
              if (correctfork) right(itu1) = w(i, j+1, k, itu1)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
              fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
              fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
              fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
              fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sk(i, j, k, 1)
              sy = sk(i, j, k, 2)
              sz = sk(i, j, k, 3)
              por = pork(i, j, k)
              if (addgridvelocities) sface = sfacek(i, j, k)
! determine the left and right state.
              left(irho) = w(i, j, k, irho)
              left(ivx) = w(i, j, k, ivx)
              left(ivy) = w(i, j, k, ivy)
              left(ivz) = w(i, j, k, ivz)
              left(irhoe) = p(i, j, k)
              if (correctfork) left(itu1) = w(i, j, k, itu1)
              right(irho) = w(i, j, k+1, irho)
              right(ivx) = w(i, j, k+1, ivx)
              right(ivy) = w(i, j, k+1, ivy)
              right(ivz) = w(i, j, k+1, ivz)
              right(irhoe) = p(i, j, k+1)
              if (correctfork) right(itu1) = w(i, j, k+1, itu1)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
              fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
              fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
              fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
              fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
            end do
          end do
        end do
      else
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
!      ==================================================================
!
!         second order reconstruction of the left and right state.     
!         the three differences used in the, possibly nonlinear,       
!         interpolation are constructed here; the actual left and      
!         right states, or at least the differences from the first     
!         order interpolation, are computed in the subroutine          
!         leftrightstate.                                              
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
              du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
              du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
              du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
              du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
              du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
              du1(irhoe) = p(i, j, k) - p(i-1, j, k)
              du2(irhoe) = p(i+1, j, k) - p(i, j, k)
              du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
                du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate(du1, du2, du3, rotmatrixi, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i+1, j, k, irho)
              right(ivx) = right(ivx) + w(i+1, j, k, ivx)
              right(ivy) = right(ivy) + w(i+1, j, k, ivy)
              right(ivz) = right(ivz) + w(i+1, j, k, ivz)
              right(irhoe) = right(irhoe) + p(i+1, j, k)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i+1, j, k, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = si(i, j, k, 1)
              sy = si(i, j, k, 2)
              sz = si(i, j, k, 3)
              por = pori(i, j, k)
              if (addgridvelocities) sface = sfacei(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
              fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
              fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
              fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
              fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
              du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
              du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
              du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
              du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
              du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
              du1(irhoe) = p(i, j, k) - p(i, j-1, k)
              du2(irhoe) = p(i, j+1, k) - p(i, j, k)
              du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
                du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate(du1, du2, du3, rotmatrixj, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i, j+1, k, irho)
              right(ivx) = right(ivx) + w(i, j+1, k, ivx)
              right(ivy) = right(ivy) + w(i, j+1, k, ivy)
              right(ivz) = right(ivz) + w(i, j+1, k, ivz)
              right(irhoe) = right(irhoe) + p(i, j+1, k)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i, j+1, k, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sj(i, j, k, 1)
              sy = sj(i, j, k, 2)
              sz = sj(i, j, k, 3)
              por = porj(i, j, k)
              if (addgridvelocities) sface = sfacej(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
              fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
              fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
              fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
              fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
              du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
              du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
              du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
              du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
              du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
              du1(irhoe) = p(i, j, k) - p(i, j, k-1)
              du2(irhoe) = p(i, j, k+1) - p(i, j, k)
              du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
                du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate(du1, du2, du3, rotmatrixk, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i, j, k+1, irho)
              right(ivx) = right(ivx) + w(i, j, k+1, ivx)
              right(ivy) = right(ivy) + w(i, j, k+1, ivy)
              right(ivz) = right(ivz) + w(i, j, k+1, ivz)
              right(irhoe) = right(irhoe) + p(i, j, k+1)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i, j, k+1, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sk(i, j, k, 1)
              sy = sk(i, j, k, 2)
              sz = sk(i, j, k, 3)
              por = pork(i, j, k)
              if (addgridvelocities) sface = sfacek(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
              fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
              fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
              fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
              fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
            end do
          end do
        end do
      end if
    end if

  contains
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
    subroutine leftrightstate(du1, du2, du3, rotmatrix, left, right)
      implicit none
!
!        local parameter.
!
      real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
      real(kind=realtype), dimension(:), intent(out) :: left, right
      real(kind=realtype), dimension(:, :, :, :, :), pointer :: &
&     rotmatrix
!
!        local variables.
!
      integer(kind=inttype) :: l
      real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
      real(kind=realtype), dimension(3, 3) :: rot
      intrinsic abs
      intrinsic max
      intrinsic sign
      intrinsic min
      real(kind=realtype) :: x6
      real(kind=realtype) :: x5
      real(kind=realtype) :: x4
      real(kind=realtype) :: x3
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: max7
      real(kind=realtype) :: max6
      real(kind=realtype) :: max5
      real(kind=realtype) :: max4
      real(kind=realtype) :: max3
      real(kind=realtype) :: max2
      real(kind=realtype) :: y4
      real(kind=realtype) :: y3
      real(kind=realtype) :: y2
      real(kind=realtype) :: y1
! check if the velocity components should be transformed to
! the cylindrical frame.
      if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
        rot(1, 1) = rotmatrix(i, j, k, 1, 1)
        rot(1, 2) = rotmatrix(i, j, k, 1, 2)
        rot(1, 3) = rotmatrix(i, j, k, 1, 3)
        rot(2, 1) = rotmatrix(i, j, k, 2, 1)
        rot(2, 2) = rotmatrix(i, j, k, 2, 2)
        rot(2, 3) = rotmatrix(i, j, k, 2, 3)
        rot(3, 1) = rotmatrix(i, j, k, 3, 1)
        rot(3, 2) = rotmatrix(i, j, k, 3, 2)
        rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
        dvx = du1(ivx)
        dvy = du1(ivy)
        dvz = du1(ivz)
        du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du2(ivx)
        dvy = du2(ivy)
        dvz = du2(ivz)
        du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du3(ivx)
        dvy = du3(ivy)
        dvz = du3(ivz)
        du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      end if
! determine the limiter used.
      select case  (limused) 
      case (nolimiter) 
! linear interpolation; no limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          left(l) = omk*du1(l) + opk*du2(l)
          right(l) = -(omk*du3(l)) - opk*du2(l)
        end do
      case (vanalbeda) 
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x1 = du2(l)
          else
            x1 = -du2(l)
          end if
          if (x1 .lt. epslim) then
            max2 = epslim
          else
            max2 = x1
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max2, du2(l))
          if (du1(l) .ge. 0.) then
            x3 = du1(l)
          else
            x3 = -du1(l)
          end if
          if (x3 .lt. epslim) then
            max4 = epslim
          else
            max4 = x3
          end if
          y1 = du2(l)/sign(max4, du1(l))
          if (zero .lt. y1) then
            rl1 = y1
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x4 = du3(l)
          else
            x4 = -du3(l)
          end if
          if (x4 .lt. epslim) then
            max5 = epslim
          else
            max5 = x4
          end if
          y2 = du2(l)/sign(max5, du3(l))
          if (zero .lt. y2) then
            rr2 = y2
          else
            rr2 = zero
          end if
! compute the corresponding limiter values.
          rl1 = rl1*(rl1+one)/(rl1*rl1+one)
          rl2 = rl2*(rl2+one)/(rl2*rl2+one)
          rr1 = rr1*(rr1+one)/(rr1*rr1+one)
          rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      case (minmod) 
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x2 = du2(l)
          else
            x2 = -du2(l)
          end if
          if (x2 .lt. epslim) then
            max3 = epslim
          else
            max3 = x2
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max3, du2(l))
          if (du1(l) .ge. 0.) then
            x5 = du1(l)
          else
            x5 = -du1(l)
          end if
          if (x5 .lt. epslim) then
            max6 = epslim
          else
            max6 = x5
          end if
          y3 = du2(l)/sign(max6, du1(l))
          if (zero .lt. y3) then
            rl1 = y3
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x6 = du3(l)
          else
            x6 = -du3(l)
          end if
          if (x6 .lt. epslim) then
            max7 = epslim
          else
            max7 = x6
          end if
          y4 = du2(l)/sign(max7, du3(l))
          if (zero .lt. y4) then
            rr2 = y4
          else
            rr2 = zero
          end if
          if (one .gt. factminmod*rl1) then
            rl1 = factminmod*rl1
          else
            rl1 = one
          end if
          if (one .gt. factminmod*rl2) then
            rl2 = factminmod*rl2
          else
            rl2 = one
          end if
          if (one .gt. factminmod*rr1) then
            rr1 = factminmod*rr1
          else
            rr1 = one
          end if
          if (one .gt. factminmod*rr2) then
            rr2 = factminmod*rr2
          else
            rr2 = one
          end if
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
      if (firstorderk) then
        left(itu1) = zero
        right(itu1) = zero
      end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
      if (rotationalperiodic) then
! left state.
        dvx = left(ivx)
        dvy = left(ivy)
        dvz = left(ivz)
        left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
! right state.
        dvx = right(ivx)
        dvy = right(ivy)
        dvz = right(ivz)
        right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
      end if
    end subroutine leftrightstate
!        ================================================================
    subroutine riemannflux(left, right, flux)
      implicit none
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(*), intent(in) :: left, right
      real(kind=realtype), dimension(*), intent(out) :: flux
!
!        local variables.
!
      real(kind=realtype) :: porflux, rface
      real(kind=realtype) :: etl, etr, z1l, z1r, tmp
      real(kind=realtype) :: dr, dru, drv, drw, dre, drk
      real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
      real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
      real(kind=realtype) :: ovaavg, ova2avg, area, eta
      real(kind=realtype) :: gm1, gm53
      real(kind=realtype) :: lam1, lam2, lam3
      real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
      real(kind=realtype), dimension(2) :: ktmp
      intrinsic sqrt
      intrinsic max
      intrinsic abs
      real(kind=realtype) :: arg1
      real(kind=realtype) :: result1
      real(kind=realtype) :: arg2
      real(kind=realtype) :: result2
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: abs2
      real(kind=realtype) :: abs1
      real(kind=realtype) :: max2
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
      porflux = half*rfil
      if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
      gm1 = gammaface - one
      gm53 = gammaface - five*third
! determine which riemann solver must be solved.
      select case  (riemannused) 
      case (roe) 
! determine the preconditioner used.
        select case  (precond) 
        case (noprecond) 
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
          z1l = sqrt(left(irho))
          z1r = sqrt(right(irho))
          tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
          if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
            ktmp(1) = left(itu1)
            ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
            drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
            kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
          else
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
            drk = 0.0
            kavg = 0.0
          end if
! compute the total energy of the left and right state.
          call etot(left(irho), left(ivx), left(ivy), left(ivz), left(&
&             irhoe), ktmp(1), etl, correctfork)
          call etot(right(irho), right(ivx), right(ivy), right(ivz), &
&             right(irhoe), ktmp(2), etr, correctfork)
! compute the difference of the conservative mean
! flow variables.
          dr = right(irho) - left(irho)
          dru = right(irho)*right(ivx) - left(irho)*left(ivx)
          drv = right(irho)*right(ivy) - left(irho)*left(ivy)
          drw = right(irho)*right(ivz) - left(irho)*left(ivz)
          dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
          ravg = fourth*(z1r+z1l)**2
          uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
          vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
          wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
          havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
          arg1 = sx**2 + sy**2 + sz**2
          area = sqrt(arg1)
          if (1.e-25_realtype .lt. area) then
            max2 = area
          else
            max2 = 1.e-25_realtype
          end if
          tmp = one/max2
          sx = sx*tmp
          sy = sy*tmp
          sz = sz*tmp
          rface = sface*tmp
! compute some dependent variables at the roe
! average state.
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
            a2avg = gm1*(havg-alphaavg) - gm53*kavg
          else
            a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
          end if
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
          if (por .eq. boundflux) unavg = rface
          x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&           left(ivz)-right(ivz))*sz
          if (x1 .ge. 0.) then
            abs1 = x1
          else
            abs1 = -x1
          end if
          arg1 = gammaface*left(irhoe)/left(irho)
          result1 = sqrt(arg1)
          arg2 = gammaface*right(irhoe)/right(irho)
          result2 = sqrt(arg2)
          x2 = result1 - result2
          if (x2 .ge. 0.) then
            abs2 = x2
          else
            abs2 = -x2
          end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
          eta = half*(abs1+abs2)
          if (unavg - rface + aavg .ge. 0.) then
            lam1 = unavg - rface + aavg
          else
            lam1 = -(unavg-rface+aavg)
          end if
          if (unavg - rface - aavg .ge. 0.) then
            lam2 = unavg - rface - aavg
          else
            lam2 = -(unavg-rface-aavg)
          end if
          if (unavg - rface .ge. 0.) then
            lam3 = unavg - rface
          else
            lam3 = -(unavg-rface)
          end if
! apply the entropy correction to the eigenvalues.
          tmp = two*eta
          if (lam1 .lt. tmp) lam1 = eta + fourth*lam1*lam1/eta
          if (lam2 .lt. tmp) lam2 = eta + fourth*lam2*lam2/eta
          if (lam3 .lt. tmp) lam3 = eta + fourth*lam3*lam3/eta
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1 = lam1*area
          lam2 = lam2*area
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
          flux(irho) = -(porflux*(lam3*dr+abv6))
          flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
          flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
          flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
          flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
        case (turkel) 
!          tmp = max(lam1,lam2,lam3)
!          flux(irho)  = -porflux*(tmp*dr)
!          flux(imx)   = -porflux*(tmp*dru)
!          flux(imy)   = -porflux*(tmp*drv)
!          flux(imz)   = -porflux*(tmp*drw)
!          flux(irhoe) = -porflux*(tmp*dre)
          call terminate('riemannflux', &
&                  'turkel preconditioner not implemented yet')
        case (choimerkle) 
          call terminate('riemannflux', &
&                  'choi merkle preconditioner not implemented yet')
        end select
      case (vanleer) 
        call terminate('riemannflux', 'van leer fvs not implemented yet'&
&               )
      case (ausmdv) 
        call terminate('riemannflux', 'ausmdv fvs not implemented yet')
      end select
    end subroutine riemannflux
  end subroutine inviscidupwindflux
!  differentiation of inviscidupwindflux in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw
!   with respect to varying inputs: *p *w *si *sj *sk *fw
!   rw status of diff variables: *p:in *w:in *si:in *sj:in *sk:in
!                *fw:in-out
!   plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
  subroutine inviscidupwindflux_d(finegrid)
!
!       inviscidupwindflux computes the artificial dissipation part of 
!       the euler fluxes by means of an approximate solution of the 1d 
!       riemann problem on the face. for first order schemes,          
!       finegrid == .false., the states in the cells are assumed to    
!       be constant; for the second order schemes on the fine grid a   
!       nonlinear reconstruction of the left and right state is done   
!       for which several options exist.                               
!       it is assumed that the pointers in blockpointers already       
!       point to the correct block.                                    
!
    use constants
    use blockpointers, only : il, jl, kl, ie, je, ke, ib, jb, kb, w, &
&   wd, p, pd, pori, porj, pork, fw, fwd, gamma, si, sid, sj, sjd, sk, &
&   skd, indfamilyi, indfamilyj, indfamilyk, spectralsol, &
&   addgridvelocities, sfacei, sfacej, sfacek, rotmatrixi, rotmatrixj, &
&   rotmatrixk, factfamilyi, factfamilyj, factfamilyk
    use flowvarrefstate, only : kpresent, nw, nwf, rgas, rgasd, tref, &
&   trefd
    use inputdiscretization, only : limiter, lumpeddiss, precond, &
&   riemann, riemanncoarse, orderturb, kappacoef
    use inputphysics, only : equations
    use iteration, only : rfil, currentlevel, groundlevel
    use cgnsgrid, only : massflowfamilydiss
    use utils_d, only : getcorrectfork, terminate
    use flowutils_d, only : etot, etot_d
    implicit none
!
!      subroutine arguments.
!
    logical, intent(in) :: finegrid
!
!      local variables.
!
    integer(kind=portype) :: por
    integer(kind=inttype) :: nwint
    integer(kind=inttype) :: i, j, k, ind
    integer(kind=inttype) :: limused, riemannused
    real(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
    real(kind=realtype) :: sxd, syd, szd
    real(kind=realtype) :: factminmod, sface
    real(kind=realtype), dimension(nw) :: left, right
    real(kind=realtype), dimension(nw) :: leftd, rightd
    real(kind=realtype), dimension(nw) :: du1, du2, du3
    real(kind=realtype), dimension(nw) :: du1d, du2d, du3d
    real(kind=realtype), dimension(nwf) :: flux
    real(kind=realtype), dimension(nwf) :: fluxd
    logical :: firstorderk, correctfork, rotationalperiodic
    intrinsic abs
    intrinsic associated
    intrinsic max
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! check if the formulation for rotational periodic problems
! must be used.
      if (associated(rotmatrixi)) then
        rotationalperiodic = .true.
      else
        rotationalperiodic = .false.
      end if
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      sfil = one - rfil
      do k=2,kl
        do j=2,jl
          do i=2,il
            fwd(i, j, k, irho) = sfil*fwd(i, j, k, irho)
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fwd(i, j, k, imx) = sfil*fwd(i, j, k, imx)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fwd(i, j, k, imy) = sfil*fwd(i, j, k, imy)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fwd(i, j, k, imz) = sfil*fwd(i, j, k, imz)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fwd(i, j, k, irhoe) = sfil*fwd(i, j, k, irhoe)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
      if (1.e-10_realtype .lt. one - kappacoef) then
        max1 = one - kappacoef
      else
        max1 = 1.e-10_realtype
      end if
! compute the factor used in the minmod limiter.
      factminmod = (three-kappacoef)/max1
! determine the limiter scheme to be used. on the fine grid the
! user specified scheme is used; on the coarse grid a first order
! scheme is computed.
      limused = firstorder
      if (finegrid) limused = limiter
! lumped diss is true for doing approx pc
      if (lumpeddiss) limused = firstorder
! determine the riemann solver which must be used.
      riemannused = riemanncoarse
      if (finegrid) riemannused = riemann
! store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
      omk = fourth*(one-kappacoef)
      opk = fourth*(one+kappacoef)
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set the number of variables to be interpolated depending
! whether or not a k-equation is present. if a k-equation is
! present also set the logical firstorderk. this indicates
! whether or not only a first order approximation is to be used
! for the turbulent kinetic energy.
      if (correctfork) then
        if (orderturb .eq. firstorder) then
          nwint = nwf
          firstorderk = .true.
        else
          nwint = itu1
          firstorderk = .false.
        end if
      else
        nwint = nwf
        firstorderk = .false.
      end if
!
!       flux computation. a distinction is made between first and      
!       second order schemes to avoid the overhead for the first order 
!       scheme.                                                        
!
      if (limused .eq. firstorder) then
        fluxd = 0.0_8
        leftd = 0.0_8
        rightd = 0.0_8
!
!         first order reconstruction. the states in the cells are      
!         constant. the left and right states are constructed easily.  
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sxd = sid(i, j, k, 1)
              sx = si(i, j, k, 1)
              syd = sid(i, j, k, 2)
              sy = si(i, j, k, 2)
              szd = sid(i, j, k, 3)
              sz = si(i, j, k, 3)
              por = pori(i, j, k)
              if (addgridvelocities) sface = sfacei(i, j, k)
! determine the left and right state.
              leftd(irho) = wd(i, j, k, irho)
              left(irho) = w(i, j, k, irho)
              leftd(ivx) = wd(i, j, k, ivx)
              left(ivx) = w(i, j, k, ivx)
              leftd(ivy) = wd(i, j, k, ivy)
              left(ivy) = w(i, j, k, ivy)
              leftd(ivz) = wd(i, j, k, ivz)
              left(ivz) = w(i, j, k, ivz)
              leftd(irhoe) = pd(i, j, k)
              left(irhoe) = p(i, j, k)
              if (correctfork) then
                leftd(itu1) = wd(i, j, k, itu1)
                left(itu1) = w(i, j, k, itu1)
              end if
              rightd(irho) = wd(i+1, j, k, irho)
              right(irho) = w(i+1, j, k, irho)
              rightd(ivx) = wd(i+1, j, k, ivx)
              right(ivx) = w(i+1, j, k, ivx)
              rightd(ivy) = wd(i+1, j, k, ivy)
              right(ivy) = w(i+1, j, k, ivy)
              rightd(ivz) = wd(i+1, j, k, ivz)
              right(ivz) = w(i+1, j, k, ivz)
              rightd(irhoe) = pd(i+1, j, k)
              right(irhoe) = p(i+1, j, k)
              if (correctfork) then
                rightd(itu1) = wd(i+1, j, k, itu1)
                right(itu1) = w(i+1, j, k, itu1)
              end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
              call riemannflux_d(left, leftd, right, rightd, flux, fluxd&
&                         )
! and scatter it to the left and right.
              fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) - fluxd(irho)
              fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
              fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) - fluxd(imx)
              fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
              fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) - fluxd(imy)
              fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
              fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) - fluxd(imz)
              fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
              fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) - fluxd(&
&               irhoe)
              fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sxd = sjd(i, j, k, 1)
              sx = sj(i, j, k, 1)
              syd = sjd(i, j, k, 2)
              sy = sj(i, j, k, 2)
              szd = sjd(i, j, k, 3)
              sz = sj(i, j, k, 3)
              por = porj(i, j, k)
              if (addgridvelocities) sface = sfacej(i, j, k)
! determine the left and right state.
              leftd(irho) = wd(i, j, k, irho)
              left(irho) = w(i, j, k, irho)
              leftd(ivx) = wd(i, j, k, ivx)
              left(ivx) = w(i, j, k, ivx)
              leftd(ivy) = wd(i, j, k, ivy)
              left(ivy) = w(i, j, k, ivy)
              leftd(ivz) = wd(i, j, k, ivz)
              left(ivz) = w(i, j, k, ivz)
              leftd(irhoe) = pd(i, j, k)
              left(irhoe) = p(i, j, k)
              if (correctfork) then
                leftd(itu1) = wd(i, j, k, itu1)
                left(itu1) = w(i, j, k, itu1)
              end if
              rightd(irho) = wd(i, j+1, k, irho)
              right(irho) = w(i, j+1, k, irho)
              rightd(ivx) = wd(i, j+1, k, ivx)
              right(ivx) = w(i, j+1, k, ivx)
              rightd(ivy) = wd(i, j+1, k, ivy)
              right(ivy) = w(i, j+1, k, ivy)
              rightd(ivz) = wd(i, j+1, k, ivz)
              right(ivz) = w(i, j+1, k, ivz)
              rightd(irhoe) = pd(i, j+1, k)
              right(irhoe) = p(i, j+1, k)
              if (correctfork) then
                rightd(itu1) = wd(i, j+1, k, itu1)
                right(itu1) = w(i, j+1, k, itu1)
              end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
              call riemannflux_d(left, leftd, right, rightd, flux, fluxd&
&                         )
! and scatter it to the left and right.
              fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) - fluxd(irho)
              fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
              fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) - fluxd(imx)
              fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
              fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) - fluxd(imy)
              fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
              fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) - fluxd(imz)
              fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
              fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) - fluxd(&
&               irhoe)
              fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sxd = skd(i, j, k, 1)
              sx = sk(i, j, k, 1)
              syd = skd(i, j, k, 2)
              sy = sk(i, j, k, 2)
              szd = skd(i, j, k, 3)
              sz = sk(i, j, k, 3)
              por = pork(i, j, k)
              if (addgridvelocities) sface = sfacek(i, j, k)
! determine the left and right state.
              leftd(irho) = wd(i, j, k, irho)
              left(irho) = w(i, j, k, irho)
              leftd(ivx) = wd(i, j, k, ivx)
              left(ivx) = w(i, j, k, ivx)
              leftd(ivy) = wd(i, j, k, ivy)
              left(ivy) = w(i, j, k, ivy)
              leftd(ivz) = wd(i, j, k, ivz)
              left(ivz) = w(i, j, k, ivz)
              leftd(irhoe) = pd(i, j, k)
              left(irhoe) = p(i, j, k)
              if (correctfork) then
                leftd(itu1) = wd(i, j, k, itu1)
                left(itu1) = w(i, j, k, itu1)
              end if
              rightd(irho) = wd(i, j, k+1, irho)
              right(irho) = w(i, j, k+1, irho)
              rightd(ivx) = wd(i, j, k+1, ivx)
              right(ivx) = w(i, j, k+1, ivx)
              rightd(ivy) = wd(i, j, k+1, ivy)
              right(ivy) = w(i, j, k+1, ivy)
              rightd(ivz) = wd(i, j, k+1, ivz)
              right(ivz) = w(i, j, k+1, ivz)
              rightd(irhoe) = pd(i, j, k+1)
              right(irhoe) = p(i, j, k+1)
              if (correctfork) then
                rightd(itu1) = wd(i, j, k+1, itu1)
                right(itu1) = w(i, j, k+1, itu1)
              end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
              call riemannflux_d(left, leftd, right, rightd, flux, fluxd&
&                         )
! and scatter it the left and right.
              fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) - fluxd(irho)
              fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
              fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) - fluxd(imx)
              fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
              fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) - fluxd(imy)
              fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
              fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) - fluxd(imz)
              fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
              fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) - fluxd(&
&               irhoe)
              fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
            end do
          end do
        end do
      else
        fluxd = 0.0_8
        leftd = 0.0_8
        rightd = 0.0_8
        du1d = 0.0_8
        du2d = 0.0_8
        du3d = 0.0_8
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
!      ==================================================================
!
!         second order reconstruction of the left and right state.     
!         the three differences used in the, possibly nonlinear,       
!         interpolation are constructed here; the actual left and      
!         right states, or at least the differences from the first     
!         order interpolation, are computed in the subroutine          
!         leftrightstate.                                              
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1d(irho) = wd(i, j, k, irho) - wd(i-1, j, k, irho)
              du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
              du2d(irho) = wd(i+1, j, k, irho) - wd(i, j, k, irho)
              du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
              du3d(irho) = wd(i+2, j, k, irho) - wd(i+1, j, k, irho)
              du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
              du1d(ivx) = wd(i, j, k, ivx) - wd(i-1, j, k, ivx)
              du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
              du2d(ivx) = wd(i+1, j, k, ivx) - wd(i, j, k, ivx)
              du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
              du3d(ivx) = wd(i+2, j, k, ivx) - wd(i+1, j, k, ivx)
              du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
              du1d(ivy) = wd(i, j, k, ivy) - wd(i-1, j, k, ivy)
              du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
              du2d(ivy) = wd(i+1, j, k, ivy) - wd(i, j, k, ivy)
              du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
              du3d(ivy) = wd(i+2, j, k, ivy) - wd(i+1, j, k, ivy)
              du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
              du1d(ivz) = wd(i, j, k, ivz) - wd(i-1, j, k, ivz)
              du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
              du2d(ivz) = wd(i+1, j, k, ivz) - wd(i, j, k, ivz)
              du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
              du3d(ivz) = wd(i+2, j, k, ivz) - wd(i+1, j, k, ivz)
              du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
              du1d(irhoe) = pd(i, j, k) - pd(i-1, j, k)
              du1(irhoe) = p(i, j, k) - p(i-1, j, k)
              du2d(irhoe) = pd(i+1, j, k) - pd(i, j, k)
              du2(irhoe) = p(i+1, j, k) - p(i, j, k)
              du3d(irhoe) = pd(i+2, j, k) - pd(i+1, j, k)
              du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
              if (correctfork) then
                du1d(itu1) = wd(i, j, k, itu1) - wd(i-1, j, k, itu1)
                du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
                du2d(itu1) = wd(i+1, j, k, itu1) - wd(i, j, k, itu1)
                du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
                du3d(itu1) = wd(i+2, j, k, itu1) - wd(i+1, j, k, itu1)
                du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, &
&                             rotmatrixi, left, leftd, right, rightd)
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              leftd(irho) = leftd(irho) + wd(i, j, k, irho)
              left(irho) = left(irho) + w(i, j, k, irho)
              leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
              left(irhoe) = left(irhoe) + p(i, j, k)
              rightd(irho) = rightd(irho) + wd(i+1, j, k, irho)
              right(irho) = right(irho) + w(i+1, j, k, irho)
              rightd(ivx) = rightd(ivx) + wd(i+1, j, k, ivx)
              right(ivx) = right(ivx) + w(i+1, j, k, ivx)
              rightd(ivy) = rightd(ivy) + wd(i+1, j, k, ivy)
              right(ivy) = right(ivy) + w(i+1, j, k, ivy)
              rightd(ivz) = rightd(ivz) + wd(i+1, j, k, ivz)
              right(ivz) = right(ivz) + w(i+1, j, k, ivz)
              rightd(irhoe) = rightd(irhoe) + pd(i+1, j, k)
              right(irhoe) = right(irhoe) + p(i+1, j, k)
              if (correctfork) then
                leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                rightd(itu1) = rightd(itu1) + wd(i+1, j, k, itu1)
                right(itu1) = right(itu1) + w(i+1, j, k, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sxd = sid(i, j, k, 1)
              sx = si(i, j, k, 1)
              syd = sid(i, j, k, 2)
              sy = si(i, j, k, 2)
              szd = sid(i, j, k, 3)
              sz = si(i, j, k, 3)
              por = pori(i, j, k)
              if (addgridvelocities) sface = sfacei(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
              call riemannflux_d(left, leftd, right, rightd, flux, fluxd&
&                         )
! and scatter it to the left and right.
              fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) - fluxd(irho)
              fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
              fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) - fluxd(imx)
              fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
              fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) - fluxd(imy)
              fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
              fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) - fluxd(imz)
              fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
              fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) - fluxd(&
&               irhoe)
              fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1d(irho) = wd(i, j, k, irho) - wd(i, j-1, k, irho)
              du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
              du2d(irho) = wd(i, j+1, k, irho) - wd(i, j, k, irho)
              du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
              du3d(irho) = wd(i, j+2, k, irho) - wd(i, j+1, k, irho)
              du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
              du1d(ivx) = wd(i, j, k, ivx) - wd(i, j-1, k, ivx)
              du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
              du2d(ivx) = wd(i, j+1, k, ivx) - wd(i, j, k, ivx)
              du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
              du3d(ivx) = wd(i, j+2, k, ivx) - wd(i, j+1, k, ivx)
              du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
              du1d(ivy) = wd(i, j, k, ivy) - wd(i, j-1, k, ivy)
              du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
              du2d(ivy) = wd(i, j+1, k, ivy) - wd(i, j, k, ivy)
              du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
              du3d(ivy) = wd(i, j+2, k, ivy) - wd(i, j+1, k, ivy)
              du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
              du1d(ivz) = wd(i, j, k, ivz) - wd(i, j-1, k, ivz)
              du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
              du2d(ivz) = wd(i, j+1, k, ivz) - wd(i, j, k, ivz)
              du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
              du3d(ivz) = wd(i, j+2, k, ivz) - wd(i, j+1, k, ivz)
              du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
              du1d(irhoe) = pd(i, j, k) - pd(i, j-1, k)
              du1(irhoe) = p(i, j, k) - p(i, j-1, k)
              du2d(irhoe) = pd(i, j+1, k) - pd(i, j, k)
              du2(irhoe) = p(i, j+1, k) - p(i, j, k)
              du3d(irhoe) = pd(i, j+2, k) - pd(i, j+1, k)
              du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
              if (correctfork) then
                du1d(itu1) = wd(i, j, k, itu1) - wd(i, j-1, k, itu1)
                du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
                du2d(itu1) = wd(i, j+1, k, itu1) - wd(i, j, k, itu1)
                du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
                du3d(itu1) = wd(i, j+2, k, itu1) - wd(i, j+1, k, itu1)
                du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, &
&                             rotmatrixj, left, leftd, right, rightd)
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              leftd(irho) = leftd(irho) + wd(i, j, k, irho)
              left(irho) = left(irho) + w(i, j, k, irho)
              leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
              left(irhoe) = left(irhoe) + p(i, j, k)
              rightd(irho) = rightd(irho) + wd(i, j+1, k, irho)
              right(irho) = right(irho) + w(i, j+1, k, irho)
              rightd(ivx) = rightd(ivx) + wd(i, j+1, k, ivx)
              right(ivx) = right(ivx) + w(i, j+1, k, ivx)
              rightd(ivy) = rightd(ivy) + wd(i, j+1, k, ivy)
              right(ivy) = right(ivy) + w(i, j+1, k, ivy)
              rightd(ivz) = rightd(ivz) + wd(i, j+1, k, ivz)
              right(ivz) = right(ivz) + w(i, j+1, k, ivz)
              rightd(irhoe) = rightd(irhoe) + pd(i, j+1, k)
              right(irhoe) = right(irhoe) + p(i, j+1, k)
              if (correctfork) then
                leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                rightd(itu1) = rightd(itu1) + wd(i, j+1, k, itu1)
                right(itu1) = right(itu1) + w(i, j+1, k, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sxd = sjd(i, j, k, 1)
              sx = sj(i, j, k, 1)
              syd = sjd(i, j, k, 2)
              sy = sj(i, j, k, 2)
              szd = sjd(i, j, k, 3)
              sz = sj(i, j, k, 3)
              por = porj(i, j, k)
              if (addgridvelocities) sface = sfacej(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
              call riemannflux_d(left, leftd, right, rightd, flux, fluxd&
&                         )
! and scatter it to the left and right.
              fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) - fluxd(irho)
              fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
              fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) - fluxd(imx)
              fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
              fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) - fluxd(imy)
              fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
              fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) - fluxd(imz)
              fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
              fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) - fluxd(&
&               irhoe)
              fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1d(irho) = wd(i, j, k, irho) - wd(i, j, k-1, irho)
              du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
              du2d(irho) = wd(i, j, k+1, irho) - wd(i, j, k, irho)
              du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
              du3d(irho) = wd(i, j, k+2, irho) - wd(i, j, k+1, irho)
              du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
              du1d(ivx) = wd(i, j, k, ivx) - wd(i, j, k-1, ivx)
              du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
              du2d(ivx) = wd(i, j, k+1, ivx) - wd(i, j, k, ivx)
              du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
              du3d(ivx) = wd(i, j, k+2, ivx) - wd(i, j, k+1, ivx)
              du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
              du1d(ivy) = wd(i, j, k, ivy) - wd(i, j, k-1, ivy)
              du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
              du2d(ivy) = wd(i, j, k+1, ivy) - wd(i, j, k, ivy)
              du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
              du3d(ivy) = wd(i, j, k+2, ivy) - wd(i, j, k+1, ivy)
              du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
              du1d(ivz) = wd(i, j, k, ivz) - wd(i, j, k-1, ivz)
              du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
              du2d(ivz) = wd(i, j, k+1, ivz) - wd(i, j, k, ivz)
              du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
              du3d(ivz) = wd(i, j, k+2, ivz) - wd(i, j, k+1, ivz)
              du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
              du1d(irhoe) = pd(i, j, k) - pd(i, j, k-1)
              du1(irhoe) = p(i, j, k) - p(i, j, k-1)
              du2d(irhoe) = pd(i, j, k+1) - pd(i, j, k)
              du2(irhoe) = p(i, j, k+1) - p(i, j, k)
              du3d(irhoe) = pd(i, j, k+2) - pd(i, j, k+1)
              du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
              if (correctfork) then
                du1d(itu1) = wd(i, j, k, itu1) - wd(i, j, k-1, itu1)
                du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
                du2d(itu1) = wd(i, j, k+1, itu1) - wd(i, j, k, itu1)
                du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
                du3d(itu1) = wd(i, j, k+2, itu1) - wd(i, j, k+1, itu1)
                du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, &
&                             rotmatrixk, left, leftd, right, rightd)
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              leftd(irho) = leftd(irho) + wd(i, j, k, irho)
              left(irho) = left(irho) + w(i, j, k, irho)
              leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
              left(irhoe) = left(irhoe) + p(i, j, k)
              rightd(irho) = rightd(irho) + wd(i, j, k+1, irho)
              right(irho) = right(irho) + w(i, j, k+1, irho)
              rightd(ivx) = rightd(ivx) + wd(i, j, k+1, ivx)
              right(ivx) = right(ivx) + w(i, j, k+1, ivx)
              rightd(ivy) = rightd(ivy) + wd(i, j, k+1, ivy)
              right(ivy) = right(ivy) + w(i, j, k+1, ivy)
              rightd(ivz) = rightd(ivz) + wd(i, j, k+1, ivz)
              right(ivz) = right(ivz) + w(i, j, k+1, ivz)
              rightd(irhoe) = rightd(irhoe) + pd(i, j, k+1)
              right(irhoe) = right(irhoe) + p(i, j, k+1)
              if (correctfork) then
                leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                rightd(itu1) = rightd(itu1) + wd(i, j, k+1, itu1)
                right(itu1) = right(itu1) + w(i, j, k+1, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sxd = skd(i, j, k, 1)
              sx = sk(i, j, k, 1)
              syd = skd(i, j, k, 2)
              sy = sk(i, j, k, 2)
              szd = skd(i, j, k, 3)
              sz = sk(i, j, k, 3)
              por = pork(i, j, k)
              if (addgridvelocities) sface = sfacek(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
              call riemannflux_d(left, leftd, right, rightd, flux, fluxd&
&                         )
! and scatter it to the left and right.
              fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) - fluxd(irho)
              fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
              fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) - fluxd(imx)
              fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
              fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) - fluxd(imy)
              fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
              fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) - fluxd(imz)
              fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
              fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) - fluxd(&
&               irhoe)
              fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
            end do
          end do
        end do
      end if
    end if

  contains
!  differentiation of leftrightstate in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: left right du1 du2 du3
!   with respect to varying inputs: left right du1 du2 du3
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
    subroutine leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, &
&     rotmatrix, left, leftd, right, rightd)
      implicit none
!
!        local parameter.
!
      real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
      real(kind=realtype), dimension(:), intent(inout) :: du1d, du2d, &
&     du3d
      real(kind=realtype), dimension(:), intent(out) :: left, right
      real(kind=realtype), dimension(:), intent(out) :: leftd, rightd
      real(kind=realtype), dimension(:, :, :, :, :), pointer :: &
&     rotmatrix
!
!        local variables.
!
      integer(kind=inttype) :: l
      real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
      real(kind=realtype) :: rl1d, rl2d, rr1d, rr2d, tmpd, dvxd, dvyd, &
&     dvzd
      real(kind=realtype), dimension(3, 3) :: rot
      intrinsic abs
      intrinsic max
      intrinsic sign
      intrinsic min
      real(kind=realtype) :: x6d
      real(kind=realtype) :: y4d
      real(kind=realtype) :: max2d
      real(kind=realtype) :: max5d
      real(kind=realtype) :: x6
      real(kind=realtype) :: x5
      real(kind=realtype) :: x4
      real(kind=realtype) :: x3
      real(kind=realtype) :: x2
      real(kind=realtype) :: x2d
      real(kind=realtype) :: x1
      real(kind=realtype) :: x5d
      real(kind=realtype) :: y3d
      real(kind=realtype) :: max4d
      real(kind=realtype) :: max7d
      real(kind=realtype) :: x1d
      real(kind=realtype) :: x4d
      real(kind=realtype) :: y2d
      real(kind=realtype) :: max3d
      real(kind=realtype) :: max7
      real(kind=realtype) :: max6
      real(kind=realtype) :: max6d
      real(kind=realtype) :: max5
      real(kind=realtype) :: max4
      real(kind=realtype) :: max3
      real(kind=realtype) :: max2
      real(kind=realtype) :: y4
      real(kind=realtype) :: y3
      real(kind=realtype) :: y2
      real(kind=realtype) :: x3d
      real(kind=realtype) :: y1
      real(kind=realtype) :: y1d
! check if the velocity components should be transformed to
! the cylindrical frame.
      if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
        rot(1, 1) = rotmatrix(i, j, k, 1, 1)
        rot(1, 2) = rotmatrix(i, j, k, 1, 2)
        rot(1, 3) = rotmatrix(i, j, k, 1, 3)
        rot(2, 1) = rotmatrix(i, j, k, 2, 1)
        rot(2, 2) = rotmatrix(i, j, k, 2, 2)
        rot(2, 3) = rotmatrix(i, j, k, 2, 3)
        rot(3, 1) = rotmatrix(i, j, k, 3, 1)
        rot(3, 2) = rotmatrix(i, j, k, 3, 2)
        rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
        dvxd = du1d(ivx)
        dvx = du1(ivx)
        dvyd = du1d(ivy)
        dvy = du1(ivy)
        dvzd = du1d(ivz)
        dvz = du1(ivz)
        du1d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
        du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du1d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
        du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du1d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
        du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvxd = du2d(ivx)
        dvx = du2(ivx)
        dvyd = du2d(ivy)
        dvy = du2(ivy)
        dvzd = du2d(ivz)
        dvz = du2(ivz)
        du2d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
        du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du2d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
        du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du2d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
        du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvxd = du3d(ivx)
        dvx = du3(ivx)
        dvyd = du3d(ivy)
        dvy = du3(ivy)
        dvzd = du3d(ivz)
        dvz = du3(ivz)
        du3d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
        du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du3d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
        du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du3d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
        du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      end if
! determine the limiter used.
      select case  (limused) 
      case (nolimiter) 
! linear interpolation; no limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          leftd(l) = omk*du1d(l) + opk*du2d(l)
          left(l) = omk*du1(l) + opk*du2(l)
          rightd(l) = -(omk*du3d(l)) - opk*du2d(l)
          right(l) = -(omk*du3(l)) - opk*du2(l)
        end do
      case (vanalbeda) 
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x1d = du2d(l)
            x1 = du2(l)
          else
            x1d = -du2d(l)
            x1 = -du2(l)
          end if
          if (x1 .lt. epslim) then
            max2 = epslim
            max2d = 0.0_8
          else
            max2d = x1d
            max2 = x1
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmpd = -(one*max2d*sign(1.d0, max2*du2(l))/sign(max2, du2(l))&
&           **2)
          tmp = one/sign(max2, du2(l))
          if (du1(l) .ge. 0.) then
            x3d = du1d(l)
            x3 = du1(l)
          else
            x3d = -du1d(l)
            x3 = -du1(l)
          end if
          if (x3 .lt. epslim) then
            max4 = epslim
            max4d = 0.0_8
          else
            max4d = x3d
            max4 = x3
          end if
          y1d = (du2d(l)*sign(max4, du1(l))-du2(l)*max4d*sign(1.d0, max4&
&           *du1(l)))/sign(max4, du1(l))**2
          y1 = du2(l)/sign(max4, du1(l))
          if (zero .lt. y1) then
            rl1d = y1d
            rl1 = y1
          else
            rl1 = zero
            rl1d = 0.0_8
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2d = du1d(l)*tmp + du1(l)*tmpd
            rl2 = du1(l)*tmp
          else
            rl2 = zero
            rl2d = 0.0_8
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1d = du3d(l)*tmp + du3(l)*tmpd
            rr1 = du3(l)*tmp
          else
            rr1 = zero
            rr1d = 0.0_8
          end if
          if (du3(l) .ge. 0.) then
            x4d = du3d(l)
            x4 = du3(l)
          else
            x4d = -du3d(l)
            x4 = -du3(l)
          end if
          if (x4 .lt. epslim) then
            max5 = epslim
            max5d = 0.0_8
          else
            max5d = x4d
            max5 = x4
          end if
          y2d = (du2d(l)*sign(max5, du3(l))-du2(l)*max5d*sign(1.d0, max5&
&           *du3(l)))/sign(max5, du3(l))**2
          y2 = du2(l)/sign(max5, du3(l))
          if (zero .lt. y2) then
            rr2d = y2d
            rr2 = y2
          else
            rr2 = zero
            rr2d = 0.0_8
          end if
! compute the corresponding limiter values.
          rl1d = ((rl1d*(rl1+one)+rl1*rl1d)*(rl1*rl1+one)-rl1*(rl1+one)*&
&           (rl1d*rl1+rl1*rl1d))/(rl1*rl1+one)**2
          rl1 = rl1*(rl1+one)/(rl1*rl1+one)
          rl2d = ((rl2d*(rl2+one)+rl2*rl2d)*(rl2*rl2+one)-rl2*(rl2+one)*&
&           (rl2d*rl2+rl2*rl2d))/(rl2*rl2+one)**2
          rl2 = rl2*(rl2+one)/(rl2*rl2+one)
          rr1d = ((rr1d*(rr1+one)+rr1*rr1d)*(rr1*rr1+one)-rr1*(rr1+one)*&
&           (rr1d*rr1+rr1*rr1d))/(rr1*rr1+one)**2
          rr1 = rr1*(rr1+one)/(rr1*rr1+one)
          rr2d = ((rr2d*(rr2+one)+rr2*rr2d)*(rr2*rr2+one)-rr2*(rr2+one)*&
&           (rr2d*rr2+rr2*rr2d))/(rr2*rr2+one)**2
          rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
          leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+&
&           rl2*du2d(l))
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l&
&           )+rr2*du3d(l))
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      case (minmod) 
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x2d = du2d(l)
            x2 = du2(l)
          else
            x2d = -du2d(l)
            x2 = -du2(l)
          end if
          if (x2 .lt. epslim) then
            max3 = epslim
            max3d = 0.0_8
          else
            max3d = x2d
            max3 = x2
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmpd = -(one*max3d*sign(1.d0, max3*du2(l))/sign(max3, du2(l))&
&           **2)
          tmp = one/sign(max3, du2(l))
          if (du1(l) .ge. 0.) then
            x5d = du1d(l)
            x5 = du1(l)
          else
            x5d = -du1d(l)
            x5 = -du1(l)
          end if
          if (x5 .lt. epslim) then
            max6 = epslim
            max6d = 0.0_8
          else
            max6d = x5d
            max6 = x5
          end if
          y3d = (du2d(l)*sign(max6, du1(l))-du2(l)*max6d*sign(1.d0, max6&
&           *du1(l)))/sign(max6, du1(l))**2
          y3 = du2(l)/sign(max6, du1(l))
          if (zero .lt. y3) then
            rl1d = y3d
            rl1 = y3
          else
            rl1 = zero
            rl1d = 0.0_8
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2d = du1d(l)*tmp + du1(l)*tmpd
            rl2 = du1(l)*tmp
          else
            rl2 = zero
            rl2d = 0.0_8
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1d = du3d(l)*tmp + du3(l)*tmpd
            rr1 = du3(l)*tmp
          else
            rr1 = zero
            rr1d = 0.0_8
          end if
          if (du3(l) .ge. 0.) then
            x6d = du3d(l)
            x6 = du3(l)
          else
            x6d = -du3d(l)
            x6 = -du3(l)
          end if
          if (x6 .lt. epslim) then
            max7 = epslim
            max7d = 0.0_8
          else
            max7d = x6d
            max7 = x6
          end if
          y4d = (du2d(l)*sign(max7, du3(l))-du2(l)*max7d*sign(1.d0, max7&
&           *du3(l)))/sign(max7, du3(l))**2
          y4 = du2(l)/sign(max7, du3(l))
          if (zero .lt. y4) then
            rr2d = y4d
            rr2 = y4
          else
            rr2 = zero
            rr2d = 0.0_8
          end if
          if (one .gt. factminmod*rl1) then
            rl1d = factminmod*rl1d
            rl1 = factminmod*rl1
          else
            rl1 = one
            rl1d = 0.0_8
          end if
          if (one .gt. factminmod*rl2) then
            rl2d = factminmod*rl2d
            rl2 = factminmod*rl2
          else
            rl2 = one
            rl2d = 0.0_8
          end if
          if (one .gt. factminmod*rr1) then
            rr1d = factminmod*rr1d
            rr1 = factminmod*rr1
          else
            rr1 = one
            rr1d = 0.0_8
          end if
          if (one .gt. factminmod*rr2) then
            rr2d = factminmod*rr2d
            rr2 = factminmod*rr2
          else
            rr2 = one
            rr2d = 0.0_8
          end if
! compute the nonlinear corrections to the first order
! scheme.
          leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+&
&           rl2*du2d(l))
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l&
&           )+rr2*du3d(l))
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
      if (firstorderk) then
        leftd(itu1) = 0.0_8
        left(itu1) = zero
        rightd(itu1) = 0.0_8
        right(itu1) = zero
      end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
      if (rotationalperiodic) then
! left state.
        dvxd = leftd(ivx)
        dvx = left(ivx)
        dvyd = leftd(ivy)
        dvy = left(ivy)
        dvzd = leftd(ivz)
        dvz = left(ivz)
        leftd(ivx) = rot(1, 1)*dvxd + rot(2, 1)*dvyd + rot(3, 1)*dvzd
        left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        leftd(ivy) = rot(1, 2)*dvxd + rot(2, 2)*dvyd + rot(3, 2)*dvzd
        left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        leftd(ivz) = rot(1, 3)*dvxd + rot(2, 3)*dvyd + rot(3, 3)*dvzd
        left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
! right state.
        dvxd = rightd(ivx)
        dvx = right(ivx)
        dvyd = rightd(ivy)
        dvy = right(ivy)
        dvzd = rightd(ivz)
        dvz = right(ivz)
        rightd(ivx) = rot(1, 1)*dvxd + rot(2, 1)*dvyd + rot(3, 1)*dvzd
        right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        rightd(ivy) = rot(1, 2)*dvxd + rot(2, 2)*dvyd + rot(3, 2)*dvzd
        right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        rightd(ivz) = rot(1, 3)*dvxd + rot(2, 3)*dvyd + rot(3, 3)*dvzd
        right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
      end if
    end subroutine leftrightstate_d
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
    subroutine leftrightstate(du1, du2, du3, rotmatrix, left, right)
      implicit none
!
!        local parameter.
!
      real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
      real(kind=realtype), dimension(:), intent(out) :: left, right
      real(kind=realtype), dimension(:, :, :, :, :), pointer :: &
&     rotmatrix
!
!        local variables.
!
      integer(kind=inttype) :: l
      real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
      real(kind=realtype), dimension(3, 3) :: rot
      intrinsic abs
      intrinsic max
      intrinsic sign
      intrinsic min
      real(kind=realtype) :: x6
      real(kind=realtype) :: x5
      real(kind=realtype) :: x4
      real(kind=realtype) :: x3
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: max7
      real(kind=realtype) :: max6
      real(kind=realtype) :: max5
      real(kind=realtype) :: max4
      real(kind=realtype) :: max3
      real(kind=realtype) :: max2
      real(kind=realtype) :: y4
      real(kind=realtype) :: y3
      real(kind=realtype) :: y2
      real(kind=realtype) :: y1
! check if the velocity components should be transformed to
! the cylindrical frame.
      if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
        rot(1, 1) = rotmatrix(i, j, k, 1, 1)
        rot(1, 2) = rotmatrix(i, j, k, 1, 2)
        rot(1, 3) = rotmatrix(i, j, k, 1, 3)
        rot(2, 1) = rotmatrix(i, j, k, 2, 1)
        rot(2, 2) = rotmatrix(i, j, k, 2, 2)
        rot(2, 3) = rotmatrix(i, j, k, 2, 3)
        rot(3, 1) = rotmatrix(i, j, k, 3, 1)
        rot(3, 2) = rotmatrix(i, j, k, 3, 2)
        rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
        dvx = du1(ivx)
        dvy = du1(ivy)
        dvz = du1(ivz)
        du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du2(ivx)
        dvy = du2(ivy)
        dvz = du2(ivz)
        du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du3(ivx)
        dvy = du3(ivy)
        dvz = du3(ivz)
        du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      end if
! determine the limiter used.
      select case  (limused) 
      case (nolimiter) 
! linear interpolation; no limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          left(l) = omk*du1(l) + opk*du2(l)
          right(l) = -(omk*du3(l)) - opk*du2(l)
        end do
      case (vanalbeda) 
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x1 = du2(l)
          else
            x1 = -du2(l)
          end if
          if (x1 .lt. epslim) then
            max2 = epslim
          else
            max2 = x1
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max2, du2(l))
          if (du1(l) .ge. 0.) then
            x3 = du1(l)
          else
            x3 = -du1(l)
          end if
          if (x3 .lt. epslim) then
            max4 = epslim
          else
            max4 = x3
          end if
          y1 = du2(l)/sign(max4, du1(l))
          if (zero .lt. y1) then
            rl1 = y1
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x4 = du3(l)
          else
            x4 = -du3(l)
          end if
          if (x4 .lt. epslim) then
            max5 = epslim
          else
            max5 = x4
          end if
          y2 = du2(l)/sign(max5, du3(l))
          if (zero .lt. y2) then
            rr2 = y2
          else
            rr2 = zero
          end if
! compute the corresponding limiter values.
          rl1 = rl1*(rl1+one)/(rl1*rl1+one)
          rl2 = rl2*(rl2+one)/(rl2*rl2+one)
          rr1 = rr1*(rr1+one)/(rr1*rr1+one)
          rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      case (minmod) 
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x2 = du2(l)
          else
            x2 = -du2(l)
          end if
          if (x2 .lt. epslim) then
            max3 = epslim
          else
            max3 = x2
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max3, du2(l))
          if (du1(l) .ge. 0.) then
            x5 = du1(l)
          else
            x5 = -du1(l)
          end if
          if (x5 .lt. epslim) then
            max6 = epslim
          else
            max6 = x5
          end if
          y3 = du2(l)/sign(max6, du1(l))
          if (zero .lt. y3) then
            rl1 = y3
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x6 = du3(l)
          else
            x6 = -du3(l)
          end if
          if (x6 .lt. epslim) then
            max7 = epslim
          else
            max7 = x6
          end if
          y4 = du2(l)/sign(max7, du3(l))
          if (zero .lt. y4) then
            rr2 = y4
          else
            rr2 = zero
          end if
          if (one .gt. factminmod*rl1) then
            rl1 = factminmod*rl1
          else
            rl1 = one
          end if
          if (one .gt. factminmod*rl2) then
            rl2 = factminmod*rl2
          else
            rl2 = one
          end if
          if (one .gt. factminmod*rr1) then
            rr1 = factminmod*rr1
          else
            rr1 = one
          end if
          if (one .gt. factminmod*rr2) then
            rr2 = factminmod*rr2
          else
            rr2 = one
          end if
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
      if (firstorderk) then
        left(itu1) = zero
        right(itu1) = zero
      end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
      if (rotationalperiodic) then
! left state.
        dvx = left(ivx)
        dvy = left(ivy)
        dvz = left(ivz)
        left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
! right state.
        dvx = right(ivx)
        dvy = right(ivy)
        dvz = right(ivz)
        right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
      end if
    end subroutine leftrightstate
!  differentiation of riemannflux in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: flux
!   with respect to varying inputs: sx sy sz flux left right
!        ================================================================
    subroutine riemannflux_d(left, leftd, right, rightd, flux, fluxd)
      implicit none
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(*), intent(in) :: left, right
      real(kind=realtype), dimension(*), intent(in) :: leftd, rightd
      real(kind=realtype), dimension(*), intent(out) :: flux
      real(kind=realtype), dimension(*), intent(out) :: fluxd
!
!        local variables.
!
      real(kind=realtype) :: porflux, rface
      real(kind=realtype) :: rfaced
      real(kind=realtype) :: etl, etr, z1l, z1r, tmp
      real(kind=realtype) :: etld, etrd, z1ld, z1rd, tmpd
      real(kind=realtype) :: dr, dru, drv, drw, dre, drk
      real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
      real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
      real(kind=realtype) :: uavgd, vavgd, wavgd, havgd, kavgd
      real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
      real(kind=realtype) :: alphaavgd, a2avgd, aavgd, unavgd
      real(kind=realtype) :: ovaavg, ova2avg, area, eta
      real(kind=realtype) :: ovaavgd, ova2avgd, aread, etad
      real(kind=realtype) :: gm1, gm53
      real(kind=realtype) :: lam1, lam2, lam3
      real(kind=realtype) :: lam1d, lam2d, lam3d
      real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
      real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
&     abv7d
      real(kind=realtype), dimension(2) :: ktmp
      real(kind=realtype), dimension(2) :: ktmpd
      intrinsic sqrt
      intrinsic max
      intrinsic abs
      real(kind=realtype) :: arg1
      real(kind=realtype) :: arg1d
      real(kind=realtype) :: result1
      real(kind=realtype) :: result1d
      real(kind=realtype) :: arg2
      real(kind=realtype) :: arg2d
      real(kind=realtype) :: result2
      real(kind=realtype) :: result2d
      real(kind=realtype) :: abs1d
      real(kind=realtype) :: max2d
      real(kind=realtype) :: x2
      real(kind=realtype) :: x2d
      real(kind=realtype) :: x1
      real(kind=realtype) :: x1d
      real(kind=realtype) :: abs2
      real(kind=realtype) :: abs2d
      real(kind=realtype) :: abs1
      real(kind=realtype) :: max2
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
      porflux = half*rfil
      if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
      gm1 = gammaface - one
      gm53 = gammaface - five*third
! determine which riemann solver must be solved.
      select case  (riemannused) 
      case (roe) 
! determine the preconditioner used.
        select case  (precond) 
        case (noprecond) 
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
          if (left(irho) .eq. 0.0_8) then
            z1ld = 0.0_8
          else
            z1ld = leftd(irho)/(2.0*sqrt(left(irho)))
          end if
          z1l = sqrt(left(irho))
          if (right(irho) .eq. 0.0_8) then
            z1rd = 0.0_8
          else
            z1rd = rightd(irho)/(2.0*sqrt(right(irho)))
          end if
          z1r = sqrt(right(irho))
          tmpd = -(one*(z1ld+z1rd)/(z1l+z1r)**2)
          tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
          if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
            ktmpd = 0.0_8
            ktmpd(1) = leftd(itu1)
            ktmp(1) = left(itu1)
            ktmpd(2) = rightd(itu1)
            ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
            drkd = rightd(irho)*right(itu1) + right(irho)*rightd(itu1) -&
&             leftd(irho)*left(itu1) - left(irho)*leftd(itu1)
            drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
            kavgd = tmpd*(z1l*left(itu1)+z1r*right(itu1)) + tmp*(z1ld*&
&             left(itu1)+z1l*leftd(itu1)+z1rd*right(itu1)+z1r*rightd(&
&             itu1))
            kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
          else
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
            drk = 0.0
            kavg = 0.0
            ktmpd = 0.0_8
            kavgd = 0.0_8
            drkd = 0.0_8
          end if
! compute the total energy of the left and right state.
          etld = 0.0_8
          call etot_d(left(irho), leftd(irho), left(ivx), leftd(ivx), &
&               left(ivy), leftd(ivy), left(ivz), leftd(ivz), left(irhoe&
&               ), leftd(irhoe), ktmp(1), ktmpd(1), etl, etld, &
&               correctfork)
          etrd = 0.0_8
          call etot_d(right(irho), rightd(irho), right(ivx), rightd(ivx)&
&               , right(ivy), rightd(ivy), right(ivz), rightd(ivz), &
&               right(irhoe), rightd(irhoe), ktmp(2), ktmpd(2), etr, &
&               etrd, correctfork)
! compute the difference of the conservative mean
! flow variables.
          drd = rightd(irho) - leftd(irho)
          dr = right(irho) - left(irho)
          drud = rightd(irho)*right(ivx) + right(irho)*rightd(ivx) - &
&           leftd(irho)*left(ivx) - left(irho)*leftd(ivx)
          dru = right(irho)*right(ivx) - left(irho)*left(ivx)
          drvd = rightd(irho)*right(ivy) + right(irho)*rightd(ivy) - &
&           leftd(irho)*left(ivy) - left(irho)*leftd(ivy)
          drv = right(irho)*right(ivy) - left(irho)*left(ivy)
          drwd = rightd(irho)*right(ivz) + right(irho)*rightd(ivz) - &
&           leftd(irho)*left(ivz) - left(irho)*leftd(ivz)
          drw = right(irho)*right(ivz) - left(irho)*left(ivz)
          dred = etrd - etld
          dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
          ravg = fourth*(z1r+z1l)**2
          uavgd = tmpd*(z1l*left(ivx)+z1r*right(ivx)) + tmp*(z1ld*left(&
&           ivx)+z1l*leftd(ivx)+z1rd*right(ivx)+z1r*rightd(ivx))
          uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
          vavgd = tmpd*(z1l*left(ivy)+z1r*right(ivy)) + tmp*(z1ld*left(&
&           ivy)+z1l*leftd(ivy)+z1rd*right(ivy)+z1r*rightd(ivy))
          vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
          wavgd = tmpd*(z1l*left(ivz)+z1r*right(ivz)) + tmp*(z1ld*left(&
&           ivz)+z1l*leftd(ivz)+z1rd*right(ivz)+z1r*rightd(ivz))
          wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
          havgd = tmpd*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r) + &
&           tmp*(((etld+leftd(irhoe))*z1l-(etl+left(irhoe))*z1ld)/z1l**2&
&           +((etrd+rightd(irhoe))*z1r-(etr+right(irhoe))*z1rd)/z1r**2)
          havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
          arg1d = 2*sx*sxd + 2*sy*syd + 2*sz*szd
          arg1 = sx**2 + sy**2 + sz**2
          if (arg1 .eq. 0.0_8) then
            aread = 0.0_8
          else
            aread = arg1d/(2.0*sqrt(arg1))
          end if
          area = sqrt(arg1)
          if (1.e-25_realtype .lt. area) then
            max2d = aread
            max2 = area
          else
            max2 = 1.e-25_realtype
            max2d = 0.0_8
          end if
          tmpd = -(one*max2d/max2**2)
          tmp = one/max2
          sxd = sxd*tmp + sx*tmpd
          sx = sx*tmp
          syd = syd*tmp + sy*tmpd
          sy = sy*tmp
          szd = szd*tmp + sz*tmpd
          sz = sz*tmp
          rfaced = sface*tmpd
          rface = sface*tmp
! compute some dependent variables at the roe
! average state.
          alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
            a2avgd = gm1*(havgd-alphaavgd) - gm53*kavgd
            a2avg = gm1*(havg-alphaavg) - gm53*kavg
          else
            a2avgd = -(gm1*(havgd-alphaavgd)-gm53*kavgd)
            a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
          end if
          if (a2avg .eq. 0.0_8) then
            aavgd = 0.0_8
          else
            aavgd = a2avgd/(2.0*sqrt(a2avg))
          end if
          aavg = sqrt(a2avg)
          unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*sz &
&           + wavg*szd
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavgd = -(one*aavgd/aavg**2)
          ovaavg = one/aavg
          ova2avgd = -(one*a2avgd/a2avg**2)
          ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
          if (por .eq. boundflux) then
            unavgd = rfaced
            unavg = rface
          end if
          x1d = (leftd(ivx)-rightd(ivx))*sx + (left(ivx)-right(ivx))*sxd&
&           + (leftd(ivy)-rightd(ivy))*sy + (left(ivy)-right(ivy))*syd +&
&           (leftd(ivz)-rightd(ivz))*sz + (left(ivz)-right(ivz))*szd
          x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&           left(ivz)-right(ivz))*sz
          if (x1 .ge. 0.) then
            abs1d = x1d
            abs1 = x1
          else
            abs1d = -x1d
            abs1 = -x1
          end if
          arg1d = (gammaface*leftd(irhoe)*left(irho)-gammaface*left(&
&           irhoe)*leftd(irho))/left(irho)**2
          arg1 = gammaface*left(irhoe)/left(irho)
          if (arg1 .eq. 0.0_8) then
            result1d = 0.0_8
          else
            result1d = arg1d/(2.0*sqrt(arg1))
          end if
          result1 = sqrt(arg1)
          arg2d = (gammaface*rightd(irhoe)*right(irho)-gammaface*right(&
&           irhoe)*rightd(irho))/right(irho)**2
          arg2 = gammaface*right(irhoe)/right(irho)
          if (arg2 .eq. 0.0_8) then
            result2d = 0.0_8
          else
            result2d = arg2d/(2.0*sqrt(arg2))
          end if
          result2 = sqrt(arg2)
          x2d = result1d - result2d
          x2 = result1 - result2
          if (x2 .ge. 0.) then
            abs2d = x2d
            abs2 = x2
          else
            abs2d = -x2d
            abs2 = -x2
          end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
          etad = half*(abs1d+abs2d)
          eta = half*(abs1+abs2)
          if (unavg - rface + aavg .ge. 0.) then
            lam1d = unavgd - rfaced + aavgd
            lam1 = unavg - rface + aavg
          else
            lam1d = -(unavgd-rfaced+aavgd)
            lam1 = -(unavg-rface+aavg)
          end if
          if (unavg - rface - aavg .ge. 0.) then
            lam2d = unavgd - rfaced - aavgd
            lam2 = unavg - rface - aavg
          else
            lam2d = -(unavgd-rfaced-aavgd)
            lam2 = -(unavg-rface-aavg)
          end if
          if (unavg - rface .ge. 0.) then
            lam3d = unavgd - rfaced
            lam3 = unavg - rface
          else
            lam3d = -(unavgd-rfaced)
            lam3 = -(unavg-rface)
          end if
! apply the entropy correction to the eigenvalues.
          tmp = two*eta
          if (lam1 .lt. tmp) then
            lam1d = etad + (fourth*(lam1d*lam1+lam1*lam1d)*eta-fourth*&
&             lam1**2*etad)/eta**2
            lam1 = eta + fourth*lam1*lam1/eta
          end if
          if (lam2 .lt. tmp) then
            lam2d = etad + (fourth*(lam2d*lam2+lam2*lam2d)*eta-fourth*&
&             lam2**2*etad)/eta**2
            lam2 = eta + fourth*lam2*lam2/eta
          end if
          if (lam3 .lt. tmp) then
            lam3d = etad + (fourth*(lam3d*lam3+lam3*lam3d)*eta-fourth*&
&             lam3**2*etad)/eta**2
            lam3 = eta + fourth*lam3*lam3/eta
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1d = lam1d*area + lam1*aread
          lam1 = lam1*area
          lam2d = lam2d*area + lam2*aread
          lam2 = lam2*area
          lam3d = lam3d*area + lam3*aread
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1d = half*(lam1d+lam2d)
          abv1 = half*(lam1+lam2)
          abv2d = half*(lam1d-lam2d)
          abv2 = half*(lam1-lam2)
          abv3d = abv1d - lam3d
          abv3 = abv1 - lam3
          abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&           vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz*&
&           drwd - unavgd*dr - unavg*drd
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd +&
&           (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd + &
&           abv3d*abv5 + abv3*abv5d
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
          fluxd(irho) = -(porflux*(lam3d*dr+lam3*drd+abv6d))
          flux(irho) = -(porflux*(lam3*dr+abv6))
          fluxd(imx) = -(porflux*(lam3d*dru+lam3*drud+uavgd*abv6+uavg*&
&           abv6d+sxd*abv7+sx*abv7d))
          flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
          fluxd(imy) = -(porflux*(lam3d*drv+lam3*drvd+vavgd*abv6+vavg*&
&           abv6d+syd*abv7+sy*abv7d))
          flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
          fluxd(imz) = -(porflux*(lam3d*drw+lam3*drwd+wavgd*abv6+wavg*&
&           abv6d+szd*abv7+sz*abv7d))
          flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
          fluxd(irhoe) = -(porflux*(lam3d*dre+lam3*dred+havgd*abv6+havg*&
&           abv6d+unavgd*abv7+unavg*abv7d))
          flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
        case (turkel) 
!          tmp = max(lam1,lam2,lam3)
!          flux(irho)  = -porflux*(tmp*dr)
!          flux(imx)   = -porflux*(tmp*dru)
!          flux(imy)   = -porflux*(tmp*drv)
!          flux(imz)   = -porflux*(tmp*drw)
!          flux(irhoe) = -porflux*(tmp*dre)
          call terminate('riemannflux', &
&                  'turkel preconditioner not implemented yet')
        case (choimerkle) 
          call terminate('riemannflux', &
&                  'choi merkle preconditioner not implemented yet')
        end select
      case (vanleer) 
        call terminate('riemannflux', 'van leer fvs not implemented yet'&
&               )
      case (ausmdv) 
        call terminate('riemannflux', 'ausmdv fvs not implemented yet')
      end select
    end subroutine riemannflux_d
!        ================================================================
    subroutine riemannflux(left, right, flux)
      implicit none
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(*), intent(in) :: left, right
      real(kind=realtype), dimension(*), intent(out) :: flux
!
!        local variables.
!
      real(kind=realtype) :: porflux, rface
      real(kind=realtype) :: etl, etr, z1l, z1r, tmp
      real(kind=realtype) :: dr, dru, drv, drw, dre, drk
      real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
      real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
      real(kind=realtype) :: ovaavg, ova2avg, area, eta
      real(kind=realtype) :: gm1, gm53
      real(kind=realtype) :: lam1, lam2, lam3
      real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
      real(kind=realtype), dimension(2) :: ktmp
      intrinsic sqrt
      intrinsic max
      intrinsic abs
      real(kind=realtype) :: arg1
      real(kind=realtype) :: result1
      real(kind=realtype) :: arg2
      real(kind=realtype) :: result2
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: abs2
      real(kind=realtype) :: abs1
      real(kind=realtype) :: max2
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
      porflux = half*rfil
      if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
      gm1 = gammaface - one
      gm53 = gammaface - five*third
! determine which riemann solver must be solved.
      select case  (riemannused) 
      case (roe) 
! determine the preconditioner used.
        select case  (precond) 
        case (noprecond) 
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
          z1l = sqrt(left(irho))
          z1r = sqrt(right(irho))
          tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
          if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
            ktmp(1) = left(itu1)
            ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
            drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
            kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
          else
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
            drk = 0.0
            kavg = 0.0
          end if
! compute the total energy of the left and right state.
          call etot(left(irho), left(ivx), left(ivy), left(ivz), left(&
&             irhoe), ktmp(1), etl, correctfork)
          call etot(right(irho), right(ivx), right(ivy), right(ivz), &
&             right(irhoe), ktmp(2), etr, correctfork)
! compute the difference of the conservative mean
! flow variables.
          dr = right(irho) - left(irho)
          dru = right(irho)*right(ivx) - left(irho)*left(ivx)
          drv = right(irho)*right(ivy) - left(irho)*left(ivy)
          drw = right(irho)*right(ivz) - left(irho)*left(ivz)
          dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
          ravg = fourth*(z1r+z1l)**2
          uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
          vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
          wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
          havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
          arg1 = sx**2 + sy**2 + sz**2
          area = sqrt(arg1)
          if (1.e-25_realtype .lt. area) then
            max2 = area
          else
            max2 = 1.e-25_realtype
          end if
          tmp = one/max2
          sx = sx*tmp
          sy = sy*tmp
          sz = sz*tmp
          rface = sface*tmp
! compute some dependent variables at the roe
! average state.
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
            a2avg = gm1*(havg-alphaavg) - gm53*kavg
          else
            a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
          end if
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
          if (por .eq. boundflux) unavg = rface
          x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&           left(ivz)-right(ivz))*sz
          if (x1 .ge. 0.) then
            abs1 = x1
          else
            abs1 = -x1
          end if
          arg1 = gammaface*left(irhoe)/left(irho)
          result1 = sqrt(arg1)
          arg2 = gammaface*right(irhoe)/right(irho)
          result2 = sqrt(arg2)
          x2 = result1 - result2
          if (x2 .ge. 0.) then
            abs2 = x2
          else
            abs2 = -x2
          end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
          eta = half*(abs1+abs2)
          if (unavg - rface + aavg .ge. 0.) then
            lam1 = unavg - rface + aavg
          else
            lam1 = -(unavg-rface+aavg)
          end if
          if (unavg - rface - aavg .ge. 0.) then
            lam2 = unavg - rface - aavg
          else
            lam2 = -(unavg-rface-aavg)
          end if
          if (unavg - rface .ge. 0.) then
            lam3 = unavg - rface
          else
            lam3 = -(unavg-rface)
          end if
! apply the entropy correction to the eigenvalues.
          tmp = two*eta
          if (lam1 .lt. tmp) lam1 = eta + fourth*lam1*lam1/eta
          if (lam2 .lt. tmp) lam2 = eta + fourth*lam2*lam2/eta
          if (lam3 .lt. tmp) lam3 = eta + fourth*lam3*lam3/eta
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1 = lam1*area
          lam2 = lam2*area
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
          flux(irho) = -(porflux*(lam3*dr+abv6))
          flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
          flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
          flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
          flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
        case (turkel) 
!          tmp = max(lam1,lam2,lam3)
!          flux(irho)  = -porflux*(tmp*dr)
!          flux(imx)   = -porflux*(tmp*dru)
!          flux(imy)   = -porflux*(tmp*drv)
!          flux(imz)   = -porflux*(tmp*drw)
!          flux(irhoe) = -porflux*(tmp*dre)
          call terminate('riemannflux', &
&                  'turkel preconditioner not implemented yet')
        case (choimerkle) 
          call terminate('riemannflux', &
&                  'choi merkle preconditioner not implemented yet')
        end select
      case (vanleer) 
        call terminate('riemannflux', 'van leer fvs not implemented yet'&
&               )
      case (ausmdv) 
        call terminate('riemannflux', 'ausmdv fvs not implemented yet')
      end select
    end subroutine riemannflux
  end subroutine inviscidupwindflux_d
!  differentiation of viscousflux in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw *(*viscsubface.tau)
!   with respect to varying inputs: *rev *aa *wx *wy *wz *w *rlv
!                *x *qx *qy *qz *ux *uy *uz *si *sj *sk *vx *vy
!                *vz *fw
!   rw status of diff variables: *rev:in *aa:in *wx:in *wy:in *wz:in
!                *w:in *rlv:in *x:in *qx:in *qy:in *qz:in *ux:in
!                *uy:in *uz:in *si:in *sj:in *sk:in *vx:in *vy:in
!                *vz:in *fw:in-out *(*viscsubface.tau):out
!   plus diff mem management of: rev:in aa:in wx:in wy:in wz:in
!                w:in rlv:in x:in qx:in qy:in qz:in ux:in uy:in
!                uz:in si:in sj:in sk:in vx:in vy:in vz:in fw:in
!                viscsubface:in *viscsubface.tau:in
  subroutine viscousflux_d()
!
!       viscousflux computes the viscous fluxes using a central        
!       difference scheme for a block.                                 
!       it is assumed that the pointers in block pointer already point 
!       to the correct block.                                          
!
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    use diffsizes
!  hint: isize1ofdrfviscsubface should be the size of dimension 1 of array *viscsubface
    implicit none
! possibly correct the wall shear stress.
! wall function is not aded
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype), parameter :: xminn=1.e-14_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: muld, mued, mutd, heatcoefd
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, &
&   w_yd, w_zd
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: corrd, ssxd, ssyd, sszd, ssd, fracdivd
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxxd, tauyyd, tauzzd
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxyd, tauxzd, tauyzd
    real(kind=realtype) :: exx, eyy, ezz
    real(kind=realtype) :: exxd, eyyd, ezzd
    real(kind=realtype) :: exy, exz, eyz
    real(kind=realtype) :: exyd, exzd, eyzd
    real(kind=realtype) :: wxx, wyy, wzz
    real(kind=realtype) :: wxy, wxz, wyz, wyx, wzx, wzy
    real(kind=realtype) :: wxyd, wxzd, wyzd, wyxd, wzxd, wzyd
    real(kind=realtype) :: den, ccr1, fact
    real(kind=realtype) :: dend, factd
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    real(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
    logical :: correctfork, storewalltensor
    intrinsic abs
    intrinsic sqrt
    intrinsic max
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: abs0
    integer :: ii1
! set qcr parameters
    ccr1 = 0.3_realtype
! the diagonals of the vorticity tensor components are always zero
    wxx = zero
    wyy = zero
    wzz = zero
! set rfilv to rfil to indicate that this is the viscous part.
! if rfilv == 0 the viscous residuals need not to be computed
! and a return can be made.
    rfilv = rfil
    if (rfilv .ge. 0.) then
      abs0 = rfilv
    else
      abs0 = -rfilv
    end if
    if (abs0 .lt. thresholdreal) then
      do ii1=1,isize1ofdrfviscsubface
        viscsubfaced(ii1)%tau = 0.0_8
      end do
      return
    else
! determine whether or not the wall stress tensor and wall heat
! flux must be stored for viscous walls.
      storewalltensor = .false.
      if (wallfunctions) then
        storewalltensor = .true.
      else if (rkstage .eq. 0 .and. currentlevel .eq. groundlevel) then
        storewalltensor = .true.
      end if
!
!         viscous fluxes in the k-direction.                           
!
      mue = zero
      do ii1=1,isize1ofdrfviscsubface
        viscsubfaced(ii1)%tau = 0.0_8
      end do
      mued = 0.0_8
      do k=1,kl
        do j=2,jl
          do i=2,il
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
            por = half*rfilv
            if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
            muld = por*(rlvd(i, j, k)+rlvd(i, j, k+1))
            mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
            if (eddymodel) then
              mued = por*(revd(i, j, k)+revd(i, j, k+1))
              mue = por*(rev(i, j, k)+rev(i, j, k+1))
            end if
            mutd = muld + mued
            mut = mul + mue
            gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
            factlamheat = one/(prandtl*gm1)
            factturbheat = one/(prandtlturb*gm1)
            heatcoefd = factlamheat*muld + factturbheat*mued
            heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
            u_xd = fourth*(uxd(i-1, j-1, k)+uxd(i, j-1, k)+uxd(i-1, j, k&
&             )+uxd(i, j, k))
            u_x = fourth*(ux(i-1, j-1, k)+ux(i, j-1, k)+ux(i-1, j, k)+ux&
&             (i, j, k))
            u_yd = fourth*(uyd(i-1, j-1, k)+uyd(i, j-1, k)+uyd(i-1, j, k&
&             )+uyd(i, j, k))
            u_y = fourth*(uy(i-1, j-1, k)+uy(i, j-1, k)+uy(i-1, j, k)+uy&
&             (i, j, k))
            u_zd = fourth*(uzd(i-1, j-1, k)+uzd(i, j-1, k)+uzd(i-1, j, k&
&             )+uzd(i, j, k))
            u_z = fourth*(uz(i-1, j-1, k)+uz(i, j-1, k)+uz(i-1, j, k)+uz&
&             (i, j, k))
            v_xd = fourth*(vxd(i-1, j-1, k)+vxd(i, j-1, k)+vxd(i-1, j, k&
&             )+vxd(i, j, k))
            v_x = fourth*(vx(i-1, j-1, k)+vx(i, j-1, k)+vx(i-1, j, k)+vx&
&             (i, j, k))
            v_yd = fourth*(vyd(i-1, j-1, k)+vyd(i, j-1, k)+vyd(i-1, j, k&
&             )+vyd(i, j, k))
            v_y = fourth*(vy(i-1, j-1, k)+vy(i, j-1, k)+vy(i-1, j, k)+vy&
&             (i, j, k))
            v_zd = fourth*(vzd(i-1, j-1, k)+vzd(i, j-1, k)+vzd(i-1, j, k&
&             )+vzd(i, j, k))
            v_z = fourth*(vz(i-1, j-1, k)+vz(i, j-1, k)+vz(i-1, j, k)+vz&
&             (i, j, k))
            w_xd = fourth*(wxd(i-1, j-1, k)+wxd(i, j-1, k)+wxd(i-1, j, k&
&             )+wxd(i, j, k))
            w_x = fourth*(wx(i-1, j-1, k)+wx(i, j-1, k)+wx(i-1, j, k)+wx&
&             (i, j, k))
            w_yd = fourth*(wyd(i-1, j-1, k)+wyd(i, j-1, k)+wyd(i-1, j, k&
&             )+wyd(i, j, k))
            w_y = fourth*(wy(i-1, j-1, k)+wy(i, j-1, k)+wy(i-1, j, k)+wy&
&             (i, j, k))
            w_zd = fourth*(wzd(i-1, j-1, k)+wzd(i, j-1, k)+wzd(i-1, j, k&
&             )+wzd(i, j, k))
            w_z = fourth*(wz(i-1, j-1, k)+wz(i, j-1, k)+wz(i-1, j, k)+wz&
&             (i, j, k))
            q_xd = fourth*(qxd(i-1, j-1, k)+qxd(i, j-1, k)+qxd(i-1, j, k&
&             )+qxd(i, j, k))
            q_x = fourth*(qx(i-1, j-1, k)+qx(i, j-1, k)+qx(i-1, j, k)+qx&
&             (i, j, k))
            q_yd = fourth*(qyd(i-1, j-1, k)+qyd(i, j-1, k)+qyd(i-1, j, k&
&             )+qyd(i, j, k))
            q_y = fourth*(qy(i-1, j-1, k)+qy(i, j-1, k)+qy(i-1, j, k)+qy&
&             (i, j, k))
            q_zd = fourth*(qzd(i-1, j-1, k)+qzd(i, j-1, k)+qzd(i-1, j, k&
&             )+qzd(i, j, k))
            q_z = fourth*(qz(i-1, j-1, k)+qz(i, j-1, k)+qz(i-1, j, k)+qz&
&             (i, j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center k to cell center k+1.
            ssxd = eighth*(xd(i-1, j-1, k+1, 1)-xd(i-1, j-1, k-1, 1)+xd(&
&             i-1, j, k+1, 1)-xd(i-1, j, k-1, 1)+xd(i, j-1, k+1, 1)-xd(i&
&             , j-1, k-1, 1)+xd(i, j, k+1, 1)-xd(i, j, k-1, 1))
            ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1&
&             , j, k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1&
&             , k-1, 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
            ssyd = eighth*(xd(i-1, j-1, k+1, 2)-xd(i-1, j-1, k-1, 2)+xd(&
&             i-1, j, k+1, 2)-xd(i-1, j, k-1, 2)+xd(i, j-1, k+1, 2)-xd(i&
&             , j-1, k-1, 2)+xd(i, j, k+1, 2)-xd(i, j, k-1, 2))
            ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1&
&             , j, k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1&
&             , k-1, 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
            sszd = eighth*(xd(i-1, j-1, k+1, 3)-xd(i-1, j-1, k-1, 3)+xd(&
&             i-1, j, k+1, 3)-xd(i-1, j, k-1, 3)+xd(i, j-1, k+1, 3)-xd(i&
&             , j-1, k-1, 3)+xd(i, j, k+1, 3)-xd(i, j, k-1, 3))
            ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1&
&             , j, k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1&
&             , k-1, 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
! determine the length of this vector and create the
! unit normal.
            arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz&
&             + ssz*sszd
            arg1 = ssx*ssx + ssy*ssy + ssz*ssz
            if (arg1 .eq. 0.0_8) then
              result1d = 0.0_8
            else
              result1d = arg1d/(2.0*sqrt(arg1))
            end if
            result1 = sqrt(arg1)
            ssd = -(one*result1d/result1**2)
            ss = one/result1
            ssxd = ssd*ssx + ss*ssxd
            ssx = ss*ssx
            ssyd = ssd*ssy + ss*ssyd
            ssy = ss*ssy
            sszd = ssd*ssz + ss*sszd
            ssz = ss*ssz
! correct the gradients.
            corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz&
&             + u_z*sszd - (wd(i, j, k+1, ivx)-wd(i, j, k, ivx))*ss - (w&
&             (i, j, k+1, ivx)-w(i, j, k, ivx))*ssd
            corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i&
&             , j, k, ivx))*ss
            u_xd = u_xd - corrd*ssx - corr*ssxd
            u_x = u_x - corr*ssx
            u_yd = u_yd - corrd*ssy - corr*ssyd
            u_y = u_y - corr*ssy
            u_zd = u_zd - corrd*ssz - corr*sszd
            u_z = u_z - corr*ssz
            corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz&
&             + v_z*sszd - (wd(i, j, k+1, ivy)-wd(i, j, k, ivy))*ss - (w&
&             (i, j, k+1, ivy)-w(i, j, k, ivy))*ssd
            corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i&
&             , j, k, ivy))*ss
            v_xd = v_xd - corrd*ssx - corr*ssxd
            v_x = v_x - corr*ssx
            v_yd = v_yd - corrd*ssy - corr*ssyd
            v_y = v_y - corr*ssy
            v_zd = v_zd - corrd*ssz - corr*sszd
            v_z = v_z - corr*ssz
            corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz&
&             + w_z*sszd - (wd(i, j, k+1, ivz)-wd(i, j, k, ivz))*ss - (w&
&             (i, j, k+1, ivz)-w(i, j, k, ivz))*ssd
            corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i&
&             , j, k, ivz))*ss
            w_xd = w_xd - corrd*ssx - corr*ssxd
            w_x = w_x - corr*ssx
            w_yd = w_yd - corrd*ssy - corr*ssyd
            w_y = w_y - corr*ssy
            w_zd = w_zd - corrd*ssz - corr*sszd
            w_z = w_z - corr*ssz
            corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz&
&             + q_z*sszd + (aad(i, j, k+1)-aad(i, j, k))*ss + (aa(i, j, &
&             k+1)-aa(i, j, k))*ssd
            corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j, k+1)-aa(i, j&
&             , k))*ss
            q_xd = q_xd - corrd*ssx - corr*ssxd
            q_x = q_x - corr*ssx
            q_yd = q_yd - corrd*ssy - corr*ssyd
            q_y = q_y - corr*ssy
            q_zd = q_zd - corrd*ssz - corr*sszd
            q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
            fracdivd = twothird*(u_xd+v_yd+w_zd)
            fracdiv = twothird*(u_x+v_y+w_z)
            tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
            tauxx = mut*(two*u_x-fracdiv)
            tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
            tauyy = mut*(two*v_y-fracdiv)
            tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
            tauzz = mut*(two*w_z-fracdiv)
            tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
            tauxy = mut*(u_y+v_x)
            tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
            tauxz = mut*(u_z+w_x)
            tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
            tauyz = mut*(v_z+w_y)
            q_xd = heatcoefd*q_x + heatcoef*q_xd
            q_x = heatcoef*q_x
            q_yd = heatcoefd*q_y + heatcoef*q_yd
            q_y = heatcoef*q_y
            q_zd = heatcoefd*q_z + heatcoef*q_zd
            q_z = heatcoef*q_z
! add qcr corrections if necessary
            if (useqcr) then
! in the qcr formulation, we add an extra term to the shear tensor:
!
! tau_ij,qcr = tau_ij - e_ij
! 
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
! compute denominator
              arg1d = u_xd*u_x + u_x*u_xd + u_yd*u_y + u_y*u_yd + u_zd*&
&               u_z + u_z*u_zd + v_xd*v_x + v_x*v_xd + v_yd*v_y + v_y*&
&               v_yd + v_zd*v_z + v_z*v_zd + w_xd*w_x + w_x*w_xd + w_yd*&
&               w_y + w_y*w_yd + w_zd*w_z + w_z*w_zd
              arg1 = u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&               v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z
              if (arg1 .eq. 0.0_8) then
                dend = 0.0_8
              else
                dend = arg1d/(2.0*sqrt(arg1))
              end if
              den = sqrt(arg1)
              if (den .lt. xminn) then
                den = xminn
                dend = 0.0_8
              else
                den = den
              end if
! compute factor that will multiply all tensor components
              factd = -(ccr1*dend/den**2)
              fact = ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
              wxyd = u_yd - v_xd
              wxy = u_y - v_x
              wxzd = u_zd - w_xd
              wxz = u_z - w_x
              wyzd = v_zd - w_yd
              wyz = v_z - w_y
              wyxd = -wxyd
              wyx = -wxy
              wzxd = -wxzd
              wzx = -wxz
              wzyd = -wyzd
              wzy = -wyz
! compute the extra terms of the boussinesq relation
              exxd = two*(factd*(wxx*tauxx+wxy*tauxy+wxz*tauxz)+fact*(&
&               wxx*tauxxd+wxyd*tauxy+wxy*tauxyd+wxzd*tauxz+wxz*tauxzd))
              exx = fact*(wxx*tauxx+wxy*tauxy+wxz*tauxz)*two
              eyyd = two*(factd*(wyx*tauxy+wyy*tauyy+wyz*tauyz)+fact*(&
&               wyxd*tauxy+wyx*tauxyd+wyy*tauyyd+wyzd*tauyz+wyz*tauyzd))
              eyy = fact*(wyx*tauxy+wyy*tauyy+wyz*tauyz)*two
              ezzd = two*(factd*(wzx*tauxz+wzy*tauyz+wzz*tauzz)+fact*(&
&               wzxd*tauxz+wzx*tauxzd+wzyd*tauyz+wzy*tauyzd+wzz*tauzzd))
              ezz = fact*(wzx*tauxz+wzy*tauyz+wzz*tauzz)*two
              exyd = factd*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz) + fact*(wxx*tauxyd+wxyd*tauyy+wxy*&
&               tauyyd+wxzd*tauyz+wxz*tauyzd+wyxd*tauxx+wyx*tauxxd+wyy*&
&               tauxyd+wyzd*tauxz+wyz*tauxzd)
              exy = fact*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz)
              exzd = factd*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz) + fact*(wxx*tauxzd+wxyd*tauyz+wxy*&
&               tauyzd+wxzd*tauzz+wxz*tauzzd+wzxd*tauxx+wzx*tauxxd+wzyd*&
&               tauxy+wzy*tauxyd+wzz*tauxzd)
              exz = fact*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz)
              eyzd = factd*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz) + fact*(wyxd*tauxz+wyx*tauxzd+wyy*&
&               tauyzd+wyzd*tauzz+wyz*tauzzd+wzxd*tauxy+wzx*tauxyd+wzyd*&
&               tauyy+wzy*tauyyd+wzz*tauyzd)
              eyz = fact*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz)
! add extra terms
              tauxxd = tauxxd - exxd
              tauxx = tauxx - exx
              tauyyd = tauyyd - eyyd
              tauyy = tauyy - eyy
              tauzzd = tauzzd - ezzd
              tauzz = tauzz - ezz
              tauxyd = tauxyd - exyd
              tauxy = tauxy - exy
              tauxzd = tauxzd - exzd
              tauxz = tauxz - exz
              tauyzd = tauyzd - eyzd
              tauyz = tauyz - eyz
            end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
            ubard = half*(wd(i, j, k, ivx)+wd(i, j, k+1, ivx))
            ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
            vbard = half*(wd(i, j, k, ivy)+wd(i, j, k+1, ivy))
            vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
            wbard = half*(wd(i, j, k, ivz)+wd(i, j, k+1, ivz))
            wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this k-face.
            fmxd = tauxxd*sk(i, j, k, 1) + tauxx*skd(i, j, k, 1) + &
&             tauxyd*sk(i, j, k, 2) + tauxy*skd(i, j, k, 2) + tauxzd*sk(&
&             i, j, k, 3) + tauxz*skd(i, j, k, 3)
            fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk&
&             (i, j, k, 3)
            fmyd = tauxyd*sk(i, j, k, 1) + tauxy*skd(i, j, k, 1) + &
&             tauyyd*sk(i, j, k, 2) + tauyy*skd(i, j, k, 2) + tauyzd*sk(&
&             i, j, k, 3) + tauyz*skd(i, j, k, 3)
            fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk&
&             (i, j, k, 3)
            fmzd = tauxzd*sk(i, j, k, 1) + tauxz*skd(i, j, k, 1) + &
&             tauyzd*sk(i, j, k, 2) + tauyz*skd(i, j, k, 2) + tauzzd*sk(&
&             i, j, k, 3) + tauzz*skd(i, j, k, 3)
            fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk&
&             (i, j, k, 3)
            frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
&             wbard*tauxz+wbar*tauxzd)*sk(i, j, k, 1) + (ubar*tauxx+vbar&
&             *tauxy+wbar*tauxz)*skd(i, j, k, 1)
            frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1)
            frhoed = frhoed + (ubard*tauxy+ubar*tauxyd+vbard*tauyy+vbar*&
&             tauyyd+wbard*tauyz+wbar*tauyzd)*sk(i, j, k, 2) + (ubar*&
&             tauxy+vbar*tauyy+wbar*tauyz)*skd(i, j, k, 2)
            frhoe = frhoe + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, &
&             k, 2)
            frhoed = frhoed + (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*&
&             tauyzd+wbard*tauzz+wbar*tauzzd)*sk(i, j, k, 3) + (ubar*&
&             tauxz+vbar*tauyz+wbar*tauzz)*skd(i, j, k, 3)
            frhoe = frhoe + (ubar*tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, &
&             k, 3)
            frhoed = frhoed - q_xd*sk(i, j, k, 1) - q_x*skd(i, j, k, 1) &
&             - q_yd*sk(i, j, k, 2) - q_y*skd(i, j, k, 2) - q_zd*sk(i, j&
&             , k, 3) - q_z*skd(i, j, k, 3)
            frhoe = frhoe - q_x*sk(i, j, k, 1) - q_y*sk(i, j, k, 2) - &
&             q_z*sk(i, j, k, 3)
! update the residuals of cell k and k+1.
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
            fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fmxd
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
            fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fmyd
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
            fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fmzd
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
            fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + frhoed
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases k == 1
! and k == kl must be tested.
            if (k .eq. 1 .and. storewalltensor .and. visckminpointer(i, &
&               j) .gt. 0) then
! we need to index viscsubface with visckminpointer(i,j) 
! since tapenade does not like temporary indexes 
              viscsubfaced(visckminpointer(i, j))%tau(i, j, 1) = tauxxd
              viscsubface(visckminpointer(i, j))%tau(i, j, 1) = tauxx
              viscsubfaced(visckminpointer(i, j))%tau(i, j, 2) = tauyyd
              viscsubface(visckminpointer(i, j))%tau(i, j, 2) = tauyy
              viscsubfaced(visckminpointer(i, j))%tau(i, j, 3) = tauzzd
              viscsubface(visckminpointer(i, j))%tau(i, j, 3) = tauzz
              viscsubfaced(visckminpointer(i, j))%tau(i, j, 4) = tauxyd
              viscsubface(visckminpointer(i, j))%tau(i, j, 4) = tauxy
              viscsubfaced(visckminpointer(i, j))%tau(i, j, 5) = tauxzd
              viscsubface(visckminpointer(i, j))%tau(i, j, 5) = tauxz
              viscsubfaced(visckminpointer(i, j))%tau(i, j, 6) = tauyzd
              viscsubface(visckminpointer(i, j))%tau(i, j, 6) = tauyz
              viscsubface(visckminpointer(i, j))%q(i, j, 1) = q_x
              viscsubface(visckminpointer(i, j))%q(i, j, 2) = q_y
              viscsubface(visckminpointer(i, j))%q(i, j, 3) = q_z
            end if
! and the k == kl case.
            if (k .eq. kl .and. storewalltensor .and. visckmaxpointer(i&
&               , j) .gt. 0) then
              viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 1) = tauxxd
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 1) = tauxx
              viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 2) = tauyyd
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 2) = tauyy
              viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 3) = tauzzd
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 3) = tauzz
              viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 4) = tauxyd
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 4) = tauxy
              viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 5) = tauxzd
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 5) = tauxz
              viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 6) = tauyzd
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 6) = tauyz
              viscsubface(visckmaxpointer(i, j))%q(i, j, 1) = q_x
              viscsubface(visckmaxpointer(i, j))%q(i, j, 2) = q_y
              viscsubface(visckmaxpointer(i, j))%q(i, j, 3) = q_z
            end if
          end do
        end do
      end do
!
!         viscous fluxes in the j-direction.                           
!
      mue = zero
      mued = 0.0_8
      do k=2,kl
        do j=1,jl
          do i=2,il
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
            por = half*rfilv
            if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
            muld = por*(rlvd(i, j, k)+rlvd(i, j+1, k))
            mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
            if (eddymodel) then
              mued = por*(revd(i, j, k)+revd(i, j+1, k))
              mue = por*(rev(i, j, k)+rev(i, j+1, k))
            end if
            mutd = muld + mued
            mut = mul + mue
            gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
            factlamheat = one/(prandtl*gm1)
            factturbheat = one/(prandtlturb*gm1)
            heatcoefd = factlamheat*muld + factturbheat*mued
            heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
            u_xd = fourth*(uxd(i-1, j, k-1)+uxd(i, j, k-1)+uxd(i-1, j, k&
&             )+uxd(i, j, k))
            u_x = fourth*(ux(i-1, j, k-1)+ux(i, j, k-1)+ux(i-1, j, k)+ux&
&             (i, j, k))
            u_yd = fourth*(uyd(i-1, j, k-1)+uyd(i, j, k-1)+uyd(i-1, j, k&
&             )+uyd(i, j, k))
            u_y = fourth*(uy(i-1, j, k-1)+uy(i, j, k-1)+uy(i-1, j, k)+uy&
&             (i, j, k))
            u_zd = fourth*(uzd(i-1, j, k-1)+uzd(i, j, k-1)+uzd(i-1, j, k&
&             )+uzd(i, j, k))
            u_z = fourth*(uz(i-1, j, k-1)+uz(i, j, k-1)+uz(i-1, j, k)+uz&
&             (i, j, k))
            v_xd = fourth*(vxd(i-1, j, k-1)+vxd(i, j, k-1)+vxd(i-1, j, k&
&             )+vxd(i, j, k))
            v_x = fourth*(vx(i-1, j, k-1)+vx(i, j, k-1)+vx(i-1, j, k)+vx&
&             (i, j, k))
            v_yd = fourth*(vyd(i-1, j, k-1)+vyd(i, j, k-1)+vyd(i-1, j, k&
&             )+vyd(i, j, k))
            v_y = fourth*(vy(i-1, j, k-1)+vy(i, j, k-1)+vy(i-1, j, k)+vy&
&             (i, j, k))
            v_zd = fourth*(vzd(i-1, j, k-1)+vzd(i, j, k-1)+vzd(i-1, j, k&
&             )+vzd(i, j, k))
            v_z = fourth*(vz(i-1, j, k-1)+vz(i, j, k-1)+vz(i-1, j, k)+vz&
&             (i, j, k))
            w_xd = fourth*(wxd(i-1, j, k-1)+wxd(i, j, k-1)+wxd(i-1, j, k&
&             )+wxd(i, j, k))
            w_x = fourth*(wx(i-1, j, k-1)+wx(i, j, k-1)+wx(i-1, j, k)+wx&
&             (i, j, k))
            w_yd = fourth*(wyd(i-1, j, k-1)+wyd(i, j, k-1)+wyd(i-1, j, k&
&             )+wyd(i, j, k))
            w_y = fourth*(wy(i-1, j, k-1)+wy(i, j, k-1)+wy(i-1, j, k)+wy&
&             (i, j, k))
            w_zd = fourth*(wzd(i-1, j, k-1)+wzd(i, j, k-1)+wzd(i-1, j, k&
&             )+wzd(i, j, k))
            w_z = fourth*(wz(i-1, j, k-1)+wz(i, j, k-1)+wz(i-1, j, k)+wz&
&             (i, j, k))
            q_xd = fourth*(qxd(i-1, j, k-1)+qxd(i, j, k-1)+qxd(i-1, j, k&
&             )+qxd(i, j, k))
            q_x = fourth*(qx(i-1, j, k-1)+qx(i, j, k-1)+qx(i-1, j, k)+qx&
&             (i, j, k))
            q_yd = fourth*(qyd(i-1, j, k-1)+qyd(i, j, k-1)+qyd(i-1, j, k&
&             )+qyd(i, j, k))
            q_y = fourth*(qy(i-1, j, k-1)+qy(i, j, k-1)+qy(i-1, j, k)+qy&
&             (i, j, k))
            q_zd = fourth*(qzd(i-1, j, k-1)+qzd(i, j, k-1)+qzd(i-1, j, k&
&             )+qzd(i, j, k))
            q_z = fourth*(qz(i-1, j, k-1)+qz(i, j, k-1)+qz(i-1, j, k)+qz&
&             (i, j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center j to cell center j+1.
            ssxd = eighth*(xd(i-1, j+1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(&
&             i-1, j+1, k, 1)-xd(i-1, j-1, k, 1)+xd(i, j+1, k-1, 1)-xd(i&
&             , j-1, k-1, 1)+xd(i, j+1, k, 1)-xd(i, j-1, k, 1))
            ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1&
&             , j+1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1&
&             , k-1, 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
            ssyd = eighth*(xd(i-1, j+1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(&
&             i-1, j+1, k, 2)-xd(i-1, j-1, k, 2)+xd(i, j+1, k-1, 2)-xd(i&
&             , j-1, k-1, 2)+xd(i, j+1, k, 2)-xd(i, j-1, k, 2))
            ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1&
&             , j+1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1&
&             , k-1, 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
            sszd = eighth*(xd(i-1, j+1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(&
&             i-1, j+1, k, 3)-xd(i-1, j-1, k, 3)+xd(i, j+1, k-1, 3)-xd(i&
&             , j-1, k-1, 3)+xd(i, j+1, k, 3)-xd(i, j-1, k, 3))
            ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1&
&             , j+1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1&
&             , k-1, 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
! determine the length of this vector and create the
! unit normal.
            arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz&
&             + ssz*sszd
            arg1 = ssx*ssx + ssy*ssy + ssz*ssz
            if (arg1 .eq. 0.0_8) then
              result1d = 0.0_8
            else
              result1d = arg1d/(2.0*sqrt(arg1))
            end if
            result1 = sqrt(arg1)
            ssd = -(one*result1d/result1**2)
            ss = one/result1
            ssxd = ssd*ssx + ss*ssxd
            ssx = ss*ssx
            ssyd = ssd*ssy + ss*ssyd
            ssy = ss*ssy
            sszd = ssd*ssz + ss*sszd
            ssz = ss*ssz
! correct the gradients.
            corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz&
&             + u_z*sszd - (wd(i, j+1, k, ivx)-wd(i, j, k, ivx))*ss - (w&
&             (i, j+1, k, ivx)-w(i, j, k, ivx))*ssd
            corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i&
&             , j, k, ivx))*ss
            u_xd = u_xd - corrd*ssx - corr*ssxd
            u_x = u_x - corr*ssx
            u_yd = u_yd - corrd*ssy - corr*ssyd
            u_y = u_y - corr*ssy
            u_zd = u_zd - corrd*ssz - corr*sszd
            u_z = u_z - corr*ssz
            corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz&
&             + v_z*sszd - (wd(i, j+1, k, ivy)-wd(i, j, k, ivy))*ss - (w&
&             (i, j+1, k, ivy)-w(i, j, k, ivy))*ssd
            corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i&
&             , j, k, ivy))*ss
            v_xd = v_xd - corrd*ssx - corr*ssxd
            v_x = v_x - corr*ssx
            v_yd = v_yd - corrd*ssy - corr*ssyd
            v_y = v_y - corr*ssy
            v_zd = v_zd - corrd*ssz - corr*sszd
            v_z = v_z - corr*ssz
            corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz&
&             + w_z*sszd - (wd(i, j+1, k, ivz)-wd(i, j, k, ivz))*ss - (w&
&             (i, j+1, k, ivz)-w(i, j, k, ivz))*ssd
            corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i&
&             , j, k, ivz))*ss
            w_xd = w_xd - corrd*ssx - corr*ssxd
            w_x = w_x - corr*ssx
            w_yd = w_yd - corrd*ssy - corr*ssyd
            w_y = w_y - corr*ssy
            w_zd = w_zd - corrd*ssz - corr*sszd
            w_z = w_z - corr*ssz
            corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz&
&             + q_z*sszd + (aad(i, j+1, k)-aad(i, j, k))*ss + (aa(i, j+1&
&             , k)-aa(i, j, k))*ssd
            corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j+1, k)-aa(i, j&
&             , k))*ss
            q_xd = q_xd - corrd*ssx - corr*ssxd
            q_x = q_x - corr*ssx
            q_yd = q_yd - corrd*ssy - corr*ssyd
            q_y = q_y - corr*ssy
            q_zd = q_zd - corrd*ssz - corr*sszd
            q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
            fracdivd = twothird*(u_xd+v_yd+w_zd)
            fracdiv = twothird*(u_x+v_y+w_z)
            tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
            tauxx = mut*(two*u_x-fracdiv)
            tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
            tauyy = mut*(two*v_y-fracdiv)
            tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
            tauzz = mut*(two*w_z-fracdiv)
            tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
            tauxy = mut*(u_y+v_x)
            tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
            tauxz = mut*(u_z+w_x)
            tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
            tauyz = mut*(v_z+w_y)
            q_xd = heatcoefd*q_x + heatcoef*q_xd
            q_x = heatcoef*q_x
            q_yd = heatcoefd*q_y + heatcoef*q_yd
            q_y = heatcoef*q_y
            q_zd = heatcoefd*q_z + heatcoef*q_zd
            q_z = heatcoef*q_z
! add qcr corrections if necessary
            if (useqcr) then
! in the qcr formulation, we add an extra term to the shear tensor:
!
! tau_ij,qcr = tau_ij - e_ij
! 
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
! compute denominator
              arg1d = u_xd*u_x + u_x*u_xd + u_yd*u_y + u_y*u_yd + u_zd*&
&               u_z + u_z*u_zd + v_xd*v_x + v_x*v_xd + v_yd*v_y + v_y*&
&               v_yd + v_zd*v_z + v_z*v_zd + w_xd*w_x + w_x*w_xd + w_yd*&
&               w_y + w_y*w_yd + w_zd*w_z + w_z*w_zd
              arg1 = u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&               v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z
              if (arg1 .eq. 0.0_8) then
                dend = 0.0_8
              else
                dend = arg1d/(2.0*sqrt(arg1))
              end if
              den = sqrt(arg1)
              if (den .lt. xminn) then
                den = xminn
                dend = 0.0_8
              else
                den = den
              end if
! compute factor that will multiply all tensor components
              factd = -(ccr1*dend/den**2)
              fact = ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
              wxyd = u_yd - v_xd
              wxy = u_y - v_x
              wxzd = u_zd - w_xd
              wxz = u_z - w_x
              wyzd = v_zd - w_yd
              wyz = v_z - w_y
              wyxd = -wxyd
              wyx = -wxy
              wzxd = -wxzd
              wzx = -wxz
              wzyd = -wyzd
              wzy = -wyz
! compute the extra terms of the boussinesq relation
              exxd = two*(factd*(wxx*tauxx+wxy*tauxy+wxz*tauxz)+fact*(&
&               wxx*tauxxd+wxyd*tauxy+wxy*tauxyd+wxzd*tauxz+wxz*tauxzd))
              exx = fact*(wxx*tauxx+wxy*tauxy+wxz*tauxz)*two
              eyyd = two*(factd*(wyx*tauxy+wyy*tauyy+wyz*tauyz)+fact*(&
&               wyxd*tauxy+wyx*tauxyd+wyy*tauyyd+wyzd*tauyz+wyz*tauyzd))
              eyy = fact*(wyx*tauxy+wyy*tauyy+wyz*tauyz)*two
              ezzd = two*(factd*(wzx*tauxz+wzy*tauyz+wzz*tauzz)+fact*(&
&               wzxd*tauxz+wzx*tauxzd+wzyd*tauyz+wzy*tauyzd+wzz*tauzzd))
              ezz = fact*(wzx*tauxz+wzy*tauyz+wzz*tauzz)*two
              exyd = factd*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz) + fact*(wxx*tauxyd+wxyd*tauyy+wxy*&
&               tauyyd+wxzd*tauyz+wxz*tauyzd+wyxd*tauxx+wyx*tauxxd+wyy*&
&               tauxyd+wyzd*tauxz+wyz*tauxzd)
              exy = fact*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz)
              exzd = factd*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz) + fact*(wxx*tauxzd+wxyd*tauyz+wxy*&
&               tauyzd+wxzd*tauzz+wxz*tauzzd+wzxd*tauxx+wzx*tauxxd+wzyd*&
&               tauxy+wzy*tauxyd+wzz*tauxzd)
              exz = fact*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz)
              eyzd = factd*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz) + fact*(wyxd*tauxz+wyx*tauxzd+wyy*&
&               tauyzd+wyzd*tauzz+wyz*tauzzd+wzxd*tauxy+wzx*tauxyd+wzyd*&
&               tauyy+wzy*tauyyd+wzz*tauyzd)
              eyz = fact*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz)
! add extra terms
              tauxxd = tauxxd - exxd
              tauxx = tauxx - exx
              tauyyd = tauyyd - eyyd
              tauyy = tauyy - eyy
              tauzzd = tauzzd - ezzd
              tauzz = tauzz - ezz
              tauxyd = tauxyd - exyd
              tauxy = tauxy - exy
              tauxzd = tauxzd - exzd
              tauxz = tauxz - exz
              tauyzd = tauyzd - eyzd
              tauyz = tauyz - eyz
            end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
            ubard = half*(wd(i, j, k, ivx)+wd(i, j+1, k, ivx))
            ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
            vbard = half*(wd(i, j, k, ivy)+wd(i, j+1, k, ivy))
            vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
            wbard = half*(wd(i, j, k, ivz)+wd(i, j+1, k, ivz))
            wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
            fmxd = tauxxd*sj(i, j, k, 1) + tauxx*sjd(i, j, k, 1) + &
&             tauxyd*sj(i, j, k, 2) + tauxy*sjd(i, j, k, 2) + tauxzd*sj(&
&             i, j, k, 3) + tauxz*sjd(i, j, k, 3)
            fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj&
&             (i, j, k, 3)
            fmyd = tauxyd*sj(i, j, k, 1) + tauxy*sjd(i, j, k, 1) + &
&             tauyyd*sj(i, j, k, 2) + tauyy*sjd(i, j, k, 2) + tauyzd*sj(&
&             i, j, k, 3) + tauyz*sjd(i, j, k, 3)
            fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj&
&             (i, j, k, 3)
            fmzd = tauxzd*sj(i, j, k, 1) + tauxz*sjd(i, j, k, 1) + &
&             tauyzd*sj(i, j, k, 2) + tauyz*sjd(i, j, k, 2) + tauzzd*sj(&
&             i, j, k, 3) + tauzz*sjd(i, j, k, 3)
            fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj&
&             (i, j, k, 3)
            frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
&             wbard*tauxz+wbar*tauxzd)*sj(i, j, k, 1) + (ubar*tauxx+vbar&
&             *tauxy+wbar*tauxz)*sjd(i, j, k, 1) + (ubard*tauxy+ubar*&
&             tauxyd+vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*sj&
&             (i, j, k, 2) + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sjd(i, j&
&             , k, 2) + (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd&
&             +wbard*tauzz+wbar*tauzzd)*sj(i, j, k, 3) + (ubar*tauxz+&
&             vbar*tauyz+wbar*tauzz)*sjd(i, j, k, 3) - q_xd*sj(i, j, k, &
&             1) - q_x*sjd(i, j, k, 1) - q_yd*sj(i, j, k, 2) - q_y*sjd(i&
&             , j, k, 2) - q_zd*sj(i, j, k, 3) - q_z*sjd(i, j, k, 3)
            frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + &
&             (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
&             tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j&
&             , k, 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
! update the residuals of cell j and j+1.
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
            fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fmxd
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
            fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fmyd
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
            fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fmzd
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
            fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + frhoed
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases j == 1
! and j == jl must be tested.
            if (j .eq. 1 .and. storewalltensor .and. viscjminpointer(i, &
&               k) .gt. 0) then
! we need to index viscsubface with viscjminpointer(i,k) 
! since tapenade does not like temporary indexes 
              viscsubfaced(viscjminpointer(i, k))%tau(i, k, 1) = tauxxd
              viscsubface(viscjminpointer(i, k))%tau(i, k, 1) = tauxx
              viscsubfaced(viscjminpointer(i, k))%tau(i, k, 2) = tauyyd
              viscsubface(viscjminpointer(i, k))%tau(i, k, 2) = tauyy
              viscsubfaced(viscjminpointer(i, k))%tau(i, k, 3) = tauzzd
              viscsubface(viscjminpointer(i, k))%tau(i, k, 3) = tauzz
              viscsubfaced(viscjminpointer(i, k))%tau(i, k, 4) = tauxyd
              viscsubface(viscjminpointer(i, k))%tau(i, k, 4) = tauxy
              viscsubfaced(viscjminpointer(i, k))%tau(i, k, 5) = tauxzd
              viscsubface(viscjminpointer(i, k))%tau(i, k, 5) = tauxz
              viscsubfaced(viscjminpointer(i, k))%tau(i, k, 6) = tauyzd
              viscsubface(viscjminpointer(i, k))%tau(i, k, 6) = tauyz
              viscsubface(viscjminpointer(i, k))%q(i, k, 1) = q_x
              viscsubface(viscjminpointer(i, k))%q(i, k, 2) = q_y
              viscsubface(viscjminpointer(i, k))%q(i, k, 3) = q_z
            end if
! and the j == jl case.
            if (j .eq. jl .and. storewalltensor .and. viscjmaxpointer(i&
&               , k) .gt. 0) then
              viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 1) = tauxxd
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 1) = tauxx
              viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 2) = tauyyd
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 2) = tauyy
              viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 3) = tauzzd
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 3) = tauzz
              viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 4) = tauxyd
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 4) = tauxy
              viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 5) = tauxzd
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 5) = tauxz
              viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 6) = tauyzd
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 6) = tauyz
              viscsubface(viscjmaxpointer(i, k))%q(i, k, 1) = q_x
              viscsubface(viscjmaxpointer(i, k))%q(i, k, 2) = q_y
              viscsubface(viscjmaxpointer(i, k))%q(i, k, 3) = q_z
            end if
          end do
        end do
      end do
!
!         viscous fluxes in the i-direction.                           
!
      mue = zero
      mued = 0.0_8
      do k=2,kl
        do j=2,jl
          do i=1,il
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
            por = half*rfilv
            if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
            muld = por*(rlvd(i, j, k)+rlvd(i+1, j, k))
            mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
            if (eddymodel) then
              mued = por*(revd(i, j, k)+revd(i+1, j, k))
              mue = por*(rev(i, j, k)+rev(i+1, j, k))
            end if
            mutd = muld + mued
            mut = mul + mue
            gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
            factlamheat = one/(prandtl*gm1)
            factturbheat = one/(prandtlturb*gm1)
            heatcoefd = factlamheat*muld + factturbheat*mued
            heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
            u_xd = fourth*(uxd(i, j-1, k-1)+uxd(i, j, k-1)+uxd(i, j-1, k&
&             )+uxd(i, j, k))
            u_x = fourth*(ux(i, j-1, k-1)+ux(i, j, k-1)+ux(i, j-1, k)+ux&
&             (i, j, k))
            u_yd = fourth*(uyd(i, j-1, k-1)+uyd(i, j, k-1)+uyd(i, j-1, k&
&             )+uyd(i, j, k))
            u_y = fourth*(uy(i, j-1, k-1)+uy(i, j, k-1)+uy(i, j-1, k)+uy&
&             (i, j, k))
            u_zd = fourth*(uzd(i, j-1, k-1)+uzd(i, j, k-1)+uzd(i, j-1, k&
&             )+uzd(i, j, k))
            u_z = fourth*(uz(i, j-1, k-1)+uz(i, j, k-1)+uz(i, j-1, k)+uz&
&             (i, j, k))
            v_xd = fourth*(vxd(i, j-1, k-1)+vxd(i, j, k-1)+vxd(i, j-1, k&
&             )+vxd(i, j, k))
            v_x = fourth*(vx(i, j-1, k-1)+vx(i, j, k-1)+vx(i, j-1, k)+vx&
&             (i, j, k))
            v_yd = fourth*(vyd(i, j-1, k-1)+vyd(i, j, k-1)+vyd(i, j-1, k&
&             )+vyd(i, j, k))
            v_y = fourth*(vy(i, j-1, k-1)+vy(i, j, k-1)+vy(i, j-1, k)+vy&
&             (i, j, k))
            v_zd = fourth*(vzd(i, j-1, k-1)+vzd(i, j, k-1)+vzd(i, j-1, k&
&             )+vzd(i, j, k))
            v_z = fourth*(vz(i, j-1, k-1)+vz(i, j, k-1)+vz(i, j-1, k)+vz&
&             (i, j, k))
            w_xd = fourth*(wxd(i, j-1, k-1)+wxd(i, j, k-1)+wxd(i, j-1, k&
&             )+wxd(i, j, k))
            w_x = fourth*(wx(i, j-1, k-1)+wx(i, j, k-1)+wx(i, j-1, k)+wx&
&             (i, j, k))
            w_yd = fourth*(wyd(i, j-1, k-1)+wyd(i, j, k-1)+wyd(i, j-1, k&
&             )+wyd(i, j, k))
            w_y = fourth*(wy(i, j-1, k-1)+wy(i, j, k-1)+wy(i, j-1, k)+wy&
&             (i, j, k))
            w_zd = fourth*(wzd(i, j-1, k-1)+wzd(i, j, k-1)+wzd(i, j-1, k&
&             )+wzd(i, j, k))
            w_z = fourth*(wz(i, j-1, k-1)+wz(i, j, k-1)+wz(i, j-1, k)+wz&
&             (i, j, k))
            q_xd = fourth*(qxd(i, j-1, k-1)+qxd(i, j, k-1)+qxd(i, j-1, k&
&             )+qxd(i, j, k))
            q_x = fourth*(qx(i, j-1, k-1)+qx(i, j, k-1)+qx(i, j-1, k)+qx&
&             (i, j, k))
            q_yd = fourth*(qyd(i, j-1, k-1)+qyd(i, j, k-1)+qyd(i, j-1, k&
&             )+qyd(i, j, k))
            q_y = fourth*(qy(i, j-1, k-1)+qy(i, j, k-1)+qy(i, j-1, k)+qy&
&             (i, j, k))
            q_zd = fourth*(qzd(i, j-1, k-1)+qzd(i, j, k-1)+qzd(i, j-1, k&
&             )+qzd(i, j, k))
            q_z = fourth*(qz(i, j-1, k-1)+qz(i, j, k-1)+qz(i, j-1, k)+qz&
&             (i, j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center i to cell center i+1.
            ssxd = eighth*(xd(i+1, j-1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(&
&             i+1, j-1, k, 1)-xd(i-1, j-1, k, 1)+xd(i+1, j, k-1, 1)-xd(i&
&             -1, j, k-1, 1)+xd(i+1, j, k, 1)-xd(i-1, j, k, 1))
            ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1&
&             , j-1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j&
&             , k-1, 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
            ssyd = eighth*(xd(i+1, j-1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(&
&             i+1, j-1, k, 2)-xd(i-1, j-1, k, 2)+xd(i+1, j, k-1, 2)-xd(i&
&             -1, j, k-1, 2)+xd(i+1, j, k, 2)-xd(i-1, j, k, 2))
            ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1&
&             , j-1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j&
&             , k-1, 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
            sszd = eighth*(xd(i+1, j-1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(&
&             i+1, j-1, k, 3)-xd(i-1, j-1, k, 3)+xd(i+1, j, k-1, 3)-xd(i&
&             -1, j, k-1, 3)+xd(i+1, j, k, 3)-xd(i-1, j, k, 3))
            ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1&
&             , j-1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j&
&             , k-1, 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
! determine the length of this vector and create the
! unit normal.
            arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz&
&             + ssz*sszd
            arg1 = ssx*ssx + ssy*ssy + ssz*ssz
            if (arg1 .eq. 0.0_8) then
              result1d = 0.0_8
            else
              result1d = arg1d/(2.0*sqrt(arg1))
            end if
            result1 = sqrt(arg1)
            ssd = -(one*result1d/result1**2)
            ss = one/result1
            ssxd = ssd*ssx + ss*ssxd
            ssx = ss*ssx
            ssyd = ssd*ssy + ss*ssyd
            ssy = ss*ssy
            sszd = ssd*ssz + ss*sszd
            ssz = ss*ssz
! correct the gradients.
            corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz&
&             + u_z*sszd - (wd(i+1, j, k, ivx)-wd(i, j, k, ivx))*ss - (w&
&             (i+1, j, k, ivx)-w(i, j, k, ivx))*ssd
            corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i&
&             , j, k, ivx))*ss
            u_xd = u_xd - corrd*ssx - corr*ssxd
            u_x = u_x - corr*ssx
            u_yd = u_yd - corrd*ssy - corr*ssyd
            u_y = u_y - corr*ssy
            u_zd = u_zd - corrd*ssz - corr*sszd
            u_z = u_z - corr*ssz
            corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz&
&             + v_z*sszd - (wd(i+1, j, k, ivy)-wd(i, j, k, ivy))*ss - (w&
&             (i+1, j, k, ivy)-w(i, j, k, ivy))*ssd
            corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i&
&             , j, k, ivy))*ss
            v_xd = v_xd - corrd*ssx - corr*ssxd
            v_x = v_x - corr*ssx
            v_yd = v_yd - corrd*ssy - corr*ssyd
            v_y = v_y - corr*ssy
            v_zd = v_zd - corrd*ssz - corr*sszd
            v_z = v_z - corr*ssz
            corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz&
&             + w_z*sszd - (wd(i+1, j, k, ivz)-wd(i, j, k, ivz))*ss - (w&
&             (i+1, j, k, ivz)-w(i, j, k, ivz))*ssd
            corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i&
&             , j, k, ivz))*ss
            w_xd = w_xd - corrd*ssx - corr*ssxd
            w_x = w_x - corr*ssx
            w_yd = w_yd - corrd*ssy - corr*ssyd
            w_y = w_y - corr*ssy
            w_zd = w_zd - corrd*ssz - corr*sszd
            w_z = w_z - corr*ssz
            corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz&
&             + q_z*sszd + (aad(i+1, j, k)-aad(i, j, k))*ss + (aa(i+1, j&
&             , k)-aa(i, j, k))*ssd
            corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i+1, j, k)-aa(i, j&
&             , k))*ss
            q_xd = q_xd - corrd*ssx - corr*ssxd
            q_x = q_x - corr*ssx
            q_yd = q_yd - corrd*ssy - corr*ssyd
            q_y = q_y - corr*ssy
            q_zd = q_zd - corrd*ssz - corr*sszd
            q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
            fracdivd = twothird*(u_xd+v_yd+w_zd)
            fracdiv = twothird*(u_x+v_y+w_z)
            tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
            tauxx = mut*(two*u_x-fracdiv)
            tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
            tauyy = mut*(two*v_y-fracdiv)
            tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
            tauzz = mut*(two*w_z-fracdiv)
            tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
            tauxy = mut*(u_y+v_x)
            tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
            tauxz = mut*(u_z+w_x)
            tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
            tauyz = mut*(v_z+w_y)
            q_xd = heatcoefd*q_x + heatcoef*q_xd
            q_x = heatcoef*q_x
            q_yd = heatcoefd*q_y + heatcoef*q_yd
            q_y = heatcoef*q_y
            q_zd = heatcoefd*q_z + heatcoef*q_zd
            q_z = heatcoef*q_z
! add qcr corrections if necessary
            if (useqcr) then
! in the qcr formulation, we add an extra term to the shear tensor:
!
! tau_ij,qcr = tau_ij - e_ij
! 
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
! compute denominator
              arg1d = u_xd*u_x + u_x*u_xd + u_yd*u_y + u_y*u_yd + u_zd*&
&               u_z + u_z*u_zd + v_xd*v_x + v_x*v_xd + v_yd*v_y + v_y*&
&               v_yd + v_zd*v_z + v_z*v_zd + w_xd*w_x + w_x*w_xd + w_yd*&
&               w_y + w_y*w_yd + w_zd*w_z + w_z*w_zd
              arg1 = u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&               v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z
              if (arg1 .eq. 0.0_8) then
                dend = 0.0_8
              else
                dend = arg1d/(2.0*sqrt(arg1))
              end if
              den = sqrt(arg1)
              if (den .lt. xminn) then
                den = xminn
                dend = 0.0_8
              else
                den = den
              end if
! compute factor that will multiply all tensor components
              factd = -(ccr1*dend/den**2)
              fact = ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
              wxyd = u_yd - v_xd
              wxy = u_y - v_x
              wxzd = u_zd - w_xd
              wxz = u_z - w_x
              wyzd = v_zd - w_yd
              wyz = v_z - w_y
              wyxd = -wxyd
              wyx = -wxy
              wzxd = -wxzd
              wzx = -wxz
              wzyd = -wyzd
              wzy = -wyz
! compute the extra terms of the boussinesq relation
              exxd = two*(factd*(wxx*tauxx+wxy*tauxy+wxz*tauxz)+fact*(&
&               wxx*tauxxd+wxyd*tauxy+wxy*tauxyd+wxzd*tauxz+wxz*tauxzd))
              exx = fact*(wxx*tauxx+wxy*tauxy+wxz*tauxz)*two
              eyyd = two*(factd*(wyx*tauxy+wyy*tauyy+wyz*tauyz)+fact*(&
&               wyxd*tauxy+wyx*tauxyd+wyy*tauyyd+wyzd*tauyz+wyz*tauyzd))
              eyy = fact*(wyx*tauxy+wyy*tauyy+wyz*tauyz)*two
              ezzd = two*(factd*(wzx*tauxz+wzy*tauyz+wzz*tauzz)+fact*(&
&               wzxd*tauxz+wzx*tauxzd+wzyd*tauyz+wzy*tauyzd+wzz*tauzzd))
              ezz = fact*(wzx*tauxz+wzy*tauyz+wzz*tauzz)*two
              exyd = factd*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz) + fact*(wxx*tauxyd+wxyd*tauyy+wxy*&
&               tauyyd+wxzd*tauyz+wxz*tauyzd+wyxd*tauxx+wyx*tauxxd+wyy*&
&               tauxyd+wyzd*tauxz+wyz*tauxzd)
              exy = fact*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz)
              exzd = factd*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz) + fact*(wxx*tauxzd+wxyd*tauyz+wxy*&
&               tauyzd+wxzd*tauzz+wxz*tauzzd+wzxd*tauxx+wzx*tauxxd+wzyd*&
&               tauxy+wzy*tauxyd+wzz*tauxzd)
              exz = fact*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz)
              eyzd = factd*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz) + fact*(wyxd*tauxz+wyx*tauxzd+wyy*&
&               tauyzd+wyzd*tauzz+wyz*tauzzd+wzxd*tauxy+wzx*tauxyd+wzyd*&
&               tauyy+wzy*tauyyd+wzz*tauyzd)
              eyz = fact*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz)
! add extra terms
              tauxxd = tauxxd - exxd
              tauxx = tauxx - exx
              tauyyd = tauyyd - eyyd
              tauyy = tauyy - eyy
              tauzzd = tauzzd - ezzd
              tauzz = tauzz - ezz
              tauxyd = tauxyd - exyd
              tauxy = tauxy - exy
              tauxzd = tauxzd - exzd
              tauxz = tauxz - exz
              tauyzd = tauyzd - eyzd
              tauyz = tauyz - eyz
            end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
            ubard = half*(wd(i, j, k, ivx)+wd(i+1, j, k, ivx))
            ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
            vbard = half*(wd(i, j, k, ivy)+wd(i+1, j, k, ivy))
            vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
            wbard = half*(wd(i, j, k, ivz)+wd(i+1, j, k, ivz))
            wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
            fmxd = tauxxd*si(i, j, k, 1) + tauxx*sid(i, j, k, 1) + &
&             tauxyd*si(i, j, k, 2) + tauxy*sid(i, j, k, 2) + tauxzd*si(&
&             i, j, k, 3) + tauxz*sid(i, j, k, 3)
            fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si&
&             (i, j, k, 3)
            fmyd = tauxyd*si(i, j, k, 1) + tauxy*sid(i, j, k, 1) + &
&             tauyyd*si(i, j, k, 2) + tauyy*sid(i, j, k, 2) + tauyzd*si(&
&             i, j, k, 3) + tauyz*sid(i, j, k, 3)
            fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si&
&             (i, j, k, 3)
            fmzd = tauxzd*si(i, j, k, 1) + tauxz*sid(i, j, k, 1) + &
&             tauyzd*si(i, j, k, 2) + tauyz*sid(i, j, k, 2) + tauzzd*si(&
&             i, j, k, 3) + tauzz*sid(i, j, k, 3)
            fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si&
&             (i, j, k, 3)
            frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
&             wbard*tauxz+wbar*tauxzd)*si(i, j, k, 1) + (ubar*tauxx+vbar&
&             *tauxy+wbar*tauxz)*sid(i, j, k, 1) + (ubard*tauxy+ubar*&
&             tauxyd+vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*si&
&             (i, j, k, 2) + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sid(i, j&
&             , k, 2) + (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd&
&             +wbard*tauzz+wbar*tauzzd)*si(i, j, k, 3) + (ubar*tauxz+&
&             vbar*tauyz+wbar*tauzz)*sid(i, j, k, 3) - q_xd*si(i, j, k, &
&             1) - q_x*sid(i, j, k, 1) - q_yd*si(i, j, k, 2) - q_y*sid(i&
&             , j, k, 2) - q_zd*si(i, j, k, 3) - q_z*sid(i, j, k, 3)
            frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + &
&             (ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
&             tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j&
&             , k, 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
! update the residuals of cell i and i+1.
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
            fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fmxd
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
            fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fmyd
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
            fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fmzd
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
            fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + frhoed
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases i == 1
! and i == il must be tested.
            if (i .eq. 1 .and. storewalltensor .and. visciminpointer(j, &
&               k) .gt. 0) then
! we need to index viscsubface with visciminpointer(j,k) 
! since tapenade does not like temporary indexes 
              viscsubfaced(visciminpointer(j, k))%tau(j, k, 1) = tauxxd
              viscsubface(visciminpointer(j, k))%tau(j, k, 1) = tauxx
              viscsubfaced(visciminpointer(j, k))%tau(j, k, 2) = tauyyd
              viscsubface(visciminpointer(j, k))%tau(j, k, 2) = tauyy
              viscsubfaced(visciminpointer(j, k))%tau(j, k, 3) = tauzzd
              viscsubface(visciminpointer(j, k))%tau(j, k, 3) = tauzz
              viscsubfaced(visciminpointer(j, k))%tau(j, k, 4) = tauxyd
              viscsubface(visciminpointer(j, k))%tau(j, k, 4) = tauxy
              viscsubfaced(visciminpointer(j, k))%tau(j, k, 5) = tauxzd
              viscsubface(visciminpointer(j, k))%tau(j, k, 5) = tauxz
              viscsubfaced(visciminpointer(j, k))%tau(j, k, 6) = tauyzd
              viscsubface(visciminpointer(j, k))%tau(j, k, 6) = tauyz
              viscsubface(visciminpointer(j, k))%q(j, k, 1) = q_x
              viscsubface(visciminpointer(j, k))%q(j, k, 2) = q_y
              viscsubface(visciminpointer(j, k))%q(j, k, 3) = q_z
            end if
! and the i == il case.
            if (i .eq. il .and. storewalltensor .and. viscimaxpointer(j&
&               , k) .gt. 0) then
! we need to index viscsubface with viscimaxpointer(j,k) 
! since tapenade does not like temporary indexes 
              viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 1) = tauxxd
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 1) = tauxx
              viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 2) = tauyyd
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 2) = tauyy
              viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 3) = tauzzd
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 3) = tauzz
              viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 4) = tauxyd
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 4) = tauxy
              viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 5) = tauxzd
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 5) = tauxz
              viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 6) = tauyzd
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 6) = tauyz
              viscsubface(viscimaxpointer(j, k))%q(j, k, 1) = q_x
              viscsubface(viscimaxpointer(j, k))%q(j, k, 2) = q_y
              viscsubface(viscimaxpointer(j, k))%q(j, k, 3) = q_z
            end if
          end do
        end do
      end do
    end if
  end subroutine viscousflux_d
  subroutine viscousflux()
!
!       viscousflux computes the viscous fluxes using a central        
!       difference scheme for a block.                                 
!       it is assumed that the pointers in block pointer already point 
!       to the correct block.                                          
!
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! possibly correct the wall shear stress.
! wall function is not aded
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype), parameter :: xminn=1.e-14_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: exx, eyy, ezz
    real(kind=realtype) :: exy, exz, eyz
    real(kind=realtype) :: wxx, wyy, wzz
    real(kind=realtype) :: wxy, wxz, wyz, wyx, wzx, wzy
    real(kind=realtype) :: den, ccr1, fact
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    logical :: correctfork, storewalltensor
    intrinsic abs
    intrinsic sqrt
    intrinsic max
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    real(kind=realtype) :: abs0
! set qcr parameters
    ccr1 = 0.3_realtype
! the diagonals of the vorticity tensor components are always zero
    wxx = zero
    wyy = zero
    wzz = zero
! set rfilv to rfil to indicate that this is the viscous part.
! if rfilv == 0 the viscous residuals need not to be computed
! and a return can be made.
    rfilv = rfil
    if (rfilv .ge. 0.) then
      abs0 = rfilv
    else
      abs0 = -rfilv
    end if
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine whether or not the wall stress tensor and wall heat
! flux must be stored for viscous walls.
      storewalltensor = .false.
      if (wallfunctions) then
        storewalltensor = .true.
      else if (rkstage .eq. 0 .and. currentlevel .eq. groundlevel) then
        storewalltensor = .true.
      end if
!
!         viscous fluxes in the k-direction.                           
!
      mue = zero
      do k=1,kl
        do j=2,jl
          do i=2,il
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
            por = half*rfilv
            if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
            mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
            if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j, k+1))
            mut = mul + mue
            gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
            factlamheat = one/(prandtl*gm1)
            factturbheat = one/(prandtlturb*gm1)
            heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
            u_x = fourth*(ux(i-1, j-1, k)+ux(i, j-1, k)+ux(i-1, j, k)+ux&
&             (i, j, k))
            u_y = fourth*(uy(i-1, j-1, k)+uy(i, j-1, k)+uy(i-1, j, k)+uy&
&             (i, j, k))
            u_z = fourth*(uz(i-1, j-1, k)+uz(i, j-1, k)+uz(i-1, j, k)+uz&
&             (i, j, k))
            v_x = fourth*(vx(i-1, j-1, k)+vx(i, j-1, k)+vx(i-1, j, k)+vx&
&             (i, j, k))
            v_y = fourth*(vy(i-1, j-1, k)+vy(i, j-1, k)+vy(i-1, j, k)+vy&
&             (i, j, k))
            v_z = fourth*(vz(i-1, j-1, k)+vz(i, j-1, k)+vz(i-1, j, k)+vz&
&             (i, j, k))
            w_x = fourth*(wx(i-1, j-1, k)+wx(i, j-1, k)+wx(i-1, j, k)+wx&
&             (i, j, k))
            w_y = fourth*(wy(i-1, j-1, k)+wy(i, j-1, k)+wy(i-1, j, k)+wy&
&             (i, j, k))
            w_z = fourth*(wz(i-1, j-1, k)+wz(i, j-1, k)+wz(i-1, j, k)+wz&
&             (i, j, k))
            q_x = fourth*(qx(i-1, j-1, k)+qx(i, j-1, k)+qx(i-1, j, k)+qx&
&             (i, j, k))
            q_y = fourth*(qy(i-1, j-1, k)+qy(i, j-1, k)+qy(i-1, j, k)+qy&
&             (i, j, k))
            q_z = fourth*(qz(i-1, j-1, k)+qz(i, j-1, k)+qz(i-1, j, k)+qz&
&             (i, j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center k to cell center k+1.
            ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1&
&             , j, k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1&
&             , k-1, 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
            ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1&
&             , j, k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1&
&             , k-1, 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
            ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1&
&             , j, k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1&
&             , k-1, 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
! determine the length of this vector and create the
! unit normal.
            arg1 = ssx*ssx + ssy*ssy + ssz*ssz
            result1 = sqrt(arg1)
            ss = one/result1
            ssx = ss*ssx
            ssy = ss*ssy
            ssz = ss*ssz
! correct the gradients.
            corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i&
&             , j, k, ivx))*ss
            u_x = u_x - corr*ssx
            u_y = u_y - corr*ssy
            u_z = u_z - corr*ssz
            corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i&
&             , j, k, ivy))*ss
            v_x = v_x - corr*ssx
            v_y = v_y - corr*ssy
            v_z = v_z - corr*ssz
            corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i&
&             , j, k, ivz))*ss
            w_x = w_x - corr*ssx
            w_y = w_y - corr*ssy
            w_z = w_z - corr*ssz
            corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j, k+1)-aa(i, j&
&             , k))*ss
            q_x = q_x - corr*ssx
            q_y = q_y - corr*ssy
            q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
            fracdiv = twothird*(u_x+v_y+w_z)
            tauxx = mut*(two*u_x-fracdiv)
            tauyy = mut*(two*v_y-fracdiv)
            tauzz = mut*(two*w_z-fracdiv)
            tauxy = mut*(u_y+v_x)
            tauxz = mut*(u_z+w_x)
            tauyz = mut*(v_z+w_y)
            q_x = heatcoef*q_x
            q_y = heatcoef*q_y
            q_z = heatcoef*q_z
! add qcr corrections if necessary
            if (useqcr) then
! in the qcr formulation, we add an extra term to the shear tensor:
!
! tau_ij,qcr = tau_ij - e_ij
! 
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
! compute denominator
              arg1 = u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&               v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z
              den = sqrt(arg1)
              if (den .lt. xminn) then
                den = xminn
              else
                den = den
              end if
! compute factor that will multiply all tensor components
              fact = ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
              wxy = u_y - v_x
              wxz = u_z - w_x
              wyz = v_z - w_y
              wyx = -wxy
              wzx = -wxz
              wzy = -wyz
! compute the extra terms of the boussinesq relation
              exx = fact*(wxx*tauxx+wxy*tauxy+wxz*tauxz)*two
              eyy = fact*(wyx*tauxy+wyy*tauyy+wyz*tauyz)*two
              ezz = fact*(wzx*tauxz+wzy*tauyz+wzz*tauzz)*two
              exy = fact*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz)
              exz = fact*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz)
              eyz = fact*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz)
! add extra terms
              tauxx = tauxx - exx
              tauyy = tauyy - eyy
              tauzz = tauzz - ezz
              tauxy = tauxy - exy
              tauxz = tauxz - exz
              tauyz = tauyz - eyz
            end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
            ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
            vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
            wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this k-face.
            fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk&
&             (i, j, k, 3)
            fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk&
&             (i, j, k, 3)
            fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk&
&             (i, j, k, 3)
            frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1)
            frhoe = frhoe + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, &
&             k, 2)
            frhoe = frhoe + (ubar*tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, &
&             k, 3)
            frhoe = frhoe - q_x*sk(i, j, k, 1) - q_y*sk(i, j, k, 2) - &
&             q_z*sk(i, j, k, 3)
! update the residuals of cell k and k+1.
            fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
            fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
            fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases k == 1
! and k == kl must be tested.
            if (k .eq. 1 .and. storewalltensor .and. visckminpointer(i, &
&               j) .gt. 0) then
! we need to index viscsubface with visckminpointer(i,j) 
! since tapenade does not like temporary indexes 
              viscsubface(visckminpointer(i, j))%tau(i, j, 1) = tauxx
              viscsubface(visckminpointer(i, j))%tau(i, j, 2) = tauyy
              viscsubface(visckminpointer(i, j))%tau(i, j, 3) = tauzz
              viscsubface(visckminpointer(i, j))%tau(i, j, 4) = tauxy
              viscsubface(visckminpointer(i, j))%tau(i, j, 5) = tauxz
              viscsubface(visckminpointer(i, j))%tau(i, j, 6) = tauyz
              viscsubface(visckminpointer(i, j))%q(i, j, 1) = q_x
              viscsubface(visckminpointer(i, j))%q(i, j, 2) = q_y
              viscsubface(visckminpointer(i, j))%q(i, j, 3) = q_z
            end if
! and the k == kl case.
            if (k .eq. kl .and. storewalltensor .and. visckmaxpointer(i&
&               , j) .gt. 0) then
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 1) = tauxx
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 2) = tauyy
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 3) = tauzz
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 4) = tauxy
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 5) = tauxz
              viscsubface(visckmaxpointer(i, j))%tau(i, j, 6) = tauyz
              viscsubface(visckmaxpointer(i, j))%q(i, j, 1) = q_x
              viscsubface(visckmaxpointer(i, j))%q(i, j, 2) = q_y
              viscsubface(visckmaxpointer(i, j))%q(i, j, 3) = q_z
            end if
          end do
        end do
      end do
!
!         viscous fluxes in the j-direction.                           
!
      continue
      mue = zero
      do k=2,kl
        do j=1,jl
          do i=2,il
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
            por = half*rfilv
            if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
            mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
            if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j+1, k))
            mut = mul + mue
            gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
            factlamheat = one/(prandtl*gm1)
            factturbheat = one/(prandtlturb*gm1)
            heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
            u_x = fourth*(ux(i-1, j, k-1)+ux(i, j, k-1)+ux(i-1, j, k)+ux&
&             (i, j, k))
            u_y = fourth*(uy(i-1, j, k-1)+uy(i, j, k-1)+uy(i-1, j, k)+uy&
&             (i, j, k))
            u_z = fourth*(uz(i-1, j, k-1)+uz(i, j, k-1)+uz(i-1, j, k)+uz&
&             (i, j, k))
            v_x = fourth*(vx(i-1, j, k-1)+vx(i, j, k-1)+vx(i-1, j, k)+vx&
&             (i, j, k))
            v_y = fourth*(vy(i-1, j, k-1)+vy(i, j, k-1)+vy(i-1, j, k)+vy&
&             (i, j, k))
            v_z = fourth*(vz(i-1, j, k-1)+vz(i, j, k-1)+vz(i-1, j, k)+vz&
&             (i, j, k))
            w_x = fourth*(wx(i-1, j, k-1)+wx(i, j, k-1)+wx(i-1, j, k)+wx&
&             (i, j, k))
            w_y = fourth*(wy(i-1, j, k-1)+wy(i, j, k-1)+wy(i-1, j, k)+wy&
&             (i, j, k))
            w_z = fourth*(wz(i-1, j, k-1)+wz(i, j, k-1)+wz(i-1, j, k)+wz&
&             (i, j, k))
            q_x = fourth*(qx(i-1, j, k-1)+qx(i, j, k-1)+qx(i-1, j, k)+qx&
&             (i, j, k))
            q_y = fourth*(qy(i-1, j, k-1)+qy(i, j, k-1)+qy(i-1, j, k)+qy&
&             (i, j, k))
            q_z = fourth*(qz(i-1, j, k-1)+qz(i, j, k-1)+qz(i-1, j, k)+qz&
&             (i, j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center j to cell center j+1.
            ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1&
&             , j+1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1&
&             , k-1, 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
            ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1&
&             , j+1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1&
&             , k-1, 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
            ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1&
&             , j+1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1&
&             , k-1, 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
! determine the length of this vector and create the
! unit normal.
            arg1 = ssx*ssx + ssy*ssy + ssz*ssz
            result1 = sqrt(arg1)
            ss = one/result1
            ssx = ss*ssx
            ssy = ss*ssy
            ssz = ss*ssz
! correct the gradients.
            corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i&
&             , j, k, ivx))*ss
            u_x = u_x - corr*ssx
            u_y = u_y - corr*ssy
            u_z = u_z - corr*ssz
            corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i&
&             , j, k, ivy))*ss
            v_x = v_x - corr*ssx
            v_y = v_y - corr*ssy
            v_z = v_z - corr*ssz
            corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i&
&             , j, k, ivz))*ss
            w_x = w_x - corr*ssx
            w_y = w_y - corr*ssy
            w_z = w_z - corr*ssz
            corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j+1, k)-aa(i, j&
&             , k))*ss
            q_x = q_x - corr*ssx
            q_y = q_y - corr*ssy
            q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
            fracdiv = twothird*(u_x+v_y+w_z)
            tauxx = mut*(two*u_x-fracdiv)
            tauyy = mut*(two*v_y-fracdiv)
            tauzz = mut*(two*w_z-fracdiv)
            tauxy = mut*(u_y+v_x)
            tauxz = mut*(u_z+w_x)
            tauyz = mut*(v_z+w_y)
            q_x = heatcoef*q_x
            q_y = heatcoef*q_y
            q_z = heatcoef*q_z
! add qcr corrections if necessary
            if (useqcr) then
! in the qcr formulation, we add an extra term to the shear tensor:
!
! tau_ij,qcr = tau_ij - e_ij
! 
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
! compute denominator
              arg1 = u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&               v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z
              den = sqrt(arg1)
              if (den .lt. xminn) then
                den = xminn
              else
                den = den
              end if
! compute factor that will multiply all tensor components
              fact = ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
              wxy = u_y - v_x
              wxz = u_z - w_x
              wyz = v_z - w_y
              wyx = -wxy
              wzx = -wxz
              wzy = -wyz
! compute the extra terms of the boussinesq relation
              exx = fact*(wxx*tauxx+wxy*tauxy+wxz*tauxz)*two
              eyy = fact*(wyx*tauxy+wyy*tauyy+wyz*tauyz)*two
              ezz = fact*(wzx*tauxz+wzy*tauyz+wzz*tauzz)*two
              exy = fact*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz)
              exz = fact*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz)
              eyz = fact*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz)
! add extra terms
              tauxx = tauxx - exx
              tauyy = tauyy - eyy
              tauzz = tauzz - ezz
              tauxy = tauxy - exy
              tauxz = tauxz - exz
              tauyz = tauyz - eyz
            end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
            ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
            vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
            wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
            fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj&
&             (i, j, k, 3)
            fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj&
&             (i, j, k, 3)
            fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj&
&             (i, j, k, 3)
            frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + &
&             (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
&             tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j&
&             , k, 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
! update the residuals of cell j and j+1.
            fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
            fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
            fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases j == 1
! and j == jl must be tested.
            if (j .eq. 1 .and. storewalltensor .and. viscjminpointer(i, &
&               k) .gt. 0) then
! we need to index viscsubface with viscjminpointer(i,k) 
! since tapenade does not like temporary indexes 
              viscsubface(viscjminpointer(i, k))%tau(i, k, 1) = tauxx
              viscsubface(viscjminpointer(i, k))%tau(i, k, 2) = tauyy
              viscsubface(viscjminpointer(i, k))%tau(i, k, 3) = tauzz
              viscsubface(viscjminpointer(i, k))%tau(i, k, 4) = tauxy
              viscsubface(viscjminpointer(i, k))%tau(i, k, 5) = tauxz
              viscsubface(viscjminpointer(i, k))%tau(i, k, 6) = tauyz
              viscsubface(viscjminpointer(i, k))%q(i, k, 1) = q_x
              viscsubface(viscjminpointer(i, k))%q(i, k, 2) = q_y
              viscsubface(viscjminpointer(i, k))%q(i, k, 3) = q_z
            end if
! and the j == jl case.
            if (j .eq. jl .and. storewalltensor .and. viscjmaxpointer(i&
&               , k) .gt. 0) then
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 1) = tauxx
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 2) = tauyy
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 3) = tauzz
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 4) = tauxy
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 5) = tauxz
              viscsubface(viscjmaxpointer(i, k))%tau(i, k, 6) = tauyz
              viscsubface(viscjmaxpointer(i, k))%q(i, k, 1) = q_x
              viscsubface(viscjmaxpointer(i, k))%q(i, k, 2) = q_y
              viscsubface(viscjmaxpointer(i, k))%q(i, k, 3) = q_z
            end if
          end do
        end do
      end do
!
!         viscous fluxes in the i-direction.                           
!
      continue
      mue = zero
      do k=2,kl
        do j=2,jl
          do i=1,il
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
            por = half*rfilv
            if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
            mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
            if (eddymodel) mue = por*(rev(i, j, k)+rev(i+1, j, k))
            mut = mul + mue
            gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
            factlamheat = one/(prandtl*gm1)
            factturbheat = one/(prandtlturb*gm1)
            heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
            u_x = fourth*(ux(i, j-1, k-1)+ux(i, j, k-1)+ux(i, j-1, k)+ux&
&             (i, j, k))
            u_y = fourth*(uy(i, j-1, k-1)+uy(i, j, k-1)+uy(i, j-1, k)+uy&
&             (i, j, k))
            u_z = fourth*(uz(i, j-1, k-1)+uz(i, j, k-1)+uz(i, j-1, k)+uz&
&             (i, j, k))
            v_x = fourth*(vx(i, j-1, k-1)+vx(i, j, k-1)+vx(i, j-1, k)+vx&
&             (i, j, k))
            v_y = fourth*(vy(i, j-1, k-1)+vy(i, j, k-1)+vy(i, j-1, k)+vy&
&             (i, j, k))
            v_z = fourth*(vz(i, j-1, k-1)+vz(i, j, k-1)+vz(i, j-1, k)+vz&
&             (i, j, k))
            w_x = fourth*(wx(i, j-1, k-1)+wx(i, j, k-1)+wx(i, j-1, k)+wx&
&             (i, j, k))
            w_y = fourth*(wy(i, j-1, k-1)+wy(i, j, k-1)+wy(i, j-1, k)+wy&
&             (i, j, k))
            w_z = fourth*(wz(i, j-1, k-1)+wz(i, j, k-1)+wz(i, j-1, k)+wz&
&             (i, j, k))
            q_x = fourth*(qx(i, j-1, k-1)+qx(i, j, k-1)+qx(i, j-1, k)+qx&
&             (i, j, k))
            q_y = fourth*(qy(i, j-1, k-1)+qy(i, j, k-1)+qy(i, j-1, k)+qy&
&             (i, j, k))
            q_z = fourth*(qz(i, j-1, k-1)+qz(i, j, k-1)+qz(i, j-1, k)+qz&
&             (i, j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center i to cell center i+1.
            ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1&
&             , j-1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j&
&             , k-1, 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
            ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1&
&             , j-1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j&
&             , k-1, 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
            ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1&
&             , j-1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j&
&             , k-1, 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
! determine the length of this vector and create the
! unit normal.
            arg1 = ssx*ssx + ssy*ssy + ssz*ssz
            result1 = sqrt(arg1)
            ss = one/result1
            ssx = ss*ssx
            ssy = ss*ssy
            ssz = ss*ssz
! correct the gradients.
            corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i&
&             , j, k, ivx))*ss
            u_x = u_x - corr*ssx
            u_y = u_y - corr*ssy
            u_z = u_z - corr*ssz
            corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i&
&             , j, k, ivy))*ss
            v_x = v_x - corr*ssx
            v_y = v_y - corr*ssy
            v_z = v_z - corr*ssz
            corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i&
&             , j, k, ivz))*ss
            w_x = w_x - corr*ssx
            w_y = w_y - corr*ssy
            w_z = w_z - corr*ssz
            corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i+1, j, k)-aa(i, j&
&             , k))*ss
            q_x = q_x - corr*ssx
            q_y = q_y - corr*ssy
            q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
            fracdiv = twothird*(u_x+v_y+w_z)
            tauxx = mut*(two*u_x-fracdiv)
            tauyy = mut*(two*v_y-fracdiv)
            tauzz = mut*(two*w_z-fracdiv)
            tauxy = mut*(u_y+v_x)
            tauxz = mut*(u_z+w_x)
            tauyz = mut*(v_z+w_y)
            q_x = heatcoef*q_x
            q_y = heatcoef*q_y
            q_z = heatcoef*q_z
! add qcr corrections if necessary
            if (useqcr) then
! in the qcr formulation, we add an extra term to the shear tensor:
!
! tau_ij,qcr = tau_ij - e_ij
! 
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
! compute denominator
              arg1 = u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&               v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z
              den = sqrt(arg1)
              if (den .lt. xminn) then
                den = xminn
              else
                den = den
              end if
! compute factor that will multiply all tensor components
              fact = ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
              wxy = u_y - v_x
              wxz = u_z - w_x
              wyz = v_z - w_y
              wyx = -wxy
              wzx = -wxz
              wzy = -wyz
! compute the extra terms of the boussinesq relation
              exx = fact*(wxx*tauxx+wxy*tauxy+wxz*tauxz)*two
              eyy = fact*(wyx*tauxy+wyy*tauyy+wyz*tauyz)*two
              ezz = fact*(wzx*tauxz+wzy*tauyz+wzz*tauzz)*two
              exy = fact*(wxx*tauxy+wxy*tauyy+wxz*tauyz+wyx*tauxx+wyy*&
&               tauxy+wyz*tauxz)
              exz = fact*(wxx*tauxz+wxy*tauyz+wxz*tauzz+wzx*tauxx+wzy*&
&               tauxy+wzz*tauxz)
              eyz = fact*(wyx*tauxz+wyy*tauyz+wyz*tauzz+wzx*tauxy+wzy*&
&               tauyy+wzz*tauyz)
! add extra terms
              tauxx = tauxx - exx
              tauyy = tauyy - eyy
              tauzz = tauzz - ezz
              tauxy = tauxy - exy
              tauxz = tauxz - exz
              tauyz = tauyz - eyz
            end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
            ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
            vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
            wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
            fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si&
&             (i, j, k, 3)
            fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si&
&             (i, j, k, 3)
            fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si&
&             (i, j, k, 3)
            frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + &
&             (ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
&             tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j&
&             , k, 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
! update the residuals of cell i and i+1.
            fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
            fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
            fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases i == 1
! and i == il must be tested.
            if (i .eq. 1 .and. storewalltensor .and. visciminpointer(j, &
&               k) .gt. 0) then
! we need to index viscsubface with visciminpointer(j,k) 
! since tapenade does not like temporary indexes 
              viscsubface(visciminpointer(j, k))%tau(j, k, 1) = tauxx
              viscsubface(visciminpointer(j, k))%tau(j, k, 2) = tauyy
              viscsubface(visciminpointer(j, k))%tau(j, k, 3) = tauzz
              viscsubface(visciminpointer(j, k))%tau(j, k, 4) = tauxy
              viscsubface(visciminpointer(j, k))%tau(j, k, 5) = tauxz
              viscsubface(visciminpointer(j, k))%tau(j, k, 6) = tauyz
              viscsubface(visciminpointer(j, k))%q(j, k, 1) = q_x
              viscsubface(visciminpointer(j, k))%q(j, k, 2) = q_y
              viscsubface(visciminpointer(j, k))%q(j, k, 3) = q_z
            end if
! and the i == il case.
            if (i .eq. il .and. storewalltensor .and. viscimaxpointer(j&
&               , k) .gt. 0) then
! we need to index viscsubface with viscimaxpointer(j,k) 
! since tapenade does not like temporary indexes 
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 1) = tauxx
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 2) = tauyy
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 3) = tauzz
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 4) = tauxy
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 5) = tauxz
              viscsubface(viscimaxpointer(j, k))%tau(j, k, 6) = tauyz
              viscsubface(viscimaxpointer(j, k))%q(j, k, 1) = q_x
              viscsubface(viscimaxpointer(j, k))%q(j, k, 2) = q_y
              viscsubface(viscimaxpointer(j, k))%q(j, k, 3) = q_z
            end if
          end do
        end do
      end do
    end if
  end subroutine viscousflux
!  differentiation of viscousfluxapprox in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw
!   with respect to varying inputs: *rev *aa *w *rlv *x *fw
!   rw status of diff variables: *rev:in *aa:in *w:in *rlv:in *x:in
!                *fw:in-out
!   plus diff mem management of: rev:in aa:in w:in rlv:in x:in
!                fw:in
  subroutine viscousfluxapprox_d()
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    integer(kind=inttype) :: ii, jj, kk
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: muld, mued, mutd, heatcoefd
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, &
&   w_yd, w_zd
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: ssxd, ssyd, sszd, ssd, fracdivd
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxxd, tauyyd, tauzzd
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxyd, tauxzd, tauyzd
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    real(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
    real(kind=realtype) :: dd
    real(kind=realtype) :: ddd
    logical :: correctfork
    mue = zero
    rfilv = rfil
    mued = 0.0_8
! viscous fluxes in the i-direction
    do k=2,kl
      do j=2,jl
        do i=1,il
! compute the vector from the center of cell i to cell i+1           
          ssxd = eighth*(xd(i+1, j-1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(i+&
&           1, j-1, k, 1)-xd(i-1, j-1, k, 1)+xd(i+1, j, k-1, 1)-xd(i-1, &
&           j, k-1, 1)+xd(i+1, j, k, 1)-xd(i-1, j, k, 1))
          ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
&           -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
&           , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
          ssyd = eighth*(xd(i+1, j-1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(i+&
&           1, j-1, k, 2)-xd(i-1, j-1, k, 2)+xd(i+1, j, k-1, 2)-xd(i-1, &
&           j, k-1, 2)+xd(i+1, j, k, 2)-xd(i-1, j, k, 2))
          ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
&           -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
&           , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
          sszd = eighth*(xd(i+1, j-1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(i+&
&           1, j-1, k, 3)-xd(i-1, j-1, k, 3)+xd(i+1, j, k-1, 3)-xd(i-1, &
&           j, k-1, 3)+xd(i+1, j, k, 3)-xd(i-1, j, k, 3))
          ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
&           -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
&           , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
! and determine one/ length of vector squared
          ssd = -(one*(ssxd*ssx+ssx*ssxd+ssyd*ssy+ssy*ssyd+sszd*ssz+ssz*&
&           sszd)/(ssx*ssx+ssy*ssy+ssz*ssz)**2)
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssxd = ssd*ssx + ss*ssxd
          ssx = ss*ssx
          ssyd = ssd*ssy + ss*ssyd
          ssy = ss*ssy
          sszd = ssd*ssz + ss*sszd
          ssz = ss*ssz
! now compute each gradient
          ddd = wd(i+1, j, k, ivx) - wd(i, j, k, ivx)
          dd = w(i+1, j, k, ivx) - w(i, j, k, ivx)
          u_xd = ddd*ssx + dd*ssxd
          u_x = dd*ssx
          u_yd = ddd*ssy + dd*ssyd
          u_y = dd*ssy
          u_zd = ddd*ssz + dd*sszd
          u_z = dd*ssz
          ddd = wd(i+1, j, k, ivy) - wd(i, j, k, ivy)
          dd = w(i+1, j, k, ivy) - w(i, j, k, ivy)
          v_xd = ddd*ssx + dd*ssxd
          v_x = dd*ssx
          v_yd = ddd*ssy + dd*ssyd
          v_y = dd*ssy
          v_zd = ddd*ssz + dd*sszd
          v_z = dd*ssz
          ddd = wd(i+1, j, k, ivz) - wd(i, j, k, ivz)
          dd = w(i+1, j, k, ivz) - w(i, j, k, ivz)
          w_xd = ddd*ssx + dd*ssxd
          w_x = dd*ssx
          w_yd = ddd*ssy + dd*ssyd
          w_y = dd*ssy
          w_zd = ddd*ssz + dd*sszd
          w_z = dd*ssz
          ddd = aad(i+1, j, k) - aad(i, j, k)
          dd = aa(i+1, j, k) - aa(i, j, k)
          q_xd = -(ddd*ssx+dd*ssxd)
          q_x = -(dd*ssx)
          q_yd = -(ddd*ssy+dd*ssyd)
          q_y = -(dd*ssy)
          q_zd = -(ddd*ssz+dd*sszd)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          muld = por*(rlvd(i, j, k)+rlvd(i+1, j, k))
          mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
          if (eddymodel) then
            mued = por*(revd(i, j, k)+revd(i+1, j, k))
            mue = por*(rev(i, j, k)+rev(i+1, j, k))
          end if
          mutd = muld + mued
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoefd = factlamheat*muld + factturbheat*mued
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdivd = twothird*(u_xd+v_yd+w_zd)
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
          tauxx = mut*(two*u_x-fracdiv)
          tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
          tauyy = mut*(two*v_y-fracdiv)
          tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
          tauzz = mut*(two*w_z-fracdiv)
          tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
          tauxy = mut*(u_y+v_x)
          tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
          tauxz = mut*(u_z+w_x)
          tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
          tauyz = mut*(v_z+w_y)
          q_xd = heatcoefd*q_x + heatcoef*q_xd
          q_x = heatcoef*q_x
          q_yd = heatcoefd*q_y + heatcoef*q_yd
          q_y = heatcoef*q_y
          q_zd = heatcoefd*q_z + heatcoef*q_zd
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubard = half*(wd(i, j, k, ivx)+wd(i+1, j, k, ivx))
          ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
          vbard = half*(wd(i, j, k, ivy)+wd(i+1, j, k, ivy))
          vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
          wbard = half*(wd(i, j, k, ivz)+wd(i+1, j, k, ivz))
          wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
          fmxd = si(i, j, k, 1)*tauxxd + si(i, j, k, 2)*tauxyd + si(i, j&
&           , k, 3)*tauxzd
          fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i&
&           , j, k, 3)
          fmyd = si(i, j, k, 1)*tauxyd + si(i, j, k, 2)*tauyyd + si(i, j&
&           , k, 3)*tauyzd
          fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i&
&           , j, k, 3)
          fmzd = si(i, j, k, 1)*tauxzd + si(i, j, k, 2)*tauyzd + si(i, j&
&           , k, 3)*tauzzd
          fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i&
&           , j, k, 3)
          frhoed = si(i, j, k, 1)*(ubard*tauxx+ubar*tauxxd+vbard*tauxy+&
&           vbar*tauxyd+wbard*tauxz+wbar*tauxzd) + si(i, j, k, 2)*(ubard&
&           *tauxy+ubar*tauxyd+vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*&
&           tauyzd) + si(i, j, k, 3)*(ubard*tauxz+ubar*tauxzd+vbard*&
&           tauyz+vbar*tauyzd+wbard*tauzz+wbar*tauzzd) - si(i, j, k, 1)*&
&           q_xd - si(i, j, k, 2)*q_yd - si(i, j, k, 3)*q_zd
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k&
&           , 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
! update the residuals of cell i and i+1.
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fmxd
          fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
          fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fmyd
          fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
          fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fmzd
          fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
          fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + frhoed
          fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
        end do
      end do
    end do
! viscous fluxes in the j-direction
    do k=2,kl
      do j=1,jl
        do i=2,il
! compute the vector from the center of cell j to cell j+1           
          ssxd = eighth*(xd(i-1, j+1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(i-&
&           1, j+1, k, 1)-xd(i-1, j-1, k, 1)+xd(i, j+1, k-1, 1)-xd(i, j-&
&           1, k-1, 1)+xd(i, j+1, k, 1)-xd(i, j-1, k, 1))
          ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
          ssyd = eighth*(xd(i-1, j+1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(i-&
&           1, j+1, k, 2)-xd(i-1, j-1, k, 2)+xd(i, j+1, k-1, 2)-xd(i, j-&
&           1, k-1, 2)+xd(i, j+1, k, 2)-xd(i, j-1, k, 2))
          ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
          sszd = eighth*(xd(i-1, j+1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(i-&
&           1, j+1, k, 3)-xd(i-1, j-1, k, 3)+xd(i, j+1, k-1, 3)-xd(i, j-&
&           1, k-1, 3)+xd(i, j+1, k, 3)-xd(i, j-1, k, 3))
          ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
! and determine one/ length of vector squared
          ssd = -(one*(ssxd*ssx+ssx*ssxd+ssyd*ssy+ssy*ssyd+sszd*ssz+ssz*&
&           sszd)/(ssx*ssx+ssy*ssy+ssz*ssz)**2)
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssxd = ssd*ssx + ss*ssxd
          ssx = ss*ssx
          ssyd = ssd*ssy + ss*ssyd
          ssy = ss*ssy
          sszd = ssd*ssz + ss*sszd
          ssz = ss*ssz
! now compute each gradient
          ddd = wd(i, j+1, k, ivx) - wd(i, j, k, ivx)
          dd = w(i, j+1, k, ivx) - w(i, j, k, ivx)
          u_xd = ddd*ssx + dd*ssxd
          u_x = dd*ssx
          u_yd = ddd*ssy + dd*ssyd
          u_y = dd*ssy
          u_zd = ddd*ssz + dd*sszd
          u_z = dd*ssz
          ddd = wd(i, j+1, k, ivy) - wd(i, j, k, ivy)
          dd = w(i, j+1, k, ivy) - w(i, j, k, ivy)
          v_xd = ddd*ssx + dd*ssxd
          v_x = dd*ssx
          v_yd = ddd*ssy + dd*ssyd
          v_y = dd*ssy
          v_zd = ddd*ssz + dd*sszd
          v_z = dd*ssz
          ddd = wd(i, j+1, k, ivz) - wd(i, j, k, ivz)
          dd = w(i, j+1, k, ivz) - w(i, j, k, ivz)
          w_xd = ddd*ssx + dd*ssxd
          w_x = dd*ssx
          w_yd = ddd*ssy + dd*ssyd
          w_y = dd*ssy
          w_zd = ddd*ssz + dd*sszd
          w_z = dd*ssz
          ddd = aad(i, j+1, k) - aad(i, j, k)
          dd = aa(i, j+1, k) - aa(i, j, k)
          q_xd = -(ddd*ssx+dd*ssxd)
          q_x = -(dd*ssx)
          q_yd = -(ddd*ssy+dd*ssyd)
          q_y = -(dd*ssy)
          q_zd = -(ddd*ssz+dd*sszd)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          muld = por*(rlvd(i, j, k)+rlvd(i, j+1, k))
          mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
          if (eddymodel) then
            mued = por*(revd(i, j, k)+revd(i, j+1, k))
            mue = por*(rev(i, j, k)+rev(i, j+1, k))
          end if
          mutd = muld + mued
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoefd = factlamheat*muld + factturbheat*mued
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdivd = twothird*(u_xd+v_yd+w_zd)
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
          tauxx = mut*(two*u_x-fracdiv)
          tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
          tauyy = mut*(two*v_y-fracdiv)
          tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
          tauzz = mut*(two*w_z-fracdiv)
          tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
          tauxy = mut*(u_y+v_x)
          tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
          tauxz = mut*(u_z+w_x)
          tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
          tauyz = mut*(v_z+w_y)
          q_xd = heatcoefd*q_x + heatcoef*q_xd
          q_x = heatcoef*q_x
          q_yd = heatcoefd*q_y + heatcoef*q_yd
          q_y = heatcoef*q_y
          q_zd = heatcoefd*q_z + heatcoef*q_zd
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubard = half*(wd(i, j, k, ivx)+wd(i, j+1, k, ivx))
          ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
          vbard = half*(wd(i, j, k, ivy)+wd(i, j+1, k, ivy))
          vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
          wbard = half*(wd(i, j, k, ivz)+wd(i, j+1, k, ivz))
          wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
          fmxd = sj(i, j, k, 1)*tauxxd + sj(i, j, k, 2)*tauxyd + sj(i, j&
&           , k, 3)*tauxzd
          fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i&
&           , j, k, 3)
          fmyd = sj(i, j, k, 1)*tauxyd + sj(i, j, k, 2)*tauyyd + sj(i, j&
&           , k, 3)*tauyzd
          fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i&
&           , j, k, 3)
          fmzd = sj(i, j, k, 1)*tauxzd + sj(i, j, k, 2)*tauyzd + sj(i, j&
&           , k, 3)*tauzzd
          fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i&
&           , j, k, 3)
          frhoed = sj(i, j, k, 1)*(ubard*tauxx+ubar*tauxxd+vbard*tauxy+&
&           vbar*tauxyd+wbard*tauxz+wbar*tauxzd) + sj(i, j, k, 2)*(ubard&
&           *tauxy+ubar*tauxyd+vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*&
&           tauyzd) + sj(i, j, k, 3)*(ubard*tauxz+ubar*tauxzd+vbard*&
&           tauyz+vbar*tauyzd+wbard*tauzz+wbar*tauzzd) - sj(i, j, k, 1)*&
&           q_xd - sj(i, j, k, 2)*q_yd - sj(i, j, k, 3)*q_zd
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k&
&           , 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
! update the residuals of cell j and j+1.
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fmxd
          fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
          fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fmyd
          fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
          fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fmzd
          fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
          fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + frhoed
          fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
        end do
      end do
    end do
! viscous fluxes in the k-direction
    do k=1,kl
      do j=2,jl
        do i=2,il
! compute the vector from the center of cell k to cell k+1           
          ssxd = eighth*(xd(i-1, j-1, k+1, 1)-xd(i-1, j-1, k-1, 1)+xd(i-&
&           1, j, k+1, 1)-xd(i-1, j, k-1, 1)+xd(i, j-1, k+1, 1)-xd(i, j-&
&           1, k-1, 1)+xd(i, j, k+1, 1)-xd(i, j, k-1, 1))
          ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
          ssyd = eighth*(xd(i-1, j-1, k+1, 2)-xd(i-1, j-1, k-1, 2)+xd(i-&
&           1, j, k+1, 2)-xd(i-1, j, k-1, 2)+xd(i, j-1, k+1, 2)-xd(i, j-&
&           1, k-1, 2)+xd(i, j, k+1, 2)-xd(i, j, k-1, 2))
          ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
          sszd = eighth*(xd(i-1, j-1, k+1, 3)-xd(i-1, j-1, k-1, 3)+xd(i-&
&           1, j, k+1, 3)-xd(i-1, j, k-1, 3)+xd(i, j-1, k+1, 3)-xd(i, j-&
&           1, k-1, 3)+xd(i, j, k+1, 3)-xd(i, j, k-1, 3))
          ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
! and determine one/ length of vector squared
          ssd = -(one*(ssxd*ssx+ssx*ssxd+ssyd*ssy+ssy*ssyd+sszd*ssz+ssz*&
&           sszd)/(ssx*ssx+ssy*ssy+ssz*ssz)**2)
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssxd = ssd*ssx + ss*ssxd
          ssx = ss*ssx
          ssyd = ssd*ssy + ss*ssyd
          ssy = ss*ssy
          sszd = ssd*ssz + ss*sszd
          ssz = ss*ssz
! now compute each gradient
          ddd = wd(i, j, k+1, ivx) - wd(i, j, k, ivx)
          dd = w(i, j, k+1, ivx) - w(i, j, k, ivx)
          u_xd = ddd*ssx + dd*ssxd
          u_x = dd*ssx
          u_yd = ddd*ssy + dd*ssyd
          u_y = dd*ssy
          u_zd = ddd*ssz + dd*sszd
          u_z = dd*ssz
          ddd = wd(i, j, k+1, ivy) - wd(i, j, k, ivy)
          dd = w(i, j, k+1, ivy) - w(i, j, k, ivy)
          v_xd = ddd*ssx + dd*ssxd
          v_x = dd*ssx
          v_yd = ddd*ssy + dd*ssyd
          v_y = dd*ssy
          v_zd = ddd*ssz + dd*sszd
          v_z = dd*ssz
          ddd = wd(i, j, k+1, ivz) - wd(i, j, k, ivz)
          dd = w(i, j, k+1, ivz) - w(i, j, k, ivz)
          w_xd = ddd*ssx + dd*ssxd
          w_x = dd*ssx
          w_yd = ddd*ssy + dd*ssyd
          w_y = dd*ssy
          w_zd = ddd*ssz + dd*sszd
          w_z = dd*ssz
          ddd = aad(i, j, k+1) - aad(i, j, k)
          dd = aa(i, j, k+1) - aa(i, j, k)
          q_xd = -(ddd*ssx+dd*ssxd)
          q_x = -(dd*ssx)
          q_yd = -(ddd*ssy+dd*ssyd)
          q_y = -(dd*ssy)
          q_zd = -(ddd*ssz+dd*sszd)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          muld = por*(rlvd(i, j, k)+rlvd(i, j, k+1))
          mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
          if (eddymodel) then
            mued = por*(revd(i, j, k)+revd(i, j, k+1))
            mue = por*(rev(i, j, k)+rev(i, j, k+1))
          end if
          mutd = muld + mued
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoefd = factlamheat*muld + factturbheat*mued
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdivd = twothird*(u_xd+v_yd+w_zd)
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
          tauxx = mut*(two*u_x-fracdiv)
          tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
          tauyy = mut*(two*v_y-fracdiv)
          tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
          tauzz = mut*(two*w_z-fracdiv)
          tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
          tauxy = mut*(u_y+v_x)
          tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
          tauxz = mut*(u_z+w_x)
          tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
          tauyz = mut*(v_z+w_y)
          q_xd = heatcoefd*q_x + heatcoef*q_xd
          q_x = heatcoef*q_x
          q_yd = heatcoefd*q_y + heatcoef*q_yd
          q_y = heatcoef*q_y
          q_zd = heatcoefd*q_z + heatcoef*q_zd
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubard = half*(wd(i, j, k, ivx)+wd(i, j, k+1, ivx))
          ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
          vbard = half*(wd(i, j, k, ivy)+wd(i, j, k+1, ivy))
          vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
          wbard = half*(wd(i, j, k, ivz)+wd(i, j, k+1, ivz))
          wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this j-face.
          fmxd = sk(i, j, k, 1)*tauxxd + sk(i, j, k, 2)*tauxyd + sk(i, j&
&           , k, 3)*tauxzd
          fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i&
&           , j, k, 3)
          fmyd = sk(i, j, k, 1)*tauxyd + sk(i, j, k, 2)*tauyyd + sk(i, j&
&           , k, 3)*tauyzd
          fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i&
&           , j, k, 3)
          fmzd = sk(i, j, k, 1)*tauxzd + sk(i, j, k, 2)*tauyzd + sk(i, j&
&           , k, 3)*tauzzd
          fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i&
&           , j, k, 3)
          frhoed = sk(i, j, k, 1)*(ubard*tauxx+ubar*tauxxd+vbard*tauxy+&
&           vbar*tauxyd+wbard*tauxz+wbar*tauxzd) + sk(i, j, k, 2)*(ubard&
&           *tauxy+ubar*tauxyd+vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*&
&           tauyzd) + sk(i, j, k, 3)*(ubard*tauxz+ubar*tauxzd+vbard*&
&           tauyz+vbar*tauyzd+wbard*tauzz+wbar*tauzzd) - sk(i, j, k, 1)*&
&           q_xd - sk(i, j, k, 2)*q_yd - sk(i, j, k, 3)*q_zd
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k, 3) - q_x*sk(i, j, k&
&           , 1) - q_y*sk(i, j, k, 2) - q_z*sk(i, j, k, 3)
! update the residuals of cell j and j+1.
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fmxd
          fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
          fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fmyd
          fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
          fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fmzd
          fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
          fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + frhoed
          fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
        end do
      end do
    end do
  end subroutine viscousfluxapprox_d
  subroutine viscousfluxapprox()
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    integer(kind=inttype) :: ii, jj, kk
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    real(kind=realtype) :: dd
    logical :: correctfork
    mue = zero
    rfilv = rfil
! viscous fluxes in the i-direction
    do k=2,kl
      do j=2,jl
        do i=1,il
! compute the vector from the center of cell i to cell i+1           
          ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
&           -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
&           , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
          ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
&           -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
&           , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
          ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
&           -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
&           , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
! and determine one/ length of vector squared
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! now compute each gradient
          dd = w(i+1, j, k, ivx) - w(i, j, k, ivx)
          u_x = dd*ssx
          u_y = dd*ssy
          u_z = dd*ssz
          dd = w(i+1, j, k, ivy) - w(i, j, k, ivy)
          v_x = dd*ssx
          v_y = dd*ssy
          v_z = dd*ssz
          dd = w(i+1, j, k, ivz) - w(i, j, k, ivz)
          w_x = dd*ssx
          w_y = dd*ssy
          w_z = dd*ssz
          dd = aa(i+1, j, k) - aa(i, j, k)
          q_x = -(dd*ssx)
          q_y = -(dd*ssy)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
          if (eddymodel) mue = por*(rev(i, j, k)+rev(i+1, j, k))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
          fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i&
&           , j, k, 3)
          fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i&
&           , j, k, 3)
          fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i&
&           , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k&
&           , 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
! update the residuals of cell i and i+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
          fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
          fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
          fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
        end do
      end do
    end do
! viscous fluxes in the j-direction
    do k=2,kl
      do j=1,jl
        do i=2,il
! compute the vector from the center of cell j to cell j+1           
          ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
          ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
          ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
! and determine one/ length of vector squared
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! now compute each gradient
          dd = w(i, j+1, k, ivx) - w(i, j, k, ivx)
          u_x = dd*ssx
          u_y = dd*ssy
          u_z = dd*ssz
          dd = w(i, j+1, k, ivy) - w(i, j, k, ivy)
          v_x = dd*ssx
          v_y = dd*ssy
          v_z = dd*ssz
          dd = w(i, j+1, k, ivz) - w(i, j, k, ivz)
          w_x = dd*ssx
          w_y = dd*ssy
          w_z = dd*ssz
          dd = aa(i, j+1, k) - aa(i, j, k)
          q_x = -(dd*ssx)
          q_y = -(dd*ssy)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
          if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j+1, k))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
          fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i&
&           , j, k, 3)
          fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i&
&           , j, k, 3)
          fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i&
&           , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k&
&           , 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
! update the residuals of cell j and j+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
          fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
          fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
          fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
        end do
      end do
    end do
! viscous fluxes in the k-direction
    do k=1,kl
      do j=2,jl
        do i=2,il
! compute the vector from the center of cell k to cell k+1           
          ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
          ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
          ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
! and determine one/ length of vector squared
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! now compute each gradient
          dd = w(i, j, k+1, ivx) - w(i, j, k, ivx)
          u_x = dd*ssx
          u_y = dd*ssy
          u_z = dd*ssz
          dd = w(i, j, k+1, ivy) - w(i, j, k, ivy)
          v_x = dd*ssx
          v_y = dd*ssy
          v_z = dd*ssz
          dd = w(i, j, k+1, ivz) - w(i, j, k, ivz)
          w_x = dd*ssx
          w_y = dd*ssy
          w_z = dd*ssz
          dd = aa(i, j, k+1) - aa(i, j, k)
          q_x = -(dd*ssx)
          q_y = -(dd*ssy)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
          if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j, k+1))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this j-face.
          fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i&
&           , j, k, 3)
          fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i&
&           , j, k, 3)
          fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i&
&           , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k, 3) - q_x*sk(i, j, k&
&           , 1) - q_y*sk(i, j, k, 2) - q_z*sk(i, j, k, 3)
! update the residuals of cell j and j+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
          fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
          fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
          fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
        end do
      end do
    end do
  end subroutine viscousfluxapprox
!  differentiation of invisciddissfluxscalarapprox in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *w *fw
!   with respect to varying inputs: *p *w *fw *radi *radj *radk
!   rw status of diff variables: *p:in *w:in-out *fw:in-out *radi:in
!                *radj:in *radk:in
!   plus diff mem management of: p:in w:in fw:in radi:in radj:in
!                radk:in
  subroutine invisciddissfluxscalarapprox_d()
!
!       invisciddissfluxscalar computes the scalar artificial          
!       dissipation, see aiaa paper 81-1259, for a given block.        
!       therefore it is assumed that the pointers in  blockpointers    
!       already point to the correct block.                            
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: rradd, dis2d
    real(kind=realtype) :: dss1, dss2, ddw, fs
    real(kind=realtype) :: ddwd, fsd
    intrinsic abs
    intrinsic max
    intrinsic min
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations) 
      case (eulerequations) 
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr
      case (nsequations, ransequations) 
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        pwr1 = rhoinf**gammainf
        sslim = 0.001_realtype*pinfcorr/pwr1
      end select
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! replace the total energy by rho times the total enthalpy.
! in this way the numerical solution is total enthalpy preserving
! for the steady euler equations. also replace the velocities by
! the momentum. only done for the entries used in the
! discretization, i.e. ignore the corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            wd(i, j, k, ivx) = wd(i, j, k, irho)*w(i, j, k, ivx) + w(i, &
&             j, k, irho)*wd(i, j, k, ivx)
            w(i, j, k, ivx) = w(i, j, k, irho)*w(i, j, k, ivx)
            wd(i, j, k, ivy) = wd(i, j, k, irho)*w(i, j, k, ivy) + w(i, &
&             j, k, irho)*wd(i, j, k, ivy)
            w(i, j, k, ivy) = w(i, j, k, irho)*w(i, j, k, ivy)
            wd(i, j, k, ivz) = wd(i, j, k, irho)*w(i, j, k, ivz) + w(i, &
&             j, k, irho)*wd(i, j, k, ivz)
            w(i, j, k, ivz) = w(i, j, k, irho)*w(i, j, k, ivz)
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) + pd(i, j, k)
            w(i, j, k, irhoe) = w(i, j, k, irhoe) + p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          wd(0, j, k, ivx) = wd(0, j, k, irho)*w(0, j, k, ivx) + w(0, j&
&           , k, irho)*wd(0, j, k, ivx)
          w(0, j, k, ivx) = w(0, j, k, irho)*w(0, j, k, ivx)
          wd(0, j, k, ivy) = wd(0, j, k, irho)*w(0, j, k, ivy) + w(0, j&
&           , k, irho)*wd(0, j, k, ivy)
          w(0, j, k, ivy) = w(0, j, k, irho)*w(0, j, k, ivy)
          wd(0, j, k, ivz) = wd(0, j, k, irho)*w(0, j, k, ivz) + w(0, j&
&           , k, irho)*wd(0, j, k, ivz)
          w(0, j, k, ivz) = w(0, j, k, irho)*w(0, j, k, ivz)
          wd(0, j, k, irhoe) = wd(0, j, k, irhoe) + pd(0, j, k)
          w(0, j, k, irhoe) = w(0, j, k, irhoe) + p(0, j, k)
          wd(1, j, k, ivx) = wd(1, j, k, irho)*w(1, j, k, ivx) + w(1, j&
&           , k, irho)*wd(1, j, k, ivx)
          w(1, j, k, ivx) = w(1, j, k, irho)*w(1, j, k, ivx)
          wd(1, j, k, ivy) = wd(1, j, k, irho)*w(1, j, k, ivy) + w(1, j&
&           , k, irho)*wd(1, j, k, ivy)
          w(1, j, k, ivy) = w(1, j, k, irho)*w(1, j, k, ivy)
          wd(1, j, k, ivz) = wd(1, j, k, irho)*w(1, j, k, ivz) + w(1, j&
&           , k, irho)*wd(1, j, k, ivz)
          w(1, j, k, ivz) = w(1, j, k, irho)*w(1, j, k, ivz)
          wd(1, j, k, irhoe) = wd(1, j, k, irhoe) + pd(1, j, k)
          w(1, j, k, irhoe) = w(1, j, k, irhoe) + p(1, j, k)
          wd(ie, j, k, ivx) = wd(ie, j, k, irho)*w(ie, j, k, ivx) + w(ie&
&           , j, k, irho)*wd(ie, j, k, ivx)
          w(ie, j, k, ivx) = w(ie, j, k, irho)*w(ie, j, k, ivx)
          wd(ie, j, k, ivy) = wd(ie, j, k, irho)*w(ie, j, k, ivy) + w(ie&
&           , j, k, irho)*wd(ie, j, k, ivy)
          w(ie, j, k, ivy) = w(ie, j, k, irho)*w(ie, j, k, ivy)
          wd(ie, j, k, ivz) = wd(ie, j, k, irho)*w(ie, j, k, ivz) + w(ie&
&           , j, k, irho)*wd(ie, j, k, ivz)
          w(ie, j, k, ivz) = w(ie, j, k, irho)*w(ie, j, k, ivz)
          wd(ie, j, k, irhoe) = wd(ie, j, k, irhoe) + pd(ie, j, k)
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) + p(ie, j, k)
          wd(ib, j, k, ivx) = wd(ib, j, k, irho)*w(ib, j, k, ivx) + w(ib&
&           , j, k, irho)*wd(ib, j, k, ivx)
          w(ib, j, k, ivx) = w(ib, j, k, irho)*w(ib, j, k, ivx)
          wd(ib, j, k, ivy) = wd(ib, j, k, irho)*w(ib, j, k, ivy) + w(ib&
&           , j, k, irho)*wd(ib, j, k, ivy)
          w(ib, j, k, ivy) = w(ib, j, k, irho)*w(ib, j, k, ivy)
          wd(ib, j, k, ivz) = wd(ib, j, k, irho)*w(ib, j, k, ivz) + w(ib&
&           , j, k, irho)*wd(ib, j, k, ivz)
          w(ib, j, k, ivz) = w(ib, j, k, irho)*w(ib, j, k, ivz)
          wd(ib, j, k, irhoe) = wd(ib, j, k, irhoe) + pd(ib, j, k)
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) + p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          wd(i, 0, k, ivx) = wd(i, 0, k, irho)*w(i, 0, k, ivx) + w(i, 0&
&           , k, irho)*wd(i, 0, k, ivx)
          w(i, 0, k, ivx) = w(i, 0, k, irho)*w(i, 0, k, ivx)
          wd(i, 0, k, ivy) = wd(i, 0, k, irho)*w(i, 0, k, ivy) + w(i, 0&
&           , k, irho)*wd(i, 0, k, ivy)
          w(i, 0, k, ivy) = w(i, 0, k, irho)*w(i, 0, k, ivy)
          wd(i, 0, k, ivz) = wd(i, 0, k, irho)*w(i, 0, k, ivz) + w(i, 0&
&           , k, irho)*wd(i, 0, k, ivz)
          w(i, 0, k, ivz) = w(i, 0, k, irho)*w(i, 0, k, ivz)
          wd(i, 0, k, irhoe) = wd(i, 0, k, irhoe) + pd(i, 0, k)
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) + p(i, 0, k)
          wd(i, 1, k, ivx) = wd(i, 1, k, irho)*w(i, 1, k, ivx) + w(i, 1&
&           , k, irho)*wd(i, 1, k, ivx)
          w(i, 1, k, ivx) = w(i, 1, k, irho)*w(i, 1, k, ivx)
          wd(i, 1, k, ivy) = wd(i, 1, k, irho)*w(i, 1, k, ivy) + w(i, 1&
&           , k, irho)*wd(i, 1, k, ivy)
          w(i, 1, k, ivy) = w(i, 1, k, irho)*w(i, 1, k, ivy)
          wd(i, 1, k, ivz) = wd(i, 1, k, irho)*w(i, 1, k, ivz) + w(i, 1&
&           , k, irho)*wd(i, 1, k, ivz)
          w(i, 1, k, ivz) = w(i, 1, k, irho)*w(i, 1, k, ivz)
          wd(i, 1, k, irhoe) = wd(i, 1, k, irhoe) + pd(i, 1, k)
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) + p(i, 1, k)
          wd(i, je, k, ivx) = wd(i, je, k, irho)*w(i, je, k, ivx) + w(i&
&           , je, k, irho)*wd(i, je, k, ivx)
          w(i, je, k, ivx) = w(i, je, k, irho)*w(i, je, k, ivx)
          wd(i, je, k, ivy) = wd(i, je, k, irho)*w(i, je, k, ivy) + w(i&
&           , je, k, irho)*wd(i, je, k, ivy)
          w(i, je, k, ivy) = w(i, je, k, irho)*w(i, je, k, ivy)
          wd(i, je, k, ivz) = wd(i, je, k, irho)*w(i, je, k, ivz) + w(i&
&           , je, k, irho)*wd(i, je, k, ivz)
          w(i, je, k, ivz) = w(i, je, k, irho)*w(i, je, k, ivz)
          wd(i, je, k, irhoe) = wd(i, je, k, irhoe) + pd(i, je, k)
          w(i, je, k, irhoe) = w(i, je, k, irhoe) + p(i, je, k)
          wd(i, jb, k, ivx) = wd(i, jb, k, irho)*w(i, jb, k, ivx) + w(i&
&           , jb, k, irho)*wd(i, jb, k, ivx)
          w(i, jb, k, ivx) = w(i, jb, k, irho)*w(i, jb, k, ivx)
          wd(i, jb, k, ivy) = wd(i, jb, k, irho)*w(i, jb, k, ivy) + w(i&
&           , jb, k, irho)*wd(i, jb, k, ivy)
          w(i, jb, k, ivy) = w(i, jb, k, irho)*w(i, jb, k, ivy)
          wd(i, jb, k, ivz) = wd(i, jb, k, irho)*w(i, jb, k, ivz) + w(i&
&           , jb, k, irho)*wd(i, jb, k, ivz)
          w(i, jb, k, ivz) = w(i, jb, k, irho)*w(i, jb, k, ivz)
          wd(i, jb, k, irhoe) = wd(i, jb, k, irhoe) + pd(i, jb, k)
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) + p(i, jb, k)
        end do
      end do
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      do k=2,kl
        do j=2,jl
          do i=2,il
            fwd(i, j, k, irho) = sfil*fwd(i, j, k, irho)
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fwd(i, j, k, imx) = sfil*fwd(i, j, k, imx)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fwd(i, j, k, imy) = sfil*fwd(i, j, k, imy)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fwd(i, j, k, imz) = sfil*fwd(i, j, k, imz)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fwd(i, j, k, irhoe) = sfil*fwd(i, j, k, irhoe)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(shocksensor(2, j, k)+two*shocksensor(&
&           1, j, k)+shocksensor(0, j, k)+sslim)
          if (x1 .ge. 0.) then
            dss1 = x1
          else
            dss1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k)+sslim)
            if (x2 .ge. 0.) then
              dss2 = x2
            else
              dss2 = -x2
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = half
            rradd = ppor*(radid(i, j, k)+radid(i+1, j, k))
            rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
            if (dss1 .lt. dss2) then
              y1 = dss2
            else
              y1 = dss1
            end if
            if (dssmax .gt. y1) then
              min1 = y1
            else
              min1 = dssmax
            end if
! modification for fd preconditioner note: this lumping
! actually still results in a greater than 3 cell stencil
! in any direction. since this seems to work slightly
! better than the dis2=sigma*fis4*rrad, we will just use
! a 5-cell stencil for doing the pc
            dis2d = fis2*min1*rradd + sigma*fis4*rradd
            dis2 = fis2*rrad*min1 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddwd = wd(i+1, j, k, irho) - wd(i, j, k, irho)
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) + fsd
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddwd = wd(i+1, j, k, ivx) - wd(i, j, k, ivx)
            ddw = w(i+1, j, k, ivx) - w(i, j, k, ivx)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fsd
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddwd = wd(i+1, j, k, ivy) - wd(i, j, k, ivy)
            ddw = w(i+1, j, k, ivy) - w(i, j, k, ivy)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fsd
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddwd = wd(i+1, j, k, ivz) - wd(i, j, k, ivz)
            ddw = w(i+1, j, k, ivz) - w(i, j, k, ivz)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fsd
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddwd = wd(i+1, j, k, irhoe) - wd(i, j, k, irhoe)
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + fsd
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do i=2,il
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(shocksensor(i, 2, k)+two*shocksensor(&
&           i, 1, k)+shocksensor(i, 0, k)+sslim)
          if (x3 .ge. 0.) then
            dss1 = x3
          else
            dss1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k)+sslim)
            if (x4 .ge. 0.) then
              dss2 = x4
            else
              dss2 = -x4
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = half
            rradd = ppor*(radjd(i, j, k)+radjd(i, j+1, k))
            rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
            if (dss1 .lt. dss2) then
              y2 = dss2
            else
              y2 = dss1
            end if
            if (dssmax .gt. y2) then
              min2 = y2
            else
              min2 = dssmax
            end if
! modification for fd preconditioner
            dis2d = fis2*min2*rradd + sigma*fis4*rradd
            dis2 = fis2*rrad*min2 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddwd = wd(i, j+1, k, irho) - wd(i, j, k, irho)
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) + fsd
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddwd = wd(i, j+1, k, ivx) - wd(i, j, k, ivx)
            ddw = w(i, j+1, k, ivx) - w(i, j, k, ivx)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fsd
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddwd = wd(i, j+1, k, ivy) - wd(i, j, k, ivy)
            ddw = w(i, j+1, k, ivy) - w(i, j, k, ivy)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fsd
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddwd = wd(i, j+1, k, ivz) - wd(i, j, k, ivz)
            ddw = w(i, j+1, k, ivz) - w(i, j, k, ivz)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fsd
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddwd = wd(i, j+1, k, irhoe) - wd(i, j, k, irhoe)
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + fsd
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do j=2,jl
        do i=2,il
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(shocksensor(i, j, 2)+two*shocksensor(&
&           i, j, 1)+shocksensor(i, j, 0)+sslim)
          if (x5 .ge. 0.) then
            dss1 = x5
          else
            dss1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k)+sslim)
            if (x6 .ge. 0.) then
              dss2 = x6
            else
              dss2 = -x6
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = half
            rradd = ppor*(radkd(i, j, k)+radkd(i, j, k+1))
            rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
            if (dss1 .lt. dss2) then
              y3 = dss2
            else
              y3 = dss1
            end if
            if (dssmax .gt. y3) then
              min3 = y3
            else
              min3 = dssmax
            end if
! modification for fd preconditioner
            dis2d = fis2*min3*rradd + sigma*fis4*rradd
            dis2 = fis2*rrad*min3 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddwd = wd(i, j, k+1, irho) - wd(i, j, k, irho)
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) + fsd
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddwd = wd(i, j, k+1, ivx) - wd(i, j, k, ivx)
            ddw = w(i, j, k+1, ivx) - w(i, j, k, ivx)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fsd
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddwd = wd(i, j, k+1, ivy) - wd(i, j, k, ivy)
            ddw = w(i, j, k+1, ivy) - w(i, j, k, ivy)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fsd
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddwd = wd(i, j, k+1, ivz) - wd(i, j, k, ivz)
            ddw = w(i, j, k+1, ivz) - w(i, j, k, ivz)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fsd
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddwd = wd(i, j, k+1, irhoe) - wd(i, j, k, irhoe)
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            fsd = dis2d*ddw + dis2*ddwd
            fs = dis2*ddw
            fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + fsd
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
! replace rho times the total enthalpy by the total energy and
! store the velocities again instead of the momentum. only for
! those entries that have been altered, i.e. ignore the
! corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            rhoid = -(one*wd(i, j, k, irho)/w(i, j, k, irho)**2)
            rhoi = one/w(i, j, k, irho)
            wd(i, j, k, ivx) = wd(i, j, k, ivx)*rhoi + w(i, j, k, ivx)*&
&             rhoid
            w(i, j, k, ivx) = w(i, j, k, ivx)*rhoi
            wd(i, j, k, ivy) = wd(i, j, k, ivy)*rhoi + w(i, j, k, ivy)*&
&             rhoid
            w(i, j, k, ivy) = w(i, j, k, ivy)*rhoi
            wd(i, j, k, ivz) = wd(i, j, k, ivz)*rhoi + w(i, j, k, ivz)*&
&             rhoid
            w(i, j, k, ivz) = w(i, j, k, ivz)*rhoi
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - pd(i, j, k)
            w(i, j, k, irhoe) = w(i, j, k, irhoe) - p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          rhoid = -(one*wd(0, j, k, irho)/w(0, j, k, irho)**2)
          rhoi = one/w(0, j, k, irho)
          wd(0, j, k, ivx) = wd(0, j, k, ivx)*rhoi + w(0, j, k, ivx)*&
&           rhoid
          w(0, j, k, ivx) = w(0, j, k, ivx)*rhoi
          wd(0, j, k, ivy) = wd(0, j, k, ivy)*rhoi + w(0, j, k, ivy)*&
&           rhoid
          w(0, j, k, ivy) = w(0, j, k, ivy)*rhoi
          wd(0, j, k, ivz) = wd(0, j, k, ivz)*rhoi + w(0, j, k, ivz)*&
&           rhoid
          w(0, j, k, ivz) = w(0, j, k, ivz)*rhoi
          wd(0, j, k, irhoe) = wd(0, j, k, irhoe) - pd(0, j, k)
          w(0, j, k, irhoe) = w(0, j, k, irhoe) - p(0, j, k)
          rhoid = -(one*wd(1, j, k, irho)/w(1, j, k, irho)**2)
          rhoi = one/w(1, j, k, irho)
          wd(1, j, k, ivx) = wd(1, j, k, ivx)*rhoi + w(1, j, k, ivx)*&
&           rhoid
          w(1, j, k, ivx) = w(1, j, k, ivx)*rhoi
          wd(1, j, k, ivy) = wd(1, j, k, ivy)*rhoi + w(1, j, k, ivy)*&
&           rhoid
          w(1, j, k, ivy) = w(1, j, k, ivy)*rhoi
          wd(1, j, k, ivz) = wd(1, j, k, ivz)*rhoi + w(1, j, k, ivz)*&
&           rhoid
          w(1, j, k, ivz) = w(1, j, k, ivz)*rhoi
          wd(1, j, k, irhoe) = wd(1, j, k, irhoe) - pd(1, j, k)
          w(1, j, k, irhoe) = w(1, j, k, irhoe) - p(1, j, k)
          rhoid = -(one*wd(ie, j, k, irho)/w(ie, j, k, irho)**2)
          rhoi = one/w(ie, j, k, irho)
          wd(ie, j, k, ivx) = wd(ie, j, k, ivx)*rhoi + w(ie, j, k, ivx)*&
&           rhoid
          w(ie, j, k, ivx) = w(ie, j, k, ivx)*rhoi
          wd(ie, j, k, ivy) = wd(ie, j, k, ivy)*rhoi + w(ie, j, k, ivy)*&
&           rhoid
          w(ie, j, k, ivy) = w(ie, j, k, ivy)*rhoi
          wd(ie, j, k, ivz) = wd(ie, j, k, ivz)*rhoi + w(ie, j, k, ivz)*&
&           rhoid
          w(ie, j, k, ivz) = w(ie, j, k, ivz)*rhoi
          wd(ie, j, k, irhoe) = wd(ie, j, k, irhoe) - pd(ie, j, k)
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) - p(ie, j, k)
          rhoid = -(one*wd(ib, j, k, irho)/w(ib, j, k, irho)**2)
          rhoi = one/w(ib, j, k, irho)
          wd(ib, j, k, ivx) = wd(ib, j, k, ivx)*rhoi + w(ib, j, k, ivx)*&
&           rhoid
          w(ib, j, k, ivx) = w(ib, j, k, ivx)*rhoi
          wd(ib, j, k, ivy) = wd(ib, j, k, ivy)*rhoi + w(ib, j, k, ivy)*&
&           rhoid
          w(ib, j, k, ivy) = w(ib, j, k, ivy)*rhoi
          wd(ib, j, k, ivz) = wd(ib, j, k, ivz)*rhoi + w(ib, j, k, ivz)*&
&           rhoid
          w(ib, j, k, ivz) = w(ib, j, k, ivz)*rhoi
          wd(ib, j, k, irhoe) = wd(ib, j, k, irhoe) - pd(ib, j, k)
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) - p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          rhoid = -(one*wd(i, 0, k, irho)/w(i, 0, k, irho)**2)
          rhoi = one/w(i, 0, k, irho)
          wd(i, 0, k, ivx) = wd(i, 0, k, ivx)*rhoi + w(i, 0, k, ivx)*&
&           rhoid
          w(i, 0, k, ivx) = w(i, 0, k, ivx)*rhoi
          wd(i, 0, k, ivy) = wd(i, 0, k, ivy)*rhoi + w(i, 0, k, ivy)*&
&           rhoid
          w(i, 0, k, ivy) = w(i, 0, k, ivy)*rhoi
          wd(i, 0, k, ivz) = wd(i, 0, k, ivz)*rhoi + w(i, 0, k, ivz)*&
&           rhoid
          w(i, 0, k, ivz) = w(i, 0, k, ivz)*rhoi
          wd(i, 0, k, irhoe) = wd(i, 0, k, irhoe) - pd(i, 0, k)
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) - p(i, 0, k)
          rhoid = -(one*wd(i, 1, k, irho)/w(i, 1, k, irho)**2)
          rhoi = one/w(i, 1, k, irho)
          wd(i, 1, k, ivx) = wd(i, 1, k, ivx)*rhoi + w(i, 1, k, ivx)*&
&           rhoid
          w(i, 1, k, ivx) = w(i, 1, k, ivx)*rhoi
          wd(i, 1, k, ivy) = wd(i, 1, k, ivy)*rhoi + w(i, 1, k, ivy)*&
&           rhoid
          w(i, 1, k, ivy) = w(i, 1, k, ivy)*rhoi
          wd(i, 1, k, ivz) = wd(i, 1, k, ivz)*rhoi + w(i, 1, k, ivz)*&
&           rhoid
          w(i, 1, k, ivz) = w(i, 1, k, ivz)*rhoi
          wd(i, 1, k, irhoe) = wd(i, 1, k, irhoe) - pd(i, 1, k)
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) - p(i, 1, k)
          rhoid = -(one*wd(i, je, k, irho)/w(i, je, k, irho)**2)
          rhoi = one/w(i, je, k, irho)
          wd(i, je, k, ivx) = wd(i, je, k, ivx)*rhoi + w(i, je, k, ivx)*&
&           rhoid
          w(i, je, k, ivx) = w(i, je, k, ivx)*rhoi
          wd(i, je, k, ivy) = wd(i, je, k, ivy)*rhoi + w(i, je, k, ivy)*&
&           rhoid
          w(i, je, k, ivy) = w(i, je, k, ivy)*rhoi
          wd(i, je, k, ivz) = wd(i, je, k, ivz)*rhoi + w(i, je, k, ivz)*&
&           rhoid
          w(i, je, k, ivz) = w(i, je, k, ivz)*rhoi
          wd(i, je, k, irhoe) = wd(i, je, k, irhoe) - pd(i, je, k)
          w(i, je, k, irhoe) = w(i, je, k, irhoe) - p(i, je, k)
          rhoid = -(one*wd(i, jb, k, irho)/w(i, jb, k, irho)**2)
          rhoi = one/w(i, jb, k, irho)
          wd(i, jb, k, ivx) = wd(i, jb, k, ivx)*rhoi + w(i, jb, k, ivx)*&
&           rhoid
          w(i, jb, k, ivx) = w(i, jb, k, ivx)*rhoi
          wd(i, jb, k, ivy) = wd(i, jb, k, ivy)*rhoi + w(i, jb, k, ivy)*&
&           rhoid
          w(i, jb, k, ivy) = w(i, jb, k, ivy)*rhoi
          wd(i, jb, k, ivz) = wd(i, jb, k, ivz)*rhoi + w(i, jb, k, ivz)*&
&           rhoid
          w(i, jb, k, ivz) = w(i, jb, k, ivz)*rhoi
          wd(i, jb, k, irhoe) = wd(i, jb, k, irhoe) - pd(i, jb, k)
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) - p(i, jb, k)
        end do
      end do
    end if
  end subroutine invisciddissfluxscalarapprox_d
  subroutine invisciddissfluxscalarapprox()
!
!       invisciddissfluxscalar computes the scalar artificial          
!       dissipation, see aiaa paper 81-1259, for a given block.        
!       therefore it is assumed that the pointers in  blockpointers    
!       already point to the correct block.                            
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: dss1, dss2, ddw, fs
    intrinsic abs
    intrinsic max
    intrinsic min
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations) 
      case (eulerequations) 
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr
      case (nsequations, ransequations) 
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        pwr1 = rhoinf**gammainf
        sslim = 0.001_realtype*pinfcorr/pwr1
      end select
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! replace the total energy by rho times the total enthalpy.
! in this way the numerical solution is total enthalpy preserving
! for the steady euler equations. also replace the velocities by
! the momentum. only done for the entries used in the
! discretization, i.e. ignore the corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            w(i, j, k, ivx) = w(i, j, k, irho)*w(i, j, k, ivx)
            w(i, j, k, ivy) = w(i, j, k, irho)*w(i, j, k, ivy)
            w(i, j, k, ivz) = w(i, j, k, irho)*w(i, j, k, ivz)
            w(i, j, k, irhoe) = w(i, j, k, irhoe) + p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          w(0, j, k, ivx) = w(0, j, k, irho)*w(0, j, k, ivx)
          w(0, j, k, ivy) = w(0, j, k, irho)*w(0, j, k, ivy)
          w(0, j, k, ivz) = w(0, j, k, irho)*w(0, j, k, ivz)
          w(0, j, k, irhoe) = w(0, j, k, irhoe) + p(0, j, k)
          w(1, j, k, ivx) = w(1, j, k, irho)*w(1, j, k, ivx)
          w(1, j, k, ivy) = w(1, j, k, irho)*w(1, j, k, ivy)
          w(1, j, k, ivz) = w(1, j, k, irho)*w(1, j, k, ivz)
          w(1, j, k, irhoe) = w(1, j, k, irhoe) + p(1, j, k)
          w(ie, j, k, ivx) = w(ie, j, k, irho)*w(ie, j, k, ivx)
          w(ie, j, k, ivy) = w(ie, j, k, irho)*w(ie, j, k, ivy)
          w(ie, j, k, ivz) = w(ie, j, k, irho)*w(ie, j, k, ivz)
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) + p(ie, j, k)
          w(ib, j, k, ivx) = w(ib, j, k, irho)*w(ib, j, k, ivx)
          w(ib, j, k, ivy) = w(ib, j, k, irho)*w(ib, j, k, ivy)
          w(ib, j, k, ivz) = w(ib, j, k, irho)*w(ib, j, k, ivz)
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) + p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          w(i, 0, k, ivx) = w(i, 0, k, irho)*w(i, 0, k, ivx)
          w(i, 0, k, ivy) = w(i, 0, k, irho)*w(i, 0, k, ivy)
          w(i, 0, k, ivz) = w(i, 0, k, irho)*w(i, 0, k, ivz)
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) + p(i, 0, k)
          w(i, 1, k, ivx) = w(i, 1, k, irho)*w(i, 1, k, ivx)
          w(i, 1, k, ivy) = w(i, 1, k, irho)*w(i, 1, k, ivy)
          w(i, 1, k, ivz) = w(i, 1, k, irho)*w(i, 1, k, ivz)
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) + p(i, 1, k)
          w(i, je, k, ivx) = w(i, je, k, irho)*w(i, je, k, ivx)
          w(i, je, k, ivy) = w(i, je, k, irho)*w(i, je, k, ivy)
          w(i, je, k, ivz) = w(i, je, k, irho)*w(i, je, k, ivz)
          w(i, je, k, irhoe) = w(i, je, k, irhoe) + p(i, je, k)
          w(i, jb, k, ivx) = w(i, jb, k, irho)*w(i, jb, k, ivx)
          w(i, jb, k, ivy) = w(i, jb, k, irho)*w(i, jb, k, ivy)
          w(i, jb, k, ivz) = w(i, jb, k, irho)*w(i, jb, k, ivz)
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) + p(i, jb, k)
        end do
      end do
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      do k=2,kl
        do j=2,jl
          do i=2,il
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(shocksensor(2, j, k)+two*shocksensor(&
&           1, j, k)+shocksensor(0, j, k)+sslim)
          if (x1 .ge. 0.) then
            dss1 = x1
          else
            dss1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k)+sslim)
            if (x2 .ge. 0.) then
              dss2 = x2
            else
              dss2 = -x2
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
            if (dss1 .lt. dss2) then
              y1 = dss2
            else
              y1 = dss1
            end if
            if (dssmax .gt. y1) then
              min1 = y1
            else
              min1 = dssmax
            end if
! modification for fd preconditioner note: this lumping
! actually still results in a greater than 3 cell stencil
! in any direction. since this seems to work slightly
! better than the dis2=sigma*fis4*rrad, we will just use
! a 5-cell stencil for doing the pc
            dis2 = fis2*rrad*min1 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            fs = dis2*ddw
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw = w(i+1, j, k, ivx) - w(i, j, k, ivx)
            fs = dis2*ddw
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw = w(i+1, j, k, ivy) - w(i, j, k, ivy)
            fs = dis2*ddw
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw = w(i+1, j, k, ivz) - w(i, j, k, ivz)
            fs = dis2*ddw
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            fs = dis2*ddw
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do i=2,il
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(shocksensor(i, 2, k)+two*shocksensor(&
&           i, 1, k)+shocksensor(i, 0, k)+sslim)
          if (x3 .ge. 0.) then
            dss1 = x3
          else
            dss1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k)+sslim)
            if (x4 .ge. 0.) then
              dss2 = x4
            else
              dss2 = -x4
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
            if (dss1 .lt. dss2) then
              y2 = dss2
            else
              y2 = dss1
            end if
            if (dssmax .gt. y2) then
              min2 = y2
            else
              min2 = dssmax
            end if
! modification for fd preconditioner
            dis2 = fis2*rrad*min2 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            fs = dis2*ddw
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw = w(i, j+1, k, ivx) - w(i, j, k, ivx)
            fs = dis2*ddw
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw = w(i, j+1, k, ivy) - w(i, j, k, ivy)
            fs = dis2*ddw
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw = w(i, j+1, k, ivz) - w(i, j, k, ivz)
            fs = dis2*ddw
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            fs = dis2*ddw
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do j=2,jl
        do i=2,il
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(shocksensor(i, j, 2)+two*shocksensor(&
&           i, j, 1)+shocksensor(i, j, 0)+sslim)
          if (x5 .ge. 0.) then
            dss1 = x5
          else
            dss1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k)+sslim)
            if (x6 .ge. 0.) then
              dss2 = x6
            else
              dss2 = -x6
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
            if (dss1 .lt. dss2) then
              y3 = dss2
            else
              y3 = dss1
            end if
            if (dssmax .gt. y3) then
              min3 = y3
            else
              min3 = dssmax
            end if
! modification for fd preconditioner
            dis2 = fis2*rrad*min3 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            fs = dis2*ddw
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw = w(i, j, k+1, ivx) - w(i, j, k, ivx)
            fs = dis2*ddw
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw = w(i, j, k+1, ivy) - w(i, j, k, ivy)
            fs = dis2*ddw
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw = w(i, j, k+1, ivz) - w(i, j, k, ivz)
            fs = dis2*ddw
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            fs = dis2*ddw
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
! replace rho times the total enthalpy by the total energy and
! store the velocities again instead of the momentum. only for
! those entries that have been altered, i.e. ignore the
! corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            rhoi = one/w(i, j, k, irho)
            w(i, j, k, ivx) = w(i, j, k, ivx)*rhoi
            w(i, j, k, ivy) = w(i, j, k, ivy)*rhoi
            w(i, j, k, ivz) = w(i, j, k, ivz)*rhoi
            w(i, j, k, irhoe) = w(i, j, k, irhoe) - p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          rhoi = one/w(0, j, k, irho)
          w(0, j, k, ivx) = w(0, j, k, ivx)*rhoi
          w(0, j, k, ivy) = w(0, j, k, ivy)*rhoi
          w(0, j, k, ivz) = w(0, j, k, ivz)*rhoi
          w(0, j, k, irhoe) = w(0, j, k, irhoe) - p(0, j, k)
          rhoi = one/w(1, j, k, irho)
          w(1, j, k, ivx) = w(1, j, k, ivx)*rhoi
          w(1, j, k, ivy) = w(1, j, k, ivy)*rhoi
          w(1, j, k, ivz) = w(1, j, k, ivz)*rhoi
          w(1, j, k, irhoe) = w(1, j, k, irhoe) - p(1, j, k)
          rhoi = one/w(ie, j, k, irho)
          w(ie, j, k, ivx) = w(ie, j, k, ivx)*rhoi
          w(ie, j, k, ivy) = w(ie, j, k, ivy)*rhoi
          w(ie, j, k, ivz) = w(ie, j, k, ivz)*rhoi
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) - p(ie, j, k)
          rhoi = one/w(ib, j, k, irho)
          w(ib, j, k, ivx) = w(ib, j, k, ivx)*rhoi
          w(ib, j, k, ivy) = w(ib, j, k, ivy)*rhoi
          w(ib, j, k, ivz) = w(ib, j, k, ivz)*rhoi
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) - p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          rhoi = one/w(i, 0, k, irho)
          w(i, 0, k, ivx) = w(i, 0, k, ivx)*rhoi
          w(i, 0, k, ivy) = w(i, 0, k, ivy)*rhoi
          w(i, 0, k, ivz) = w(i, 0, k, ivz)*rhoi
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) - p(i, 0, k)
          rhoi = one/w(i, 1, k, irho)
          w(i, 1, k, ivx) = w(i, 1, k, ivx)*rhoi
          w(i, 1, k, ivy) = w(i, 1, k, ivy)*rhoi
          w(i, 1, k, ivz) = w(i, 1, k, ivz)*rhoi
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) - p(i, 1, k)
          rhoi = one/w(i, je, k, irho)
          w(i, je, k, ivx) = w(i, je, k, ivx)*rhoi
          w(i, je, k, ivy) = w(i, je, k, ivy)*rhoi
          w(i, je, k, ivz) = w(i, je, k, ivz)*rhoi
          w(i, je, k, irhoe) = w(i, je, k, irhoe) - p(i, je, k)
          rhoi = one/w(i, jb, k, irho)
          w(i, jb, k, ivx) = w(i, jb, k, ivx)*rhoi
          w(i, jb, k, ivy) = w(i, jb, k, ivy)*rhoi
          w(i, jb, k, ivz) = w(i, jb, k, ivz)*rhoi
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) - p(i, jb, k)
        end do
      end do
    end if
  end subroutine invisciddissfluxscalarapprox
!  differentiation of invisciddissfluxmatrixapprox in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw
!   with respect to varying inputs: *p *w *fw
!   rw status of diff variables: *p:in *w:in *fw:in-out
!   plus diff mem management of: p:in w:in fw:in
  subroutine invisciddissfluxmatrixapprox_d()
!
!       invisciddissfluxmatrix computes the matrix artificial          
!       dissipation term. instead of the spectral radius, as used in   
!       the scalar dissipation scheme, the absolute value of the flux  
!       jacobian is used. this leads to a less diffusive and           
!       consequently more accurate scheme. it is assumed that the      
!       pointers in blockpointers already point to the correct block.  
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    use utils_d, only : getcorrectfork
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: rradd
    real(kind=realtype) :: dp1, dp2, ddw, tmp, fs
    real(kind=realtype) :: ddwd, fsd
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
&   abv7d
    logical :: correctfork
    intrinsic abs
    intrinsic max
    intrinsic min
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs12
    real(kind=realtype) :: abs11
    real(kind=realtype) :: abs10
    real(kind=realtype) :: abs9
    real(kind=realtype) :: abs8
    real(kind=realtype) :: abs7
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      do k=2,kl
        do j=2,jl
          do i=2,il
            fwd(i, j, k, irho) = sfil*fwd(i, j, k, irho)
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fwd(i, j, k, imx) = sfil*fwd(i, j, k, imx)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fwd(i, j, k, imy) = sfil*fwd(i, j, k, imy)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fwd(i, j, k, imz) = sfil*fwd(i, j, k, imz)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fwd(i, j, k, irhoe) = sfil*fwd(i, j, k, irhoe)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          if (shocksensor(2, j, k) - shocksensor(1, j, k) .ge. 0.) then
            abs1 = shocksensor(2, j, k) - shocksensor(1, j, k)
          else
            abs1 = -(shocksensor(2, j, k)-shocksensor(1, j, k))
          end if
          if (shocksensor(1, j, k) - shocksensor(0, j, k) .ge. 0.) then
            abs7 = shocksensor(1, j, k) - shocksensor(0, j, k)
          else
            abs7 = -(shocksensor(1, j, k)-shocksensor(0, j, k))
          end if
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(omega*(shocksensor(2, j, k)+two*&
&           shocksensor(1, j, k)+shocksensor(0, j, k))+oneminomega*(abs1&
&           +abs7)+plim)
          if (x1 .ge. 0.) then
            dp1 = x1
          else
            dp1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            if (shocksensor(i+2, j, k) - shocksensor(i+1, j, k) .ge. 0.&
&           ) then
              abs2 = shocksensor(i+2, j, k) - shocksensor(i+1, j, k)
            else
              abs2 = -(shocksensor(i+2, j, k)-shocksensor(i+1, j, k))
            end if
            if (shocksensor(i+1, j, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs8 = shocksensor(i+1, j, k) - shocksensor(i, j, k)
            else
              abs8 = -(shocksensor(i+1, j, k)-shocksensor(i, j, k))
            end if
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs2+abs8)+plim)
            if (x2 .ge. 0.) then
              dp2 = x2
            else
              dp2 = -x2
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y1 = dp2
            else
              y1 = dp1
            end if
            if (dpmax .gt. y1) then
              min1 = y1
            else
              min1 = dpmax
            end if
            dis2 = fis2*ppor*min1 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddwd = wd(i+1, j, k, irho) - wd(i, j, k, irho)
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            drd = dis2*ddwd
            dr = dis2*ddw
            ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, ivx) + w(i+1, j, k, &
&             irho)*wd(i+1, j, k, ivx) - wd(i, j, k, irho)*w(i, j, k, &
&             ivx) - w(i, j, k, irho)*wd(i, j, k, ivx)
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            drud = dis2*ddwd
            dru = dis2*ddw
            ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, ivy) + w(i+1, j, k, &
&             irho)*wd(i+1, j, k, ivy) - wd(i, j, k, irho)*w(i, j, k, &
&             ivy) - w(i, j, k, irho)*wd(i, j, k, ivy)
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drvd = dis2*ddwd
            drv = dis2*ddw
            ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, ivz) + w(i+1, j, k, &
&             irho)*wd(i+1, j, k, ivz) - wd(i, j, k, irho)*w(i, j, k, &
&             ivz) - w(i, j, k, irho)*wd(i, j, k, ivz)
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drwd = dis2*ddwd
            drw = dis2*ddw
            ddwd = wd(i+1, j, k, irhoe) - wd(i, j, k, irhoe)
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            dred = dis2*ddwd
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, itu1) + w(i+1, j, &
&               k, irho)*wd(i+1, j, k, itu1) - wd(i, j, k, irho)*w(i, j&
&               , k, itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
              ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drkd = dis2*ddwd
              drk = dis2*ddw
              kavgd = half*(wd(i, j, k, itu1)+wd(i+1, j, k, itu1))
              kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
            else
              drk = zero
              kavg = zero
              kavgd = 0.0_8
              drkd = 0.0_8
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavgd = half*(wd(i+1, j, k, ivx)+wd(i, j, k, ivx))
            uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
            vavgd = half*(wd(i+1, j, k, ivy)+wd(i, j, k, ivy))
            vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
            wavgd = half*(wd(i+1, j, k, ivz)+wd(i, j, k, ivz))
            wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
            a2avgd = half*((gamma(i+1, j, k)*pd(i+1, j, k)*w(i+1, j, k, &
&             irho)-gamma(i+1, j, k)*p(i+1, j, k)*wd(i+1, j, k, irho))/w&
&             (i+1, j, k, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k&
&             , irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, &
&             j, k, irho)**2)
            a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = si(i, j, k, 1)
            sy = si(i, j, k, 2)
            sz = si(i, j, k, 3)
            arg1 = sx**2 + sy**2 + sz**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max1 = area
            else
              max1 = 1.e-25_realtype
            end if
            tmp = one/max1
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            if (a2avg .eq. 0.0_8) then
              aavgd = 0.0_8
            else
              aavgd = a2avgd/(2.0*sqrt(a2avg))
            end if
            aavg = sqrt(a2avg)
            unavgd = sx*uavgd + sy*vavgd + sz*wavgd
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavgd = -(one*aavgd/aavg**2)
            ovaavg = one/aavg
            ova2avgd = -(one*a2avgd/a2avg**2)
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacei(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1d = unavgd + aavgd
              lam1 = unavg - sface + aavg
            else
              lam1d = -(unavgd+aavgd)
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2d = unavgd - aavgd
              lam2 = unavg - sface - aavg
            else
              lam2d = -(unavgd-aavgd)
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3d = unavgd
              lam3 = unavg - sface
            else
              lam3d = -unavgd
              lam3 = -(unavg-sface)
            end if
            rradd = lam3d + aavgd
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1d = epsacoustic*rradd
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2d = epsacoustic*rradd
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3d = epsshear*rradd
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1d = area*lam1d
            lam1 = lam1*area
            lam2d = area*lam2d
            lam2 = lam2*area
            lam3d = area*lam3d
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1d = half*(lam1d+lam2d)
            abv1 = half*(lam1+lam2)
            abv2d = half*(lam1d-lam2d)
            abv2 = half*(lam1-lam2)
            abv3d = abv1d - lam3d
            abv3 = abv1 - lam3
            abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&             vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5d = sx*drud + sy*drvd + sz*drwd - unavgd*dr - unavg*drd
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd&
&             + (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd +&
&             abv3d*abv5 + abv3*abv5d
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fsd = lam3d*dr + lam3*drd + abv6d
            fs = lam3*dr + abv6
            fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) + fsd
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sx*&
&             abv7d
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fsd
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + sy*&
&             abv7d
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fsd
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + sz*&
&             abv7d
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fsd
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + &
&             unavgd*abv7 + unavg*abv7d
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + fsd
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do i=2,il
          if (shocksensor(i, 2, k) - shocksensor(i, 1, k) .ge. 0.) then
            abs3 = shocksensor(i, 2, k) - shocksensor(i, 1, k)
          else
            abs3 = -(shocksensor(i, 2, k)-shocksensor(i, 1, k))
          end if
          if (shocksensor(i, 1, k) - shocksensor(i, 0, k) .ge. 0.) then
            abs9 = shocksensor(i, 1, k) - shocksensor(i, 0, k)
          else
            abs9 = -(shocksensor(i, 1, k)-shocksensor(i, 0, k))
          end if
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(omega*(shocksensor(i, 2, k)+two*&
&           shocksensor(i, 1, k)+shocksensor(i, 0, k))+oneminomega*(abs3&
&           +abs9)+plim)
          if (x3 .ge. 0.) then
            dp1 = x3
          else
            dp1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            if (shocksensor(i, j+2, k) - shocksensor(i, j+1, k) .ge. 0.&
&           ) then
              abs4 = shocksensor(i, j+2, k) - shocksensor(i, j+1, k)
            else
              abs4 = -(shocksensor(i, j+2, k)-shocksensor(i, j+1, k))
            end if
            if (shocksensor(i, j+1, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs10 = shocksensor(i, j+1, k) - shocksensor(i, j, k)
            else
              abs10 = -(shocksensor(i, j+1, k)-shocksensor(i, j, k))
            end if
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs4+abs10)+plim)
            if (x4 .ge. 0.) then
              dp2 = x4
            else
              dp2 = -x4
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y2 = dp2
            else
              y2 = dp1
            end if
            if (dpmax .gt. y2) then
              min2 = y2
            else
              min2 = dpmax
            end if
            dis2 = fis2*ppor*min2 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddwd = wd(i, j+1, k, irho) - wd(i, j, k, irho)
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            drd = dis2*ddwd
            dr = dis2*ddw
            ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, ivx) + w(i, j+1, k, &
&             irho)*wd(i, j+1, k, ivx) - wd(i, j, k, irho)*w(i, j, k, &
&             ivx) - w(i, j, k, irho)*wd(i, j, k, ivx)
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            drud = dis2*ddwd
            dru = dis2*ddw
            ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, ivy) + w(i, j+1, k, &
&             irho)*wd(i, j+1, k, ivy) - wd(i, j, k, irho)*w(i, j, k, &
&             ivy) - w(i, j, k, irho)*wd(i, j, k, ivy)
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drvd = dis2*ddwd
            drv = dis2*ddw
            ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, ivz) + w(i, j+1, k, &
&             irho)*wd(i, j+1, k, ivz) - wd(i, j, k, irho)*w(i, j, k, &
&             ivz) - w(i, j, k, irho)*wd(i, j, k, ivz)
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drwd = dis2*ddwd
            drw = dis2*ddw
            ddwd = wd(i, j+1, k, irhoe) - wd(i, j, k, irhoe)
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            dred = dis2*ddwd
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, itu1) + w(i, j+1, &
&               k, irho)*wd(i, j+1, k, itu1) - wd(i, j, k, irho)*w(i, j&
&               , k, itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
              ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drkd = dis2*ddwd
              drk = dis2*ddw
              kavgd = half*(wd(i, j, k, itu1)+wd(i, j+1, k, itu1))
              kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
            else
              drk = zero
              kavg = zero
              kavgd = 0.0_8
              drkd = 0.0_8
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavgd = half*(wd(i, j+1, k, ivx)+wd(i, j, k, ivx))
            uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
            vavgd = half*(wd(i, j+1, k, ivy)+wd(i, j, k, ivy))
            vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
            wavgd = half*(wd(i, j+1, k, ivz)+wd(i, j, k, ivz))
            wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
            a2avgd = half*((gamma(i, j+1, k)*pd(i, j+1, k)*w(i, j+1, k, &
&             irho)-gamma(i, j+1, k)*p(i, j+1, k)*wd(i, j+1, k, irho))/w&
&             (i, j+1, k, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k&
&             , irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, &
&             j, k, irho)**2)
            a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = sj(i, j, k, 1)
            sy = sj(i, j, k, 2)
            sz = sj(i, j, k, 3)
            arg1 = sx**2 + sy**2 + sz**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max2 = area
            else
              max2 = 1.e-25_realtype
            end if
            tmp = one/max2
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            if (a2avg .eq. 0.0_8) then
              aavgd = 0.0_8
            else
              aavgd = a2avgd/(2.0*sqrt(a2avg))
            end if
            aavg = sqrt(a2avg)
            unavgd = sx*uavgd + sy*vavgd + sz*wavgd
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavgd = -(one*aavgd/aavg**2)
            ovaavg = one/aavg
            ova2avgd = -(one*a2avgd/a2avg**2)
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacej(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1d = unavgd + aavgd
              lam1 = unavg - sface + aavg
            else
              lam1d = -(unavgd+aavgd)
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2d = unavgd - aavgd
              lam2 = unavg - sface - aavg
            else
              lam2d = -(unavgd-aavgd)
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3d = unavgd
              lam3 = unavg - sface
            else
              lam3d = -unavgd
              lam3 = -(unavg-sface)
            end if
            rradd = lam3d + aavgd
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1d = epsacoustic*rradd
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2d = epsacoustic*rradd
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3d = epsshear*rradd
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1d = area*lam1d
            lam1 = lam1*area
            lam2d = area*lam2d
            lam2 = lam2*area
            lam3d = area*lam3d
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1d = half*(lam1d+lam2d)
            abv1 = half*(lam1+lam2)
            abv2d = half*(lam1d-lam2d)
            abv2 = half*(lam1-lam2)
            abv3d = abv1d - lam3d
            abv3 = abv1 - lam3
            abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&             vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5d = sx*drud + sy*drvd + sz*drwd - unavgd*dr - unavg*drd
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd&
&             + (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd +&
&             abv3d*abv5 + abv3*abv5d
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fsd = lam3d*dr + lam3*drd + abv6d
            fs = lam3*dr + abv6
            fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) + fsd
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sx*&
&             abv7d
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fsd
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + sy*&
&             abv7d
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fsd
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + sz*&
&             abv7d
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fsd
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + &
&             unavgd*abv7 + unavg*abv7d
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + fsd
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do j=2,jl
        do i=2,il
          if (shocksensor(i, j, 2) - shocksensor(i, j, 1) .ge. 0.) then
            abs5 = shocksensor(i, j, 2) - shocksensor(i, j, 1)
          else
            abs5 = -(shocksensor(i, j, 2)-shocksensor(i, j, 1))
          end if
          if (shocksensor(i, j, 1) - shocksensor(i, j, 0) .ge. 0.) then
            abs11 = shocksensor(i, j, 1) - shocksensor(i, j, 0)
          else
            abs11 = -(shocksensor(i, j, 1)-shocksensor(i, j, 0))
          end if
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(omega*(shocksensor(i, j, 2)+two*&
&           shocksensor(i, j, 1)+shocksensor(i, j, 0))+oneminomega*(abs5&
&           +abs11)+plim)
          if (x5 .ge. 0.) then
            dp1 = x5
          else
            dp1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            if (shocksensor(i, j, k+2) - shocksensor(i, j, k+1) .ge. 0.&
&           ) then
              abs6 = shocksensor(i, j, k+2) - shocksensor(i, j, k+1)
            else
              abs6 = -(shocksensor(i, j, k+2)-shocksensor(i, j, k+1))
            end if
            if (shocksensor(i, j, k+1) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs12 = shocksensor(i, j, k+1) - shocksensor(i, j, k)
            else
              abs12 = -(shocksensor(i, j, k+1)-shocksensor(i, j, k))
            end if
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k))+oneminomega*(&
&             abs6+abs12)+plim)
            if (x6 .ge. 0.) then
              dp2 = x6
            else
              dp2 = -x6
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y3 = dp2
            else
              y3 = dp1
            end if
            if (dpmax .gt. y3) then
              min3 = y3
            else
              min3 = dpmax
            end if
            dis2 = fis2*ppor*min3 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddwd = wd(i, j, k+1, irho) - wd(i, j, k, irho)
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            drd = dis2*ddwd
            dr = dis2*ddw
            ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, ivx) + w(i, j, k+1, &
&             irho)*wd(i, j, k+1, ivx) - wd(i, j, k, irho)*w(i, j, k, &
&             ivx) - w(i, j, k, irho)*wd(i, j, k, ivx)
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            drud = dis2*ddwd
            dru = dis2*ddw
            ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, ivy) + w(i, j, k+1, &
&             irho)*wd(i, j, k+1, ivy) - wd(i, j, k, irho)*w(i, j, k, &
&             ivy) - w(i, j, k, irho)*wd(i, j, k, ivy)
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drvd = dis2*ddwd
            drv = dis2*ddw
            ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, ivz) + w(i, j, k+1, &
&             irho)*wd(i, j, k+1, ivz) - wd(i, j, k, irho)*w(i, j, k, &
&             ivz) - w(i, j, k, irho)*wd(i, j, k, ivz)
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drwd = dis2*ddwd
            drw = dis2*ddw
            ddwd = wd(i, j, k+1, irhoe) - wd(i, j, k, irhoe)
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            dred = dis2*ddwd
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, itu1) + w(i, j, k+&
&               1, irho)*wd(i, j, k+1, itu1) - wd(i, j, k, irho)*w(i, j&
&               , k, itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
              ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drkd = dis2*ddwd
              drk = dis2*ddw
              kavgd = half*(wd(i, j, k+1, itu1)+wd(i, j, k, itu1))
              kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
            else
              drk = zero
              kavg = zero
              kavgd = 0.0_8
              drkd = 0.0_8
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavgd = half*(wd(i, j, k+1, ivx)+wd(i, j, k, ivx))
            uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
            vavgd = half*(wd(i, j, k+1, ivy)+wd(i, j, k, ivy))
            vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
            wavgd = half*(wd(i, j, k+1, ivz)+wd(i, j, k, ivz))
            wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
            a2avgd = half*((gamma(i, j, k+1)*pd(i, j, k+1)*w(i, j, k+1, &
&             irho)-gamma(i, j, k+1)*p(i, j, k+1)*wd(i, j, k+1, irho))/w&
&             (i, j, k+1, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k&
&             , irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, &
&             j, k, irho)**2)
            a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = sk(i, j, k, 1)
            sy = sk(i, j, k, 2)
            sz = sk(i, j, k, 3)
            arg1 = sx**2 + sy**2 + sz**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max3 = area
            else
              max3 = 1.e-25_realtype
            end if
            tmp = one/max3
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            if (a2avg .eq. 0.0_8) then
              aavgd = 0.0_8
            else
              aavgd = a2avgd/(2.0*sqrt(a2avg))
            end if
            aavg = sqrt(a2avg)
            unavgd = sx*uavgd + sy*vavgd + sz*wavgd
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavgd = -(one*aavgd/aavg**2)
            ovaavg = one/aavg
            ova2avgd = -(one*a2avgd/a2avg**2)
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacek(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1d = unavgd + aavgd
              lam1 = unavg - sface + aavg
            else
              lam1d = -(unavgd+aavgd)
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2d = unavgd - aavgd
              lam2 = unavg - sface - aavg
            else
              lam2d = -(unavgd-aavgd)
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3d = unavgd
              lam3 = unavg - sface
            else
              lam3d = -unavgd
              lam3 = -(unavg-sface)
            end if
            rradd = lam3d + aavgd
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1d = epsacoustic*rradd
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2d = epsacoustic*rradd
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3d = epsshear*rradd
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1d = area*lam1d
            lam1 = lam1*area
            lam2d = area*lam2d
            lam2 = lam2*area
            lam3d = area*lam3d
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1d = half*(lam1d+lam2d)
            abv1 = half*(lam1+lam2)
            abv2d = half*(lam1d-lam2d)
            abv2 = half*(lam1-lam2)
            abv3d = abv1d - lam3d
            abv3 = abv1 - lam3
            abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&             vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5d = sx*drud + sy*drvd + sz*drwd - unavgd*dr - unavg*drd
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd&
&             + (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd +&
&             abv3d*abv5 + abv3*abv5d
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fsd = lam3d*dr + lam3*drd + abv6d
            fs = lam3*dr + abv6
            fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) + fsd
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sx*&
&             abv7d
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fsd
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + sy*&
&             abv7d
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fsd
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + sz*&
&             abv7d
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fsd
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + &
&             unavgd*abv7 + unavg*abv7d
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + fsd
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxmatrixapprox_d
  subroutine invisciddissfluxmatrixapprox()
!
!       invisciddissfluxmatrix computes the matrix artificial          
!       dissipation term. instead of the spectral radius, as used in   
!       the scalar dissipation scheme, the absolute value of the flux  
!       jacobian is used. this leads to a less diffusive and           
!       consequently more accurate scheme. it is assumed that the      
!       pointers in blockpointers already point to the correct block.  
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    use utils_d, only : getcorrectfork
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: dp1, dp2, ddw, tmp, fs
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    logical :: correctfork
    intrinsic abs
    intrinsic max
    intrinsic min
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs12
    real(kind=realtype) :: abs11
    real(kind=realtype) :: abs10
    real(kind=realtype) :: abs9
    real(kind=realtype) :: abs8
    real(kind=realtype) :: abs7
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      do k=2,kl
        do j=2,jl
          do i=2,il
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
!
!       dissipative fluxes in the i-direction.                         
!
      do k=2,kl
        do j=2,jl
          if (shocksensor(2, j, k) - shocksensor(1, j, k) .ge. 0.) then
            abs1 = shocksensor(2, j, k) - shocksensor(1, j, k)
          else
            abs1 = -(shocksensor(2, j, k)-shocksensor(1, j, k))
          end if
          if (shocksensor(1, j, k) - shocksensor(0, j, k) .ge. 0.) then
            abs7 = shocksensor(1, j, k) - shocksensor(0, j, k)
          else
            abs7 = -(shocksensor(1, j, k)-shocksensor(0, j, k))
          end if
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(omega*(shocksensor(2, j, k)+two*&
&           shocksensor(1, j, k)+shocksensor(0, j, k))+oneminomega*(abs1&
&           +abs7)+plim)
          if (x1 .ge. 0.) then
            dp1 = x1
          else
            dp1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            if (shocksensor(i+2, j, k) - shocksensor(i+1, j, k) .ge. 0.&
&           ) then
              abs2 = shocksensor(i+2, j, k) - shocksensor(i+1, j, k)
            else
              abs2 = -(shocksensor(i+2, j, k)-shocksensor(i+1, j, k))
            end if
            if (shocksensor(i+1, j, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs8 = shocksensor(i+1, j, k) - shocksensor(i, j, k)
            else
              abs8 = -(shocksensor(i+1, j, k)-shocksensor(i, j, k))
            end if
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs2+abs8)+plim)
            if (x2 .ge. 0.) then
              dp2 = x2
            else
              dp2 = -x2
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y1 = dp2
            else
              y1 = dp1
            end if
            if (dpmax .gt. y1) then
              min1 = y1
            else
              min1 = dpmax
            end if
            dis2 = fis2*ppor*min1 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            dr = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            dru = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drv = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drw = dis2*ddw
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = si(i, j, k, 1)
            sy = si(i, j, k, 2)
            sz = si(i, j, k, 3)
            arg1 = sx**2 + sy**2 + sz**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max1 = area
            else
              max1 = 1.e-25_realtype
            end if
            tmp = one/max1
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacei(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.                         
!
      do k=2,kl
        do i=2,il
          if (shocksensor(i, 2, k) - shocksensor(i, 1, k) .ge. 0.) then
            abs3 = shocksensor(i, 2, k) - shocksensor(i, 1, k)
          else
            abs3 = -(shocksensor(i, 2, k)-shocksensor(i, 1, k))
          end if
          if (shocksensor(i, 1, k) - shocksensor(i, 0, k) .ge. 0.) then
            abs9 = shocksensor(i, 1, k) - shocksensor(i, 0, k)
          else
            abs9 = -(shocksensor(i, 1, k)-shocksensor(i, 0, k))
          end if
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(omega*(shocksensor(i, 2, k)+two*&
&           shocksensor(i, 1, k)+shocksensor(i, 0, k))+oneminomega*(abs3&
&           +abs9)+plim)
          if (x3 .ge. 0.) then
            dp1 = x3
          else
            dp1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            if (shocksensor(i, j+2, k) - shocksensor(i, j+1, k) .ge. 0.&
&           ) then
              abs4 = shocksensor(i, j+2, k) - shocksensor(i, j+1, k)
            else
              abs4 = -(shocksensor(i, j+2, k)-shocksensor(i, j+1, k))
            end if
            if (shocksensor(i, j+1, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs10 = shocksensor(i, j+1, k) - shocksensor(i, j, k)
            else
              abs10 = -(shocksensor(i, j+1, k)-shocksensor(i, j, k))
            end if
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs4+abs10)+plim)
            if (x4 .ge. 0.) then
              dp2 = x4
            else
              dp2 = -x4
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y2 = dp2
            else
              y2 = dp1
            end if
            if (dpmax .gt. y2) then
              min2 = y2
            else
              min2 = dpmax
            end if
            dis2 = fis2*ppor*min2 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            dr = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            dru = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drv = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drw = dis2*ddw
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = sj(i, j, k, 1)
            sy = sj(i, j, k, 2)
            sz = sj(i, j, k, 3)
            arg1 = sx**2 + sy**2 + sz**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max2 = area
            else
              max2 = 1.e-25_realtype
            end if
            tmp = one/max2
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacej(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.                         
!
      do j=2,jl
        do i=2,il
          if (shocksensor(i, j, 2) - shocksensor(i, j, 1) .ge. 0.) then
            abs5 = shocksensor(i, j, 2) - shocksensor(i, j, 1)
          else
            abs5 = -(shocksensor(i, j, 2)-shocksensor(i, j, 1))
          end if
          if (shocksensor(i, j, 1) - shocksensor(i, j, 0) .ge. 0.) then
            abs11 = shocksensor(i, j, 1) - shocksensor(i, j, 0)
          else
            abs11 = -(shocksensor(i, j, 1)-shocksensor(i, j, 0))
          end if
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(omega*(shocksensor(i, j, 2)+two*&
&           shocksensor(i, j, 1)+shocksensor(i, j, 0))+oneminomega*(abs5&
&           +abs11)+plim)
          if (x5 .ge. 0.) then
            dp1 = x5
          else
            dp1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            if (shocksensor(i, j, k+2) - shocksensor(i, j, k+1) .ge. 0.&
&           ) then
              abs6 = shocksensor(i, j, k+2) - shocksensor(i, j, k+1)
            else
              abs6 = -(shocksensor(i, j, k+2)-shocksensor(i, j, k+1))
            end if
            if (shocksensor(i, j, k+1) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs12 = shocksensor(i, j, k+1) - shocksensor(i, j, k)
            else
              abs12 = -(shocksensor(i, j, k+1)-shocksensor(i, j, k))
            end if
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k))+oneminomega*(&
&             abs6+abs12)+plim)
            if (x6 .ge. 0.) then
              dp2 = x6
            else
              dp2 = -x6
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y3 = dp2
            else
              y3 = dp1
            end if
            if (dpmax .gt. y3) then
              min3 = y3
            else
              min3 = dpmax
            end if
            dis2 = fis2*ppor*min3 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            dr = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            dru = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drv = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drw = dis2*ddw
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = sk(i, j, k, 1)
            sy = sk(i, j, k, 2)
            sz = sk(i, j, k, 3)
            arg1 = sx**2 + sy**2 + sz**2
            area = sqrt(arg1)
            if (1.e-25_realtype .lt. area) then
              max3 = area
            else
              max3 = 1.e-25_realtype
            end if
            tmp = one/max3
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacek(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxmatrixapprox
end module fluxes_d

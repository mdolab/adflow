!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of invisciddissfluxscalarapprox in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *w *fw
!   with respect to varying inputs: gammainf rhoinf pinfcorr *p
!                *w *radi *radj *radk
!   plus diff mem management of: p:in w:in fw:in radi:in radj:in
!                radk:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          invisciddissfluxscalar.f90                      *
!      * author:        edwin van der weide                             *
!      * starting date: 03-24-2003                                      *
!      * last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine invisciddissfluxscalarapprox_d()
!
!      ******************************************************************
!      *                                                                *
!      * invisciddissfluxscalar computes the scalar artificial          *
!      * dissipation, see aiaa paper 81-1259, for a given block.        *
!      * therefore it is assumed that the pointers in  blockpointers    *
!      * already point to the correct block.                            *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use cgnsgrid
  use constants
  use flowvarrefstate
  use inputdiscretization
  use inputphysics
  use iteration
  implicit none
!
!      local parameter.
!
  real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ind
  real(kind=realtype) :: sslim, rhoi
  real(kind=realtype) :: sslimd, rhoid
  real(kind=realtype) :: sfil, fis2, fis4
  real(kind=realtype) :: ppor, rrad, dis2
  real(kind=realtype) :: rradd, dis2d
  real(kind=realtype) :: dss1, dss2, ddw, fs
  real(kind=realtype) :: dss1d, dss2d, ddwd, fsd
  intrinsic abs
  intrinsic max
  intrinsic min
  real(kind=realtype) :: pwr1
  real(kind=realtype) :: pwr1d
  real(kind=realtype) :: x6d
  real(kind=realtype) :: min3
  real(kind=realtype) :: min2
  real(kind=realtype) :: min1
  real(kind=realtype) :: x6
  real(kind=realtype) :: x5
  real(kind=realtype) :: min1d
  real(kind=realtype) :: x4
  real(kind=realtype) :: x3
  real(kind=realtype) :: x2
  real(kind=realtype) :: x2d
  real(kind=realtype) :: x1
  real(kind=realtype) :: x5d
  real(kind=realtype) :: y3d
  real(kind=realtype) :: x1d
  real(kind=realtype) :: min3d
  real(kind=realtype) :: x4d
  real(kind=realtype) :: y2d
  real(kind=realtype) :: abs0
  real(kind=realtype) :: min2d
  real(kind=realtype) :: y3
  real(kind=realtype) :: y2
  real(kind=realtype) :: x3d
  real(kind=realtype) :: y1
  real(kind=realtype) :: y1d
  if (rfil .ge. 0.) then
    abs0 = rfil
  else
    abs0 = -rfil
  end if
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
  if (abs0 .lt. thresholdreal) then
    fwd = 0.0_8
    return
  else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
    select case  (equations) 
    case (eulerequations) 
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
      sslimd = 0.001_realtype*pinfcorrd
      sslim = 0.001_realtype*pinfcorr
    case (nsequations, ransequations) 
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
      if (rhoinf .gt. 0.0_8) then
        pwr1d = rhoinf**gammainf*(log(rhoinf)*gammainfd+gammainf*rhoinfd&
&         /rhoinf)
      else if (rhoinf .eq. 0.0_8) then
        if (gammainf .eq. 1.0) then
          pwr1d = rhoinfd
        else
          pwr1d = 0.0_8
        end if
      else if (gammainf .eq. int(gammainf)) then
        pwr1d = gammainf*rhoinf**(gammainf-1)*rhoinfd
      else
        pwr1d = 0.0_8
      end if
      pwr1 = rhoinf**gammainf
      sslimd = (0.001_realtype*pinfcorrd*pwr1-0.001_realtype*pinfcorr*&
&       pwr1d)/pwr1**2
      sslim = 0.001_realtype*pinfcorr/pwr1
    case default
      sslimd = 0.0_8
    end select
! set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
    sfil = one - rfil
! replace the total energy by rho times the total enthalpy.
! in this way the numerical solution is total enthalpy preserving
! for the steady euler equations. also replace the velocities by
! the momentum. only done for the entries used in the
! discretization, i.e. ignore the corner halo's.
    do k=0,kb
      do j=2,jl
        do i=2,il
          wd(i, j, k, ivx) = wd(i, j, k, irho)*w(i, j, k, ivx) + w(i, j&
&           , k, irho)*wd(i, j, k, ivx)
          w(i, j, k, ivx) = w(i, j, k, irho)*w(i, j, k, ivx)
          wd(i, j, k, ivy) = wd(i, j, k, irho)*w(i, j, k, ivy) + w(i, j&
&           , k, irho)*wd(i, j, k, ivy)
          w(i, j, k, ivy) = w(i, j, k, irho)*w(i, j, k, ivy)
          wd(i, j, k, ivz) = wd(i, j, k, irho)*w(i, j, k, ivz) + w(i, j&
&           , k, irho)*wd(i, j, k, ivz)
          w(i, j, k, ivz) = w(i, j, k, irho)*w(i, j, k, ivz)
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) + pd(i, j, k)
          w(i, j, k, irhoe) = w(i, j, k, irhoe) + p(i, j, k)
        end do
      end do
    end do
    do k=2,kl
      do j=2,jl
        wd(0, j, k, ivx) = wd(0, j, k, irho)*w(0, j, k, ivx) + w(0, j, k&
&         , irho)*wd(0, j, k, ivx)
        w(0, j, k, ivx) = w(0, j, k, irho)*w(0, j, k, ivx)
        wd(0, j, k, ivy) = wd(0, j, k, irho)*w(0, j, k, ivy) + w(0, j, k&
&         , irho)*wd(0, j, k, ivy)
        w(0, j, k, ivy) = w(0, j, k, irho)*w(0, j, k, ivy)
        wd(0, j, k, ivz) = wd(0, j, k, irho)*w(0, j, k, ivz) + w(0, j, k&
&         , irho)*wd(0, j, k, ivz)
        w(0, j, k, ivz) = w(0, j, k, irho)*w(0, j, k, ivz)
        wd(0, j, k, irhoe) = wd(0, j, k, irhoe) + pd(0, j, k)
        w(0, j, k, irhoe) = w(0, j, k, irhoe) + p(0, j, k)
        wd(1, j, k, ivx) = wd(1, j, k, irho)*w(1, j, k, ivx) + w(1, j, k&
&         , irho)*wd(1, j, k, ivx)
        w(1, j, k, ivx) = w(1, j, k, irho)*w(1, j, k, ivx)
        wd(1, j, k, ivy) = wd(1, j, k, irho)*w(1, j, k, ivy) + w(1, j, k&
&         , irho)*wd(1, j, k, ivy)
        w(1, j, k, ivy) = w(1, j, k, irho)*w(1, j, k, ivy)
        wd(1, j, k, ivz) = wd(1, j, k, irho)*w(1, j, k, ivz) + w(1, j, k&
&         , irho)*wd(1, j, k, ivz)
        w(1, j, k, ivz) = w(1, j, k, irho)*w(1, j, k, ivz)
        wd(1, j, k, irhoe) = wd(1, j, k, irhoe) + pd(1, j, k)
        w(1, j, k, irhoe) = w(1, j, k, irhoe) + p(1, j, k)
        wd(ie, j, k, ivx) = wd(ie, j, k, irho)*w(ie, j, k, ivx) + w(ie, &
&         j, k, irho)*wd(ie, j, k, ivx)
        w(ie, j, k, ivx) = w(ie, j, k, irho)*w(ie, j, k, ivx)
        wd(ie, j, k, ivy) = wd(ie, j, k, irho)*w(ie, j, k, ivy) + w(ie, &
&         j, k, irho)*wd(ie, j, k, ivy)
        w(ie, j, k, ivy) = w(ie, j, k, irho)*w(ie, j, k, ivy)
        wd(ie, j, k, ivz) = wd(ie, j, k, irho)*w(ie, j, k, ivz) + w(ie, &
&         j, k, irho)*wd(ie, j, k, ivz)
        w(ie, j, k, ivz) = w(ie, j, k, irho)*w(ie, j, k, ivz)
        wd(ie, j, k, irhoe) = wd(ie, j, k, irhoe) + pd(ie, j, k)
        w(ie, j, k, irhoe) = w(ie, j, k, irhoe) + p(ie, j, k)
        wd(ib, j, k, ivx) = wd(ib, j, k, irho)*w(ib, j, k, ivx) + w(ib, &
&         j, k, irho)*wd(ib, j, k, ivx)
        w(ib, j, k, ivx) = w(ib, j, k, irho)*w(ib, j, k, ivx)
        wd(ib, j, k, ivy) = wd(ib, j, k, irho)*w(ib, j, k, ivy) + w(ib, &
&         j, k, irho)*wd(ib, j, k, ivy)
        w(ib, j, k, ivy) = w(ib, j, k, irho)*w(ib, j, k, ivy)
        wd(ib, j, k, ivz) = wd(ib, j, k, irho)*w(ib, j, k, ivz) + w(ib, &
&         j, k, irho)*wd(ib, j, k, ivz)
        w(ib, j, k, ivz) = w(ib, j, k, irho)*w(ib, j, k, ivz)
        wd(ib, j, k, irhoe) = wd(ib, j, k, irhoe) + pd(ib, j, k)
        w(ib, j, k, irhoe) = w(ib, j, k, irhoe) + p(ib, j, k)
      end do
    end do
    do k=2,kl
      do i=2,il
        wd(i, 0, k, ivx) = wd(i, 0, k, irho)*w(i, 0, k, ivx) + w(i, 0, k&
&         , irho)*wd(i, 0, k, ivx)
        w(i, 0, k, ivx) = w(i, 0, k, irho)*w(i, 0, k, ivx)
        wd(i, 0, k, ivy) = wd(i, 0, k, irho)*w(i, 0, k, ivy) + w(i, 0, k&
&         , irho)*wd(i, 0, k, ivy)
        w(i, 0, k, ivy) = w(i, 0, k, irho)*w(i, 0, k, ivy)
        wd(i, 0, k, ivz) = wd(i, 0, k, irho)*w(i, 0, k, ivz) + w(i, 0, k&
&         , irho)*wd(i, 0, k, ivz)
        w(i, 0, k, ivz) = w(i, 0, k, irho)*w(i, 0, k, ivz)
        wd(i, 0, k, irhoe) = wd(i, 0, k, irhoe) + pd(i, 0, k)
        w(i, 0, k, irhoe) = w(i, 0, k, irhoe) + p(i, 0, k)
        wd(i, 1, k, ivx) = wd(i, 1, k, irho)*w(i, 1, k, ivx) + w(i, 1, k&
&         , irho)*wd(i, 1, k, ivx)
        w(i, 1, k, ivx) = w(i, 1, k, irho)*w(i, 1, k, ivx)
        wd(i, 1, k, ivy) = wd(i, 1, k, irho)*w(i, 1, k, ivy) + w(i, 1, k&
&         , irho)*wd(i, 1, k, ivy)
        w(i, 1, k, ivy) = w(i, 1, k, irho)*w(i, 1, k, ivy)
        wd(i, 1, k, ivz) = wd(i, 1, k, irho)*w(i, 1, k, ivz) + w(i, 1, k&
&         , irho)*wd(i, 1, k, ivz)
        w(i, 1, k, ivz) = w(i, 1, k, irho)*w(i, 1, k, ivz)
        wd(i, 1, k, irhoe) = wd(i, 1, k, irhoe) + pd(i, 1, k)
        w(i, 1, k, irhoe) = w(i, 1, k, irhoe) + p(i, 1, k)
        wd(i, je, k, ivx) = wd(i, je, k, irho)*w(i, je, k, ivx) + w(i, &
&         je, k, irho)*wd(i, je, k, ivx)
        w(i, je, k, ivx) = w(i, je, k, irho)*w(i, je, k, ivx)
        wd(i, je, k, ivy) = wd(i, je, k, irho)*w(i, je, k, ivy) + w(i, &
&         je, k, irho)*wd(i, je, k, ivy)
        w(i, je, k, ivy) = w(i, je, k, irho)*w(i, je, k, ivy)
        wd(i, je, k, ivz) = wd(i, je, k, irho)*w(i, je, k, ivz) + w(i, &
&         je, k, irho)*wd(i, je, k, ivz)
        w(i, je, k, ivz) = w(i, je, k, irho)*w(i, je, k, ivz)
        wd(i, je, k, irhoe) = wd(i, je, k, irhoe) + pd(i, je, k)
        w(i, je, k, irhoe) = w(i, je, k, irhoe) + p(i, je, k)
        wd(i, jb, k, ivx) = wd(i, jb, k, irho)*w(i, jb, k, ivx) + w(i, &
&         jb, k, irho)*wd(i, jb, k, ivx)
        w(i, jb, k, ivx) = w(i, jb, k, irho)*w(i, jb, k, ivx)
        wd(i, jb, k, ivy) = wd(i, jb, k, irho)*w(i, jb, k, ivy) + w(i, &
&         jb, k, irho)*wd(i, jb, k, ivy)
        w(i, jb, k, ivy) = w(i, jb, k, irho)*w(i, jb, k, ivy)
        wd(i, jb, k, ivz) = wd(i, jb, k, irho)*w(i, jb, k, ivz) + w(i, &
&         jb, k, irho)*wd(i, jb, k, ivz)
        w(i, jb, k, ivz) = w(i, jb, k, irho)*w(i, jb, k, ivz)
        wd(i, jb, k, irhoe) = wd(i, jb, k, irhoe) + pd(i, jb, k)
        w(i, jb, k, irhoe) = w(i, jb, k, irhoe) + p(i, jb, k)
      end do
    end do
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
    do k=2,kl
      do j=2,jl
        do i=2,il
          fwd(i, j, k, irho) = 0.0_8
          fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
          fwd(i, j, k, imx) = 0.0_8
          fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
          fwd(i, j, k, imy) = 0.0_8
          fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
          fwd(i, j, k, imz) = 0.0_8
          fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
          fwd(i, j, k, irhoe) = 0.0_8
          fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
        end do
      end do
    end do
    fwd = 0.0_8
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the i-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do j=2,jl
        x1d = -((shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&         shocksensor(0, j, k))*sslimd/(shocksensor(2, j, k)+two*&
&         shocksensor(1, j, k)+shocksensor(0, j, k)+sslim)**2)
        x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+shocksensor(&
&         0, j, k))/(shocksensor(2, j, k)+two*shocksensor(1, j, k)+&
&         shocksensor(0, j, k)+sslim)
        if (x1 .ge. 0.) then
          dss1d = x1d
          dss1 = x1
        else
          dss1d = -x1d
          dss1 = -x1
        end if
! loop in i-direction.
        do i=1,il
          x2d = -((shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&           shocksensor(i, j, k))*sslimd/(shocksensor(i+2, j, k)+two*&
&           shocksensor(i+1, j, k)+shocksensor(i, j, k)+sslim)**2)
          x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&           shocksensor(i, j, k))/(shocksensor(i+2, j, k)+two*&
&           shocksensor(i+1, j, k)+shocksensor(i, j, k)+sslim)
          if (x2 .ge. 0.) then
            dss2d = x2d
            dss2 = x2
          else
            dss2d = -x2d
            dss2 = -x2
          end if
! compute the dissipation coefficients for this face.
          ppor = zero
          if (pori(i, j, k) .eq. normalflux) ppor = half
          rradd = ppor*(radid(i, j, k)+radid(i+1, j, k))
          rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
          if (dss1 .lt. dss2) then
            y1d = dss2d
            y1 = dss2
          else
            y1d = dss1d
            y1 = dss1
          end if
          if (dssmax .gt. y1) then
            min1d = y1d
            min1 = y1
          else
            min1 = dssmax
            min1d = 0.0_8
          end if
! modification for fd preconditioner note: this lumping
! actually still results in a greater than 3 cell stencil
! in any direction. since this seems to work slightly
! better than the dis2=sigma*fis4*rrad, we will just use
! a 5-cell stencil for doing the pc
          dis2d = fis2*(rradd*min1+rrad*min1d) + sigma*fis4*rradd
          dis2 = fis2*rrad*min1 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
          ddwd = wd(i+1, j, k, irho) - wd(i, j, k, irho)
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) + fsd
          fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
          fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
          ddwd = wd(i+1, j, k, ivx) - wd(i, j, k, ivx)
          ddw = w(i+1, j, k, ivx) - w(i, j, k, ivx)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fsd
          fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
          ddwd = wd(i+1, j, k, ivy) - wd(i, j, k, ivy)
          ddw = w(i+1, j, k, ivy) - w(i, j, k, ivy)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fsd
          fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
          ddwd = wd(i+1, j, k, ivz) - wd(i, j, k, ivz)
          ddw = w(i+1, j, k, ivz) - w(i, j, k, ivz)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fsd
          fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
          ddwd = wd(i+1, j, k, irhoe) - wd(i, j, k, irhoe)
          ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + fsd
          fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
          dss1d = dss2d
          dss1 = dss2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the j-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do i=2,il
        x3d = -((shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&         shocksensor(i, 0, k))*sslimd/(shocksensor(i, 2, k)+two*&
&         shocksensor(i, 1, k)+shocksensor(i, 0, k)+sslim)**2)
        x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+shocksensor(&
&         i, 0, k))/(shocksensor(i, 2, k)+two*shocksensor(i, 1, k)+&
&         shocksensor(i, 0, k)+sslim)
        if (x3 .ge. 0.) then
          dss1d = x3d
          dss1 = x3
        else
          dss1d = -x3d
          dss1 = -x3
        end if
! loop in j-direction.
        do j=1,jl
          x4d = -((shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&           shocksensor(i, j, k))*sslimd/(shocksensor(i, j+2, k)+two*&
&           shocksensor(i, j+1, k)+shocksensor(i, j, k)+sslim)**2)
          x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&           shocksensor(i, j, k))/(shocksensor(i, j+2, k)+two*&
&           shocksensor(i, j+1, k)+shocksensor(i, j, k)+sslim)
          if (x4 .ge. 0.) then
            dss2d = x4d
            dss2 = x4
          else
            dss2d = -x4d
            dss2 = -x4
          end if
! compute the dissipation coefficients for this face.
          ppor = zero
          if (porj(i, j, k) .eq. normalflux) ppor = half
          rradd = ppor*(radjd(i, j, k)+radjd(i, j+1, k))
          rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
          if (dss1 .lt. dss2) then
            y2d = dss2d
            y2 = dss2
          else
            y2d = dss1d
            y2 = dss1
          end if
          if (dssmax .gt. y2) then
            min2d = y2d
            min2 = y2
          else
            min2 = dssmax
            min2d = 0.0_8
          end if
! modification for fd preconditioner
          dis2d = fis2*(rradd*min2+rrad*min2d) + sigma*fis4*rradd
          dis2 = fis2*rrad*min2 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
          ddwd = wd(i, j+1, k, irho) - wd(i, j, k, irho)
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) + fsd
          fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
          fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
          ddwd = wd(i, j+1, k, ivx) - wd(i, j, k, ivx)
          ddw = w(i, j+1, k, ivx) - w(i, j, k, ivx)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fsd
          fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
          ddwd = wd(i, j+1, k, ivy) - wd(i, j, k, ivy)
          ddw = w(i, j+1, k, ivy) - w(i, j, k, ivy)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fsd
          fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
          ddwd = wd(i, j+1, k, ivz) - wd(i, j, k, ivz)
          ddw = w(i, j+1, k, ivz) - w(i, j, k, ivz)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fsd
          fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
          ddwd = wd(i, j+1, k, irhoe) - wd(i, j, k, irhoe)
          ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + fsd
          fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
          dss1d = dss2d
          dss1 = dss2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the k-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do j=2,jl
      do i=2,il
        x5d = -((shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&         shocksensor(i, j, 0))*sslimd/(shocksensor(i, j, 2)+two*&
&         shocksensor(i, j, 1)+shocksensor(i, j, 0)+sslim)**2)
        x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+shocksensor(&
&         i, j, 0))/(shocksensor(i, j, 2)+two*shocksensor(i, j, 1)+&
&         shocksensor(i, j, 0)+sslim)
        if (x5 .ge. 0.) then
          dss1d = x5d
          dss1 = x5
        else
          dss1d = -x5d
          dss1 = -x5
        end if
! loop in k-direction.
        do k=1,kl
          x6d = -((shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&           shocksensor(i, j, k))*sslimd/(shocksensor(i, j, k+2)+two*&
&           shocksensor(i, j, k+1)+shocksensor(i, j, k)+sslim)**2)
          x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&           shocksensor(i, j, k))/(shocksensor(i, j, k+2)+two*&
&           shocksensor(i, j, k+1)+shocksensor(i, j, k)+sslim)
          if (x6 .ge. 0.) then
            dss2d = x6d
            dss2 = x6
          else
            dss2d = -x6d
            dss2 = -x6
          end if
! compute the dissipation coefficients for this face.
          ppor = zero
          if (pork(i, j, k) .eq. normalflux) ppor = half
          rradd = ppor*(radkd(i, j, k)+radkd(i, j, k+1))
          rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
          if (dss1 .lt. dss2) then
            y3d = dss2d
            y3 = dss2
          else
            y3d = dss1d
            y3 = dss1
          end if
          if (dssmax .gt. y3) then
            min3d = y3d
            min3 = y3
          else
            min3 = dssmax
            min3d = 0.0_8
          end if
! modification for fd preconditioner
          dis2d = fis2*(rradd*min3+rrad*min3d) + sigma*fis4*rradd
          dis2 = fis2*rrad*min3 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
          ddwd = wd(i, j, k+1, irho) - wd(i, j, k, irho)
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) + fsd
          fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
          fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
          ddwd = wd(i, j, k+1, ivx) - wd(i, j, k, ivx)
          ddw = w(i, j, k+1, ivx) - w(i, j, k, ivx)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fsd
          fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
          ddwd = wd(i, j, k+1, ivy) - wd(i, j, k, ivy)
          ddw = w(i, j, k+1, ivy) - w(i, j, k, ivy)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fsd
          fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
          ddwd = wd(i, j, k+1, ivz) - wd(i, j, k, ivz)
          ddw = w(i, j, k+1, ivz) - w(i, j, k, ivz)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fsd
          fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
          ddwd = wd(i, j, k+1, irhoe) - wd(i, j, k, irhoe)
          ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          fsd = dis2d*ddw + dis2*ddwd
          fs = dis2*ddw
          fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + fsd
          fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
          dss1d = dss2d
          dss1 = dss2
        end do
      end do
    end do
! replace rho times the total enthalpy by the total energy and
! store the velocities again instead of the momentum. only for
! those entries that have been altered, i.e. ignore the
! corner halo's.
    do k=0,kb
      do j=2,jl
        do i=2,il
          rhoid = -(one*wd(i, j, k, irho)/w(i, j, k, irho)**2)
          rhoi = one/w(i, j, k, irho)
          wd(i, j, k, ivx) = wd(i, j, k, ivx)*rhoi + w(i, j, k, ivx)*&
&           rhoid
          w(i, j, k, ivx) = w(i, j, k, ivx)*rhoi
          wd(i, j, k, ivy) = wd(i, j, k, ivy)*rhoi + w(i, j, k, ivy)*&
&           rhoid
          w(i, j, k, ivy) = w(i, j, k, ivy)*rhoi
          wd(i, j, k, ivz) = wd(i, j, k, ivz)*rhoi + w(i, j, k, ivz)*&
&           rhoid
          w(i, j, k, ivz) = w(i, j, k, ivz)*rhoi
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - pd(i, j, k)
          w(i, j, k, irhoe) = w(i, j, k, irhoe) - p(i, j, k)
        end do
      end do
    end do
    do k=2,kl
      do j=2,jl
        rhoid = -(one*wd(0, j, k, irho)/w(0, j, k, irho)**2)
        rhoi = one/w(0, j, k, irho)
        wd(0, j, k, ivx) = wd(0, j, k, ivx)*rhoi + w(0, j, k, ivx)*rhoid
        w(0, j, k, ivx) = w(0, j, k, ivx)*rhoi
        wd(0, j, k, ivy) = wd(0, j, k, ivy)*rhoi + w(0, j, k, ivy)*rhoid
        w(0, j, k, ivy) = w(0, j, k, ivy)*rhoi
        wd(0, j, k, ivz) = wd(0, j, k, ivz)*rhoi + w(0, j, k, ivz)*rhoid
        w(0, j, k, ivz) = w(0, j, k, ivz)*rhoi
        wd(0, j, k, irhoe) = wd(0, j, k, irhoe) - pd(0, j, k)
        w(0, j, k, irhoe) = w(0, j, k, irhoe) - p(0, j, k)
        rhoid = -(one*wd(1, j, k, irho)/w(1, j, k, irho)**2)
        rhoi = one/w(1, j, k, irho)
        wd(1, j, k, ivx) = wd(1, j, k, ivx)*rhoi + w(1, j, k, ivx)*rhoid
        w(1, j, k, ivx) = w(1, j, k, ivx)*rhoi
        wd(1, j, k, ivy) = wd(1, j, k, ivy)*rhoi + w(1, j, k, ivy)*rhoid
        w(1, j, k, ivy) = w(1, j, k, ivy)*rhoi
        wd(1, j, k, ivz) = wd(1, j, k, ivz)*rhoi + w(1, j, k, ivz)*rhoid
        w(1, j, k, ivz) = w(1, j, k, ivz)*rhoi
        wd(1, j, k, irhoe) = wd(1, j, k, irhoe) - pd(1, j, k)
        w(1, j, k, irhoe) = w(1, j, k, irhoe) - p(1, j, k)
        rhoid = -(one*wd(ie, j, k, irho)/w(ie, j, k, irho)**2)
        rhoi = one/w(ie, j, k, irho)
        wd(ie, j, k, ivx) = wd(ie, j, k, ivx)*rhoi + w(ie, j, k, ivx)*&
&         rhoid
        w(ie, j, k, ivx) = w(ie, j, k, ivx)*rhoi
        wd(ie, j, k, ivy) = wd(ie, j, k, ivy)*rhoi + w(ie, j, k, ivy)*&
&         rhoid
        w(ie, j, k, ivy) = w(ie, j, k, ivy)*rhoi
        wd(ie, j, k, ivz) = wd(ie, j, k, ivz)*rhoi + w(ie, j, k, ivz)*&
&         rhoid
        w(ie, j, k, ivz) = w(ie, j, k, ivz)*rhoi
        wd(ie, j, k, irhoe) = wd(ie, j, k, irhoe) - pd(ie, j, k)
        w(ie, j, k, irhoe) = w(ie, j, k, irhoe) - p(ie, j, k)
        rhoid = -(one*wd(ib, j, k, irho)/w(ib, j, k, irho)**2)
        rhoi = one/w(ib, j, k, irho)
        wd(ib, j, k, ivx) = wd(ib, j, k, ivx)*rhoi + w(ib, j, k, ivx)*&
&         rhoid
        w(ib, j, k, ivx) = w(ib, j, k, ivx)*rhoi
        wd(ib, j, k, ivy) = wd(ib, j, k, ivy)*rhoi + w(ib, j, k, ivy)*&
&         rhoid
        w(ib, j, k, ivy) = w(ib, j, k, ivy)*rhoi
        wd(ib, j, k, ivz) = wd(ib, j, k, ivz)*rhoi + w(ib, j, k, ivz)*&
&         rhoid
        w(ib, j, k, ivz) = w(ib, j, k, ivz)*rhoi
        wd(ib, j, k, irhoe) = wd(ib, j, k, irhoe) - pd(ib, j, k)
        w(ib, j, k, irhoe) = w(ib, j, k, irhoe) - p(ib, j, k)
      end do
    end do
    do k=2,kl
      do i=2,il
        rhoid = -(one*wd(i, 0, k, irho)/w(i, 0, k, irho)**2)
        rhoi = one/w(i, 0, k, irho)
        wd(i, 0, k, ivx) = wd(i, 0, k, ivx)*rhoi + w(i, 0, k, ivx)*rhoid
        w(i, 0, k, ivx) = w(i, 0, k, ivx)*rhoi
        wd(i, 0, k, ivy) = wd(i, 0, k, ivy)*rhoi + w(i, 0, k, ivy)*rhoid
        w(i, 0, k, ivy) = w(i, 0, k, ivy)*rhoi
        wd(i, 0, k, ivz) = wd(i, 0, k, ivz)*rhoi + w(i, 0, k, ivz)*rhoid
        w(i, 0, k, ivz) = w(i, 0, k, ivz)*rhoi
        wd(i, 0, k, irhoe) = wd(i, 0, k, irhoe) - pd(i, 0, k)
        w(i, 0, k, irhoe) = w(i, 0, k, irhoe) - p(i, 0, k)
        rhoid = -(one*wd(i, 1, k, irho)/w(i, 1, k, irho)**2)
        rhoi = one/w(i, 1, k, irho)
        wd(i, 1, k, ivx) = wd(i, 1, k, ivx)*rhoi + w(i, 1, k, ivx)*rhoid
        w(i, 1, k, ivx) = w(i, 1, k, ivx)*rhoi
        wd(i, 1, k, ivy) = wd(i, 1, k, ivy)*rhoi + w(i, 1, k, ivy)*rhoid
        w(i, 1, k, ivy) = w(i, 1, k, ivy)*rhoi
        wd(i, 1, k, ivz) = wd(i, 1, k, ivz)*rhoi + w(i, 1, k, ivz)*rhoid
        w(i, 1, k, ivz) = w(i, 1, k, ivz)*rhoi
        wd(i, 1, k, irhoe) = wd(i, 1, k, irhoe) - pd(i, 1, k)
        w(i, 1, k, irhoe) = w(i, 1, k, irhoe) - p(i, 1, k)
        rhoid = -(one*wd(i, je, k, irho)/w(i, je, k, irho)**2)
        rhoi = one/w(i, je, k, irho)
        wd(i, je, k, ivx) = wd(i, je, k, ivx)*rhoi + w(i, je, k, ivx)*&
&         rhoid
        w(i, je, k, ivx) = w(i, je, k, ivx)*rhoi
        wd(i, je, k, ivy) = wd(i, je, k, ivy)*rhoi + w(i, je, k, ivy)*&
&         rhoid
        w(i, je, k, ivy) = w(i, je, k, ivy)*rhoi
        wd(i, je, k, ivz) = wd(i, je, k, ivz)*rhoi + w(i, je, k, ivz)*&
&         rhoid
        w(i, je, k, ivz) = w(i, je, k, ivz)*rhoi
        wd(i, je, k, irhoe) = wd(i, je, k, irhoe) - pd(i, je, k)
        w(i, je, k, irhoe) = w(i, je, k, irhoe) - p(i, je, k)
        rhoid = -(one*wd(i, jb, k, irho)/w(i, jb, k, irho)**2)
        rhoi = one/w(i, jb, k, irho)
        wd(i, jb, k, ivx) = wd(i, jb, k, ivx)*rhoi + w(i, jb, k, ivx)*&
&         rhoid
        w(i, jb, k, ivx) = w(i, jb, k, ivx)*rhoi
        wd(i, jb, k, ivy) = wd(i, jb, k, ivy)*rhoi + w(i, jb, k, ivy)*&
&         rhoid
        w(i, jb, k, ivy) = w(i, jb, k, ivy)*rhoi
        wd(i, jb, k, ivz) = wd(i, jb, k, ivz)*rhoi + w(i, jb, k, ivz)*&
&         rhoid
        w(i, jb, k, ivz) = w(i, jb, k, ivz)*rhoi
        wd(i, jb, k, irhoe) = wd(i, jb, k, irhoe) - pd(i, jb, k)
        w(i, jb, k, irhoe) = w(i, jb, k, irhoe) - p(i, jb, k)
      end do
    end do
  end if
end subroutine invisciddissfluxscalarapprox_d

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module utils_d
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
  function tsbeta(degreepolbeta, coefpolbeta, degreefourbeta, &
&   omegafourbeta, coscoeffourbeta, sincoeffourbeta, t)
!
!       tsbeta computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsbeta
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolbeta
    integer(kind=inttype), intent(in) :: degreefourbeta
    real(kind=realtype), intent(in) :: omegafourbeta, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolbeta
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourbeta
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourbeta
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: beta, val
    intrinsic cos
    intrinsic sin
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsbeta = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      beta = coefpolbeta(0)
      do nn=1,degreepolbeta
        pwr1 = t**nn
        beta = beta + coefpolbeta(nn)*pwr1
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      beta = beta + coscoeffourbeta(0)
      do nn=1,degreefourbeta
        val = nn*omegafourbeta*t
        beta = beta + coscoeffourbeta(nn)*cos(val) + sincoeffourbeta(nn)&
&         *sin(val)
      end do
! set tsbeta to phi.
      tsbeta = beta
    end if
  end function tsbeta
  function tsbetadot(degreepolbeta, coefpolbeta, degreefourbeta, &
&   omegafourbeta, coscoeffourbeta, sincoeffourbeta, t)
!
!       tsbeta computes the angle of attack for a given time interval  
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsbetadot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolbeta
    integer(kind=inttype), intent(in) :: degreefourbeta
    real(kind=realtype), intent(in) :: omegafourbeta, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolbeta
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourbeta
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourbeta
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: betadot, val
    intrinsic sin
    intrinsic cos
    integer :: pwy1
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsbetadot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      betadot = zero
      do nn=1,degreepolbeta
        pwy1 = nn - 1
        pwr1 = t**pwy1
        betadot = betadot + nn*coefpolbeta(nn)*pwr1
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefourbeta
        val = nn*omegafourbeta
        betadot = betadot - val*coscoeffourbeta(nn)*sin(val*t) + val*&
&         sincoeffourbeta(nn)*cos(val*t)
      end do
! set tsbeta to phi.
      tsbetadot = betadot
    end if
  end function tsbetadot
  function tsmach(degreepolmach, coefpolmach, degreefourmach, &
&   omegafourmach, coscoeffourmach, sincoeffourmach, t)
!
!       tsmach computes the mach number for a given time interval      
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsmach
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolmach
    integer(kind=inttype), intent(in) :: degreefourmach
    real(kind=realtype), intent(in) :: omegafourmach, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolmach
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourmach
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourmach
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: intervalmach, val
    intrinsic cos
    intrinsic sin
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsmach = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      intervalmach = coefpolmach(0)
      do nn=1,degreepolmach
        pwr1 = t**nn
        intervalmach = intervalmach + coefpolmach(nn)*pwr1
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      intervalmach = intervalmach + coscoeffourmach(0)
      do nn=1,degreefourmach
        val = nn*omegafourmach*t
        intervalmach = intervalmach + coscoeffourmach(nn)*cos(val) + &
&         sincoeffourmach(nn)*sin(val)
      end do
      print*, 'intsmach', intervalmach, nn, val, t
! set tsmach to phi.
      tsmach = intervalmach
    end if
  end function tsmach
  function tsmachdot(degreepolmach, coefpolmach, degreefourmach, &
&   omegafourmach, coscoeffourmach, sincoeffourmach, t)
!
!       tsmach computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsmachdot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolmach
    integer(kind=inttype), intent(in) :: degreefourmach
    real(kind=realtype), intent(in) :: omegafourmach, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolmach
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourmach
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourmach
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: machdot, val
    intrinsic sin
    intrinsic cos
    integer :: pwy1
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsmachdot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      machdot = zero
      do nn=1,degreepolmach
        pwy1 = nn - 1
        pwr1 = t**pwy1
        machdot = machdot + nn*coefpolmach(nn)*pwr1
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefourmach
        val = nn*omegafourmach
        machdot = machdot - val*coscoeffourmach(nn)*sin(val*t) + val*&
&         sincoeffourmach(nn)*cos(val*t)
      end do
! set tsmach to phi.
      tsmachdot = machdot
    end if
  end function tsmachdot
!  differentiation of derivativerigidrotangle in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: derivativerigidrotangle
!   with respect to varying inputs: timeref
  function derivativerigidrotangle_d(degreepolrot, coefpolrot, &
&   degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t, &
&   derivativerigidrotangle)
!
!       derivativerigidrotangle computes the time derivative of the    
!       rigid body rotation angle at the given time for the given      
!       arguments. the angle is described by a combination of a        
!       polynomial and fourier series.                                 
!
    use constants
    use inputphysics, only : equationmode
    use flowvarrefstate, only : timeref, timerefd
    implicit none
!
!      function type
!
    real(kind=realtype) :: derivativerigidrotangle
    real(kind=realtype) :: derivativerigidrotangle_d
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: dphi, val
    intrinsic sin
    intrinsic cos
    integer :: pwy1
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      derivativerigidrotangle = zero
      derivativerigidrotangle_d = 0.0_8
      return
    else
! compute the polynomial contribution.
      dphi = zero
      do nn=1,degreepolrot
        pwy1 = nn - 1
        pwr1 = t**pwy1
        dphi = dphi + nn*coefpolrot(nn)*pwr1
      end do
! compute the fourier contribution.
      do nn=1,degreefourrot
        val = nn*omegafourrot
        dphi = dphi - val*coscoeffourrot(nn)*sin(val*t)
        dphi = dphi + val*sincoeffourrot(nn)*cos(val*t)
      end do
! set derivativerigidrotangle to dphi. multiply by timeref
! to obtain the correct non-dimensional value.
      derivativerigidrotangle_d = dphi*timerefd
      derivativerigidrotangle = timeref*dphi
    end if
  end function derivativerigidrotangle_d
  function derivativerigidrotangle(degreepolrot, coefpolrot, &
&   degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!       derivativerigidrotangle computes the time derivative of the    
!       rigid body rotation angle at the given time for the given      
!       arguments. the angle is described by a combination of a        
!       polynomial and fourier series.                                 
!
    use constants
    use inputphysics, only : equationmode
    use flowvarrefstate, only : timeref
    implicit none
!
!      function type
!
    real(kind=realtype) :: derivativerigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: dphi, val
    intrinsic sin
    intrinsic cos
    integer :: pwy1
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      derivativerigidrotangle = zero
      return
    else
! compute the polynomial contribution.
      dphi = zero
      do nn=1,degreepolrot
        pwy1 = nn - 1
        pwr1 = t**pwy1
        dphi = dphi + nn*coefpolrot(nn)*pwr1
      end do
! compute the fourier contribution.
      do nn=1,degreefourrot
        val = nn*omegafourrot
        dphi = dphi - val*coscoeffourrot(nn)*sin(val*t)
        dphi = dphi + val*sincoeffourrot(nn)*cos(val*t)
      end do
! set derivativerigidrotangle to dphi. multiply by timeref
! to obtain the correct non-dimensional value.
      derivativerigidrotangle = timeref*dphi
    end if
  end function derivativerigidrotangle
!  differentiation of mydim in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: mydim
!   with respect to varying inputs: x y
  function mydim_d(x, xd, y, yd, mydim)
    use constants
    implicit none
    real(kind=realtype) :: x, y
    real(kind=realtype) :: xd, yd
    real(kind=realtype) :: mydim
    real(kind=realtype) :: mydim_d
    mydim_d = xd - yd
    mydim = x - y
    if (mydim .lt. 0.0) then
      mydim = 0.0
      mydim_d = 0.0_8
    end if
  end function mydim_d
  function mydim(x, y)
    use constants
    implicit none
    real(kind=realtype) :: x, y
    real(kind=realtype) :: mydim
    mydim = x - y
    if (mydim .lt. 0.0) mydim = 0.0
  end function mydim
  function getcorrectfork()
    use constants
    use flowvarrefstate, only : kpresent
    use iteration, only : currentlevel, groundlevel
    implicit none
    logical :: getcorrectfork
    if (kpresent .and. currentlevel .le. groundlevel) then
      getcorrectfork = .true.
    else
      getcorrectfork = .false.
    end if
  end function getcorrectfork
  subroutine rotmatrixrigidbody(tnew, told, rotationmatrix, &
&   rotationpoint)
!
!       rotmatrixrigidbody determines the rotation matrix and the      
!       rotation point to determine the coordinates of the new time    
!       level starting from the coordinates of the old time level.     
!
    use constants
    use inputmotion
    use flowvarrefstate, only : lref
    implicit none
!
!      subroutine arguments.
!
    real(kind=realtype), intent(in) :: tnew, told
    real(kind=realtype), dimension(3), intent(out) :: rotationpoint
    real(kind=realtype), dimension(3, 3), intent(out) :: rotationmatrix
!
!      local variables.
!
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: phi
    real(kind=realtype) :: cosx, cosy, cosz, sinx, siny, sinz
    real(kind=realtype), dimension(3, 3) :: mnew, mold
    intrinsic sin
    intrinsic cos
! determine the rotation angle around the x-axis for the new
! time level and the corresponding values of the sine and cosine.
    phi = rigidrotangle(degreepolxrot, coefpolxrot, degreefourxrot, &
&     omegafourxrot, coscoeffourxrot, sincoeffourxrot, tnew)
    sinx = sin(phi)
    cosx = cos(phi)
! idem for the y-axis.
    phi = rigidrotangle(degreepolyrot, coefpolyrot, degreefouryrot, &
&     omegafouryrot, coscoeffouryrot, sincoeffouryrot, tnew)
    siny = sin(phi)
    cosy = cos(phi)
! idem for the z-axis.
    phi = rigidrotangle(degreepolzrot, coefpolzrot, degreefourzrot, &
&     omegafourzrot, coscoeffourzrot, sincoeffourzrot, tnew)
    sinz = sin(phi)
    cosz = cos(phi)
! construct the transformation matrix at the new time level.
! it is assumed that the sequence of rotation is first around the
! x-axis then around the y-axis and finally around the z-axis.
    mnew(1, 1) = cosy*cosz
    mnew(2, 1) = cosy*sinz
    mnew(3, 1) = -siny
    mnew(1, 2) = sinx*siny*cosz - cosx*sinz
    mnew(2, 2) = sinx*siny*sinz + cosx*cosz
    mnew(3, 2) = sinx*cosy
    mnew(1, 3) = cosx*siny*cosz + sinx*sinz
    mnew(2, 3) = cosx*siny*sinz - sinx*cosz
    mnew(3, 3) = cosx*cosy
! determine the rotation angle around the x-axis for the old
! time level and the corresponding values of the sine and cosine.
    phi = rigidrotangle(degreepolxrot, coefpolxrot, degreefourxrot, &
&     omegafourxrot, coscoeffourxrot, sincoeffourxrot, told)
    sinx = sin(phi)
    cosx = cos(phi)
! idem for the y-axis.
    phi = rigidrotangle(degreepolyrot, coefpolyrot, degreefouryrot, &
&     omegafouryrot, coscoeffouryrot, sincoeffouryrot, told)
    siny = sin(phi)
    cosy = cos(phi)
! idem for the z-axis.
    phi = rigidrotangle(degreepolzrot, coefpolzrot, degreefourzrot, &
&     omegafourzrot, coscoeffourzrot, sincoeffourzrot, told)
    sinz = sin(phi)
    cosz = cos(phi)
! construct the transformation matrix at the old time level.
    mold(1, 1) = cosy*cosz
    mold(2, 1) = cosy*sinz
    mold(3, 1) = -siny
    mold(1, 2) = sinx*siny*cosz - cosx*sinz
    mold(2, 2) = sinx*siny*sinz + cosx*cosz
    mold(3, 2) = sinx*cosy
    mold(1, 3) = cosx*siny*cosz + sinx*sinz
    mold(2, 3) = cosx*siny*sinz - sinx*cosz
    mold(3, 3) = cosx*cosy
! construct the transformation matrix between the new and the
! old time level. this is mnew*inverse(mold). however the
! inverse of mold is the transpose.
    do j=1,3
      do i=1,3
        rotationmatrix(i, j) = mnew(i, 1)*mold(j, 1) + mnew(i, 2)*mold(j&
&         , 2) + mnew(i, 3)*mold(j, 3)
      end do
    end do
! determine the rotation point at the old time level; it is
! possible that this value changes due to translation of the grid.
!  ainf = sqrt(gammainf*pinf/rhoinf)
!  rotationpoint(1) = lref*rotpoint(1) &
!                   + machgrid(1)*ainf*told/timeref
!  rotationpoint(2) = lref*rotpoint(2) &
!                   + machgrid(2)*ainf*told/timeref
!  rotationpoint(3) = lref*rotpoint(3) &
!                   + machgrid(3)*ainf*told/timeref
    rotationpoint(1) = lref*rotpoint(1)
    rotationpoint(2) = lref*rotpoint(2)
    rotationpoint(3) = lref*rotpoint(3)
  end subroutine rotmatrixrigidbody
  function secondderivativerigidrotangle(degreepolrot, coefpolrot, &
&   degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!       2ndderivativerigidrotangle computes the 2nd time derivative of 
!       the rigid body rotation angle at the given time for the given  
!       arguments. the angle is described by a combination of a        
!       polynomial and fourier series.                                 
!
    use constants
    use flowvarrefstate, only : timeref
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: secondderivativerigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: dphi, val
    intrinsic sin
    intrinsic cos
    integer :: pwy1
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      secondderivativerigidrotangle = zero
      return
    else
! compute the polynomial contribution.
      dphi = zero
      do nn=2,degreepolrot
        pwy1 = nn - 2
        pwr1 = t**pwy1
        dphi = dphi + (nn-1)*nn*coefpolrot(nn)*pwr1
      end do
! compute the fourier contribution.
      do nn=1,degreefourrot
        val = nn*omegafourrot
        dphi = dphi - val**2*sincoeffourrot(nn)*sin(val*t)
        dphi = dphi - val**2*coscoeffourrot(nn)*cos(val*t)
      end do
! set derivativerigidrotangle to dphi. multiply by timeref
! to obtain the correct non-dimensional value.
      secondderivativerigidrotangle = timeref**2*dphi
    end if
  end function secondderivativerigidrotangle
  function rigidrotangle(degreepolrot, coefpolrot, degreefourrot, &
&   omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!       rigidrotangle computes the rigid body rotation angle at the    
!       given time for the given arguments. the angle is described by  
!       a combination of a polynomial and fourier series.              
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: rigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: phi, val
    intrinsic cos
    intrinsic sin
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      rigidrotangle = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      phi = coefpolrot(0)
      do nn=1,degreepolrot
        pwr1 = t**nn
        phi = phi + coefpolrot(nn)*pwr1
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      phi = phi + coscoeffourrot(0)
      do nn=1,degreefourrot
        val = nn*omegafourrot*t
        phi = phi + coscoeffourrot(nn)*cos(val) + sincoeffourrot(nn)*sin&
&         (val)
      end do
! set rigidrotangle to phi.
      rigidrotangle = phi
    end if
  end function rigidrotangle
!  differentiation of setbcpointers in forward (tangent) mode (with options i4 dr8 r8):
!   plus diff mem management of: rev:in p:in sfacei:in sfacej:in
!                s:in sfacek:in w:in rlv:in x:in si:in sj:in sk:in
!                bcdata:in xx:in-out rev0:in-out rev1:in-out rev2:in-out
!                rev3:in-out pp0:in-out pp1:in-out pp2:in-out pp3:in-out
!                rlv0:in-out rlv1:in-out rlv2:in-out rlv3:in-out
!                ss:in-out ssi:in-out ssj:in-out ssk:in-out ww0:in-out
!                ww1:in-out ww2:in-out ww3:in-out
  subroutine setbcpointers_d(nn, spatialpointers)
!
!       setbcpointers sets the pointers needed for the boundary        
!       condition treatment on a general face, such that the boundary  
!       routines are only implemented once instead of 6 times.         
!
    use constants
    use blockpointers, only : w, wd, p, pd, rlv, rlvd, rev, revd, &
&   gamma, x, xd, d2wall, si, sid, sj, sjd, sk, skd, s, sd, globalcell, &
&   bcdata, bcdatad, nx, il, ie, ib, ny, jl, je, jb, nz, kl, ke, kb, &
&   bcfaceid, addgridvelocities, sfacei, sfaceid, sfacej, sfacejd, &
&   sfacek, sfacekd, addgridvelocities
    use bcpointers_d, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, ww3, ww3d,&
&   pp0, pp0d, pp1, pp1d, pp2, pp2d, pp3, pp3d, rlv0, rlv0d, rlv1, rlv1d&
&   , rlv2, rlv2d, rlv3, rlv3d, rev0, rev0d, rev1, rev1d, rev2, rev2d, &
&   rev3, rev3d, gamma0, gamma1, gamma2, gamma3, gcp, xx, xxd, ss, ssd, &
&   ssi, ssid, ssj, ssjd, ssk, sskd, dd2wall, sface, istart, iend, &
&   jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!---------------------------------------------------------------------------
      ww3d => wd(3, 1:, 1:, :)
      ww3 => w(3, 1:, 1:, :)
      ww2d => wd(2, 1:, 1:, :)
      ww2 => w(2, 1:, 1:, :)
      ww1d => wd(1, 1:, 1:, :)
      ww1 => w(1, 1:, 1:, :)
      ww0d => wd(0, 1:, 1:, :)
      ww0 => w(0, 1:, 1:, :)
      pp3d => pd(3, 1:, 1:)
      pp3 => p(3, 1:, 1:)
      pp2d => pd(2, 1:, 1:)
      pp2 => p(2, 1:, 1:)
      pp1d => pd(1, 1:, 1:)
      pp1 => p(1, 1:, 1:)
      pp0d => pd(0, 1:, 1:)
      pp0 => p(0, 1:, 1:)
      rlv3d => rlvd(3, 1:, 1:)
      rlv3 => rlv(3, 1:, 1:)
      rlv2d => rlvd(2, 1:, 1:)
      rlv2 => rlv(2, 1:, 1:)
      rlv1d => rlvd(1, 1:, 1:)
      rlv1 => rlv(1, 1:, 1:)
      rlv0d => rlvd(0, 1:, 1:)
      rlv0 => rlv(0, 1:, 1:)
      rev3d => revd(3, 1:, 1:)
      rev3 => rev(3, 1:, 1:)
      rev2d => revd(2, 1:, 1:)
      rev2 => rev(2, 1:, 1:)
      rev1d => revd(1, 1:, 1:)
      rev1 => rev(1, 1:, 1:)
      rev0d => revd(0, 1:, 1:)
      rev0 => rev(0, 1:, 1:)
      gamma3 => gamma(3, 1:, 1:)
      gamma2 => gamma(2, 1:, 1:)
      gamma1 => gamma(1, 1:, 1:)
      gamma0 => gamma(0, 1:, 1:)
      gcp => globalcell(2, 1:, 1:)
    case (imax) 
!---------------------------------------------------------------------------
      ww3d => wd(nx, 1:, 1:, :)
      ww3 => w(nx, 1:, 1:, :)
      ww2d => wd(il, 1:, 1:, :)
      ww2 => w(il, 1:, 1:, :)
      ww1d => wd(ie, 1:, 1:, :)
      ww1 => w(ie, 1:, 1:, :)
      ww0d => wd(ib, 1:, 1:, :)
      ww0 => w(ib, 1:, 1:, :)
      pp3d => pd(nx, 1:, 1:)
      pp3 => p(nx, 1:, 1:)
      pp2d => pd(il, 1:, 1:)
      pp2 => p(il, 1:, 1:)
      pp1d => pd(ie, 1:, 1:)
      pp1 => p(ie, 1:, 1:)
      pp0d => pd(ib, 1:, 1:)
      pp0 => p(ib, 1:, 1:)
      rlv3d => rlvd(nx, 1:, 1:)
      rlv3 => rlv(nx, 1:, 1:)
      rlv2d => rlvd(il, 1:, 1:)
      rlv2 => rlv(il, 1:, 1:)
      rlv1d => rlvd(ie, 1:, 1:)
      rlv1 => rlv(ie, 1:, 1:)
      rlv0d => rlvd(ib, 1:, 1:)
      rlv0 => rlv(ib, 1:, 1:)
      rev3d => revd(nx, 1:, 1:)
      rev3 => rev(nx, 1:, 1:)
      rev2d => revd(il, 1:, 1:)
      rev2 => rev(il, 1:, 1:)
      rev1d => revd(ie, 1:, 1:)
      rev1 => rev(ie, 1:, 1:)
      rev0d => revd(ib, 1:, 1:)
      rev0 => rev(ib, 1:, 1:)
      gamma3 => gamma(nx, 1:, 1:)
      gamma2 => gamma(il, 1:, 1:)
      gamma1 => gamma(ie, 1:, 1:)
      gamma0 => gamma(ib, 1:, 1:)
      gcp => globalcell(il, 1:, 1:)
    case (jmin) 
!---------------------------------------------------------------------------
      ww3d => wd(1:, 3, 1:, :)
      ww3 => w(1:, 3, 1:, :)
      ww2d => wd(1:, 2, 1:, :)
      ww2 => w(1:, 2, 1:, :)
      ww1d => wd(1:, 1, 1:, :)
      ww1 => w(1:, 1, 1:, :)
      ww0d => wd(1:, 0, 1:, :)
      ww0 => w(1:, 0, 1:, :)
      pp3d => pd(1:, 3, 1:)
      pp3 => p(1:, 3, 1:)
      pp2d => pd(1:, 2, 1:)
      pp2 => p(1:, 2, 1:)
      pp1d => pd(1:, 1, 1:)
      pp1 => p(1:, 1, 1:)
      pp0d => pd(1:, 0, 1:)
      pp0 => p(1:, 0, 1:)
      rlv3d => rlvd(1:, 3, 1:)
      rlv3 => rlv(1:, 3, 1:)
      rlv2d => rlvd(1:, 2, 1:)
      rlv2 => rlv(1:, 2, 1:)
      rlv1d => rlvd(1:, 1, 1:)
      rlv1 => rlv(1:, 1, 1:)
      rlv0d => rlvd(1:, 0, 1:)
      rlv0 => rlv(1:, 0, 1:)
      rev3d => revd(1:, 3, 1:)
      rev3 => rev(1:, 3, 1:)
      rev2d => revd(1:, 2, 1:)
      rev2 => rev(1:, 2, 1:)
      rev1d => revd(1:, 1, 1:)
      rev1 => rev(1:, 1, 1:)
      rev0d => revd(1:, 0, 1:)
      rev0 => rev(1:, 0, 1:)
      gamma3 => gamma(1:, 3, 1:)
      gamma2 => gamma(1:, 2, 1:)
      gamma1 => gamma(1:, 1, 1:)
      gamma0 => gamma(1:, 0, 1:)
      gcp => globalcell(1:, 2, 1:)
    case (jmax) 
!---------------------------------------------------------------------------
      ww3d => wd(1:, ny, 1:, :)
      ww3 => w(1:, ny, 1:, :)
      ww2d => wd(1:, jl, 1:, :)
      ww2 => w(1:, jl, 1:, :)
      ww1d => wd(1:, je, 1:, :)
      ww1 => w(1:, je, 1:, :)
      ww0d => wd(1:, jb, 1:, :)
      ww0 => w(1:, jb, 1:, :)
      pp3d => pd(1:, ny, 1:)
      pp3 => p(1:, ny, 1:)
      pp2d => pd(1:, jl, 1:)
      pp2 => p(1:, jl, 1:)
      pp1d => pd(1:, je, 1:)
      pp1 => p(1:, je, 1:)
      pp0d => pd(1:, jb, 1:)
      pp0 => p(1:, jb, 1:)
      rlv3d => rlvd(1:, ny, 1:)
      rlv3 => rlv(1:, ny, 1:)
      rlv2d => rlvd(1:, jl, 1:)
      rlv2 => rlv(1:, jl, 1:)
      rlv1d => rlvd(1:, je, 1:)
      rlv1 => rlv(1:, je, 1:)
      rlv0d => rlvd(1:, jb, 1:)
      rlv0 => rlv(1:, jb, 1:)
      rev3d => revd(1:, ny, 1:)
      rev3 => rev(1:, ny, 1:)
      rev2d => revd(1:, jl, 1:)
      rev2 => rev(1:, jl, 1:)
      rev1d => revd(1:, je, 1:)
      rev1 => rev(1:, je, 1:)
      rev0d => revd(1:, jb, 1:)
      rev0 => rev(1:, jb, 1:)
      gamma3 => gamma(1:, ny, 1:)
      gamma2 => gamma(1:, jl, 1:)
      gamma1 => gamma(1:, je, 1:)
      gamma0 => gamma(1:, jb, 1:)
      gcp => globalcell(1:, jl, 1:)
    case (kmin) 
!---------------------------------------------------------------------------
      ww3d => wd(1:, 1:, 3, :)
      ww3 => w(1:, 1:, 3, :)
      ww2d => wd(1:, 1:, 2, :)
      ww2 => w(1:, 1:, 2, :)
      ww1d => wd(1:, 1:, 1, :)
      ww1 => w(1:, 1:, 1, :)
      ww0d => wd(1:, 1:, 0, :)
      ww0 => w(1:, 1:, 0, :)
      pp3d => pd(1:, 1:, 3)
      pp3 => p(1:, 1:, 3)
      pp2d => pd(1:, 1:, 2)
      pp2 => p(1:, 1:, 2)
      pp1d => pd(1:, 1:, 1)
      pp1 => p(1:, 1:, 1)
      pp0d => pd(1:, 1:, 0)
      pp0 => p(1:, 1:, 0)
      rlv3d => rlvd(1:, 1:, 3)
      rlv3 => rlv(1:, 1:, 3)
      rlv2d => rlvd(1:, 1:, 2)
      rlv2 => rlv(1:, 1:, 2)
      rlv1d => rlvd(1:, 1:, 1)
      rlv1 => rlv(1:, 1:, 1)
      rlv0d => rlvd(1:, 1:, 0)
      rlv0 => rlv(1:, 1:, 0)
      rev3d => revd(1:, 1:, 3)
      rev3 => rev(1:, 1:, 3)
      rev2d => revd(1:, 1:, 2)
      rev2 => rev(1:, 1:, 2)
      rev1d => revd(1:, 1:, 1)
      rev1 => rev(1:, 1:, 1)
      rev0d => revd(1:, 1:, 0)
      rev0 => rev(1:, 1:, 0)
      gamma3 => gamma(1:, 1:, 3)
      gamma2 => gamma(1:, 1:, 2)
      gamma1 => gamma(1:, 1:, 1)
      gamma0 => gamma(1:, 1:, 0)
      gcp => globalcell(1:, 1:, 2)
    case (kmax) 
!---------------------------------------------------------------------------
      ww3d => wd(1:, 1:, nz, :)
      ww3 => w(1:, 1:, nz, :)
      ww2d => wd(1:, 1:, kl, :)
      ww2 => w(1:, 1:, kl, :)
      ww1d => wd(1:, 1:, ke, :)
      ww1 => w(1:, 1:, ke, :)
      ww0d => wd(1:, 1:, kb, :)
      ww0 => w(1:, 1:, kb, :)
      pp3d => pd(1:, 1:, nz)
      pp3 => p(1:, 1:, nz)
      pp2d => pd(1:, 1:, kl)
      pp2 => p(1:, 1:, kl)
      pp1d => pd(1:, 1:, ke)
      pp1 => p(1:, 1:, ke)
      pp0d => pd(1:, 1:, kb)
      pp0 => p(1:, 1:, kb)
      rlv3d => rlvd(1:, 1:, nz)
      rlv3 => rlv(1:, 1:, nz)
      rlv2d => rlvd(1:, 1:, kl)
      rlv2 => rlv(1:, 1:, kl)
      rlv1d => rlvd(1:, 1:, ke)
      rlv1 => rlv(1:, 1:, ke)
      rlv0d => rlvd(1:, 1:, kb)
      rlv0 => rlv(1:, 1:, kb)
      rev3d => revd(1:, 1:, nz)
      rev3 => rev(1:, 1:, nz)
      rev2d => revd(1:, 1:, kl)
      rev2 => rev(1:, 1:, kl)
      rev1d => revd(1:, 1:, ke)
      rev1 => rev(1:, 1:, ke)
      rev0d => revd(1:, 1:, kb)
      rev0 => rev(1:, 1:, kb)
      gamma3 => gamma(1:, 1:, nz)
      gamma2 => gamma(1:, 1:, kl)
      gamma1 => gamma(1:, 1:, ke)
      gamma0 => gamma(1:, 1:, kb)
      gcp => globalcell(1:, 1:, kl)
    end select
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xxd => xd(1, :, :, :)
        xx => x(1, :, :, :)
        ssid => sid(1, :, :, :)
        ssi => si(1, :, :, :)
        ssjd => sjd(2, :, :, :)
        ssj => sj(2, :, :, :)
        sskd => skd(2, :, :, :)
        ssk => sk(2, :, :, :)
        ssd => sd(2, :, :, :)
        ss => s(2, :, :, :)
      case (imax) 
        xxd => xd(il, :, :, :)
        xx => x(il, :, :, :)
        ssid => sid(il, :, :, :)
        ssi => si(il, :, :, :)
        ssjd => sjd(il, :, :, :)
        ssj => sj(il, :, :, :)
        sskd => skd(il, :, :, :)
        ssk => sk(il, :, :, :)
        ssd => sd(il, :, :, :)
        ss => s(il, :, :, :)
      case (jmin) 
        xxd => xd(:, 1, :, :)
        xx => x(:, 1, :, :)
        ssid => sjd(:, 1, :, :)
        ssi => sj(:, 1, :, :)
        ssjd => sid(:, 2, :, :)
        ssj => si(:, 2, :, :)
        sskd => skd(:, 2, :, :)
        ssk => sk(:, 2, :, :)
        ssd => sd(:, 2, :, :)
        ss => s(:, 2, :, :)
      case (jmax) 
        xxd => xd(:, jl, :, :)
        xx => x(:, jl, :, :)
        ssid => sjd(:, jl, :, :)
        ssi => sj(:, jl, :, :)
        ssjd => sid(:, jl, :, :)
        ssj => si(:, jl, :, :)
        sskd => skd(:, jl, :, :)
        ssk => sk(:, jl, :, :)
        ssd => sd(:, jl, :, :)
        ss => s(:, jl, :, :)
      case (kmin) 
        xxd => xd(:, :, 1, :)
        xx => x(:, :, 1, :)
        ssid => skd(:, :, 1, :)
        ssi => sk(:, :, 1, :)
        ssjd => sid(:, :, 2, :)
        ssj => si(:, :, 2, :)
        sskd => sjd(:, :, 2, :)
        ssk => sj(:, :, 2, :)
        ssd => sd(:, :, 2, :)
        ss => s(:, :, 2, :)
      case (kmax) 
        xxd => xd(:, :, kl, :)
        xx => x(:, :, kl, :)
        ssid => skd(:, :, kl, :)
        ssi => sk(:, :, kl, :)
        ssjd => sid(:, :, kl, :)
        ssj => si(:, :, kl, :)
        sskd => sjd(:, :, kl, :)
        ssk => sj(:, :, kl, :)
        ssd => sd(:, :, kl, :)
        ss => s(:, :, kl, :)
      end select
      if (addgridvelocities) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          sface => sfacei(1, :, :)
        case (imax) 
          sface => sfacei(il, :, :)
        case (jmin) 
          sface => sfacej(:, 1, :)
        case (jmax) 
          sface => sfacej(:, jl, :)
        case (kmin) 
          sface => sfacek(:, :, 1)
        case (kmax) 
          sface => sfacek(:, :, kl)
        end select
      end if
      if (equations .eq. ransequations) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          dd2wall => d2wall(2, :, :)
        case (imax) 
          dd2wall => d2wall(il, :, :)
        case (jmin) 
          dd2wall => d2wall(:, 2, :)
        case (jmax) 
          dd2wall => d2wall(:, jl, :)
        case (kmin) 
          dd2wall => d2wall(:, :, 2)
        case (kmax) 
          dd2wall => d2wall(:, :, kl)
        end select
      end if
    end if
  end subroutine setbcpointers_d
  subroutine setbcpointers(nn, spatialpointers)
!
!       setbcpointers sets the pointers needed for the boundary        
!       condition treatment on a general face, such that the boundary  
!       routines are only implemented once instead of 6 times.         
!
    use constants
    use blockpointers, only : w, p, rlv, rev, gamma, x, d2wall, si, sj&
&   , sk, s, globalcell, bcdata, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid, addgridvelocities, sfacei, sfacej, sfacek, &
&   addgridvelocities
    use bcpointers_d, only : ww0, ww1, ww2, ww3, pp0, pp1, pp2, pp3, &
&   rlv0, rlv1, rlv2, rlv3, rev0, rev1, rev2, rev3, gamma0, gamma1, &
&   gamma2, gamma3, gcp, xx, ss, ssi, ssj, ssk, dd2wall, sface, istart, &
&   iend, jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!---------------------------------------------------------------------------
      ww3 => w(3, 1:, 1:, :)
      ww2 => w(2, 1:, 1:, :)
      ww1 => w(1, 1:, 1:, :)
      ww0 => w(0, 1:, 1:, :)
      pp3 => p(3, 1:, 1:)
      pp2 => p(2, 1:, 1:)
      pp1 => p(1, 1:, 1:)
      pp0 => p(0, 1:, 1:)
      rlv3 => rlv(3, 1:, 1:)
      rlv2 => rlv(2, 1:, 1:)
      rlv1 => rlv(1, 1:, 1:)
      rlv0 => rlv(0, 1:, 1:)
      rev3 => rev(3, 1:, 1:)
      rev2 => rev(2, 1:, 1:)
      rev1 => rev(1, 1:, 1:)
      rev0 => rev(0, 1:, 1:)
      gamma3 => gamma(3, 1:, 1:)
      gamma2 => gamma(2, 1:, 1:)
      gamma1 => gamma(1, 1:, 1:)
      gamma0 => gamma(0, 1:, 1:)
      gcp => globalcell(2, 1:, 1:)
    case (imax) 
!---------------------------------------------------------------------------
      ww3 => w(nx, 1:, 1:, :)
      ww2 => w(il, 1:, 1:, :)
      ww1 => w(ie, 1:, 1:, :)
      ww0 => w(ib, 1:, 1:, :)
      pp3 => p(nx, 1:, 1:)
      pp2 => p(il, 1:, 1:)
      pp1 => p(ie, 1:, 1:)
      pp0 => p(ib, 1:, 1:)
      rlv3 => rlv(nx, 1:, 1:)
      rlv2 => rlv(il, 1:, 1:)
      rlv1 => rlv(ie, 1:, 1:)
      rlv0 => rlv(ib, 1:, 1:)
      rev3 => rev(nx, 1:, 1:)
      rev2 => rev(il, 1:, 1:)
      rev1 => rev(ie, 1:, 1:)
      rev0 => rev(ib, 1:, 1:)
      gamma3 => gamma(nx, 1:, 1:)
      gamma2 => gamma(il, 1:, 1:)
      gamma1 => gamma(ie, 1:, 1:)
      gamma0 => gamma(ib, 1:, 1:)
      gcp => globalcell(il, 1:, 1:)
    case (jmin) 
!---------------------------------------------------------------------------
      ww3 => w(1:, 3, 1:, :)
      ww2 => w(1:, 2, 1:, :)
      ww1 => w(1:, 1, 1:, :)
      ww0 => w(1:, 0, 1:, :)
      pp3 => p(1:, 3, 1:)
      pp2 => p(1:, 2, 1:)
      pp1 => p(1:, 1, 1:)
      pp0 => p(1:, 0, 1:)
      rlv3 => rlv(1:, 3, 1:)
      rlv2 => rlv(1:, 2, 1:)
      rlv1 => rlv(1:, 1, 1:)
      rlv0 => rlv(1:, 0, 1:)
      rev3 => rev(1:, 3, 1:)
      rev2 => rev(1:, 2, 1:)
      rev1 => rev(1:, 1, 1:)
      rev0 => rev(1:, 0, 1:)
      gamma3 => gamma(1:, 3, 1:)
      gamma2 => gamma(1:, 2, 1:)
      gamma1 => gamma(1:, 1, 1:)
      gamma0 => gamma(1:, 0, 1:)
      gcp => globalcell(1:, 2, 1:)
    case (jmax) 
!---------------------------------------------------------------------------
      ww3 => w(1:, ny, 1:, :)
      ww2 => w(1:, jl, 1:, :)
      ww1 => w(1:, je, 1:, :)
      ww0 => w(1:, jb, 1:, :)
      pp3 => p(1:, ny, 1:)
      pp2 => p(1:, jl, 1:)
      pp1 => p(1:, je, 1:)
      pp0 => p(1:, jb, 1:)
      rlv3 => rlv(1:, ny, 1:)
      rlv2 => rlv(1:, jl, 1:)
      rlv1 => rlv(1:, je, 1:)
      rlv0 => rlv(1:, jb, 1:)
      rev3 => rev(1:, ny, 1:)
      rev2 => rev(1:, jl, 1:)
      rev1 => rev(1:, je, 1:)
      rev0 => rev(1:, jb, 1:)
      gamma3 => gamma(1:, ny, 1:)
      gamma2 => gamma(1:, jl, 1:)
      gamma1 => gamma(1:, je, 1:)
      gamma0 => gamma(1:, jb, 1:)
      gcp => globalcell(1:, jl, 1:)
    case (kmin) 
!---------------------------------------------------------------------------
      ww3 => w(1:, 1:, 3, :)
      ww2 => w(1:, 1:, 2, :)
      ww1 => w(1:, 1:, 1, :)
      ww0 => w(1:, 1:, 0, :)
      pp3 => p(1:, 1:, 3)
      pp2 => p(1:, 1:, 2)
      pp1 => p(1:, 1:, 1)
      pp0 => p(1:, 1:, 0)
      rlv3 => rlv(1:, 1:, 3)
      rlv2 => rlv(1:, 1:, 2)
      rlv1 => rlv(1:, 1:, 1)
      rlv0 => rlv(1:, 1:, 0)
      rev3 => rev(1:, 1:, 3)
      rev2 => rev(1:, 1:, 2)
      rev1 => rev(1:, 1:, 1)
      rev0 => rev(1:, 1:, 0)
      gamma3 => gamma(1:, 1:, 3)
      gamma2 => gamma(1:, 1:, 2)
      gamma1 => gamma(1:, 1:, 1)
      gamma0 => gamma(1:, 1:, 0)
      gcp => globalcell(1:, 1:, 2)
    case (kmax) 
!---------------------------------------------------------------------------
      ww3 => w(1:, 1:, nz, :)
      ww2 => w(1:, 1:, kl, :)
      ww1 => w(1:, 1:, ke, :)
      ww0 => w(1:, 1:, kb, :)
      pp3 => p(1:, 1:, nz)
      pp2 => p(1:, 1:, kl)
      pp1 => p(1:, 1:, ke)
      pp0 => p(1:, 1:, kb)
      rlv3 => rlv(1:, 1:, nz)
      rlv2 => rlv(1:, 1:, kl)
      rlv1 => rlv(1:, 1:, ke)
      rlv0 => rlv(1:, 1:, kb)
      rev3 => rev(1:, 1:, nz)
      rev2 => rev(1:, 1:, kl)
      rev1 => rev(1:, 1:, ke)
      rev0 => rev(1:, 1:, kb)
      gamma3 => gamma(1:, 1:, nz)
      gamma2 => gamma(1:, 1:, kl)
      gamma1 => gamma(1:, 1:, ke)
      gamma0 => gamma(1:, 1:, kb)
      gcp => globalcell(1:, 1:, kl)
    end select
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xx => x(1, :, :, :)
        ssi => si(1, :, :, :)
        ssj => sj(2, :, :, :)
        ssk => sk(2, :, :, :)
        ss => s(2, :, :, :)
      case (imax) 
        xx => x(il, :, :, :)
        ssi => si(il, :, :, :)
        ssj => sj(il, :, :, :)
        ssk => sk(il, :, :, :)
        ss => s(il, :, :, :)
      case (jmin) 
        xx => x(:, 1, :, :)
        ssi => sj(:, 1, :, :)
        ssj => si(:, 2, :, :)
        ssk => sk(:, 2, :, :)
        ss => s(:, 2, :, :)
      case (jmax) 
        xx => x(:, jl, :, :)
        ssi => sj(:, jl, :, :)
        ssj => si(:, jl, :, :)
        ssk => sk(:, jl, :, :)
        ss => s(:, jl, :, :)
      case (kmin) 
        xx => x(:, :, 1, :)
        ssi => sk(:, :, 1, :)
        ssj => si(:, :, 2, :)
        ssk => sj(:, :, 2, :)
        ss => s(:, :, 2, :)
      case (kmax) 
        xx => x(:, :, kl, :)
        ssi => sk(:, :, kl, :)
        ssj => si(:, :, kl, :)
        ssk => sj(:, :, kl, :)
        ss => s(:, :, kl, :)
      end select
      if (addgridvelocities) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          sface => sfacei(1, :, :)
        case (imax) 
          sface => sfacei(il, :, :)
        case (jmin) 
          sface => sfacej(:, 1, :)
        case (jmax) 
          sface => sfacej(:, jl, :)
        case (kmin) 
          sface => sfacek(:, :, 1)
        case (kmax) 
          sface => sfacek(:, :, kl)
        end select
      end if
      if (equations .eq. ransequations) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          dd2wall => d2wall(2, :, :)
        case (imax) 
          dd2wall => d2wall(il, :, :)
        case (jmin) 
          dd2wall => d2wall(:, 2, :)
        case (jmax) 
          dd2wall => d2wall(:, jl, :)
        case (kmin) 
          dd2wall => d2wall(:, :, 2)
        case (kmax) 
          dd2wall => d2wall(:, :, kl)
        end select
      end if
    end if
  end subroutine setbcpointers
  subroutine resetbcpointers(nn, spatialpointers)
!
!       resetbcpointers nullifyies the boundary pointers. for reverse  
!       mode ad it copies the values back in to the respective arrays  
!
    use constants
    use blockpointers, only : w, p, rlv, rev, gamma, x, d2wall, si, sj&
&   , sk, s, globalcell, bcdata, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid, sfacei, sfacej, sfacek, addgridvelocities
    use bcpointers_d, only : ww0, ww1, ww2, ww3, pp0, pp1, pp2, pp3, &
&   rlv0, rlv1, rlv2, rlv3, rev0, rev1, rev2, rev3, gamma0, gamma1, &
&   gamma2, gamma3, gcp, xx, ss, ssi, ssj, ssk, dd2wall, istart, iend, &
&   jstart, jend, isize, jsize, sface
    use inputphysics, only : cpmodel, equations
    implicit none
! for forward mode we are using pointers so we just don't do
! anything.
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
  end subroutine resetbcpointers
!  differentiation of computerootbendingmoment in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: bendingmoment
!   with respect to varying inputs: lengthref pointref cf cm
  subroutine computerootbendingmoment_d(cf, cfd, cm, cmd, liftindex, &
&   bendingmoment, bendingmomentd)
!                                                      *
! compute a normalized bending moment coefficient from *
! the force and moment coefficient. at the moment this *
! routine only works for a half body. additional logic *
! would be needed for a full body.                     *
!                                                      *
    use constants
    use inputphysics, only : lengthref, lengthrefd, pointref, &
&   pointrefd, pointrefec
    implicit none
!input/output variables
    real(kind=realtype), dimension(3), intent(in) :: cf, cm
    real(kind=realtype), dimension(3), intent(in) :: cfd, cmd
    integer(kind=inttype), intent(in) :: liftindex
    real(kind=realtype), intent(out) :: bendingmoment
    real(kind=realtype), intent(out) :: bendingmomentd
!subroutine variables
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    real(kind=realtype) :: elasticmomentxd, elasticmomentyd, &
&   elasticmomentzd
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    bendingmoment = zero
    if (liftindex .eq. 2) then
!z out wing sum momentx,momentz
      elasticmomentxd = cmd(1) + ((cfd(2)*(pointrefec(3)-pointref(3))-cf&
&       (2)*pointrefd(3))*lengthref-cf(2)*(pointrefec(3)-pointref(3))*&
&       lengthrefd)/lengthref**2 - ((cfd(3)*(pointrefec(2)-pointref(2))-&
&       cf(3)*pointrefd(2))*lengthref-cf(3)*(pointrefec(2)-pointref(2))*&
&       lengthrefd)/lengthref**2
      elasticmomentx = cm(1) + cf(2)*(pointrefec(3)-pointref(3))/&
&       lengthref - cf(3)*(pointrefec(2)-pointref(2))/lengthref
      elasticmomentzd = cmd(3) - ((cfd(2)*(pointrefec(1)-pointref(1))-cf&
&       (2)*pointrefd(1))*lengthref-cf(2)*(pointrefec(1)-pointref(1))*&
&       lengthrefd)/lengthref**2 + ((cfd(1)*(pointrefec(2)-pointref(2))-&
&       cf(1)*pointrefd(2))*lengthref-cf(1)*(pointrefec(2)-pointref(2))*&
&       lengthrefd)/lengthref**2
      elasticmomentz = cm(3) - cf(2)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(2)-pointref(2))/lengthref
      arg1d = 2*elasticmomentx*elasticmomentxd + 2*elasticmomentz*&
&       elasticmomentzd
      arg1 = elasticmomentx**2 + elasticmomentz**2
      if (arg1 .eq. 0.0_8) then
        bendingmomentd = 0.0_8
      else
        bendingmomentd = arg1d/(2.0*sqrt(arg1))
      end if
      bendingmoment = sqrt(arg1)
    else if (liftindex .eq. 3) then
!y out wing sum momentx,momenty
      elasticmomentxd = cmd(1) + ((cfd(3)*(pointrefec(2)-pointref(2))-cf&
&       (3)*pointrefd(2))*lengthref-cf(3)*(pointrefec(2)-pointref(2))*&
&       lengthrefd)/lengthref**2 + ((cfd(3)*(pointrefec(3)-pointref(3))-&
&       cf(3)*pointrefd(3))*lengthref-cf(3)*(pointrefec(3)-pointref(3))*&
&       lengthrefd)/lengthref**2
      elasticmomentx = cm(1) + cf(3)*(pointrefec(2)-pointref(2))/&
&       lengthref + cf(3)*(pointrefec(3)-pointref(3))/lengthref
      elasticmomentyd = cmd(2) + ((cfd(3)*(pointrefec(1)-pointref(1))-cf&
&       (3)*pointrefd(1))*lengthref-cf(3)*(pointrefec(1)-pointref(1))*&
&       lengthrefd)/lengthref**2 + ((cfd(1)*(pointrefec(3)-pointref(3))-&
&       cf(1)*pointrefd(3))*lengthref-cf(1)*(pointrefec(3)-pointref(3))*&
&       lengthrefd)/lengthref**2
      elasticmomenty = cm(2) + cf(3)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(3)-pointref(3))/lengthref
      arg1d = 2*elasticmomentx*elasticmomentxd + 2*elasticmomenty*&
&       elasticmomentyd
      arg1 = elasticmomentx**2 + elasticmomenty**2
      if (arg1 .eq. 0.0_8) then
        bendingmomentd = 0.0_8
      else
        bendingmomentd = arg1d/(2.0*sqrt(arg1))
      end if
      bendingmoment = sqrt(arg1)
    else
      bendingmomentd = 0.0_8
    end if
  end subroutine computerootbendingmoment_d
  subroutine computerootbendingmoment(cf, cm, liftindex, bendingmoment)
!                                                      *
! compute a normalized bending moment coefficient from *
! the force and moment coefficient. at the moment this *
! routine only works for a half body. additional logic *
! would be needed for a full body.                     *
!                                                      *
    use constants
    use inputphysics, only : lengthref, pointref, pointrefec
    implicit none
!input/output variables
    real(kind=realtype), dimension(3), intent(in) :: cf, cm
    integer(kind=inttype), intent(in) :: liftindex
    real(kind=realtype), intent(out) :: bendingmoment
!subroutine variables
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    intrinsic sqrt
    real(kind=realtype) :: arg1
    bendingmoment = zero
    if (liftindex .eq. 2) then
!z out wing sum momentx,momentz
      elasticmomentx = cm(1) + cf(2)*(pointrefec(3)-pointref(3))/&
&       lengthref - cf(3)*(pointrefec(2)-pointref(2))/lengthref
      elasticmomentz = cm(3) - cf(2)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(2)-pointref(2))/lengthref
      arg1 = elasticmomentx**2 + elasticmomentz**2
      bendingmoment = sqrt(arg1)
    else if (liftindex .eq. 3) then
!y out wing sum momentx,momenty
      elasticmomentx = cm(1) + cf(3)*(pointrefec(2)-pointref(2))/&
&       lengthref + cf(3)*(pointrefec(3)-pointref(3))/lengthref
      elasticmomenty = cm(2) + cf(3)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(3)-pointref(3))/lengthref
      arg1 = elasticmomentx**2 + elasticmomenty**2
      bendingmoment = sqrt(arg1)
    end if
  end subroutine computerootbendingmoment
!  differentiation of computetsderivatives in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: dcdalphadot coef0 dcdalpha
!   with respect to varying inputs: machgrid lengthref machcoef
!                dragdirection liftdirection gammainf pinf rhoinfdim
!                pinfdim pref moment force
  subroutine computetsderivatives_d(force, forced, moment, momentd, &
&   liftindex, coef0, coef0d, dcdalpha, dcdalphad, dcdalphadot, &
&   dcdalphadotd, dcdq, dcdqdot)
!
!      computes the stability derivatives based on the time spectral  
!      solution of a given mesh. takes in the force coefficients at   
!      all time instantces and computes the agregate parameters       
!
    use constants
    use communication
    use inputphysics
    use inputtimespectral
    use inputtsstabderiv
    use flowvarrefstate
    use monitor
    use section
    use inputmotion
    implicit none
!
!     subroutine arguments.
!
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced&
&   , momentd
    real(kind=realtype), dimension(8) :: dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
    real(kind=realtype), dimension(8) :: dcdalphad, dcdalphadotd
    real(kind=realtype), dimension(8) :: coef0
    real(kind=realtype), dimension(8) :: coef0d
    integer(kind=inttype) :: liftindex
! working variables
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoefd
    real(kind=realtype), dimension(8) :: coef0dot
    real(kind=realtype), dimension(8) :: coef0dotd
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   resbasecoef
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   resbasecoefd
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalalpha, intervalalphadot
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalmach, intervalmachdot
    real(kind=realtype), dimension(nsections) :: t
    real(kind=realtype) :: alpha, beta
    integer(kind=inttype) :: i, sps, nn
!speed of sound: for normalization of q derivatives
    real(kind=realtype) :: a
    real(kind=realtype) :: ad
    real(kind=realtype) :: scaledim, fact, factmoment
    real(kind=realtype) :: scaledimd, factd, factmomentd
! functions
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphix, &
&   dphiy, dphiz
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphixdot, &
&   dphiydot, dphizdot
    real(kind=realtype) :: derivativerigidrotangle, &
&   secondderivativerigidrotangle
    real(kind=realtype) :: derivativerigidrotangle_d
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
    scaledim = pref/pinf
    factd = -(two*surfaceref*lref**2*((gammainfd*pinf+gammainf*pinfd)*&
&     machcoef**2*scaledim+gammainf*pinf*(2*machcoef*machcoefd*scaledim+&
&     machcoef**2*scaledimd))/(gammainf*pinf*machcoef**2*surfaceref*lref&
&     **2*scaledim)**2)
    fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
    factmomentd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref&
&     *lref)**2
    factmoment = fact/(lengthref*lref)
    call getdirangle(veldirfreestream, liftdirection, liftindex, alpha, &
&              beta)
    if (tsqmode) then
      print*, &
&     'ts q mode code needs to be updated in computetsderivatives!'
      stop
! !q is pitch
! do sps =1,ntimeintervalsspectral
!    !compute the time of this intervavc
!    t = timeunsteadyrestart
!    if(equationmode == timespectral) then
!       do nn=1,nsections
!          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod &
!               /         (ntimeintervalsspectral*1.0)
!       enddo
!    endif
!    ! compute the time derivative of the rotation angles around the
!    ! z-axis. i.e. compute q
!    dphiz(sps) = derivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
!    ! add in q_dot computation
!    dphizdot(sps) = secondderivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
! end do
! !now compute dcl/dq
! do i =1,8
!    call computeleastsquaresregression(basecoef(:,i),dphiz,ntimeintervalsspectral,dcdq(i),coef0(i))
! end do
! ! now subtract off estimated cl,cmz and use remainder to compute 
! ! clqdot and cmzqdot.
! do i = 1,8
!    do sps = 1,ntimeintervalsspectral
!       resbasecoef(sps,i) = basecoef(sps,i)-(dcdq(i)*dphiz(sps)+coef0(i))
!    enddo
! enddo
! !now normalize the results...
! a  = sqrt(gammainf*pinfdim/rhoinfdim)
! dcdq = dcdq*timeref*2*(machgrid*a)/lengthref
! !now compute dcl/dpdot
! do i = 1,8
!    call computeleastsquaresregression(resbasecoef(:,i),dphizdot,ntimeintervalsspectral,dcdqdot(i),coef0dot(i))
! enddo
    else if (tsalphamode) then
      basecoefd = 0.0_8
      do sps=1,ntimeintervalsspectral
!compute the time of this interval
        t = timeunsteadyrestart
        if (equationmode .eq. timespectral) then
          do nn=1,nsections
            t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&             ntimeintervalsspectral*1.0)
          end do
        end if
        intervalalpha(sps) = tsalpha(degreepolalpha, coefpolalpha, &
&         degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        intervalalphadot(sps) = tsalphadot(degreepolalpha, coefpolalpha&
&         , degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
! this call is wrong!!!! 
!call getdirangle(veldirfreestream,liftdirection,liftindex,alpha+intervalalpha(sps), beta)
        basecoefd(sps, 1) = factd*(force(1, sps)*liftdirection(1)+force(&
&         2, sps)*liftdirection(2)+force(3, sps)*liftdirection(3)) + &
&         fact*(forced(1, sps)*liftdirection(1)+force(1, sps)*&
&         liftdirectiond(1)+forced(2, sps)*liftdirection(2)+force(2, sps&
&         )*liftdirectiond(2)+forced(3, sps)*liftdirection(3)+force(3, &
&         sps)*liftdirectiond(3))
        basecoef(sps, 1) = fact*(force(1, sps)*liftdirection(1)+force(2&
&         , sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
        basecoefd(sps, 2) = factd*(force(1, sps)*dragdirection(1)+force(&
&         2, sps)*dragdirection(2)+force(3, sps)*dragdirection(3)) + &
&         fact*(forced(1, sps)*dragdirection(1)+force(1, sps)*&
&         dragdirectiond(1)+forced(2, sps)*dragdirection(2)+force(2, sps&
&         )*dragdirectiond(2)+forced(3, sps)*dragdirection(3)+force(3, &
&         sps)*dragdirectiond(3))
        basecoef(sps, 2) = fact*(force(1, sps)*dragdirection(1)+force(2&
&         , sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
        basecoefd(sps, 3) = forced(1, sps)*fact + force(1, sps)*factd
        basecoef(sps, 3) = force(1, sps)*fact
        basecoefd(sps, 4) = forced(2, sps)*fact + force(2, sps)*factd
        basecoef(sps, 4) = force(2, sps)*fact
        basecoefd(sps, 5) = forced(3, sps)*fact + force(3, sps)*factd
        basecoef(sps, 5) = force(3, sps)*fact
        basecoefd(sps, 6) = momentd(1, sps)*factmoment + moment(1, sps)*&
&         factmomentd
        basecoef(sps, 6) = moment(1, sps)*factmoment
        basecoefd(sps, 7) = momentd(2, sps)*factmoment + moment(2, sps)*&
&         factmomentd
        basecoef(sps, 7) = moment(2, sps)*factmoment
        basecoefd(sps, 8) = momentd(3, sps)*factmoment + moment(3, sps)*&
&         factmomentd
        basecoef(sps, 8) = moment(3, sps)*factmoment
      end do
      coef0d = 0.0_8
      dcdalphad = 0.0_8
!now compute dcl/dalpha
      do i=1,8
        call computeleastsquaresregression_d(basecoef(:, i), basecoefd(:&
&                                      , i), intervalalpha, &
&                                      ntimeintervalsspectral, dcdalpha(&
&                                      i), dcdalphad(i), coef0(i), &
&                                      coef0d(i))
      end do
      resbasecoefd = 0.0_8
! now subtract off estimated cl,cmz and use remainder to compute 
! clalphadot and cmzalphadot.
      do i=1,8
        do sps=1,ntimeintervalsspectral
          resbasecoefd(sps, i) = basecoefd(sps, i) - intervalalpha(sps)*&
&           dcdalphad(i) - coef0d(i)
          resbasecoef(sps, i) = basecoef(sps, i) - (dcdalpha(i)*&
&           intervalalpha(sps)+coef0(i))
        end do
      end do
      dcdalphadotd = 0.0_8
!now compute dci/dalphadot
      do i=1,8
        call computeleastsquaresregression_d(resbasecoef(:, i), &
&                                      resbasecoefd(:, i), &
&                                      intervalalphadot, &
&                                      ntimeintervalsspectral, &
&                                      dcdalphadot(i), dcdalphadotd(i), &
&                                      coef0dot(i), coef0dotd(i))
      end do
      arg1d = ((gammainfd*pinfdim+gammainf*pinfdimd)*rhoinfdim-gammainf*&
&       pinfdim*rhoinfdimd)/rhoinfdim**2
      arg1 = gammainf*pinfdim/rhoinfdim
      if (arg1 .eq. 0.0_8) then
        ad = 0.0_8
      else
        ad = arg1d/(2.0*sqrt(arg1))
      end if
      a = sqrt(arg1)
      dcdalphadotd = (2*((dcdalphadotd*machgrid+dcdalphadot*machgridd)*a&
&       +dcdalphadot*machgrid*ad)*lengthref-dcdalphadot*2*machgrid*a*&
&       lengthrefd)/lengthref**2
      dcdalphadot = dcdalphadot*2*(machgrid*a)/lengthref
    else
      call terminate('computetsderivatives', &
&              'not a valid stability motion')
      dcdalphadotd = 0.0_8
      coef0d = 0.0_8
      dcdalphad = 0.0_8
    end if
  end subroutine computetsderivatives_d
!  differentiation of computeleastsquaresregression in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: m b
!   with respect to varying inputs: y
  subroutine computeleastsquaresregression_d(y, yd, x, npts, m, md0, b, &
&   bd)
!
!       computes the slope of best fit for a set of x,y data of length 
!       npts                                                           
!
    use constants
    implicit none
!subroutine arguments 
    integer(kind=inttype) :: npts
    real(kind=realtype), dimension(npts) :: x, y
    real(kind=realtype), dimension(npts) :: yd
    real(kind=realtype) :: m, b
    real(kind=realtype) :: md0, bd
!local variables
    real(kind=realtype) :: sumx, sumy, sumx2, sumxy
    real(kind=realtype) :: sumyd, sumxyd
    integer(kind=inttype) :: i
!begin execution
    sumx = 0.0
    sumy = 0.0
    sumx2 = 0.0
    sumxy = 0.0
    sumyd = 0.0_8
    sumxyd = 0.0_8
    do i=1,npts
      sumx = sumx + x(i)
      sumyd = sumyd + yd(i)
      sumy = sumy + y(i)
      sumx2 = sumx2 + x(i)*x(i)
      sumxyd = sumxyd + x(i)*yd(i)
      sumxy = sumxy + x(i)*y(i)
    end do
    md0 = (npts*sumxyd-sumx*sumyd)/(npts*sumx2-sumx**2)
    m = (npts*sumxy-sumy*sumx)/(npts*sumx2-sumx**2)
    bd = (sumx2*sumyd-sumx*sumxyd)/(npts*sumx2-sumx**2)
    b = (sumy*sumx2-sumx*sumxy)/(npts*sumx2-sumx**2)
  end subroutine computeleastsquaresregression_d
  subroutine computetsderivatives(force, moment, liftindex, coef0, &
&   dcdalpha, dcdalphadot, dcdq, dcdqdot)
!
!      computes the stability derivatives based on the time spectral  
!      solution of a given mesh. takes in the force coefficients at   
!      all time instantces and computes the agregate parameters       
!
    use constants
    use communication
    use inputphysics
    use inputtimespectral
    use inputtsstabderiv
    use flowvarrefstate
    use monitor
    use section
    use inputmotion
    implicit none
!
!     subroutine arguments.
!
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype), dimension(8) :: dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
    real(kind=realtype), dimension(8) :: coef0
    integer(kind=inttype) :: liftindex
! working variables
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(8) :: coef0dot
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   resbasecoef
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalalpha, intervalalphadot
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalmach, intervalmachdot
    real(kind=realtype), dimension(nsections) :: t
    real(kind=realtype) :: alpha, beta
    integer(kind=inttype) :: i, sps, nn
!speed of sound: for normalization of q derivatives
    real(kind=realtype) :: a
    real(kind=realtype) :: scaledim, fact, factmoment
! functions
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphix, &
&   dphiy, dphiz
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphixdot, &
&   dphiydot, dphizdot
    real(kind=realtype) :: derivativerigidrotangle, &
&   secondderivativerigidrotangle
    intrinsic sqrt
    real(kind=realtype) :: arg1
    scaledim = pref/pinf
    fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
    factmoment = fact/(lengthref*lref)
    call getdirangle(veldirfreestream, liftdirection, liftindex, alpha, &
&              beta)
    if (tsqmode) then
      print*, &
&     'ts q mode code needs to be updated in computetsderivatives!'
      stop
! !q is pitch
! do sps =1,ntimeintervalsspectral
!    !compute the time of this intervavc
!    t = timeunsteadyrestart
!    if(equationmode == timespectral) then
!       do nn=1,nsections
!          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod &
!               /         (ntimeintervalsspectral*1.0)
!       enddo
!    endif
!    ! compute the time derivative of the rotation angles around the
!    ! z-axis. i.e. compute q
!    dphiz(sps) = derivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
!    ! add in q_dot computation
!    dphizdot(sps) = secondderivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
! end do
! !now compute dcl/dq
! do i =1,8
!    call computeleastsquaresregression(basecoef(:,i),dphiz,ntimeintervalsspectral,dcdq(i),coef0(i))
! end do
! ! now subtract off estimated cl,cmz and use remainder to compute 
! ! clqdot and cmzqdot.
! do i = 1,8
!    do sps = 1,ntimeintervalsspectral
!       resbasecoef(sps,i) = basecoef(sps,i)-(dcdq(i)*dphiz(sps)+coef0(i))
!    enddo
! enddo
! !now normalize the results...
! a  = sqrt(gammainf*pinfdim/rhoinfdim)
! dcdq = dcdq*timeref*2*(machgrid*a)/lengthref
! !now compute dcl/dpdot
! do i = 1,8
!    call computeleastsquaresregression(resbasecoef(:,i),dphizdot,ntimeintervalsspectral,dcdqdot(i),coef0dot(i))
! enddo
    else if (tsalphamode) then
      do sps=1,ntimeintervalsspectral
!compute the time of this interval
        t = timeunsteadyrestart
        if (equationmode .eq. timespectral) then
          do nn=1,nsections
            t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&             ntimeintervalsspectral*1.0)
          end do
        end if
        intervalalpha(sps) = tsalpha(degreepolalpha, coefpolalpha, &
&         degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        intervalalphadot(sps) = tsalphadot(degreepolalpha, coefpolalpha&
&         , degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
! this call is wrong!!!! 
!call getdirangle(veldirfreestream,liftdirection,liftindex,alpha+intervalalpha(sps), beta)
        basecoef(sps, 1) = fact*(force(1, sps)*liftdirection(1)+force(2&
&         , sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
        basecoef(sps, 2) = fact*(force(1, sps)*dragdirection(1)+force(2&
&         , sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
        basecoef(sps, 3) = force(1, sps)*fact
        basecoef(sps, 4) = force(2, sps)*fact
        basecoef(sps, 5) = force(3, sps)*fact
        basecoef(sps, 6) = moment(1, sps)*factmoment
        basecoef(sps, 7) = moment(2, sps)*factmoment
        basecoef(sps, 8) = moment(3, sps)*factmoment
      end do
!now compute dcl/dalpha
      do i=1,8
        call computeleastsquaresregression(basecoef(:, i), intervalalpha&
&                                    , ntimeintervalsspectral, dcdalpha(&
&                                    i), coef0(i))
      end do
! now subtract off estimated cl,cmz and use remainder to compute 
! clalphadot and cmzalphadot.
      do i=1,8
        do sps=1,ntimeintervalsspectral
          resbasecoef(sps, i) = basecoef(sps, i) - (dcdalpha(i)*&
&           intervalalpha(sps)+coef0(i))
        end do
      end do
!now compute dci/dalphadot
      do i=1,8
        call computeleastsquaresregression(resbasecoef(:, i), &
&                                    intervalalphadot, &
&                                    ntimeintervalsspectral, dcdalphadot&
&                                    (i), coef0dot(i))
      end do
      arg1 = gammainf*pinfdim/rhoinfdim
      a = sqrt(arg1)
      dcdalphadot = dcdalphadot*2*(machgrid*a)/lengthref
    else
      call terminate('computetsderivatives', &
&              'not a valid stability motion')
    end if
  end subroutine computetsderivatives
  function tsalpha(degreepolalpha, coefpolalpha, degreefouralpha, &
&   omegafouralpha, coscoeffouralpha, sincoeffouralpha, t)
!
!       tsalpha computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsalpha
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolalpha
    integer(kind=inttype), intent(in) :: degreefouralpha
    real(kind=realtype), intent(in) :: omegafouralpha, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolalpha
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffouralpha
    real(kind=realtype), dimension(*), intent(in) :: sincoeffouralpha
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: alpha, val
    intrinsic cos
    intrinsic sin
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsalpha = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      alpha = coefpolalpha(0)
      do nn=1,degreepolalpha
        pwr1 = t**nn
        alpha = alpha + coefpolalpha(nn)*pwr1
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      alpha = alpha + coscoeffouralpha(0)
      do nn=1,degreefouralpha
        val = nn*omegafouralpha*t
        alpha = alpha + coscoeffouralpha(nn)*cos(val) + sincoeffouralpha&
&         (nn)*sin(val)
      end do
!print *,'intsalpha',alpha,nn,val,t
! set tsalpha to phi.
      tsalpha = alpha
    end if
  end function tsalpha
  function tsalphadot(degreepolalpha, coefpolalpha, degreefouralpha, &
&   omegafouralpha, coscoeffouralpha, sincoeffouralpha, t)
!
!       tsalpha computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsalphadot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolalpha
    integer(kind=inttype), intent(in) :: degreefouralpha
    real(kind=realtype), intent(in) :: omegafouralpha, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolalpha
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffouralpha
    real(kind=realtype), dimension(*), intent(in) :: sincoeffouralpha
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: alphadot, val
    intrinsic sin
    intrinsic cos
    integer :: pwy1
    real(kind=realtype) :: pwr1
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsalphadot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      alphadot = zero
      do nn=1,degreepolalpha
        pwy1 = nn - 1
        pwr1 = t**pwy1
        alphadot = alphadot + nn*coefpolalpha(nn)*pwr1
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefouralpha
        val = nn*omegafouralpha
        alphadot = alphadot - val*coscoeffouralpha(nn)*sin(val*t) + val*&
&         sincoeffouralpha(nn)*cos(val*t)
      end do
! set tsalpha to phi.
      tsalphadot = alphadot
    end if
  end function tsalphadot
  subroutine computeleastsquaresregression(y, x, npts, m, b)
!
!       computes the slope of best fit for a set of x,y data of length 
!       npts                                                           
!
    use constants
    implicit none
!subroutine arguments 
    integer(kind=inttype) :: npts
    real(kind=realtype), dimension(npts) :: x, y
    real(kind=realtype) :: m, b
!local variables
    real(kind=realtype) :: sumx, sumy, sumx2, sumxy
    integer(kind=inttype) :: i
!begin execution
    sumx = 0.0
    sumy = 0.0
    sumx2 = 0.0
    sumxy = 0.0
    do i=1,npts
      sumx = sumx + x(i)
      sumy = sumy + y(i)
      sumx2 = sumx2 + x(i)*x(i)
      sumxy = sumxy + x(i)*y(i)
    end do
    m = (npts*sumxy-sumy*sumx)/(npts*sumx2-sumx**2)
    b = (sumy*sumx2-sumx*sumxy)/(npts*sumx2-sumx**2)
  end subroutine computeleastsquaresregression
!  differentiation of getdirangle in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: alpha beta
!   with respect to varying inputs: freestreamaxis
  subroutine getdirangle_d(freestreamaxis, freestreamaxisd, liftaxis, &
&   liftindex, alpha, alphad, beta, betad)
!
!      convert the wind axes to angle of attack and side slip angle.  
!      the direction angles alpha and beta are computed given the     
!      components of the wind direction vector (freestreamaxis), the  
!      lift direction vector (liftaxis) and assuming that the         
!      body direction (xb,yb,zb) is in the default ijk coordinate     
!      system. the rotations are determined by first determining      
!      whether the lift is primarily in the j or k direction and then 
!      determining the angles accordingly.                            
!      direction vector:                                              
!        1) rotation about the zb or yb -axis: alpha clockwise (cw)   
!           (xb,yb,zb) -> (x1,y1,z1)                                  
!        2) rotation about the yl or z1 -axis: beta counter-clockwise 
!           (ccw) (x1,y1,z1) -> (xw,yw,zw)                            
!         input arguments:                                            
!            freestreamaxis = wind vector in body axes                
!            liftaxis       = lift direction vector in body axis      
!         output arguments:                                           
!            alpha    = angle of attack in radians                    
!            beta     = side slip angle in radians                    
!
    use constants
    implicit none
!
!     subroutine arguments.
!
!      real(kind=realtype), intent(in)  :: xw, yw, zw
    real(kind=realtype), dimension(3), intent(in) :: freestreamaxis
    real(kind=realtype), dimension(3), intent(in) :: freestreamaxisd
    real(kind=realtype), dimension(3), intent(in) :: liftaxis
    real(kind=realtype), intent(out) :: alpha, beta
    real(kind=realtype), intent(out) :: alphad, betad
    integer(kind=inttype), intent(out) :: liftindex
!
!     local variables.
!
    real(kind=realtype) :: rnorm
    real(kind=realtype) :: rnormd
    integer(kind=inttype) :: flowindex, i
    real(kind=realtype), dimension(3) :: freestreamaxisnorm
    real(kind=realtype), dimension(3) :: freestreamaxisnormd
    integer(kind=inttype) :: temp
    intrinsic abs
    intrinsic sqrt
    intrinsic asin
    intrinsic atan2
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: abs7
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
! assume domoniate flow is x
    flowindex = 1
    if (liftaxis(1) .ge. 0.) then
      abs0 = liftaxis(1)
    else
      abs0 = -liftaxis(1)
    end if
    if (liftaxis(2) .ge. 0.) then
      abs2 = liftaxis(2)
    else
      abs2 = -liftaxis(2)
    end if
    if (liftaxis(1) .ge. 0.) then
      abs4 = liftaxis(1)
    else
      abs4 = -liftaxis(1)
    end if
    if (liftaxis(3) .ge. 0.) then
      abs6 = liftaxis(3)
    else
      abs6 = -liftaxis(3)
    end if
! determine the dominant lift direction
    if (abs0 .gt. abs2 .and. abs4 .gt. abs6) then
      temp = 1
    else
      if (liftaxis(2) .ge. 0.) then
        abs1 = liftaxis(2)
      else
        abs1 = -liftaxis(2)
      end if
      if (liftaxis(1) .ge. 0.) then
        abs3 = liftaxis(1)
      else
        abs3 = -liftaxis(1)
      end if
      if (liftaxis(2) .ge. 0.) then
        abs5 = liftaxis(2)
      else
        abs5 = -liftaxis(2)
      end if
      if (liftaxis(3) .ge. 0.) then
        abs7 = liftaxis(3)
      else
        abs7 = -liftaxis(3)
      end if
      if (abs1 .gt. abs3 .and. abs5 .gt. abs7) then
        temp = 2
      else
        temp = 3
      end if
    end if
    liftindex = temp
! normalize the freestreamdirection vector.
    arg1d = 2*freestreamaxis(1)*freestreamaxisd(1) + 2*freestreamaxis(2)&
&     *freestreamaxisd(2) + 2*freestreamaxis(3)*freestreamaxisd(3)
    arg1 = freestreamaxis(1)**2 + freestreamaxis(2)**2 + freestreamaxis(&
&     3)**2
    if (arg1 .eq. 0.0_8) then
      rnormd = 0.0_8
    else
      rnormd = arg1d/(2.0*sqrt(arg1))
    end if
    rnorm = sqrt(arg1)
    freestreamaxisnormd = 0.0_8
    do i=1,3
      freestreamaxisnormd(i) = (freestreamaxisd(i)*rnorm-freestreamaxis(&
&       i)*rnormd)/rnorm**2
      freestreamaxisnorm(i) = freestreamaxis(i)/rnorm
    end do
    if (liftindex .eq. 2) then
! different coordinate system for aerosurf
! wing is in z- direction
! compute angle of attack alpha.
      if (freestreamaxisnorm(2) .eq. 1.0 .or. freestreamaxisnorm(2) .eq.&
&         (-1.0)) then
        alphad = 0.0_8
      else
        alphad = freestreamaxisnormd(2)/sqrt(1.0-freestreamaxisnorm(2)**&
&         2)
      end if
      alpha = asin(freestreamaxisnorm(2))
! compute side-slip angle beta.
      betad = -((freestreamaxisnormd(3)*freestreamaxisnorm(1)-&
&       freestreamaxisnormd(1)*freestreamaxisnorm(3))/(&
&       freestreamaxisnorm(3)**2+freestreamaxisnorm(1)**2))
      beta = -atan2(freestreamaxisnorm(3), freestreamaxisnorm(1))
    else if (liftindex .eq. 3) then
! wing is in y- direction
! compute angle of attack alpha.
      if (freestreamaxisnorm(3) .eq. 1.0 .or. freestreamaxisnorm(3) .eq.&
&         (-1.0)) then
        alphad = 0.0_8
      else
        alphad = freestreamaxisnormd(3)/sqrt(1.0-freestreamaxisnorm(3)**&
&         2)
      end if
      alpha = asin(freestreamaxisnorm(3))
! compute side-slip angle beta.
      betad = (freestreamaxisnormd(2)*freestreamaxisnorm(1)-&
&       freestreamaxisnormd(1)*freestreamaxisnorm(2))/(&
&       freestreamaxisnorm(2)**2+freestreamaxisnorm(1)**2)
      beta = atan2(freestreamaxisnorm(2), freestreamaxisnorm(1))
    else
      call terminate('getdirangle', 'invalid lift direction')
      alphad = 0.0_8
      betad = 0.0_8
    end if
  end subroutine getdirangle_d
  subroutine getdirangle(freestreamaxis, liftaxis, liftindex, alpha, &
&   beta)
!
!      convert the wind axes to angle of attack and side slip angle.  
!      the direction angles alpha and beta are computed given the     
!      components of the wind direction vector (freestreamaxis), the  
!      lift direction vector (liftaxis) and assuming that the         
!      body direction (xb,yb,zb) is in the default ijk coordinate     
!      system. the rotations are determined by first determining      
!      whether the lift is primarily in the j or k direction and then 
!      determining the angles accordingly.                            
!      direction vector:                                              
!        1) rotation about the zb or yb -axis: alpha clockwise (cw)   
!           (xb,yb,zb) -> (x1,y1,z1)                                  
!        2) rotation about the yl or z1 -axis: beta counter-clockwise 
!           (ccw) (x1,y1,z1) -> (xw,yw,zw)                            
!         input arguments:                                            
!            freestreamaxis = wind vector in body axes                
!            liftaxis       = lift direction vector in body axis      
!         output arguments:                                           
!            alpha    = angle of attack in radians                    
!            beta     = side slip angle in radians                    
!
    use constants
    implicit none
!
!     subroutine arguments.
!
!      real(kind=realtype), intent(in)  :: xw, yw, zw
    real(kind=realtype), dimension(3), intent(in) :: freestreamaxis
    real(kind=realtype), dimension(3), intent(in) :: liftaxis
    real(kind=realtype), intent(out) :: alpha, beta
    integer(kind=inttype), intent(out) :: liftindex
!
!     local variables.
!
    real(kind=realtype) :: rnorm
    integer(kind=inttype) :: flowindex, i
    real(kind=realtype), dimension(3) :: freestreamaxisnorm
    integer(kind=inttype) :: temp
    intrinsic abs
    intrinsic sqrt
    intrinsic asin
    intrinsic atan2
    real(kind=realtype) :: arg1
    real(kind=realtype) :: abs7
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
! assume domoniate flow is x
    flowindex = 1
    if (liftaxis(1) .ge. 0.) then
      abs0 = liftaxis(1)
    else
      abs0 = -liftaxis(1)
    end if
    if (liftaxis(2) .ge. 0.) then
      abs2 = liftaxis(2)
    else
      abs2 = -liftaxis(2)
    end if
    if (liftaxis(1) .ge. 0.) then
      abs4 = liftaxis(1)
    else
      abs4 = -liftaxis(1)
    end if
    if (liftaxis(3) .ge. 0.) then
      abs6 = liftaxis(3)
    else
      abs6 = -liftaxis(3)
    end if
! determine the dominant lift direction
    if (abs0 .gt. abs2 .and. abs4 .gt. abs6) then
      temp = 1
    else
      if (liftaxis(2) .ge. 0.) then
        abs1 = liftaxis(2)
      else
        abs1 = -liftaxis(2)
      end if
      if (liftaxis(1) .ge. 0.) then
        abs3 = liftaxis(1)
      else
        abs3 = -liftaxis(1)
      end if
      if (liftaxis(2) .ge. 0.) then
        abs5 = liftaxis(2)
      else
        abs5 = -liftaxis(2)
      end if
      if (liftaxis(3) .ge. 0.) then
        abs7 = liftaxis(3)
      else
        abs7 = -liftaxis(3)
      end if
      if (abs1 .gt. abs3 .and. abs5 .gt. abs7) then
        temp = 2
      else
        temp = 3
      end if
    end if
    liftindex = temp
! normalize the freestreamdirection vector.
    arg1 = freestreamaxis(1)**2 + freestreamaxis(2)**2 + freestreamaxis(&
&     3)**2
    rnorm = sqrt(arg1)
    do i=1,3
      freestreamaxisnorm(i) = freestreamaxis(i)/rnorm
    end do
    if (liftindex .eq. 2) then
! different coordinate system for aerosurf
! wing is in z- direction
! compute angle of attack alpha.
      alpha = asin(freestreamaxisnorm(2))
! compute side-slip angle beta.
      beta = -atan2(freestreamaxisnorm(3), freestreamaxisnorm(1))
    else if (liftindex .eq. 3) then
! wing is in y- direction
! compute angle of attack alpha.
      alpha = asin(freestreamaxisnorm(3))
! compute side-slip angle beta.
      beta = atan2(freestreamaxisnorm(2), freestreamaxisnorm(1))
    else
      call terminate('getdirangle', 'invalid lift direction')
    end if
  end subroutine getdirangle
  subroutine terminate(routinename, errormessage)
!
!       terminate writes an error message to standard output and       
!       terminates the execution of the program.                       
!
    use constants
    use communication, only : sumb_comm_world, myid
    implicit none
!
!      subroutine arguments
!
    character(len=*), intent(in) :: routinename
    character(len=*), intent(in) :: errormessage
  end subroutine terminate
  subroutine stabilityderivativedriver()
!
!      runs the time spectral stability derivative routines from the  
!      main program file                                              
!
    use precision
    implicit none
!call computetsderivatives(coef0,dcdalpha,dcdalphadot,dcdq,dcdqdot)
!
!     local variables.
! 
    real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot, dcdbeta&
&   , dcdbetadot, dcdmach, dcdmachdot
    real(kind=realtype), dimension(8) :: dcdp, dcdpdot, dcdq, dcdqdot, &
&   dcdr, dcdrdot
    real(kind=realtype), dimension(8) :: coef0, coef0dot
  end subroutine stabilityderivativedriver
  subroutine setcoeftimeintegrator()
!
!       setcoeftimeintegrator determines the coefficients of the       
!       time integration scheme in unsteady mode. normally these are   
!       equal to the coefficients corresponding to the specified       
!       accuracy. however during the initial phase there are not       
!       enough states in the past and the accuracy is reduced.         
!
    use constants
    use inputunsteady
    use inputphysics
    use iteration
    use monitor
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: nn, nlevelsset
! determine which time integrator must be used.
! modified by hdn
    select case  (timeaccuracy) 
    case (firstorder) 
! 1st order. no need to check the number of available
! states in the past. set the two coefficients and
! nlevelsset to 2.
      coeftime(0) = 1.0_realtype
      coeftime(1) = -1.0_realtype
      if (useale .and. equationmode .eq. unsteady) then
        coeftimeale(1) = 1.0_realtype
        coefmeshale(1, 1) = half
        coefmeshale(1, 2) = half
      end if
      nlevelsset = 2
    case (secondorder) 
!--------------------------------------------------
! second order time integrator. determine the amount of
! available states and set the coefficients accordingly.
      select case  (noldsolavail) 
      case (1_inttype) 
        coeftime(0) = 1.0_realtype
        coeftime(1) = -1.0_realtype
        if (useale .and. equationmode .eq. unsteady) then
          coeftimeale(1) = half
          coeftimeale(2) = half
          coeftimeale(3) = zero
          coeftimeale(4) = zero
          coefmeshale(1, 1) = half
          coefmeshale(1, 2) = half
          coefmeshale(2, 1) = half
          coefmeshale(2, 2) = half
        end if
        nlevelsset = 2
      case default
! 2 or bigger.
        coeftime(0) = 1.5_realtype
        coeftime(1) = -2.0_realtype
        coeftime(2) = 0.5_realtype
        if (useale .and. equationmode .eq. unsteady) then
          coeftimeale(1) = threefourth
          coeftimeale(2) = threefourth
          coeftimeale(3) = -fourth
          coeftimeale(4) = -fourth
          coefmeshale(1, 1) = half*(1.0_realtype+1.0_realtype/sqrtthree)
          coefmeshale(1, 2) = half*(1.0_realtype-1.0_realtype/sqrtthree)
          coefmeshale(2, 1) = coefmeshale(1, 2)
          coefmeshale(2, 2) = coefmeshale(1, 1)
        end if
        nlevelsset = 3
      end select
    case (thirdorder) 
!--------------------------------------------------
! third order time integrator.  determine the amount of
! available states and set the coefficients accordingly.
      select case  (noldsolavail) 
      case (1_inttype) 
        coeftime(0) = 1.0_realtype
        coeftime(1) = -1.0_realtype
        if (useale .and. equationmode .eq. unsteady) then
          coeftimeale(1) = 1.0_realtype
          coefmeshale(1, 1) = half
          coefmeshale(1, 2) = half
        end if
        nlevelsset = 2
      case (2_inttype) 
        coeftime(0) = 1.5_realtype
        coeftime(1) = -2.0_realtype
        coeftime(2) = 0.5_realtype
        if (useale .and. equationmode .eq. unsteady) then
          coeftimeale(1) = threefourth
          coeftimeale(2) = -fourth
          coefmeshale(1, 1) = half*(1.0_realtype+1.0_realtype/sqrtthree)
          coefmeshale(1, 2) = half*(1.0_realtype-1.0_realtype/sqrtthree)
          coefmeshale(2, 1) = coefmeshale(1, 2)
          coefmeshale(2, 2) = coefmeshale(1, 1)
        end if
        nlevelsset = 3
      case default
! 3 or bigger.
        coeftime(0) = 11.0_realtype/6.0_realtype
        coeftime(1) = -3.0_realtype
        coeftime(2) = 1.5_realtype
        coeftime(3) = -(1.0_realtype/3.0_realtype)
! these numbers are not correct
! do not use 3rd order ale for now
        if (useale .and. equationmode .eq. unsteady) then
          print*, 'third-order ale not implemented yet.'
          coeftimeale(1) = threefourth
          coeftimeale(2) = threefourth
          coeftimeale(3) = -fourth
          coeftimeale(4) = -fourth
          coefmeshale(1, 1) = half*(1.0_realtype+1.0_realtype/sqrtthree)
          coefmeshale(1, 2) = half*(1.0_realtype-1.0_realtype/sqrtthree)
          coefmeshale(2, 1) = coefmeshale(1, 2)
          coefmeshale(2, 2) = coefmeshale(1, 1)
          coefmeshale(3, 1) = coefmeshale(1, 2)
          coefmeshale(3, 2) = coefmeshale(1, 1)
        end if
        nlevelsset = 4
      end select
    end select
! set the rest of the coefficients to 0 if not enough states
! in the past are available.
    do nn=nlevelsset,noldlevels
      coeftime(nn) = zero
    end do
  end subroutine setcoeftimeintegrator
  function mynorm2(x)
    use constants
    implicit none
    real(kind=realtype), dimension(3), intent(in) :: x
    real(kind=realtype) :: mynorm2
    intrinsic sqrt
    real(kind=realtype) :: arg1
    arg1 = x(1)**2 + x(2)**2 + x(3)**2
    mynorm2 = sqrt(arg1)
  end function mynorm2
end module utils_d

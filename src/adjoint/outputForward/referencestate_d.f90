!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of referencestate in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: gammainf pinf timeref rhoinf
!                muref rhoinfdim tref muinf uinf rgas pinfdim pref
!   with respect to varying inputs: pref mach tempfreestream reynolds
!                veldirfreestream machcoef
!
!      ******************************************************************
!      *                                                                *
!      * file:          referencestate.f90                              *
!      * author:        edwin van der weide, seonghyeon hahn            *
!      * starting date: 05-29-2003                                      *
!      * last modified: 04-22-2006                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine referencestate_d()
!
!      ******************************************************************
!      *                                                                *
!      * referencestate computes the reference state values in case     *
!      * these have not been specified. a distinction is made between   *
!      * internal and external flows. in case nothing has been          *
!      * specified for the former a dimensional computation will be     *
!      * made. for the latter the reference state is set to an          *
!      * arbitrary state for an inviscid computation and computed for a *
!      * viscous computation. furthermore for internal flows an average *
!      * velocity direction is computed from the boundary conditions,   *
!      * which is used for initialization.                              *
!      *                                                                *
!      ******************************************************************
!
  use bctypes
  use block
  use communication
  use constants
  use flowvarrefstate
  use inputmotion
  use inputphysics
  use inputtimespectral
  use iteration
  implicit none
!
!      local variables.
!
  integer :: ierr
  integer(kind=inttype) :: sps, nn, mm
  real(kind=realtype) :: gm1, ratio, tmp
  real(kind=realtype) :: mx, my, mz, re, v, tinfdim
  real(kind=realtype) :: mxd, myd, mzd, red, vd, tinfdimd
  real(kind=realtype), dimension(3) :: dirloc, dirglob
  real(kind=realtype), dimension(5) :: valloc, valglob
  type(bcdatatype), dimension(:), pointer :: bcdata
  interface 
      subroutine velmagnanddirectionsubface(vmag, dir, bcdata, mm)
        use block
        implicit none
        integer(kind=inttype), intent(in) :: mm
        real(kind=realtype), intent(out) :: vmag
        real(kind=realtype), dimension(3), intent(inout) :: dir
        type(bcdatatype), dimension(:), pointer :: bcdata
      end subroutine velmagnanddirectionsubface
  end interface

  intrinsic sqrt
  real(kind=realtype) :: arg1
  real(kind=realtype) :: arg1d
  real(kind=realtype) :: result1
  real(kind=realtype) :: result1d
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! initialize the dimensional free stream temperature and pressure.
! from these values the density and viscosity is computed. for
! external viscous and internal computation this is corrected
! later on.
  pinfdimd = prefd
  pinfdim = pref
  if (pref .le. zero) then
    pinfdim = 101325.0_realtype
    pinfdimd = 0.0_8
  end if
  tinfdimd = tempfreestreamd
  tinfdim = tempfreestream
  rhoinfdimd = (pinfdimd*rgasdim*tinfdim-pinfdim*rgasdim*tinfdimd)/(&
&   rgasdim*tinfdim)**2
  rhoinfdim = pinfdim/(rgasdim*tinfdim)
  mudimd = musuthdim*((tsuthdim+ssuthdim)*1.5_realtype*(tinfdim/tsuthdim&
&   )**0.5*tinfdimd/((tinfdim+ssuthdim)*tsuthdim)-(tsuthdim+ssuthdim)*&
&   tinfdimd*(tinfdim/tsuthdim)**1.5_realtype/(tinfdim+ssuthdim)**2)
  mudim = musuthdim*((tsuthdim+ssuthdim)/(tinfdim+ssuthdim))*(tinfdim/&
&   tsuthdim)**1.5_realtype
! check the flow type we are having here.
  if (flowtype .eq. internalflow) then
    gammainfd = 0.0_8
    trefd = 0.0_8
    rhorefd = 0.0_8
  else
! external flow. compute the value of gammainf.
    call computegamma_d(tempfreestream, tempfreestreamd, gammainf, &
&                 gammainfd, 1)
! in case of a viscous problem, compute the
! dimensional free stream density and pressure.
    if (equations .eq. nsequations .or. equations .eq. ransequations) &
&   then
! compute the x, y, and z-components of the mach number
! relative to the body; i.e. the mesh velocity must be
! taken into account here.
      mxd = machcoefd*veldirfreestream(1) + machcoef*veldirfreestreamd(1&
&       )
      mx = machcoef*veldirfreestream(1)
      myd = machcoefd*veldirfreestream(2) + machcoef*veldirfreestreamd(2&
&       )
      my = machcoef*veldirfreestream(2)
      mzd = machcoefd*veldirfreestream(3) + machcoef*veldirfreestreamd(3&
&       )
      mz = machcoef*veldirfreestream(3)
! reynolds number per meter, the viscosity using sutherland's
! law and the free stream velocity relative to the body.
      red = reynoldsd/reynoldslength
      re = reynolds/reynoldslength
      mudimd = musuthdim*((tsuthdim+ssuthdim)*1.5*(tempfreestream/&
&       tsuthdim)**0.5*tempfreestreamd/((tempfreestream+ssuthdim)*&
&       tsuthdim)-(tsuthdim+ssuthdim)*tempfreestreamd*(tempfreestream/&
&       tsuthdim)**1.5/(tempfreestream+ssuthdim)**2)
      mudim = musuthdim*((tsuthdim+ssuthdim)/(tempfreestream+ssuthdim))*&
&       (tempfreestream/tsuthdim)**1.5
      arg1d = rgasdim*((mxd*mx+mx*mxd+myd*my+my*myd+mzd*mz+mz*mzd)*&
&       gammainf*tempfreestream+(mx*mx+my*my+mz*mz)*(gammainfd*&
&       tempfreestream+gammainf*tempfreestreamd))
      arg1 = (mx*mx+my*my+mz*mz)*gammainf*rgasdim*tempfreestream
      if (arg1 .eq. 0.0_8) then
        vd = 0.0_8
      else
        vd = arg1d/(2.0*sqrt(arg1))
      end if
      v = sqrt(arg1)
! compute the free stream density and pressure.
! set tinfdim to tempfreestream.
      rhoinfdimd = ((red*mudim+re*mudimd)*v-re*mudim*vd)/v**2
      rhoinfdim = re*mudim/v
      pinfdimd = rgasdim*(rhoinfdimd*tempfreestream+rhoinfdim*&
&       tempfreestreamd)
      pinfdim = rhoinfdim*rgasdim*tempfreestream
      tinfdimd = tempfreestreamd
      tinfdim = tempfreestream
    end if
! in case the reference pressure, density and temperature were
! not specified, set them to the infinity values.
    if (pref .le. zero) then
      prefd = pinfdimd
      pref = pinfdim
    end if
    if (rhoref .le. zero) then
      rhorefd = rhoinfdimd
      rhoref = rhoinfdim
    else
      rhorefd = 0.0_8
    end if
    if (tref .le. zero) then
      trefd = tinfdimd
      tref = tinfdim
    else
      trefd = 0.0_8
    end if
  end if
! compute the value of muref, such that the nondimensional
! equations are identical to the dimensional ones.
! note that in the non-dimensionalization of muref there is
! a reference length. however this reference length is 1.0
! in this code, because the coordinates are converted to
! meters.
  if (pref*rhoref .eq. 0.0_8) then
    murefd = 0.0_8
  else
    murefd = (prefd*rhoref+pref*rhorefd)/(2.0*sqrt(pref*rhoref))
  end if
  muref = sqrt(pref*rhoref)
! compute timeref for a correct nondimensionalization of the
! unsteady equations. some story as for the reference viscosity
! concerning the reference length.
  if (rhoref/pref .eq. 0.0_8) then
    timerefd = 0.0_8
  else
    timerefd = (rhorefd*pref-rhoref*prefd)/(pref**2*2.0*sqrt(rhoref/pref&
&     ))
  end if
  timeref = sqrt(rhoref/pref)
! compute the nondimensional pressure, density, velocity,
! viscosity and gas constant.
  pinfd = (pinfdimd*pref-pinfdim*prefd)/pref**2
  pinf = pinfdim/pref
  rhoinfd = (rhoinfdimd*rhoref-rhoinfdim*rhorefd)/rhoref**2
  rhoinf = rhoinfdim/rhoref
  arg1d = ((gammainfd*pinf+gammainf*pinfd)*rhoinf-gammainf*pinf*rhoinfd)&
&   /rhoinf**2
  arg1 = gammainf*pinf/rhoinf
  if (arg1 .eq. 0.0_8) then
    result1d = 0.0_8
  else
    result1d = arg1d/(2.0*sqrt(arg1))
  end if
  result1 = sqrt(arg1)
  uinfd = machd*result1 + mach*result1d
  uinf = mach*result1
  rgasd = (rgasdim*(rhorefd*tref+rhoref*trefd)*pref-rgasdim*rhoref*tref*&
&   prefd)/pref**2
  rgas = rgasdim*rhoref*tref/pref
  muinfd = (mudimd*muref-mudim*murefd)/muref**2
  muinf = mudim/muref

contains
!=================================================================
!===============================================================
  function maxvaluesubface(var)
    implicit none
!
!        function type
!
    real(kind=realtype) :: maxvaluesubface
!
!        function argument.
!
    real(kind=realtype), dimension(:, :), pointer :: var
!
!        local variables.
!
    integer(kind=inttype) :: i, j
    intrinsic associated
    intrinsic max
!
!        ****************************************************************
!        *                                                              *
!        * begin execution                                              *
!        *                                                              *
!        ****************************************************************
!
! initialize the function to -1 and return immediately if
! var is not associated with data.
    maxvaluesubface = -one
    if (.not.associated(var)) then
      return
    else
! loop over the owned faces of the subface. as the cell range
! may contain halo values, the nodal range is used.
      do j=bcdata(mm)%jnbeg+1,bcdata(mm)%jnend
        do i=bcdata(mm)%inbeg+1,bcdata(mm)%inend
          if (maxvaluesubface .lt. var(i, j)) then
            maxvaluesubface = var(i, j)
          else
            maxvaluesubface = maxvaluesubface
          end if
        end do
      end do
    end if
  end function maxvaluesubface
end subroutine referencestate_d

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of boundarynormals in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.norm)
!   with respect to varying inputs: *si *sj *sk
!   plus diff mem management of: si:in sj:in sk:in bcdata:in *bcdata.norm:in
subroutine boundarynormals_d()
! **************************************************************
! *                                                            *
! * the unit normals on the boundary faces. these always point *
! * out of the domain, so a multiplication by -1 is needed for *
! * the imin, jmin and kmin boundaries.                        *
! *                                                            *
! **************************************************************
!
  use bctypes
  use blockpointers
  use cgnsgrid
  use communication
  use inputtimespectral
  use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
  implicit none
! local variables.
  integer(kind=inttype) :: i, j, ii
  integer(kind=inttype) :: mm
  real(kind=realtype) :: fact, mult
  real(kind=realtype) :: factd
  real(kind=realtype) :: xxp, yyp, zzp
  real(kind=realtype) :: xxpd, yypd, zzpd
  intrinsic mod
  intrinsic sqrt
  real(kind=realtype) :: arg1
  real(kind=realtype) :: arg1d
  integer :: ii1
  do ii1=1,isize1ofdrfbcdata
    bcdatad(ii1)%norm = 0.0_8
  end do
  zzpd = 0.0_8
  yypd = 0.0_8
  xxpd = 0.0_8
!loop over the boundary subfaces of this block.
bocoloop:do mm=1,nbocos
! loop over the boundary faces of the subface.
    do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&       bcdata(mm)%icbeg+1)-1
      i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm)%&
&       icbeg
      j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
      select case  (bcfaceid(mm)) 
      case (imin) 
        mult = -one
        xxpd = sid(1, i, j, 1)
        xxp = si(1, i, j, 1)
        yypd = sid(1, i, j, 2)
        yyp = si(1, i, j, 2)
        zzpd = sid(1, i, j, 3)
        zzp = si(1, i, j, 3)
      case (imax) 
        mult = one
        xxpd = sid(il, i, j, 1)
        xxp = si(il, i, j, 1)
        yypd = sid(il, i, j, 2)
        yyp = si(il, i, j, 2)
        zzpd = sid(il, i, j, 3)
        zzp = si(il, i, j, 3)
      case (jmin) 
        mult = -one
        xxpd = sjd(i, 1, j, 1)
        xxp = sj(i, 1, j, 1)
        yypd = sjd(i, 1, j, 2)
        yyp = sj(i, 1, j, 2)
        zzpd = sjd(i, 1, j, 3)
        zzp = sj(i, 1, j, 3)
      case (jmax) 
        mult = one
        xxpd = sjd(i, jl, j, 1)
        xxp = sj(i, jl, j, 1)
        yypd = sjd(i, jl, j, 2)
        yyp = sj(i, jl, j, 2)
        zzpd = sjd(i, jl, j, 3)
        zzp = sj(i, jl, j, 3)
      case (kmin) 
        mult = -one
        xxpd = skd(i, j, 1, 1)
        xxp = sk(i, j, 1, 1)
        yypd = skd(i, j, 1, 2)
        yyp = sk(i, j, 1, 2)
        zzpd = skd(i, j, 1, 3)
        zzp = sk(i, j, 1, 3)
      case (kmax) 
        mult = one
        xxpd = skd(i, j, kl, 1)
        xxp = sk(i, j, kl, 1)
        yypd = skd(i, j, kl, 2)
        yyp = sk(i, j, kl, 2)
        zzpd = skd(i, j, kl, 3)
        zzp = sk(i, j, kl, 3)
      end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
      arg1d = xxpd*xxp + xxp*xxpd + yypd*yyp + yyp*yypd + zzpd*zzp + zzp&
&       *zzpd
      arg1 = xxp*xxp + yyp*yyp + zzp*zzp
      if (arg1 .eq. 0.0_8) then
        factd = 0.0_8
      else
        factd = arg1d/(2.0*sqrt(arg1))
      end if
      fact = sqrt(arg1)
      if (fact .gt. zero) then
        factd = -(mult*factd/fact**2)
        fact = mult/fact
      end if
! compute the unit normal.
      bcdatad(mm)%norm(i, j, 1) = factd*xxp + fact*xxpd
      bcdata(mm)%norm(i, j, 1) = fact*xxp
      bcdatad(mm)%norm(i, j, 2) = factd*yyp + fact*yypd
      bcdata(mm)%norm(i, j, 2) = fact*yyp
      bcdatad(mm)%norm(i, j, 3) = factd*zzp + fact*zzpd
      bcdata(mm)%norm(i, j, 3) = fact*zzp
    end do
  end do bocoloop
end subroutine boundarynormals_d

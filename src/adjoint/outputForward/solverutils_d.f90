!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module solverutils_d
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
!  differentiation of timestep_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *radi *radj *radk
!   with respect to varying inputs: *p *sfacei *sfacej *sfacek
!                *w *si *sj *sk gammainf rhoinf pinfcorr
!   plus diff mem management of: p:in sfacei:in sfacej:in sfacek:in
!                w:in si:in sj:in sk:in radi:in radj:in radk:in
  subroutine timestep_block_d(onlyradii)
!
!       timestep computes the time step, or more precisely the time    
!       step divided by the volume per unit cfl, in the owned cells.   
!       however, for the artificial dissipation schemes, the spectral  
!       radii in the halo's are needed. therefore the loop is taken    
!       over the the first level of halo cells. the spectral radii are 
!       stored and possibly modified for high aspect ratio cells.      
!
    use constants
    use blockpointers, only : ie, je, ke, il, jl, kl, w, wd, p, pd, &
&   rlv, rlvd, rev, revd, radi, radid, radj, radjd, radk, radkd, si, sid&
&   , sj, sjd, sk, skd, sfacei, sfaceid, sfacej, sfacejd, sfacek, &
&   sfacekd, dtl, gamma, vol, vold, addgridvelocities, sectionid
    use flowvarrefstate, only : timeref, timerefd, eddymodel, gammainf&
&   , gammainfd, pinfcorr, pinfcorrd, viscous, rhoinf, rhoinfd
    use inputdiscretization, only : adis, dirscaling, &
&   radiineededcoarse, radiineededfine, precond
    use inputphysics, only : equationmode
    use iteration, only : groundlevel, currentlevel
    use section, only : sections
    use inputtimespectral, only : ntimeintervalsspectral
    use utils_d, only : terminate
    implicit none
! the rest of this file can be skipped if only the spectral
! radii need to be computed.
!
!      subroutine argument.
!
    logical, intent(in) :: onlyradii
!
!      local parameters.
!
    real(kind=realtype), parameter :: b=2.0_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: plim, rlim, clim2
    real(kind=realtype) :: clim2d
    real(kind=realtype) :: uux, uuy, uuz, cc2, qsi, qsj, qsk, sx, sy, sz&
&   , rmu
    real(kind=realtype) :: uuxd, uuyd, uuzd, cc2d, qsid, qsjd, qskd, sxd&
&   , syd, szd
    real(kind=realtype) :: ri, rj, rk, rij, rjk, rki
    real(kind=realtype) :: rid, rjd, rkd, rijd, rjkd, rkid
    real(kind=realtype) :: vsi, vsj, vsk, rfl, dpi, dpj, dpk
    real(kind=realtype) :: sface, tmp
    real(kind=realtype) :: sfaced
    logical :: radiineeded, doscaling
    intrinsic max
    intrinsic abs
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: pwx1d
    real(kind=realtype) :: abs1d
    real(kind=realtype) :: abs0d
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs2d
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
! determine whether or not the spectral radii are needed for the
! flux computation.
    radiineeded = radiineededcoarse
    if (currentlevel .le. groundlevel) radiineeded = radiineededfine
! return immediately if only the spectral radii must be computed
! and these are not needed for the flux computation.
    if (onlyradii .and. (.not.radiineeded)) then
      radid = 0.0_8
      radjd = 0.0_8
      radkd = 0.0_8
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used. idem for rlim; compute clim2 as well.
      plim = 0.001_realtype*pinfcorr
      rlim = 0.001_realtype*rhoinf
      clim2d = (0.000001_realtype*(gammainfd*pinfcorr+gammainf*pinfcorrd&
&       )*rhoinf-0.000001_realtype*gammainf*pinfcorr*rhoinfd)/rhoinf**2
      clim2 = 0.000001_realtype*gammainf*pinfcorr/rhoinf
      doscaling = dirscaling .and. currentlevel .le. groundlevel
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
!
!           inviscid contribution, depending on the preconditioner.    
!           compute the cell centered values of the spectral radii.    
!
      select case  (precond) 
      case (noprecond) 
        radid = 0.0_8
        radjd = 0.0_8
        radkd = 0.0_8
        sfaced = 0.0_8
! no preconditioner. simply the standard spectral radius.
! loop over the cells, including the first level halo.
        do k=1,ke
          do j=1,je
            do i=1,ie
! compute the velocities and speed of sound squared.
              uuxd = wd(i, j, k, ivx)
              uux = w(i, j, k, ivx)
              uuyd = wd(i, j, k, ivy)
              uuy = w(i, j, k, ivy)
              uuzd = wd(i, j, k, ivz)
              uuz = w(i, j, k, ivz)
              cc2d = (gamma(i, j, k)*pd(i, j, k)*w(i, j, k, irho)-gamma(&
&               i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, j, k, irho)&
&               **2
              cc2 = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
              if (cc2 .lt. clim2) then
                cc2d = clim2d
                cc2 = clim2
              else
                cc2 = cc2
              end if
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face. to avoid
! a number of multiplications by 0.5 simply the sum
! is taken.
              if (addgridvelocities) then
                sfaced = sfaceid(i-1, j, k) + sfaceid(i, j, k)
                sface = sfacei(i-1, j, k) + sfacei(i, j, k)
              end if
! spectral radius in i-direction.
              sxd = sid(i-1, j, k, 1) + sid(i, j, k, 1)
              sx = si(i-1, j, k, 1) + si(i, j, k, 1)
              syd = sid(i-1, j, k, 2) + sid(i, j, k, 2)
              sy = si(i-1, j, k, 2) + si(i, j, k, 2)
              szd = sid(i-1, j, k, 3) + sid(i, j, k, 3)
              sz = si(i-1, j, k, 3) + si(i, j, k, 3)
              qsid = uuxd*sx + uux*sxd + uuyd*sy + uuy*syd + uuzd*sz + &
&               uuz*szd - sfaced
              qsi = uux*sx + uuy*sy + uuz*sz - sface
              if (qsi .ge. 0.) then
                abs0d = qsid
                abs0 = qsi
              else
                abs0d = -qsid
                abs0 = -qsi
              end if
              arg1d = cc2d*(sx**2+sy**2+sz**2) + cc2*(2*sx*sxd+2*sy*syd+&
&               2*sz*szd)
              arg1 = cc2*(sx**2+sy**2+sz**2)
              if (arg1 .eq. 0.0_8) then
                result1d = 0.0_8
              else
                result1d = arg1d/(2.0*sqrt(arg1))
              end if
              result1 = sqrt(arg1)
              rid = half*(abs0d+result1d)
              ri = half*(abs0+result1)
! the grid velocity in j-direction.
              if (addgridvelocities) then
                sfaced = sfacejd(i, j-1, k) + sfacejd(i, j, k)
                sface = sfacej(i, j-1, k) + sfacej(i, j, k)
              end if
! spectral radius in j-direction.
              sxd = sjd(i, j-1, k, 1) + sjd(i, j, k, 1)
              sx = sj(i, j-1, k, 1) + sj(i, j, k, 1)
              syd = sjd(i, j-1, k, 2) + sjd(i, j, k, 2)
              sy = sj(i, j-1, k, 2) + sj(i, j, k, 2)
              szd = sjd(i, j-1, k, 3) + sjd(i, j, k, 3)
              sz = sj(i, j-1, k, 3) + sj(i, j, k, 3)
              qsjd = uuxd*sx + uux*sxd + uuyd*sy + uuy*syd + uuzd*sz + &
&               uuz*szd - sfaced
              qsj = uux*sx + uuy*sy + uuz*sz - sface
              if (qsj .ge. 0.) then
                abs1d = qsjd
                abs1 = qsj
              else
                abs1d = -qsjd
                abs1 = -qsj
              end if
              arg1d = cc2d*(sx**2+sy**2+sz**2) + cc2*(2*sx*sxd+2*sy*syd+&
&               2*sz*szd)
              arg1 = cc2*(sx**2+sy**2+sz**2)
              if (arg1 .eq. 0.0_8) then
                result1d = 0.0_8
              else
                result1d = arg1d/(2.0*sqrt(arg1))
              end if
              result1 = sqrt(arg1)
              rjd = half*(abs1d+result1d)
              rj = half*(abs1+result1)
! the grid velocity in k-direction.
              if (addgridvelocities) then
                sfaced = sfacekd(i, j, k-1) + sfacekd(i, j, k)
                sface = sfacek(i, j, k-1) + sfacek(i, j, k)
              end if
! spectral radius in k-direction.
              sxd = skd(i, j, k-1, 1) + skd(i, j, k, 1)
              sx = sk(i, j, k-1, 1) + sk(i, j, k, 1)
              syd = skd(i, j, k-1, 2) + skd(i, j, k, 2)
              sy = sk(i, j, k-1, 2) + sk(i, j, k, 2)
              szd = skd(i, j, k-1, 3) + skd(i, j, k, 3)
              sz = sk(i, j, k-1, 3) + sk(i, j, k, 3)
              qskd = uuxd*sx + uux*sxd + uuyd*sy + uuy*syd + uuzd*sz + &
&               uuz*szd - sfaced
              qsk = uux*sx + uuy*sy + uuz*sz - sface
              if (qsk .ge. 0.) then
                abs2d = qskd
                abs2 = qsk
              else
                abs2d = -qskd
                abs2 = -qsk
              end if
              arg1d = cc2d*(sx**2+sy**2+sz**2) + cc2*(2*sx*sxd+2*sy*syd+&
&               2*sz*szd)
              arg1 = cc2*(sx**2+sy**2+sz**2)
              if (arg1 .eq. 0.0_8) then
                result1d = 0.0_8
              else
                result1d = arg1d/(2.0*sqrt(arg1))
              end if
              result1 = sqrt(arg1)
              rkd = half*(abs2d+result1d)
              rk = half*(abs2+result1)
! compute the inviscid contribution to the time step.
              dtl(i, j, k) = ri + rj + rk
!
!           adapt the spectral radii if directional scaling must be    
!           applied.                                                   
!
              if (doscaling) then
                if (ri .lt. eps) then
                  ri = eps
                  rid = 0.0_8
                else
                  ri = ri
                end if
                if (rj .lt. eps) then
                  rj = eps
                  rjd = 0.0_8
                else
                  rj = rj
                end if
                if (rk .lt. eps) then
                  rk = eps
                  rkd = 0.0_8
                else
                  rk = rk
                end if
! compute the scaling in the three coordinate
! directions.
                pwx1d = (rid*rj-ri*rjd)/rj**2
                pwx1 = ri/rj
                if (pwx1 .gt. 0.0_8 .or. (pwx1 .lt. 0.0_8 .and. adis &
&                   .eq. int(adis))) then
                  rijd = adis*pwx1**(adis-1)*pwx1d
                else if (pwx1 .eq. 0.0_8 .and. adis .eq. 1.0) then
                  rijd = pwx1d
                else
                  rijd = 0.0_8
                end if
                rij = pwx1**adis
                pwx1d = (rjd*rk-rj*rkd)/rk**2
                pwx1 = rj/rk
                if (pwx1 .gt. 0.0_8 .or. (pwx1 .lt. 0.0_8 .and. adis &
&                   .eq. int(adis))) then
                  rjkd = adis*pwx1**(adis-1)*pwx1d
                else if (pwx1 .eq. 0.0_8 .and. adis .eq. 1.0) then
                  rjkd = pwx1d
                else
                  rjkd = 0.0_8
                end if
                rjk = pwx1**adis
                pwx1d = (rkd*ri-rk*rid)/ri**2
                pwx1 = rk/ri
                if (pwx1 .gt. 0.0_8 .or. (pwx1 .lt. 0.0_8 .and. adis &
&                   .eq. int(adis))) then
                  rkid = adis*pwx1**(adis-1)*pwx1d
                else if (pwx1 .eq. 0.0_8 .and. adis .eq. 1.0) then
                  rkid = pwx1d
                else
                  rkid = 0.0_8
                end if
                rki = pwx1**adis
! create the scaled versions of the aspect ratios.
! note that the multiplication is done with radi, radj
! and radk, such that the influence of the clipping
! is negligible.
                radid(i, j, k) = rid*(one+one/rij+rki) + ri*(rkid-one*&
&                 rijd/rij**2)
                radi(i, j, k) = ri*(one+one/rij+rki)
                radjd(i, j, k) = rjd*(one+one/rjk+rij) + rj*(rijd-one*&
&                 rjkd/rjk**2)
                radj(i, j, k) = rj*(one+one/rjk+rij)
                radkd(i, j, k) = rkd*(one+one/rki+rjk) + rk*(rjkd-one*&
&                 rkid/rki**2)
                radk(i, j, k) = rk*(one+one/rki+rjk)
              else
                radid(i, j, k) = rid
                radi(i, j, k) = ri
                radjd(i, j, k) = rjd
                radj(i, j, k) = rj
                radkd(i, j, k) = rkd
                radk(i, j, k) = rk
              end if
            end do
          end do
        end do
      case (turkel) 
        call terminate('timestep', &
&                'turkel preconditioner not implemented yet')
        radid = 0.0_8
        radjd = 0.0_8
        radkd = 0.0_8
      case (choimerkle) 
        call terminate('timestep', &
&                'choi merkle preconditioner not implemented yet')
        radid = 0.0_8
        radjd = 0.0_8
        radkd = 0.0_8
      case default
        radid = 0.0_8
        radjd = 0.0_8
        radkd = 0.0_8
      end select
    end if
  end subroutine timestep_block_d
  subroutine timestep_block(onlyradii)
!
!       timestep computes the time step, or more precisely the time    
!       step divided by the volume per unit cfl, in the owned cells.   
!       however, for the artificial dissipation schemes, the spectral  
!       radii in the halo's are needed. therefore the loop is taken    
!       over the the first level of halo cells. the spectral radii are 
!       stored and possibly modified for high aspect ratio cells.      
!
    use constants
    use blockpointers, only : ie, je, ke, il, jl, kl, w, p, rlv, rev, &
&   radi, radj, radk, si, sj, sk, sfacei, sfacej, sfacek, dtl, gamma, &
&   vol, addgridvelocities, sectionid
    use flowvarrefstate, only : timeref, eddymodel, gammainf, pinfcorr&
&   , viscous, rhoinf
    use inputdiscretization, only : adis, dirscaling, &
&   radiineededcoarse, radiineededfine, precond
    use inputphysics, only : equationmode
    use iteration, only : groundlevel, currentlevel
    use section, only : sections
    use inputtimespectral, only : ntimeintervalsspectral
    use utils_d, only : terminate
    implicit none
! the rest of this file can be skipped if only the spectral
! radii need to be computed.
!
!      subroutine argument.
!
    logical, intent(in) :: onlyradii
!
!      local parameters.
!
    real(kind=realtype), parameter :: b=2.0_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: plim, rlim, clim2
    real(kind=realtype) :: uux, uuy, uuz, cc2, qsi, qsj, qsk, sx, sy, sz&
&   , rmu
    real(kind=realtype) :: ri, rj, rk, rij, rjk, rki
    real(kind=realtype) :: vsi, vsj, vsk, rfl, dpi, dpj, dpk
    real(kind=realtype) :: sface, tmp
    logical :: radiineeded, doscaling
    intrinsic max
    intrinsic abs
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
! determine whether or not the spectral radii are needed for the
! flux computation.
    radiineeded = radiineededcoarse
    if (currentlevel .le. groundlevel) radiineeded = radiineededfine
! return immediately if only the spectral radii must be computed
! and these are not needed for the flux computation.
    if (onlyradii .and. (.not.radiineeded)) then
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used. idem for rlim; compute clim2 as well.
      plim = 0.001_realtype*pinfcorr
      rlim = 0.001_realtype*rhoinf
      clim2 = 0.000001_realtype*gammainf*pinfcorr/rhoinf
      doscaling = dirscaling .and. currentlevel .le. groundlevel
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
!
!           inviscid contribution, depending on the preconditioner.    
!           compute the cell centered values of the spectral radii.    
!
      select case  (precond) 
      case (noprecond) 
! no preconditioner. simply the standard spectral radius.
! loop over the cells, including the first level halo.
        do k=1,ke
          do j=1,je
            do i=1,ie
! compute the velocities and speed of sound squared.
              uux = w(i, j, k, ivx)
              uuy = w(i, j, k, ivy)
              uuz = w(i, j, k, ivz)
              cc2 = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
              if (cc2 .lt. clim2) then
                cc2 = clim2
              else
                cc2 = cc2
              end if
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face. to avoid
! a number of multiplications by 0.5 simply the sum
! is taken.
              if (addgridvelocities) sface = sfacei(i-1, j, k) + sfacei(&
&                 i, j, k)
! spectral radius in i-direction.
              sx = si(i-1, j, k, 1) + si(i, j, k, 1)
              sy = si(i-1, j, k, 2) + si(i, j, k, 2)
              sz = si(i-1, j, k, 3) + si(i, j, k, 3)
              qsi = uux*sx + uuy*sy + uuz*sz - sface
              if (qsi .ge. 0.) then
                abs0 = qsi
              else
                abs0 = -qsi
              end if
              arg1 = cc2*(sx**2+sy**2+sz**2)
              result1 = sqrt(arg1)
              ri = half*(abs0+result1)
! the grid velocity in j-direction.
              if (addgridvelocities) sface = sfacej(i, j-1, k) + sfacej(&
&                 i, j, k)
! spectral radius in j-direction.
              sx = sj(i, j-1, k, 1) + sj(i, j, k, 1)
              sy = sj(i, j-1, k, 2) + sj(i, j, k, 2)
              sz = sj(i, j-1, k, 3) + sj(i, j, k, 3)
              qsj = uux*sx + uuy*sy + uuz*sz - sface
              if (qsj .ge. 0.) then
                abs1 = qsj
              else
                abs1 = -qsj
              end if
              arg1 = cc2*(sx**2+sy**2+sz**2)
              result1 = sqrt(arg1)
              rj = half*(abs1+result1)
! the grid velocity in k-direction.
              if (addgridvelocities) sface = sfacek(i, j, k-1) + sfacek(&
&                 i, j, k)
! spectral radius in k-direction.
              sx = sk(i, j, k-1, 1) + sk(i, j, k, 1)
              sy = sk(i, j, k-1, 2) + sk(i, j, k, 2)
              sz = sk(i, j, k-1, 3) + sk(i, j, k, 3)
              qsk = uux*sx + uuy*sy + uuz*sz - sface
              if (qsk .ge. 0.) then
                abs2 = qsk
              else
                abs2 = -qsk
              end if
              arg1 = cc2*(sx**2+sy**2+sz**2)
              result1 = sqrt(arg1)
              rk = half*(abs2+result1)
! compute the inviscid contribution to the time step.
              dtl(i, j, k) = ri + rj + rk
!
!           adapt the spectral radii if directional scaling must be    
!           applied.                                                   
!
              if (doscaling) then
                if (ri .lt. eps) then
                  ri = eps
                else
                  ri = ri
                end if
                if (rj .lt. eps) then
                  rj = eps
                else
                  rj = rj
                end if
                if (rk .lt. eps) then
                  rk = eps
                else
                  rk = rk
                end if
! compute the scaling in the three coordinate
! directions.
                pwx1 = ri/rj
                rij = pwx1**adis
                pwx1 = rj/rk
                rjk = pwx1**adis
                pwx1 = rk/ri
                rki = pwx1**adis
! create the scaled versions of the aspect ratios.
! note that the multiplication is done with radi, radj
! and radk, such that the influence of the clipping
! is negligible.
                radi(i, j, k) = ri*(one+one/rij+rki)
                radj(i, j, k) = rj*(one+one/rjk+rij)
                radk(i, j, k) = rk*(one+one/rki+rjk)
              else
                radi(i, j, k) = ri
                radj(i, j, k) = rj
                radk(i, j, k) = rk
              end if
            end do
          end do
        end do
      case (turkel) 
        call terminate('timestep', &
&                'turkel preconditioner not implemented yet')
      case (choimerkle) 
        call terminate('timestep', &
&                'choi merkle preconditioner not implemented yet')
      end select
    end if
  end subroutine timestep_block
!  differentiation of gridvelocitiesfinelevel_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *sfacei *sfacej *s *sfacek
!   with respect to varying inputs: *x *si *sj *sk veldirfreestream
!                machgrid gammainf pinf timeref rhoinf
!   plus diff mem management of: sfacei:in sfacej:in s:in sfacek:in
!                x:in si:in sj:in sk:in
  subroutine gridvelocitiesfinelevel_block_d(useoldcoor, t, sps)
!
!       gridvelocitiesfinelevel computes the grid velocities for       
!       the cell centers and the normal grid velocities for the faces  
!       of moving blocks for the currently finest grid, i.e.           
!       groundlevel. the velocities are computed at time t for         
!       spectral mode sps. if useoldcoor is .true. the velocities      
!       are determined using the unsteady time integrator in           
!       combination with the old coordinates; otherwise the analytic   
!       form is used.                                                  
!
    use blockpointers
    use cgnsgrid
    use flowvarrefstate
    use inputmotion
    use inputunsteady
    use iteration
    use inputphysics
    use inputtsstabderiv
    use monitor
    use communication
    use flowutils_d, only : derivativerotmatrixrigid, &
&   derivativerotmatrixrigid_d, getdirvector, getdirvector_d
    use utils_d, only : setcoeftimeintegrator, tsalpha, tsbeta, tsmach, &
&   terminate, rotmatrixrigidbody, getdirangle, getdirangle_d
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: useoldcoor
    real(kind=realtype), dimension(*), intent(in) :: t
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm
    integer(kind=inttype) :: i, j, k, ii, iie, jje, kke
    real(kind=realtype) :: oneover4dt, oneover8dt
    real(kind=realtype) :: oneover4dtd, oneover8dtd
    real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
    real(kind=realtype) :: velxgridd, velygridd, velzgridd, ainfd
    real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
    real(kind=realtype) :: velxgrid0d, velygrid0d, velzgrid0d
    real(kind=realtype), dimension(3) :: sc, xc, xxc
    real(kind=realtype), dimension(3) :: scd, xcd, xxcd
    real(kind=realtype), dimension(3) :: rotcenter, rotrate
    real(kind=realtype), dimension(3) :: rotrated
    real(kind=realtype), dimension(3) :: rotationpoint
    real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
&   derivrotationmatrix
    real(kind=realtype), dimension(3, 3) :: derivrotationmatrixd
    real(kind=realtype) :: tnew, told
    real(kind=realtype), dimension(:, :), pointer :: sface
    real(kind=realtype), dimension(:, :), pointer :: sfaced
    real(kind=realtype), dimension(:, :, :), pointer :: xx, ss
    real(kind=realtype), dimension(:, :, :), pointer :: xxd, ssd
    real(kind=realtype), dimension(:, :, :, :), pointer :: xxold
    integer(kind=inttype) :: liftindex
    real(kind=realtype) :: alpha, beta, intervalmach, alphats, &
&   alphaincrement, betats, betaincrement
    real(kind=realtype) :: alphad, betad, alphatsd, betatsd
    real(kind=realtype), dimension(3) :: veldir
    real(kind=realtype), dimension(3) :: veldird
    real(kind=realtype), dimension(3) :: refdirection
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
! compute the mesh velocity from the given mesh mach number.
! vel{x,y,z}grid0 is the actual velocity you want at the
! geometry. 
    arg1d = ((gammainfd*pinf+gammainf*pinfd)*rhoinf-gammainf*pinf*&
&     rhoinfd)/rhoinf**2
    arg1 = gammainf*pinf/rhoinf
    if (arg1 .eq. 0.0_8) then
      ainfd = 0.0_8
    else
      ainfd = arg1d/(2.0*sqrt(arg1))
    end if
    ainf = sqrt(arg1)
    velxgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(1)) &
&     - ainf*machgrid*veldirfreestreamd(1)
    velxgrid0 = ainf*machgrid*(-veldirfreestream(1))
    velygrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(2)) &
&     - ainf*machgrid*veldirfreestreamd(2)
    velygrid0 = ainf*machgrid*(-veldirfreestream(2))
    velzgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(3)) &
&     - ainf*machgrid*veldirfreestreamd(3)
    velzgrid0 = ainf*machgrid*(-veldirfreestream(3))
! compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. it is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
    call derivativerotmatrixrigid_d(derivrotationmatrix, &
&                             derivrotationmatrixd, rotationpoint, t(1))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
    if (tsstability) then
! determine the time values of the old and new time level.
! it is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
      tnew = timeunsteady + timeunsteadyrestart
      told = tnew - t(1)
      if ((tspmode .or. tsqmode) .or. tsrmode) then
! compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
        call rotmatrixrigidbody(tnew, told, rotationmatrix, &
&                         rotationpoint)
        if (tsalphafollowing) then
          velxgrid0d = rotationmatrix(1, 1)*velxgrid0d + rotationmatrix(&
&           1, 2)*velygrid0d + rotationmatrix(1, 3)*velzgrid0d
          velxgrid0 = rotationmatrix(1, 1)*velxgrid0 + rotationmatrix(1&
&           , 2)*velygrid0 + rotationmatrix(1, 3)*velzgrid0
          velygrid0d = rotationmatrix(2, 1)*velxgrid0d + rotationmatrix(&
&           2, 2)*velygrid0d + rotationmatrix(2, 3)*velzgrid0d
          velygrid0 = rotationmatrix(2, 1)*velxgrid0 + rotationmatrix(2&
&           , 2)*velygrid0 + rotationmatrix(2, 3)*velzgrid0
          velzgrid0d = rotationmatrix(3, 1)*velxgrid0d + rotationmatrix(&
&           3, 2)*velygrid0d + rotationmatrix(3, 3)*velzgrid0d
          velzgrid0 = rotationmatrix(3, 1)*velxgrid0 + rotationmatrix(3&
&           , 2)*velygrid0 + rotationmatrix(3, 3)*velzgrid0
        end if
      else if (tsalphamode) then
! get the baseline alpha and determine the liftindex
        call getdirangle_d(veldirfreestream, veldirfreestreamd, &
&                    liftdirection, liftindex, alpha, alphad, beta, &
&                    betad)
!determine the alpha for this time instance
        alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
&         degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        alphatsd = alphad
        alphats = alpha + alphaincrement
!determine the grid velocity for this alpha
        refdirection(:) = zero
        refdirection(1) = one
        call getdirvector_d(refdirection, alphats, alphatsd, beta, betad&
&                     , veldir, veldird, liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
        velxgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(1)) - ainf&
&         *machgrid*veldird(1)
        velxgrid0 = ainf*machgrid*(-veldir(1))
        velygrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(2)) - ainf&
&         *machgrid*veldird(2)
        velygrid0 = ainf*machgrid*(-veldir(2))
        velzgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(3)) - ainf&
&         *machgrid*veldird(3)
        velzgrid0 = ainf*machgrid*(-veldir(3))
      else if (tsbetamode) then
! get the baseline alpha and determine the liftindex
        call getdirangle_d(veldirfreestream, veldirfreestreamd, &
&                    liftdirection, liftindex, alpha, alphad, beta, &
&                    betad)
!determine the alpha for this time instance
        betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
&         degreefourbeta, omegafourbeta, coscoeffourbeta, &
&         sincoeffourbeta, t(1))
        betatsd = betad
        betats = beta + betaincrement
!determine the grid velocity for this alpha
        refdirection(:) = zero
        refdirection(1) = one
        call getdirvector_d(refdirection, alpha, alphad, betats, betatsd&
&                     , veldir, veldird, liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
        velxgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(1)) - ainf&
&         *machgrid*veldird(1)
        velxgrid0 = ainf*machgrid*(-veldir(1))
        velygrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(2)) - ainf&
&         *machgrid*veldird(2)
        velygrid0 = ainf*machgrid*(-veldir(2))
        velzgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(3)) - ainf&
&         *machgrid*veldird(3)
        velzgrid0 = ainf*machgrid*(-veldir(3))
      else if (tsmachmode) then
!determine the mach number at this time interval
        intervalmach = tsmach(degreepolmach, coefpolmach, degreefourmach&
&         , omegafourmach, coscoeffourmach, sincoeffourmach, t(1))
!set the effective grid velocity
        velxgrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&         veldirfreestream(1)) - ainf*(intervalmach+machgrid)*&
&         veldirfreestreamd(1)
        velxgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(1))
        velygrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&         veldirfreestream(2)) - ainf*(intervalmach+machgrid)*&
&         veldirfreestreamd(2)
        velygrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(2))
        velzgrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&         veldirfreestream(3)) - ainf*(intervalmach+machgrid)*&
&         veldirfreestreamd(3)
        velzgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(3))
      else if (tsaltitudemode) then
        call terminate('gridvelocityfinelevel', &
&                'altitude motion not yet implemented...')
      else
        call terminate('gridvelocityfinelevel', &
&                'not a recognized stability motion')
      end if
    end if
    if (blockismoving) then
! determine the situation we are having here.
      if (useoldcoor) then
!
!             the velocities must be determined via a finite           
!             difference formula using the coordinates of the old      
!             levels.                                                  
!
! set the coefficients for the time integrator and store
! the inverse of the physical nondimensional time step,
! divided by 4 and 8, a bit easier.
        call setcoeftimeintegrator()
        oneover4dtd = fourth*timerefd/deltat
        oneover4dt = fourth*timeref/deltat
        oneover8dtd = half*oneover4dtd
        oneover8dt = half*oneover4dt
        sd = 0.0_8
        scd = 0.0_8
!
!             grid velocities of the cell centers, including the       
!             1st level halo cells.                                    
!
! loop over the cells, including the 1st level halo's.
        do k=1,ke
          do j=1,je
            do i=1,ie
! the velocity of the cell center is determined
! by a finite difference formula. first store
! the current coordinate, multiplied by 8 and
! coeftime(0) in sc.
              scd(1) = coeftime(0)*(xd(i-1, j-1, k-1, 1)+xd(i, j-1, k-1&
&               , 1)+xd(i-1, j, k-1, 1)+xd(i, j, k-1, 1)+xd(i-1, j-1, k&
&               , 1)+xd(i, j-1, k, 1)+xd(i-1, j, k, 1)+xd(i, j, k, 1))
              sc(1) = (x(i-1, j-1, k-1, 1)+x(i, j-1, k-1, 1)+x(i-1, j, k&
&               -1, 1)+x(i, j, k-1, 1)+x(i-1, j-1, k, 1)+x(i, j-1, k, 1)&
&               +x(i-1, j, k, 1)+x(i, j, k, 1))*coeftime(0)
              scd(2) = coeftime(0)*(xd(i-1, j-1, k-1, 2)+xd(i, j-1, k-1&
&               , 2)+xd(i-1, j, k-1, 2)+xd(i, j, k-1, 2)+xd(i-1, j-1, k&
&               , 2)+xd(i, j-1, k, 2)+xd(i-1, j, k, 2)+xd(i, j, k, 2))
              sc(2) = (x(i-1, j-1, k-1, 2)+x(i, j-1, k-1, 2)+x(i-1, j, k&
&               -1, 2)+x(i, j, k-1, 2)+x(i-1, j-1, k, 2)+x(i, j-1, k, 2)&
&               +x(i-1, j, k, 2)+x(i, j, k, 2))*coeftime(0)
              scd(3) = coeftime(0)*(xd(i-1, j-1, k-1, 3)+xd(i, j-1, k-1&
&               , 3)+xd(i-1, j, k-1, 3)+xd(i, j, k-1, 3)+xd(i-1, j-1, k&
&               , 3)+xd(i, j-1, k, 3)+xd(i-1, j, k, 3)+xd(i, j, k, 3))
              sc(3) = (x(i-1, j-1, k-1, 3)+x(i, j-1, k-1, 3)+x(i-1, j, k&
&               -1, 3)+x(i, j, k-1, 3)+x(i-1, j-1, k, 3)+x(i, j-1, k, 3)&
&               +x(i-1, j, k, 3)+x(i, j, k, 3))*coeftime(0)
! loop over the older levels to complete the
! finite difference formula.
              do ii=1,noldlevels
                sc(1) = sc(1) + (xold(ii, i-1, j-1, k-1, 1)+xold(ii, i, &
&                 j-1, k-1, 1)+xold(ii, i-1, j, k-1, 1)+xold(ii, i, j, k&
&                 -1, 1)+xold(ii, i-1, j-1, k, 1)+xold(ii, i, j-1, k, 1)&
&                 +xold(ii, i-1, j, k, 1)+xold(ii, i, j, k, 1))*coeftime&
&                 (ii)
                sc(2) = sc(2) + (xold(ii, i-1, j-1, k-1, 2)+xold(ii, i, &
&                 j-1, k-1, 2)+xold(ii, i-1, j, k-1, 2)+xold(ii, i, j, k&
&                 -1, 2)+xold(ii, i-1, j-1, k, 2)+xold(ii, i, j-1, k, 2)&
&                 +xold(ii, i-1, j, k, 2)+xold(ii, i, j, k, 2))*coeftime&
&                 (ii)
                sc(3) = sc(3) + (xold(ii, i-1, j-1, k-1, 3)+xold(ii, i, &
&                 j-1, k-1, 3)+xold(ii, i-1, j, k-1, 3)+xold(ii, i, j, k&
&                 -1, 3)+xold(ii, i-1, j-1, k, 3)+xold(ii, i, j-1, k, 3)&
&                 +xold(ii, i-1, j, k, 3)+xold(ii, i, j, k, 3))*coeftime&
&                 (ii)
              end do
! divide by 8 delta t to obtain the correct
! velocities.
              sd(i, j, k, 1) = scd(1)*oneover8dt + sc(1)*oneover8dtd
              s(i, j, k, 1) = sc(1)*oneover8dt
              sd(i, j, k, 2) = scd(2)*oneover8dt + sc(2)*oneover8dtd
              s(i, j, k, 2) = sc(2)*oneover8dt
              sd(i, j, k, 3) = scd(3)*oneover8dt + sc(3)*oneover8dtd
              s(i, j, k, 3) = sc(3)*oneover8dt
            end do
          end do
        end do
        sfaceid = 0.0_8
        sfacejd = 0.0_8
        sfacekd = 0.0_8
!
!             normal grid velocities of the faces.                     
!
! loop over the three directions.
loopdir:do mm=1,3
! set the upper boundaries depending on the direction.
          select case  (mm) 
          case (1_inttype) 
! normals in i-direction
            iie = ie
            jje = je
            kke = ke
          case (2_inttype) 
! normals in j-direction
            iie = je
            jje = ie
            kke = ke
          case (3_inttype) 
! normals in k-direction
            iie = ke
            jje = ie
            kke = je
          end select
!
!               normal grid velocities in generalized i-direction.     
!               mm == 1: i-direction                                   
!               mm == 2: j-direction                                   
!               mm == 3: k-direction                                   
!
          do i=0,iie
! set the pointers for the coordinates, normals and
! normal velocities for this generalized i-plane.
! this depends on the value of mm.
            select case  (mm) 
            case (1_inttype) 
! normals in i-direction
              xxd => xd(i, :, :, :)
              xx => x(i, :, :, :)
              xxold => xold(:, i, :, :, :)
              ssd => sid(i, :, :, :)
              ss => si(i, :, :, :)
              sfaced => sfaceid(i, :, :)
              sface => sfacei(i, :, :)
            case (2_inttype) 
! normals in j-direction
              xxd => xd(:, i, :, :)
              xx => x(:, i, :, :)
              xxold => xold(:, :, i, :, :)
              ssd => sjd(:, i, :, :)
              ss => sj(:, i, :, :)
              sfaced => sfacejd(:, i, :)
              sface => sfacej(:, i, :)
            case (3_inttype) 
! normals in k-direction
              xxd => xd(:, :, i, :)
              xx => x(:, :, i, :)
              xxold => xold(:, :, :, i, :)
              ssd => skd(:, :, i, :)
              ss => sk(:, :, i, :)
              sfaced => sfacekd(:, :, i)
              sface => sfacek(:, :, i)
            end select
! loop over the k and j-direction of this
! generalized i-face. note that due to the usage of
! the pointers xx and xxold an offset of +1 must be
! used in the coordinate arrays, because x and xold
! originally start at 0 for the i, j and k indices.
            do k=1,kke
              do j=1,jje
! the velocity of the face center is determined
! by a finite difference formula. first store
! the current coordinate, multiplied by 4 and
! coeftime(0) in sc.
                scd(1) = coeftime(0)*(xxd(j+1, k+1, 1)+xxd(j, k+1, 1)+&
&                 xxd(j+1, k, 1)+xxd(j, k, 1))
                sc(1) = coeftime(0)*(xx(j+1, k+1, 1)+xx(j, k+1, 1)+xx(j+&
&                 1, k, 1)+xx(j, k, 1))
                scd(2) = coeftime(0)*(xxd(j+1, k+1, 2)+xxd(j, k+1, 2)+&
&                 xxd(j+1, k, 2)+xxd(j, k, 2))
                sc(2) = coeftime(0)*(xx(j+1, k+1, 2)+xx(j, k+1, 2)+xx(j+&
&                 1, k, 2)+xx(j, k, 2))
                scd(3) = coeftime(0)*(xxd(j+1, k+1, 3)+xxd(j, k+1, 3)+&
&                 xxd(j+1, k, 3)+xxd(j, k, 3))
                sc(3) = coeftime(0)*(xx(j+1, k+1, 3)+xx(j, k+1, 3)+xx(j+&
&                 1, k, 3)+xx(j, k, 3))
! loop over the older levels to complete the
! finite difference.
                do ii=1,noldlevels
                  sc(1) = sc(1) + coeftime(ii)*(xxold(ii, j+1, k+1, 1)+&
&                   xxold(ii, j, k+1, 1)+xxold(ii, j+1, k, 1)+xxold(ii, &
&                   j, k, 1))
                  sc(2) = sc(2) + coeftime(ii)*(xxold(ii, j+1, k+1, 2)+&
&                   xxold(ii, j, k+1, 2)+xxold(ii, j+1, k, 2)+xxold(ii, &
&                   j, k, 2))
                  sc(3) = sc(3) + coeftime(ii)*(xxold(ii, j+1, k+1, 3)+&
&                   xxold(ii, j, k+1, 3)+xxold(ii, j+1, k, 3)+xxold(ii, &
&                   j, k, 3))
                end do
! determine the dot product of sc and the normal
! and divide by 4 deltat to obtain the correct
! value of the normal velocity.
                sfaced(j, k) = scd(1)*ss(j, k, 1) + sc(1)*ssd(j, k, 1) +&
&                 scd(2)*ss(j, k, 2) + sc(2)*ssd(j, k, 2) + scd(3)*ss(j&
&                 , k, 3) + sc(3)*ssd(j, k, 3)
                sface(j, k) = sc(1)*ss(j, k, 1) + sc(2)*ss(j, k, 2) + sc&
&                 (3)*ss(j, k, 3)
                sfaced(j, k) = sfaced(j, k)*oneover4dt + sface(j, k)*&
&                 oneover4dtd
                sface(j, k) = sface(j, k)*oneover4dt
              end do
            end do
          end do
        end do loopdir
      else
!
!             the velocities must be determined analytically.          
!
! store the rotation center and determine the
! nondimensional rotation rate of this block. as the
! reference length is 1 timeref == 1/uref and at the end
! the nondimensional velocity is computed.
        j = nbkglobal
        rotcenter = cgnsdoms(j)%rotcenter
        rotrated = cgnsdoms(j)%rotrate*timerefd
        rotrate = timeref*cgnsdoms(j)%rotrate
        velxgridd = velxgrid0d
        velxgrid = velxgrid0
        velygridd = velygrid0d
        velygrid = velygrid0
        velzgridd = velzgrid0d
        velzgrid = velzgrid0
        sd = 0.0_8
        xcd = 0.0_8
        xxcd = 0.0_8
        scd = 0.0_8
!
!             grid velocities of the cell centers, including the       
!             1st level halo cells.                                    
!
! loop over the cells, including the 1st level halo's.
        do k=1,ke
          do j=1,je
            do i=1,ie
! determine the coordinates of the cell center,
! which are stored in xc.
              xcd(1) = eighth*(xd(i-1, j-1, k-1, 1)+xd(i, j-1, k-1, 1)+&
&               xd(i-1, j, k-1, 1)+xd(i, j, k-1, 1)+xd(i-1, j-1, k, 1)+&
&               xd(i, j-1, k, 1)+xd(i-1, j, k, 1)+xd(i, j, k, 1))
              xc(1) = eighth*(x(i-1, j-1, k-1, 1)+x(i, j-1, k-1, 1)+x(i-&
&               1, j, k-1, 1)+x(i, j, k-1, 1)+x(i-1, j-1, k, 1)+x(i, j-1&
&               , k, 1)+x(i-1, j, k, 1)+x(i, j, k, 1))
              xcd(2) = eighth*(xd(i-1, j-1, k-1, 2)+xd(i, j-1, k-1, 2)+&
&               xd(i-1, j, k-1, 2)+xd(i, j, k-1, 2)+xd(i-1, j-1, k, 2)+&
&               xd(i, j-1, k, 2)+xd(i-1, j, k, 2)+xd(i, j, k, 2))
              xc(2) = eighth*(x(i-1, j-1, k-1, 2)+x(i, j-1, k-1, 2)+x(i-&
&               1, j, k-1, 2)+x(i, j, k-1, 2)+x(i-1, j-1, k, 2)+x(i, j-1&
&               , k, 2)+x(i-1, j, k, 2)+x(i, j, k, 2))
              xcd(3) = eighth*(xd(i-1, j-1, k-1, 3)+xd(i, j-1, k-1, 3)+&
&               xd(i-1, j, k-1, 3)+xd(i, j, k-1, 3)+xd(i-1, j-1, k, 3)+&
&               xd(i, j-1, k, 3)+xd(i-1, j, k, 3)+xd(i, j, k, 3))
              xc(3) = eighth*(x(i-1, j-1, k-1, 3)+x(i, j-1, k-1, 3)+x(i-&
&               1, j, k-1, 3)+x(i, j, k-1, 3)+x(i-1, j-1, k, 3)+x(i, j-1&
&               , k, 3)+x(i-1, j, k, 3)+x(i, j, k, 3))
! determine the coordinates relative to the
! center of rotation.
              xxcd(1) = xcd(1)
              xxc(1) = xc(1) - rotcenter(1)
              xxcd(2) = xcd(2)
              xxc(2) = xc(2) - rotcenter(2)
              xxcd(3) = xcd(3)
              xxc(3) = xc(3) - rotcenter(3)
! determine the rotation speed of the cell center,
! which is omega*r.
              scd(1) = rotrated(2)*xxc(3) + rotrate(2)*xxcd(3) - &
&               rotrated(3)*xxc(2) - rotrate(3)*xxcd(2)
              sc(1) = rotrate(2)*xxc(3) - rotrate(3)*xxc(2)
              scd(2) = rotrated(3)*xxc(1) + rotrate(3)*xxcd(1) - &
&               rotrated(1)*xxc(3) - rotrate(1)*xxcd(3)
              sc(2) = rotrate(3)*xxc(1) - rotrate(1)*xxc(3)
              scd(3) = rotrated(1)*xxc(2) + rotrate(1)*xxcd(2) - &
&               rotrated(2)*xxc(1) - rotrate(2)*xxcd(1)
              sc(3) = rotrate(1)*xxc(2) - rotrate(2)*xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
              xxcd(1) = xcd(1)
              xxc(1) = xc(1) - rotationpoint(1)
              xxcd(2) = xcd(2)
              xxc(2) = xc(2) - rotationpoint(2)
              xxcd(3) = xcd(3)
              xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell center.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
              sd(i, j, k, 1) = scd(1) + velxgridd + derivrotationmatrixd&
&               (1, 1)*xxc(1) + derivrotationmatrix(1, 1)*xxcd(1) + &
&               derivrotationmatrixd(1, 2)*xxc(2) + derivrotationmatrix(&
&               1, 2)*xxcd(2) + derivrotationmatrixd(1, 3)*xxc(3) + &
&               derivrotationmatrix(1, 3)*xxcd(3)
              s(i, j, k, 1) = sc(1) + velxgrid + derivrotationmatrix(1, &
&               1)*xxc(1) + derivrotationmatrix(1, 2)*xxc(2) + &
&               derivrotationmatrix(1, 3)*xxc(3)
              sd(i, j, k, 2) = scd(2) + velygridd + derivrotationmatrixd&
&               (2, 1)*xxc(1) + derivrotationmatrix(2, 1)*xxcd(1) + &
&               derivrotationmatrixd(2, 2)*xxc(2) + derivrotationmatrix(&
&               2, 2)*xxcd(2) + derivrotationmatrixd(2, 3)*xxc(3) + &
&               derivrotationmatrix(2, 3)*xxcd(3)
              s(i, j, k, 2) = sc(2) + velygrid + derivrotationmatrix(2, &
&               1)*xxc(1) + derivrotationmatrix(2, 2)*xxc(2) + &
&               derivrotationmatrix(2, 3)*xxc(3)
              sd(i, j, k, 3) = scd(3) + velzgridd + derivrotationmatrixd&
&               (3, 1)*xxc(1) + derivrotationmatrix(3, 1)*xxcd(1) + &
&               derivrotationmatrixd(3, 2)*xxc(2) + derivrotationmatrix(&
&               3, 2)*xxcd(2) + derivrotationmatrixd(3, 3)*xxc(3) + &
&               derivrotationmatrix(3, 3)*xxcd(3)
              s(i, j, k, 3) = sc(3) + velzgrid + derivrotationmatrix(3, &
&               1)*xxc(1) + derivrotationmatrix(3, 2)*xxc(2) + &
&               derivrotationmatrix(3, 3)*xxc(3)
            end do
          end do
        end do
        sfaceid = 0.0_8
        sfacejd = 0.0_8
        sfacekd = 0.0_8
!
!             normal grid velocities of the faces.                     
!
! loop over the three directions.
loopdirection:do mm=1,3
! set the upper boundaries depending on the direction.
          select case  (mm) 
          case (1_inttype) 
! normals in i-direction
            iie = ie
            jje = je
            kke = ke
          case (2_inttype) 
! normals in j-direction
            iie = je
            jje = ie
            kke = ke
          case (3_inttype) 
! normals in k-direction
            iie = ke
            jje = ie
            kke = je
          end select
!
!               normal grid velocities in generalized i-direction.     
!               mm == 1: i-direction                                   
!               mm == 2: j-direction                                   
!               mm == 3: k-direction                                   
!
          do i=0,iie
! set the pointers for the coordinates, normals and
! normal velocities for this generalized i-plane.
! this depends on the value of mm.
            select case  (mm) 
            case (1_inttype) 
! normals in i-direction
              xxd => xd(i, :, :, :)
              xx => x(i, :, :, :)
              ssd => sid(i, :, :, :)
              ss => si(i, :, :, :)
              sfaced => sfaceid(i, :, :)
              sface => sfacei(i, :, :)
            case (2_inttype) 
! normals in j-direction
              xxd => xd(:, i, :, :)
              xx => x(:, i, :, :)
              ssd => sjd(:, i, :, :)
              ss => sj(:, i, :, :)
              sfaced => sfacejd(:, i, :)
              sface => sfacej(:, i, :)
            case (3_inttype) 
! normals in k-direction
              xxd => xd(:, :, i, :)
              xx => x(:, :, i, :)
              ssd => skd(:, :, i, :)
              ss => sk(:, :, i, :)
              sfaced => sfacekd(:, :, i)
              sface => sfacek(:, :, i)
            end select
! loop over the k and j-direction of this generalized
! i-face. note that due to the usage of the pointer
! xx an offset of +1 must be used in the coordinate
! array, because x originally starts at 0 for the
! i, j and k indices.
            do k=1,kke
              do j=1,jje
! determine the coordinates of the face center,
! which are stored in xc.
                xcd(1) = fourth*(xxd(j+1, k+1, 1)+xxd(j, k+1, 1)+xxd(j+1&
&                 , k, 1)+xxd(j, k, 1))
                xc(1) = fourth*(xx(j+1, k+1, 1)+xx(j, k+1, 1)+xx(j+1, k&
&                 , 1)+xx(j, k, 1))
                xcd(2) = fourth*(xxd(j+1, k+1, 2)+xxd(j, k+1, 2)+xxd(j+1&
&                 , k, 2)+xxd(j, k, 2))
                xc(2) = fourth*(xx(j+1, k+1, 2)+xx(j, k+1, 2)+xx(j+1, k&
&                 , 2)+xx(j, k, 2))
                xcd(3) = fourth*(xxd(j+1, k+1, 3)+xxd(j, k+1, 3)+xxd(j+1&
&                 , k, 3)+xxd(j, k, 3))
                xc(3) = fourth*(xx(j+1, k+1, 3)+xx(j, k+1, 3)+xx(j+1, k&
&                 , 3)+xx(j, k, 3))
! determine the coordinates relative to the
! center of rotation.
                xxcd(1) = xcd(1)
                xxc(1) = xc(1) - rotcenter(1)
                xxcd(2) = xcd(2)
                xxc(2) = xc(2) - rotcenter(2)
                xxcd(3) = xcd(3)
                xxc(3) = xc(3) - rotcenter(3)
! determine the rotation speed of the face center,
! which is omega*r.
                scd(1) = rotrated(2)*xxc(3) + rotrate(2)*xxcd(3) - &
&                 rotrated(3)*xxc(2) - rotrate(3)*xxcd(2)
                sc(1) = rotrate(2)*xxc(3) - rotrate(3)*xxc(2)
                scd(2) = rotrated(3)*xxc(1) + rotrate(3)*xxcd(1) - &
&                 rotrated(1)*xxc(3) - rotrate(1)*xxcd(3)
                sc(2) = rotrate(3)*xxc(1) - rotrate(1)*xxc(3)
                scd(3) = rotrated(1)*xxc(2) + rotrate(1)*xxcd(2) - &
&                 rotrated(2)*xxc(1) - rotrate(2)*xxcd(1)
                sc(3) = rotrate(1)*xxc(2) - rotrate(2)*xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
                xxcd(1) = xcd(1)
                xxc(1) = xc(1) - rotationpoint(1)
                xxcd(2) = xcd(2)
                xxc(2) = xc(2) - rotationpoint(2)
                xxcd(3) = xcd(3)
                xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell face.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
                scd(1) = scd(1) + velxgridd + derivrotationmatrixd(1, 1)&
&                 *xxc(1) + derivrotationmatrix(1, 1)*xxcd(1) + &
&                 derivrotationmatrixd(1, 2)*xxc(2) + &
&                 derivrotationmatrix(1, 2)*xxcd(2) + &
&                 derivrotationmatrixd(1, 3)*xxc(3) + &
&                 derivrotationmatrix(1, 3)*xxcd(3)
                sc(1) = sc(1) + velxgrid + derivrotationmatrix(1, 1)*xxc&
&                 (1) + derivrotationmatrix(1, 2)*xxc(2) + &
&                 derivrotationmatrix(1, 3)*xxc(3)
                scd(2) = scd(2) + velygridd + derivrotationmatrixd(2, 1)&
&                 *xxc(1) + derivrotationmatrix(2, 1)*xxcd(1) + &
&                 derivrotationmatrixd(2, 2)*xxc(2) + &
&                 derivrotationmatrix(2, 2)*xxcd(2) + &
&                 derivrotationmatrixd(2, 3)*xxc(3) + &
&                 derivrotationmatrix(2, 3)*xxcd(3)
                sc(2) = sc(2) + velygrid + derivrotationmatrix(2, 1)*xxc&
&                 (1) + derivrotationmatrix(2, 2)*xxc(2) + &
&                 derivrotationmatrix(2, 3)*xxc(3)
                scd(3) = scd(3) + velzgridd + derivrotationmatrixd(3, 1)&
&                 *xxc(1) + derivrotationmatrix(3, 1)*xxcd(1) + &
&                 derivrotationmatrixd(3, 2)*xxc(2) + &
&                 derivrotationmatrix(3, 2)*xxcd(2) + &
&                 derivrotationmatrixd(3, 3)*xxc(3) + &
&                 derivrotationmatrix(3, 3)*xxcd(3)
                sc(3) = sc(3) + velzgrid + derivrotationmatrix(3, 1)*xxc&
&                 (1) + derivrotationmatrix(3, 2)*xxc(2) + &
&                 derivrotationmatrix(3, 3)*xxc(3)
! store the dot product of grid velocity sc and
! the normal ss in sface.
                sfaced(j, k) = scd(1)*ss(j, k, 1) + sc(1)*ssd(j, k, 1) +&
&                 scd(2)*ss(j, k, 2) + sc(2)*ssd(j, k, 2) + scd(3)*ss(j&
&                 , k, 3) + sc(3)*ssd(j, k, 3)
                sface(j, k) = sc(1)*ss(j, k, 1) + sc(2)*ss(j, k, 2) + sc&
&                 (3)*ss(j, k, 3)
              end do
            end do
          end do
        end do loopdirection
      end if
    else
      sfaceid = 0.0_8
      sfacejd = 0.0_8
      sd = 0.0_8
      sfacekd = 0.0_8
    end if
  end subroutine gridvelocitiesfinelevel_block_d
  subroutine gridvelocitiesfinelevel_block(useoldcoor, t, sps)
!
!       gridvelocitiesfinelevel computes the grid velocities for       
!       the cell centers and the normal grid velocities for the faces  
!       of moving blocks for the currently finest grid, i.e.           
!       groundlevel. the velocities are computed at time t for         
!       spectral mode sps. if useoldcoor is .true. the velocities      
!       are determined using the unsteady time integrator in           
!       combination with the old coordinates; otherwise the analytic   
!       form is used.                                                  
!
    use blockpointers
    use cgnsgrid
    use flowvarrefstate
    use inputmotion
    use inputunsteady
    use iteration
    use inputphysics
    use inputtsstabderiv
    use monitor
    use communication
    use flowutils_d, only : derivativerotmatrixrigid, getdirvector
    use utils_d, only : setcoeftimeintegrator, tsalpha, tsbeta, tsmach, &
&   terminate, rotmatrixrigidbody, getdirangle
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: useoldcoor
    real(kind=realtype), dimension(*), intent(in) :: t
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm
    integer(kind=inttype) :: i, j, k, ii, iie, jje, kke
    real(kind=realtype) :: oneover4dt, oneover8dt
    real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
    real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
    real(kind=realtype), dimension(3) :: sc, xc, xxc
    real(kind=realtype), dimension(3) :: rotcenter, rotrate
    real(kind=realtype), dimension(3) :: rotationpoint
    real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
&   derivrotationmatrix
    real(kind=realtype) :: tnew, told
    real(kind=realtype), dimension(:, :), pointer :: sface
    real(kind=realtype), dimension(:, :, :), pointer :: xx, ss
    real(kind=realtype), dimension(:, :, :, :), pointer :: xxold
    integer(kind=inttype) :: liftindex
    real(kind=realtype) :: alpha, beta, intervalmach, alphats, &
&   alphaincrement, betats, betaincrement
    real(kind=realtype), dimension(3) :: veldir
    real(kind=realtype), dimension(3) :: refdirection
    intrinsic sqrt
    real(kind=realtype) :: arg1
! compute the mesh velocity from the given mesh mach number.
! vel{x,y,z}grid0 is the actual velocity you want at the
! geometry. 
    arg1 = gammainf*pinf/rhoinf
    ainf = sqrt(arg1)
    velxgrid0 = ainf*machgrid*(-veldirfreestream(1))
    velygrid0 = ainf*machgrid*(-veldirfreestream(2))
    velzgrid0 = ainf*machgrid*(-veldirfreestream(3))
! compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. it is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
    call derivativerotmatrixrigid(derivrotationmatrix, rotationpoint, t(&
&                           1))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
    if (tsstability) then
! determine the time values of the old and new time level.
! it is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
      tnew = timeunsteady + timeunsteadyrestart
      told = tnew - t(1)
      if ((tspmode .or. tsqmode) .or. tsrmode) then
! compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
        call rotmatrixrigidbody(tnew, told, rotationmatrix, &
&                         rotationpoint)
        if (tsalphafollowing) then
          velxgrid0 = rotationmatrix(1, 1)*velxgrid0 + rotationmatrix(1&
&           , 2)*velygrid0 + rotationmatrix(1, 3)*velzgrid0
          velygrid0 = rotationmatrix(2, 1)*velxgrid0 + rotationmatrix(2&
&           , 2)*velygrid0 + rotationmatrix(2, 3)*velzgrid0
          velzgrid0 = rotationmatrix(3, 1)*velxgrid0 + rotationmatrix(3&
&           , 2)*velygrid0 + rotationmatrix(3, 3)*velzgrid0
        end if
      else if (tsalphamode) then
! get the baseline alpha and determine the liftindex
        call getdirangle(veldirfreestream, liftdirection, liftindex, &
&                  alpha, beta)
!determine the alpha for this time instance
        alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
&         degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        alphats = alpha + alphaincrement
!determine the grid velocity for this alpha
        refdirection(:) = zero
        refdirection(1) = one
        call getdirvector(refdirection, alphats, beta, veldir, liftindex&
&                  )
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
        velxgrid0 = ainf*machgrid*(-veldir(1))
        velygrid0 = ainf*machgrid*(-veldir(2))
        velzgrid0 = ainf*machgrid*(-veldir(3))
      else if (tsbetamode) then
! get the baseline alpha and determine the liftindex
        call getdirangle(veldirfreestream, liftdirection, liftindex, &
&                  alpha, beta)
!determine the alpha for this time instance
        betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
&         degreefourbeta, omegafourbeta, coscoeffourbeta, &
&         sincoeffourbeta, t(1))
        betats = beta + betaincrement
!determine the grid velocity for this alpha
        refdirection(:) = zero
        refdirection(1) = one
        call getdirvector(refdirection, alpha, betats, veldir, liftindex&
&                  )
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
        velxgrid0 = ainf*machgrid*(-veldir(1))
        velygrid0 = ainf*machgrid*(-veldir(2))
        velzgrid0 = ainf*machgrid*(-veldir(3))
      else if (tsmachmode) then
!determine the mach number at this time interval
        intervalmach = tsmach(degreepolmach, coefpolmach, degreefourmach&
&         , omegafourmach, coscoeffourmach, sincoeffourmach, t(1))
!set the effective grid velocity
        velxgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(1))
        velygrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(2))
        velzgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(3))
      else if (tsaltitudemode) then
        call terminate('gridvelocityfinelevel', &
&                'altitude motion not yet implemented...')
      else
        call terminate('gridvelocityfinelevel', &
&                'not a recognized stability motion')
      end if
    end if
    if (blockismoving) then
! determine the situation we are having here.
      if (useoldcoor) then
!
!             the velocities must be determined via a finite           
!             difference formula using the coordinates of the old      
!             levels.                                                  
!
! set the coefficients for the time integrator and store
! the inverse of the physical nondimensional time step,
! divided by 4 and 8, a bit easier.
        call setcoeftimeintegrator()
        oneover4dt = fourth*timeref/deltat
        oneover8dt = half*oneover4dt
!
!             grid velocities of the cell centers, including the       
!             1st level halo cells.                                    
!
! loop over the cells, including the 1st level halo's.
        do k=1,ke
          do j=1,je
            do i=1,ie
! the velocity of the cell center is determined
! by a finite difference formula. first store
! the current coordinate, multiplied by 8 and
! coeftime(0) in sc.
              sc(1) = (x(i-1, j-1, k-1, 1)+x(i, j-1, k-1, 1)+x(i-1, j, k&
&               -1, 1)+x(i, j, k-1, 1)+x(i-1, j-1, k, 1)+x(i, j-1, k, 1)&
&               +x(i-1, j, k, 1)+x(i, j, k, 1))*coeftime(0)
              sc(2) = (x(i-1, j-1, k-1, 2)+x(i, j-1, k-1, 2)+x(i-1, j, k&
&               -1, 2)+x(i, j, k-1, 2)+x(i-1, j-1, k, 2)+x(i, j-1, k, 2)&
&               +x(i-1, j, k, 2)+x(i, j, k, 2))*coeftime(0)
              sc(3) = (x(i-1, j-1, k-1, 3)+x(i, j-1, k-1, 3)+x(i-1, j, k&
&               -1, 3)+x(i, j, k-1, 3)+x(i-1, j-1, k, 3)+x(i, j-1, k, 3)&
&               +x(i-1, j, k, 3)+x(i, j, k, 3))*coeftime(0)
! loop over the older levels to complete the
! finite difference formula.
              do ii=1,noldlevels
                sc(1) = sc(1) + (xold(ii, i-1, j-1, k-1, 1)+xold(ii, i, &
&                 j-1, k-1, 1)+xold(ii, i-1, j, k-1, 1)+xold(ii, i, j, k&
&                 -1, 1)+xold(ii, i-1, j-1, k, 1)+xold(ii, i, j-1, k, 1)&
&                 +xold(ii, i-1, j, k, 1)+xold(ii, i, j, k, 1))*coeftime&
&                 (ii)
                sc(2) = sc(2) + (xold(ii, i-1, j-1, k-1, 2)+xold(ii, i, &
&                 j-1, k-1, 2)+xold(ii, i-1, j, k-1, 2)+xold(ii, i, j, k&
&                 -1, 2)+xold(ii, i-1, j-1, k, 2)+xold(ii, i, j-1, k, 2)&
&                 +xold(ii, i-1, j, k, 2)+xold(ii, i, j, k, 2))*coeftime&
&                 (ii)
                sc(3) = sc(3) + (xold(ii, i-1, j-1, k-1, 3)+xold(ii, i, &
&                 j-1, k-1, 3)+xold(ii, i-1, j, k-1, 3)+xold(ii, i, j, k&
&                 -1, 3)+xold(ii, i-1, j-1, k, 3)+xold(ii, i, j-1, k, 3)&
&                 +xold(ii, i-1, j, k, 3)+xold(ii, i, j, k, 3))*coeftime&
&                 (ii)
              end do
! divide by 8 delta t to obtain the correct
! velocities.
              s(i, j, k, 1) = sc(1)*oneover8dt
              s(i, j, k, 2) = sc(2)*oneover8dt
              s(i, j, k, 3) = sc(3)*oneover8dt
            end do
          end do
        end do
!
!             normal grid velocities of the faces.                     
!
! loop over the three directions.
loopdir:do mm=1,3
! set the upper boundaries depending on the direction.
          select case  (mm) 
          case (1_inttype) 
! normals in i-direction
            iie = ie
            jje = je
            kke = ke
          case (2_inttype) 
! normals in j-direction
            iie = je
            jje = ie
            kke = ke
          case (3_inttype) 
! normals in k-direction
            iie = ke
            jje = ie
            kke = je
          end select
!
!               normal grid velocities in generalized i-direction.     
!               mm == 1: i-direction                                   
!               mm == 2: j-direction                                   
!               mm == 3: k-direction                                   
!
          do i=0,iie
! set the pointers for the coordinates, normals and
! normal velocities for this generalized i-plane.
! this depends on the value of mm.
            select case  (mm) 
            case (1_inttype) 
! normals in i-direction
              xx => x(i, :, :, :)
              xxold => xold(:, i, :, :, :)
              ss => si(i, :, :, :)
              sface => sfacei(i, :, :)
            case (2_inttype) 
! normals in j-direction
              xx => x(:, i, :, :)
              xxold => xold(:, :, i, :, :)
              ss => sj(:, i, :, :)
              sface => sfacej(:, i, :)
            case (3_inttype) 
! normals in k-direction
              xx => x(:, :, i, :)
              xxold => xold(:, :, :, i, :)
              ss => sk(:, :, i, :)
              sface => sfacek(:, :, i)
            end select
! loop over the k and j-direction of this
! generalized i-face. note that due to the usage of
! the pointers xx and xxold an offset of +1 must be
! used in the coordinate arrays, because x and xold
! originally start at 0 for the i, j and k indices.
            do k=1,kke
              do j=1,jje
! the velocity of the face center is determined
! by a finite difference formula. first store
! the current coordinate, multiplied by 4 and
! coeftime(0) in sc.
                sc(1) = coeftime(0)*(xx(j+1, k+1, 1)+xx(j, k+1, 1)+xx(j+&
&                 1, k, 1)+xx(j, k, 1))
                sc(2) = coeftime(0)*(xx(j+1, k+1, 2)+xx(j, k+1, 2)+xx(j+&
&                 1, k, 2)+xx(j, k, 2))
                sc(3) = coeftime(0)*(xx(j+1, k+1, 3)+xx(j, k+1, 3)+xx(j+&
&                 1, k, 3)+xx(j, k, 3))
! loop over the older levels to complete the
! finite difference.
                do ii=1,noldlevels
                  sc(1) = sc(1) + coeftime(ii)*(xxold(ii, j+1, k+1, 1)+&
&                   xxold(ii, j, k+1, 1)+xxold(ii, j+1, k, 1)+xxold(ii, &
&                   j, k, 1))
                  sc(2) = sc(2) + coeftime(ii)*(xxold(ii, j+1, k+1, 2)+&
&                   xxold(ii, j, k+1, 2)+xxold(ii, j+1, k, 2)+xxold(ii, &
&                   j, k, 2))
                  sc(3) = sc(3) + coeftime(ii)*(xxold(ii, j+1, k+1, 3)+&
&                   xxold(ii, j, k+1, 3)+xxold(ii, j+1, k, 3)+xxold(ii, &
&                   j, k, 3))
                end do
! determine the dot product of sc and the normal
! and divide by 4 deltat to obtain the correct
! value of the normal velocity.
                sface(j, k) = sc(1)*ss(j, k, 1) + sc(2)*ss(j, k, 2) + sc&
&                 (3)*ss(j, k, 3)
                sface(j, k) = sface(j, k)*oneover4dt
              end do
            end do
          end do
        end do loopdir
      else
!
!             the velocities must be determined analytically.          
!
! store the rotation center and determine the
! nondimensional rotation rate of this block. as the
! reference length is 1 timeref == 1/uref and at the end
! the nondimensional velocity is computed.
        j = nbkglobal
        rotcenter = cgnsdoms(j)%rotcenter
        rotrate = timeref*cgnsdoms(j)%rotrate
        velxgrid = velxgrid0
        velygrid = velygrid0
        velzgrid = velzgrid0
!
!             grid velocities of the cell centers, including the       
!             1st level halo cells.                                    
!
! loop over the cells, including the 1st level halo's.
        do k=1,ke
          do j=1,je
            do i=1,ie
! determine the coordinates of the cell center,
! which are stored in xc.
              xc(1) = eighth*(x(i-1, j-1, k-1, 1)+x(i, j-1, k-1, 1)+x(i-&
&               1, j, k-1, 1)+x(i, j, k-1, 1)+x(i-1, j-1, k, 1)+x(i, j-1&
&               , k, 1)+x(i-1, j, k, 1)+x(i, j, k, 1))
              xc(2) = eighth*(x(i-1, j-1, k-1, 2)+x(i, j-1, k-1, 2)+x(i-&
&               1, j, k-1, 2)+x(i, j, k-1, 2)+x(i-1, j-1, k, 2)+x(i, j-1&
&               , k, 2)+x(i-1, j, k, 2)+x(i, j, k, 2))
              xc(3) = eighth*(x(i-1, j-1, k-1, 3)+x(i, j-1, k-1, 3)+x(i-&
&               1, j, k-1, 3)+x(i, j, k-1, 3)+x(i-1, j-1, k, 3)+x(i, j-1&
&               , k, 3)+x(i-1, j, k, 3)+x(i, j, k, 3))
! determine the coordinates relative to the
! center of rotation.
              xxc(1) = xc(1) - rotcenter(1)
              xxc(2) = xc(2) - rotcenter(2)
              xxc(3) = xc(3) - rotcenter(3)
! determine the rotation speed of the cell center,
! which is omega*r.
              sc(1) = rotrate(2)*xxc(3) - rotrate(3)*xxc(2)
              sc(2) = rotrate(3)*xxc(1) - rotrate(1)*xxc(3)
              sc(3) = rotrate(1)*xxc(2) - rotrate(2)*xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
              xxc(1) = xc(1) - rotationpoint(1)
              xxc(2) = xc(2) - rotationpoint(2)
              xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell center.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
              s(i, j, k, 1) = sc(1) + velxgrid + derivrotationmatrix(1, &
&               1)*xxc(1) + derivrotationmatrix(1, 2)*xxc(2) + &
&               derivrotationmatrix(1, 3)*xxc(3)
              s(i, j, k, 2) = sc(2) + velygrid + derivrotationmatrix(2, &
&               1)*xxc(1) + derivrotationmatrix(2, 2)*xxc(2) + &
&               derivrotationmatrix(2, 3)*xxc(3)
              s(i, j, k, 3) = sc(3) + velzgrid + derivrotationmatrix(3, &
&               1)*xxc(1) + derivrotationmatrix(3, 2)*xxc(2) + &
&               derivrotationmatrix(3, 3)*xxc(3)
            end do
          end do
        end do
!
!             normal grid velocities of the faces.                     
!
! loop over the three directions.
loopdirection:do mm=1,3
! set the upper boundaries depending on the direction.
          select case  (mm) 
          case (1_inttype) 
! normals in i-direction
            iie = ie
            jje = je
            kke = ke
          case (2_inttype) 
! normals in j-direction
            iie = je
            jje = ie
            kke = ke
          case (3_inttype) 
! normals in k-direction
            iie = ke
            jje = ie
            kke = je
          end select
!
!               normal grid velocities in generalized i-direction.     
!               mm == 1: i-direction                                   
!               mm == 2: j-direction                                   
!               mm == 3: k-direction                                   
!
          do i=0,iie
! set the pointers for the coordinates, normals and
! normal velocities for this generalized i-plane.
! this depends on the value of mm.
            select case  (mm) 
            case (1_inttype) 
! normals in i-direction
              xx => x(i, :, :, :)
              ss => si(i, :, :, :)
              sface => sfacei(i, :, :)
            case (2_inttype) 
! normals in j-direction
              xx => x(:, i, :, :)
              ss => sj(:, i, :, :)
              sface => sfacej(:, i, :)
            case (3_inttype) 
! normals in k-direction
              xx => x(:, :, i, :)
              ss => sk(:, :, i, :)
              sface => sfacek(:, :, i)
            end select
! loop over the k and j-direction of this generalized
! i-face. note that due to the usage of the pointer
! xx an offset of +1 must be used in the coordinate
! array, because x originally starts at 0 for the
! i, j and k indices.
            do k=1,kke
              do j=1,jje
! determine the coordinates of the face center,
! which are stored in xc.
                xc(1) = fourth*(xx(j+1, k+1, 1)+xx(j, k+1, 1)+xx(j+1, k&
&                 , 1)+xx(j, k, 1))
                xc(2) = fourth*(xx(j+1, k+1, 2)+xx(j, k+1, 2)+xx(j+1, k&
&                 , 2)+xx(j, k, 2))
                xc(3) = fourth*(xx(j+1, k+1, 3)+xx(j, k+1, 3)+xx(j+1, k&
&                 , 3)+xx(j, k, 3))
! determine the coordinates relative to the
! center of rotation.
                xxc(1) = xc(1) - rotcenter(1)
                xxc(2) = xc(2) - rotcenter(2)
                xxc(3) = xc(3) - rotcenter(3)
! determine the rotation speed of the face center,
! which is omega*r.
                sc(1) = rotrate(2)*xxc(3) - rotrate(3)*xxc(2)
                sc(2) = rotrate(3)*xxc(1) - rotrate(1)*xxc(3)
                sc(3) = rotrate(1)*xxc(2) - rotrate(2)*xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
                xxc(1) = xc(1) - rotationpoint(1)
                xxc(2) = xc(2) - rotationpoint(2)
                xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell face.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
                sc(1) = sc(1) + velxgrid + derivrotationmatrix(1, 1)*xxc&
&                 (1) + derivrotationmatrix(1, 2)*xxc(2) + &
&                 derivrotationmatrix(1, 3)*xxc(3)
                sc(2) = sc(2) + velygrid + derivrotationmatrix(2, 1)*xxc&
&                 (1) + derivrotationmatrix(2, 2)*xxc(2) + &
&                 derivrotationmatrix(2, 3)*xxc(3)
                sc(3) = sc(3) + velzgrid + derivrotationmatrix(3, 1)*xxc&
&                 (1) + derivrotationmatrix(3, 2)*xxc(2) + &
&                 derivrotationmatrix(3, 3)*xxc(3)
! store the dot product of grid velocity sc and
! the normal ss in sface.
                sface(j, k) = sc(1)*ss(j, k, 1) + sc(2)*ss(j, k, 2) + sc&
&                 (3)*ss(j, k, 3)
              end do
            end do
          end do
        end do loopdirection
      end if
    end if
  end subroutine gridvelocitiesfinelevel_block
!  differentiation of slipvelocitiesfinelevel_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.uslip)
!   with respect to varying inputs: *x veldirfreestream machgrid
!                gammainf pinf timeref rhoinf
!   plus diff mem management of: x:in bcdata:in *bcdata.uslip:in
  subroutine slipvelocitiesfinelevel_block_d(useoldcoor, t, sps)
!
!       slipvelocitiesfinelevel computes the slip velocities for       
!       viscous subfaces on all viscous boundaries on groundlevel for  
!       the given spectral solution. if useoldcoor is .true. the       
!       velocities are determined using the unsteady time integrator;  
!       otherwise the analytic form is used.                           
!
    use constants
    use inputtimespectral
    use blockpointers
    use cgnsgrid
    use flowvarrefstate
    use inputmotion
    use inputunsteady
    use iteration
    use inputphysics
    use inputtsstabderiv
    use monitor
    use communication
    use flowutils_d, only : derivativerotmatrixrigid, &
&   derivativerotmatrixrigid_d, getdirvector, getdirvector_d
    use utils_d, only : tsalpha, tsbeta, tsmach, terminate, &
&   rotmatrixrigidbody, setcoeftimeintegrator, getdirangle, &
&   getdirangle_d
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: useoldcoor
    real(kind=realtype), dimension(*), intent(in) :: t
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm, i, j, level
    real(kind=realtype) :: oneover4dt
    real(kind=realtype) :: oneover4dtd
    real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
    real(kind=realtype) :: velxgridd, velygridd, velzgridd, ainfd
    real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
    real(kind=realtype) :: velxgrid0d, velygrid0d, velzgrid0d
    real(kind=realtype), dimension(3) :: xc, xxc
    real(kind=realtype), dimension(3) :: xcd, xxcd
    real(kind=realtype), dimension(3) :: rotcenter, rotrate
    real(kind=realtype), dimension(3) :: rotrated
    real(kind=realtype), dimension(3) :: rotationpoint
    real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
&   derivrotationmatrix
    real(kind=realtype), dimension(3, 3) :: derivrotationmatrixd
    real(kind=realtype) :: tnew, told
    real(kind=realtype), dimension(:, :, :), pointer :: uslip
    real(kind=realtype), dimension(:, :, :), pointer :: uslipd
    real(kind=realtype), dimension(:, :, :), pointer :: xface
    real(kind=realtype), dimension(:, :, :), pointer :: xfaced
    real(kind=realtype), dimension(:, :, :, :), pointer :: xfaceold
    integer(kind=inttype) :: liftindex
    real(kind=realtype) :: alpha, beta, intervalmach, alphats, &
&   alphaincrement, betats, betaincrement
    real(kind=realtype) :: alphad, betad, alphatsd, betatsd
    real(kind=realtype), dimension(3) :: veldir
    real(kind=realtype), dimension(3) :: veldird
    real(kind=realtype), dimension(3) :: refdirection
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: ii1
! determine the situation we are having here.
    if (useoldcoor) then
! the velocities must be determined via a finite difference
! formula using the coordinates of the old levels.
! set the coefficients for the time integrator and store the
! inverse of the physical nondimensional time step, divided
! by 4, a bit easier.
      call setcoeftimeintegrator()
      oneover4dtd = fourth*timerefd/deltat
      oneover4dt = fourth*timeref/deltat
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%uslip = 0.0_8
      end do
      xcd = 0.0_8
! loop over the number of viscous subfaces.
bocoloop1:do mm=1,nviscbocos
! set the pointer for uslip to make the code more
! readable.
        uslipd => bcdatad(mm)%uslip
        uslip => bcdata(mm)%uslip
! determine the grid face on which the subface is located
! and set some variables accordingly.
        select case  (bcfaceid(mm)) 
        case (imin) 
          xfaced => xd(1, :, :, :)
          xface => x(1, :, :, :)
          xfaceold => xold(:, 1, :, :, :)
        case (imax) 
          xfaced => xd(il, :, :, :)
          xface => x(il, :, :, :)
          xfaceold => xold(:, il, :, :, :)
        case (jmin) 
          xfaced => xd(:, 1, :, :)
          xface => x(:, 1, :, :)
          xfaceold => xold(:, :, 1, :, :)
        case (jmax) 
          xfaced => xd(:, jl, :, :)
          xface => x(:, jl, :, :)
          xfaceold => xold(:, :, jl, :, :)
        case (kmin) 
          xfaced => xd(:, :, 1, :)
          xface => x(:, :, 1, :)
          xfaceold => xold(:, :, :, 1, :)
        case (kmax) 
          xfaced => xd(:, :, kl, :)
          xface => x(:, :, kl, :)
          xfaceold => xold(:, :, :, kl, :)
        end select
! some boundary faces have a different rotation speed than
! the corresponding block. this happens e.g. in the tip gap
! region of turbomachinary problems where the casing does
! not rotate. as the coordinate difference corresponds to
! the rotation rate of the block, a correction must be
! computed. therefore compute the difference in rotation
! rate and store the rotation center a bit easier. note that
! the rotation center of subface is taken, because if there
! is a difference in rotation rate this info for the subface
! must always be specified.
        j = nbkglobal
        i = cgnssubface(mm)
        rotcenter = cgnsdoms(j)%bocoinfo(i)%rotcenter
        rotrated = (cgnsdoms(j)%bocoinfo(i)%rotrate-cgnsdoms(j)%rotrate)&
&         *timerefd
        rotrate = timeref*(cgnsdoms(j)%bocoinfo(i)%rotrate-cgnsdoms(j)%&
&         rotrate)
! loop over the quadrilateral faces of the viscous subface.
! note that due to the usage of the pointers xface and
! xfaceold an offset of +1 must be used in the coordinate
! arrays, because x and xold originally start at 0 for the
! i, j and k indices.
        do j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
          do i=bcdata(mm)%icbeg,bcdata(mm)%icend
! determine the coordinates of the centroid of the
! face, multiplied by 4.
            xcd(1) = xfaced(i+1, j+1, 1) + xfaced(i+1, j, 1) + xfaced(i&
&             , j+1, 1) + xfaced(i, j, 1)
            xc(1) = xface(i+1, j+1, 1) + xface(i+1, j, 1) + xface(i, j+1&
&             , 1) + xface(i, j, 1)
            xcd(2) = xfaced(i+1, j+1, 2) + xfaced(i+1, j, 2) + xfaced(i&
&             , j+1, 2) + xfaced(i, j, 2)
            xc(2) = xface(i+1, j+1, 2) + xface(i+1, j, 2) + xface(i, j+1&
&             , 2) + xface(i, j, 2)
            xcd(3) = xfaced(i+1, j+1, 3) + xfaced(i+1, j, 3) + xfaced(i&
&             , j+1, 3) + xfaced(i, j, 3)
            xc(3) = xface(i+1, j+1, 3) + xface(i+1, j, 3) + xface(i, j+1&
&             , 3) + xface(i, j, 3)
! multiply the sum of the 4 vertex coordinates with
! coeftime(0) to obtain the contribution for the
! current time level. the division by 4*deltat will
! take place later. this is both more efficient and
! more accurate for extremely small time steps.
            uslipd(i, j, 1) = coeftime(0)*xcd(1)
            uslip(i, j, 1) = coeftime(0)*xc(1)
            uslipd(i, j, 2) = coeftime(0)*xcd(2)
            uslip(i, j, 2) = coeftime(0)*xc(2)
            uslipd(i, j, 3) = coeftime(0)*xcd(3)
            uslip(i, j, 3) = coeftime(0)*xc(3)
! loop over the older time levels and take their
! contribution into account.
            do level=1,noldlevels
              uslip(i, j, 1) = uslip(i, j, 1) + coeftime(level)*(&
&               xfaceold(level, i+1, j+1, 1)+xfaceold(level, i+1, j, 1)+&
&               xfaceold(level, i, j+1, 1)+xfaceold(level, i, j, 1))
              uslip(i, j, 2) = uslip(i, j, 2) + coeftime(level)*(&
&               xfaceold(level, i+1, j+1, 2)+xfaceold(level, i+1, j, 2)+&
&               xfaceold(level, i, j+1, 2)+xfaceold(level, i, j, 2))
              uslip(i, j, 3) = uslip(i, j, 3) + coeftime(level)*(&
&               xfaceold(level, i+1, j+1, 3)+xfaceold(level, i+1, j, 3)+&
&               xfaceold(level, i, j+1, 3)+xfaceold(level, i, j, 3))
            end do
! divide by 4 times the time step to obtain the
! correct velocity.
            uslipd(i, j, 1) = uslipd(i, j, 1)*oneover4dt + uslip(i, j, 1&
&             )*oneover4dtd
            uslip(i, j, 1) = uslip(i, j, 1)*oneover4dt
            uslipd(i, j, 2) = uslipd(i, j, 2)*oneover4dt + uslip(i, j, 2&
&             )*oneover4dtd
            uslip(i, j, 2) = uslip(i, j, 2)*oneover4dt
            uslipd(i, j, 3) = uslipd(i, j, 3)*oneover4dt + uslip(i, j, 3&
&             )*oneover4dtd
            uslip(i, j, 3) = uslip(i, j, 3)*oneover4dt
! determine the correction due to the difference
! in rotation rate between the block and subface.
! first determine the coordinates relative to the
! rotation center. remember that 4 times this value
! is currently stored in xc.
            xcd(1) = fourth*xcd(1)
            xc(1) = fourth*xc(1) - rotcenter(1)
            xcd(2) = fourth*xcd(2)
            xc(2) = fourth*xc(2) - rotcenter(2)
            xcd(3) = fourth*xcd(3)
            xc(3) = fourth*xc(3) - rotcenter(3)
! compute the velocity, which is the cross product
! of rotrate and xc and add it to uslip.
            uslipd(i, j, 1) = uslipd(i, j, 1) + rotrated(2)*xc(3) + &
&             rotrate(2)*xcd(3) - rotrated(3)*xc(2) - rotrate(3)*xcd(2)
            uslip(i, j, 1) = uslip(i, j, 1) + rotrate(2)*xc(3) - rotrate&
&             (3)*xc(2)
            uslipd(i, j, 2) = uslipd(i, j, 2) + rotrated(3)*xc(1) + &
&             rotrate(3)*xcd(1) - rotrated(1)*xc(3) - rotrate(1)*xcd(3)
            uslip(i, j, 2) = uslip(i, j, 2) + rotrate(3)*xc(1) - rotrate&
&             (1)*xc(3)
            uslipd(i, j, 3) = uslipd(i, j, 3) + rotrated(1)*xc(2) + &
&             rotrate(1)*xcd(2) - rotrated(2)*xc(1) - rotrate(2)*xcd(1)
            uslip(i, j, 3) = uslip(i, j, 3) + rotrate(1)*xc(2) - rotrate&
&             (2)*xc(1)
          end do
        end do
      end do bocoloop1
    else
! the velocities must be determined analytically.
! compute the mesh velocity from the given mesh mach number.
!  ainf = sqrt(gammainf*pinf/rhoinf)
!  velxgrid = ainf*machgrid(1)
!  velygrid = ainf*machgrid(2)
!  velzgrid = ainf*machgrid(3)
      arg1d = ((gammainfd*pinf+gammainf*pinfd)*rhoinf-gammainf*pinf*&
&       rhoinfd)/rhoinf**2
      arg1 = gammainf*pinf/rhoinf
      if (arg1 .eq. 0.0_8) then
        ainfd = 0.0_8
      else
        ainfd = arg1d/(2.0*sqrt(arg1))
      end if
      ainf = sqrt(arg1)
      velxgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(1)&
&       ) - ainf*machgrid*veldirfreestreamd(1)
      velxgrid0 = ainf*machgrid*(-veldirfreestream(1))
      velygrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(2)&
&       ) - ainf*machgrid*veldirfreestreamd(2)
      velygrid0 = ainf*machgrid*(-veldirfreestream(2))
      velzgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(3)&
&       ) - ainf*machgrid*veldirfreestreamd(3)
      velzgrid0 = ainf*machgrid*(-veldirfreestream(3))
! compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. it is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
      call derivativerotmatrixrigid_d(derivrotationmatrix, &
&                               derivrotationmatrixd, rotationpoint, t(1&
&                               ))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
      if (tsstability) then
! determine the time values of the old and new time level.
! it is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
        tnew = timeunsteady + timeunsteadyrestart
        told = tnew - t(1)
        if ((tspmode .or. tsqmode) .or. tsrmode) then
! compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
          call rotmatrixrigidbody(tnew, told, rotationmatrix, &
&                           rotationpoint)
          if (tsalphafollowing) then
            velxgrid0d = rotationmatrix(1, 1)*velxgrid0d + &
&             rotationmatrix(1, 2)*velygrid0d + rotationmatrix(1, 3)*&
&             velzgrid0d
            velxgrid0 = rotationmatrix(1, 1)*velxgrid0 + rotationmatrix(&
&             1, 2)*velygrid0 + rotationmatrix(1, 3)*velzgrid0
            velygrid0d = rotationmatrix(2, 1)*velxgrid0d + &
&             rotationmatrix(2, 2)*velygrid0d + rotationmatrix(2, 3)*&
&             velzgrid0d
            velygrid0 = rotationmatrix(2, 1)*velxgrid0 + rotationmatrix(&
&             2, 2)*velygrid0 + rotationmatrix(2, 3)*velzgrid0
            velzgrid0d = rotationmatrix(3, 1)*velxgrid0d + &
&             rotationmatrix(3, 2)*velygrid0d + rotationmatrix(3, 3)*&
&             velzgrid0d
            velzgrid0 = rotationmatrix(3, 1)*velxgrid0 + rotationmatrix(&
&             3, 2)*velygrid0 + rotationmatrix(3, 3)*velzgrid0
            do ii1=1,isize1ofdrfbcdata
              bcdatad(ii1)%uslip = 0.0_8
            end do
            xcd = 0.0_8
            xxcd = 0.0_8
          else
            do ii1=1,isize1ofdrfbcdata
              bcdatad(ii1)%uslip = 0.0_8
            end do
            xcd = 0.0_8
            xxcd = 0.0_8
          end if
        else if (tsalphamode) then
! get the baseline alpha and determine the liftindex
          call getdirangle_d(veldirfreestream, veldirfreestreamd, &
&                      liftdirection, liftindex, alpha, alphad, beta, &
&                      betad)
!determine the alpha for this time instance
          alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
&           degreefouralpha, omegafouralpha, coscoeffouralpha, &
&           sincoeffouralpha, t(1))
          alphatsd = alphad
          alphats = alpha + alphaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector_d(refdirection, alphats, alphatsd, beta, &
&                       betad, veldir, veldird, liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          velxgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(1)) - &
&           ainf*machgrid*veldird(1)
          velxgrid0 = ainf*machgrid*(-veldir(1))
          velygrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(2)) - &
&           ainf*machgrid*veldird(2)
          velygrid0 = ainf*machgrid*(-veldir(2))
          velzgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(3)) - &
&           ainf*machgrid*veldird(3)
          velzgrid0 = ainf*machgrid*(-veldir(3))
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xcd = 0.0_8
          xxcd = 0.0_8
        else if (tsbetamode) then
! get the baseline alpha and determine the liftindex
          call getdirangle_d(veldirfreestream, veldirfreestreamd, &
&                      liftdirection, liftindex, alpha, alphad, beta, &
&                      betad)
!determine the alpha for this time instance
          betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
&           degreefourbeta, omegafourbeta, coscoeffourbeta, &
&           sincoeffourbeta, t(1))
          betatsd = betad
          betats = beta + betaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector_d(refdirection, alpha, alphad, betats, &
&                       betatsd, veldir, veldird, liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          velxgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(1)) - &
&           ainf*machgrid*veldird(1)
          velxgrid0 = ainf*machgrid*(-veldir(1))
          velygrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(2)) - &
&           ainf*machgrid*veldird(2)
          velygrid0 = ainf*machgrid*(-veldir(2))
          velzgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldir(3)) - &
&           ainf*machgrid*veldird(3)
          velzgrid0 = ainf*machgrid*(-veldir(3))
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xcd = 0.0_8
          xxcd = 0.0_8
        else if (tsmachmode) then
!determine the mach number at this time interval
          intervalmach = tsmach(degreepolmach, coefpolmach, &
&           degreefourmach, omegafourmach, coscoeffourmach, &
&           sincoeffourmach, t(1))
!set the effective grid velocity
          velxgrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&           veldirfreestream(1)) - ainf*(intervalmach+machgrid)*&
&           veldirfreestreamd(1)
          velxgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(1)&
&           )
          velygrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&           veldirfreestream(2)) - ainf*(intervalmach+machgrid)*&
&           veldirfreestreamd(2)
          velygrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(2)&
&           )
          velzgrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&           veldirfreestream(3)) - ainf*(intervalmach+machgrid)*&
&           veldirfreestreamd(3)
          velzgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(3)&
&           )
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xcd = 0.0_8
          xxcd = 0.0_8
        else if (tsaltitudemode) then
          call terminate('gridvelocityfinelevel', &
&                  'altitude motion not yet implemented...')
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xcd = 0.0_8
          xxcd = 0.0_8
        else
          call terminate('gridvelocityfinelevel', &
&                  'not a recognized stability motion')
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xcd = 0.0_8
          xxcd = 0.0_8
        end if
      else
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%uslip = 0.0_8
        end do
        xcd = 0.0_8
        xxcd = 0.0_8
      end if
! loop over the number of viscous subfaces.
bocoloop2:do mm=1,nviscbocos
! determine the grid face on which the subface is located
! and set some variables accordingly.
        select case  (bcfaceid(mm)) 
        case (imin) 
          xfaced => xd(1, :, :, :)
          xface => x(1, :, :, :)
        case (imax) 
          xfaced => xd(il, :, :, :)
          xface => x(il, :, :, :)
        case (jmin) 
          xfaced => xd(:, 1, :, :)
          xface => x(:, 1, :, :)
        case (jmax) 
          xfaced => xd(:, jl, :, :)
          xface => x(:, jl, :, :)
        case (kmin) 
          xfaced => xd(:, :, 1, :)
          xface => x(:, :, 1, :)
        case (kmax) 
          xfaced => xd(:, :, kl, :)
          xface => x(:, :, kl, :)
        end select
! store the rotation center and the rotation rate
! for this subface.
        j = nbkglobal
        i = cgnssubface(mm)
        rotcenter = cgnsdoms(j)%bocoinfo(i)%rotcenter
        rotrated = cgnsdoms(j)%bocoinfo(i)%rotrate*timerefd
        rotrate = timeref*cgnsdoms(j)%bocoinfo(i)%rotrate
! usewindaxis should go back here!
        velxgridd = velxgrid0d
        velxgrid = velxgrid0
        velygridd = velygrid0d
        velygrid = velygrid0
        velzgridd = velzgrid0d
        velzgrid = velzgrid0
! loop over the quadrilateral faces of the viscous
! subface.
        do j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
          do i=bcdata(mm)%icbeg,bcdata(mm)%icend
! compute the coordinates of the centroid of the face.
! normally this would be an average of i-1 and i, but
! due to the usage of the pointer xface and the fact
! that x starts at index 0 this is shifted 1 index.
            xcd(1) = fourth*(xfaced(i+1, j+1, 1)+xfaced(i+1, j, 1)+&
&             xfaced(i, j+1, 1)+xfaced(i, j, 1))
            xc(1) = fourth*(xface(i+1, j+1, 1)+xface(i+1, j, 1)+xface(i&
&             , j+1, 1)+xface(i, j, 1))
            xcd(2) = fourth*(xfaced(i+1, j+1, 2)+xfaced(i+1, j, 2)+&
&             xfaced(i, j+1, 2)+xfaced(i, j, 2))
            xc(2) = fourth*(xface(i+1, j+1, 2)+xface(i+1, j, 2)+xface(i&
&             , j+1, 2)+xface(i, j, 2))
            xcd(3) = fourth*(xfaced(i+1, j+1, 3)+xfaced(i+1, j, 3)+&
&             xfaced(i, j+1, 3)+xfaced(i, j, 3))
            xc(3) = fourth*(xface(i+1, j+1, 3)+xface(i+1, j, 3)+xface(i&
&             , j+1, 3)+xface(i, j, 3))
! determine the coordinates relative to the center
! of rotation.
            xxcd(1) = xcd(1)
            xxc(1) = xc(1) - rotcenter(1)
            xxcd(2) = xcd(2)
            xxc(2) = xc(2) - rotcenter(2)
            xxcd(3) = xcd(3)
            xxc(3) = xc(3) - rotcenter(3)
! compute the velocity, which is the cross product
! of rotrate and xc.
            bcdatad(mm)%uslip(i, j, 1) = rotrated(2)*xxc(3) + rotrate(2)&
&             *xxcd(3) - rotrated(3)*xxc(2) - rotrate(3)*xxcd(2)
            bcdata(mm)%uslip(i, j, 1) = rotrate(2)*xxc(3) - rotrate(3)*&
&             xxc(2)
            bcdatad(mm)%uslip(i, j, 2) = rotrated(3)*xxc(1) + rotrate(3)&
&             *xxcd(1) - rotrated(1)*xxc(3) - rotrate(1)*xxcd(3)
            bcdata(mm)%uslip(i, j, 2) = rotrate(3)*xxc(1) - rotrate(1)*&
&             xxc(3)
            bcdatad(mm)%uslip(i, j, 3) = rotrated(1)*xxc(2) + rotrate(1)&
&             *xxcd(2) - rotrated(2)*xxc(1) - rotrate(2)*xxcd(1)
            bcdata(mm)%uslip(i, j, 3) = rotrate(1)*xxc(2) - rotrate(2)*&
&             xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
            xxcd(1) = xcd(1)
            xxc(1) = xc(1) - rotationpoint(1)
            xxcd(2) = xcd(2)
            xxc(2) = xc(2) - rotationpoint(2)
            xxcd(3) = xcd(3)
            xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell center.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
            bcdatad(mm)%uslip(i, j, 1) = bcdatad(mm)%uslip(i, j, 1) + &
&             velxgridd + derivrotationmatrixd(1, 1)*xxc(1) + &
&             derivrotationmatrix(1, 1)*xxcd(1) + derivrotationmatrixd(1&
&             , 2)*xxc(2) + derivrotationmatrix(1, 2)*xxcd(2) + &
&             derivrotationmatrixd(1, 3)*xxc(3) + derivrotationmatrix(1&
&             , 3)*xxcd(3)
            bcdata(mm)%uslip(i, j, 1) = bcdata(mm)%uslip(i, j, 1) + &
&             velxgrid + derivrotationmatrix(1, 1)*xxc(1) + &
&             derivrotationmatrix(1, 2)*xxc(2) + derivrotationmatrix(1, &
&             3)*xxc(3)
            bcdatad(mm)%uslip(i, j, 2) = bcdatad(mm)%uslip(i, j, 2) + &
&             velygridd + derivrotationmatrixd(2, 1)*xxc(1) + &
&             derivrotationmatrix(2, 1)*xxcd(1) + derivrotationmatrixd(2&
&             , 2)*xxc(2) + derivrotationmatrix(2, 2)*xxcd(2) + &
&             derivrotationmatrixd(2, 3)*xxc(3) + derivrotationmatrix(2&
&             , 3)*xxcd(3)
            bcdata(mm)%uslip(i, j, 2) = bcdata(mm)%uslip(i, j, 2) + &
&             velygrid + derivrotationmatrix(2, 1)*xxc(1) + &
&             derivrotationmatrix(2, 2)*xxc(2) + derivrotationmatrix(2, &
&             3)*xxc(3)
            bcdatad(mm)%uslip(i, j, 3) = bcdatad(mm)%uslip(i, j, 3) + &
&             velzgridd + derivrotationmatrixd(3, 1)*xxc(1) + &
&             derivrotationmatrix(3, 1)*xxcd(1) + derivrotationmatrixd(3&
&             , 2)*xxc(2) + derivrotationmatrix(3, 2)*xxcd(2) + &
&             derivrotationmatrixd(3, 3)*xxc(3) + derivrotationmatrix(3&
&             , 3)*xxcd(3)
            bcdata(mm)%uslip(i, j, 3) = bcdata(mm)%uslip(i, j, 3) + &
&             velzgrid + derivrotationmatrix(3, 1)*xxc(1) + &
&             derivrotationmatrix(3, 2)*xxc(2) + derivrotationmatrix(3, &
&             3)*xxc(3)
          end do
        end do
      end do bocoloop2
    end if
  end subroutine slipvelocitiesfinelevel_block_d
  subroutine slipvelocitiesfinelevel_block(useoldcoor, t, sps)
!
!       slipvelocitiesfinelevel computes the slip velocities for       
!       viscous subfaces on all viscous boundaries on groundlevel for  
!       the given spectral solution. if useoldcoor is .true. the       
!       velocities are determined using the unsteady time integrator;  
!       otherwise the analytic form is used.                           
!
    use constants
    use inputtimespectral
    use blockpointers
    use cgnsgrid
    use flowvarrefstate
    use inputmotion
    use inputunsteady
    use iteration
    use inputphysics
    use inputtsstabderiv
    use monitor
    use communication
    use flowutils_d, only : derivativerotmatrixrigid, getdirvector
    use utils_d, only : tsalpha, tsbeta, tsmach, terminate, &
&   rotmatrixrigidbody, setcoeftimeintegrator, getdirangle
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: useoldcoor
    real(kind=realtype), dimension(*), intent(in) :: t
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm, i, j, level
    real(kind=realtype) :: oneover4dt
    real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
    real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
    real(kind=realtype), dimension(3) :: xc, xxc
    real(kind=realtype), dimension(3) :: rotcenter, rotrate
    real(kind=realtype), dimension(3) :: rotationpoint
    real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
&   derivrotationmatrix
    real(kind=realtype) :: tnew, told
    real(kind=realtype), dimension(:, :, :), pointer :: uslip
    real(kind=realtype), dimension(:, :, :), pointer :: xface
    real(kind=realtype), dimension(:, :, :, :), pointer :: xfaceold
    integer(kind=inttype) :: liftindex
    real(kind=realtype) :: alpha, beta, intervalmach, alphats, &
&   alphaincrement, betats, betaincrement
    real(kind=realtype), dimension(3) :: veldir
    real(kind=realtype), dimension(3) :: refdirection
    intrinsic sqrt
    real(kind=realtype) :: arg1
! determine the situation we are having here.
    if (useoldcoor) then
! the velocities must be determined via a finite difference
! formula using the coordinates of the old levels.
! set the coefficients for the time integrator and store the
! inverse of the physical nondimensional time step, divided
! by 4, a bit easier.
      call setcoeftimeintegrator()
      oneover4dt = fourth*timeref/deltat
! loop over the number of viscous subfaces.
bocoloop1:do mm=1,nviscbocos
! set the pointer for uslip to make the code more
! readable.
        uslip => bcdata(mm)%uslip
! determine the grid face on which the subface is located
! and set some variables accordingly.
        select case  (bcfaceid(mm)) 
        case (imin) 
          xface => x(1, :, :, :)
          xfaceold => xold(:, 1, :, :, :)
        case (imax) 
          xface => x(il, :, :, :)
          xfaceold => xold(:, il, :, :, :)
        case (jmin) 
          xface => x(:, 1, :, :)
          xfaceold => xold(:, :, 1, :, :)
        case (jmax) 
          xface => x(:, jl, :, :)
          xfaceold => xold(:, :, jl, :, :)
        case (kmin) 
          xface => x(:, :, 1, :)
          xfaceold => xold(:, :, :, 1, :)
        case (kmax) 
          xface => x(:, :, kl, :)
          xfaceold => xold(:, :, :, kl, :)
        end select
! some boundary faces have a different rotation speed than
! the corresponding block. this happens e.g. in the tip gap
! region of turbomachinary problems where the casing does
! not rotate. as the coordinate difference corresponds to
! the rotation rate of the block, a correction must be
! computed. therefore compute the difference in rotation
! rate and store the rotation center a bit easier. note that
! the rotation center of subface is taken, because if there
! is a difference in rotation rate this info for the subface
! must always be specified.
        j = nbkglobal
        i = cgnssubface(mm)
        rotcenter = cgnsdoms(j)%bocoinfo(i)%rotcenter
        rotrate = timeref*(cgnsdoms(j)%bocoinfo(i)%rotrate-cgnsdoms(j)%&
&         rotrate)
! loop over the quadrilateral faces of the viscous subface.
! note that due to the usage of the pointers xface and
! xfaceold an offset of +1 must be used in the coordinate
! arrays, because x and xold originally start at 0 for the
! i, j and k indices.
        do j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
          do i=bcdata(mm)%icbeg,bcdata(mm)%icend
! determine the coordinates of the centroid of the
! face, multiplied by 4.
            xc(1) = xface(i+1, j+1, 1) + xface(i+1, j, 1) + xface(i, j+1&
&             , 1) + xface(i, j, 1)
            xc(2) = xface(i+1, j+1, 2) + xface(i+1, j, 2) + xface(i, j+1&
&             , 2) + xface(i, j, 2)
            xc(3) = xface(i+1, j+1, 3) + xface(i+1, j, 3) + xface(i, j+1&
&             , 3) + xface(i, j, 3)
! multiply the sum of the 4 vertex coordinates with
! coeftime(0) to obtain the contribution for the
! current time level. the division by 4*deltat will
! take place later. this is both more efficient and
! more accurate for extremely small time steps.
            uslip(i, j, 1) = coeftime(0)*xc(1)
            uslip(i, j, 2) = coeftime(0)*xc(2)
            uslip(i, j, 3) = coeftime(0)*xc(3)
! loop over the older time levels and take their
! contribution into account.
            do level=1,noldlevels
              uslip(i, j, 1) = uslip(i, j, 1) + coeftime(level)*(&
&               xfaceold(level, i+1, j+1, 1)+xfaceold(level, i+1, j, 1)+&
&               xfaceold(level, i, j+1, 1)+xfaceold(level, i, j, 1))
              uslip(i, j, 2) = uslip(i, j, 2) + coeftime(level)*(&
&               xfaceold(level, i+1, j+1, 2)+xfaceold(level, i+1, j, 2)+&
&               xfaceold(level, i, j+1, 2)+xfaceold(level, i, j, 2))
              uslip(i, j, 3) = uslip(i, j, 3) + coeftime(level)*(&
&               xfaceold(level, i+1, j+1, 3)+xfaceold(level, i+1, j, 3)+&
&               xfaceold(level, i, j+1, 3)+xfaceold(level, i, j, 3))
            end do
! divide by 4 times the time step to obtain the
! correct velocity.
            uslip(i, j, 1) = uslip(i, j, 1)*oneover4dt
            uslip(i, j, 2) = uslip(i, j, 2)*oneover4dt
            uslip(i, j, 3) = uslip(i, j, 3)*oneover4dt
! determine the correction due to the difference
! in rotation rate between the block and subface.
! first determine the coordinates relative to the
! rotation center. remember that 4 times this value
! is currently stored in xc.
            xc(1) = fourth*xc(1) - rotcenter(1)
            xc(2) = fourth*xc(2) - rotcenter(2)
            xc(3) = fourth*xc(3) - rotcenter(3)
! compute the velocity, which is the cross product
! of rotrate and xc and add it to uslip.
            uslip(i, j, 1) = uslip(i, j, 1) + rotrate(2)*xc(3) - rotrate&
&             (3)*xc(2)
            uslip(i, j, 2) = uslip(i, j, 2) + rotrate(3)*xc(1) - rotrate&
&             (1)*xc(3)
            uslip(i, j, 3) = uslip(i, j, 3) + rotrate(1)*xc(2) - rotrate&
&             (2)*xc(1)
          end do
        end do
      end do bocoloop1
    else
! the velocities must be determined analytically.
! compute the mesh velocity from the given mesh mach number.
!  ainf = sqrt(gammainf*pinf/rhoinf)
!  velxgrid = ainf*machgrid(1)
!  velygrid = ainf*machgrid(2)
!  velzgrid = ainf*machgrid(3)
      arg1 = gammainf*pinf/rhoinf
      ainf = sqrt(arg1)
      velxgrid0 = ainf*machgrid*(-veldirfreestream(1))
      velygrid0 = ainf*machgrid*(-veldirfreestream(2))
      velzgrid0 = ainf*machgrid*(-veldirfreestream(3))
! compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. it is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
      call derivativerotmatrixrigid(derivrotationmatrix, rotationpoint, &
&                             t(1))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
      if (tsstability) then
! determine the time values of the old and new time level.
! it is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
        tnew = timeunsteady + timeunsteadyrestart
        told = tnew - t(1)
        if ((tspmode .or. tsqmode) .or. tsrmode) then
! compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
          call rotmatrixrigidbody(tnew, told, rotationmatrix, &
&                           rotationpoint)
          if (tsalphafollowing) then
            velxgrid0 = rotationmatrix(1, 1)*velxgrid0 + rotationmatrix(&
&             1, 2)*velygrid0 + rotationmatrix(1, 3)*velzgrid0
            velygrid0 = rotationmatrix(2, 1)*velxgrid0 + rotationmatrix(&
&             2, 2)*velygrid0 + rotationmatrix(2, 3)*velzgrid0
            velzgrid0 = rotationmatrix(3, 1)*velxgrid0 + rotationmatrix(&
&             3, 2)*velygrid0 + rotationmatrix(3, 3)*velzgrid0
          end if
        else if (tsalphamode) then
! get the baseline alpha and determine the liftindex
          call getdirangle(veldirfreestream, liftdirection, liftindex, &
&                    alpha, beta)
!determine the alpha for this time instance
          alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
&           degreefouralpha, omegafouralpha, coscoeffouralpha, &
&           sincoeffouralpha, t(1))
          alphats = alpha + alphaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector(refdirection, alphats, beta, veldir, &
&                     liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          velxgrid0 = ainf*machgrid*(-veldir(1))
          velygrid0 = ainf*machgrid*(-veldir(2))
          velzgrid0 = ainf*machgrid*(-veldir(3))
        else if (tsbetamode) then
! get the baseline alpha and determine the liftindex
          call getdirangle(veldirfreestream, liftdirection, liftindex, &
&                    alpha, beta)
!determine the alpha for this time instance
          betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
&           degreefourbeta, omegafourbeta, coscoeffourbeta, &
&           sincoeffourbeta, t(1))
          betats = beta + betaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector(refdirection, alpha, betats, veldir, &
&                     liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          velxgrid0 = ainf*machgrid*(-veldir(1))
          velygrid0 = ainf*machgrid*(-veldir(2))
          velzgrid0 = ainf*machgrid*(-veldir(3))
        else if (tsmachmode) then
!determine the mach number at this time interval
          intervalmach = tsmach(degreepolmach, coefpolmach, &
&           degreefourmach, omegafourmach, coscoeffourmach, &
&           sincoeffourmach, t(1))
!set the effective grid velocity
          velxgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(1)&
&           )
          velygrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(2)&
&           )
          velzgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(3)&
&           )
        else if (tsaltitudemode) then
          call terminate('gridvelocityfinelevel', &
&                  'altitude motion not yet implemented...')
        else
          call terminate('gridvelocityfinelevel', &
&                  'not a recognized stability motion')
        end if
      end if
! loop over the number of viscous subfaces.
bocoloop2:do mm=1,nviscbocos
! determine the grid face on which the subface is located
! and set some variables accordingly.
        select case  (bcfaceid(mm)) 
        case (imin) 
          xface => x(1, :, :, :)
        case (imax) 
          xface => x(il, :, :, :)
        case (jmin) 
          xface => x(:, 1, :, :)
        case (jmax) 
          xface => x(:, jl, :, :)
        case (kmin) 
          xface => x(:, :, 1, :)
        case (kmax) 
          xface => x(:, :, kl, :)
        end select
! store the rotation center and the rotation rate
! for this subface.
        j = nbkglobal
        i = cgnssubface(mm)
        rotcenter = cgnsdoms(j)%bocoinfo(i)%rotcenter
        rotrate = timeref*cgnsdoms(j)%bocoinfo(i)%rotrate
! usewindaxis should go back here!
        velxgrid = velxgrid0
        velygrid = velygrid0
        velzgrid = velzgrid0
! loop over the quadrilateral faces of the viscous
! subface.
        do j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
          do i=bcdata(mm)%icbeg,bcdata(mm)%icend
! compute the coordinates of the centroid of the face.
! normally this would be an average of i-1 and i, but
! due to the usage of the pointer xface and the fact
! that x starts at index 0 this is shifted 1 index.
            xc(1) = fourth*(xface(i+1, j+1, 1)+xface(i+1, j, 1)+xface(i&
&             , j+1, 1)+xface(i, j, 1))
            xc(2) = fourth*(xface(i+1, j+1, 2)+xface(i+1, j, 2)+xface(i&
&             , j+1, 2)+xface(i, j, 2))
            xc(3) = fourth*(xface(i+1, j+1, 3)+xface(i+1, j, 3)+xface(i&
&             , j+1, 3)+xface(i, j, 3))
! determine the coordinates relative to the center
! of rotation.
            xxc(1) = xc(1) - rotcenter(1)
            xxc(2) = xc(2) - rotcenter(2)
            xxc(3) = xc(3) - rotcenter(3)
! compute the velocity, which is the cross product
! of rotrate and xc.
            bcdata(mm)%uslip(i, j, 1) = rotrate(2)*xxc(3) - rotrate(3)*&
&             xxc(2)
            bcdata(mm)%uslip(i, j, 2) = rotrate(3)*xxc(1) - rotrate(1)*&
&             xxc(3)
            bcdata(mm)%uslip(i, j, 3) = rotrate(1)*xxc(2) - rotrate(2)*&
&             xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
            xxc(1) = xc(1) - rotationpoint(1)
            xxc(2) = xc(2) - rotationpoint(2)
            xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell center.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
            bcdata(mm)%uslip(i, j, 1) = bcdata(mm)%uslip(i, j, 1) + &
&             velxgrid + derivrotationmatrix(1, 1)*xxc(1) + &
&             derivrotationmatrix(1, 2)*xxc(2) + derivrotationmatrix(1, &
&             3)*xxc(3)
            bcdata(mm)%uslip(i, j, 2) = bcdata(mm)%uslip(i, j, 2) + &
&             velygrid + derivrotationmatrix(2, 1)*xxc(1) + &
&             derivrotationmatrix(2, 2)*xxc(2) + derivrotationmatrix(2, &
&             3)*xxc(3)
            bcdata(mm)%uslip(i, j, 3) = bcdata(mm)%uslip(i, j, 3) + &
&             velzgrid + derivrotationmatrix(3, 1)*xxc(1) + &
&             derivrotationmatrix(3, 2)*xxc(2) + derivrotationmatrix(3, &
&             3)*xxc(3)
          end do
        end do
      end do bocoloop2
    end if
  end subroutine slipvelocitiesfinelevel_block
!  differentiation of normalvelocities_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.rface)
!   with respect to varying inputs: *sfacei *sfacej *sfacek *si
!                *sj *sk
!   plus diff mem management of: sfacei:in sfacej:in sfacek:in
!                si:in sj:in sk:in bcdata:in *bcdata.rface:in
  subroutine normalvelocities_block_d(sps)
!
!       normalvelocitiesalllevels computes the normal grid             
!       velocities of some boundary faces of the moving blocks for     
!       spectral mode sps. all grid levels from ground level to the    
!       coarsest level are considered.                                 
!
    use constants
    use blockpointers, only : il, jl, kl, addgridvelocities, nbocos, &
&   bcdata, bcdatad, sfacei, sfaceid, sfacej, sfacejd, sfacek, sfacekd, &
&   bcfaceid, si, sid, sj, sjd, sk, skd
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
!
!      local variables.
!
    integer(kind=inttype) :: mm
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: weight, mult
    real(kind=realtype) :: weightd
    real(kind=realtype), dimension(:, :), pointer :: sface
    real(kind=realtype), dimension(:, :), pointer :: sfaced
    real(kind=realtype), dimension(:, :, :), pointer :: ss
    real(kind=realtype), dimension(:, :, :), pointer :: ssd
    intrinsic associated
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: ii1
! check for a moving block. as it is possible that in a
! multidisicplinary environment additional grid velocities
! are set, the test should be done on addgridvelocities
! and not on blockismoving.
    if (addgridvelocities) then
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%rface = 0.0_8
      end do
!
!             determine the normal grid velocities of the boundaries.  
!             as these values are based on the unit normal. a division 
!             by the length of the normal is needed.                   
!             furthermore the boundary unit normals are per definition 
!             outward pointing, while on the imin, jmin and kmin       
!             boundaries the face normals are inward pointing. this    
!             is taken into account by the factor mult.                
!
! loop over the boundary subfaces.
bocoloop:do mm=1,nbocos
! check whether rface is allocated.
        if (associated(bcdata(mm)%rface)) then
! determine the block face on which the subface is
! located and set some variables accordingly.
          select case  (bcfaceid(mm)) 
          case (imin) 
            mult = -one
            ssd => sid(1, :, :, :)
            ss => si(1, :, :, :)
            sfaced => sfaceid(1, :, :)
            sface => sfacei(1, :, :)
          case (imax) 
            mult = one
            ssd => sid(il, :, :, :)
            ss => si(il, :, :, :)
            sfaced => sfaceid(il, :, :)
            sface => sfacei(il, :, :)
          case (jmin) 
            mult = -one
            ssd => sjd(:, 1, :, :)
            ss => sj(:, 1, :, :)
            sfaced => sfacejd(:, 1, :)
            sface => sfacej(:, 1, :)
          case (jmax) 
            mult = one
            ssd => sjd(:, jl, :, :)
            ss => sj(:, jl, :, :)
            sfaced => sfacejd(:, jl, :)
            sface => sfacej(:, jl, :)
          case (kmin) 
            mult = -one
            ssd => skd(:, :, 1, :)
            ss => sk(:, :, 1, :)
            sfaced => sfacekd(:, :, 1)
            sface => sfacek(:, :, 1)
          case (kmax) 
            mult = one
            ssd => skd(:, :, kl, :)
            ss => sk(:, :, kl, :)
            sfaced => sfacekd(:, :, kl)
            sface => sfacek(:, :, kl)
          end select
! loop over the faces of the subface.
          do j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
            do i=bcdata(mm)%icbeg,bcdata(mm)%icend
! compute the inverse of the length of the normal
! vector and possibly correct for inward pointing.
              arg1d = 2*ss(i, j, 1)*ssd(i, j, 1) + 2*ss(i, j, 2)*ssd(i, &
&               j, 2) + 2*ss(i, j, 3)*ssd(i, j, 3)
              arg1 = ss(i, j, 1)**2 + ss(i, j, 2)**2 + ss(i, j, 3)**2
              if (arg1 .eq. 0.0_8) then
                weightd = 0.0_8
              else
                weightd = arg1d/(2.0*sqrt(arg1))
              end if
              weight = sqrt(arg1)
              if (weight .gt. zero) then
                weightd = -(mult*weightd/weight**2)
                weight = mult/weight
              end if
! compute the normal velocity based on the outward
! pointing unit normal.
              bcdatad(mm)%rface(i, j) = weightd*sface(i, j) + weight*&
&               sfaced(i, j)
              bcdata(mm)%rface(i, j) = weight*sface(i, j)
            end do
          end do
        end if
      end do bocoloop
    else
! block is not moving. loop over the boundary faces and set
! the normal grid velocity to zero if allocated.
      do mm=1,nbocos
        if (associated(bcdata(mm)%rface)) then
          bcdatad(mm)%rface = 0.0_8
          bcdata(mm)%rface = zero
        end if
      end do
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%rface = 0.0_8
      end do
    end if
  end subroutine normalvelocities_block_d
  subroutine normalvelocities_block(sps)
!
!       normalvelocitiesalllevels computes the normal grid             
!       velocities of some boundary faces of the moving blocks for     
!       spectral mode sps. all grid levels from ground level to the    
!       coarsest level are considered.                                 
!
    use constants
    use blockpointers, only : il, jl, kl, addgridvelocities, nbocos, &
&   bcdata, sfacei, sfacej, sfacek, bcfaceid, si, sj, sk
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
!
!      local variables.
!
    integer(kind=inttype) :: mm
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: weight, mult
    real(kind=realtype), dimension(:, :), pointer :: sface
    real(kind=realtype), dimension(:, :, :), pointer :: ss
    intrinsic associated
    intrinsic sqrt
    real(kind=realtype) :: arg1
! check for a moving block. as it is possible that in a
! multidisicplinary environment additional grid velocities
! are set, the test should be done on addgridvelocities
! and not on blockismoving.
    if (addgridvelocities) then
!
!             determine the normal grid velocities of the boundaries.  
!             as these values are based on the unit normal. a division 
!             by the length of the normal is needed.                   
!             furthermore the boundary unit normals are per definition 
!             outward pointing, while on the imin, jmin and kmin       
!             boundaries the face normals are inward pointing. this    
!             is taken into account by the factor mult.                
!
! loop over the boundary subfaces.
bocoloop:do mm=1,nbocos
! check whether rface is allocated.
        if (associated(bcdata(mm)%rface)) then
! determine the block face on which the subface is
! located and set some variables accordingly.
          select case  (bcfaceid(mm)) 
          case (imin) 
            mult = -one
            ss => si(1, :, :, :)
            sface => sfacei(1, :, :)
          case (imax) 
            mult = one
            ss => si(il, :, :, :)
            sface => sfacei(il, :, :)
          case (jmin) 
            mult = -one
            ss => sj(:, 1, :, :)
            sface => sfacej(:, 1, :)
          case (jmax) 
            mult = one
            ss => sj(:, jl, :, :)
            sface => sfacej(:, jl, :)
          case (kmin) 
            mult = -one
            ss => sk(:, :, 1, :)
            sface => sfacek(:, :, 1)
          case (kmax) 
            mult = one
            ss => sk(:, :, kl, :)
            sface => sfacek(:, :, kl)
          end select
! loop over the faces of the subface.
          do j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
            do i=bcdata(mm)%icbeg,bcdata(mm)%icend
! compute the inverse of the length of the normal
! vector and possibly correct for inward pointing.
              arg1 = ss(i, j, 1)**2 + ss(i, j, 2)**2 + ss(i, j, 3)**2
              weight = sqrt(arg1)
              if (weight .gt. zero) weight = mult/weight
! compute the normal velocity based on the outward
! pointing unit normal.
              bcdata(mm)%rface(i, j) = weight*sface(i, j)
            end do
          end do
        end if
      end do bocoloop
    else
! block is not moving. loop over the boundary faces and set
! the normal grid velocity to zero if allocated.
      do mm=1,nbocos
        if (associated(bcdata(mm)%rface)) bcdata(mm)%rface = zero
      end do
    end if
  end subroutine normalvelocities_block
end module solverutils_d

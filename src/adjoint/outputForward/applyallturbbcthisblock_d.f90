!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of applyallturbbcthisblock in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev *w
!   with respect to varying inputs: *rev *bvtj1 *bvtj2 *w *bvtk1
!                *bvtk2 *bvti1 *bvti2
!   plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
!                bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
!      ==================================================================
subroutine applyallturbbcthisblock_d(secondhalo)
!
!      ******************************************************************
!      *                                                                *
!      * applyallturbbcthisblock sets the halo values of the            *
!      * turbulent variables and eddy viscosity for the block the       *
!      * variables in blockpointers currently point to.                 *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use flowvarrefstate
  use inputphysics
  implicit none
!
!      subroutine arguments.
!
  logical, intent(in) :: secondhalo
!
!      local variables.
!
  integer(kind=inttype) :: nn, i, j, l, m
  real(kind=realtype), dimension(:, :, :, :), pointer :: bmt
  real(kind=realtype), dimension(:, :, :), pointer :: bvt, ww1, ww2
! loop over the boundary condition subfaces of this block.
bocos:do nn=1,nbocos
! loop over the faces and set the state in
! the turbulent halo cells.
    if (.not.wallfunctions) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              wd(1, i, j, l) = bvti1d(i, j, l)
              w(1, i, j, l) = bvti1(i, j, l)
              do m=nt1,nt2
                wd(1, i, j, l) = wd(1, i, j, l) - bmti1(i, j, l, m)*wd(2&
&                 , i, j, m)
                w(1, i, j, l) = w(1, i, j, l) - bmti1(i, j, l, m)*w(2, i&
&                 , j, m)
              end do
            end do
          end do
        end do
      case (imax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              wd(ie, i, j, l) = bvti2d(i, j, l)
              w(ie, i, j, l) = bvti2(i, j, l)
              do m=nt1,nt2
                wd(ie, i, j, l) = wd(ie, i, j, l) - bmti2(i, j, l, m)*wd&
&                 (il, i, j, m)
                w(ie, i, j, l) = w(ie, i, j, l) - bmti2(i, j, l, m)*w(il&
&                 , i, j, m)
              end do
            end do
          end do
        end do
      case (jmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              wd(i, 1, j, l) = bvtj1d(i, j, l)
              w(i, 1, j, l) = bvtj1(i, j, l)
              do m=nt1,nt2
                wd(i, 1, j, l) = wd(i, 1, j, l) - bmtj1(i, j, l, m)*wd(i&
&                 , 2, j, m)
                w(i, 1, j, l) = w(i, 1, j, l) - bmtj1(i, j, l, m)*w(i, 2&
&                 , j, m)
              end do
            end do
          end do
        end do
      case (jmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              wd(i, je, j, l) = bvtj2d(i, j, l)
              w(i, je, j, l) = bvtj2(i, j, l)
              do m=nt1,nt2
                wd(i, je, j, l) = wd(i, je, j, l) - bmtj2(i, j, l, m)*wd&
&                 (i, jl, j, m)
                w(i, je, j, l) = w(i, je, j, l) - bmtj2(i, j, l, m)*w(i&
&                 , jl, j, m)
              end do
            end do
          end do
        end do
      case (kmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              wd(i, j, 1, l) = bvtk1d(i, j, l)
              w(i, j, 1, l) = bvtk1(i, j, l)
              do m=nt1,nt2
                wd(i, j, 1, l) = wd(i, j, 1, l) - bmtk1(i, j, l, m)*wd(i&
&                 , j, 2, m)
                w(i, j, 1, l) = w(i, j, 1, l) - bmtk1(i, j, l, m)*w(i, j&
&                 , 2, m)
              end do
            end do
          end do
        end do
      case (kmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              wd(i, j, ke, l) = bvtk2d(i, j, l)
              w(i, j, ke, l) = bvtk2(i, j, l)
              do m=nt1,nt2
                wd(i, j, ke, l) = wd(i, j, ke, l) - bmtk2(i, j, l, m)*wd&
&                 (i, j, kl, m)
                w(i, j, ke, l) = w(i, j, ke, l) - bmtk2(i, j, l, m)*w(i&
&                 , j, kl, m)
              end do
            end do
          end do
        end do
      end select
    end if
! set the value of the eddy viscosity, depending on the type of
! boundary condition. only if the turbulence model is an eddy
! viscosity model of course.
    if (eddymodel) then
      if (bctype(nn) .eq. nswalladiabatic .or. bctype(nn) .eq. &
&         nswallisothermal) then
! viscous wall boundary condition. eddy viscosity is
! zero at the wall.
        call bceddywall_d(nn)
      else
! any boundary condition but viscous wall. a homogeneous
! neumann condition is applied to the eddy viscosity.
        call bceddynowall_d(nn)
      end if
    end if
! extrapolate the turbulent variables in case a second halo
! is needed.
    if (secondhalo) call turb2ndhalo_d(nn)
  end do bocos
end subroutine applyallturbbcthisblock_d

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module adjointextra_d
  implicit none

contains
!  differentiation of block_res in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(flowdoms.w) *(flowdoms.dw)
!                *(*bcdata.fv) *(*bcdata.fp) *(*bcdata.area) *rev0
!                *rev1 *pp0 *pp1 *rlv0 *rlv1 *ww0 *ww1 funcvalues
!   with respect to varying inputs: *(flowdoms.x) *(flowdoms.w)
!                mach machgrid rgasdim lengthref machcoef pointref
!                tinfdim rhoinfdim pinfdim *xx *rev0 *rev1 *rev2
!                *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3
!                *ss *ssi *ssj *ssk *ww0 *ww1 *ww2 *ww3 alpha beta
!   rw status of diff variables: *(flowdoms.x):in *(flowdoms.vol):(loc)
!                *(flowdoms.w):in-out *(flowdoms.dw):out *rev:(loc)
!                *aa:(loc) *bvtj1:(loc) *bvtj2:(loc) *wx:(loc)
!                *wy:(loc) *wz:(loc) *p:(loc) *sfacei:(loc) *sfacej:(loc)
!                *s:(loc) *sfacek:(loc) *rlv:(loc) *qx:(loc) *qy:(loc)
!                *qz:(loc) *scratch:(loc) *bvtk1:(loc) *bvtk2:(loc)
!                *ux:(loc) *uy:(loc) *uz:(loc) *si:(loc) *sj:(loc)
!                *sk:(loc) *bvti1:(loc) *bvti2:(loc) *vx:(loc)
!                *vy:(loc) *vz:(loc) *fw:(loc) *(*viscsubface.tau):(loc)
!                *(*bcdata.norm):(loc) *(*bcdata.rface):(loc) *(*bcdata.fv):out
!                *(*bcdata.fp):out *(*bcdata.area):out *(*bcdata.uslip):(loc)
!                *radi:(loc) *radj:(loc) *radk:(loc) mach:in veldirfreestream:(loc)
!                machgrid:in rgasdim:in lengthref:in machcoef:in
!                dragdirection:(loc) liftdirection:(loc) pointref:in
!                gammainf:(loc) tinfdim:in pinf:(loc) timeref:(loc)
!                rhoinf:(loc) muref:(loc) rhoinfdim:in tref:(loc)
!                winf:(loc) muinf:(loc) uinf:(loc) pinfcorr:(loc)
!                rgas:(loc) muinfdim:(loc) pinfdim:in pref:(loc)
!                rhoref:(loc) *xx:in *rev0:in-out *rev1:in-out
!                *rev2:in *rev3:in *pp0:in-out *pp1:in-out *pp2:in
!                *pp3:in *rlv0:in-out *rlv1:in-out *rlv2:in *rlv3:in
!                *ss:in *ssi:in *ssj:in *ssk:in *ww0:in-out *ww1:in-out
!                *ww2:in *ww3:in funcvalues:out alpha:in beta:in
!   plus diff mem management of: flowdoms.x:in flowdoms.vol:in
!                flowdoms.w:in flowdoms.dw:in rev:in aa:in bvtj1:in
!                bvtj2:in wx:in wy:in wz:in p:in sfacei:in sfacej:in
!                s:in sfacek:in rlv:in qx:in qy:in qz:in scratch:in
!                bvtk1:in bvtk2:in ux:in uy:in uz:in si:in sj:in
!                sk:in bvti1:in bvti2:in vx:in vy:in vz:in fw:in
!                viscsubface:in *viscsubface.tau:in bcdata:in *bcdata.norm:in
!                *bcdata.rface:in *bcdata.fv:in *bcdata.fp:in *bcdata.area:in
!                *bcdata.uslip:in radi:in radj:in radk:in xx:in-out
!                rev0:in-out rev1:in-out rev2:in-out rev3:in-out
!                pp0:in-out pp1:in-out pp2:in-out pp3:in-out rlv0:in-out
!                rlv1:in-out rlv2:in-out rlv3:in-out ss:in-out
!                ssi:in-out ssj:in-out ssk:in-out ww0:in-out ww1:in-out
!                ww2:in-out ww3:in-out
! this is a super-combined function that combines the original
! functionality of: 
! pressure computation
! timestep
! applyallbcs
! initres
! residual 
! the real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the nominal
! block/sps loop is outside the calculation. this routine is suitable
! for forward mode ad with tapenade
  subroutine block_res_d(nn, sps, usespatial, alpha, alphad, beta, betad&
&   , liftindex, frozenturb)
! note that we import all the pointers from block res that will be
! used in any routine. otherwise, tapenade gives warnings about
! saving a hidden variable. 
    use constants
    use block, only : flowdoms, flowdomsd
    use bcroutines_d
    use bcpointers_d
    use blockpointers, only : w, wd, dw, dwd, x, xd, vol, vold, il, jl&
&   , kl, sectionid, wold, volold, bcdata, bcdatad, si, sid, sj, sjd, sk&
&   , skd, sfacei, sfaceid, sfacej, sfacejd, sfacek, sfacekd, rlv, rlvd,&
&   gamma, p, pd, rev, revd, bmtj1, bmtj2, scratch, scratchd, bmtk2, &
&   bmtk1, fw, fwd, aa, aad, d2wall, bmti1, bmti2, s, sd
    use flowvarrefstate
    use inputphysics
    use inputiteration
    use inputtimespectral
    use section
    use monitor
    use iteration
    use diffsizes
    use costfunctions
    use initializeflow_d, only : referencestate, referencestate_d
    use walldistance_d, only : updatewalldistancesquickly, xsurf
    use inputdiscretization
    use sa_d
    use inputunsteady
    use turbbcroutines_d
    use turbutils_d
    use utils_d, only : terminate
    use flowutils_d, only : adjustinflowangle, adjustinflowangle_d, &
&   computepressuresimple, computepressuresimple_d, computelamviscosity,&
&   computelamviscosity_d
    use solverutils_d, only : gridvelocitiesfinelevel_block, &
&   gridvelocitiesfinelevel_block_d, normalvelocities_block, &
&   normalvelocities_block_d, slipvelocitiesfinelevel_block, &
&   slipvelocitiesfinelevel_block_d, timestep_block, timestep_block_d
    use residuals_d, only : residual_block, residual_block_d
    use surfaceintegrations_d, only : forcesandmoments, &
&   forcesandmoments_d
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
! input arguments:
    integer(kind=inttype), intent(in) :: nn, sps
    logical, intent(in) :: usespatial, frozenturb
    real(kind=realtype), intent(in) :: alpha, beta
    real(kind=realtype), intent(in) :: alphad, betad
    integer(kind=inttype), intent(in) :: liftindex
! output variables
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced&
&   , momentd
    real(kind=realtype) :: sepsensor, cavitation, sepsensoravg(3)
    real(kind=realtype) :: sepsensord, cavitationd, sepsensoravgd(3)
! working variables
    real(kind=realtype) :: gm1, v2, fact, tmp
    real(kind=realtype) :: factd, tmpd
    integer(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj, m
    integer(kind=inttype) :: nstate
    real(kind=realtype), dimension(nsections) :: t
    logical :: useoldcoor
    real(kind=realtype), dimension(3) :: cfp, cfv, cmp, cmv
    real(kind=realtype), dimension(3) :: cfpd, cfvd, cmpd, cmvd
    real(kind=realtype) :: yplusmax, scaledim, oneoverdt
    real(kind=realtype) :: scaledimd, oneoverdtd
    intrinsic real
    integer :: ii3
    integer :: ii2
    integer :: ii1
    useoldcoor = .false.
! setup number of state variable based on turbulence assumption
    if (frozenturb) then
      nstate = nwf
    else
      nstate = nw
    end if
! set pointers to input/output variables
    wd => flowdomsd(nn, currentlevel, sps)%w
    w => flowdoms(nn, currentlevel, sps)%w
    dwd => flowdomsd(nn, 1, sps)%dw
    dw => flowdoms(nn, 1, sps)%dw
    xd => flowdomsd(nn, currentlevel, sps)%x
    x => flowdoms(nn, currentlevel, sps)%x
    vold => flowdomsd(nn, currentlevel, sps)%vol
    vol => flowdoms(nn, currentlevel, sps)%vol
! ------------------------------------------------
!        additional 'extra' components
! ------------------------------------------------ 
    call adjustinflowangle_d(alpha, alphad, beta, betad, liftindex)
    call referencestate_d()
! ------------------------------------------------
!        additional spatial components
! ------------------------------------------------
    if (usespatial) then
      call volume_block_d()
      call metric_block_d()
      call boundarynormals_d()
! -------------------------------------
! these functions are required for ts
! --------------------------------------
      t = timeunsteadyrestart
      if (equationmode .eq. timespectral) then
        do mm=1,nsections
          t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/real(&
&           ntimeintervalsspectral, realtype)
        end do
      end if
      call gridvelocitiesfinelevel_block_d(useoldcoor, t, sps)
! required for ts
      call normalvelocities_block_d(sps)
! required for ts
      call slipvelocitiesfinelevel_block_d(useoldcoor, t, sps)
    else
      do ii1=1,ntimeintervalsspectral
        do ii2=1,1
          do ii3=nn,nn
            flowdomsd(ii3, ii2, ii1)%vol = 0.0_8
          end do
        end do
      end do
      sfaceid = 0.0_8
      sfacejd = 0.0_8
      sd = 0.0_8
      sfacekd = 0.0_8
      sid = 0.0_8
      sjd = 0.0_8
      skd = 0.0_8
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%norm = 0.0_8
      end do
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%rface = 0.0_8
      end do
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%uslip = 0.0_8
      end do
    end if
! ------------------------------------------------
!        normal residual computation
! ------------------------------------------------
! compute the pressures
    call computepressuresimple_d()
! compute laminar/eddy viscosity if required
    call computelamviscosity_d()
    call computeeddyviscosity_d()
    call applyallbc_block_d(.true.)
    if (equations .eq. ransequations) then
      call bcturbtreatment_d()
      call applyallturbbcthisblock_d(.true.)
    end if
! compute skin_friction velocity (only for wall functions)
! #ifndef tapenade_reverse
!   call computeutau_block
! #endif
! compute time step and spectral radius
    call timestep_block_d(.false.)
spectralloop0:do sps2=1,ntimeintervalsspectral
      flowdomsd(nn, 1, sps2)%dw(:, :, :, :) = 0.0_8
      flowdoms(nn, 1, sps2)%dw(:, :, :, :) = zero
    end do spectralloop0
! -------------------------------
! compute turbulence residual for rans equations
    if (equations .eq. ransequations) then
! ! initialize only the turblent variables
! call unsteadyturbspectral_block(itu1, itu1, nn, sps)
      select case  (turbmodel) 
      case (spalartallmaras) 
        call sa_block_d(.true.)
      case default
!case (mentersst)
! not implemented yet
!call sst_block(.true.)
        call terminate('turbresidual', &
&                'only sa turbulence adjoint implemented')
        do ii1=1,ntimeintervalsspectral
          do ii2=1,1
            do ii3=nn,nn
              flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
            end do
          end do
        end do
      end select
    else
      do ii1=1,ntimeintervalsspectral
        do ii2=1,1
          do ii3=nn,nn
            flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
          end do
        end do
      end do
    end if
! -------------------------------  
! next initialize residual for flow variables. the is the only place
! where there is an n^2 dependance. there are issues with
! initres. so only the necesary timespectral code has been copied
! here. see initres for more information and comments.
!call initres_block(1, nwf, nn, sps)
    if (equationmode .eq. steady) then
      dwd(:, :, :, 1:nwf) = 0.0_8
      dw(:, :, :, 1:nwf) = zero
    else if (equationmode .eq. timespectral) then
! zero dw on all spectral instances
spectralloop1:do sps2=1,ntimeintervalsspectral
        flowdomsd(nn, 1, sps2)%dw(:, :, :, 1:nwf) = 0.0_8
        flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
      end do spectralloop1
spectralloop2:do sps2=1,ntimeintervalsspectral
        jj = sectionid
timeloopfine:do mm=1,ntimeintervalsspectral
          ii = 3*(mm-1)
varloopfine:do l=1,nwf
            if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
              if (l .eq. ivx) ll = 3*sps2 - 2
              if (l .eq. ivy) ll = 3*sps2 - 1
              if (l .eq. ivz) ll = 3*sps2
              do k=2,kl
                do j=2,jl
                  do i=2,il
                    tmpd = dvector(jj, ll, ii+1)*flowdomsd(nn, 1, mm)%w(&
&                     i, j, k, ivx) + dvector(jj, ll, ii+2)*flowdomsd(nn&
&                     , 1, mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
&                     flowdomsd(nn, 1, mm)%w(i, j, k, ivz)
                    tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i&
&                     , j, k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, &
&                     1, mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
&                     flowdoms(nn, 1, mm)%w(i, j, k, ivz)
                    flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn&
&                     , 1, sps2)%dw(i, j, k, l) + (tmpd*flowdoms(nn, 1, &
&                     mm)%vol(i, j, k)+tmp*flowdomsd(nn, 1, mm)%vol(i, j&
&                     , k))*flowdoms(nn, 1, mm)%w(i, j, k, irho) + tmp*&
&                     flowdoms(nn, 1, mm)%vol(i, j, k)*flowdomsd(nn, 1, &
&                     mm)%w(i, j, k, irho)
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%&
&                     vol(i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
                  end do
                end do
              end do
            else
              do k=2,kl
                do j=2,jl
                  do i=2,il
! this is: dw = dw + dscalar*vol*w
                    flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn&
&                     , 1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
&                     (flowdomsd(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1&
&                     , mm)%w(i, j, k, l)+flowdoms(nn, 1, mm)%vol(i, j, &
&                     k)*flowdomsd(nn, 1, mm)%w(i, j, k, l))
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
&                     flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, &
&                     mm)%w(i, j, k, l)
                  end do
                end do
              end do
            end if
          end do varloopfine
        end do timeloopfine
      end do spectralloop2
    else if (equationmode .eq. unsteady) then
! assume only md or bdf types
! store the inverse of the physical nondimensional
! time step a bit easier.
      oneoverdtd = timerefd/deltat
      oneoverdt = timeref/deltat
! ground level of the multigrid cycle. initialize the
! owned cells to the unsteady source term. first the
! term for the current time level. note that in w the
! velocities are stored and not the momentum variables.
! therefore the if-statement is present to correct this.
      do l=1,nw
        if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
! momentum variables.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdomsd(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*((&
&                 vold(i, j, k)*w(i, j, k, l)+vol(i, j, k)*wd(i, j, k, l&
&                 ))*w(i, j, k, irho)+vol(i, j, k)*w(i, j, k, l)*wd(i, j&
&                 , k, irho))
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)*w(i, j, k, irho)
              end do
            end do
          end do
        else
! non-momentum variables, for which the variable
! to be solved is stored; for the flow equations this
! is the conservative variable, for the turbulent
! equations the primitive variable.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdomsd(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*(vold&
&                 (i, j, k)*w(i, j, k, l)+vol(i, j, k)*wd(i, j, k, l))
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)
              end do
            end do
          end do
        end if
      end do
! the terms from the older time levels. here the
! conservative variables are stored. in case of a
! deforming mesh, also the old volumes must be taken.
      if (deforming_grid) then
! mesh is deforming and thus the volumes can change.
! use the old volumes as well.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*volold(m, i, j, k)&
&                   *wold(m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      else
! rigid mesh. the volumes remain constant.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdomsd(nn, 1, sps)%dw(i, j, k, l) = flowdomsd(nn, 1&
&                   , sps)%dw(i, j, k, l) + coeftime(m)*wold(m, i, j, k&
&                   , l)*vold(i, j, k)
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*vol(i, j, k)*wold(&
&                   m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      end if
! multiply the time derivative by the inverse of the
! time step to obtain the true time derivative.
! this is done after the summation has been done, because
! otherwise you run into finite accuracy problems for
! very small time steps.
      do l=1,nw
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdomsd(nn, 1, sps)%dw(i, j, k, l) = oneoverdtd*flowdoms&
&               (nn, 1, sps)%dw(i, j, k, l) + oneoverdt*flowdomsd(nn, 1&
&               , sps)%dw(i, j, k, l)
              flowdoms(nn, 1, sps)%dw(i, j, k, l) = oneoverdt*flowdoms(&
&               nn, 1, sps)%dw(i, j, k, l)
            end do
          end do
        end do
      end do
    end if
!  actual residual calc
    call residual_block_d()
! divide through by the reference volume
    do sps2=1,ntimeintervalsspectral
      do l=1,nwf
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)
              flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)
            end do
          end do
        end do
      end do
! treat the turblent residual with the scaling factor on the
! residual
      do l=nt1,nstate
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = turbresscale(l-nt1&
&               +1)*flowdomsd(nn, 1, sps2)%dw(i, j, k, l)/flowdoms(nn, &
&               currentlevel, sps2)%volref(i, j, k)
              flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)*turbresscale(l-nt1+1)
            end do
          end do
        end do
      end do
    end do
    call forcesandmoments_d(cfp, cfpd, cfv, cfvd, cmp, cmpd, cmv, cmvd, &
&                     yplusmax, sepsensor, sepsensord, sepsensoravg, &
&                     sepsensoravgd, cavitation, cavitationd)
! convert back to actual forces. note that even though we use
! machcoef, lref, and surfaceref here, they are not differented,
! since f doesn't actually depend on them. ideally we would just get
! the raw forces and moment form forcesandmoments. 
    force = zero
    moment = zero
    scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
    scaledim = pref/pinf
    factd = -(two*surfaceref*lref**2*(((gammainfd*pinf+gammainf*pinfd)*&
&     scaledim+gammainf*pinf*scaledimd)*machcoef**2+gammainf*pinf*&
&     scaledim*(machcoefd*machcoef+machcoef*machcoefd))/(gammainf*pinf*&
&     machcoef*machcoef*surfaceref*lref*lref*scaledim)**2)
    fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
&     scaledim)
    forced = 0.0_8
    do sps2=1,ntimeintervalsspectral
      forced(:, sps2) = ((cfpd+cfvd)*fact-(cfp+cfv)*factd)/fact**2
      force(:, sps2) = (cfp+cfv)/fact
    end do
    factd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*lref)&
&     **2
    fact = fact/(lengthref*lref)
    momentd = 0.0_8
    do sps2=1,ntimeintervalsspectral
      momentd(:, sps2) = ((cmpd+cmvd)*fact-(cmp+cmv)*factd)/fact**2
      moment(:, sps2) = (cmp+cmv)/fact
    end do
    call getcostfunction_d(force, forced, moment, momentd, sepsensor, &
&                    sepsensord, sepsensoravg, sepsensoravgd, cavitation&
&                    , cavitationd, alpha, beta, liftindex)
  end subroutine block_res_d
! this is a super-combined function that combines the original
! functionality of: 
! pressure computation
! timestep
! applyallbcs
! initres
! residual 
! the real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the nominal
! block/sps loop is outside the calculation. this routine is suitable
! for forward mode ad with tapenade
  subroutine block_res(nn, sps, usespatial, alpha, beta, liftindex, &
&   frozenturb)
! note that we import all the pointers from block res that will be
! used in any routine. otherwise, tapenade gives warnings about
! saving a hidden variable. 
    use constants
    use block, only : flowdoms
    use bcroutines_d
    use bcpointers_d
    use blockpointers, only : w, dw, x, vol, il, jl, kl, sectionid, &
&   wold, volold, bcdata, si, sj, sk, sfacei, sfacej, sfacek, rlv, gamma&
&   , p, rev, bmtj1, bmtj2, scratch, bmtk2, bmtk1, fw, aa, d2wall, bmti1&
&   , bmti2, s
    use flowvarrefstate
    use inputphysics
    use inputiteration
    use inputtimespectral
    use section
    use monitor
    use iteration
    use diffsizes
    use costfunctions
    use initializeflow_d, only : referencestate
    use walldistance_d, only : updatewalldistancesquickly, xsurf
    use inputdiscretization
    use sa_d
    use inputunsteady
    use turbbcroutines_d
    use turbutils_d
    use utils_d, only : terminate
    use flowutils_d, only : adjustinflowangle, computepressuresimple, &
&   computelamviscosity
    use solverutils_d, only : gridvelocitiesfinelevel_block, &
&   normalvelocities_block, slipvelocitiesfinelevel_block, &
&   timestep_block
    use residuals_d, only : residual_block
    use surfaceintegrations_d, only : forcesandmoments
    implicit none
! input arguments:
    integer(kind=inttype), intent(in) :: nn, sps
    logical, intent(in) :: usespatial, frozenturb
    real(kind=realtype), intent(in) :: alpha, beta
    integer(kind=inttype), intent(in) :: liftindex
! output variables
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype) :: sepsensor, cavitation, sepsensoravg(3)
! working variables
    real(kind=realtype) :: gm1, v2, fact, tmp
    integer(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj, m
    integer(kind=inttype) :: nstate
    real(kind=realtype), dimension(nsections) :: t
    logical :: useoldcoor
    real(kind=realtype), dimension(3) :: cfp, cfv, cmp, cmv
    real(kind=realtype) :: yplusmax, scaledim, oneoverdt
    intrinsic real
    useoldcoor = .false.
! setup number of state variable based on turbulence assumption
    if (frozenturb) then
      nstate = nwf
    else
      nstate = nw
    end if
! set pointers to input/output variables
    w => flowdoms(nn, currentlevel, sps)%w
    dw => flowdoms(nn, 1, sps)%dw
    x => flowdoms(nn, currentlevel, sps)%x
    vol => flowdoms(nn, currentlevel, sps)%vol
! ------------------------------------------------
!        additional 'extra' components
! ------------------------------------------------ 
    call adjustinflowangle(alpha, beta, liftindex)
    call referencestate()
! ------------------------------------------------
!        additional spatial components
! ------------------------------------------------
    if (usespatial) then
      call volume_block()
      call metric_block()
      call boundarynormals()
! -------------------------------------
! these functions are required for ts
! --------------------------------------
      t = timeunsteadyrestart
      if (equationmode .eq. timespectral) then
        do mm=1,nsections
          t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/real(&
&           ntimeintervalsspectral, realtype)
        end do
      end if
      call gridvelocitiesfinelevel_block(useoldcoor, t, sps)
! required for ts
      call normalvelocities_block(sps)
! required for ts
      call slipvelocitiesfinelevel_block(useoldcoor, t, sps)
    end if
! ------------------------------------------------
!        normal residual computation
! ------------------------------------------------
! compute the pressures
    call computepressuresimple()
! compute laminar/eddy viscosity if required
    call computelamviscosity()
    call computeeddyviscosity()
    call applyallbc_block(.true.)
    if (equations .eq. ransequations) then
      call bcturbtreatment()
      call applyallturbbcthisblock(.true.)
    end if
! compute skin_friction velocity (only for wall functions)
! #ifndef tapenade_reverse
!   call computeutau_block
! #endif
! compute time step and spectral radius
    call timestep_block(.false.)
spectralloop0:do sps2=1,ntimeintervalsspectral
      flowdoms(nn, 1, sps2)%dw(:, :, :, :) = zero
    end do spectralloop0
! -------------------------------
! compute turbulence residual for rans equations
    if (equations .eq. ransequations) then
! ! initialize only the turblent variables
! call unsteadyturbspectral_block(itu1, itu1, nn, sps)
      select case  (turbmodel) 
      case (spalartallmaras) 
        call sa_block(.true.)
      case default
!case (mentersst)
! not implemented yet
!call sst_block(.true.)
        call terminate('turbresidual', &
&                'only sa turbulence adjoint implemented')
      end select
    end if
! -------------------------------  
! next initialize residual for flow variables. the is the only place
! where there is an n^2 dependance. there are issues with
! initres. so only the necesary timespectral code has been copied
! here. see initres for more information and comments.
!call initres_block(1, nwf, nn, sps)
    if (equationmode .eq. steady) then
      dw(:, :, :, 1:nwf) = zero
    else if (equationmode .eq. timespectral) then
! zero dw on all spectral instances
spectralloop1:do sps2=1,ntimeintervalsspectral
        flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
      end do spectralloop1
spectralloop2:do sps2=1,ntimeintervalsspectral
        jj = sectionid
timeloopfine:do mm=1,ntimeintervalsspectral
          ii = 3*(mm-1)
varloopfine:do l=1,nwf
            if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
              if (l .eq. ivx) ll = 3*sps2 - 2
              if (l .eq. ivy) ll = 3*sps2 - 1
              if (l .eq. ivz) ll = 3*sps2
              do k=2,kl
                do j=2,jl
                  do i=2,il
                    tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i&
&                     , j, k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, &
&                     1, mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
&                     flowdoms(nn, 1, mm)%w(i, j, k, ivz)
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%&
&                     vol(i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
                  end do
                end do
              end do
            else
              do k=2,kl
                do j=2,jl
                  do i=2,il
! this is: dw = dw + dscalar*vol*w
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
&                     flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, &
&                     mm)%w(i, j, k, l)
                  end do
                end do
              end do
            end if
          end do varloopfine
        end do timeloopfine
      end do spectralloop2
    else if (equationmode .eq. unsteady) then
! assume only md or bdf types
! store the inverse of the physical nondimensional
! time step a bit easier.
      oneoverdt = timeref/deltat
! ground level of the multigrid cycle. initialize the
! owned cells to the unsteady source term. first the
! term for the current time level. note that in w the
! velocities are stored and not the momentum variables.
! therefore the if-statement is present to correct this.
      do l=1,nw
        if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
! momentum variables.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)*w(i, j, k, irho)
              end do
            end do
          end do
        else
! non-momentum variables, for which the variable
! to be solved is stored; for the flow equations this
! is the conservative variable, for the turbulent
! equations the primitive variable.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)
              end do
            end do
          end do
        end if
      end do
! the terms from the older time levels. here the
! conservative variables are stored. in case of a
! deforming mesh, also the old volumes must be taken.
      if (deforming_grid) then
! mesh is deforming and thus the volumes can change.
! use the old volumes as well.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*volold(m, i, j, k)&
&                   *wold(m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      else
! rigid mesh. the volumes remain constant.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*vol(i, j, k)*wold(&
&                   m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      end if
! multiply the time derivative by the inverse of the
! time step to obtain the true time derivative.
! this is done after the summation has been done, because
! otherwise you run into finite accuracy problems for
! very small time steps.
      do l=1,nw
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdoms(nn, 1, sps)%dw(i, j, k, l) = oneoverdt*flowdoms(&
&               nn, 1, sps)%dw(i, j, k, l)
            end do
          end do
        end do
      end do
    end if
!  actual residual calc
    call residual_block()
! divide through by the reference volume
    do sps2=1,ntimeintervalsspectral
      do l=1,nwf
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)
            end do
          end do
        end do
      end do
! treat the turblent residual with the scaling factor on the
! residual
      do l=nt1,nstate
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)*turbresscale(l-nt1+1)
            end do
          end do
        end do
      end do
    end do
    call forcesandmoments(cfp, cfv, cmp, cmv, yplusmax, sepsensor, &
&                   sepsensoravg, cavitation)
! convert back to actual forces. note that even though we use
! machcoef, lref, and surfaceref here, they are not differented,
! since f doesn't actually depend on them. ideally we would just get
! the raw forces and moment form forcesandmoments. 
    force = zero
    moment = zero
    scaledim = pref/pinf
    fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
&     scaledim)
    do sps2=1,ntimeintervalsspectral
      force(:, sps2) = (cfp+cfv)/fact
    end do
    fact = fact/(lengthref*lref)
    do sps2=1,ntimeintervalsspectral
      moment(:, sps2) = (cmp+cmv)/fact
    end do
    call getcostfunction(force, moment, sepsensor, sepsensoravg, &
&                  cavitation, alpha, beta, liftindex)
  end subroutine block_res
  subroutine resscale()
    use blockpointers
    use flowvarrefstate
    use inputiteration
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, l
    real(kind=realtype) :: ovol
! divide through by the reference volume
    do k=2,kl
      do j=2,jl
        do i=2,il
          ovol = one/volref(i, j, k)
          do l=1,nwf
            dw(i, j, k, l) = (dw(i, j, k, l)+fw(i, j, k, l))*ovol
          end do
          do l=nt1,nt2
            dw(i, j, k, l) = (dw(i, j, k, l)+fw(i, j, k, l))*ovol*&
&             turbresscale(l-nt1+1)
          end do
        end do
      end do
    end do
  end subroutine resscale
!  differentiation of getcostfunction in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: funcvalues
!   with respect to varying inputs: machgrid lengthref machcoef
!                dragdirection liftdirection pointref gammainf
!                pinf rhoinfdim pinfdim pref moment sepsensoravg
!                force cavitation sepsensor
  subroutine getcostfunction_d(force, forced, moment, momentd, sepsensor&
&   , sepsensord, sepsensoravg, sepsensoravgd, cavitation, cavitationd, &
&   alpha, beta, liftindex)
! compute the value of the actual objective function based on the
! (summed) forces and moments and any other "extra" design
! variables. the index of the objective is determined by 'idv'. this
! function is intended to be ad'ed in reverse mode. 
    use constants
    use inputtimespectral
    use costfunctions
    use inputphysics
    use flowvarrefstate
    use inputtsstabderiv
    use utils_d, only : computetsderivatives, computetsderivatives_d, &
&   computerootbendingmoment, computerootbendingmoment_d
    implicit none
! input 
    integer(kind=inttype), intent(in) :: liftindex
    real(kind=realtype), dimension(3, ntimeintervalsspectral), intent(in&
&   ) :: force, moment
    real(kind=realtype), dimension(3, ntimeintervalsspectral), intent(in&
&   ) :: forced, momentd
    real(kind=realtype), intent(in) :: sepsensor, cavitation, &
&   sepsensoravg(3)
    real(kind=realtype), intent(in) :: sepsensord, cavitationd, &
&   sepsensoravgd(3)
    real(kind=realtype), intent(in) :: alpha, beta
! working
    real(kind=realtype) :: fact, factmoment, scaledim, ovrnts
    real(kind=realtype) :: factd, factmomentd, scaledimd
    real(kind=realtype), dimension(3) :: cf, cm
    real(kind=realtype), dimension(3) :: cfd, cmd
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(8) :: coef0, dcdalpha, dcdalphadot, &
&   dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: coef0d, dcdalphad, dcdalphadotd
    real(kind=realtype) :: bendingmoment
    real(kind=realtype) :: bendingmomentd
    integer(kind=inttype) :: sps
! generate constants
    scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
    scaledim = pref/pinf
    factd = -(two*surfaceref*lref**2*((gammainfd*pinf+gammainf*pinfd)*&
&     machcoef**2*scaledim+gammainf*pinf*(2*machcoef*machcoefd*scaledim+&
&     machcoef**2*scaledimd))/(gammainf*pinf*machcoef**2*surfaceref*lref&
&     **2*scaledim)**2)
    fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
    factmomentd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref&
&     *lref)**2
    factmoment = fact/(lengthref*lref)
    ovrnts = one/ntimeintervalsspectral
! pre-compute ts stability info if required:
    if (tsstability) then
      call computetsderivatives_d(force, forced, moment, momentd, &
&                           liftindex, coef0, coef0d, dcdalpha, &
&                           dcdalphad, dcdalphadot, dcdalphadotd, dcdq, &
&                           dcdqdot)
    else
      dcdalphadotd = 0.0_8
      coef0d = 0.0_8
      dcdalphad = 0.0_8
    end if
    funcvalues = zero
    funcvaluesd = 0.0_8
! now we just compute each cost function:
    do sps=1,ntimeintervalsspectral
      funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + ovrnts&
&       *forced(1, sps)
      funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
&       force(1, sps)
      funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + ovrnts&
&       *forced(2, sps)
      funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
&       force(2, sps)
      funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + ovrnts&
&       *forced(3, sps)
      funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
&       force(3, sps)
      funcvaluesd(costfuncmomx) = funcvaluesd(costfuncmomx) + ovrnts*&
&       momentd(1, sps)
      funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*&
&       moment(1, sps)
      funcvaluesd(costfuncmomy) = funcvaluesd(costfuncmomy) + ovrnts*&
&       momentd(2, sps)
      funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*&
&       moment(2, sps)
      funcvaluesd(costfuncmomz) = funcvaluesd(costfuncmomz) + ovrnts*&
&       momentd(3, sps)
      funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*&
&       moment(3, sps)
      funcvaluesd(costfuncsepsensor) = funcvaluesd(costfuncsepsensor) + &
&       ovrnts*sepsensord
      funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
&       ovrnts*sepsensor
      funcvaluesd(costfunccavitation) = funcvaluesd(costfunccavitation) &
&       + ovrnts*cavitationd
      funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
&       ovrnts*cavitation
      funcvaluesd(costfuncsepsensoravgx) = funcvaluesd(&
&       costfuncsepsensoravgx) + ovrnts*sepsensoravgd(1)
      funcvalues(costfuncsepsensoravgx) = funcvalues(&
&       costfuncsepsensoravgx) + ovrnts*sepsensoravg(1)
      funcvaluesd(costfuncsepsensoravgy) = funcvaluesd(&
&       costfuncsepsensoravgy) + ovrnts*sepsensoravgd(2)
      funcvalues(costfuncsepsensoravgy) = funcvalues(&
&       costfuncsepsensoravgy) + ovrnts*sepsensoravg(2)
      funcvaluesd(costfuncsepsensoravgz) = funcvaluesd(&
&       costfuncsepsensoravgz) + ovrnts*sepsensoravgd(3)
      funcvalues(costfuncsepsensoravgz) = funcvalues(&
&       costfuncsepsensoravgz) + ovrnts*sepsensoravg(3)
! bending moment calc
      cmd = factmomentd*moment(:, sps) + factmoment*momentd(:, sps)
      cm = factmoment*moment(:, sps)
      cfd = factd*force(:, sps) + fact*forced(:, sps)
      cf = fact*force(:, sps)
      call computerootbendingmoment_d(cf, cfd, cm, cmd, liftindex, &
&                               bendingmoment, bendingmomentd)
      funcvaluesd(costfuncbendingcoef) = funcvaluesd(costfuncbendingcoef&
&       ) + ovrnts*bendingmomentd
      funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) &
&       + ovrnts*bendingmoment
    end do
    funcvaluesd(costfuncforcexcoef) = funcvaluesd(costfuncforcex)*fact +&
&     funcvalues(costfuncforcex)*factd
    funcvalues(costfuncforcexcoef) = funcvalues(costfuncforcex)*fact
    funcvaluesd(costfuncforceycoef) = funcvaluesd(costfuncforcey)*fact +&
&     funcvalues(costfuncforcey)*factd
    funcvalues(costfuncforceycoef) = funcvalues(costfuncforcey)*fact
    funcvaluesd(costfuncforcezcoef) = funcvaluesd(costfuncforcez)*fact +&
&     funcvalues(costfuncforcez)*factd
    funcvalues(costfuncforcezcoef) = funcvalues(costfuncforcez)*fact
    funcvaluesd(costfuncmomxcoef) = funcvaluesd(costfuncmomx)*factmoment&
&     + funcvalues(costfuncmomx)*factmomentd
    funcvalues(costfuncmomxcoef) = funcvalues(costfuncmomx)*factmoment
    funcvaluesd(costfuncmomycoef) = funcvaluesd(costfuncmomy)*factmoment&
&     + funcvalues(costfuncmomy)*factmomentd
    funcvalues(costfuncmomycoef) = funcvalues(costfuncmomy)*factmoment
    funcvaluesd(costfuncmomzcoef) = funcvaluesd(costfuncmomz)*factmoment&
&     + funcvalues(costfuncmomz)*factmomentd
    funcvalues(costfuncmomzcoef) = funcvalues(costfuncmomz)*factmoment
    funcvaluesd(costfunclift) = funcvaluesd(costfuncforcex)*&
&     liftdirection(1) + funcvalues(costfuncforcex)*liftdirectiond(1) + &
&     funcvaluesd(costfuncforcey)*liftdirection(2) + funcvalues(&
&     costfuncforcey)*liftdirectiond(2) + funcvaluesd(costfuncforcez)*&
&     liftdirection(3) + funcvalues(costfuncforcez)*liftdirectiond(3)
    funcvalues(costfunclift) = funcvalues(costfuncforcex)*liftdirection(&
&     1) + funcvalues(costfuncforcey)*liftdirection(2) + funcvalues(&
&     costfuncforcez)*liftdirection(3)
    funcvaluesd(costfuncdrag) = funcvaluesd(costfuncforcex)*&
&     dragdirection(1) + funcvalues(costfuncforcex)*dragdirectiond(1) + &
&     funcvaluesd(costfuncforcey)*dragdirection(2) + funcvalues(&
&     costfuncforcey)*dragdirectiond(2) + funcvaluesd(costfuncforcez)*&
&     dragdirection(3) + funcvalues(costfuncforcez)*dragdirectiond(3)
    funcvalues(costfuncdrag) = funcvalues(costfuncforcex)*dragdirection(&
&     1) + funcvalues(costfuncforcey)*dragdirection(2) + funcvalues(&
&     costfuncforcez)*dragdirection(3)
    funcvaluesd(costfuncliftcoef) = funcvaluesd(costfunclift)*fact + &
&     funcvalues(costfunclift)*factd
    funcvalues(costfuncliftcoef) = funcvalues(costfunclift)*fact
    funcvaluesd(costfuncdragcoef) = funcvaluesd(costfuncdrag)*fact + &
&     funcvalues(costfuncdrag)*factd
    funcvalues(costfuncdragcoef) = funcvalues(costfuncdrag)*fact
! -------------------- time spectral objectives ------------------
    funcvaluesd(costfunccl0) = coef0d(1)
    funcvalues(costfunccl0) = coef0(1)
    funcvaluesd(costfunccd0) = coef0d(2)
    funcvalues(costfunccd0) = coef0(2)
    funcvaluesd(costfunccm0) = coef0d(8)
    funcvalues(costfunccm0) = coef0(8)
    funcvaluesd(costfuncclalpha) = dcdalphad(1)
    funcvalues(costfuncclalpha) = dcdalpha(1)
    funcvaluesd(costfunccdalpha) = dcdalphad(2)
    funcvalues(costfunccdalpha) = dcdalpha(2)
    funcvaluesd(costfunccmzalpha) = dcdalphad(8)
    funcvalues(costfunccmzalpha) = dcdalpha(8)
    funcvaluesd(costfuncclalphadot) = dcdalphadotd(1)
    funcvalues(costfuncclalphadot) = dcdalphadot(1)
    funcvaluesd(costfunccdalphadot) = dcdalphadotd(2)
    funcvalues(costfunccdalphadot) = dcdalphadot(2)
    funcvaluesd(costfunccmzalphadot) = dcdalphadotd(8)
    funcvalues(costfunccmzalphadot) = dcdalphadot(8)
    funcvaluesd(costfuncclq) = 0.0_8
    funcvalues(costfuncclq) = dcdq(1)
    funcvaluesd(costfunccdq) = 0.0_8
    funcvalues(costfunccdq) = dcdq(2)
    funcvaluesd(costfunccmzq) = 0.0_8
    funcvalues(costfunccmzq) = dcdq(8)
    funcvaluesd(costfuncclqdot) = 0.0_8
    funcvalues(costfuncclqdot) = dcdqdot(1)
    funcvaluesd(costfunccdqdot) = 0.0_8
    funcvalues(costfunccdqdot) = dcdqdot(2)
    funcvaluesd(costfunccmzqdot) = 0.0_8
    funcvalues(costfunccmzqdot) = dcdqdot(8)
  end subroutine getcostfunction_d
  subroutine getcostfunction(force, moment, sepsensor, sepsensoravg, &
&   cavitation, alpha, beta, liftindex)
! compute the value of the actual objective function based on the
! (summed) forces and moments and any other "extra" design
! variables. the index of the objective is determined by 'idv'. this
! function is intended to be ad'ed in reverse mode. 
    use constants
    use inputtimespectral
    use costfunctions
    use inputphysics
    use flowvarrefstate
    use inputtsstabderiv
    use utils_d, only : computetsderivatives, computerootbendingmoment
    implicit none
! input 
    integer(kind=inttype), intent(in) :: liftindex
    real(kind=realtype), dimension(3, ntimeintervalsspectral), intent(in&
&   ) :: force, moment
    real(kind=realtype), intent(in) :: sepsensor, cavitation, &
&   sepsensoravg(3)
    real(kind=realtype), intent(in) :: alpha, beta
! working
    real(kind=realtype) :: fact, factmoment, scaledim, ovrnts
    real(kind=realtype), dimension(3) :: cf, cm
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(8) :: coef0, dcdalpha, dcdalphadot, &
&   dcdq, dcdqdot
    real(kind=realtype) :: bendingmoment
    integer(kind=inttype) :: sps
! generate constants
    scaledim = pref/pinf
    fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
    factmoment = fact/(lengthref*lref)
    ovrnts = one/ntimeintervalsspectral
! pre-compute ts stability info if required:
    if (tsstability) call computetsderivatives(force, moment, liftindex&
&                                        , coef0, dcdalpha, dcdalphadot&
&                                        , dcdq, dcdqdot)
    funcvalues = zero
! now we just compute each cost function:
    do sps=1,ntimeintervalsspectral
      funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
&       force(1, sps)
      funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
&       force(2, sps)
      funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
&       force(3, sps)
      funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*&
&       moment(1, sps)
      funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*&
&       moment(2, sps)
      funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*&
&       moment(3, sps)
      funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
&       ovrnts*sepsensor
      funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
&       ovrnts*cavitation
      funcvalues(costfuncsepsensoravgx) = funcvalues(&
&       costfuncsepsensoravgx) + ovrnts*sepsensoravg(1)
      funcvalues(costfuncsepsensoravgy) = funcvalues(&
&       costfuncsepsensoravgy) + ovrnts*sepsensoravg(2)
      funcvalues(costfuncsepsensoravgz) = funcvalues(&
&       costfuncsepsensoravgz) + ovrnts*sepsensoravg(3)
! bending moment calc
      cm = factmoment*moment(:, sps)
      cf = fact*force(:, sps)
      call computerootbendingmoment(cf, cm, liftindex, bendingmoment)
      funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) &
&       + ovrnts*bendingmoment
    end do
    funcvalues(costfuncforcexcoef) = funcvalues(costfuncforcex)*fact
    funcvalues(costfuncforceycoef) = funcvalues(costfuncforcey)*fact
    funcvalues(costfuncforcezcoef) = funcvalues(costfuncforcez)*fact
    funcvalues(costfuncmomxcoef) = funcvalues(costfuncmomx)*factmoment
    funcvalues(costfuncmomycoef) = funcvalues(costfuncmomy)*factmoment
    funcvalues(costfuncmomzcoef) = funcvalues(costfuncmomz)*factmoment
    funcvalues(costfunclift) = funcvalues(costfuncforcex)*liftdirection(&
&     1) + funcvalues(costfuncforcey)*liftdirection(2) + funcvalues(&
&     costfuncforcez)*liftdirection(3)
    funcvalues(costfuncdrag) = funcvalues(costfuncforcex)*dragdirection(&
&     1) + funcvalues(costfuncforcey)*dragdirection(2) + funcvalues(&
&     costfuncforcez)*dragdirection(3)
    funcvalues(costfuncliftcoef) = funcvalues(costfunclift)*fact
    funcvalues(costfuncdragcoef) = funcvalues(costfuncdrag)*fact
! -------------------- time spectral objectives ------------------
    funcvalues(costfunccl0) = coef0(1)
    funcvalues(costfunccd0) = coef0(2)
    funcvalues(costfunccm0) = coef0(8)
    funcvalues(costfuncclalpha) = dcdalpha(1)
    funcvalues(costfunccdalpha) = dcdalpha(2)
    funcvalues(costfunccmzalpha) = dcdalpha(8)
    funcvalues(costfuncclalphadot) = dcdalphadot(1)
    funcvalues(costfunccdalphadot) = dcdalphadot(2)
    funcvalues(costfunccmzalphadot) = dcdalphadot(8)
    funcvalues(costfuncclq) = dcdq(1)
    funcvalues(costfunccdq) = dcdq(2)
    funcvalues(costfunccmzq) = dcdq(8)
    funcvalues(costfuncclqdot) = dcdqdot(1)
    funcvalues(costfunccdqdot) = dcdqdot(2)
    funcvalues(costfunccmzqdot) = dcdqdot(8)
  end subroutine getcostfunction
  subroutine volume_block()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vol = zero
    do k=1,ke
      n = k - 1
      do j=1,je
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x&
&               (i, m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2&
&               ), x(i, m, k, 3), vp1)
          call volpym(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, &
&               m, k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2&
&               ), x(l, j, n, 3), vp2)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, &
&               j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x&
&               (l, j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2&
&               ), x(i, j, n, 3), vp3)
          call volpym(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, &
&               m, n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2&
&               ), x(l, m, k, 3), vp4)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x&
&               (l, m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2&
&               ), x(l, j, k, 3), vp5)
          call volpym(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, &
&               j, n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2&
&               ), x(i, m, n, 3), vp6)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            vol(i, j, k) = vol(i, j, k)
          else
            vol(i, j, k) = -vol(i, j, k)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) vol(1, j, k)&
&          = vol(2, j, k)
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) vol(ie, j, k&
&         ) = vol(il, j, k)
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) vol(i, 1, k)&
&          = vol(i, 2, k)
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) vol(i, je, k&
&         ) = vol(i, jl, k)
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) vol(i, j, 1)&
&          = vol(i, j, 2)
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) vol(i, j, ke&
&         ) = vol(i, j, kl)
      end do
    end do

  contains
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,     
!         whose coordinates are set in the subroutine metric itself,   
!         is the top node and a-b-c-d is the quadrilateral surface.    
!         it is assumed that the cross product vca * vdb points in     
!         the direction of the top node. here vca is the diagonal      
!         running from node c to node a and vdb the diagonal from      
!         node d to node b.                                            
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block
!  differentiation of volume_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *vol
!   with respect to varying inputs: *x
!   plus diff mem management of: x:in vol:in
  subroutine volume_block_d()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xpd, ypd, zpd, vp1d, vp2d, vp3d, vp4d, vp5d, &
&   vp6d
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vold = 0.0_8
    vol = zero
    vold = 0.0_8
    vp1d = 0.0_8
    vp2d = 0.0_8
    vp3d = 0.0_8
    vp4d = 0.0_8
    vp5d = 0.0_8
    vp6d = 0.0_8
    do k=1,ke
      n = k - 1
      do j=1,je
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          xpd = eighth*(xd(i, j, k, 1)+xd(i, m, k, 1)+xd(i, m, n, 1)+xd(&
&           i, j, n, 1)+xd(l, j, k, 1)+xd(l, m, k, 1)+xd(l, m, n, 1)+xd(&
&           l, j, n, 1))
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          ypd = eighth*(xd(i, j, k, 2)+xd(i, m, k, 2)+xd(i, m, n, 2)+xd(&
&           i, j, n, 2)+xd(l, j, k, 2)+xd(l, m, k, 2)+xd(l, m, n, 2)+xd(&
&           l, j, n, 2))
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          zpd = eighth*(xd(i, j, k, 3)+xd(i, m, k, 3)+xd(i, m, n, 3)+xd(&
&           i, j, n, 3)+xd(l, j, k, 3)+xd(l, m, k, 3)+xd(l, m, n, 3)+xd(&
&           l, j, n, 3))
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym_d(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, j, n&
&                 , 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i, j, n, 2), x&
&                 (i, j, n, 3), xd(i, j, n, 3), x(i, m, n, 1), xd(i, m, &
&                 n, 1), x(i, m, n, 2), xd(i, m, n, 2), x(i, m, n, 3), &
&                 xd(i, m, n, 3), x(i, m, k, 1), xd(i, m, k, 1), x(i, m&
&                 , k, 2), xd(i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3)&
&                 , vp1, vp1d)
          call volpym_d(x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd&
&                 (l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), x(l, m, k&
&                 , 1), xd(l, m, k, 1), x(l, m, k, 2), xd(l, m, k, 2), x&
&                 (l, m, k, 3), xd(l, m, k, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, j, n, 1), xd(l, j, n, 1), x(l, j&
&                 , n, 2), xd(l, j, n, 2), x(l, j, n, 3), xd(l, j, n, 3)&
&                 , vp2, vp2d)
          call volpym_d(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(l, j, k&
&                 , 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l, j, k, 2), x&
&                 (l, j, k, 3), xd(l, j, k, 3), x(l, j, n, 1), xd(l, j, &
&                 n, 1), x(l, j, n, 2), xd(l, j, n, 2), x(l, j, n, 3), &
&                 xd(l, j, n, 3), x(i, j, n, 1), xd(i, j, n, 1), x(i, j&
&                 , n, 2), xd(i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3)&
&                 , vp3, vp3d)
          call volpym_d(x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd&
&                 (i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), x(i, m, n&
&                 , 1), xd(i, m, n, 1), x(i, m, n, 2), xd(i, m, n, 2), x&
&                 (i, m, n, 3), xd(i, m, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, m, k, 1), xd(l, m, k, 1), x(l, m&
&                 , k, 2), xd(l, m, k, 2), x(l, m, k, 3), xd(l, m, k, 3)&
&                 , vp4, vp4d)
          call volpym_d(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, m, k&
&                 , 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i, m, k, 2), x&
&                 (i, m, k, 3), xd(i, m, k, 3), x(l, m, k, 1), xd(l, m, &
&                 k, 1), x(l, m, k, 2), xd(l, m, k, 2), x(l, m, k, 3), &
&                 xd(l, m, k, 3), x(l, j, k, 1), xd(l, j, k, 1), x(l, j&
&                 , k, 2), xd(l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3)&
&                 , vp5, vp5d)
          call volpym_d(x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd&
&                 (i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), x(l, j, n&
&                 , 1), xd(l, j, n, 1), x(l, j, n, 2), xd(l, j, n, 2), x&
&                 (l, j, n, 3), xd(l, j, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(i, m, n, 1), xd(i, m, n, 1), x(i, m&
&                 , n, 2), xd(i, m, n, 2), x(i, m, n, 3), xd(i, m, n, 3)&
&                 , vp6, vp6d)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vold(i, j, k) = sixth*(vp1d+vp2d+vp3d+vp4d+vp5d+vp6d)
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            vol(i, j, k) = vol(i, j, k)
          else
            vold(i, j, k) = -vold(i, j, k)
            vol(i, j, k) = -vol(i, j, k)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) then
          vold(1, j, k) = vold(2, j, k)
          vol(1, j, k) = vol(2, j, k)
        end if
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) then
          vold(ie, j, k) = vold(il, j, k)
          vol(ie, j, k) = vol(il, j, k)
        end if
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) then
          vold(i, 1, k) = vold(i, 2, k)
          vol(i, 1, k) = vol(i, 2, k)
        end if
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) then
          vold(i, je, k) = vold(i, jl, k)
          vol(i, je, k) = vol(i, jl, k)
        end if
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) then
          vold(i, j, 1) = vold(i, j, 2)
          vol(i, j, 1) = vol(i, j, 2)
        end if
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) then
          vold(i, j, ke) = vold(i, j, kl)
          vol(i, j, ke) = vol(i, j, kl)
        end if
      end do
    end do

  contains
!  differentiation of volpym in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: volume
!   with respect to varying inputs: xp yp zp xa xb xc xd ya yb
!                yc yd za zb zc zd
    subroutine volpym_d(xa, xad, ya, yad, za, zad, xb, xbd, yb, ybd, zb&
&     , zbd, xc, xcd, yc, ycd, zc, zcd, xd, xdd, yd, ydd, zd, zdd, &
&     volume, volumed)
!
!         volpym computes 6 times the volume of a pyramid. node p,     
!         whose coordinates are set in the subroutine metric itself,   
!         is the top node and a-b-c-d is the quadrilateral surface.    
!         it is assumed that the cross product vca * vdb points in     
!         the direction of the top node. here vca is the diagonal      
!         running from node c to node a and vdb the diagonal from      
!         node d to node b.                                            
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
      real(kind=realtype) :: volumed
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xad, yad, zad, xbd, ybd, zbd
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      real(kind=realtype), intent(in) :: xcd, ycd, zcd, xdd, ydd, zdd
      volumed = (xpd-fourth*(xad+xbd+xcd+xdd))*((ya-yc)*(zb-zd)-(za-zc)*&
&       (yb-yd)) + (xp-fourth*(xa+xb+xc+xd))*((yad-ycd)*(zb-zd)+(ya-yc)*&
&       (zbd-zdd)-(zad-zcd)*(yb-yd)-(za-zc)*(ybd-ydd)) + (ypd-fourth*(&
&       yad+ybd+ycd+ydd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd)) + (yp-fourth&
&       *(ya+yb+yc+yd))*((zad-zcd)*(xb-xd)+(za-zc)*(xbd-xdd)-(xad-xcd)*(&
&       zb-zd)-(xa-xc)*(zbd-zdd)) + (zpd-fourth*(zad+zbd+zcd+zdd))*((xa-&
&       xc)*(yb-yd)-(ya-yc)*(xb-xd)) + (zp-fourth*(za+zb+zc+zd))*((xad-&
&       xcd)*(yb-yd)+(xa-xc)*(ybd-ydd)-(yad-ycd)*(xb-xd)-(ya-yc)*(xbd-&
&       xdd))
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym_d
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,     
!         whose coordinates are set in the subroutine metric itself,   
!         is the top node and a-b-c-d is the quadrilateral surface.    
!         it is assumed that the cross product vca * vdb points in     
!         the direction of the top node. here vca is the diagonal      
!         running from node c to node a and vdb the diagonal from      
!         node d to node b.                                            
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block_d
!  differentiation of metric_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *si *sj *sk
!   with respect to varying inputs: *x
!   plus diff mem management of: x:in si:in sj:in sk:in
  subroutine metric_block_d()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    real(kind=realtype), dimension(3) :: v1d, v2d
    intrinsic mod
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
      sid = 0.0_8
      v1d = 0.0_8
      v2d = 0.0_8
    else
      fact = -half
      sid = 0.0_8
      v1d = 0.0_8
      v2d = 0.0_8
    end if
!
!  computation of the face normals in i-, j- and k-direction. 
!  formula's are valid for a right handed block; for a left   
!  handed block the correct orientation is obtained via fact. 
!  the normals point in the direction of increasing index.    
!  the absolute value of fact is 0.5, because the cross       
!  product of the two diagonals is twice the normal vector.   
!  note that also the normals of the first level halo cells   
!  are computed. these are needed for the viscous fluxes.     
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1d(1) = xd(i, j, n, 1) - xd(i, m, k, 1)
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1d(2) = xd(i, j, n, 2) - xd(i, m, k, 2)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1d(3) = xd(i, j, n, 3) - xd(i, m, k, 3)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2d(1) = xd(i, j, k, 1) - xd(i, m, n, 1)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2d(2) = xd(i, j, k, 2) - xd(i, m, n, 2)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2d(3) = xd(i, j, k, 3) - xd(i, m, n, 3)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sid(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-v1(&
&       3)*v2d(2))
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sid(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-v1(&
&       1)*v2d(3))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sid(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-v1(&
&       2)*v2d(1))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    sjd = 0.0_8
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1d(1) = xd(i, j, n, 1) - xd(l, j, k, 1)
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1d(2) = xd(i, j, n, 2) - xd(l, j, k, 2)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1d(3) = xd(i, j, n, 3) - xd(l, j, k, 3)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2d(1) = xd(l, j, n, 1) - xd(i, j, k, 1)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2d(2) = xd(l, j, n, 2) - xd(i, j, k, 2)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2d(3) = xd(l, j, n, 3) - xd(i, j, k, 3)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sjd(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-v1(&
&       3)*v2d(2))
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sjd(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-v1(&
&       1)*v2d(3))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sjd(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-v1(&
&       2)*v2d(1))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    skd = 0.0_8
! projected areas of cell faces in the k direction.
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1d(1) = xd(i, j, k, 1) - xd(l, m, k, 1)
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1d(2) = xd(i, j, k, 2) - xd(l, m, k, 2)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1d(3) = xd(i, j, k, 3) - xd(l, m, k, 3)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2d(1) = xd(l, j, k, 1) - xd(i, m, k, 1)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2d(2) = xd(l, j, k, 2) - xd(i, m, k, 2)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2d(3) = xd(l, j, k, 3) - xd(i, m, k, 3)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      skd(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-v1(&
&       3)*v2d(2))
      sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      skd(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-v1(&
&       1)*v2d(3))
      sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      skd(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-v1(&
&       2)*v2d(1))
      sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
  end subroutine metric_block_d
  subroutine metric_block()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic mod
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
    else
      fact = -half
    end if
!
!  computation of the face normals in i-, j- and k-direction. 
!  formula's are valid for a right handed block; for a left   
!  handed block the correct orientation is obtained via fact. 
!  the normals point in the direction of increasing index.    
!  the absolute value of fact is 0.5, because the cross       
!  product of the two diagonals is twice the normal vector.   
!  note that also the normals of the first level halo cells   
!  are computed. these are needed for the viscous fluxes.     
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the k direction.
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
  end subroutine metric_block
!  differentiation of boundarynormals in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.norm)
!   with respect to varying inputs: *si *sj *sk
!   plus diff mem management of: si:in sj:in sk:in bcdata:in *bcdata.norm:in
  subroutine boundarynormals_d()
!  the unit normals on the boundary faces. these always point 
!  out of the domain, so a multiplication by -1 is needed for 
!  the imin, jmin and kmin boundaries.                        
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: factd
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype) :: xxpd, yypd, zzpd
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: ii1
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%norm = 0.0_8
    end do
    zzpd = 0.0_8
    yypd = 0.0_8
    xxpd = 0.0_8
!loop over the boundary subfaces of this block.
bocoloop:do mm=1,nbocos
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxpd = sid(1, i, j, 1)
          xxp = si(1, i, j, 1)
          yypd = sid(1, i, j, 2)
          yyp = si(1, i, j, 2)
          zzpd = sid(1, i, j, 3)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxpd = sid(il, i, j, 1)
          xxp = si(il, i, j, 1)
          yypd = sid(il, i, j, 2)
          yyp = si(il, i, j, 2)
          zzpd = sid(il, i, j, 3)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxpd = sjd(i, 1, j, 1)
          xxp = sj(i, 1, j, 1)
          yypd = sjd(i, 1, j, 2)
          yyp = sj(i, 1, j, 2)
          zzpd = sjd(i, 1, j, 3)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxpd = sjd(i, jl, j, 1)
          xxp = sj(i, jl, j, 1)
          yypd = sjd(i, jl, j, 2)
          yyp = sj(i, jl, j, 2)
          zzpd = sjd(i, jl, j, 3)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxpd = skd(i, j, 1, 1)
          xxp = sk(i, j, 1, 1)
          yypd = skd(i, j, 1, 2)
          yyp = sk(i, j, 1, 2)
          zzpd = skd(i, j, 1, 3)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxpd = skd(i, j, kl, 1)
          xxp = sk(i, j, kl, 1)
          yypd = skd(i, j, kl, 2)
          yyp = sk(i, j, kl, 2)
          zzpd = skd(i, j, kl, 3)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        arg1d = xxpd*xxp + xxp*xxpd + yypd*yyp + yyp*yypd + zzpd*zzp + &
&         zzp*zzpd
        arg1 = xxp*xxp + yyp*yyp + zzp*zzp
        if (arg1 .eq. 0.0_8) then
          factd = 0.0_8
        else
          factd = arg1d/(2.0*sqrt(arg1))
        end if
        fact = sqrt(arg1)
        if (fact .gt. zero) then
          factd = -(mult*factd/fact**2)
          fact = mult/fact
        end if
! compute the unit normal.
        bcdatad(mm)%norm(i, j, 1) = factd*xxp + fact*xxpd
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdatad(mm)%norm(i, j, 2) = factd*yyp + fact*yypd
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdatad(mm)%norm(i, j, 3) = factd*zzp + fact*zzpd
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
    end do bocoloop
  end subroutine boundarynormals_d
  subroutine boundarynormals()
!  the unit normals on the boundary faces. these always point 
!  out of the domain, so a multiplication by -1 is needed for 
!  the imin, jmin and kmin boundaries.                        
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xxp, yyp, zzp
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
!loop over the boundary subfaces of this block.
bocoloop:do mm=1,nbocos
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        arg1 = xxp*xxp + yyp*yyp + zzp*zzp
        fact = sqrt(arg1)
        if (fact .gt. zero) fact = mult/fact
! compute the unit normal.
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
    end do bocoloop
  end subroutine boundarynormals
!  differentiation of xhalo_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *x
!   with respect to varying inputs: *x
!   rw status of diff variables: *x:in-out
!   plus diff mem management of: x:in
  subroutine xhalo_block_d()
!
!       xhalo determines the coordinates of the nodal halo's.          
!       first it sets all halo coordinates by simple extrapolation,    
!       then the symmetry planes are treated (also the unit normal of  
!       symmetry planes are determined) and finally an exchange is     
!       made for the internal halo's.                                  
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype) :: dotd
    real(kind=realtype), dimension(3) :: v1, v2, norm
    real(kind=realtype), dimension(3) :: v1d
    intrinsic sqrt
    real(kind=realtype) :: arg1
! extrapolation in i-direction.
    do k=1,kl
      do j=1,jl
        xd(0, j, k, 1) = two*xd(1, j, k, 1) - xd(2, j, k, 1)
        x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
        xd(0, j, k, 2) = two*xd(1, j, k, 2) - xd(2, j, k, 2)
        x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
        xd(0, j, k, 3) = two*xd(1, j, k, 3) - xd(2, j, k, 3)
        x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
        xd(ie, j, k, 1) = two*xd(il, j, k, 1) - xd(nx, j, k, 1)
        x(ie, j, k, 1) = two*x(il, j, k, 1) - x(nx, j, k, 1)
        xd(ie, j, k, 2) = two*xd(il, j, k, 2) - xd(nx, j, k, 2)
        x(ie, j, k, 2) = two*x(il, j, k, 2) - x(nx, j, k, 2)
        xd(ie, j, k, 3) = two*xd(il, j, k, 3) - xd(nx, j, k, 3)
        x(ie, j, k, 3) = two*x(il, j, k, 3) - x(nx, j, k, 3)
      end do
    end do
! extrapolation in j-direction.
    do k=1,kl
      do i=0,ie
        xd(i, 0, k, 1) = two*xd(i, 1, k, 1) - xd(i, 2, k, 1)
        x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
        xd(i, 0, k, 2) = two*xd(i, 1, k, 2) - xd(i, 2, k, 2)
        x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
        xd(i, 0, k, 3) = two*xd(i, 1, k, 3) - xd(i, 2, k, 3)
        x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
        xd(i, je, k, 1) = two*xd(i, jl, k, 1) - xd(i, ny, k, 1)
        x(i, je, k, 1) = two*x(i, jl, k, 1) - x(i, ny, k, 1)
        xd(i, je, k, 2) = two*xd(i, jl, k, 2) - xd(i, ny, k, 2)
        x(i, je, k, 2) = two*x(i, jl, k, 2) - x(i, ny, k, 2)
        xd(i, je, k, 3) = two*xd(i, jl, k, 3) - xd(i, ny, k, 3)
        x(i, je, k, 3) = two*x(i, jl, k, 3) - x(i, ny, k, 3)
      end do
    end do
! extrapolation in k-direction.
    do j=0,je
      do i=0,ie
        xd(i, j, 0, 1) = two*xd(i, j, 1, 1) - xd(i, j, 2, 1)
        x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
        xd(i, j, 0, 2) = two*xd(i, j, 1, 2) - xd(i, j, 2, 2)
        x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
        xd(i, j, 0, 3) = two*xd(i, j, 1, 3) - xd(i, j, 2, 3)
        x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
        xd(i, j, ke, 1) = two*xd(i, j, kl, 1) - xd(i, j, nz, 1)
        x(i, j, ke, 1) = two*x(i, j, kl, 1) - x(i, j, nz, 1)
        xd(i, j, ke, 2) = two*xd(i, j, kl, 2) - xd(i, j, nz, 2)
        x(i, j, ke, 2) = two*x(i, j, kl, 2) - x(i, j, nz, 2)
        xd(i, j, ke, 3) = two*xd(i, j, kl, 3) - xd(i, j, nz, 3)
        x(i, j, ke, 3) = two*x(i, j, kl, 3) - x(i, j, nz, 3)
      end do
    end do
    v1d = 0.0_8
!
!           mirror the halo coordinates adjacent to the symmetry       
!           planes                                                     
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        norm(1) = bcdata(mm)%symnorm(1)
        norm(2) = bcdata(mm)%symnorm(2)
        norm(3) = bcdata(mm)%symnorm(3)
        arg1 = norm(1)**2 + norm(2)**2 + norm(3)**2
        length = sqrt(arg1)
! compute the unit normal of the subface.
        norm(1) = norm(1)/length
        norm(2) = norm(2)/length
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(1, i, j, 1) - xd(2, i, j, 1)
                v1(1) = x(1, i, j, 1) - x(2, i, j, 1)
                v1d(2) = xd(1, i, j, 2) - xd(2, i, j, 2)
                v1(2) = x(1, i, j, 2) - x(2, i, j, 2)
                v1d(3) = xd(1, i, j, 3) - xd(2, i, j, 3)
                v1(3) = x(1, i, j, 3) - x(2, i, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(0, i, j, 1) = xd(2, i, j, 1) + norm(1)*dotd
                x(0, i, j, 1) = x(2, i, j, 1) + dot*norm(1)
                xd(0, i, j, 2) = xd(2, i, j, 2) + norm(2)*dotd
                x(0, i, j, 2) = x(2, i, j, 2) + dot*norm(2)
                xd(0, i, j, 3) = xd(2, i, j, 3) + norm(3)*dotd
                x(0, i, j, 3) = x(2, i, j, 3) + dot*norm(3)
              end do
            end do
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(il, i, j, 1) - xd(nx, i, j, 1)
                v1(1) = x(il, i, j, 1) - x(nx, i, j, 1)
                v1d(2) = xd(il, i, j, 2) - xd(nx, i, j, 2)
                v1(2) = x(il, i, j, 2) - x(nx, i, j, 2)
                v1d(3) = xd(il, i, j, 3) - xd(nx, i, j, 3)
                v1(3) = x(il, i, j, 3) - x(nx, i, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(ie, i, j, 1) = xd(nx, i, j, 1) + norm(1)*dotd
                x(ie, i, j, 1) = x(nx, i, j, 1) + dot*norm(1)
                xd(ie, i, j, 2) = xd(nx, i, j, 2) + norm(2)*dotd
                x(ie, i, j, 2) = x(nx, i, j, 2) + dot*norm(2)
                xd(ie, i, j, 3) = xd(nx, i, j, 3) + norm(3)*dotd
                x(ie, i, j, 3) = x(nx, i, j, 3) + dot*norm(3)
              end do
            end do
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, 1, j, 1) - xd(i, 2, j, 1)
                v1(1) = x(i, 1, j, 1) - x(i, 2, j, 1)
                v1d(2) = xd(i, 1, j, 2) - xd(i, 2, j, 2)
                v1(2) = x(i, 1, j, 2) - x(i, 2, j, 2)
                v1d(3) = xd(i, 1, j, 3) - xd(i, 2, j, 3)
                v1(3) = x(i, 1, j, 3) - x(i, 2, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, 0, j, 1) = xd(i, 2, j, 1) + norm(1)*dotd
                x(i, 0, j, 1) = x(i, 2, j, 1) + dot*norm(1)
                xd(i, 0, j, 2) = xd(i, 2, j, 2) + norm(2)*dotd
                x(i, 0, j, 2) = x(i, 2, j, 2) + dot*norm(2)
                xd(i, 0, j, 3) = xd(i, 2, j, 3) + norm(3)*dotd
                x(i, 0, j, 3) = x(i, 2, j, 3) + dot*norm(3)
              end do
            end do
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, jl, j, 1) - xd(i, ny, j, 1)
                v1(1) = x(i, jl, j, 1) - x(i, ny, j, 1)
                v1d(2) = xd(i, jl, j, 2) - xd(i, ny, j, 2)
                v1(2) = x(i, jl, j, 2) - x(i, ny, j, 2)
                v1d(3) = xd(i, jl, j, 3) - xd(i, ny, j, 3)
                v1(3) = x(i, jl, j, 3) - x(i, ny, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, je, j, 1) = xd(i, ny, j, 1) + norm(1)*dotd
                x(i, je, j, 1) = x(i, ny, j, 1) + dot*norm(1)
                xd(i, je, j, 2) = xd(i, ny, j, 2) + norm(2)*dotd
                x(i, je, j, 2) = x(i, ny, j, 2) + dot*norm(2)
                xd(i, je, j, 3) = xd(i, ny, j, 3) + norm(3)*dotd
                x(i, je, j, 3) = x(i, ny, j, 3) + dot*norm(3)
              end do
            end do
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, j, 1, 1) - xd(i, j, 2, 1)
                v1(1) = x(i, j, 1, 1) - x(i, j, 2, 1)
                v1d(2) = xd(i, j, 1, 2) - xd(i, j, 2, 2)
                v1(2) = x(i, j, 1, 2) - x(i, j, 2, 2)
                v1d(3) = xd(i, j, 1, 3) - xd(i, j, 2, 3)
                v1(3) = x(i, j, 1, 3) - x(i, j, 2, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, j, 0, 1) = xd(i, j, 2, 1) + norm(1)*dotd
                x(i, j, 0, 1) = x(i, j, 2, 1) + dot*norm(1)
                xd(i, j, 0, 2) = xd(i, j, 2, 2) + norm(2)*dotd
                x(i, j, 0, 2) = x(i, j, 2, 2) + dot*norm(2)
                xd(i, j, 0, 3) = xd(i, j, 2, 3) + norm(3)*dotd
                x(i, j, 0, 3) = x(i, j, 2, 3) + dot*norm(3)
              end do
            end do
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, j, kl, 1) - xd(i, j, nz, 1)
                v1(1) = x(i, j, kl, 1) - x(i, j, nz, 1)
                v1d(2) = xd(i, j, kl, 2) - xd(i, j, nz, 2)
                v1(2) = x(i, j, kl, 2) - x(i, j, nz, 2)
                v1d(3) = xd(i, j, kl, 3) - xd(i, j, nz, 3)
                v1(3) = x(i, j, kl, 3) - x(i, j, nz, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, j, ke, 1) = xd(i, j, nz, 1) + norm(1)*dotd
                x(i, j, ke, 1) = x(i, j, nz, 1) + dot*norm(1)
                xd(i, j, ke, 2) = xd(i, j, nz, 2) + norm(2)*dotd
                x(i, j, ke, 2) = x(i, j, nz, 2) + dot*norm(2)
                xd(i, j, ke, 3) = xd(i, j, nz, 3) + norm(3)*dotd
                x(i, j, ke, 3) = x(i, j, nz, 3) + dot*norm(3)
              end do
            end do
          end select
        end if
      end if
    end do loopbocos
  end subroutine xhalo_block_d
  subroutine xhalo_block()
!
!       xhalo determines the coordinates of the nodal halo's.          
!       first it sets all halo coordinates by simple extrapolation,    
!       then the symmetry planes are treated (also the unit normal of  
!       symmetry planes are determined) and finally an exchange is     
!       made for the internal halo's.                                  
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype), dimension(3) :: v1, v2, norm
    intrinsic sqrt
    real(kind=realtype) :: arg1
! extrapolation in i-direction.
    do k=1,kl
      do j=1,jl
        x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
        x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
        x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
        x(ie, j, k, 1) = two*x(il, j, k, 1) - x(nx, j, k, 1)
        x(ie, j, k, 2) = two*x(il, j, k, 2) - x(nx, j, k, 2)
        x(ie, j, k, 3) = two*x(il, j, k, 3) - x(nx, j, k, 3)
      end do
    end do
! extrapolation in j-direction.
    do k=1,kl
      do i=0,ie
        x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
        x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
        x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
        x(i, je, k, 1) = two*x(i, jl, k, 1) - x(i, ny, k, 1)
        x(i, je, k, 2) = two*x(i, jl, k, 2) - x(i, ny, k, 2)
        x(i, je, k, 3) = two*x(i, jl, k, 3) - x(i, ny, k, 3)
      end do
    end do
! extrapolation in k-direction.
    do j=0,je
      do i=0,ie
        x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
        x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
        x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
        x(i, j, ke, 1) = two*x(i, j, kl, 1) - x(i, j, nz, 1)
        x(i, j, ke, 2) = two*x(i, j, kl, 2) - x(i, j, nz, 2)
        x(i, j, ke, 3) = two*x(i, j, kl, 3) - x(i, j, nz, 3)
      end do
    end do
!
!           mirror the halo coordinates adjacent to the symmetry       
!           planes                                                     
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        norm(1) = bcdata(mm)%symnorm(1)
        norm(2) = bcdata(mm)%symnorm(2)
        norm(3) = bcdata(mm)%symnorm(3)
        arg1 = norm(1)**2 + norm(2)**2 + norm(3)**2
        length = sqrt(arg1)
! compute the unit normal of the subface.
        norm(1) = norm(1)/length
        norm(2) = norm(2)/length
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(1, i, j, 1) - x(2, i, j, 1)
                v1(2) = x(1, i, j, 2) - x(2, i, j, 2)
                v1(3) = x(1, i, j, 3) - x(2, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(0, i, j, 1) = x(2, i, j, 1) + dot*norm(1)
                x(0, i, j, 2) = x(2, i, j, 2) + dot*norm(2)
                x(0, i, j, 3) = x(2, i, j, 3) + dot*norm(3)
              end do
            end do
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(il, i, j, 1) - x(nx, i, j, 1)
                v1(2) = x(il, i, j, 2) - x(nx, i, j, 2)
                v1(3) = x(il, i, j, 3) - x(nx, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(ie, i, j, 1) = x(nx, i, j, 1) + dot*norm(1)
                x(ie, i, j, 2) = x(nx, i, j, 2) + dot*norm(2)
                x(ie, i, j, 3) = x(nx, i, j, 3) + dot*norm(3)
              end do
            end do
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, 1, j, 1) - x(i, 2, j, 1)
                v1(2) = x(i, 1, j, 2) - x(i, 2, j, 2)
                v1(3) = x(i, 1, j, 3) - x(i, 2, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, 0, j, 1) = x(i, 2, j, 1) + dot*norm(1)
                x(i, 0, j, 2) = x(i, 2, j, 2) + dot*norm(2)
                x(i, 0, j, 3) = x(i, 2, j, 3) + dot*norm(3)
              end do
            end do
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, jl, j, 1) - x(i, ny, j, 1)
                v1(2) = x(i, jl, j, 2) - x(i, ny, j, 2)
                v1(3) = x(i, jl, j, 3) - x(i, ny, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, je, j, 1) = x(i, ny, j, 1) + dot*norm(1)
                x(i, je, j, 2) = x(i, ny, j, 2) + dot*norm(2)
                x(i, je, j, 3) = x(i, ny, j, 3) + dot*norm(3)
              end do
            end do
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, 1, 1) - x(i, j, 2, 1)
                v1(2) = x(i, j, 1, 2) - x(i, j, 2, 2)
                v1(3) = x(i, j, 1, 3) - x(i, j, 2, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, 0, 1) = x(i, j, 2, 1) + dot*norm(1)
                x(i, j, 0, 2) = x(i, j, 2, 2) + dot*norm(2)
                x(i, j, 0, 3) = x(i, j, 2, 3) + dot*norm(3)
              end do
            end do
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, kl, 1) - x(i, j, nz, 1)
                v1(2) = x(i, j, kl, 2) - x(i, j, nz, 2)
                v1(3) = x(i, j, kl, 3) - x(i, j, nz, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, ke, 1) = x(i, j, nz, 1) + dot*norm(1)
                x(i, j, ke, 2) = x(i, j, nz, 2) + dot*norm(2)
                x(i, j, ke, 3) = x(i, j, nz, 3) + dot*norm(3)
              end do
            end do
          end select
        end if
      end if
    end do loopbocos
  end subroutine xhalo_block
end module adjointextra_d

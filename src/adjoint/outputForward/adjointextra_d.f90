!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module adjointextra_d
  implicit none

contains
  subroutine volume_block()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vol = zero
    do k=1,ke
      n = k - 1
      do j=1,je
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x&
&               (i, m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2&
&               ), x(i, m, k, 3), vp1)
          call volpym(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, &
&               m, k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2&
&               ), x(l, j, n, 3), vp2)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, &
&               j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x&
&               (l, j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2&
&               ), x(i, j, n, 3), vp3)
          call volpym(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, &
&               m, n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2&
&               ), x(l, m, k, 3), vp4)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x&
&               (l, m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2&
&               ), x(l, j, k, 3), vp5)
          call volpym(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, &
&               j, n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2&
&               ), x(i, m, n, 3), vp6)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            vol(i, j, k) = vol(i, j, k)
          else
            vol(i, j, k) = -vol(i, j, k)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) vol(1, j, k)&
&          = vol(2, j, k)
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) vol(ie, j, k&
&         ) = vol(il, j, k)
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) vol(i, 1, k)&
&          = vol(i, 2, k)
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) vol(i, je, k&
&         ) = vol(i, jl, k)
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) vol(i, j, 1)&
&          = vol(i, j, 2)
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) vol(i, j, ke&
&         ) = vol(i, j, kl)
      end do
    end do

  contains
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,
!         whose coordinates are set in the subroutine metric itself,
!         is the top node and a-b-c-d is the quadrilateral surface.
!         it is assumed that the cross product vca * vdb points in
!         the direction of the top node. here vca is the diagonal
!         running from node c to node a and vdb the diagonal from
!         node d to node b.
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block
!  differentiation of volume_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *vol
!   with respect to varying inputs: *x
!   rw status of diff variables: *x:in *vol:out
!   plus diff mem management of: x:in vol:in
  subroutine volume_block_d()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xpd, ypd, zpd, vp1d, vp2d, vp3d, vp4d, vp5d, &
&   vp6d
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vold = 0.0_8
    vol = zero
    vold = 0.0_8
    vp1d = 0.0_8
    vp2d = 0.0_8
    vp3d = 0.0_8
    vp4d = 0.0_8
    vp5d = 0.0_8
    vp6d = 0.0_8
    do k=1,ke
      n = k - 1
      do j=1,je
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          xpd = eighth*(xd(i, j, k, 1)+xd(i, m, k, 1)+xd(i, m, n, 1)+xd(&
&           i, j, n, 1)+xd(l, j, k, 1)+xd(l, m, k, 1)+xd(l, m, n, 1)+xd(&
&           l, j, n, 1))
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          ypd = eighth*(xd(i, j, k, 2)+xd(i, m, k, 2)+xd(i, m, n, 2)+xd(&
&           i, j, n, 2)+xd(l, j, k, 2)+xd(l, m, k, 2)+xd(l, m, n, 2)+xd(&
&           l, j, n, 2))
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          zpd = eighth*(xd(i, j, k, 3)+xd(i, m, k, 3)+xd(i, m, n, 3)+xd(&
&           i, j, n, 3)+xd(l, j, k, 3)+xd(l, m, k, 3)+xd(l, m, n, 3)+xd(&
&           l, j, n, 3))
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym_d(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, j, n&
&                 , 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i, j, n, 2), x&
&                 (i, j, n, 3), xd(i, j, n, 3), x(i, m, n, 1), xd(i, m, &
&                 n, 1), x(i, m, n, 2), xd(i, m, n, 2), x(i, m, n, 3), &
&                 xd(i, m, n, 3), x(i, m, k, 1), xd(i, m, k, 1), x(i, m&
&                 , k, 2), xd(i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3)&
&                 , vp1, vp1d)
          call volpym_d(x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd&
&                 (l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), x(l, m, k&
&                 , 1), xd(l, m, k, 1), x(l, m, k, 2), xd(l, m, k, 2), x&
&                 (l, m, k, 3), xd(l, m, k, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, j, n, 1), xd(l, j, n, 1), x(l, j&
&                 , n, 2), xd(l, j, n, 2), x(l, j, n, 3), xd(l, j, n, 3)&
&                 , vp2, vp2d)
          call volpym_d(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(l, j, k&
&                 , 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l, j, k, 2), x&
&                 (l, j, k, 3), xd(l, j, k, 3), x(l, j, n, 1), xd(l, j, &
&                 n, 1), x(l, j, n, 2), xd(l, j, n, 2), x(l, j, n, 3), &
&                 xd(l, j, n, 3), x(i, j, n, 1), xd(i, j, n, 1), x(i, j&
&                 , n, 2), xd(i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3)&
&                 , vp3, vp3d)
          call volpym_d(x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd&
&                 (i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), x(i, m, n&
&                 , 1), xd(i, m, n, 1), x(i, m, n, 2), xd(i, m, n, 2), x&
&                 (i, m, n, 3), xd(i, m, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, m, k, 1), xd(l, m, k, 1), x(l, m&
&                 , k, 2), xd(l, m, k, 2), x(l, m, k, 3), xd(l, m, k, 3)&
&                 , vp4, vp4d)
          call volpym_d(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, m, k&
&                 , 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i, m, k, 2), x&
&                 (i, m, k, 3), xd(i, m, k, 3), x(l, m, k, 1), xd(l, m, &
&                 k, 1), x(l, m, k, 2), xd(l, m, k, 2), x(l, m, k, 3), &
&                 xd(l, m, k, 3), x(l, j, k, 1), xd(l, j, k, 1), x(l, j&
&                 , k, 2), xd(l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3)&
&                 , vp5, vp5d)
          call volpym_d(x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd&
&                 (i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), x(l, j, n&
&                 , 1), xd(l, j, n, 1), x(l, j, n, 2), xd(l, j, n, 2), x&
&                 (l, j, n, 3), xd(l, j, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(i, m, n, 1), xd(i, m, n, 1), x(i, m&
&                 , n, 2), xd(i, m, n, 2), x(i, m, n, 3), xd(i, m, n, 3)&
&                 , vp6, vp6d)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vold(i, j, k) = sixth*(vp1d+vp2d+vp3d+vp4d+vp5d+vp6d)
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            vol(i, j, k) = vol(i, j, k)
          else
            vold(i, j, k) = -vold(i, j, k)
            vol(i, j, k) = -vol(i, j, k)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) then
          vold(1, j, k) = vold(2, j, k)
          vol(1, j, k) = vol(2, j, k)
        end if
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) then
          vold(ie, j, k) = vold(il, j, k)
          vol(ie, j, k) = vol(il, j, k)
        end if
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) then
          vold(i, 1, k) = vold(i, 2, k)
          vol(i, 1, k) = vol(i, 2, k)
        end if
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) then
          vold(i, je, k) = vold(i, jl, k)
          vol(i, je, k) = vol(i, jl, k)
        end if
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) then
          vold(i, j, 1) = vold(i, j, 2)
          vol(i, j, 1) = vol(i, j, 2)
        end if
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) then
          vold(i, j, ke) = vold(i, j, kl)
          vol(i, j, ke) = vol(i, j, kl)
        end if
      end do
    end do

  contains
!  differentiation of volpym in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: volume
!   with respect to varying inputs: xp yp zp xa xb xc xd ya yb
!                yc yd za zb zc zd
    subroutine volpym_d(xa, xad, ya, yad, za, zad, xb, xbd, yb, ybd, zb&
&     , zbd, xc, xcd, yc, ycd, zc, zcd, xd, xdd, yd, ydd, zd, zdd, &
&     volume, volumed)
!
!         volpym computes 6 times the volume of a pyramid. node p,
!         whose coordinates are set in the subroutine metric itself,
!         is the top node and a-b-c-d is the quadrilateral surface.
!         it is assumed that the cross product vca * vdb points in
!         the direction of the top node. here vca is the diagonal
!         running from node c to node a and vdb the diagonal from
!         node d to node b.
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
      real(kind=realtype) :: volumed
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xad, yad, zad, xbd, ybd, zbd
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      real(kind=realtype), intent(in) :: xcd, ycd, zcd, xdd, ydd, zdd
      volumed = (xpd-fourth*(xad+xbd+xcd+xdd))*((ya-yc)*(zb-zd)-(za-zc)*&
&       (yb-yd)) + (xp-fourth*(xa+xb+xc+xd))*((yad-ycd)*(zb-zd)+(ya-yc)*&
&       (zbd-zdd)-(zad-zcd)*(yb-yd)-(za-zc)*(ybd-ydd)) + (ypd-fourth*(&
&       yad+ybd+ycd+ydd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd)) + (yp-fourth&
&       *(ya+yb+yc+yd))*((zad-zcd)*(xb-xd)+(za-zc)*(xbd-xdd)-(xad-xcd)*(&
&       zb-zd)-(xa-xc)*(zbd-zdd)) + (zpd-fourth*(zad+zbd+zcd+zdd))*((xa-&
&       xc)*(yb-yd)-(ya-yc)*(xb-xd)) + (zp-fourth*(za+zb+zc+zd))*((xad-&
&       xcd)*(yb-yd)+(xa-xc)*(ybd-ydd)-(yad-ycd)*(xb-xd)-(ya-yc)*(xbd-&
&       xdd))
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym_d
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,
!         whose coordinates are set in the subroutine metric itself,
!         is the top node and a-b-c-d is the quadrilateral surface.
!         it is assumed that the cross product vca * vdb points in
!         the direction of the top node. here vca is the diagonal
!         running from node c to node a and vdb the diagonal from
!         node d to node b.
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block_d
!  differentiation of metric_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *si *sj *sk
!   with respect to varying inputs: *x
!   rw status of diff variables: *x:in *si:out *sj:out *sk:out
!   plus diff mem management of: x:in si:in sj:in sk:in
  subroutine metric_block_d()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    real(kind=realtype), dimension(3) :: v1d, v2d
    intrinsic mod
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
      sid = 0.0_8
      v1d = 0.0_8
      v2d = 0.0_8
    else
      fact = -half
      sid = 0.0_8
      v1d = 0.0_8
      v2d = 0.0_8
    end if
!
!  computation of the face normals in i-, j- and k-direction.
!  formula's are valid for a right handed block; for a left
!  handed block the correct orientation is obtained via fact.
!  the normals point in the direction of increasing index.
!  the absolute value of fact is 0.5, because the cross
!  product of the two diagonals is twice the normal vector.
!  note that also the normals of the first level halo cells
!  are computed. these are needed for the viscous fluxes.
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1d(1) = xd(i, j, n, 1) - xd(i, m, k, 1)
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1d(2) = xd(i, j, n, 2) - xd(i, m, k, 2)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1d(3) = xd(i, j, n, 3) - xd(i, m, k, 3)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2d(1) = xd(i, j, k, 1) - xd(i, m, n, 1)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2d(2) = xd(i, j, k, 2) - xd(i, m, n, 2)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2d(3) = xd(i, j, k, 3) - xd(i, m, n, 3)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sid(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-v1(&
&       3)*v2d(2))
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sid(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-v1(&
&       1)*v2d(3))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sid(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-v1(&
&       2)*v2d(1))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    sjd = 0.0_8
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1d(1) = xd(i, j, n, 1) - xd(l, j, k, 1)
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1d(2) = xd(i, j, n, 2) - xd(l, j, k, 2)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1d(3) = xd(i, j, n, 3) - xd(l, j, k, 3)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2d(1) = xd(l, j, n, 1) - xd(i, j, k, 1)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2d(2) = xd(l, j, n, 2) - xd(i, j, k, 2)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2d(3) = xd(l, j, n, 3) - xd(i, j, k, 3)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sjd(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-v1(&
&       3)*v2d(2))
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sjd(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-v1(&
&       1)*v2d(3))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sjd(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-v1(&
&       2)*v2d(1))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    skd = 0.0_8
! projected areas of cell faces in the k direction.
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1d(1) = xd(i, j, k, 1) - xd(l, m, k, 1)
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1d(2) = xd(i, j, k, 2) - xd(l, m, k, 2)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1d(3) = xd(i, j, k, 3) - xd(l, m, k, 3)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2d(1) = xd(l, j, k, 1) - xd(i, m, k, 1)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2d(2) = xd(l, j, k, 2) - xd(i, m, k, 2)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2d(3) = xd(l, j, k, 3) - xd(i, m, k, 3)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      skd(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-v1(&
&       3)*v2d(2))
      sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      skd(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-v1(&
&       1)*v2d(3))
      sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      skd(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-v1(&
&       2)*v2d(1))
      sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
  end subroutine metric_block_d
  subroutine metric_block()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic mod
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
    else
      fact = -half
    end if
!
!  computation of the face normals in i-, j- and k-direction.
!  formula's are valid for a right handed block; for a left
!  handed block the correct orientation is obtained via fact.
!  the normals point in the direction of increasing index.
!  the absolute value of fact is 0.5, because the cross
!  product of the two diagonals is twice the normal vector.
!  note that also the normals of the first level halo cells
!  are computed. these are needed for the viscous fluxes.
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the k direction.
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
  end subroutine metric_block
!  differentiation of boundarynormals in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.norm)
!   with respect to varying inputs: *si *sj *sk
!   rw status of diff variables: *si:in *sj:in *sk:in *(*bcdata.norm):out
!   plus diff mem management of: si:in sj:in sk:in bcdata:in *bcdata.norm:in
  subroutine boundarynormals_d()
!  the unit normals on the boundary faces. these always point
!  out of the domain, so a multiplication by -1 is needed for
!  the imin, jmin and kmin boundaries.
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: factd
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype) :: xxpd, yypd, zzpd
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: ii1
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%norm = 0.0_8
    end do
    zzpd = 0.0_8
    yypd = 0.0_8
    xxpd = 0.0_8
!loop over the boundary subfaces of this block.
bocoloop:do mm=1,nbocos
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxpd = sid(1, i, j, 1)
          xxp = si(1, i, j, 1)
          yypd = sid(1, i, j, 2)
          yyp = si(1, i, j, 2)
          zzpd = sid(1, i, j, 3)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxpd = sid(il, i, j, 1)
          xxp = si(il, i, j, 1)
          yypd = sid(il, i, j, 2)
          yyp = si(il, i, j, 2)
          zzpd = sid(il, i, j, 3)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxpd = sjd(i, 1, j, 1)
          xxp = sj(i, 1, j, 1)
          yypd = sjd(i, 1, j, 2)
          yyp = sj(i, 1, j, 2)
          zzpd = sjd(i, 1, j, 3)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxpd = sjd(i, jl, j, 1)
          xxp = sj(i, jl, j, 1)
          yypd = sjd(i, jl, j, 2)
          yyp = sj(i, jl, j, 2)
          zzpd = sjd(i, jl, j, 3)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxpd = skd(i, j, 1, 1)
          xxp = sk(i, j, 1, 1)
          yypd = skd(i, j, 1, 2)
          yyp = sk(i, j, 1, 2)
          zzpd = skd(i, j, 1, 3)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxpd = skd(i, j, kl, 1)
          xxp = sk(i, j, kl, 1)
          yypd = skd(i, j, kl, 2)
          yyp = sk(i, j, kl, 2)
          zzpd = skd(i, j, kl, 3)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        arg1d = xxpd*xxp + xxp*xxpd + yypd*yyp + yyp*yypd + zzpd*zzp + &
&         zzp*zzpd
        arg1 = xxp*xxp + yyp*yyp + zzp*zzp
        if (arg1 .eq. 0.0_8) then
          factd = 0.0_8
        else
          factd = arg1d/(2.0*sqrt(arg1))
        end if
        fact = sqrt(arg1)
        if (fact .gt. zero) then
          factd = -(mult*factd/fact**2)
          fact = mult/fact
        end if
! compute the unit normal.
        bcdatad(mm)%norm(i, j, 1) = factd*xxp + fact*xxpd
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdatad(mm)%norm(i, j, 2) = factd*yyp + fact*yypd
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdatad(mm)%norm(i, j, 3) = factd*zzp + fact*zzpd
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
    end do bocoloop
  end subroutine boundarynormals_d
  subroutine boundarynormals()
!  the unit normals on the boundary faces. these always point
!  out of the domain, so a multiplication by -1 is needed for
!  the imin, jmin and kmin boundaries.
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xxp, yyp, zzp
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
!loop over the boundary subfaces of this block.
bocoloop:do mm=1,nbocos
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        arg1 = xxp*xxp + yyp*yyp + zzp*zzp
        fact = sqrt(arg1)
        if (fact .gt. zero) fact = mult/fact
! compute the unit normal.
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
    end do bocoloop
  end subroutine boundarynormals
!  differentiation of xhalo_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *x
!   with respect to varying inputs: *x
!   rw status of diff variables: *x:in-out
!   plus diff mem management of: x:in
  subroutine xhalo_block_d()
!
!       xhalo determines the coordinates of the nodal halo's.
!       first it sets all halo coordinates by simple extrapolation,
!       then the symmetry planes are treated (also the unit normal of
!       symmetry planes are determined) and finally an exchange is
!       made for the internal halo's.
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype) :: dotd
    real(kind=realtype), dimension(3) :: v1, v2, norm
    real(kind=realtype), dimension(3) :: v1d
    intrinsic sqrt
    real(kind=realtype) :: arg1
! extrapolation in i-direction.
    do k=1,kl
      do j=1,jl
        xd(0, j, k, 1) = two*xd(1, j, k, 1) - xd(2, j, k, 1)
        x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
        xd(0, j, k, 2) = two*xd(1, j, k, 2) - xd(2, j, k, 2)
        x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
        xd(0, j, k, 3) = two*xd(1, j, k, 3) - xd(2, j, k, 3)
        x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
        xd(ie, j, k, 1) = two*xd(il, j, k, 1) - xd(nx, j, k, 1)
        x(ie, j, k, 1) = two*x(il, j, k, 1) - x(nx, j, k, 1)
        xd(ie, j, k, 2) = two*xd(il, j, k, 2) - xd(nx, j, k, 2)
        x(ie, j, k, 2) = two*x(il, j, k, 2) - x(nx, j, k, 2)
        xd(ie, j, k, 3) = two*xd(il, j, k, 3) - xd(nx, j, k, 3)
        x(ie, j, k, 3) = two*x(il, j, k, 3) - x(nx, j, k, 3)
      end do
    end do
! extrapolation in j-direction.
    do k=1,kl
      do i=0,ie
        xd(i, 0, k, 1) = two*xd(i, 1, k, 1) - xd(i, 2, k, 1)
        x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
        xd(i, 0, k, 2) = two*xd(i, 1, k, 2) - xd(i, 2, k, 2)
        x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
        xd(i, 0, k, 3) = two*xd(i, 1, k, 3) - xd(i, 2, k, 3)
        x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
        xd(i, je, k, 1) = two*xd(i, jl, k, 1) - xd(i, ny, k, 1)
        x(i, je, k, 1) = two*x(i, jl, k, 1) - x(i, ny, k, 1)
        xd(i, je, k, 2) = two*xd(i, jl, k, 2) - xd(i, ny, k, 2)
        x(i, je, k, 2) = two*x(i, jl, k, 2) - x(i, ny, k, 2)
        xd(i, je, k, 3) = two*xd(i, jl, k, 3) - xd(i, ny, k, 3)
        x(i, je, k, 3) = two*x(i, jl, k, 3) - x(i, ny, k, 3)
      end do
    end do
! extrapolation in k-direction.
    do j=0,je
      do i=0,ie
        xd(i, j, 0, 1) = two*xd(i, j, 1, 1) - xd(i, j, 2, 1)
        x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
        xd(i, j, 0, 2) = two*xd(i, j, 1, 2) - xd(i, j, 2, 2)
        x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
        xd(i, j, 0, 3) = two*xd(i, j, 1, 3) - xd(i, j, 2, 3)
        x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
        xd(i, j, ke, 1) = two*xd(i, j, kl, 1) - xd(i, j, nz, 1)
        x(i, j, ke, 1) = two*x(i, j, kl, 1) - x(i, j, nz, 1)
        xd(i, j, ke, 2) = two*xd(i, j, kl, 2) - xd(i, j, nz, 2)
        x(i, j, ke, 2) = two*x(i, j, kl, 2) - x(i, j, nz, 2)
        xd(i, j, ke, 3) = two*xd(i, j, kl, 3) - xd(i, j, nz, 3)
        x(i, j, ke, 3) = two*x(i, j, kl, 3) - x(i, j, nz, 3)
      end do
    end do
    v1d = 0.0_8
!
!           mirror the halo coordinates adjacent to the symmetry
!           planes
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        norm(1) = bcdata(mm)%symnorm(1)
        norm(2) = bcdata(mm)%symnorm(2)
        norm(3) = bcdata(mm)%symnorm(3)
        arg1 = norm(1)**2 + norm(2)**2 + norm(3)**2
        length = sqrt(arg1)
! compute the unit normal of the subface.
        norm(1) = norm(1)/length
        norm(2) = norm(2)/length
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(1, i, j, 1) - xd(2, i, j, 1)
                v1(1) = x(1, i, j, 1) - x(2, i, j, 1)
                v1d(2) = xd(1, i, j, 2) - xd(2, i, j, 2)
                v1(2) = x(1, i, j, 2) - x(2, i, j, 2)
                v1d(3) = xd(1, i, j, 3) - xd(2, i, j, 3)
                v1(3) = x(1, i, j, 3) - x(2, i, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(0, i, j, 1) = xd(2, i, j, 1) + norm(1)*dotd
                x(0, i, j, 1) = x(2, i, j, 1) + dot*norm(1)
                xd(0, i, j, 2) = xd(2, i, j, 2) + norm(2)*dotd
                x(0, i, j, 2) = x(2, i, j, 2) + dot*norm(2)
                xd(0, i, j, 3) = xd(2, i, j, 3) + norm(3)*dotd
                x(0, i, j, 3) = x(2, i, j, 3) + dot*norm(3)
              end do
            end do
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(il, i, j, 1) - xd(nx, i, j, 1)
                v1(1) = x(il, i, j, 1) - x(nx, i, j, 1)
                v1d(2) = xd(il, i, j, 2) - xd(nx, i, j, 2)
                v1(2) = x(il, i, j, 2) - x(nx, i, j, 2)
                v1d(3) = xd(il, i, j, 3) - xd(nx, i, j, 3)
                v1(3) = x(il, i, j, 3) - x(nx, i, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(ie, i, j, 1) = xd(nx, i, j, 1) + norm(1)*dotd
                x(ie, i, j, 1) = x(nx, i, j, 1) + dot*norm(1)
                xd(ie, i, j, 2) = xd(nx, i, j, 2) + norm(2)*dotd
                x(ie, i, j, 2) = x(nx, i, j, 2) + dot*norm(2)
                xd(ie, i, j, 3) = xd(nx, i, j, 3) + norm(3)*dotd
                x(ie, i, j, 3) = x(nx, i, j, 3) + dot*norm(3)
              end do
            end do
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, 1, j, 1) - xd(i, 2, j, 1)
                v1(1) = x(i, 1, j, 1) - x(i, 2, j, 1)
                v1d(2) = xd(i, 1, j, 2) - xd(i, 2, j, 2)
                v1(2) = x(i, 1, j, 2) - x(i, 2, j, 2)
                v1d(3) = xd(i, 1, j, 3) - xd(i, 2, j, 3)
                v1(3) = x(i, 1, j, 3) - x(i, 2, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, 0, j, 1) = xd(i, 2, j, 1) + norm(1)*dotd
                x(i, 0, j, 1) = x(i, 2, j, 1) + dot*norm(1)
                xd(i, 0, j, 2) = xd(i, 2, j, 2) + norm(2)*dotd
                x(i, 0, j, 2) = x(i, 2, j, 2) + dot*norm(2)
                xd(i, 0, j, 3) = xd(i, 2, j, 3) + norm(3)*dotd
                x(i, 0, j, 3) = x(i, 2, j, 3) + dot*norm(3)
              end do
            end do
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, jl, j, 1) - xd(i, ny, j, 1)
                v1(1) = x(i, jl, j, 1) - x(i, ny, j, 1)
                v1d(2) = xd(i, jl, j, 2) - xd(i, ny, j, 2)
                v1(2) = x(i, jl, j, 2) - x(i, ny, j, 2)
                v1d(3) = xd(i, jl, j, 3) - xd(i, ny, j, 3)
                v1(3) = x(i, jl, j, 3) - x(i, ny, j, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, je, j, 1) = xd(i, ny, j, 1) + norm(1)*dotd
                x(i, je, j, 1) = x(i, ny, j, 1) + dot*norm(1)
                xd(i, je, j, 2) = xd(i, ny, j, 2) + norm(2)*dotd
                x(i, je, j, 2) = x(i, ny, j, 2) + dot*norm(2)
                xd(i, je, j, 3) = xd(i, ny, j, 3) + norm(3)*dotd
                x(i, je, j, 3) = x(i, ny, j, 3) + dot*norm(3)
              end do
            end do
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, j, 1, 1) - xd(i, j, 2, 1)
                v1(1) = x(i, j, 1, 1) - x(i, j, 2, 1)
                v1d(2) = xd(i, j, 1, 2) - xd(i, j, 2, 2)
                v1(2) = x(i, j, 1, 2) - x(i, j, 2, 2)
                v1d(3) = xd(i, j, 1, 3) - xd(i, j, 2, 3)
                v1(3) = x(i, j, 1, 3) - x(i, j, 2, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, j, 0, 1) = xd(i, j, 2, 1) + norm(1)*dotd
                x(i, j, 0, 1) = x(i, j, 2, 1) + dot*norm(1)
                xd(i, j, 0, 2) = xd(i, j, 2, 2) + norm(2)*dotd
                x(i, j, 0, 2) = x(i, j, 2, 2) + dot*norm(2)
                xd(i, j, 0, 3) = xd(i, j, 2, 3) + norm(3)*dotd
                x(i, j, 0, 3) = x(i, j, 2, 3) + dot*norm(3)
              end do
            end do
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1d(1) = xd(i, j, kl, 1) - xd(i, j, nz, 1)
                v1(1) = x(i, j, kl, 1) - x(i, j, nz, 1)
                v1d(2) = xd(i, j, kl, 2) - xd(i, j, nz, 2)
                v1(2) = x(i, j, kl, 2) - x(i, j, nz, 2)
                v1d(3) = xd(i, j, kl, 3) - xd(i, j, nz, 3)
                v1(3) = x(i, j, kl, 3) - x(i, j, nz, 3)
                dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
&                 )
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                xd(i, j, ke, 1) = xd(i, j, nz, 1) + norm(1)*dotd
                x(i, j, ke, 1) = x(i, j, nz, 1) + dot*norm(1)
                xd(i, j, ke, 2) = xd(i, j, nz, 2) + norm(2)*dotd
                x(i, j, ke, 2) = x(i, j, nz, 2) + dot*norm(2)
                xd(i, j, ke, 3) = xd(i, j, nz, 3) + norm(3)*dotd
                x(i, j, ke, 3) = x(i, j, nz, 3) + dot*norm(3)
              end do
            end do
          end select
        end if
      end if
    end do loopbocos
  end subroutine xhalo_block_d
  subroutine xhalo_block()
!
!       xhalo determines the coordinates of the nodal halo's.
!       first it sets all halo coordinates by simple extrapolation,
!       then the symmetry planes are treated (also the unit normal of
!       symmetry planes are determined) and finally an exchange is
!       made for the internal halo's.
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype), dimension(3) :: v1, v2, norm
    intrinsic sqrt
    real(kind=realtype) :: arg1
! extrapolation in i-direction.
    do k=1,kl
      do j=1,jl
        x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
        x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
        x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
        x(ie, j, k, 1) = two*x(il, j, k, 1) - x(nx, j, k, 1)
        x(ie, j, k, 2) = two*x(il, j, k, 2) - x(nx, j, k, 2)
        x(ie, j, k, 3) = two*x(il, j, k, 3) - x(nx, j, k, 3)
      end do
    end do
! extrapolation in j-direction.
    do k=1,kl
      do i=0,ie
        x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
        x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
        x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
        x(i, je, k, 1) = two*x(i, jl, k, 1) - x(i, ny, k, 1)
        x(i, je, k, 2) = two*x(i, jl, k, 2) - x(i, ny, k, 2)
        x(i, je, k, 3) = two*x(i, jl, k, 3) - x(i, ny, k, 3)
      end do
    end do
! extrapolation in k-direction.
    do j=0,je
      do i=0,ie
        x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
        x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
        x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
        x(i, j, ke, 1) = two*x(i, j, kl, 1) - x(i, j, nz, 1)
        x(i, j, ke, 2) = two*x(i, j, kl, 2) - x(i, j, nz, 2)
        x(i, j, ke, 3) = two*x(i, j, kl, 3) - x(i, j, nz, 3)
      end do
    end do
!
!           mirror the halo coordinates adjacent to the symmetry
!           planes
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        norm(1) = bcdata(mm)%symnorm(1)
        norm(2) = bcdata(mm)%symnorm(2)
        norm(3) = bcdata(mm)%symnorm(3)
        arg1 = norm(1)**2 + norm(2)**2 + norm(3)**2
        length = sqrt(arg1)
! compute the unit normal of the subface.
        norm(1) = norm(1)/length
        norm(2) = norm(2)/length
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(1, i, j, 1) - x(2, i, j, 1)
                v1(2) = x(1, i, j, 2) - x(2, i, j, 2)
                v1(3) = x(1, i, j, 3) - x(2, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(0, i, j, 1) = x(2, i, j, 1) + dot*norm(1)
                x(0, i, j, 2) = x(2, i, j, 2) + dot*norm(2)
                x(0, i, j, 3) = x(2, i, j, 3) + dot*norm(3)
              end do
            end do
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(il, i, j, 1) - x(nx, i, j, 1)
                v1(2) = x(il, i, j, 2) - x(nx, i, j, 2)
                v1(3) = x(il, i, j, 3) - x(nx, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(ie, i, j, 1) = x(nx, i, j, 1) + dot*norm(1)
                x(ie, i, j, 2) = x(nx, i, j, 2) + dot*norm(2)
                x(ie, i, j, 3) = x(nx, i, j, 3) + dot*norm(3)
              end do
            end do
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, 1, j, 1) - x(i, 2, j, 1)
                v1(2) = x(i, 1, j, 2) - x(i, 2, j, 2)
                v1(3) = x(i, 1, j, 3) - x(i, 2, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, 0, j, 1) = x(i, 2, j, 1) + dot*norm(1)
                x(i, 0, j, 2) = x(i, 2, j, 2) + dot*norm(2)
                x(i, 0, j, 3) = x(i, 2, j, 3) + dot*norm(3)
              end do
            end do
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, jl, j, 1) - x(i, ny, j, 1)
                v1(2) = x(i, jl, j, 2) - x(i, ny, j, 2)
                v1(3) = x(i, jl, j, 3) - x(i, ny, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, je, j, 1) = x(i, ny, j, 1) + dot*norm(1)
                x(i, je, j, 2) = x(i, ny, j, 2) + dot*norm(2)
                x(i, je, j, 3) = x(i, ny, j, 3) + dot*norm(3)
              end do
            end do
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, 1, 1) - x(i, j, 2, 1)
                v1(2) = x(i, j, 1, 2) - x(i, j, 2, 2)
                v1(3) = x(i, j, 1, 3) - x(i, j, 2, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, 0, 1) = x(i, j, 2, 1) + dot*norm(1)
                x(i, j, 0, 2) = x(i, j, 2, 2) + dot*norm(2)
                x(i, j, 0, 3) = x(i, j, 2, 3) + dot*norm(3)
              end do
            end do
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, kl, 1) - x(i, j, nz, 1)
                v1(2) = x(i, j, kl, 2) - x(i, j, nz, 2)
                v1(3) = x(i, j, kl, 3) - x(i, j, nz, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, ke, 1) = x(i, j, nz, 1) + dot*norm(1)
                x(i, j, ke, 2) = x(i, j, nz, 2) + dot*norm(2)
                x(i, j, ke, 3) = x(i, j, nz, 3) + dot*norm(3)
              end do
            end do
          end select
        end if
      end if
    end do loopbocos
  end subroutine xhalo_block
!  differentiation of resscale in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *dw
!   rw status of diff variables: *dw:in-out
!   plus diff mem management of: dw:in
  subroutine resscale_d()
    use constants
    use blockpointers, only : il, jl, kl, nx, ny, nz, volref, dw, dwd
    use flowvarrefstate, only : nwf, nt1, nt2
    use inputiteration, only : turbresscale
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii, nturb
    real(kind=realtype) :: ovol
! divide through by the reference volume
    nturb = nt2 - nt1 + 1
    do k=2,kl
      do j=2,jl
        do i=2,il
          ovol = one/volref(i, j, k)
          dwd(i, j, k, 1:nwf) = ovol*dwd(i, j, k, 1:nwf)
          dw(i, j, k, 1:nwf) = dw(i, j, k, 1:nwf)*ovol
          dwd(i, j, k, nt1:nt2) = ovol*turbresscale(1:nturb)*dwd(i, j, k&
&           , nt1:nt2)
          dw(i, j, k, nt1:nt2) = dw(i, j, k, nt1:nt2)*ovol*turbresscale(&
&           1:nturb)
        end do
      end do
    end do
  end subroutine resscale_d
  subroutine resscale()
    use constants
    use blockpointers, only : il, jl, kl, nx, ny, nz, volref, dw
    use flowvarrefstate, only : nwf, nt1, nt2
    use inputiteration, only : turbresscale
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii, nturb
    real(kind=realtype) :: ovol
! divide through by the reference volume
    nturb = nt2 - nt1 + 1
    do k=2,kl
      do j=2,jl
        do i=2,il
          ovol = one/volref(i, j, k)
          dw(i, j, k, 1:nwf) = dw(i, j, k, 1:nwf)*ovol
          dw(i, j, k, nt1:nt2) = dw(i, j, k, nt1:nt2)*ovol*turbresscale(&
&           1:nturb)
        end do
      end do
    end do
  end subroutine resscale
!  differentiation of sumdwandfw in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *dw *fw
!   rw status of diff variables: *dw:in-out *fw:in
!   plus diff mem management of: dw:in fw:in
  subroutine sumdwandfw_d()
    use constants
    use blockpointers, only : il, jl, kl, dw, dwd, fw, fwd, iblank
    use flowvarrefstate, only : nwf
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, l
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    real(kind=realtype) :: max1
    do l=1,nwf
      do k=2,kl
        do j=2,jl
          do i=2,il
            x1 = real(iblank(i, j, k), realtype)
            if (x1 .lt. zero) then
              max1 = zero
            else
              max1 = x1
            end if
            dwd(i, j, k, l) = max1*(dwd(i, j, k, l)+fwd(i, j, k, l))
            dw(i, j, k, l) = (dw(i, j, k, l)+fw(i, j, k, l))*max1
          end do
        end do
      end do
    end do
  end subroutine sumdwandfw_d
  subroutine sumdwandfw()
    use constants
    use blockpointers, only : il, jl, kl, dw, fw, iblank
    use flowvarrefstate, only : nwf
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, l
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    real(kind=realtype) :: max1
    do l=1,nwf
      do k=2,kl
        do j=2,jl
          do i=2,il
            x1 = real(iblank(i, j, k), realtype)
            if (x1 .lt. zero) then
              max1 = zero
            else
              max1 = x1
            end if
            dw(i, j, k, l) = (dw(i, j, k, l)+fw(i, j, k, l))*max1
          end do
        end do
      end do
    end do
  end subroutine sumdwandfw


!  differentiation of slipvelocitiesfinelevel_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.uslip)
!   with respect to varying inputs: veldirfreestream machgrid gammainf
!                pinf timeref rhoinf *x
!   rw status of diff variables: veldirfreestream:in machgrid:in
!                gammainf:in pinf:in timeref:in rhoinf:in *x:in
!                *(*bcdata.uslip):out
!   plus diff mem management of: x:in bcdata:in *bcdata.uslip:in
! mham addition
  subroutine slipvelocitiesfinelevel_block_d(useoldcoor, t, sps)
!
!       slipvelocitiesfinelevel computes the slip velocities for
!       viscous subfaces on all viscous boundaries on groundlevel for
!       the given spectral solution. if useoldcoor is .true. the
!       velocities are determined using the unsteady time integrator;
!       otherwise the analytic form is used.
!
    use constants
    use inputtimespectral
! this gives nbkglobal
    use blockpointers
    use cgnsgrid
    use flowvarrefstate
    use inputmotion
    use inputunsteady
    use iteration
    use inputphysics
    use inputtsstabderiv
    use monitor
    use communication
    use flowutils_d, only : derivativerotmatrixrigid, &
&   derivativerotmatrixrigid_d, getdirvector, getdirvector_d
    use utils_d, only : tsalpha, tsbeta, tsmach, terminate, &
&   rotmatrixrigidbody, setcoeftimeintegrator, getdirangle
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
! mham: these nested loops have been replaced by fakenestedloop2
!    enddo
! enddo
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: useoldcoor
    real(kind=realtype), dimension(*), intent(in) :: t
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm, i, j, level
    real(kind=realtype) :: oneover4dt
    real(kind=realtype) :: velxgrid, velygrid, velzgrid, ainf
    real(kind=realtype) :: velxgridd, velygridd, velzgridd, ainfd
    real(kind=realtype) :: velxgrid0, velygrid0, velzgrid0
    real(kind=realtype) :: velxgrid0d, velygrid0d, velzgrid0d
    real(kind=realtype), dimension(3) :: xc, xxc
    real(kind=realtype), dimension(3) :: xcd, xxcd
    real(kind=realtype), dimension(3) :: rotcenter, rotrate
    real(kind=realtype), dimension(3) :: rotrated
    real(kind=realtype), dimension(3) :: rotationpoint
    real(kind=realtype), dimension(3, 3) :: rotationmatrix, &
&   derivrotationmatrix
    real(kind=realtype), dimension(3, 3) :: derivrotationmatrixd
    real(kind=realtype) :: tnew, told
! mham corrections for tapenade use
! real(kind=realtype), dimension(:,:,:),   pointer :: uslip
! real(kind=realtype), dimension(:,:,:),   pointer :: xface
! mham: we do not need xfaceold...
! real(kind=realtype), dimension(:,:,:,:), pointer :: xfaceold
!
! l. 2241 in bcdata.f90
! bcdata(mm)%uslip(ibeg:iend,jbeg:jend,3)
! this one we simply insert below. it is one-to-one. code will be longer
! / less readable but effectively unaltered
!
    real(kind=realtype) :: xface_x, xface_y, xface_z
    real(kind=realtype) :: xface_xd, xface_yd, xface_zd
    real(kind=realtype) :: xface_x_ij_10, xface_y_ij_10, xface_z_ij_10, &
&   xface_x_ij_01, xface_y_ij_01, xface_z_ij_01, xface_x_ij_11, &
&   xface_y_ij_11, xface_z_ij_11
    real(kind=realtype) :: xface_x_ij_10d, xface_y_ij_10d, &
&   xface_z_ij_10d, xface_x_ij_01d, xface_y_ij_01d, xface_z_ij_01d, &
&   xface_x_ij_11d, xface_y_ij_11d, xface_z_ij_11d
! real(kind=realtype)   :: xfaceold
! mham: now, we must remember to declare new counter used in the fake-loop
    integer :: ii, i_, j_
!        
    real(kind=realtype) :: intervalmach, alphats, alphaincrement, betats&
&   , betaincrement
    real(kind=realtype), dimension(3) :: veldir
    real(kind=realtype), dimension(3) :: refdirection
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: ii1
! determine the situation we are having here.
    if (useoldcoor) then
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%uslip = 0.0_8
      end do
    else
! mham: nothing here, since we set useoldcoor=.false.
!       everything has been cut out.
! the velocities must be determined analytically.
! compute the mesh velocity from the given mesh mach number.
!  ainf = sqrt(gammainf*pinf/rhoinf)
!  velxgrid = ainf*machgrid(1)
!  velygrid = ainf*machgrid(2)
!  velzgrid = ainf*machgrid(3)
      arg1d = ((gammainfd*pinf+gammainf*pinfd)*rhoinf-gammainf*pinf*&
&       rhoinfd)/rhoinf**2
      arg1 = gammainf*pinf/rhoinf
      if (arg1 .eq. 0.0_8) then
        ainfd = 0.0_8
      else
        ainfd = arg1d/(2.0*sqrt(arg1))
      end if
      ainf = sqrt(arg1)
      velxgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(1)&
&       ) - ainf*machgrid*veldirfreestreamd(1)
      velxgrid0 = ainf*machgrid*(-veldirfreestream(1))
      velygrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(2)&
&       ) - ainf*machgrid*veldirfreestreamd(2)
      velygrid0 = ainf*machgrid*(-veldirfreestream(2))
      velzgrid0d = -((ainfd*machgrid+ainf*machgridd)*veldirfreestream(3)&
&       ) - ainf*machgrid*veldirfreestreamd(3)
      velzgrid0 = ainf*machgrid*(-veldirfreestream(3))
! compute the derivative of the rotation matrix and the rotation
! point; needed for velocity due to the rigid body rotation of
! the entire grid. it is assumed that the rigid body motion of
! the grid is only specified if there is only 1 section present.
      call derivativerotmatrixrigid_d(derivrotationmatrix, &
&                               derivrotationmatrixd, rotationpoint, t(1&
&                               ))
!compute the rotation matrix to update the velocities for the time
!spectral stability derivative case...
      if (tsstability) then
! determine the time values of the old and new time level.
! it is assumed that the rigid body rotation of the mesh is only
! used when only 1 section is present.
        tnew = timeunsteady + timeunsteadyrestart
        told = tnew - t(1)
        if ((tspmode .or. tsqmode) .or. tsrmode) then
! compute the rotation matrix of the rigid body rotation as
! well as the rotation point; the latter may vary in time due
! to rigid body translation.
          call rotmatrixrigidbody(tnew, told, rotationmatrix, &
&                           rotationpoint)
          if (tsalphafollowing) then
            velxgrid0d = rotationmatrix(1, 1)*velxgrid0d + &
&             rotationmatrix(1, 2)*velygrid0d + rotationmatrix(1, 3)*&
&             velzgrid0d
            velxgrid0 = rotationmatrix(1, 1)*velxgrid0 + rotationmatrix(&
&             1, 2)*velygrid0 + rotationmatrix(1, 3)*velzgrid0
            velygrid0d = rotationmatrix(2, 1)*velxgrid0d + &
&             rotationmatrix(2, 2)*velygrid0d + rotationmatrix(2, 3)*&
&             velzgrid0d
            velygrid0 = rotationmatrix(2, 1)*velxgrid0 + rotationmatrix(&
&             2, 2)*velygrid0 + rotationmatrix(2, 3)*velzgrid0
            velzgrid0d = rotationmatrix(3, 1)*velxgrid0d + &
&             rotationmatrix(3, 2)*velygrid0d + rotationmatrix(3, 3)*&
&             velzgrid0d
            velzgrid0 = rotationmatrix(3, 1)*velxgrid0 + rotationmatrix(&
&             3, 2)*velygrid0 + rotationmatrix(3, 3)*velzgrid0
            do ii1=1,isize1ofdrfbcdata
              bcdatad(ii1)%uslip = 0.0_8
            end do
            xface_x_ij_10d = 0.0_8
            xface_x_ij_11d = 0.0_8
            xcd = 0.0_8
            xxcd = 0.0_8
            xface_z_ij_01d = 0.0_8
            xface_y_ij_01d = 0.0_8
            xface_z_ij_10d = 0.0_8
            xface_z_ij_11d = 0.0_8
            xface_x_ij_01d = 0.0_8
            xface_y_ij_10d = 0.0_8
            xface_y_ij_11d = 0.0_8
            xface_xd = 0.0_8
            xface_yd = 0.0_8
            xface_zd = 0.0_8
          else
            do ii1=1,isize1ofdrfbcdata
              bcdatad(ii1)%uslip = 0.0_8
            end do
            xface_x_ij_10d = 0.0_8
            xface_x_ij_11d = 0.0_8
            xcd = 0.0_8
            xxcd = 0.0_8
            xface_z_ij_01d = 0.0_8
            xface_y_ij_01d = 0.0_8
            xface_z_ij_10d = 0.0_8
            xface_z_ij_11d = 0.0_8
            xface_x_ij_01d = 0.0_8
            xface_y_ij_10d = 0.0_8
            xface_y_ij_11d = 0.0_8
            xface_xd = 0.0_8
            xface_yd = 0.0_8
            xface_zd = 0.0_8
          end if
        else if (tsalphamode) then
!determine the alpha for this time instance
          alphaincrement = tsalpha(degreepolalpha, coefpolalpha, &
&           degreefouralpha, omegafouralpha, coscoeffouralpha, &
&           sincoeffouralpha, t(1))
          alphats = alpha + alphaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector(refdirection, alphats, beta, veldir, &
&                     liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          velxgrid0d = -(veldir(1)*(ainfd*machgrid+ainf*machgridd))
          velxgrid0 = ainf*machgrid*(-veldir(1))
          velygrid0d = -(veldir(2)*(ainfd*machgrid+ainf*machgridd))
          velygrid0 = ainf*machgrid*(-veldir(2))
          velzgrid0d = -(veldir(3)*(ainfd*machgrid+ainf*machgridd))
          velzgrid0 = ainf*machgrid*(-veldir(3))
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xface_x_ij_10d = 0.0_8
          xface_x_ij_11d = 0.0_8
          xcd = 0.0_8
          xxcd = 0.0_8
          xface_z_ij_01d = 0.0_8
          xface_y_ij_01d = 0.0_8
          xface_z_ij_10d = 0.0_8
          xface_z_ij_11d = 0.0_8
          xface_x_ij_01d = 0.0_8
          xface_y_ij_10d = 0.0_8
          xface_y_ij_11d = 0.0_8
          xface_xd = 0.0_8
          xface_yd = 0.0_8
          xface_zd = 0.0_8
        else if (tsbetamode) then
!determine the alpha for this time instance
          betaincrement = tsbeta(degreepolbeta, coefpolbeta, &
&           degreefourbeta, omegafourbeta, coscoeffourbeta, &
&           sincoeffourbeta, t(1))
          betats = beta + betaincrement
!determine the grid velocity for this alpha
          refdirection(:) = zero
          refdirection(1) = one
          call getdirvector(refdirection, alpha, betats, veldir, &
&                     liftindex)
!do i need to update the lift direction and drag direction as well?
!set the effictive grid velocity for this time interval
          velxgrid0d = -(veldir(1)*(ainfd*machgrid+ainf*machgridd))
          velxgrid0 = ainf*machgrid*(-veldir(1))
          velygrid0d = -(veldir(2)*(ainfd*machgrid+ainf*machgridd))
          velygrid0 = ainf*machgrid*(-veldir(2))
          velzgrid0d = -(veldir(3)*(ainfd*machgrid+ainf*machgridd))
          velzgrid0 = ainf*machgrid*(-veldir(3))
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xface_x_ij_10d = 0.0_8
          xface_x_ij_11d = 0.0_8
          xcd = 0.0_8
          xxcd = 0.0_8
          xface_z_ij_01d = 0.0_8
          xface_y_ij_01d = 0.0_8
          xface_z_ij_10d = 0.0_8
          xface_z_ij_11d = 0.0_8
          xface_x_ij_01d = 0.0_8
          xface_y_ij_10d = 0.0_8
          xface_y_ij_11d = 0.0_8
          xface_xd = 0.0_8
          xface_yd = 0.0_8
          xface_zd = 0.0_8
        else if (tsmachmode) then
!determine the mach number at this time interval
          intervalmach = tsmach(degreepolmach, coefpolmach, &
&           degreefourmach, omegafourmach, coscoeffourmach, &
&           sincoeffourmach, t(1))
!set the effective grid velocity
          velxgrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&           veldirfreestream(1)) - ainf*(intervalmach+machgrid)*&
&           veldirfreestreamd(1)
          velxgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(1)&
&           )
          velygrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&           veldirfreestream(2)) - ainf*(intervalmach+machgrid)*&
&           veldirfreestreamd(2)
          velygrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(2)&
&           )
          velzgrid0d = -((ainfd*(intervalmach+machgrid)+ainf*machgridd)*&
&           veldirfreestream(3)) - ainf*(intervalmach+machgrid)*&
&           veldirfreestreamd(3)
          velzgrid0 = ainf*(intervalmach+machgrid)*(-veldirfreestream(3)&
&           )
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xface_x_ij_10d = 0.0_8
          xface_x_ij_11d = 0.0_8
          xcd = 0.0_8
          xxcd = 0.0_8
          xface_z_ij_01d = 0.0_8
          xface_y_ij_01d = 0.0_8
          xface_z_ij_10d = 0.0_8
          xface_z_ij_11d = 0.0_8
          xface_x_ij_01d = 0.0_8
          xface_y_ij_10d = 0.0_8
          xface_y_ij_11d = 0.0_8
          xface_xd = 0.0_8
          xface_yd = 0.0_8
          xface_zd = 0.0_8
        else if (tsaltitudemode) then
          call terminate('gridvelocityfinelevel', &
&                  'altitude motion not yet implemented...')
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xface_x_ij_10d = 0.0_8
          xface_x_ij_11d = 0.0_8
          xcd = 0.0_8
          xxcd = 0.0_8
          xface_z_ij_01d = 0.0_8
          xface_y_ij_01d = 0.0_8
          xface_z_ij_10d = 0.0_8
          xface_z_ij_11d = 0.0_8
          xface_x_ij_01d = 0.0_8
          xface_y_ij_10d = 0.0_8
          xface_y_ij_11d = 0.0_8
          xface_xd = 0.0_8
          xface_yd = 0.0_8
          xface_zd = 0.0_8
        else
          call terminate('gridvelocityfinelevel', &
&                  'not a recognized stability motion')
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%uslip = 0.0_8
          end do
          xface_x_ij_10d = 0.0_8
          xface_x_ij_11d = 0.0_8
          xcd = 0.0_8
          xxcd = 0.0_8
          xface_z_ij_01d = 0.0_8
          xface_y_ij_01d = 0.0_8
          xface_z_ij_10d = 0.0_8
          xface_z_ij_11d = 0.0_8
          xface_x_ij_01d = 0.0_8
          xface_y_ij_10d = 0.0_8
          xface_y_ij_11d = 0.0_8
          xface_xd = 0.0_8
          xface_yd = 0.0_8
          xface_zd = 0.0_8
        end if
      else
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%uslip = 0.0_8
        end do
        xface_x_ij_10d = 0.0_8
        xface_x_ij_11d = 0.0_8
        xcd = 0.0_8
        xxcd = 0.0_8
        xface_z_ij_01d = 0.0_8
        xface_y_ij_01d = 0.0_8
        xface_z_ij_10d = 0.0_8
        xface_z_ij_11d = 0.0_8
        xface_x_ij_01d = 0.0_8
        xface_y_ij_10d = 0.0_8
        xface_y_ij_11d = 0.0_8
        xface_xd = 0.0_8
        xface_yd = 0.0_8
        xface_zd = 0.0_8
      end if
! loop over the number of viscous subfaces.
bocoloop2:do mm=1,nviscbocos
        do j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
          do i=bcdata(mm)%icbeg,bcdata(mm)%icend
! determine the grid face on which the subface is located
! and set some variables accordingly.
            select case  (bcfaceid(mm)) 
            case (imin) 
! xface => x(1,:,:,:)
              xface_xd = xd(1, i-1, j-1, 1)
              xface_x = x(1, i-1, j-1, 1)
              xface_yd = xd(1, i-1, j-1, 2)
              xface_y = x(1, i-1, j-1, 2)
              xface_zd = xd(1, i-1, j-1, 3)
              xface_z = x(1, i-1, j-1, 3)
              xface_x_ij_10d = xd(1, i+1-1, j+0-1, 1)
              xface_x_ij_10 = x(1, i+1-1, j+0-1, 1)
              xface_y_ij_10d = xd(1, i+1-1, j+0-1, 2)
              xface_y_ij_10 = x(1, i+1-1, j+0-1, 2)
              xface_z_ij_10d = xd(1, i+1-1, j+0-1, 3)
              xface_z_ij_10 = x(1, i+1-1, j+0-1, 3)
              xface_x_ij_01d = xd(1, i+0-1, j+1-1, 1)
              xface_x_ij_01 = x(1, i+0-1, j+1-1, 1)
              xface_y_ij_01d = xd(1, i+0-1, j+1-1, 2)
              xface_y_ij_01 = x(1, i+0-1, j+1-1, 2)
              xface_z_ij_01d = xd(1, i+0-1, j+1-1, 3)
              xface_z_ij_01 = x(1, i+0-1, j+1-1, 3)
              xface_x_ij_11d = xd(1, i+1-1, j+1-1, 1)
              xface_x_ij_11 = x(1, i+1-1, j+1-1, 1)
              xface_y_ij_11d = xd(1, i+1-1, j+1-1, 2)
              xface_y_ij_11 = x(1, i+1-1, j+1-1, 2)
              xface_z_ij_11d = xd(1, i+1-1, j+1-1, 3)
              xface_z_ij_11 = x(1, i+1-1, j+1-1, 3)
            case (imax) 
! xface => x(il,:,:,:)
              xface_xd = xd(il, i-1, j-1, 1)
              xface_x = x(il, i-1, j-1, 1)
              xface_yd = xd(il, i-1, j-1, 2)
              xface_y = x(il, i-1, j-1, 2)
              xface_zd = xd(il, i-1, j-1, 3)
              xface_z = x(il, i-1, j-1, 3)
              xface_x_ij_10d = xd(il, i+1-1, j+0-1, 1)
              xface_x_ij_10 = x(il, i+1-1, j+0-1, 1)
              xface_y_ij_10d = xd(il, i+1-1, j+0-1, 2)
              xface_y_ij_10 = x(il, i+1-1, j+0-1, 2)
              xface_z_ij_10d = xd(il, i+1-1, j+0-1, 3)
              xface_z_ij_10 = x(il, i+1-1, j+0-1, 3)
              xface_x_ij_01d = xd(il, i+0-1, j+1-1, 1)
              xface_x_ij_01 = x(il, i+0-1, j+1-1, 1)
              xface_y_ij_01d = xd(il, i+0-1, j+1-1, 2)
              xface_y_ij_01 = x(il, i+0-1, j+1-1, 2)
              xface_z_ij_01d = xd(il, i+0-1, j+1-1, 3)
              xface_z_ij_01 = x(il, i+0-1, j+1-1, 3)
              xface_x_ij_11d = xd(il, i+1-1, j+1-1, 1)
              xface_x_ij_11 = x(il, i+1-1, j+1-1, 1)
              xface_y_ij_11d = xd(il, i+1-1, j+1-1, 2)
              xface_y_ij_11 = x(il, i+1-1, j+1-1, 2)
              xface_z_ij_11d = xd(il, i+1-1, j+1-1, 3)
              xface_z_ij_11 = x(il, i+1-1, j+1-1, 3)
            case (jmin) 
! xface => x(:,1,:,:)
              xface_xd = xd(i-1, 1, j-1, 1)
              xface_x = x(i-1, 1, j-1, 1)
              xface_yd = xd(i-1, 1, j-1, 2)
              xface_y = x(i-1, 1, j-1, 2)
              xface_zd = xd(i-1, 1, j-1, 3)
              xface_z = x(i-1, 1, j-1, 3)
              xface_x_ij_10d = xd(i+1-1, 1, j+0-1, 1)
              xface_x_ij_10 = x(i+1-1, 1, j+0-1, 1)
              xface_y_ij_10d = xd(i+1-1, 1, j+0-1, 2)
              xface_y_ij_10 = x(i+1-1, 1, j+0-1, 2)
              xface_z_ij_10d = xd(i+1-1, 1, j+0-1, 3)
              xface_z_ij_10 = x(i+1-1, 1, j+0-1, 3)
              xface_x_ij_01d = xd(i+0-1, 1, j+1-1, 1)
              xface_x_ij_01 = x(i+0-1, 1, j+1-1, 1)
              xface_y_ij_01d = xd(i+0-1, 1, j+1-1, 2)
              xface_y_ij_01 = x(i+0-1, 1, j+1-1, 2)
              xface_z_ij_01d = xd(i+0-1, 1, j+1-1, 3)
              xface_z_ij_01 = x(i+0-1, 1, j+1-1, 3)
              xface_x_ij_11d = xd(i+1-1, 1, j+1-1, 1)
              xface_x_ij_11 = x(i+1-1, 1, j+1-1, 1)
              xface_y_ij_11d = xd(i+1-1, 1, j+1-1, 2)
              xface_y_ij_11 = x(i+1-1, 1, j+1-1, 2)
              xface_z_ij_11d = xd(i+1-1, 1, j+1-1, 3)
              xface_z_ij_11 = x(i+1-1, 1, j+1-1, 3)
            case (jmax) 
! xface => x(:,jl,:,:)
              xface_xd = xd(i-1, jl, j-1, 1)
              xface_x = x(i-1, jl, j-1, 1)
              xface_yd = xd(i-1, jl, j-1, 2)
              xface_y = x(i-1, jl, j-1, 2)
              xface_zd = xd(i-1, jl, j-1, 3)
              xface_z = x(i-1, jl, j-1, 3)
              xface_x_ij_10d = xd(i+1-1, jl, j+0-1, 1)
              xface_x_ij_10 = x(i+1-1, jl, j+0-1, 1)
              xface_y_ij_10d = xd(i+1-1, jl, j+0-1, 2)
              xface_y_ij_10 = x(i+1-1, jl, j+0-1, 2)
              xface_z_ij_10d = xd(i+1-1, jl, j+0-1, 3)
              xface_z_ij_10 = x(i+1-1, jl, j+0-1, 3)
              xface_x_ij_01d = xd(i+0-1, jl, j+1-1, 1)
              xface_x_ij_01 = x(i+0-1, jl, j+1-1, 1)
              xface_y_ij_01d = xd(i+0-1, jl, j+1-1, 2)
              xface_y_ij_01 = x(i+0-1, jl, j+1-1, 2)
              xface_z_ij_01d = xd(i+0-1, jl, j+1-1, 3)
              xface_z_ij_01 = x(i+0-1, jl, j+1-1, 3)
              xface_x_ij_11d = xd(i+1-1, jl, j+1-1, 1)
              xface_x_ij_11 = x(i+1-1, jl, j+1-1, 1)
              xface_y_ij_11d = xd(i+1-1, jl, j+1-1, 2)
              xface_y_ij_11 = x(i+1-1, jl, j+1-1, 2)
              xface_z_ij_11d = xd(i+1-1, jl, j+1-1, 3)
              xface_z_ij_11 = x(i+1-1, jl, j+1-1, 3)
            case (kmin) 
! xface => x(:,:,1,:)
              xface_xd = xd(i-1, j-1, 1, 1)
              xface_x = x(i-1, j-1, 1, 1)
              xface_yd = xd(i-1, j-1, 1, 2)
              xface_y = x(i-1, j-1, 1, 2)
              xface_zd = xd(i-1, j-1, 1, 3)
              xface_z = x(i-1, j-1, 1, 3)
              xface_x_ij_10d = xd(i+1-1, j+0-1, 1, 1)
              xface_x_ij_10 = x(i+1-1, j+0-1, 1, 1)
              xface_y_ij_10d = xd(i+1-1, j+0-1, 1, 2)
              xface_y_ij_10 = x(i+1-1, j+0-1, 1, 2)
              xface_z_ij_10d = xd(i+1-1, j+0-1, 1, 3)
              xface_z_ij_10 = x(i+1-1, j+0-1, 1, 3)
              xface_x_ij_01d = xd(i+0-1, j+1-1, 1, 1)
              xface_x_ij_01 = x(i+0-1, j+1-1, 1, 1)
              xface_y_ij_01d = xd(i+0-1, j+1-1, 1, 2)
              xface_y_ij_01 = x(i+0-1, j+1-1, 1, 2)
              xface_z_ij_01d = xd(i+0-1, j+1-1, 1, 3)
              xface_z_ij_01 = x(i+0-1, j+1-1, 1, 3)
              xface_x_ij_11d = xd(i+1-1, j+1-1, 1, 1)
              xface_x_ij_11 = x(i+1-1, j+1-1, 1, 1)
              xface_y_ij_11d = xd(i+1-1, j+1-1, 1, 2)
              xface_y_ij_11 = x(i+1-1, j+1-1, 1, 2)
              xface_z_ij_11d = xd(i+1-1, j+1-1, 1, 3)
              xface_z_ij_11 = x(i+1-1, j+1-1, 1, 3)
            case (kmax) 
! xface => x(:,:,kl,:)
              xface_xd = xd(i-1, j-1, kl, 1)
              xface_x = x(i-1, j-1, kl, 1)
              xface_yd = xd(i-1, j-1, kl, 2)
              xface_y = x(i-1, j-1, kl, 2)
              xface_zd = xd(i-1, j-1, kl, 3)
              xface_z = x(i-1, j-1, kl, 3)
              xface_x_ij_10d = xd(i+1-1, j+0-1, kl, 1)
              xface_x_ij_10 = x(i+1-1, j+0-1, kl, 1)
              xface_y_ij_10d = xd(i+1-1, j+0-1, kl, 2)
              xface_y_ij_10 = x(i+1-1, j+0-1, kl, 2)
              xface_z_ij_10d = xd(i+1-1, j+0-1, kl, 3)
              xface_z_ij_10 = x(i+1-1, j+0-1, kl, 3)
              xface_x_ij_01d = xd(i+0-1, j+1-1, kl, 1)
              xface_x_ij_01 = x(i+0-1, j+1-1, kl, 1)
              xface_y_ij_01d = xd(i+0-1, j+1-1, kl, 2)
              xface_y_ij_01 = x(i+0-1, j+1-1, kl, 2)
              xface_z_ij_01d = xd(i+0-1, j+1-1, kl, 3)
              xface_z_ij_01 = x(i+0-1, j+1-1, kl, 3)
              xface_x_ij_11d = xd(i+1-1, j+1-1, kl, 1)
              xface_x_ij_11 = x(i+1-1, j+1-1, kl, 1)
              xface_y_ij_11d = xd(i+1-1, j+1-1, kl, 2)
              xface_y_ij_11 = x(i+1-1, j+1-1, kl, 2)
              xface_z_ij_11d = xd(i+1-1, j+1-1, kl, 3)
              xface_z_ij_11 = x(i+1-1, j+1-1, kl, 3)
            end select
! store the rotation center and the rotation rate
! for this subface.
! mham: had to redo this a second time. if we do as stated below
! then tapenade will make a mistake! it will simply drop the
! initialization line of j_; "j_ = nbkglobal" and then we will
! get a runtime error on flux when we run the code since
! j_ has not been initialized properly. therefore, we will skip
! the j_ and the i_ altogether and insert nbkglobal and
! cgnssubface(mm) directly in the rotcenter and rotrate line...
! ! mham: notice we had to rename these two placeholders, (i,j)->
! ! (i_,j_) since i and j are now inside the i,j-double loop
! j_ = nbkglobal
! i_ = cgnssubface(mm)
            rotcenter = cgnsdoms(nbkglobal)%bocoinfo(cgnssubface(mm))%&
&             rotcenter
            rotrated = cgnsdoms(nbkglobal)%bocoinfo(cgnssubface(mm))%&
&             rotrate*timerefd
            rotrate = timeref*cgnsdoms(nbkglobal)%bocoinfo(cgnssubface(&
&             mm))%rotrate
! mham: deprecated lines
! rotcenter = cgnsdoms(j_)%bocoinfo(i_)%rotcenter
! rotrate   = timeref*cgnsdoms(j_)%bocoinfo(i_)%rotrate
! usewindaxis should go back here!
            velxgridd = velxgrid0d
            velxgrid = velxgrid0
            velygridd = velygrid0d
            velygrid = velygrid0
            velzgridd = velzgrid0d
            velzgrid = velzgrid0
! loop over the quadrilateral faces of the viscous
! subface.
! mham: this nested loop has been replaced by fakenestedloop2
! do j=bcdata(mm)%jcbeg, bcdata(mm)%jcend
!    do i=bcdata(mm)%icbeg, bcdata(mm)%icend
! compute the coordinates of the centroid of the face.
! normally this would be an average of i-1 and i, but
! due to the usage of the pointer xface and the fact
! that x starts at index 0 this is shifted 1 index.
! mham: this region is deprecated and has been replaced to
! allow for a more smooth tapenade differentiation w.o. any pointers
! xc(1) = fourth*(xface(i+1,j+1,1) + xface(i+1,j,1) &
!      +         xface(i,  j+1,1) + xface(i,  j,1))
! xc(2) = fourth*(xface(i+1,j+1,2) + xface(i+1,j,2) &
!      +         xface(i,  j+1,2) + xface(i,  j,2))
! xc(3) = fourth*(xface(i+1,j+1,3) + xface(i+1,j,3) &
!      +         xface(i,  j+1,3) + xface(i,  j,3))
            xcd(1) = fourth*(xface_x_ij_11d+xface_x_ij_10d+&
&             xface_x_ij_01d+xface_xd)
            xc(1) = fourth*(xface_x_ij_11+xface_x_ij_10+xface_x_ij_01+&
&             xface_x)
            xcd(2) = fourth*(xface_y_ij_11d+xface_y_ij_10d+&
&             xface_y_ij_01d+xface_yd)
            xc(2) = fourth*(xface_y_ij_11+xface_y_ij_10+xface_y_ij_01+&
&             xface_y)
            xcd(3) = fourth*(xface_z_ij_11d+xface_z_ij_10d+&
&             xface_z_ij_01d+xface_zd)
            xc(3) = fourth*(xface_z_ij_11+xface_z_ij_10+xface_z_ij_01+&
&             xface_z)
! determine the coordinates relative to the center
! of rotation.
            xxcd(1) = xcd(1)
            xxc(1) = xc(1) - rotcenter(1)
            xxcd(2) = xcd(2)
            xxc(2) = xc(2) - rotcenter(2)
            xxcd(3) = xcd(3)
            xxc(3) = xc(3) - rotcenter(3)
! compute the velocity, which is the cross product
! of rotrate and xc.
            bcdatad(mm)%uslip(i, j, 1) = rotrated(2)*xxc(3) + rotrate(2)&
&             *xxcd(3) - rotrated(3)*xxc(2) - rotrate(3)*xxcd(2)
            bcdata(mm)%uslip(i, j, 1) = rotrate(2)*xxc(3) - rotrate(3)*&
&             xxc(2)
            bcdatad(mm)%uslip(i, j, 2) = rotrated(3)*xxc(1) + rotrate(3)&
&             *xxcd(1) - rotrated(1)*xxc(3) - rotrate(1)*xxcd(3)
            bcdata(mm)%uslip(i, j, 2) = rotrate(3)*xxc(1) - rotrate(1)*&
&             xxc(3)
            bcdatad(mm)%uslip(i, j, 3) = rotrated(1)*xxc(2) + rotrate(1)&
&             *xxcd(2) - rotrated(2)*xxc(1) - rotrate(2)*xxcd(1)
            bcdata(mm)%uslip(i, j, 3) = rotrate(1)*xxc(2) - rotrate(2)*&
&             xxc(1)
! determine the coordinates relative to the
! rigid body rotation point.
            xxcd(1) = xcd(1)
            xxc(1) = xc(1) - rotationpoint(1)
            xxcd(2) = xcd(2)
            xxc(2) = xc(2) - rotationpoint(2)
            xxcd(3) = xcd(3)
            xxc(3) = xc(3) - rotationpoint(3)
! determine the total velocity of the cell center.
! this is a combination of rotation speed of this
! block and the entire rigid body rotation.
            bcdatad(mm)%uslip(i, j, 1) = bcdatad(mm)%uslip(i, j, 1) + &
&             velxgridd + derivrotationmatrixd(1, 1)*xxc(1) + &
&             derivrotationmatrix(1, 1)*xxcd(1) + derivrotationmatrixd(1&
&             , 2)*xxc(2) + derivrotationmatrix(1, 2)*xxcd(2) + &
&             derivrotationmatrixd(1, 3)*xxc(3) + derivrotationmatrix(1&
&             , 3)*xxcd(3)
            bcdata(mm)%uslip(i, j, 1) = bcdata(mm)%uslip(i, j, 1) + &
&             velxgrid + derivrotationmatrix(1, 1)*xxc(1) + &
&             derivrotationmatrix(1, 2)*xxc(2) + derivrotationmatrix(1, &
&             3)*xxc(3)
            bcdatad(mm)%uslip(i, j, 2) = bcdatad(mm)%uslip(i, j, 2) + &
&             velygridd + derivrotationmatrixd(2, 1)*xxc(1) + &
&             derivrotationmatrix(2, 1)*xxcd(1) + derivrotationmatrixd(2&
&             , 2)*xxc(2) + derivrotationmatrix(2, 2)*xxcd(2) + &
&             derivrotationmatrixd(2, 3)*xxc(3) + derivrotationmatrix(2&
&             , 3)*xxcd(3)
            bcdata(mm)%uslip(i, j, 2) = bcdata(mm)%uslip(i, j, 2) + &
&             velygrid + derivrotationmatrix(2, 1)*xxc(1) + &
&             derivrotationmatrix(2, 2)*xxc(2) + derivrotationmatrix(2, &
&             3)*xxc(3)
            bcdatad(mm)%uslip(i, j, 3) = bcdatad(mm)%uslip(i, j, 3) + &
&             velzgridd + derivrotationmatrixd(3, 1)*xxc(1) + &
&             derivrotationmatrix(3, 1)*xxcd(1) + derivrotationmatrixd(3&
&             , 2)*xxc(2) + derivrotationmatrix(3, 2)*xxcd(2) + &
&             derivrotationmatrixd(3, 3)*xxc(3) + derivrotationmatrix(3&
&             , 3)*xxcd(3)
            bcdata(mm)%uslip(i, j, 3) = bcdata(mm)%uslip(i, j, 3) + &
&             velzgrid + derivrotationmatrix(3, 1)*xxc(1) + &
&             derivrotationmatrix(3, 2)*xxc(2) + derivrotationmatrix(3, &
&             3)*xxc(3)
          end do
        end do
      end do bocoloop2
    end if
  end subroutine slipvelocitiesfinelevel_block_d
! mham addition

!  differentiation of normalvelocities_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.rface)
!   with respect to varying inputs: *sfacei *sfacej *sfacek *si
!                *sj *sk
!   rw status of diff variables: *sfacei:in *sfacej:in *sfacek:in
!                *si:in *sj:in *sk:in *(*bcdata.rface):out
!   plus diff mem management of: sfacei:in sfacej:in sfacek:in
!                si:in sj:in sk:in bcdata:in *bcdata.rface:in
! mham addition
  subroutine normalvelocities_block_d(sps)
!
!       normalvelocitiesalllevels computes the normal grid
!       velocities of some boundary faces of the moving blocks for
!       spectral mode sps. all grid levels from ground level to the
!       coarsest level are considered.
!
    use constants
    use blockpointers, only : il, jl, kl, addgridvelocities, nbocos, &
&   bcdata, bcdatad, sfacei, sfaceid, sfacej, sfacejd, sfacek, sfacekd, &
&   bcfaceid, si, sid, sj, sjd, sk, skd
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: sps
!
!      local variables.
!
    integer(kind=inttype) :: mm
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: weight, mult
    real(kind=realtype) :: weightd
! mham: comment out deprecated pointers
! real(kind=realtype), dimension(:,:),   pointer :: sface  
! real(kind=realtype), dimension(:,:,:), pointer :: ss
    real(kind=realtype) :: sface_ij
    real(kind=realtype) :: sface_ijd
    real(kind=realtype) :: ss_x, ss_y, ss_z
    real(kind=realtype) :: ss_xd, ss_yd, ss_zd
! mham: we also need a pointer for the fake double loop:
    integer(kind=inttype) :: ii_
    intrinsic associated
    intrinsic mod
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: ii1
! check for a moving block. as it is possible that in a
! multidisicplinary environment additional grid velocities
! are set, the test should be done on addgridvelocities
! and not on blockismoving.
    if (addgridvelocities) then
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%rface = 0.0_8
      end do
      sface_ijd = 0.0_8
      ss_xd = 0.0_8
      ss_yd = 0.0_8
      ss_zd = 0.0_8
!
!             determine the normal grid velocities of the boundaries.
!             as these values are based on the unit normal. a division
!             by the length of the normal is needed.
!             furthermore the boundary unit normals are per definition
!             outward pointing, while on the imin, jmin and kmin
!             boundaries the face normals are inward pointing. this
!             is taken into account by the factor mult.
!
! loop over the boundary subfaces.
bocoloop:do mm=1,nbocos
! check whether rface is allocated.
        if (associated(bcdata(mm)%rface)) then
! determine the block face on which the subface is
! located and set some variables accordingly.
fakedoubleloop:do ii_=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm&
&             )%icend-bcdata(mm)%icbeg+1)-1
            j = ii_/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%&
&             jcbeg
            i = mod(ii_, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + &
&             bcdata(mm)%icbeg
            select case  (bcfaceid(mm)) 
            case (imin) 
              mult = -one
! ss => si(1,:,:,:)
              ss_xd = sid(1, i, j, 1)
              ss_x = si(1, i, j, 1)
              ss_yd = sid(1, i, j, 2)
              ss_y = si(1, i, j, 2)
              ss_zd = sid(1, i, j, 3)
              ss_z = si(1, i, j, 3)
! sface => sfacei(1,:,:)
              sface_ijd = sfaceid(1, i, j)
              sface_ij = sfacei(1, i, j)
            case (imax) 
              mult = one
! ss => si(il,:,:,:)
              ss_xd = sid(il, i, j, 1)
              ss_x = si(il, i, j, 1)
              ss_yd = sid(il, i, j, 2)
              ss_y = si(il, i, j, 2)
              ss_zd = sid(il, i, j, 3)
              ss_z = si(il, i, j, 3)
! sface => sfacei(il,:,:)
              sface_ijd = sfaceid(il, i, j)
              sface_ij = sfacei(il, i, j)
            case (jmin) 
              mult = -one
! ss => sj(:,1,:,:) 
              ss_xd = sjd(i, 1, j, 1)
              ss_x = sj(i, 1, j, 1)
              ss_yd = sjd(i, 1, j, 2)
              ss_y = sj(i, 1, j, 2)
              ss_zd = sjd(i, 1, j, 3)
              ss_z = sj(i, 1, j, 3)
! sface => sfacej(:,1,:)
              sface_ijd = sfacejd(i, 1, j)
              sface_ij = sfacej(i, 1, j)
            case (jmax) 
              mult = one
! ss => sj(:,jl,:,:)
              ss_xd = sjd(i, jl, j, 1)
              ss_x = sj(i, jl, j, 1)
              ss_yd = sjd(i, jl, j, 2)
              ss_y = sj(i, jl, j, 2)
              ss_zd = sjd(i, jl, j, 3)
              ss_z = sj(i, jl, j, 3)
! sface => sfacej(:,jl,:)
              sface_ijd = sfacejd(i, jl, j)
              sface_ij = sfacej(i, jl, j)
            case (kmin) 
              mult = -one
! ss => sk(:,:,1,:)
              ss_xd = skd(i, j, 1, 1)
              ss_x = sk(i, j, 1, 1)
              ss_yd = skd(i, j, 1, 2)
              ss_y = sk(i, j, 1, 2)
              ss_zd = skd(i, j, 1, 3)
              ss_z = sk(i, j, 1, 3)
! sface => sfacek(:,:,1)
              sface_ijd = sfacekd(i, j, 1)
              sface_ij = sfacek(i, j, 1)
            case (kmax) 
              mult = one
! ss => sk(:,:,kl,:)
              ss_xd = skd(i, j, kl, 1)
              ss_x = sk(i, j, kl, 1)
              ss_yd = skd(i, j, kl, 2)
              ss_y = sk(i, j, kl, 2)
              ss_zd = skd(i, j, kl, 3)
              ss_z = sk(i, j, kl, 3)
! sface => sfacek(:,:,kl)
              sface_ijd = sfacekd(i, j, kl)
              sface_ij = sfacek(i, j, kl)
            end select
! loop over the faces of the subface.
! mham: remove nested pointer loop
! do j=bcdata(mm)%jcbeg, bcdata(mm)%jcend
!    do i=bcdata(mm)%icbeg, bcdata(mm)%icend
! compute the inverse of the length of the normal
! vector and possibly correct for inward pointing.
! mham: remove old pointer version
! weight = sqrt(ss(i,j,1)**2 + ss(i,j,2)**2 &
!      +      ss(i,j,3)**2)
! mham: insert new fake pointers
            arg1d = 2*ss_x*ss_xd + 2*ss_y*ss_yd + 2*ss_z*ss_zd
            arg1 = ss_x**2 + ss_y**2 + ss_z**2
            if (arg1 .eq. 0.0_8) then
              weightd = 0.0_8
            else
              weightd = arg1d/(2.0*sqrt(arg1))
            end if
            weight = sqrt(arg1)
            if (weight .gt. zero) then
              weightd = -(mult*weightd/weight**2)
              weight = mult/weight
            end if
! compute the normal velocity based on the outward
! pointing unit normal.
! mham: remove old pointer version
! bcdata(mm)%rface(i,j) = weight*sface(i,j)
! mham: insert new fake pointers
            bcdatad(mm)%rface(i, j) = weightd*sface_ij + weight*&
&             sface_ijd
            bcdata(mm)%rface(i, j) = weight*sface_ij
          end do fakedoubleloop
        end if
      end do bocoloop
    else
! mham: remember to remove old enddo's from
!       nested pointer loop
!    enddo
! enddo
! mham: remember to close the fake loop
! block is not moving. loop over the boundary faces and set
! the normal grid velocity to zero if allocated.
      do mm=1,nbocos
        if (associated(bcdata(mm)%rface)) then
          bcdatad(mm)%rface = 0.0_8
          bcdata(mm)%rface = zero
        end if
      end do
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%rface = 0.0_8
      end do
    end if
  end subroutine normalvelocities_block_d


end module adjointextra_d

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of bcturbtreatment in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *bvtj1 *bvtj2 *bvtk1 *bvtk2
!                *bvti1 *bvti2
!   with respect to varying inputs: winf *w *rlv
!   plus diff mem management of: bvtj1:in bvtj2:in w:in rlv:in
!                bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          bcturbtreatment.f90                             *
!      * author:        georgi kalitzin, edwin van der weide            *
!      *                seonghyeon hahn                                 *
!      * starting date: 06-13-2003                                      *
!      * last modified: 08-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine bcturbtreatment_d()
!
!      ******************************************************************
!      *                                                                *
!      * bcturbtreatment sets the arrays bmti1, bvti1, etc, such that   *
!      * the physical boundary conditions are treated correctly.        *
!      * it is assumed that the variables in blockpointers already      *
!      * point to the correct block.                                    *
!      *                                                                *
!      * the turbulent variable in the halo is computed as follows:     *
!      * whalo = -bmt*winternal + bvt for every block facer. as it is   *
!      * possible to have a coupling in the boundary conditions bmt     *
!      * actually are matrices. if there is no coupling between the     *
!      * boundary conditions of the turbulence equations bmt is a       *
!      * diagonal matrix.                                               *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use flowvarrefstate
  implicit none
!
!      local variable.
!
  integer(kind=inttype) :: nn, i, j, k, l, m
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! initialize the arrays for the boundary condition treatment
! to zero, such that internal block boundaries are solved
! correctly (i.e. explicitly).
  do k=1,ke
    do j=1,je
      do l=nt1,nt2
        do m=nt1,nt2
          bmti1(j, k, l, m) = zero
          bmti2(j, k, l, m) = zero
        end do
        bvti1d(j, k, l) = 0.0_8
        bvti1(j, k, l) = zero
        bvti2d(j, k, l) = 0.0_8
        bvti2(j, k, l) = zero
      end do
    end do
  end do
  do k=1,ke
    do i=1,ie
      do l=nt1,nt2
        do m=nt1,nt2
          bmtj1(i, k, l, m) = zero
          bmtj2(i, k, l, m) = zero
        end do
        bvtj1d(i, k, l) = 0.0_8
        bvtj1(i, k, l) = zero
        bvtj2d(i, k, l) = 0.0_8
        bvtj2(i, k, l) = zero
      end do
    end do
  end do
  do j=1,je
    do i=1,ie
      do l=nt1,nt2
        do m=nt1,nt2
          bmtk1(i, j, l, m) = zero
          bmtk2(i, j, l, m) = zero
        end do
        bvtk1d(i, j, l) = 0.0_8
        bvtk1(i, j, l) = zero
        bvtk2d(i, j, l) = 0.0_8
        bvtk2(i, j, l) = zero
      end do
    end do
  end do
  bvtj1d = 0.0_8
  bvtj2d = 0.0_8
  bvtk1d = 0.0_8
  bvtk2d = 0.0_8
  bvti1d = 0.0_8
  bvti2d = 0.0_8
! loop over the boundary condition subfaces of this block.
bocos:do nn=1,nbocos
! determine the kind of boundary condition for this subface.
    select case  (bctype(nn)) 
    case (nswalladiabatic, nswallisothermal) 
! viscous wall. there is no difference between an adiabatic
! and an isothermal wall for the turbulent equations.
! set the implicit treatment of the wall boundary conditions.
      call bcturbwall_d(nn)
    case (symm, symmpolar, eulerwall) 
!=============================================================
!=============================================================
! symmetry, polar symmetry or inviscid wall. treatment of
! the turbulent equations is identical.
      call bcturbsymm(nn)
    case (farfield) 
!=============================================================
! farfield. the kind of boundary condition to be applied,
! inflow or outflow, depends on the local conditions.
      call bcturbfarfield_d(nn)
    case (slidinginterface, oversetouterbound, domaininterfaceall, &
&   domaininterfacerhouvw, domaininterfacep, domaininterfacerho, &
&   domaininterfacetotal) 
!=============================================================
! sliding mesh interface, overset outer boudaries, and 
! domain interface with another code are not really boundary
! condition and therefore the values are kept.
      call bcturbinterface_d(nn)
    end select
  end do bocos
end subroutine bcturbtreatment_d

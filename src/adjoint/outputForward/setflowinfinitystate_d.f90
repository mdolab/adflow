!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of setflowinfinitystate in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: winf pinfcorr
!   with respect to varying inputs: gammainf pinf rhoinf tref muinf
!                uinf rgas veldirfreestream machcoef
!
!      ******************************************************************
!      *                                                                *
!      * file:          setflowinfinitystate.f90                        *
!      * author:        edwin van der weide, georgi kalitzin            *
!      * starting date: 02-21-2003                                      *
!      * last modified: 06-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine setflowinfinitystate_d()
!
!      ******************************************************************
!      *                                                                *
!      * setflowinfinitystate sets the free stream state vector of      *
!      * the flow variables. if nothing is specified for each of the    *
!      * farfield boundaries, these values will be taken to define the  *
!      * free stream.                                                   *
!      *                                                                *
!      ******************************************************************
!
  use constants
  use flowvarrefstate
  use inputphysics
  use paramturb
  implicit none
!
!      local variables
!
  integer(kind=inttype) :: ierr
  real(kind=realtype) :: nuinf, ktmp, uinf2
  real(kind=realtype) :: nuinfd, ktmpd, uinf2d
!
!      function definition
!
  real(kind=realtype) :: sanuknowneddyratio
  real(kind=realtype) :: sanuknowneddyratio_d
! dummy parameters
  real(kind=realtype) :: vinf, zinf
  real(kind=realtype) :: vinfd, zinfd
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! compute the velocity squared based on machcoef;
! needed for the initialization of the turbulent energy,
! especially for moving geometries.
  uinf2d = (((machcoefd*machcoef+machcoef*machcoefd)*gammainf*pinf+&
&   machcoef**2*(gammainfd*pinf+gammainf*pinfd))*rhoinf-machcoef**2*&
&   gammainf*pinf*rhoinfd)/rhoinf**2
  uinf2 = machcoef*machcoef*gammainf*pinf/rhoinf
! allocate the memory for winf.
! zero out the winf first
  winf(:) = zero
! set the reference value of the flow variables, except the total
! energy. this will be computed at the end of this routine.
  winfd = 0.0_8
  winfd(irho) = rhoinfd
  winf(irho) = rhoinf
  winfd(ivx) = uinfd*veldirfreestream(1) + uinf*veldirfreestreamd(1)
  winf(ivx) = uinf*veldirfreestream(1)
  winfd(ivy) = uinfd*veldirfreestream(2) + uinf*veldirfreestreamd(2)
  winf(ivy) = uinf*veldirfreestream(2)
  winfd(ivz) = uinfd*veldirfreestream(3) + uinf*veldirfreestreamd(3)
  winf(ivz) = uinf*veldirfreestream(3)
! set the turbulent variables if transport variables are to be
! solved. we should be checking for rans equations here,
! however, this code is included in block res. the issue is
! that for frozen turbulence (or ank jacobian) we call the
! block_res with equationtype set to laminar even though we are
! actually solving the rans equations. the issue is that, the
! freestream turb variables will be changed to zero, thus
! changing the solution. insteady we check if nw > nwf which
! will accomplish the same thing. 
  if (nw .gt. nwf) then
    nuinfd = (muinfd*rhoinf-muinf*rhoinfd)/rhoinf**2
    nuinf = muinf/rhoinf
    select case  (turbmodel) 
    case (spalartallmaras, spalartallmarasedwards) 
      winfd(itu1) = sanuknowneddyratio_d(eddyvisinfratio, nuinf, nuinfd&
&       , winf(itu1))
    case (komegawilcox, komegamodified, mentersst) 
!=============================================================
      winfd(itu1) = 1.5_realtype*turbintensityinf**2*uinf2d
      winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
      winfd(itu2) = (winfd(itu1)*eddyvisinfratio*nuinf-winf(itu1)*&
&       eddyvisinfratio*nuinfd)/(eddyvisinfratio*nuinf)**2
      winf(itu2) = winf(itu1)/(eddyvisinfratio*nuinf)
    case (ktau) 
!=============================================================
      winfd(itu1) = 1.5_realtype*turbintensityinf**2*uinf2d
      winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
      winfd(itu2) = (eddyvisinfratio*nuinfd*winf(itu1)-eddyvisinfratio*&
&       nuinf*winfd(itu1))/winf(itu1)**2
      winf(itu2) = eddyvisinfratio*nuinf/winf(itu1)
    case (v2f) 
!=============================================================
      winfd(itu1) = 1.5_realtype*turbintensityinf**2*uinf2d
      winf(itu1) = 1.5_realtype*uinf2*turbintensityinf**2
      winfd(itu2) = (0.09_realtype*2*winf(itu1)*winfd(itu1)*&
&       eddyvisinfratio*nuinf-0.09_realtype*winf(itu1)**2*&
&       eddyvisinfratio*nuinfd)/(eddyvisinfratio*nuinf)**2
      winf(itu2) = 0.09_realtype*winf(itu1)**2/(eddyvisinfratio*nuinf)
      winfd(itu3) = 0.666666_realtype*winfd(itu1)
      winf(itu3) = 0.666666_realtype*winf(itu1)
      winfd(itu4) = 0.0_8
      winf(itu4) = 0.0_realtype
    end select
  end if
! set the value of pinfcorr. in case a k-equation is present
! add 2/3 times rho*k.
  pinfcorrd = pinfd
  pinfcorr = pinf
  if (kpresent) then
    pinfcorrd = pinfd + two*third*(rhoinfd*winf(itu1)+rhoinf*winfd(itu1)&
&     )
    pinfcorr = pinf + two*third*rhoinf*winf(itu1)
  end if
! compute the free stream total energy.
  ktmp = zero
  if (kpresent) then
    ktmpd = winfd(itu1)
    ktmp = winf(itu1)
  else
    ktmpd = 0.0_8
  end if
  vinf = zero
  zinf = zero
  zinfd = 0.0_8
  vinfd = 0.0_8
  call etotarray_d(rhoinf, rhoinfd, uinf, uinfd, vinf, vinfd, zinf, &
&            zinfd, pinfcorr, pinfcorrd, ktmp, ktmpd, winf(irhoe), winfd&
&            (irhoe), kpresent, 1)
end subroutine setflowinfinitystate_d

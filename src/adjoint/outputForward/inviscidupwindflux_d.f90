!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of inviscidupwindflux in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw
!   with respect to varying inputs: tref rgas *p *sfacei *sfacej
!                *sfacek *w *si *sj *sk
!   plus diff mem management of: p:in sfacei:in sfacej:in sfacek:in
!                w:in si:in sj:in sk:in fw:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          inviscidupwindflux.f90                          *
!      * author:        edwin van der weide                             *
!      * starting date: 03-25-2003                                      *
!      * last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine inviscidupwindflux_d(finegrid)
!
!      ******************************************************************
!      *                                                                *
!      * inviscidupwindflux computes the artificial dissipation part of *
!      * the euler fluxes by means of an approximate solution of the 1d *
!      * riemann problem on the face. for first order schemes,          *
!      * finegrid == .false., the states in the cells are assumed to    *
!      * be constant; for the second order schemes on the fine grid a   *
!      * nonlinear reconstruction of the left and right state is done   *
!      * for which several options exist.                               *
!      * it is assumed that the pointers in blockpointers already       *
!      * point to the correct block.                                    *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use cgnsgrid
  use constants
  use inputdiscretization
  use inputphysics
  use flowvarrefstate
  use iteration
  implicit none
!
!      subroutine arguments.
!
  logical, intent(in) :: finegrid
!
!      local variables.
!
  integer(kind=portype) :: por
  integer(kind=inttype) :: nwint
  integer(kind=inttype) :: i, j, k, ind
  integer(kind=inttype) :: limused, riemannused
  real(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
  real(kind=realtype) :: sxd, syd, szd
  real(kind=realtype) :: factminmod, sface
  real(kind=realtype) :: sfaced
  real(kind=realtype), dimension(nw) :: left, right
  real(kind=realtype), dimension(nw) :: leftd, rightd
  real(kind=realtype), dimension(nw) :: du1, du2, du3
  real(kind=realtype), dimension(nw) :: du1d, du2d, du3d
  real(kind=realtype), dimension(nwf) :: flux
  real(kind=realtype), dimension(nwf) :: fluxd
  logical :: firstorderk, correctfork, rotationalperiodic
  intrinsic abs
  intrinsic associated
  intrinsic max
  real(kind=realtype) :: abs0
  real(kind=realtype) :: max1
  if (rfil .ge. 0.) then
    abs0 = rfil
  else
    abs0 = -rfil
  end if
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
  if (abs0 .lt. thresholdreal) then
    fwd = 0.0_8
    return
  else
! check if the formulation for rotational periodic problems
! must be used.
    if (associated(rotmatrixi)) then
      rotationalperiodic = .true.
    else
      rotationalperiodic = .false.
    end if
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
    sfil = one - rfil
    do k=2,kl
      do j=2,jl
        do i=2,il
          fwd(i, j, k, irho) = 0.0_8
          fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
          fwd(i, j, k, imx) = 0.0_8
          fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
          fwd(i, j, k, imy) = 0.0_8
          fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
          fwd(i, j, k, imz) = 0.0_8
          fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
          fwd(i, j, k, irhoe) = 0.0_8
          fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
        end do
      end do
    end do
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .eq. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
    if (1.e-10_realtype .lt. one - kappacoef) then
      max1 = one - kappacoef
    else
      max1 = 1.e-10_realtype
    end if
! compute the factor used in the minmod limiter.
    factminmod = (three-kappacoef)/max1
! determine the limiter scheme to be used. on the fine grid the
! user specified scheme is used; on the coarse grid a first order
! scheme is computed.
    limused = firstorder
    if (finegrid) limused = limiter
! lumped diss is true for doing approx pc
    if (lumpeddiss) limused = firstorder
! determine the riemann solver which must be used.
    riemannused = riemanncoarse
    if (finegrid) riemannused = riemann
! store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
    omk = fourth*(one-kappacoef)
    opk = fourth*(one+kappacoef)
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
! set the number of variables to be interpolated depending
! whether or not a k-equation is present. if a k-equation is
! present also set the logical firstorderk. this indicates
! whether or not only a first order approximation is to be used
! for the turbulent kinetic energy.
    if (correctfork) then
      if (orderturb .eq. firstorder) then
        nwint = nwf
        firstorderk = .true.
      else
        nwint = itu1
        firstorderk = .false.
      end if
    else
      nwint = nwf
      firstorderk = .false.
    end if
!
!      ******************************************************************
!      *                                                                *
!      * flux computation. a distinction is made between first and      *
!      * second order schemes to avoid the overhead for the first order *
!      * scheme.                                                        *
!      *                                                                *
!      ******************************************************************
!
    if (limused .eq. firstorder) then
      fwd = 0.0_8
      fluxd = 0.0_8
      leftd = 0.0_8
      rightd = 0.0_8
      sfaced = 0.0_8
!
!        ****************************************************************
!        *                                                              *
!        * first order reconstruction. the states in the cells are      *
!        * constant. the left and right states are constructed easily.  *
!        *                                                              *
!        ****************************************************************
!
! fluxes in the i-direction.
      do k=2,kl
        do j=2,jl
          do i=1,il
! store the normal vector, the porosity and the
! mesh velocity if present.
            sxd = sid(i, j, k, 1)
            sx = si(i, j, k, 1)
            syd = sid(i, j, k, 2)
            sy = si(i, j, k, 2)
            szd = sid(i, j, k, 3)
            sz = si(i, j, k, 3)
            por = pori(i, j, k)
            if (addgridvelocities) then
              sfaced = sfaceid(i, j, k)
              sface = sfacei(i, j, k)
            end if
! determine the left and right state.
            leftd(irho) = wd(i, j, k, irho)
            left(irho) = w(i, j, k, irho)
            leftd(ivx) = wd(i, j, k, ivx)
            left(ivx) = w(i, j, k, ivx)
            leftd(ivy) = wd(i, j, k, ivy)
            left(ivy) = w(i, j, k, ivy)
            leftd(ivz) = wd(i, j, k, ivz)
            left(ivz) = w(i, j, k, ivz)
            leftd(irhoe) = pd(i, j, k)
            left(irhoe) = p(i, j, k)
            if (correctfork) then
              leftd(itu1) = wd(i, j, k, itu1)
              left(itu1) = w(i, j, k, itu1)
            end if
            rightd(irho) = wd(i+1, j, k, irho)
            right(irho) = w(i+1, j, k, irho)
            rightd(ivx) = wd(i+1, j, k, ivx)
            right(ivx) = w(i+1, j, k, ivx)
            rightd(ivy) = wd(i+1, j, k, ivy)
            right(ivy) = w(i+1, j, k, ivy)
            rightd(ivz) = wd(i+1, j, k, ivz)
            right(ivz) = w(i+1, j, k, ivz)
            rightd(irhoe) = pd(i+1, j, k)
            right(irhoe) = p(i+1, j, k)
            if (correctfork) then
              rightd(itu1) = wd(i+1, j, k, itu1)
              right(itu1) = w(i+1, j, k, itu1)
            end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
            gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
            call riemannflux_d(left, leftd, right, rightd, flux, fluxd)
! and scatter it to the left and right.
            fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
            fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
            fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
            fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
            fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
            fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
            fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
            fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
            fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) - fluxd(irho)
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
            fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) - fluxd(imx)
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
            fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) - fluxd(imy)
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
            fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) - fluxd(imz)
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
            fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) - fluxd(irhoe)
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
          end do
        end do
      end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in j-direction.
      do k=2,kl
        do j=1,jl
          do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
            sxd = sjd(i, j, k, 1)
            sx = sj(i, j, k, 1)
            syd = sjd(i, j, k, 2)
            sy = sj(i, j, k, 2)
            szd = sjd(i, j, k, 3)
            sz = sj(i, j, k, 3)
            por = porj(i, j, k)
            if (addgridvelocities) then
              sfaced = sfacejd(i, j, k)
              sface = sfacej(i, j, k)
            end if
! determine the left and right state.
            leftd(irho) = wd(i, j, k, irho)
            left(irho) = w(i, j, k, irho)
            leftd(ivx) = wd(i, j, k, ivx)
            left(ivx) = w(i, j, k, ivx)
            leftd(ivy) = wd(i, j, k, ivy)
            left(ivy) = w(i, j, k, ivy)
            leftd(ivz) = wd(i, j, k, ivz)
            left(ivz) = w(i, j, k, ivz)
            leftd(irhoe) = pd(i, j, k)
            left(irhoe) = p(i, j, k)
            if (correctfork) then
              leftd(itu1) = wd(i, j, k, itu1)
              left(itu1) = w(i, j, k, itu1)
            end if
            rightd(irho) = wd(i, j+1, k, irho)
            right(irho) = w(i, j+1, k, irho)
            rightd(ivx) = wd(i, j+1, k, ivx)
            right(ivx) = w(i, j+1, k, ivx)
            rightd(ivy) = wd(i, j+1, k, ivy)
            right(ivy) = w(i, j+1, k, ivy)
            rightd(ivz) = wd(i, j+1, k, ivz)
            right(ivz) = w(i, j+1, k, ivz)
            rightd(irhoe) = pd(i, j+1, k)
            right(irhoe) = p(i, j+1, k)
            if (correctfork) then
              rightd(itu1) = wd(i, j+1, k, itu1)
              right(itu1) = w(i, j+1, k, itu1)
            end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
            gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
            call riemannflux_d(left, leftd, right, rightd, flux, fluxd)
! and scatter it to the left and right.
            fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
            fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
            fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
            fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
            fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
            fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
            fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
            fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
            fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) - fluxd(irho)
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
            fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) - fluxd(imx)
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
            fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) - fluxd(imy)
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
            fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) - fluxd(imz)
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
            fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) - fluxd(irhoe)
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
          end do
        end do
      end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in k-direction.
      do k=1,kl
        do j=2,jl
          do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
            sxd = skd(i, j, k, 1)
            sx = sk(i, j, k, 1)
            syd = skd(i, j, k, 2)
            sy = sk(i, j, k, 2)
            szd = skd(i, j, k, 3)
            sz = sk(i, j, k, 3)
            por = pork(i, j, k)
            if (addgridvelocities) then
              sfaced = sfacekd(i, j, k)
              sface = sfacek(i, j, k)
            end if
! determine the left and right state.
            leftd(irho) = wd(i, j, k, irho)
            left(irho) = w(i, j, k, irho)
            leftd(ivx) = wd(i, j, k, ivx)
            left(ivx) = w(i, j, k, ivx)
            leftd(ivy) = wd(i, j, k, ivy)
            left(ivy) = w(i, j, k, ivy)
            leftd(ivz) = wd(i, j, k, ivz)
            left(ivz) = w(i, j, k, ivz)
            leftd(irhoe) = pd(i, j, k)
            left(irhoe) = p(i, j, k)
            if (correctfork) then
              leftd(itu1) = wd(i, j, k, itu1)
              left(itu1) = w(i, j, k, itu1)
            end if
            rightd(irho) = wd(i, j, k+1, irho)
            right(irho) = w(i, j, k+1, irho)
            rightd(ivx) = wd(i, j, k+1, ivx)
            right(ivx) = w(i, j, k+1, ivx)
            rightd(ivy) = wd(i, j, k+1, ivy)
            right(ivy) = w(i, j, k+1, ivy)
            rightd(ivz) = wd(i, j, k+1, ivz)
            right(ivz) = w(i, j, k+1, ivz)
            rightd(irhoe) = pd(i, j, k+1)
            right(irhoe) = p(i, j, k+1)
            if (correctfork) then
              rightd(itu1) = wd(i, j, k+1, itu1)
              right(itu1) = w(i, j, k+1, itu1)
            end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
            gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
            call riemannflux_d(left, leftd, right, rightd, flux, fluxd)
! and scatter it the left and right.
            fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
            fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
            fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
            fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
            fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
            fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
            fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
            fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
            fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) - fluxd(irho)
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
            fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) - fluxd(imx)
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
            fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) - fluxd(imy)
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
            fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) - fluxd(imz)
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
            fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) - fluxd(irhoe)
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
          end do
        end do
      end do
    else
      fwd = 0.0_8
      fluxd = 0.0_8
      leftd = 0.0_8
      rightd = 0.0_8
      du1d = 0.0_8
      du2d = 0.0_8
      du3d = 0.0_8
      sfaced = 0.0_8
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
!      ==================================================================
!
!        ****************************************************************
!        *                                                              *
!        * second order reconstruction of the left and right state.     *
!        * the three differences used in the, possibly nonlinear,       *
!        * interpolation are constructed here; the actual left and      *
!        * right states, or at least the differences from the first     *
!        * order interpolation, are computed in the subroutine          *
!        * leftrightstate.                                              *
!        *                                                              *
!        ****************************************************************
!
! fluxes in the i-direction.
      do k=2,kl
        do j=2,jl
          do i=1,il
! store the three differences used in the interpolation
! in du1, du2, du3.
            du1d(irho) = wd(i, j, k, irho) - wd(i-1, j, k, irho)
            du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
            du2d(irho) = wd(i+1, j, k, irho) - wd(i, j, k, irho)
            du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
            du3d(irho) = wd(i+2, j, k, irho) - wd(i+1, j, k, irho)
            du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
            du1d(ivx) = wd(i, j, k, ivx) - wd(i-1, j, k, ivx)
            du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
            du2d(ivx) = wd(i+1, j, k, ivx) - wd(i, j, k, ivx)
            du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
            du3d(ivx) = wd(i+2, j, k, ivx) - wd(i+1, j, k, ivx)
            du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
            du1d(ivy) = wd(i, j, k, ivy) - wd(i-1, j, k, ivy)
            du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
            du2d(ivy) = wd(i+1, j, k, ivy) - wd(i, j, k, ivy)
            du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
            du3d(ivy) = wd(i+2, j, k, ivy) - wd(i+1, j, k, ivy)
            du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
            du1d(ivz) = wd(i, j, k, ivz) - wd(i-1, j, k, ivz)
            du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
            du2d(ivz) = wd(i+1, j, k, ivz) - wd(i, j, k, ivz)
            du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
            du3d(ivz) = wd(i+2, j, k, ivz) - wd(i+1, j, k, ivz)
            du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
            du1d(irhoe) = pd(i, j, k) - pd(i-1, j, k)
            du1(irhoe) = p(i, j, k) - p(i-1, j, k)
            du2d(irhoe) = pd(i+1, j, k) - pd(i, j, k)
            du2(irhoe) = p(i+1, j, k) - p(i, j, k)
            du3d(irhoe) = pd(i+2, j, k) - pd(i+1, j, k)
            du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
            if (correctfork) then
              du1d(itu1) = wd(i, j, k, itu1) - wd(i-1, j, k, itu1)
              du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
              du2d(itu1) = wd(i+1, j, k, itu1) - wd(i, j, k, itu1)
              du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
              du3d(itu1) = wd(i+2, j, k, itu1) - wd(i+1, j, k, itu1)
              du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
            end if
! compute the differences from the first order scheme.
            call leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, &
&                           rotmatrixi, left, leftd, right, rightd)
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
            leftd(irho) = leftd(irho) + wd(i, j, k, irho)
            left(irho) = left(irho) + w(i, j, k, irho)
            leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
            left(ivx) = left(ivx) + w(i, j, k, ivx)
            leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
            left(ivy) = left(ivy) + w(i, j, k, ivy)
            leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
            left(ivz) = left(ivz) + w(i, j, k, ivz)
            leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
            left(irhoe) = left(irhoe) + p(i, j, k)
            rightd(irho) = rightd(irho) + wd(i+1, j, k, irho)
            right(irho) = right(irho) + w(i+1, j, k, irho)
            rightd(ivx) = rightd(ivx) + wd(i+1, j, k, ivx)
            right(ivx) = right(ivx) + w(i+1, j, k, ivx)
            rightd(ivy) = rightd(ivy) + wd(i+1, j, k, ivy)
            right(ivy) = right(ivy) + w(i+1, j, k, ivy)
            rightd(ivz) = rightd(ivz) + wd(i+1, j, k, ivz)
            right(ivz) = right(ivz) + w(i+1, j, k, ivz)
            rightd(irhoe) = rightd(irhoe) + pd(i+1, j, k)
            right(irhoe) = right(irhoe) + p(i+1, j, k)
            if (correctfork) then
              leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
              left(itu1) = left(itu1) + w(i, j, k, itu1)
              rightd(itu1) = rightd(itu1) + wd(i+1, j, k, itu1)
              right(itu1) = right(itu1) + w(i+1, j, k, itu1)
            end if
! store the normal vector, the porosity and the
! mesh velocity if present.
            sxd = sid(i, j, k, 1)
            sx = si(i, j, k, 1)
            syd = sid(i, j, k, 2)
            sy = si(i, j, k, 2)
            szd = sid(i, j, k, 3)
            sz = si(i, j, k, 3)
            por = pori(i, j, k)
            if (addgridvelocities) then
              sfaced = sfaceid(i, j, k)
              sface = sfacei(i, j, k)
            end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
            gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
            call riemannflux_d(left, leftd, right, rightd, flux, fluxd)
! and scatter it to the left and right.
            fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
            fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
            fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
            fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
            fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
            fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
            fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
            fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
            fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) - fluxd(irho)
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
            fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) - fluxd(imx)
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
            fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) - fluxd(imy)
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
            fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) - fluxd(imz)
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
            fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) - fluxd(irhoe)
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
          end do
        end do
      end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the j-direction.
      do k=2,kl
        do j=1,jl
          do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
            du1d(irho) = wd(i, j, k, irho) - wd(i, j-1, k, irho)
            du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
            du2d(irho) = wd(i, j+1, k, irho) - wd(i, j, k, irho)
            du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
            du3d(irho) = wd(i, j+2, k, irho) - wd(i, j+1, k, irho)
            du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
            du1d(ivx) = wd(i, j, k, ivx) - wd(i, j-1, k, ivx)
            du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
            du2d(ivx) = wd(i, j+1, k, ivx) - wd(i, j, k, ivx)
            du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
            du3d(ivx) = wd(i, j+2, k, ivx) - wd(i, j+1, k, ivx)
            du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
            du1d(ivy) = wd(i, j, k, ivy) - wd(i, j-1, k, ivy)
            du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
            du2d(ivy) = wd(i, j+1, k, ivy) - wd(i, j, k, ivy)
            du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
            du3d(ivy) = wd(i, j+2, k, ivy) - wd(i, j+1, k, ivy)
            du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
            du1d(ivz) = wd(i, j, k, ivz) - wd(i, j-1, k, ivz)
            du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
            du2d(ivz) = wd(i, j+1, k, ivz) - wd(i, j, k, ivz)
            du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
            du3d(ivz) = wd(i, j+2, k, ivz) - wd(i, j+1, k, ivz)
            du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
            du1d(irhoe) = pd(i, j, k) - pd(i, j-1, k)
            du1(irhoe) = p(i, j, k) - p(i, j-1, k)
            du2d(irhoe) = pd(i, j+1, k) - pd(i, j, k)
            du2(irhoe) = p(i, j+1, k) - p(i, j, k)
            du3d(irhoe) = pd(i, j+2, k) - pd(i, j+1, k)
            du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
            if (correctfork) then
              du1d(itu1) = wd(i, j, k, itu1) - wd(i, j-1, k, itu1)
              du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
              du2d(itu1) = wd(i, j+1, k, itu1) - wd(i, j, k, itu1)
              du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
              du3d(itu1) = wd(i, j+2, k, itu1) - wd(i, j+1, k, itu1)
              du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
            end if
! compute the differences from the first order scheme.
            call leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, &
&                           rotmatrixj, left, leftd, right, rightd)
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
            leftd(irho) = leftd(irho) + wd(i, j, k, irho)
            left(irho) = left(irho) + w(i, j, k, irho)
            leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
            left(ivx) = left(ivx) + w(i, j, k, ivx)
            leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
            left(ivy) = left(ivy) + w(i, j, k, ivy)
            leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
            left(ivz) = left(ivz) + w(i, j, k, ivz)
            leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
            left(irhoe) = left(irhoe) + p(i, j, k)
            rightd(irho) = rightd(irho) + wd(i, j+1, k, irho)
            right(irho) = right(irho) + w(i, j+1, k, irho)
            rightd(ivx) = rightd(ivx) + wd(i, j+1, k, ivx)
            right(ivx) = right(ivx) + w(i, j+1, k, ivx)
            rightd(ivy) = rightd(ivy) + wd(i, j+1, k, ivy)
            right(ivy) = right(ivy) + w(i, j+1, k, ivy)
            rightd(ivz) = rightd(ivz) + wd(i, j+1, k, ivz)
            right(ivz) = right(ivz) + w(i, j+1, k, ivz)
            rightd(irhoe) = rightd(irhoe) + pd(i, j+1, k)
            right(irhoe) = right(irhoe) + p(i, j+1, k)
            if (correctfork) then
              leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
              left(itu1) = left(itu1) + w(i, j, k, itu1)
              rightd(itu1) = rightd(itu1) + wd(i, j+1, k, itu1)
              right(itu1) = right(itu1) + w(i, j+1, k, itu1)
            end if
! store the normal vector, the porosity and the
! mesh velocity if present.
            sxd = sjd(i, j, k, 1)
            sx = sj(i, j, k, 1)
            syd = sjd(i, j, k, 2)
            sy = sj(i, j, k, 2)
            szd = sjd(i, j, k, 3)
            sz = sj(i, j, k, 3)
            por = porj(i, j, k)
            if (addgridvelocities) then
              sfaced = sfacejd(i, j, k)
              sface = sfacej(i, j, k)
            end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
            gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
            call riemannflux_d(left, leftd, right, rightd, flux, fluxd)
! and scatter it to the left and right.
            fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
            fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
            fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
            fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
            fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
            fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
            fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
            fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
            fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) - fluxd(irho)
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
            fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) - fluxd(imx)
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
            fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) - fluxd(imy)
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
            fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) - fluxd(imz)
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
            fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) - fluxd(irhoe)
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
          end do
        end do
      end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the k-direction.
      do k=1,kl
        do j=2,jl
          do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
            du1d(irho) = wd(i, j, k, irho) - wd(i, j, k-1, irho)
            du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
            du2d(irho) = wd(i, j, k+1, irho) - wd(i, j, k, irho)
            du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
            du3d(irho) = wd(i, j, k+2, irho) - wd(i, j, k+1, irho)
            du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
            du1d(ivx) = wd(i, j, k, ivx) - wd(i, j, k-1, ivx)
            du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
            du2d(ivx) = wd(i, j, k+1, ivx) - wd(i, j, k, ivx)
            du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
            du3d(ivx) = wd(i, j, k+2, ivx) - wd(i, j, k+1, ivx)
            du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
            du1d(ivy) = wd(i, j, k, ivy) - wd(i, j, k-1, ivy)
            du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
            du2d(ivy) = wd(i, j, k+1, ivy) - wd(i, j, k, ivy)
            du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
            du3d(ivy) = wd(i, j, k+2, ivy) - wd(i, j, k+1, ivy)
            du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
            du1d(ivz) = wd(i, j, k, ivz) - wd(i, j, k-1, ivz)
            du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
            du2d(ivz) = wd(i, j, k+1, ivz) - wd(i, j, k, ivz)
            du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
            du3d(ivz) = wd(i, j, k+2, ivz) - wd(i, j, k+1, ivz)
            du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
            du1d(irhoe) = pd(i, j, k) - pd(i, j, k-1)
            du1(irhoe) = p(i, j, k) - p(i, j, k-1)
            du2d(irhoe) = pd(i, j, k+1) - pd(i, j, k)
            du2(irhoe) = p(i, j, k+1) - p(i, j, k)
            du3d(irhoe) = pd(i, j, k+2) - pd(i, j, k+1)
            du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
            if (correctfork) then
              du1d(itu1) = wd(i, j, k, itu1) - wd(i, j, k-1, itu1)
              du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
              du2d(itu1) = wd(i, j, k+1, itu1) - wd(i, j, k, itu1)
              du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
              du3d(itu1) = wd(i, j, k+2, itu1) - wd(i, j, k+1, itu1)
              du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
            end if
! compute the differences from the first order scheme.
            call leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, &
&                           rotmatrixk, left, leftd, right, rightd)
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
            leftd(irho) = leftd(irho) + wd(i, j, k, irho)
            left(irho) = left(irho) + w(i, j, k, irho)
            leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
            left(ivx) = left(ivx) + w(i, j, k, ivx)
            leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
            left(ivy) = left(ivy) + w(i, j, k, ivy)
            leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
            left(ivz) = left(ivz) + w(i, j, k, ivz)
            leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
            left(irhoe) = left(irhoe) + p(i, j, k)
            rightd(irho) = rightd(irho) + wd(i, j, k+1, irho)
            right(irho) = right(irho) + w(i, j, k+1, irho)
            rightd(ivx) = rightd(ivx) + wd(i, j, k+1, ivx)
            right(ivx) = right(ivx) + w(i, j, k+1, ivx)
            rightd(ivy) = rightd(ivy) + wd(i, j, k+1, ivy)
            right(ivy) = right(ivy) + w(i, j, k+1, ivy)
            rightd(ivz) = rightd(ivz) + wd(i, j, k+1, ivz)
            right(ivz) = right(ivz) + w(i, j, k+1, ivz)
            rightd(irhoe) = rightd(irhoe) + pd(i, j, k+1)
            right(irhoe) = right(irhoe) + p(i, j, k+1)
            if (correctfork) then
              leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
              left(itu1) = left(itu1) + w(i, j, k, itu1)
              rightd(itu1) = rightd(itu1) + wd(i, j, k+1, itu1)
              right(itu1) = right(itu1) + w(i, j, k+1, itu1)
            end if
! store the normal vector, the porosity and the
! mesh velocity if present.
            sxd = skd(i, j, k, 1)
            sx = sk(i, j, k, 1)
            syd = skd(i, j, k, 2)
            sy = sk(i, j, k, 2)
            szd = skd(i, j, k, 3)
            sz = sk(i, j, k, 3)
            por = pork(i, j, k)
            if (addgridvelocities) then
              sfaced = sfacekd(i, j, k)
              sface = sfacek(i, j, k)
            end if
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
            gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
            call riemannflux_d(left, leftd, right, rightd, flux, fluxd)
! and scatter it to the left and right.
            fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
            fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
            fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
            fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
            fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
            fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
            fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
            fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
            fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
            fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) - fluxd(irho)
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
            fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) - fluxd(imx)
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
            fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) - fluxd(imy)
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
            fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) - fluxd(imz)
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
            fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) - fluxd(irhoe)
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
          end do
        end do
      end do
    end if
  end if

contains
!  differentiation of leftrightstate in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: left right du1 du2 du3
!   with respect to varying inputs: left right du1 du2 du3
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
  subroutine leftrightstate_d(du1, du1d, du2, du2d, du3, du3d, rotmatrix&
&   , left, leftd, right, rightd)
    implicit none
!
!        local parameter.
!
    real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
    real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
    real(kind=realtype), dimension(:), intent(inout) :: du1d, du2d, du3d
    real(kind=realtype), dimension(:), intent(out) :: left, right
    real(kind=realtype), dimension(:), intent(out) :: leftd, rightd
    real(kind=realtype), dimension(:, :, :, :, :), pointer :: rotmatrix
!
!        local variables.
!
    integer(kind=inttype) :: l
    real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
    real(kind=realtype) :: rl1d, rl2d, rr1d, rr2d, tmpd, dvxd, dvyd, &
&   dvzd
    real(kind=realtype), dimension(3, 3) :: rot
    intrinsic abs
    intrinsic max
    intrinsic sign
    intrinsic min
    real(kind=realtype) :: x6d
    real(kind=realtype) :: y4d
    real(kind=realtype) :: max2d
    real(kind=realtype) :: max5d
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x1
    real(kind=realtype) :: x5d
    real(kind=realtype) :: y3d
    real(kind=realtype) :: max4d
    real(kind=realtype) :: max7d
    real(kind=realtype) :: x1d
    real(kind=realtype) :: x4d
    real(kind=realtype) :: y2d
    real(kind=realtype) :: max3d
    real(kind=realtype) :: max7
    real(kind=realtype) :: max6
    real(kind=realtype) :: max6d
    real(kind=realtype) :: max5
    real(kind=realtype) :: max4
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: y4
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: x3d
    real(kind=realtype) :: y1
    real(kind=realtype) :: y1d
!
!        ****************************************************************
!        *                                                              *
!        * begin execution.                                             *
!        *                                                              *
!        ****************************************************************
!
! check if the velocity components should be transformed to
! the cylindrical frame.
    if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
      rot(1, 1) = rotmatrix(i, j, k, 1, 1)
      rot(1, 2) = rotmatrix(i, j, k, 1, 2)
      rot(1, 3) = rotmatrix(i, j, k, 1, 3)
      rot(2, 1) = rotmatrix(i, j, k, 2, 1)
      rot(2, 2) = rotmatrix(i, j, k, 2, 2)
      rot(2, 3) = rotmatrix(i, j, k, 2, 3)
      rot(3, 1) = rotmatrix(i, j, k, 3, 1)
      rot(3, 2) = rotmatrix(i, j, k, 3, 2)
      rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
      dvxd = du1d(ivx)
      dvx = du1(ivx)
      dvyd = du1d(ivy)
      dvy = du1(ivy)
      dvzd = du1d(ivz)
      dvz = du1(ivz)
      du1d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
      du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
      du1d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
      du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
      du1d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
      du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      dvxd = du2d(ivx)
      dvx = du2(ivx)
      dvyd = du2d(ivy)
      dvy = du2(ivy)
      dvzd = du2d(ivz)
      dvz = du2(ivz)
      du2d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
      du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
      du2d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
      du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
      du2d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
      du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      dvxd = du3d(ivx)
      dvx = du3(ivx)
      dvyd = du3d(ivy)
      dvy = du3(ivy)
      dvzd = du3d(ivz)
      dvz = du3(ivz)
      du3d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
      du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
      du3d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
      du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
      du3d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
      du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
    end if
! determine the limiter used.
    select case  (limused) 
    case (nolimiter) 
! linear interpolation; no limiter.
! loop over the number of variables to be interpolated.
      do l=1,nwint
        leftd(l) = omk*du1d(l) + opk*du2d(l)
        left(l) = omk*du1(l) + opk*du2(l)
        rightd(l) = -(omk*du3d(l)) - opk*du2d(l)
        right(l) = -(omk*du3(l)) - opk*du2(l)
      end do
    case (vanalbeda) 
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
      do l=1,nwint
        if (du2(l) .ge. 0.) then
          x1d = du2d(l)
          x1 = du2(l)
        else
          x1d = -du2d(l)
          x1 = -du2(l)
        end if
        if (x1 .lt. epslim) then
          max2 = epslim
          max2d = 0.0_8
        else
          max2d = x1d
          max2 = x1
        end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
        tmpd = -(one*max2d*sign(1.d0, max2*du2(l))/sign(max2, du2(l))**2&
&         )
        tmp = one/sign(max2, du2(l))
        if (du1(l) .ge. 0.) then
          x3d = du1d(l)
          x3 = du1(l)
        else
          x3d = -du1d(l)
          x3 = -du1(l)
        end if
        if (x3 .lt. epslim) then
          max4 = epslim
          max4d = 0.0_8
        else
          max4d = x3d
          max4 = x3
        end if
        y1d = (du2d(l)*sign(max4, du1(l))-du2(l)*max4d*sign(1.d0, max4*&
&         du1(l)))/sign(max4, du1(l))**2
        y1 = du2(l)/sign(max4, du1(l))
        if (zero .lt. y1) then
          rl1d = y1d
          rl1 = y1
        else
          rl1 = zero
          rl1d = 0.0_8
        end if
        if (zero .lt. du1(l)*tmp) then
          rl2d = du1d(l)*tmp + du1(l)*tmpd
          rl2 = du1(l)*tmp
        else
          rl2 = zero
          rl2d = 0.0_8
        end if
        if (zero .lt. du3(l)*tmp) then
          rr1d = du3d(l)*tmp + du3(l)*tmpd
          rr1 = du3(l)*tmp
        else
          rr1 = zero
          rr1d = 0.0_8
        end if
        if (du3(l) .ge. 0.) then
          x4d = du3d(l)
          x4 = du3(l)
        else
          x4d = -du3d(l)
          x4 = -du3(l)
        end if
        if (x4 .lt. epslim) then
          max5 = epslim
          max5d = 0.0_8
        else
          max5d = x4d
          max5 = x4
        end if
        y2d = (du2d(l)*sign(max5, du3(l))-du2(l)*max5d*sign(1.d0, max5*&
&         du3(l)))/sign(max5, du3(l))**2
        y2 = du2(l)/sign(max5, du3(l))
        if (zero .lt. y2) then
          rr2d = y2d
          rr2 = y2
        else
          rr2 = zero
          rr2d = 0.0_8
        end if
! compute the corresponding limiter values.
        rl1d = ((rl1d*(rl1+one)+rl1*rl1d)*(rl1*rl1+one)-rl1*(rl1+one)*(&
&         rl1d*rl1+rl1*rl1d))/(rl1*rl1+one)**2
        rl1 = rl1*(rl1+one)/(rl1*rl1+one)
        rl2d = ((rl2d*(rl2+one)+rl2*rl2d)*(rl2*rl2+one)-rl2*(rl2+one)*(&
&         rl2d*rl2+rl2*rl2d))/(rl2*rl2+one)**2
        rl2 = rl2*(rl2+one)/(rl2*rl2+one)
        rr1d = ((rr1d*(rr1+one)+rr1*rr1d)*(rr1*rr1+one)-rr1*(rr1+one)*(&
&         rr1d*rr1+rr1*rr1d))/(rr1*rr1+one)**2
        rr1 = rr1*(rr1+one)/(rr1*rr1+one)
        rr2d = ((rr2d*(rr2+one)+rr2*rr2d)*(rr2*rr2+one)-rr2*(rr2+one)*(&
&         rr2d*rr2+rr2*rr2d))/(rr2*rr2+one)**2
        rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
        leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+rl2*&
&         du2d(l))
        left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
        rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l)+&
&         rr2*du3d(l))
        right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
      end do
    case (minmod) 
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
      do l=1,nwint
        if (du2(l) .ge. 0.) then
          x2d = du2d(l)
          x2 = du2(l)
        else
          x2d = -du2d(l)
          x2 = -du2(l)
        end if
        if (x2 .lt. epslim) then
          max3 = epslim
          max3d = 0.0_8
        else
          max3d = x2d
          max3 = x2
        end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
        tmpd = -(one*max3d*sign(1.d0, max3*du2(l))/sign(max3, du2(l))**2&
&         )
        tmp = one/sign(max3, du2(l))
        if (du1(l) .ge. 0.) then
          x5d = du1d(l)
          x5 = du1(l)
        else
          x5d = -du1d(l)
          x5 = -du1(l)
        end if
        if (x5 .lt. epslim) then
          max6 = epslim
          max6d = 0.0_8
        else
          max6d = x5d
          max6 = x5
        end if
        y3d = (du2d(l)*sign(max6, du1(l))-du2(l)*max6d*sign(1.d0, max6*&
&         du1(l)))/sign(max6, du1(l))**2
        y3 = du2(l)/sign(max6, du1(l))
        if (zero .lt. y3) then
          rl1d = y3d
          rl1 = y3
        else
          rl1 = zero
          rl1d = 0.0_8
        end if
        if (zero .lt. du1(l)*tmp) then
          rl2d = du1d(l)*tmp + du1(l)*tmpd
          rl2 = du1(l)*tmp
        else
          rl2 = zero
          rl2d = 0.0_8
        end if
        if (zero .lt. du3(l)*tmp) then
          rr1d = du3d(l)*tmp + du3(l)*tmpd
          rr1 = du3(l)*tmp
        else
          rr1 = zero
          rr1d = 0.0_8
        end if
        if (du3(l) .ge. 0.) then
          x6d = du3d(l)
          x6 = du3(l)
        else
          x6d = -du3d(l)
          x6 = -du3(l)
        end if
        if (x6 .lt. epslim) then
          max7 = epslim
          max7d = 0.0_8
        else
          max7d = x6d
          max7 = x6
        end if
        y4d = (du2d(l)*sign(max7, du3(l))-du2(l)*max7d*sign(1.d0, max7*&
&         du3(l)))/sign(max7, du3(l))**2
        y4 = du2(l)/sign(max7, du3(l))
        if (zero .lt. y4) then
          rr2d = y4d
          rr2 = y4
        else
          rr2 = zero
          rr2d = 0.0_8
        end if
        if (one .gt. factminmod*rl1) then
          rl1d = factminmod*rl1d
          rl1 = factminmod*rl1
        else
          rl1 = one
          rl1d = 0.0_8
        end if
        if (one .gt. factminmod*rl2) then
          rl2d = factminmod*rl2d
          rl2 = factminmod*rl2
        else
          rl2 = one
          rl2d = 0.0_8
        end if
        if (one .gt. factminmod*rr1) then
          rr1d = factminmod*rr1d
          rr1 = factminmod*rr1
        else
          rr1 = one
          rr1d = 0.0_8
        end if
        if (one .gt. factminmod*rr2) then
          rr2d = factminmod*rr2d
          rr2 = factminmod*rr2
        else
          rr2 = one
          rr2d = 0.0_8
        end if
! compute the nonlinear corrections to the first order
! scheme.
        leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+rl2*&
&         du2d(l))
        left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
        rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l)+&
&         rr2*du3d(l))
        right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
      end do
    end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
    if (firstorderk) then
      leftd(itu1) = 0.0_8
      left(itu1) = zero
      rightd(itu1) = 0.0_8
      right(itu1) = zero
    end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
    if (rotationalperiodic) then
! left state.
      dvxd = leftd(ivx)
      dvx = left(ivx)
      dvyd = leftd(ivy)
      dvy = left(ivy)
      dvzd = leftd(ivz)
      dvz = left(ivz)
      leftd(ivx) = rot(1, 1)*dvxd + rot(2, 1)*dvyd + rot(3, 1)*dvzd
      left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
      leftd(ivy) = rot(1, 2)*dvxd + rot(2, 2)*dvyd + rot(3, 2)*dvzd
      left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
      leftd(ivz) = rot(1, 3)*dvxd + rot(2, 3)*dvyd + rot(3, 3)*dvzd
      left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
! right state.
      dvxd = rightd(ivx)
      dvx = right(ivx)
      dvyd = rightd(ivy)
      dvy = right(ivy)
      dvzd = rightd(ivz)
      dvz = right(ivz)
      rightd(ivx) = rot(1, 1)*dvxd + rot(2, 1)*dvyd + rot(3, 1)*dvzd
      right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
      rightd(ivy) = rot(1, 2)*dvxd + rot(2, 2)*dvyd + rot(3, 2)*dvzd
      right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
      rightd(ivz) = rot(1, 3)*dvxd + rot(2, 3)*dvyd + rot(3, 3)*dvzd
      right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
    end if
  end subroutine leftrightstate_d
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
  subroutine leftrightstate(du1, du2, du3, rotmatrix, left, right)
    implicit none
!
!        local parameter.
!
    real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
    real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
    real(kind=realtype), dimension(:), intent(out) :: left, right
    real(kind=realtype), dimension(:, :, :, :, :), pointer :: rotmatrix
!
!        local variables.
!
    integer(kind=inttype) :: l
    real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
    real(kind=realtype), dimension(3, 3) :: rot
    intrinsic abs
    intrinsic max
    intrinsic sign
    intrinsic min
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: max7
    real(kind=realtype) :: max6
    real(kind=realtype) :: max5
    real(kind=realtype) :: max4
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: y4
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
!
!        ****************************************************************
!        *                                                              *
!        * begin execution.                                             *
!        *                                                              *
!        ****************************************************************
!
! check if the velocity components should be transformed to
! the cylindrical frame.
    if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
      rot(1, 1) = rotmatrix(i, j, k, 1, 1)
      rot(1, 2) = rotmatrix(i, j, k, 1, 2)
      rot(1, 3) = rotmatrix(i, j, k, 1, 3)
      rot(2, 1) = rotmatrix(i, j, k, 2, 1)
      rot(2, 2) = rotmatrix(i, j, k, 2, 2)
      rot(2, 3) = rotmatrix(i, j, k, 2, 3)
      rot(3, 1) = rotmatrix(i, j, k, 3, 1)
      rot(3, 2) = rotmatrix(i, j, k, 3, 2)
      rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
      dvx = du1(ivx)
      dvy = du1(ivy)
      dvz = du1(ivz)
      du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
      du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
      du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      dvx = du2(ivx)
      dvy = du2(ivy)
      dvz = du2(ivz)
      du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
      du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
      du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      dvx = du3(ivx)
      dvy = du3(ivy)
      dvz = du3(ivz)
      du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
      du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
      du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
    end if
! determine the limiter used.
    select case  (limused) 
    case (nolimiter) 
! linear interpolation; no limiter.
! loop over the number of variables to be interpolated.
      do l=1,nwint
        left(l) = omk*du1(l) + opk*du2(l)
        right(l) = -(omk*du3(l)) - opk*du2(l)
      end do
    case (vanalbeda) 
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
      do l=1,nwint
        if (du2(l) .ge. 0.) then
          x1 = du2(l)
        else
          x1 = -du2(l)
        end if
        if (x1 .lt. epslim) then
          max2 = epslim
        else
          max2 = x1
        end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
        tmp = one/sign(max2, du2(l))
        if (du1(l) .ge. 0.) then
          x3 = du1(l)
        else
          x3 = -du1(l)
        end if
        if (x3 .lt. epslim) then
          max4 = epslim
        else
          max4 = x3
        end if
        y1 = du2(l)/sign(max4, du1(l))
        if (zero .lt. y1) then
          rl1 = y1
        else
          rl1 = zero
        end if
        if (zero .lt. du1(l)*tmp) then
          rl2 = du1(l)*tmp
        else
          rl2 = zero
        end if
        if (zero .lt. du3(l)*tmp) then
          rr1 = du3(l)*tmp
        else
          rr1 = zero
        end if
        if (du3(l) .ge. 0.) then
          x4 = du3(l)
        else
          x4 = -du3(l)
        end if
        if (x4 .lt. epslim) then
          max5 = epslim
        else
          max5 = x4
        end if
        y2 = du2(l)/sign(max5, du3(l))
        if (zero .lt. y2) then
          rr2 = y2
        else
          rr2 = zero
        end if
! compute the corresponding limiter values.
        rl1 = rl1*(rl1+one)/(rl1*rl1+one)
        rl2 = rl2*(rl2+one)/(rl2*rl2+one)
        rr1 = rr1*(rr1+one)/(rr1*rr1+one)
        rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
        left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
        right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
      end do
    case (minmod) 
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
      do l=1,nwint
        if (du2(l) .ge. 0.) then
          x2 = du2(l)
        else
          x2 = -du2(l)
        end if
        if (x2 .lt. epslim) then
          max3 = epslim
        else
          max3 = x2
        end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
        tmp = one/sign(max3, du2(l))
        if (du1(l) .ge. 0.) then
          x5 = du1(l)
        else
          x5 = -du1(l)
        end if
        if (x5 .lt. epslim) then
          max6 = epslim
        else
          max6 = x5
        end if
        y3 = du2(l)/sign(max6, du1(l))
        if (zero .lt. y3) then
          rl1 = y3
        else
          rl1 = zero
        end if
        if (zero .lt. du1(l)*tmp) then
          rl2 = du1(l)*tmp
        else
          rl2 = zero
        end if
        if (zero .lt. du3(l)*tmp) then
          rr1 = du3(l)*tmp
        else
          rr1 = zero
        end if
        if (du3(l) .ge. 0.) then
          x6 = du3(l)
        else
          x6 = -du3(l)
        end if
        if (x6 .lt. epslim) then
          max7 = epslim
        else
          max7 = x6
        end if
        y4 = du2(l)/sign(max7, du3(l))
        if (zero .lt. y4) then
          rr2 = y4
        else
          rr2 = zero
        end if
        if (one .gt. factminmod*rl1) then
          rl1 = factminmod*rl1
        else
          rl1 = one
        end if
        if (one .gt. factminmod*rl2) then
          rl2 = factminmod*rl2
        else
          rl2 = one
        end if
        if (one .gt. factminmod*rr1) then
          rr1 = factminmod*rr1
        else
          rr1 = one
        end if
        if (one .gt. factminmod*rr2) then
          rr2 = factminmod*rr2
        else
          rr2 = one
        end if
! compute the nonlinear corrections to the first order
! scheme.
        left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
        right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
      end do
    end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
    if (firstorderk) then
      left(itu1) = zero
      right(itu1) = zero
    end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
    if (rotationalperiodic) then
! left state.
      dvx = left(ivx)
      dvy = left(ivy)
      dvz = left(ivz)
      left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
      left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
      left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
! right state.
      dvx = right(ivx)
      dvy = right(ivy)
      dvz = right(ivz)
      right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
      right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
      right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
    end if
  end subroutine leftrightstate
!  differentiation of riemannflux in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: flux
!   with respect to varying inputs: tref rgas sface sx sy sz flux
!                left right
!        ================================================================
  subroutine riemannflux_d(left, leftd, right, rightd, flux, fluxd)
    implicit none
!
!        subroutine arguments.
!
    real(kind=realtype), dimension(*), intent(in) :: left, right
    real(kind=realtype), dimension(*), intent(in) :: leftd, rightd
    real(kind=realtype), dimension(*), intent(out) :: flux
    real(kind=realtype), dimension(*), intent(out) :: fluxd
!
!        local variables.
!
    real(kind=realtype) :: porflux, rface
    real(kind=realtype) :: rfaced
    real(kind=realtype) :: etl, etr, z1l, z1r, tmp
    real(kind=realtype) :: etld, etrd, z1ld, z1rd, tmpd
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk
    real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
    real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
    real(kind=realtype) :: uavgd, vavgd, wavgd, havgd, kavgd
    real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
    real(kind=realtype) :: alphaavgd, a2avgd, aavgd, unavgd
    real(kind=realtype) :: ovaavg, ova2avg, area, eta
    real(kind=realtype) :: ovaavgd, ova2avgd, aread, etad
    real(kind=realtype) :: gm1, gm53
    real(kind=realtype) :: lam1, lam2, lam3
    real(kind=realtype) :: lam1d, lam2d, lam3d
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
&   abv7d
    real(kind=realtype), dimension(2) :: rhotmp, utmp, vtmp, wtmp
    real(kind=realtype), dimension(2) :: rhotmpd, utmpd, vtmpd, wtmpd
    real(kind=realtype), dimension(2) :: ptmp, ktmp, etmp
    real(kind=realtype), dimension(2) :: ptmpd, ktmpd, etmpd
    intrinsic sqrt
    intrinsic max
    intrinsic abs
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: arg2
    real(kind=realtype) :: arg2d
    real(kind=realtype) :: result2
    real(kind=realtype) :: result2d
    real(kind=realtype) :: abs1d
    real(kind=realtype) :: max2d
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x1
    real(kind=realtype) :: x1d
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs2d
    real(kind=realtype) :: abs1
    real(kind=realtype) :: max2
!
!        ****************************************************************
!        *                                                              *
!        * begin execution.                                             *
!        *                                                              *
!        ****************************************************************
!
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
    porflux = half*rfil
    if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
    gm1 = gammaface - one
    gm53 = gammaface - five*third
! determine which riemann solver must be solved.
    select case  (riemannused) 
    case (roe) 
! determine the preconditioner used.
      select case  (precond) 
      case (noprecond) 
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
        if (left(irho) .eq. 0.0_8) then
          z1ld = 0.0_8
        else
          z1ld = leftd(irho)/(2.0*sqrt(left(irho)))
        end if
        z1l = sqrt(left(irho))
        if (right(irho) .eq. 0.0_8) then
          z1rd = 0.0_8
        else
          z1rd = rightd(irho)/(2.0*sqrt(right(irho)))
        end if
        z1r = sqrt(right(irho))
        tmpd = -(one*(z1ld+z1rd)/(z1l+z1r)**2)
        tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
        if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
          ktmpd = 0.0_8
          ktmpd(1) = leftd(itu1)
          ktmp(1) = left(itu1)
          ktmpd(2) = rightd(itu1)
          ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
          drkd = rightd(irho)*right(itu1) + right(irho)*rightd(itu1) - &
&           leftd(irho)*left(itu1) - left(irho)*leftd(itu1)
          drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
          kavgd = tmpd*(z1l*left(itu1)+z1r*right(itu1)) + tmp*(z1ld*left&
&           (itu1)+z1l*leftd(itu1)+z1rd*right(itu1)+z1r*rightd(itu1))
          kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
        else
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
          drk = 0.0
          kavg = 0.0
          ktmpd = 0.0_8
          kavgd = 0.0_8
          drkd = 0.0_8
        end if
! compute the total energy of the left and right state.
        rhotmpd = 0.0_8
        rhotmpd(1) = leftd(irho)
        rhotmp(1) = left(irho)
        rhotmpd(2) = rightd(irho)
        rhotmp(2) = right(irho)
        utmpd = 0.0_8
        utmpd(1) = leftd(ivx)
        utmp(1) = left(ivx)
        utmpd(2) = rightd(ivx)
        utmp(2) = right(ivx)
        vtmpd = 0.0_8
        vtmpd(1) = leftd(ivy)
        vtmp(1) = left(ivy)
        vtmpd(2) = rightd(ivy)
        vtmp(2) = right(ivy)
        wtmpd = 0.0_8
        wtmpd(1) = leftd(ivz)
        wtmp(1) = left(ivz)
        wtmpd(2) = rightd(ivz)
        wtmp(2) = right(ivz)
        ptmpd = 0.0_8
        ptmpd(1) = leftd(irhoe)
        ptmp(1) = left(irhoe)
        ptmpd(2) = rightd(irhoe)
        ptmp(2) = right(irhoe)
        etmpd = 0.0_8
        call etotarray_d(rhotmp, rhotmpd, utmp, utmpd, vtmp, vtmpd, wtmp&
&                  , wtmpd, ptmp, ptmpd, ktmp, ktmpd, etmp, etmpd, &
&                  correctfork, 2)
        etld = etmpd(1)
        etl = etmp(1)
        etrd = etmpd(2)
        etr = etmp(2)
! compute the difference of the conservative mean
! flow variables.
        drd = rightd(irho) - leftd(irho)
        dr = right(irho) - left(irho)
        drud = rightd(irho)*right(ivx) + right(irho)*rightd(ivx) - leftd&
&         (irho)*left(ivx) - left(irho)*leftd(ivx)
        dru = right(irho)*right(ivx) - left(irho)*left(ivx)
        drvd = rightd(irho)*right(ivy) + right(irho)*rightd(ivy) - leftd&
&         (irho)*left(ivy) - left(irho)*leftd(ivy)
        drv = right(irho)*right(ivy) - left(irho)*left(ivy)
        drwd = rightd(irho)*right(ivz) + right(irho)*rightd(ivz) - leftd&
&         (irho)*left(ivz) - left(irho)*leftd(ivz)
        drw = right(irho)*right(ivz) - left(irho)*left(ivz)
        dred = etrd - etld
        dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
        ravg = fourth*(z1r+z1l)**2
        uavgd = tmpd*(z1l*left(ivx)+z1r*right(ivx)) + tmp*(z1ld*left(ivx&
&         )+z1l*leftd(ivx)+z1rd*right(ivx)+z1r*rightd(ivx))
        uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
        vavgd = tmpd*(z1l*left(ivy)+z1r*right(ivy)) + tmp*(z1ld*left(ivy&
&         )+z1l*leftd(ivy)+z1rd*right(ivy)+z1r*rightd(ivy))
        vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
        wavgd = tmpd*(z1l*left(ivz)+z1r*right(ivz)) + tmp*(z1ld*left(ivz&
&         )+z1l*leftd(ivz)+z1rd*right(ivz)+z1r*rightd(ivz))
        wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
        havgd = tmpd*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r) + &
&         tmp*(((etld+leftd(irhoe))*z1l-(etl+left(irhoe))*z1ld)/z1l**2+(&
&         (etrd+rightd(irhoe))*z1r-(etr+right(irhoe))*z1rd)/z1r**2)
        havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
        arg1d = 2*sx*sxd + 2*sy*syd + 2*sz*szd
        arg1 = sx**2 + sy**2 + sz**2
        if (arg1 .eq. 0.0_8) then
          aread = 0.0_8
        else
          aread = arg1d/(2.0*sqrt(arg1))
        end if
        area = sqrt(arg1)
        if (1.e-25_realtype .lt. area) then
          max2d = aread
          max2 = area
        else
          max2 = 1.e-25_realtype
          max2d = 0.0_8
        end if
        tmpd = -(one*max2d/max2**2)
        tmp = one/max2
        sxd = sxd*tmp + sx*tmpd
        sx = sx*tmp
        syd = syd*tmp + sy*tmpd
        sy = sy*tmp
        szd = szd*tmp + sz*tmpd
        sz = sz*tmp
        rfaced = sfaced*tmp + sface*tmpd
        rface = sface*tmp
! compute some dependent variables at the roe
! average state.
        alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
          a2avgd = gm1*(havgd-alphaavgd) - gm53*kavgd
          a2avg = gm1*(havg-alphaavg) - gm53*kavg
        else
          a2avgd = -(gm1*(havgd-alphaavgd)-gm53*kavgd)
          a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
        end if
        if (a2avg .eq. 0.0_8) then
          aavgd = 0.0_8
        else
          aavgd = a2avgd/(2.0*sqrt(a2avg))
        end if
        aavg = sqrt(a2avg)
        unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*sz + &
&         wavg*szd
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavgd = -(one*aavgd/aavg**2)
        ovaavg = one/aavg
        ova2avgd = -(one*a2avgd/a2avg**2)
        ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
        if (por .eq. boundflux) then
          unavgd = rfaced
          unavg = rface
        end if
        x1d = (leftd(ivx)-rightd(ivx))*sx + (left(ivx)-right(ivx))*sxd +&
&         (leftd(ivy)-rightd(ivy))*sy + (left(ivy)-right(ivy))*syd + (&
&         leftd(ivz)-rightd(ivz))*sz + (left(ivz)-right(ivz))*szd
        x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&         left(ivz)-right(ivz))*sz
        if (x1 .ge. 0.) then
          abs1d = x1d
          abs1 = x1
        else
          abs1d = -x1d
          abs1 = -x1
        end if
        arg1d = (gammaface*leftd(irhoe)*left(irho)-gammaface*left(irhoe)&
&         *leftd(irho))/left(irho)**2
        arg1 = gammaface*left(irhoe)/left(irho)
        if (arg1 .eq. 0.0_8) then
          result1d = 0.0_8
        else
          result1d = arg1d/(2.0*sqrt(arg1))
        end if
        result1 = sqrt(arg1)
        arg2d = (gammaface*rightd(irhoe)*right(irho)-gammaface*right(&
&         irhoe)*rightd(irho))/right(irho)**2
        arg2 = gammaface*right(irhoe)/right(irho)
        if (arg2 .eq. 0.0_8) then
          result2d = 0.0_8
        else
          result2d = arg2d/(2.0*sqrt(arg2))
        end if
        result2 = sqrt(arg2)
        x2d = result1d - result2d
        x2 = result1 - result2
        if (x2 .ge. 0.) then
          abs2d = x2d
          abs2 = x2
        else
          abs2d = -x2d
          abs2 = -x2
        end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
        etad = half*(abs1d+abs2d)
        eta = half*(abs1+abs2)
        if (unavg - rface + aavg .ge. 0.) then
          lam1d = unavgd - rfaced + aavgd
          lam1 = unavg - rface + aavg
        else
          lam1d = -(unavgd-rfaced+aavgd)
          lam1 = -(unavg-rface+aavg)
        end if
        if (unavg - rface - aavg .ge. 0.) then
          lam2d = unavgd - rfaced - aavgd
          lam2 = unavg - rface - aavg
        else
          lam2d = -(unavgd-rfaced-aavgd)
          lam2 = -(unavg-rface-aavg)
        end if
        if (unavg - rface .ge. 0.) then
          lam3d = unavgd - rfaced
          lam3 = unavg - rface
        else
          lam3d = -(unavgd-rfaced)
          lam3 = -(unavg-rface)
        end if
! apply the entropy correction to the eigenvalues.
        tmp = two*eta
        if (lam1 .lt. tmp) then
          lam1d = etad + (fourth*(lam1d*lam1+lam1*lam1d)*eta-fourth*lam1&
&           **2*etad)/eta**2
          lam1 = eta + fourth*lam1*lam1/eta
        end if
        if (lam2 .lt. tmp) then
          lam2d = etad + (fourth*(lam2d*lam2+lam2*lam2d)*eta-fourth*lam2&
&           **2*etad)/eta**2
          lam2 = eta + fourth*lam2*lam2/eta
        end if
        if (lam3 .lt. tmp) then
          lam3d = etad + (fourth*(lam3d*lam3+lam3*lam3d)*eta-fourth*lam3&
&           **2*etad)/eta**2
          lam3 = eta + fourth*lam3*lam3/eta
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1d = lam1d*area + lam1*aread
        lam1 = lam1*area
        lam2d = lam2d*area + lam2*aread
        lam2 = lam2*area
        lam3d = lam3d*area + lam3*aread
        lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1d = half*(lam1d+lam2d)
        abv1 = half*(lam1+lam2)
        abv2d = half*(lam1d-lam2d)
        abv2 = half*(lam1-lam2)
        abv3d = abv1d - lam3d
        abv3 = abv1 - lam3
        abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-vavgd&
&         *drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz*&
&         drwd - unavgd*dr - unavg*drd
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd + (&
&         abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd + &
&         abv3d*abv5 + abv3*abv5d
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
        fluxd(irho) = -(porflux*(lam3d*dr+lam3*drd+abv6d))
        flux(irho) = -(porflux*(lam3*dr+abv6))
        fluxd(imx) = -(porflux*(lam3d*dru+lam3*drud+uavgd*abv6+uavg*&
&         abv6d+sxd*abv7+sx*abv7d))
        flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
        fluxd(imy) = -(porflux*(lam3d*drv+lam3*drvd+vavgd*abv6+vavg*&
&         abv6d+syd*abv7+sy*abv7d))
        flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
        fluxd(imz) = -(porflux*(lam3d*drw+lam3*drwd+wavgd*abv6+wavg*&
&         abv6d+szd*abv7+sz*abv7d))
        flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
        fluxd(irhoe) = -(porflux*(lam3d*dre+lam3*dred+havgd*abv6+havg*&
&         abv6d+unavgd*abv7+unavg*abv7d))
        flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
      case (turkel) 
!          tmp = max(lam1,lam2,lam3)
!          flux(irho)  = -porflux*(tmp*dr)
!          flux(imx)   = -porflux*(tmp*dru)
!          flux(imy)   = -porflux*(tmp*drv)
!          flux(imz)   = -porflux*(tmp*drw)
!          flux(irhoe) = -porflux*(tmp*dre)
        call returnfail('riemannflux', &
&                    'turkel preconditioner not implemented yet')
      case (choimerkle) 
        call returnfail('riemannflux', &
&                    'choi merkle preconditioner not implemented yet')
      end select
    case (vanleer) 
      call returnfail('riemannflux', &
&                  'van leer fvs not implemented yet')
    case (ausmdv) 
      call returnfail('riemannflux', 'ausmdv fvs not implemented yet'&
&                 )
    end select
  end subroutine riemannflux_d
!        ================================================================
  subroutine riemannflux(left, right, flux)
    implicit none
!
!        subroutine arguments.
!
    real(kind=realtype), dimension(*), intent(in) :: left, right
    real(kind=realtype), dimension(*), intent(out) :: flux
!
!        local variables.
!
    real(kind=realtype) :: porflux, rface
    real(kind=realtype) :: etl, etr, z1l, z1r, tmp
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk
    real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
    real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
    real(kind=realtype) :: ovaavg, ova2avg, area, eta
    real(kind=realtype) :: gm1, gm53
    real(kind=realtype) :: lam1, lam2, lam3
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype), dimension(2) :: rhotmp, utmp, vtmp, wtmp
    real(kind=realtype), dimension(2) :: ptmp, ktmp, etmp
    intrinsic sqrt
    intrinsic max
    intrinsic abs
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    real(kind=realtype) :: arg2
    real(kind=realtype) :: result2
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: max2
!
!        ****************************************************************
!        *                                                              *
!        * begin execution.                                             *
!        *                                                              *
!        ****************************************************************
!
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
    porflux = half*rfil
    if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
    gm1 = gammaface - one
    gm53 = gammaface - five*third
! determine which riemann solver must be solved.
    select case  (riemannused) 
    case (roe) 
! determine the preconditioner used.
      select case  (precond) 
      case (noprecond) 
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
        z1l = sqrt(left(irho))
        z1r = sqrt(right(irho))
        tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
        if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
          ktmp(1) = left(itu1)
          ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
          drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
          kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
        else
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
          drk = 0.0
          kavg = 0.0
        end if
! compute the total energy of the left and right state.
        rhotmp(1) = left(irho)
        rhotmp(2) = right(irho)
        utmp(1) = left(ivx)
        utmp(2) = right(ivx)
        vtmp(1) = left(ivy)
        vtmp(2) = right(ivy)
        wtmp(1) = left(ivz)
        wtmp(2) = right(ivz)
        ptmp(1) = left(irhoe)
        ptmp(2) = right(irhoe)
        call etotarray(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
&                   correctfork, 2)
        etl = etmp(1)
        etr = etmp(2)
! compute the difference of the conservative mean
! flow variables.
        dr = right(irho) - left(irho)
        dru = right(irho)*right(ivx) - left(irho)*left(ivx)
        drv = right(irho)*right(ivy) - left(irho)*left(ivy)
        drw = right(irho)*right(ivz) - left(irho)*left(ivz)
        dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
        ravg = fourth*(z1r+z1l)**2
        uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
        vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
        wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
        havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
        arg1 = sx**2 + sy**2 + sz**2
        area = sqrt(arg1)
        if (1.e-25_realtype .lt. area) then
          max2 = area
        else
          max2 = 1.e-25_realtype
        end if
        tmp = one/max2
        sx = sx*tmp
        sy = sy*tmp
        sz = sz*tmp
        rface = sface*tmp
! compute some dependent variables at the roe
! average state.
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
          a2avg = gm1*(havg-alphaavg) - gm53*kavg
        else
          a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
        end if
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
        if (por .eq. boundflux) unavg = rface
        x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&         left(ivz)-right(ivz))*sz
        if (x1 .ge. 0.) then
          abs1 = x1
        else
          abs1 = -x1
        end if
        arg1 = gammaface*left(irhoe)/left(irho)
        result1 = sqrt(arg1)
        arg2 = gammaface*right(irhoe)/right(irho)
        result2 = sqrt(arg2)
        x2 = result1 - result2
        if (x2 .ge. 0.) then
          abs2 = x2
        else
          abs2 = -x2
        end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
        eta = half*(abs1+abs2)
        if (unavg - rface + aavg .ge. 0.) then
          lam1 = unavg - rface + aavg
        else
          lam1 = -(unavg-rface+aavg)
        end if
        if (unavg - rface - aavg .ge. 0.) then
          lam2 = unavg - rface - aavg
        else
          lam2 = -(unavg-rface-aavg)
        end if
        if (unavg - rface .ge. 0.) then
          lam3 = unavg - rface
        else
          lam3 = -(unavg-rface)
        end if
! apply the entropy correction to the eigenvalues.
        tmp = two*eta
        if (lam1 .lt. tmp) lam1 = eta + fourth*lam1*lam1/eta
        if (lam2 .lt. tmp) lam2 = eta + fourth*lam2*lam2/eta
        if (lam3 .lt. tmp) lam3 = eta + fourth*lam3*lam3/eta
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = lam1*area
        lam2 = lam2*area
        lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
        flux(irho) = -(porflux*(lam3*dr+abv6))
        flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
        flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
        flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
        flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
      case (turkel) 
!          tmp = max(lam1,lam2,lam3)
!          flux(irho)  = -porflux*(tmp*dr)
!          flux(imx)   = -porflux*(tmp*dru)
!          flux(imy)   = -porflux*(tmp*drv)
!          flux(imz)   = -porflux*(tmp*drw)
!          flux(irhoe) = -porflux*(tmp*dre)
        call returnfail('riemannflux', &
&                    'turkel preconditioner not implemented yet')
      case (choimerkle) 
        call returnfail('riemannflux', &
&                    'choi merkle preconditioner not implemented yet')
      end select
    case (vanleer) 
      call returnfail('riemannflux', &
&                  'van leer fvs not implemented yet')
    case (ausmdv) 
      call returnfail('riemannflux', 'ausmdv fvs not implemented yet'&
&                 )
    end select
  end subroutine riemannflux
end subroutine inviscidupwindflux_d

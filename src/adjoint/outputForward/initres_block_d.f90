   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4512) -  3 Aug 2012 15:11
   !
   !  Differentiation of initres_block in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *dw
   !   with respect to varying inputs: *(*flowdoms.w) *dw
   !   Plus diff mem management of: flowdoms:in *flowdoms.w:in dw:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          initres.f90                                     *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-18-2003                                      *
   !      * Last modified: 06-28-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INITRES_BLOCK_D(varstart, varend, nn, sps)
   USE FLOWVARREFSTATE
   USE INPUTITERATION
   USE BLOCKPOINTERS_D
   USE INPUTTIMESPECTRAL
   USE INPUTUNSTEADY
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * initres initializes the given range of the residual. Either to *
   !      * zero, steady computation, or to an unsteady term for the time  *
   !      * spectral and unsteady modes. For the coarser grid levels the   *
   !      * residual forcing term is taken into account.                   *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: varstart, varend, nn, sps
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm, ll, ii, jj, i, j, k, l, m
   REAL(kind=realtype) :: oneoverdt, tmp
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: ww, wsp, wsp1
   REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: wspd
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: volsp
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately of no variables are in the range.
   IF (varend .LT. varstart) THEN
   RETURN
   ELSE
   ! Determine the equation mode and act accordingly.
   SELECT CASE  (equationmode) 
   CASE (steady) 
   ! Steady state computation.
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   ! Ground level of the multigrid cycle. Initialize the
   ! owned residuals to zero.
   DO l=varstart,varend
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   dwd(i, j, k, l) = 0.0_8
   dw(i, j, k, l) = zero
   END DO
   END DO
   END DO
   END DO
   END IF
   CASE (timespectral) 
   !===========================================================
   ! Time spectral computation. The time derivative of the
   ! current solution is given by a linear combination of
   ! all other solutions, i.e. a matrix vector product.
   ! First store the section to which this block belongs
   ! in jj.
   jj = sectionid
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   ! Finest multigrid level. The residual must be
   ! initialized to the time derivative.
   ! Initialize it to zero.
   DO l=varstart,varend
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   dwd(i, j, k, l) = 0.0_8
   dw(i, j, k, l) = zero
   END DO
   END DO
   END DO
   END DO
   ! Loop over the number of terms which contribute
   ! to the time derivative.
   timeloopfine:DO mm=1,ntimeintervalsspectral
   ! Store the pointer for the variable to be used to
   ! compute the unsteady source term and the volume.
   ! Also store in ii the offset needed for vector
   ! quantities.
   wspd => flowdomsd(nn, currentlevel, mm)%w
   wsp => flowdoms(nn, currentlevel, mm)%w
   volsp => flowdoms(nn, currentlevel, mm)%vol
   ii = 3*(mm-1)
   ! Loop over the number of variables to be set.
   varloopfine:DO l=varstart,varend
   ! Test for a momentum variable.
   IF ((l .EQ. ivx .OR. l .EQ. ivy) .OR. l .EQ. ivz) THEN
   ! Momentum variable. A special treatment is
   ! needed because it is a vector and the velocities
   ! are stored instead of the momentum. Set the
   ! coefficient ll, which defines the row of the
   ! matrix used later on.
   IF (l .EQ. ivx) ll = 3*sps - 2
   IF (l .EQ. ivy) ll = 3*sps - 1
   IF (l .EQ. ivz) ll = 3*sps
   ! Loop over the owned cell centers to add the
   ! contribution from wsp.
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Store the matrix vector product with the
   ! velocity in tmp.
   tmpd = dvector(jj, ll, ii+1)*wspd(i, j, k, ivx) + &
   &                      dvector(jj, ll, ii+2)*wspd(i, j, k, ivy) + dvector&
   &                      (jj, ll, ii+3)*wspd(i, j, k, ivz)
   tmp = dvector(jj, ll, ii+1)*wsp(i, j, k, ivx) + &
   &                      dvector(jj, ll, ii+2)*wsp(i, j, k, ivy) + dvector(&
   &                      jj, ll, ii+3)*wsp(i, j, k, ivz)
   ! Update the residual. Note the
   ! multiplication with the density to obtain
   ! the correct time derivative for the
   ! momentum variable.
   dwd(i, j, k, l) = dwd(i, j, k, l) + volsp(i, j, k)*(&
   &                      tmpd*wsp(i, j, k, irho)+tmp*wspd(i, j, k, irho))
   dw(i, j, k, l) = dw(i, j, k, l) + tmp*volsp(i, j, k)&
   &                      *wsp(i, j, k, irho)
   END DO
   END DO
   END DO
   ELSE
   ! Scalar variable.  Loop over the owned cells to
   ! add the contribution of wsp to the time
   ! derivative.
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   dwd(i, j, k, l) = dwd(i, j, k, l) + dscalar(jj, sps&
   &                      , mm)*volsp(i, j, k)*wspd(i, j, k, l)
   dw(i, j, k, l) = dw(i, j, k, l) + dscalar(jj, sps, &
   &                      mm)*volsp(i, j, k)*wsp(i, j, k, l)
   END DO
   END DO
   END DO
   END IF
   END DO varloopfine
   END DO timeloopfine
   END IF
   END SELECT
   ! Set the residual in the halo cells to zero. This is just
   ! to avoid possible problems. Their values do not matter.
   DO l=varstart,varend
   DO k=0,kb
   DO j=0,jb
   dwd(0, j, k, l) = 0.0_8
   dw(0, j, k, l) = zero
   dwd(1, j, k, l) = 0.0_8
   dw(1, j, k, l) = zero
   dwd(ie, j, k, l) = 0.0_8
   dw(ie, j, k, l) = zero
   dwd(ib, j, k, l) = 0.0_8
   dw(ib, j, k, l) = zero
   END DO
   END DO
   DO k=0,kb
   DO i=2,il
   dwd(i, 0, k, l) = 0.0_8
   dw(i, 0, k, l) = zero
   dwd(i, 1, k, l) = 0.0_8
   dw(i, 1, k, l) = zero
   dwd(i, je, k, l) = 0.0_8
   dw(i, je, k, l) = zero
   dwd(i, jb, k, l) = 0.0_8
   dw(i, jb, k, l) = zero
   END DO
   END DO
   DO j=2,jl
   DO i=2,il
   dwd(i, j, 0, l) = 0.0_8
   dw(i, j, 0, l) = zero
   dwd(i, j, 1, l) = 0.0_8
   dw(i, j, 1, l) = zero
   dwd(i, j, ke, l) = 0.0_8
   dw(i, j, ke, l) = zero
   dwd(i, j, kb, l) = 0.0_8
   dw(i, j, kb, l) = zero
   END DO
   END DO
   END DO
   END IF
   END SUBROUTINE INITRES_BLOCK_D

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module sst_d
! this module contains the source code related to the sst turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier.
  use constants
  implicit none
  real(kind=realtype), dimension(:, :, :, :, :), allocatable :: qq

contains
!  differentiation of sstsource in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *w *scratch
!   rw status of diff variables: *w:in *scratch:in-out
!   plus diff mem management of: w:in scratch:in
  subroutine sstsource_d()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use paramturb
    implicit none
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rsstgamd, rsstbetad
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: rhoid, ssd, spkd, sdkd
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic min
    real(kind=realtype) :: result1
! set model constants
    result1 = sqrt(rsstbetas)
    rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/result1
    result1 = sqrt(rsstbetas)
    rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/result1
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstgamd = rsstgam1*t1d + rsstgam2*t2d
          rsstgam = t1*rsstgam1 + t2*rsstgam2
          rsstbetad = rsstbeta1*t1d + rsstbeta2*t2d
          rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
          rhoid = -(one*wd(i, j, k, irho)/w(i, j, k, irho)**2)
          rhoi = one/w(i, j, k, irho)
          ssd = scratchd(i, j, k, iprod)
          ss = scratch(i, j, k, iprod)
          spkd = rev(i, j, k)*(ssd*rhoi+ss*rhoid)
          spk = rev(i, j, k)*ss*rhoi
          sdkd = rsstbetas*(wd(i, j, k, itu1)*w(i, j, k, itu2)+w(i, j, k&
&           , itu1)*wd(i, j, k, itu2))
          sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
          if (spk .gt. pklim*sdk) then
            spkd = pklim*sdkd
            spk = pklim*sdk
          else
            spk = spk
          end if
          scratchd(i, j, k, idvt+0) = spkd - sdkd
          scratch(i, j, k, idvt+0) = spk - sdk
          scratchd(i, j, k, idvt+1) = rsstgamd*ss + rsstgam*ssd + two*&
&           rsstsigw2*(t2d*scratch(i, j, k, icd)+t2*scratchd(i, j, k, &
&           icd)) - rsstbetad*w(i, j, k, itu2)**2 - rsstbeta*2*w(i, j, k&
&           , itu2)*wd(i, j, k, itu2)
          scratch(i, j, k, idvt+1) = rsstgam*ss + two*t2*rsstsigw2*&
&           scratch(i, j, k, icd) - rsstbeta*w(i, j, k, itu2)**2
        end do
      end do
    end do
  end subroutine sstsource_d
  subroutine sstsource()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use paramturb
    implicit none
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic min
    real(kind=realtype) :: result1
! set model constants
    result1 = sqrt(rsstbetas)
    rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/result1
    result1 = sqrt(rsstbetas)
    rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/result1
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstgam = t1*rsstgam1 + t2*rsstgam2
          rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
          rhoi = one/w(i, j, k, irho)
          ss = scratch(i, j, k, iprod)
          spk = rev(i, j, k)*ss*rhoi
          sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
          if (spk .gt. pklim*sdk) then
            spk = pklim*sdk
          else
            spk = spk
          end if
          scratch(i, j, k, idvt+0) = spk - sdk
          scratch(i, j, k, idvt+1) = rsstgam*ss + two*t2*rsstsigw2*&
&           scratch(i, j, k, icd) - rsstbeta*w(i, j, k, itu2)**2
        end do
      end do
    end do
  end subroutine sstsource
!  differentiation of sstviscous in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *w *rlv *scratch *vol *si *sj
!                *sk
!   rw status of diff variables: *w:in *rlv:in *scratch:in-out
!                *vol:in *si:in *sj:in *sk:in
!   plus diff mem management of: w:in rlv:in scratch:in vol:in
!                si:in sj:in sk:in
  subroutine sstviscous_d()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigkp1d, rsstsigkd, rsstsigkm1d
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: rsstsigwp1d, rsstsigwd, rsstsigwm1d
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          volid = -(one*vold(i, j, k)/vol(i, j, k)**2)
          voli = one/vol(i, j, k)
          volmid = -(two*(vold(i, j, k)+vold(i, j, k-1))/(vol(i, j, k)+&
&           vol(i, j, k-1))**2)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpid = -(two*(vold(i, j, k)+vold(i, j, k+1))/(vol(i, j, k)+&
&           vol(i, j, k+1))**2)
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xmd = skd(i, j, k-1, 1)*volmi + sk(i, j, k-1, 1)*volmid
          xm = sk(i, j, k-1, 1)*volmi
          ymd = skd(i, j, k-1, 2)*volmi + sk(i, j, k-1, 2)*volmid
          ym = sk(i, j, k-1, 2)*volmi
          zmd = skd(i, j, k-1, 3)*volmi + sk(i, j, k-1, 3)*volmid
          zm = sk(i, j, k-1, 3)*volmi
          xpd = skd(i, j, k, 1)*volpi + sk(i, j, k, 1)*volpid
          xp = sk(i, j, k, 1)*volpi
          ypd = skd(i, j, k, 2)*volpi + sk(i, j, k, 2)*volpid
          yp = sk(i, j, k, 2)*volpi
          zpd = skd(i, j, k, 3)*volpi + sk(i, j, k, 3)*volpid
          zp = sk(i, j, k, 3)*volpi
          xad = half*((skd(i, j, k, 1)+skd(i, j, k-1, 1))*voli+(sk(i, j&
&           , k, 1)+sk(i, j, k-1, 1))*volid)
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          yad = half*((skd(i, j, k, 2)+skd(i, j, k-1, 2))*voli+(sk(i, j&
&           , k, 2)+sk(i, j, k-1, 2))*volid)
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          zad = half*((skd(i, j, k, 3)+skd(i, j, k-1, 3))*voli+(sk(i, j&
&           , k, 3)+sk(i, j, k-1, 3))*volid)
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttmd = xmd*xa + xm*xad + ymd*ya + ym*yad + zmd*za + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xpd*xa + xp*xad + ypd*ya + yp*yad + zpd*za + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
          t1d = scratchd(i, j, k+1, if1sst)
          t1 = scratch(i, j, k+1, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k-1, if1sst)
          t1 = scratch(i, j, k-1, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoid = -(one*wd(i, j, k, irho)/w(i, j, k, irho)**2)
          rhoi = one/w(i, j, k, irho)
          mulmd = half*(rlvd(i, j, k-1)+rlvd(i, j, k))
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j, k+1)+rlvd(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muemd = half*(rev(i, j, k-1)*rsstsigkm1d+rev(i, j, k)*&
&           rsstsigkd)
          muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
          muepd = half*(rev(i, j, k+1)*rsstsigkp1d+rev(i, j, k)*&
&           rsstsigkd)
          muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
          c1md = (ttmd*rhoi+ttm*rhoid)*(mulm+muem) + ttm*rhoi*(mulmd+&
&           muemd)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = (ttpd*rhoi+ttp*rhoid)*(mulp+muep) + ttp*rhoi*(mulpd+&
&           muepd)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          muemd = half*(rev(i, j, k-1)*rsstsigwm1d+rev(i, j, k)*&
&           rsstsigwd)
          muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
          muepd = half*(rev(i, j, k+1)*rsstsigwp1d+rev(i, j, k)*&
&           rsstsigwd)
          muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
          c2md = (ttmd*rhoi+ttm*rhoid)*(mulm+muem) + ttm*rhoi*(mulmd+&
&           muemd)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = (ttpd*rhoi+ttp*rhoid)*(mulp+muep) + ttp*rhoi*(mulpd+&
&           muepd)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratchd(i, j, k, idvt+0) = scratchd(i, j, k, idvt+0) + c1md*w&
&           (i, j, k-1, itu1) + c1m*wd(i, j, k-1, itu1) - c10d*w(i, j, k&
&           , itu1) - c10*wd(i, j, k, itu1) + c1pd*w(i, j, k+1, itu1) + &
&           c1p*wd(i, j, k+1, itu1)
          scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i&
&           , j, k-1, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, &
&           itu1)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + c2md*w&
&           (i, j, k-1, itu2) + c2m*wd(i, j, k-1, itu2) - c20d*w(i, j, k&
&           , itu2) - c20*wd(i, j, k, itu2) + c2pd*w(i, j, k+1, itu2) + &
&           c2p*wd(i, j, k+1, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j, k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          volid = -(one*vold(i, j, k)/vol(i, j, k)**2)
          voli = one/vol(i, j, k)
          volmid = -(two*(vold(i, j, k)+vold(i, j-1, k))/(vol(i, j, k)+&
&           vol(i, j-1, k))**2)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpid = -(two*(vold(i, j, k)+vold(i, j+1, k))/(vol(i, j, k)+&
&           vol(i, j+1, k))**2)
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xmd = sjd(i, j-1, k, 1)*volmi + sj(i, j-1, k, 1)*volmid
          xm = sj(i, j-1, k, 1)*volmi
          ymd = sjd(i, j-1, k, 2)*volmi + sj(i, j-1, k, 2)*volmid
          ym = sj(i, j-1, k, 2)*volmi
          zmd = sjd(i, j-1, k, 3)*volmi + sj(i, j-1, k, 3)*volmid
          zm = sj(i, j-1, k, 3)*volmi
          xpd = sjd(i, j, k, 1)*volpi + sj(i, j, k, 1)*volpid
          xp = sj(i, j, k, 1)*volpi
          ypd = sjd(i, j, k, 2)*volpi + sj(i, j, k, 2)*volpid
          yp = sj(i, j, k, 2)*volpi
          zpd = sjd(i, j, k, 3)*volpi + sj(i, j, k, 3)*volpid
          zp = sj(i, j, k, 3)*volpi
          xad = half*((sjd(i, j, k, 1)+sjd(i, j-1, k, 1))*voli+(sj(i, j&
&           , k, 1)+sj(i, j-1, k, 1))*volid)
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          yad = half*((sjd(i, j, k, 2)+sjd(i, j-1, k, 2))*voli+(sj(i, j&
&           , k, 2)+sj(i, j-1, k, 2))*volid)
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          zad = half*((sjd(i, j, k, 3)+sjd(i, j-1, k, 3))*voli+(sj(i, j&
&           , k, 3)+sj(i, j-1, k, 3))*volid)
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttmd = xmd*xa + xm*xad + ymd*ya + ym*yad + zmd*za + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xpd*xa + xp*xad + ypd*ya + yp*yad + zpd*za + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
          t1d = scratchd(i, j+1, k, if1sst)
          t1 = scratch(i, j+1, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j-1, k, if1sst)
          t1 = scratch(i, j-1, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoid = -(one*wd(i, j, k, irho)/w(i, j, k, irho)**2)
          rhoi = one/w(i, j, k, irho)
          mulmd = half*(rlvd(i, j-1, k)+rlvd(i, j, k))
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j+1, k)+rlvd(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muemd = half*(rev(i, j-1, k)*rsstsigkm1d+rev(i, j, k)*&
&           rsstsigkd)
          muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
          muepd = half*(rev(i, j+1, k)*rsstsigkp1d+rev(i, j, k)*&
&           rsstsigkd)
          muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
          c1md = (ttmd*rhoi+ttm*rhoid)*(mulm+muem) + ttm*rhoi*(mulmd+&
&           muemd)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = (ttpd*rhoi+ttp*rhoid)*(mulp+muep) + ttp*rhoi*(mulpd+&
&           muepd)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          muemd = half*(rev(i, j-1, k)*rsstsigwm1d+rev(i, j, k)*&
&           rsstsigwd)
          muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
          muepd = half*(rev(i, j+1, k)*rsstsigwp1d+rev(i, j, k)*&
&           rsstsigwd)
          muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
          c2md = (ttmd*rhoi+ttm*rhoid)*(mulm+muem) + ttm*rhoi*(mulmd+&
&           muemd)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = (ttpd*rhoi+ttp*rhoid)*(mulp+muep) + ttp*rhoi*(mulpd+&
&           muepd)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratchd(i, j, k, idvt+0) = scratchd(i, j, k, idvt+0) + c1md*w&
&           (i, j-1, k, itu1) + c1m*wd(i, j-1, k, itu1) - c10d*w(i, j, k&
&           , itu1) - c10*wd(i, j, k, itu1) + c1pd*w(i, j+1, k, itu1) + &
&           c1p*wd(i, j+1, k, itu1)
          scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i&
&           , j-1, k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, &
&           itu1)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + c2md*w&
&           (i, j-1, k, itu2) + c2m*wd(i, j-1, k, itu2) - c20d*w(i, j, k&
&           , itu2) - c20*wd(i, j, k, itu2) + c2pd*w(i, j+1, k, itu2) + &
&           c2p*wd(i, j+1, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j-1, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          volid = -(one*vold(i, j, k)/vol(i, j, k)**2)
          voli = one/vol(i, j, k)
          volmid = -(two*(vold(i, j, k)+vold(i-1, j, k))/(vol(i, j, k)+&
&           vol(i-1, j, k))**2)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpid = -(two*(vold(i, j, k)+vold(i+1, j, k))/(vol(i, j, k)+&
&           vol(i+1, j, k))**2)
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xmd = sid(i-1, j, k, 1)*volmi + si(i-1, j, k, 1)*volmid
          xm = si(i-1, j, k, 1)*volmi
          ymd = sid(i-1, j, k, 2)*volmi + si(i-1, j, k, 2)*volmid
          ym = si(i-1, j, k, 2)*volmi
          zmd = sid(i-1, j, k, 3)*volmi + si(i-1, j, k, 3)*volmid
          zm = si(i-1, j, k, 3)*volmi
          xpd = sid(i, j, k, 1)*volpi + si(i, j, k, 1)*volpid
          xp = si(i, j, k, 1)*volpi
          ypd = sid(i, j, k, 2)*volpi + si(i, j, k, 2)*volpid
          yp = si(i, j, k, 2)*volpi
          zpd = sid(i, j, k, 3)*volpi + si(i, j, k, 3)*volpid
          zp = si(i, j, k, 3)*volpi
          xad = half*((sid(i, j, k, 1)+sid(i-1, j, k, 1))*voli+(si(i, j&
&           , k, 1)+si(i-1, j, k, 1))*volid)
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          yad = half*((sid(i, j, k, 2)+sid(i-1, j, k, 2))*voli+(si(i, j&
&           , k, 2)+si(i-1, j, k, 2))*volid)
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          zad = half*((sid(i, j, k, 3)+sid(i-1, j, k, 3))*voli+(si(i, j&
&           , k, 3)+si(i-1, j, k, 3))*volid)
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttmd = xmd*xa + xm*xad + ymd*ya + ym*yad + zmd*za + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xpd*xa + xp*xad + ypd*ya + yp*yad + zpd*za + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
          t1d = scratchd(i+1, j, k, if1sst)
          t1 = scratch(i+1, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i-1, j, k, if1sst)
          t1 = scratch(i-1, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoid = -(one*wd(i, j, k, irho)/w(i, j, k, irho)**2)
          rhoi = one/w(i, j, k, irho)
          mulmd = half*(rlvd(i-1, j, k)+rlvd(i, j, k))
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i+1, j, k)+rlvd(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muemd = half*(rev(i-1, j, k)*rsstsigkm1d+rev(i, j, k)*&
&           rsstsigkd)
          muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
          muepd = half*(rev(i+1, j, k)*rsstsigkp1d+rev(i, j, k)*&
&           rsstsigkd)
          muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
          c1md = (ttmd*rhoi+ttm*rhoid)*(mulm+muem) + ttm*rhoi*(mulmd+&
&           muemd)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = (ttpd*rhoi+ttp*rhoid)*(mulp+muep) + ttp*rhoi*(mulpd+&
&           muepd)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          muemd = half*(rev(i-1, j, k)*rsstsigwm1d+rev(i, j, k)*&
&           rsstsigwd)
          muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
          muepd = half*(rev(i+1, j, k)*rsstsigwp1d+rev(i, j, k)*&
&           rsstsigwd)
          muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
          c2md = (ttmd*rhoi+ttm*rhoid)*(mulm+muem) + ttm*rhoi*(mulmd+&
&           muemd)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = (ttpd*rhoi+ttp*rhoid)*(mulp+muep) + ttp*rhoi*(mulpd+&
&           muepd)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratchd(i, j, k, idvt+0) = scratchd(i, j, k, idvt+0) + c1md*w&
&           (i-1, j, k, itu1) + c1m*wd(i-1, j, k, itu1) - c10d*w(i, j, k&
&           , itu1) - c10*wd(i, j, k, itu1) + c1pd*w(i+1, j, k, itu1) + &
&           c1p*wd(i+1, j, k, itu1)
          scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i-&
&           1, j, k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, &
&           itu1)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + c2md*w&
&           (i-1, j, k, itu2) + c2m*wd(i-1, j, k, itu2) - c20d*w(i, j, k&
&           , itu2) - c20*wd(i, j, k, itu2) + c2pd*w(i+1, j, k, itu2) + &
&           c2p*wd(i+1, j, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i-&
&           1, j, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i+1, j, k, &
&           itu2)
        end do
      end do
    end do
  end subroutine sstviscous_d
  subroutine sstviscous()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
          t1 = scratch(i, j, k+1, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k-1, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i&
&           , j, k-1, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, &
&           itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j, k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
          t1 = scratch(i, j+1, k, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j-1, k, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i&
&           , j-1, k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, &
&           itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j-1, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
          t1 = scratch(i+1, j, k, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i-1, j, k, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i-&
&           1, j, k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, &
&           itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i-&
&           1, j, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i+1, j, k, &
&           itu2)
        end do
      end do
    end do
  end subroutine sstviscous
!  differentiation of sstresscale in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:in
!   plus diff mem management of: dw:in scratch:in
  subroutine sstresscale_d()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          dwd(i, j, k, itu1) = -(volref(i, j, k)*rblank*scratchd(i, j, k&
&           , idvt+0))
          dw(i, j, k, itu1) = -(volref(i, j, k)*scratch(i, j, k, idvt+0)&
&           *rblank)
          dwd(i, j, k, itu2) = -(volref(i, j, k)*rblank*scratchd(i, j, k&
&           , idvt+1))
          dw(i, j, k, itu2) = -(volref(i, j, k)*scratch(i, j, k, idvt+1)&
&           *rblank)
        end do
      end do
    end do
  end subroutine sstresscale_d
  subroutine sstresscale()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          dw(i, j, k, itu1) = -(volref(i, j, k)*scratch(i, j, k, idvt+0)&
&           *rblank)
          dw(i, j, k, itu2) = -(volref(i, j, k)*scratch(i, j, k, idvt+1)&
&           *rblank)
        end do
      end do
    end do
  end subroutine sstresscale
!  differentiation of f1sst in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *w *scratch *d2wall
!   rw status of diff variables: *w:in *scratch:in-out *d2wall:in
!   plus diff mem management of: w:in scratch:in d2wall:in
  subroutine f1sst_d()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    real(kind=realtype) :: t1, t2, arg1, myeps
    real(kind=realtype) :: t1d, t2d, arg1d
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: arg10
    real(kind=realtype) :: arg10d
    real(kind=realtype) :: max1d
    real(kind=realtype) :: max1
    myeps = 1e-10_realtype/two/rsstsigw2
! compute the blending function f1 for all owned cells.
    do k=1,ke
      do j=1,je
        do i=1,ie
          if (w(i, j, k, itu1) .eq. 0.0_8) then
            result1d = 0.0_8
          else
            result1d = wd(i, j, k, itu1)/(2.0*sqrt(w(i, j, k, itu1)))
          end if
          result1 = sqrt(w(i, j, k, itu1))
          t1d = (result1d*0.09_realtype*w(i, j, k, itu2)*d2wall(i, j, k)&
&           -result1*0.09_realtype*(wd(i, j, k, itu2)*d2wall(i, j, k)+w(&
&           i, j, k, itu2)*d2walld(i, j, k)))/(0.09_realtype*w(i, j, k, &
&           itu2)*d2wall(i, j, k))**2
          t1 = result1/(0.09_realtype*w(i, j, k, itu2)*d2wall(i, j, k))
          t2d = -(500.0_realtype*rlv(i, j, k)*((wd(i, j, k, irho)*w(i, j&
&           , k, itu2)+w(i, j, k, irho)*wd(i, j, k, itu2))*d2wall(i, j, &
&           k)**2+w(i, j, k, irho)*w(i, j, k, itu2)*2*d2wall(i, j, k)*&
&           d2walld(i, j, k))/(w(i, j, k, irho)*w(i, j, k, itu2)*d2wall(&
&           i, j, k)**2)**2)
          t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, &
&           itu2)*d2wall(i, j, k)**2)
          if (t1 .lt. t2) then
            t1d = t2d
            t1 = t2
          else
            t1 = t1
          end if
          if (eps .lt. scratch(i, j, k, icd)) then
            max1d = scratchd(i, j, k, icd)
            max1 = scratch(i, j, k, icd)
          else
            max1 = eps
            max1d = 0.0_8
          end if
          t2d = (two*wd(i, j, k, itu1)*max1*d2wall(i, j, k)**2-two*w(i, &
&           j, k, itu1)*(max1d*d2wall(i, j, k)**2+max1*2*d2wall(i, j, k)&
&           *d2walld(i, j, k)))/(max1*d2wall(i, j, k)**2)**2
          t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
          if (t1 .gt. t2) then
            arg1d = t2d
            arg1 = t2
          else
            arg1d = t1d
            arg1 = t1
          end if
          arg10d = 4*arg1**3*arg1d
          arg10 = arg1**4
          scratchd(i, j, k, if1sst) = arg10d*(1.0-tanh(arg10)**2)
          scratch(i, j, k, if1sst) = tanh(arg10)
        end do
      end do
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratchd(1, j, k, if1sst) = scratchd(2, j, k, if1sst)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratchd(ie, j, k, if1sst) = scratchd(il, j, k, if1sst)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, 1, k, if1sst) = scratchd(i, 2, k, if1sst)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, je, k, if1sst) = scratchd(i, jl, k, if1sst)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, j, 1, if1sst) = scratchd(i, j, 2, if1sst)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, j, ke, if1sst) = scratchd(i, j, kl, if1sst)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst_d
  subroutine f1sst()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    real(kind=realtype) :: t1, t2, arg1, myeps
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    real(kind=realtype) :: result1
    real(kind=realtype) :: arg10
    real(kind=realtype) :: max1
    myeps = 1e-10_realtype/two/rsstsigw2
! compute the blending function f1 for all owned cells.
    do k=1,ke
      do j=1,je
        do i=1,ie
          result1 = sqrt(w(i, j, k, itu1))
          t1 = result1/(0.09_realtype*w(i, j, k, itu2)*d2wall(i, j, k))
          t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, &
&           itu2)*d2wall(i, j, k)**2)
          if (t1 .lt. t2) then
            t1 = t2
          else
            t1 = t1
          end if
          if (eps .lt. scratch(i, j, k, icd)) then
            max1 = scratch(i, j, k, icd)
          else
            max1 = eps
          end if
          t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
          if (t1 .gt. t2) then
            arg1 = t2
          else
            arg1 = t1
          end if
          arg10 = arg1**4
          scratch(i, j, k, if1sst) = tanh(arg10)
        end do
      end do
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst
end module sst_d

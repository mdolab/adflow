!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module bcdata_d
  use constants
  use bcdatamod
  implicit none

contains
! ---------------------------------------------------------------
! routines that set the appropriate variable names for bcs with
! bcdata.
  subroutine setbcvarnamesisothermalwall()
    use cgnsnames
    use constants
    implicit none
    nbcvar = nbcvarisothermalwall
    bcvarnames(1) = cgnstemp
  end subroutine setbcvarnamesisothermalwall
  subroutine setbcvarnamessubsonicinflow()
    use constants
    use cgnsnames
    use inputphysics, only : equations
    use flowvarrefstate, only : nwt
    implicit none
!
!      local variables.
!
    logical :: varallowed
    nbcvar = nbcvarsubsonicinflow
    if (equations .eq. ransequations) nbcvar = nbcvar + nwt
    bcvarnames(1) = cgnsptot
    bcvarnames(2) = cgnsttot
    bcvarnames(3) = cgnsrhotot
    bcvarnames(4) = cgnsvelanglex
    bcvarnames(5) = cgnsvelangley
    bcvarnames(6) = cgnsvelanglez
    bcvarnames(7) = cgnsvelvecx
    bcvarnames(8) = cgnsvelvecy
    bcvarnames(9) = cgnsvelvecz
    bcvarnames(10) = cgnsvelvecr
    bcvarnames(11) = cgnsvelvectheta
    bcvarnames(12) = cgnsdensity
    bcvarnames(13) = cgnsvelx
    bcvarnames(14) = cgnsvely
    bcvarnames(15) = cgnsvelz
    bcvarnames(16) = cgnsvelr
    bcvarnames(17) = cgnsveltheta
    call setbcvarnamesturb(17_inttype)
  end subroutine setbcvarnamessubsonicinflow
  subroutine setbcvarnamessubsonicoutflow()
    use cgnsnames
    use constants
    use flowvarrefstate, only : nwt
    implicit none
    nbcvar = nbcvarsubsonicoutflow
    bcvarnames(1) = cgnspressure
  end subroutine setbcvarnamessubsonicoutflow
  subroutine setbcvarnamessupersonicinflow()
    use constants
    use cgnsnames
    use inputphysics, only : equations
    use flowvarrefstate, only : nwt
    implicit none
    nbcvar = nbcvarsupersonicinflow
    if (equations .eq. ransequations) nbcvar = nbcvar + nwt
    bcvarnames(1) = cgnsdensity
    bcvarnames(2) = cgnspressure
    bcvarnames(3) = cgnsvelx
    bcvarnames(4) = cgnsvely
    bcvarnames(5) = cgnsvelz
    bcvarnames(6) = cgnsvelr
    bcvarnames(7) = cgnsveltheta
    call setbcvarnamesturb(7_inttype)
  end subroutine setbcvarnamessupersonicinflow
  subroutine setbcvarnamesturb(offset)
!
!       setbcvarnamesturb sets the names for the turbulence
!       variables to be determined. this depends on the turbulence
!       model. if not the rans equations are solved an immediate
!       return is made.
!
    use constants
    use cgnsnames
    use inputphysics, only : equations, turbmodel
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: offset
! return immediately if not the rans equations are solved.
    if (equations .ne. ransequations) then
      return
    else
! determine the turbulence model and set the names accordingly.
      select case  (turbmodel) 
      case (spalartallmaras, spalartallmarasedwards) 
        bcvarnames(offset+1) = cgnsturbsanu
      case (komegawilcox, komegamodified, mentersst) 
        bcvarnames(offset+1) = cgnsturbk
        bcvarnames(offset+2) = cgnsturbomega
      case (ktau) 
        bcvarnames(offset+1) = cgnsturbk
        bcvarnames(offset+2) = cgnsturbtau
      case (v2f) 
        bcvarnames(offset+1) = cgnsturbk
        bcvarnames(offset+2) = cgnsturbepsilon
        bcvarnames(offset+3) = cgnsturbv2
        bcvarnames(offset+4) = cgnsturbf
      end select
    end if
  end subroutine setbcvarnamesturb
!  differentiation of computehtot in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: ht
!   with respect to varying inputs: tt ht
! ---------------------------------------------------------------
! --------------------------------------
!                utilities
! --------------------------------------
  subroutine computehtot_d(tt, ttd, ht, htd)
!
!       computehtot computes the total enthalpy from the given total
!       temperature. the total enthalpy is the integral of cp, which
!       is a very simple expression for constant cp. for a variable cp
!       it is a bit more work.
!
    use constants
    use cpcurvefits
    use communication, only : myid
    use inputphysics, only : cpmodel, gammaconstant, rgasdim
    use flowvarrefstate, only : pinfdim, pinfdimd
    implicit none
!
!      subroutine arguments.
!
    real(kind=realtype), intent(in) :: tt
    real(kind=realtype), intent(in) :: ttd
    real(kind=realtype), intent(out) :: ht
    real(kind=realtype), intent(out) :: htd
!
!      local variables.
!
    integer(kind=inttype) :: ii, nn, mm, start
    real(kind=realtype) :: t2
!        ================================================================
! determine the cp model used in the computation.
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp. the total enthalpy is simply cp*tt.
      htd = gammaconstant*rgasdim*ttd/(gammaconstant-one)
      ht = gammaconstant*rgasdim*tt/(gammaconstant-one)
    end select
  end subroutine computehtot_d
! ---------------------------------------------------------------
! --------------------------------------
!                utilities
! --------------------------------------
  subroutine computehtot(tt, ht)
!
!       computehtot computes the total enthalpy from the given total
!       temperature. the total enthalpy is the integral of cp, which
!       is a very simple expression for constant cp. for a variable cp
!       it is a bit more work.
!
    use constants
    use cpcurvefits
    use communication, only : myid
    use inputphysics, only : cpmodel, gammaconstant, rgasdim
    use flowvarrefstate, only : pinfdim
    implicit none
!
!      subroutine arguments.
!
    real(kind=realtype), intent(in) :: tt
    real(kind=realtype), intent(out) :: ht
!
!      local variables.
!
    integer(kind=inttype) :: ii, nn, mm, start
    real(kind=realtype) :: t2
!        ================================================================
! determine the cp model used in the computation.
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp. the total enthalpy is simply cp*tt.
      ht = gammaconstant*rgasdim*tt/(gammaconstant-one)
    end select
  end subroutine computehtot
  subroutine unitvectorscylsystem(boco)
!
!       unitvectorscylsystem determines the unit vectors of the
!       local coordinate systen of the boundary face defined by the
!       data in bcdatamod. in that local system the axial direction
!       is rotation axis.
!
    use constants
    use blockpointers, only : bcfaceid, bcdata, x, si, sj, sk, il, jl,&
&   kl, sectionid
    use section, only : sections
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: boco
!
!      local variables.
!
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: factinlet, var
    real(kind=realtype), dimension(3) :: dir
    real(kind=realtype), dimension(:, :, :), pointer :: ss
    intrinsic abs
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    real(kind=realtype) :: abs0
! set the pointers for coordinates and normals of the block
! face on which this subface is located. set factinlet
! such that factinlet*normals points into the domain.
    select case  (bcfaceid(boco)) 
    case (imin) 
      xf => x(1, :, :, :)
      ss => si(1, :, :, :)
      factinlet = one
    case (imax) 
      xf => x(il, :, :, :)
      ss => si(il, :, :, :)
      factinlet = -one
    case (jmin) 
      xf => x(:, 1, :, :)
      ss => sj(:, 1, :, :)
      factinlet = one
    case (jmax) 
      xf => x(:, jl, :, :)
      ss => sj(:, jl, :, :)
      factinlet = -one
    case (kmin) 
      xf => x(:, :, 1, :)
      ss => sk(:, :, 1, :)
      factinlet = one
    case (kmax) 
      xf => x(:, :, kl, :)
      ss => sk(:, :, kl, :)
      factinlet = -one
    end select
! loop over the physical range of the subface to store the sum of
! the normals. note that jbeg, jend, ibeg, iend cannot be used
! here, because they may include the halo faces. instead the
! nodal range is used, which defines the original subface. the
! offset of +1 in the start index is there because you need
! the face id's.
    dir(1) = zero
    dir(2) = zero
    dir(3) = zero
    do j=bcdata(boco)%jnbeg+1,bcdata(boco)%jnend
      do i=bcdata(boco)%inbeg+1,bcdata(boco)%inend
        dir(1) = dir(1) + ss(i, j, 1)
        dir(2) = dir(2) + ss(i, j, 2)
        dir(3) = dir(3) + ss(i, j, 3)
      end do
    end do
! multiply by factinlet to make sure that the normal
! is inward pointing.
    dir(1) = dir(1)*factinlet
    dir(2) = dir(2)*factinlet
    dir(3) = dir(3)*factinlet
! determine three unit vectors, which define the local cartesian
! coordinate system of the rotation axis. first the axial
! direction. if the axis cannot be determined from rotation info,
! it is assumed to be the x-axis.
    axis = sections(sectionid)%rotaxis
    var = axis(1)**2 + axis(2)**2 + axis(3)**2
    if (var .lt. half) then
! no rotation axis specified. assume the x-axis
! and set the logical axassumed to .true.
      axis(1) = one
      axis(2) = zero
      axis(3) = zero
      axassumed = .true.
    end if
! the axial axis must be such that it points into the
! computational domain. if the dot product with dir is
! negative the direction of axis should be reversed.
    var = axis(1)*dir(1) + axis(2)*dir(2) + axis(3)*dir(3)
    if (var .lt. zero) then
      axis(1) = -axis(1)
      axis(2) = -axis(2)
      axis(3) = -axis(3)
    end if
    if (axis(2) .ge. 0.) then
      abs0 = axis(2)
    else
      abs0 = -axis(2)
    end if
! two unit vectors define the radial plane. these vectors are
! defined up to a constants. just pick a direction for the second
! and create a unit vector normal to axis.
    if (abs0 .lt. 0.707107_realtype) then
      radvec1(1) = zero
      radvec1(2) = one
      radvec1(3) = zero
    else
      radvec1(1) = zero
      radvec1(2) = zero
      radvec1(3) = one
    end if
    var = radvec1(1)*axis(1) + radvec1(2)*axis(2) + radvec1(3)*axis(3)
    radvec1(1) = radvec1(1) - var*axis(1)
    radvec1(2) = radvec1(2) - var*axis(2)
    radvec1(3) = radvec1(3) - var*axis(3)
    arg1 = radvec1(1)**2 + radvec1(2)**2 + radvec1(3)**2
    result1 = sqrt(arg1)
    var = one/result1
    radvec1(1) = radvec1(1)*var
    radvec1(2) = radvec1(2)*var
    radvec1(3) = radvec1(3)*var
! the second vector of the radial plane is obtained
! by taking the cross product of axis and radvec1.
    radvec2(1) = axis(2)*radvec1(3) - axis(3)*radvec1(2)
    radvec2(2) = axis(3)*radvec1(1) - axis(1)*radvec1(3)
    radvec2(3) = axis(1)*radvec1(2) - axis(2)*radvec1(1)
  end subroutine unitvectorscylsystem
!  differentiation of bcdataisothermalwall in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.tns_wall)
!   with respect to varying inputs: tref bcvararray
!   rw status of diff variables: tref:in *(*bcdata.tns_wall):out
!                bcvararray:in
!   plus diff mem management of: bcdata:in *bcdata.tns_wall:in
! ---------------------------------------------------------------
! routines that set the actual bcdata values from the cgns data set
! information.
! ---------------------------------------------------------------
  subroutine bcdataisothermalwall_d(boco, bcvararray, bcvararrayd, ibeg&
&   , iend, jbeg, jend)
!
!       bcdataisothermalwall tries to extract the wall temperature
!       for the currently active boundary face, which is an isothermal
!       viscous wall.
!
    use constants
    use cgnsnames
    use blockpointers, only : bcfaceid, bcdata, bcdatad, nbkglobal
    use utils_d, only : terminate, sitemperature
    use flowvarrefstate, only : tref, trefd
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararrayd
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: mult, trans
    character(len=maxstringlen) :: errormessage
    intrinsic trim
    integer :: ii1
! write an error message and terminate if it was not
! possible to determine the temperature.
    if (.not.bcvarpresent(1)) then
      write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdataisothermalwall', errormessage)
    end if
! convert to si-units and store the temperature in tns_wall.
    call sitemperature(temp(1), mult, trans)
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%tns_wall = 0.0_8
    end do
    do j=jbeg,jend
      do i=ibeg,iend
        bcdatad(boco)%tns_wall(i, j) = (mult*bcvararrayd(i, j, 1)*tref-(&
&         mult*bcvararray(i, j, 1)+trans)*trefd)/tref**2
        bcdata(boco)%tns_wall(i, j) = (mult*bcvararray(i, j, 1)+trans)/&
&         tref
      end do
    end do
 100 format('zone ',a,', boundary subface ',a, &
&          ': wall temperature not specified for isothermal wall')
  end subroutine bcdataisothermalwall_d
! ---------------------------------------------------------------
! routines that set the actual bcdata values from the cgns data set
! information.
! ---------------------------------------------------------------
  subroutine bcdataisothermalwall(boco, bcvararray, ibeg, iend, jbeg, &
&   jend)
!
!       bcdataisothermalwall tries to extract the wall temperature
!       for the currently active boundary face, which is an isothermal
!       viscous wall.
!
    use constants
    use cgnsnames
    use blockpointers, only : bcfaceid, bcdata, nbkglobal
    use utils_d, only : terminate, sitemperature
    use flowvarrefstate, only : tref
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: mult, trans
    character(len=maxstringlen) :: errormessage
    intrinsic trim
! write an error message and terminate if it was not
! possible to determine the temperature.
    if (.not.bcvarpresent(1)) then
      write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdataisothermalwall', errormessage)
    end if
! convert to si-units and store the temperature in tns_wall.
    call sitemperature(temp(1), mult, trans)
    do j=jbeg,jend
      do i=ibeg,iend
        bcdata(boco)%tns_wall(i, j) = (mult*bcvararray(i, j, 1)+trans)/&
&         tref
      end do
    end do
 100 format('zone ',a,', boundary subface ',a, &
&          ': wall temperature not specified for isothermal wall')
  end subroutine bcdataisothermalwall
  subroutine bcdatasubsonicinflow(boco, bcvararray, ibeg, iend, jbeg, &
&   jend, allturbpresent)
!
!       bcdatasubsonicinflow tries to extract the prescribed data
!       for the currently active boundary face, which is a subsonic
!       inflow. either total conditions and velocity direction or the
!       velocity and density can be prescribed. in the latter case the
!       mass flow is prescribed, which is okay as long as the flow is
!       not choked.
!
    use constants
    use cgnsnames
    use blockpointers, only : nbkglobal, sectionid, bcfaceid, bcdata
    use flowvarrefstate, only : tref, pref, href, rhoref, muref, nwt, &
&   winf
    use inputphysics, only : equations
    use utils_d, only : sidensity, sivelocity, sipressure, siangle, &
&   sitemperature, terminate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    logical, intent(inout) :: allturbpresent
!
!      local variables.
!
    integer :: ierr, nn
    logical :: ptpresent, ttpresent, rhotpresent
    logical :: axpresent, aypresent, azpresent
    logical :: xdirpresent, ydirpresent, zdirpresent
    logical :: rdirpresent, tdirpresent
    logical :: velxpresent, velypresent, velzpresent
    logical :: rhopresent, velrpresent, veltpresent
    logical :: totpresent, velpresent, dirpresent
    character(len=maxstringlen) :: errormessage
    intrinsic trim
! store the logicals, which indicate succes or failure
! a bit more readable.
    ptpresent = bcvarpresent(1)
    ttpresent = bcvarpresent(2)
    rhotpresent = bcvarpresent(3)
    axpresent = bcvarpresent(4)
    aypresent = bcvarpresent(5)
    azpresent = bcvarpresent(6)
    xdirpresent = bcvarpresent(7)
    ydirpresent = bcvarpresent(8)
    zdirpresent = bcvarpresent(9)
    rdirpresent = bcvarpresent(10)
    tdirpresent = bcvarpresent(11)
    rhopresent = bcvarpresent(12)
    velxpresent = bcvarpresent(13)
    velypresent = bcvarpresent(14)
    velzpresent = bcvarpresent(15)
    velrpresent = bcvarpresent(16)
    veltpresent = bcvarpresent(17)
! check if the total conditions are present.
    nn = 0
    if (ptpresent) nn = nn + 1
    if (ttpresent) nn = nn + 1
    if (rhotpresent) nn = nn + 1
    totpresent = .false.
    if (nn .ge. 2) totpresent = .true.
! check if a velocity direction is present.
    dirpresent = .false.
    if (xdirpresent .and. rdirpresent) dirpresent = .true.
    if ((axpresent .or. xdirpresent) .and. (aypresent .or. ydirpresent) &
&       .and. (azpresent .or. zdirpresent)) dirpresent = .true.
! check if a velocity vector is present.
    velpresent = .false.
    if (velxpresent .and. velrpresent) velpresent = .true.
    if (velxpresent .and. velypresent .and. velzpresent) velpresent = &
&       .true.
! determine the situation we have here.
    if (totpresent .and. dirpresent) then
! total conditions and velocity direction are prescribed.
! determine the values for the faces of the subface.
      call totalsubsonicinlet()
    else
! not enough data is prescribed. print an error message
! and exit.
      write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdatasubsonicinflow', errormessage)
    end if
! set the turbulence variables and check if all of them are
! prescribed. if not set allturbpresent to .false.
    allturbpresent = setbcvarturb(17_inttype, boco, bcvararray, ibeg, &
&     iend, jbeg, jend, bcdata(boco)%turbinlet)
 100 format('zone ',a,', boundary subface ',a, &
&          ': not enough data specified for subsonic inlet')

  contains
!=================================================================
!===============================================================
    subroutine totalsubsonicinlet()
!
!         totalsubsonicinlet converts the prescribed total
!         conditions and velocity direction into a useable format.
!
      use constants
      use communication, only : adflow_comm_world
      use inputphysics, only : rgasdim
      use section, only : sections
      implicit none
!
!        local variables.
!
      integer(kind=inttype) :: i, j, nn
      real(kind=realtype) :: rhot, mult, trans, hdim, tdim
      real(kind=realtype) :: ax, r1, r2, var, wax, wrad, wtheta
      real(kind=realtype), dimension(3) :: xc, dir
      integer :: ierr
      intrinsic max
      intrinsic sqrt
      intrinsic cos
      real(kind=realtype) :: result1
      real(kind=realtype) :: arg1
      real(kind=realtype) :: max2
      real(kind=realtype) :: max1
      real(kind=realtype) :: y1
! set the subsonic inlet treatment to totalconditions.
      bcdata(boco)%subsonicinlettreatment = totalconditions
! if the total pressure is present, convert it to si-units and
! store it.
      if (ptpresent) then
        call sipressure(mass(1), length(1), time(1), mult, trans)
        do j=jbeg,jend
          do i=ibeg,iend
            bcdata(boco)%ptinlet(i, j) = (mult*bcvararray(i, j, 1)+trans&
&             )/pref
          end do
        end do
      end if
! if the total temperature is present, convert it to si-units
! and store it.
      if (ttpresent) then
        call sitemperature(temp(2), mult, trans)
        do j=jbeg,jend
          do i=ibeg,iend
            bcdata(boco)%ttinlet(i, j) = (mult*bcvararray(i, j, 2)+trans&
&             )/tref
          end do
        end do
      end if
! check if the total density is present. if so, it may be used
! to determine the total temperature or pressure if one of these
! variables was not specified.
      if (rhotpresent) then
        call sidensity(mass(3), length(3), mult, trans)
        if (ptpresent .and. (.not.ttpresent)) then
! total pressure is present but total temperature is not.
! convert the total density to si-units and use the perfect
! gas law to obtain the total temperature.
          do j=jbeg,jend
            do i=ibeg,iend
              rhot = mult*bcvararray(i, j, 3) + trans
              bcdata(boco)%ttinlet(i, j) = bcdata(boco)%ptinlet(i, j)*&
&               pref/(rgasdim*rhot)/tref
            end do
          end do
        else if (ttpresent .and. (.not.ptpresent)) then
! total temperature is present but total pressure is not.
! convert the total density to si-units and use the perfect
! gas law to obtain the total pressure.
          do j=jbeg,jend
            do i=ibeg,iend
              rhot = mult*bcvararray(i, j, 3) + trans
              bcdata(boco)%ptinlet(i, j) = rgasdim*rhot*bcdata(boco)%&
&               ttinlet(i, j)*tref/pref
            end do
          end do
        end if
      end if
! determine the velocity direction. there are multiple
! possibilities to specify this direction.
      if (rdirpresent) then
! radial direction specified, i.e. a cylindrical coordinate
! system is used for the velocity direction.
! determine the unit vectors, which define the cylindrical
! coordinate system aligned with the rotation axis.
        call unitvectorscylsystem(boco)
! initialize wtheta to zero. this value will be used if no
! theta velocity component was specified.
        wtheta = zero
! loop over the faces of the subface.
        do j=jbeg,jend
          do i=ibeg,iend
! determine the coordinates of the face center relative to
! the rotation point of this section. normally this is an
! average of i-1, i, j-1, j, but due to the usage of the
! pointer xf and the fact that x originally starts at 0,
! an offset of 1 is introduced and thus the average should
! be taken of i, i+1, j and j+1.
            xc(1) = fourth*(xf(i, j, 1)+xf(i+1, j, 1)+xf(i, j+1, 1)+xf(i&
&             +1, j+1, 1)) - sections(sectionid)%rotcenter(1)
            xc(2) = fourth*(xf(i, j, 2)+xf(i+1, j, 2)+xf(i, j+1, 2)+xf(i&
&             +1, j+1, 2)) - sections(sectionid)%rotcenter(2)
            xc(3) = fourth*(xf(i, j, 3)+xf(i+1, j, 3)+xf(i, j+1, 3)+xf(i&
&             +1, j+1, 3)) - sections(sectionid)%rotcenter(3)
! determine the coordinates in the local cartesian frame,
! i.e. the frame determined by axis, radvec1 and radvec2.
            ax = xc(1)*axis(1) + xc(2)*axis(2) + xc(3)*axis(3)
            r1 = xc(1)*radvec1(1) + xc(2)*radvec1(2) + xc(3)*radvec1(3)
            r2 = xc(1)*radvec2(1) + xc(2)*radvec2(2) + xc(3)*radvec2(3)
! determine the weights of the unit vectors in the local
! cylindrical system.
            wax = bcvararray(i, j, 7)
            wrad = bcvararray(i, j, 10)
            if (tdirpresent) wtheta = bcvararray(i, j, 11)
            if (eps .lt. r1*r1 + r2*r2) then
              max1 = r1*r1 + r2*r2
            else
              max1 = eps
            end if
! determine the direction in the local cartesian frame,
! determined by axis, radvec1 and radvec2.
            result1 = sqrt(max1)
            var = one/result1
            dir(1) = wax
            dir(2) = var*(wrad*r1-wtheta*r2)
            dir(3) = var*(wrad*r2+wtheta*r1)
! transform this direction to the global cartesian frame.
            bcdata(boco)%flowxdirinlet(i, j) = dir(1)*axis(1) + dir(2)*&
&             radvec1(1) + dir(3)*radvec2(1)
            bcdata(boco)%flowydirinlet(i, j) = dir(1)*axis(2) + dir(2)*&
&             radvec1(2) + dir(3)*radvec2(2)
            bcdata(boco)%flowzdirinlet(i, j) = dir(1)*axis(3) + dir(2)*&
&             radvec1(3) + dir(3)*radvec2(3)
          end do
        end do
      else
! cartesian direction specified. either the angle or the
! direction should be present.
! x-direction.
        if (axpresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(4), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowxdirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 4) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowxdirinlet(i, j) = bcvararray(i, j, 7)
            end do
          end do
        end if
! y-direction.
        if (aypresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(5), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowydirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 5) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowydirinlet(i, j) = bcvararray(i, j, 8)
            end do
          end do
        end if
! z-direction.
        if (azpresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(6), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowzdirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 6) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowzdirinlet(i, j) = bcvararray(i, j, 9)
            end do
          end do
        end if
      end if
! loop over the faces of the subface to compute some
! additional info.
      do j=jbeg,jend
        do i=ibeg,iend
! compute the total enthalpy from the given
! total temperature.
          tdim = bcdata(boco)%ttinlet(i, j)*tref
          call computehtot(tdim, hdim)
          bcdata(boco)%htinlet(i, j) = hdim/href
! determine the unit vector of the flow direction.
          dir(1) = bcdata(boco)%flowxdirinlet(i, j)
          dir(2) = bcdata(boco)%flowydirinlet(i, j)
          dir(3) = bcdata(boco)%flowzdirinlet(i, j)
          arg1 = dir(1)**2 + dir(2)**2 + dir(3)**2
          y1 = sqrt(arg1)
          if (eps .lt. y1) then
            max2 = y1
          else
            max2 = eps
          end if
          var = one/max2
          bcdata(boco)%flowxdirinlet(i, j) = var*dir(1)
          bcdata(boco)%flowydirinlet(i, j) = var*dir(2)
          bcdata(boco)%flowzdirinlet(i, j) = var*dir(3)
        end do
      end do
! check if the prescribed direction is an inflow. no halo's
! should be included here and therefore the nodal range
! (with an offset) must be used.
      nn = 0
      do j=bcdata(boco)%jnbeg+1,bcdata(boco)%jnend
        do i=bcdata(boco)%inbeg+1,bcdata(boco)%inend
          var = bcdata(boco)%flowxdirinlet(i, j)*bcdata(boco)%norm(i, j&
&           , 1) + bcdata(boco)%flowydirinlet(i, j)*bcdata(boco)%norm(i&
&           , j, 2) + bcdata(boco)%flowzdirinlet(i, j)*bcdata(boco)%norm&
&           (i, j, 3)
          if (var .gt. zero) nn = nn + 1
        end do
      end do
    end subroutine totalsubsonicinlet
  end subroutine bcdatasubsonicinflow
!  differentiation of bcdatasubsonicinflow in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.ptinlet) *(*bcdata.ttinlet)
!                *(*bcdata.htinlet) *(*bcdata.turbinlet)
!   with respect to varying inputs: muref tref winf href pref rhoref
!                bcvararray
!   rw status of diff variables: muref:in tref:in winf:in href:in
!                pref:in rhoref:in *(*bcdata.ptinlet):out *(*bcdata.ttinlet):out
!                *(*bcdata.htinlet):out *(*bcdata.turbinlet):out
!                bcvararray:in
!   plus diff mem management of: bcdata:in *bcdata.ptinlet:in *bcdata.ttinlet:in
!                *bcdata.htinlet:in *bcdata.turbinlet:in-out
  subroutine bcdatasubsonicinflow_d(boco, bcvararray, bcvararrayd, ibeg&
&   , iend, jbeg, jend, allturbpresent)
!
!       bcdatasubsonicinflow tries to extract the prescribed data
!       for the currently active boundary face, which is a subsonic
!       inflow. either total conditions and velocity direction or the
!       velocity and density can be prescribed. in the latter case the
!       mass flow is prescribed, which is okay as long as the flow is
!       not choked.
!
    use constants
    use cgnsnames
    use blockpointers, only : nbkglobal, sectionid, bcfaceid, bcdata, &
&   bcdatad
    use flowvarrefstate, only : tref, trefd, pref, prefd, href, hrefd,&
&   rhoref, rhorefd, muref, murefd, nwt, winf, winfd
    use inputphysics, only : equations
    use utils_d, only : sidensity, sivelocity, sipressure, siangle, &
&   sitemperature, terminate
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararrayd
    logical, intent(inout) :: allturbpresent
!
!      local variables.
!
    integer :: ierr, nn
    logical :: ptpresent, ttpresent, rhotpresent
    logical :: axpresent, aypresent, azpresent
    logical :: xdirpresent, ydirpresent, zdirpresent
    logical :: rdirpresent, tdirpresent
    logical :: velxpresent, velypresent, velzpresent
    logical :: rhopresent, velrpresent, veltpresent
    logical :: totpresent, velpresent, dirpresent
    character(len=maxstringlen) :: errormessage
    intrinsic trim
    integer :: ii1
! store the logicals, which indicate succes or failure
! a bit more readable.
    ptpresent = bcvarpresent(1)
    ttpresent = bcvarpresent(2)
    rhotpresent = bcvarpresent(3)
    axpresent = bcvarpresent(4)
    aypresent = bcvarpresent(5)
    azpresent = bcvarpresent(6)
    xdirpresent = bcvarpresent(7)
    ydirpresent = bcvarpresent(8)
    zdirpresent = bcvarpresent(9)
    rdirpresent = bcvarpresent(10)
    tdirpresent = bcvarpresent(11)
    rhopresent = bcvarpresent(12)
    velxpresent = bcvarpresent(13)
    velypresent = bcvarpresent(14)
    velzpresent = bcvarpresent(15)
    velrpresent = bcvarpresent(16)
    veltpresent = bcvarpresent(17)
! check if the total conditions are present.
    nn = 0
    if (ptpresent) nn = nn + 1
    if (ttpresent) nn = nn + 1
    if (rhotpresent) nn = nn + 1
    totpresent = .false.
    if (nn .ge. 2) totpresent = .true.
! check if a velocity direction is present.
    dirpresent = .false.
    if (xdirpresent .and. rdirpresent) dirpresent = .true.
    if ((axpresent .or. xdirpresent) .and. (aypresent .or. ydirpresent) &
&       .and. (azpresent .or. zdirpresent)) dirpresent = .true.
! check if a velocity vector is present.
    velpresent = .false.
    if (velxpresent .and. velrpresent) velpresent = .true.
    if (velxpresent .and. velypresent .and. velzpresent) velpresent = &
&       .true.
! determine the situation we have here.
    if (totpresent .and. dirpresent) then
! total conditions and velocity direction are prescribed.
! determine the values for the faces of the subface.
      call totalsubsonicinlet_d()
    else
! not enough data is prescribed. print an error message
! and exit.
      write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdatasubsonicinflow', errormessage)
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%ptinlet = 0.0_8
      end do
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%ttinlet = 0.0_8
      end do
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%htinlet = 0.0_8
      end do
    end if
! set the turbulence variables and check if all of them are
! prescribed. if not set allturbpresent to .false.
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%turbinlet = 0.0_8
    end do
    call setbcvarturb_d(17_inttype, boco, bcvararray, bcvararrayd, ibeg&
&                 , iend, jbeg, jend, bcdata(boco)%turbinlet, bcdatad(&
&                 boco)%turbinlet, allturbpresent)
 100 format('zone ',a,', boundary subface ',a, &
&          ': not enough data specified for subsonic inlet')

  contains
!  differentiation of totalsubsonicinlet in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.ptinlet) *(*bcdata.ttinlet)
!                *(*bcdata.htinlet)
!   with respect to varying inputs: tref href pref bcvararray
!   plus diff mem management of: bcdata:in *bcdata.ptinlet:in *bcdata.ttinlet:in
!                *bcdata.htinlet:in
!=================================================================
!===============================================================
    subroutine totalsubsonicinlet_d()
!
!         totalsubsonicinlet converts the prescribed total
!         conditions and velocity direction into a useable format.
!
      use constants
      use communication, only : adflow_comm_world
      use inputphysics, only : rgasdim
      use section, only : sections
      use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
      implicit none
!
!        local variables.
!
      integer(kind=inttype) :: i, j, nn
      real(kind=realtype) :: rhot, mult, trans, hdim, tdim
      real(kind=realtype) :: rhotd, hdimd, tdimd
      real(kind=realtype) :: ax, r1, r2, var, wax, wrad, wtheta
      real(kind=realtype), dimension(3) :: xc, dir
      integer :: ierr
      intrinsic max
      intrinsic sqrt
      intrinsic cos
      real(kind=realtype) :: result1
      real(kind=realtype) :: arg1
      integer :: ii1
      real(kind=realtype) :: max2
      real(kind=realtype) :: max1
      real(kind=realtype) :: y1
! set the subsonic inlet treatment to totalconditions.
      bcdata(boco)%subsonicinlettreatment = totalconditions
! if the total pressure is present, convert it to si-units and
! store it.
      if (ptpresent) then
        call sipressure(mass(1), length(1), time(1), mult, trans)
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%ptinlet = 0.0_8
        end do
        do j=jbeg,jend
          do i=ibeg,iend
            bcdatad(boco)%ptinlet(i, j) = (mult*bcvararrayd(i, j, 1)*&
&             pref-(mult*bcvararray(i, j, 1)+trans)*prefd)/pref**2
            bcdata(boco)%ptinlet(i, j) = (mult*bcvararray(i, j, 1)+trans&
&             )/pref
          end do
        end do
      else
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%ptinlet = 0.0_8
        end do
      end if
! if the total temperature is present, convert it to si-units
! and store it.
      if (ttpresent) then
        call sitemperature(temp(2), mult, trans)
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%ttinlet = 0.0_8
        end do
        do j=jbeg,jend
          do i=ibeg,iend
            bcdatad(boco)%ttinlet(i, j) = (mult*bcvararrayd(i, j, 2)*&
&             tref-(mult*bcvararray(i, j, 2)+trans)*trefd)/tref**2
            bcdata(boco)%ttinlet(i, j) = (mult*bcvararray(i, j, 2)+trans&
&             )/tref
          end do
        end do
      else
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%ttinlet = 0.0_8
        end do
      end if
! check if the total density is present. if so, it may be used
! to determine the total temperature or pressure if one of these
! variables was not specified.
      if (rhotpresent) then
        call sidensity(mass(3), length(3), mult, trans)
        if (ptpresent .and. (.not.ttpresent)) then
! total pressure is present but total temperature is not.
! convert the total density to si-units and use the perfect
! gas law to obtain the total temperature.
          do j=jbeg,jend
            do i=ibeg,iend
              rhotd = mult*bcvararrayd(i, j, 3)
              rhot = mult*bcvararray(i, j, 3) + trans
              bcdatad(boco)%ttinlet(i, j) = (((bcdatad(boco)%ptinlet(i, &
&               j)*pref+bcdata(boco)%ptinlet(i, j)*prefd)*rgasdim*rhot-&
&               bcdata(boco)%ptinlet(i, j)*pref*rgasdim*rhotd)*tref/(&
&               rgasdim**2*rhot**2)-bcdata(boco)%ptinlet(i, j)*pref*&
&               trefd/(rgasdim*rhot))/tref**2
              bcdata(boco)%ttinlet(i, j) = bcdata(boco)%ptinlet(i, j)*&
&               pref/(rgasdim*rhot)/tref
            end do
          end do
        else if (ttpresent .and. (.not.ptpresent)) then
! total temperature is present but total pressure is not.
! convert the total density to si-units and use the perfect
! gas law to obtain the total pressure.
          do j=jbeg,jend
            do i=ibeg,iend
              rhotd = mult*bcvararrayd(i, j, 3)
              rhot = mult*bcvararray(i, j, 3) + trans
              bcdatad(boco)%ptinlet(i, j) = (rgasdim*((rhotd*tref+rhot*&
&               trefd)*bcdata(boco)%ttinlet(i, j)+rhot*tref*bcdatad(boco&
&               )%ttinlet(i, j))*pref-rgasdim*rhot*bcdata(boco)%ttinlet(&
&               i, j)*tref*prefd)/pref**2
              bcdata(boco)%ptinlet(i, j) = rgasdim*rhot*bcdata(boco)%&
&               ttinlet(i, j)*tref/pref
            end do
          end do
        end if
      end if
! determine the velocity direction. there are multiple
! possibilities to specify this direction.
      if (rdirpresent) then
! radial direction specified, i.e. a cylindrical coordinate
! system is used for the velocity direction.
! determine the unit vectors, which define the cylindrical
! coordinate system aligned with the rotation axis.
        call unitvectorscylsystem(boco)
! initialize wtheta to zero. this value will be used if no
! theta velocity component was specified.
        wtheta = zero
! loop over the faces of the subface.
        do j=jbeg,jend
          do i=ibeg,iend
! determine the coordinates of the face center relative to
! the rotation point of this section. normally this is an
! average of i-1, i, j-1, j, but due to the usage of the
! pointer xf and the fact that x originally starts at 0,
! an offset of 1 is introduced and thus the average should
! be taken of i, i+1, j and j+1.
            xc(1) = fourth*(xf(i, j, 1)+xf(i+1, j, 1)+xf(i, j+1, 1)+xf(i&
&             +1, j+1, 1)) - sections(sectionid)%rotcenter(1)
            xc(2) = fourth*(xf(i, j, 2)+xf(i+1, j, 2)+xf(i, j+1, 2)+xf(i&
&             +1, j+1, 2)) - sections(sectionid)%rotcenter(2)
            xc(3) = fourth*(xf(i, j, 3)+xf(i+1, j, 3)+xf(i, j+1, 3)+xf(i&
&             +1, j+1, 3)) - sections(sectionid)%rotcenter(3)
! determine the coordinates in the local cartesian frame,
! i.e. the frame determined by axis, radvec1 and radvec2.
            ax = xc(1)*axis(1) + xc(2)*axis(2) + xc(3)*axis(3)
            r1 = xc(1)*radvec1(1) + xc(2)*radvec1(2) + xc(3)*radvec1(3)
            r2 = xc(1)*radvec2(1) + xc(2)*radvec2(2) + xc(3)*radvec2(3)
! determine the weights of the unit vectors in the local
! cylindrical system.
            wax = bcvararray(i, j, 7)
            wrad = bcvararray(i, j, 10)
            if (tdirpresent) wtheta = bcvararray(i, j, 11)
            if (eps .lt. r1*r1 + r2*r2) then
              max1 = r1*r1 + r2*r2
            else
              max1 = eps
            end if
! determine the direction in the local cartesian frame,
! determined by axis, radvec1 and radvec2.
            result1 = sqrt(max1)
            var = one/result1
            dir(1) = wax
            dir(2) = var*(wrad*r1-wtheta*r2)
            dir(3) = var*(wrad*r2+wtheta*r1)
! transform this direction to the global cartesian frame.
            bcdata(boco)%flowxdirinlet(i, j) = dir(1)*axis(1) + dir(2)*&
&             radvec1(1) + dir(3)*radvec2(1)
            bcdata(boco)%flowydirinlet(i, j) = dir(1)*axis(2) + dir(2)*&
&             radvec1(2) + dir(3)*radvec2(2)
            bcdata(boco)%flowzdirinlet(i, j) = dir(1)*axis(3) + dir(2)*&
&             radvec1(3) + dir(3)*radvec2(3)
          end do
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%htinlet = 0.0_8
        end do
        hdimd = 0.0_8
      else
! cartesian direction specified. either the angle or the
! direction should be present.
! x-direction.
        if (axpresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(4), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowxdirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 4) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowxdirinlet(i, j) = bcvararray(i, j, 7)
            end do
          end do
        end if
! y-direction.
        if (aypresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(5), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowydirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 5) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowydirinlet(i, j) = bcvararray(i, j, 8)
            end do
          end do
        end if
! z-direction.
        if (azpresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(6), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowzdirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 6) + trans)
            end do
          end do
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%htinlet = 0.0_8
          end do
          hdimd = 0.0_8
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowzdirinlet(i, j) = bcvararray(i, j, 9)
            end do
          end do
          do ii1=1,isize1ofdrfbcdata
            bcdatad(ii1)%htinlet = 0.0_8
          end do
          hdimd = 0.0_8
        end if
      end if
! loop over the faces of the subface to compute some
! additional info.
      do j=jbeg,jend
        do i=ibeg,iend
! compute the total enthalpy from the given
! total temperature.
          tdimd = bcdatad(boco)%ttinlet(i, j)*tref + bcdata(boco)%&
&           ttinlet(i, j)*trefd
          tdim = bcdata(boco)%ttinlet(i, j)*tref
          call computehtot_d(tdim, tdimd, hdim, hdimd)
          bcdatad(boco)%htinlet(i, j) = (hdimd*href-hdim*hrefd)/href**2
          bcdata(boco)%htinlet(i, j) = hdim/href
! determine the unit vector of the flow direction.
          dir(1) = bcdata(boco)%flowxdirinlet(i, j)
          dir(2) = bcdata(boco)%flowydirinlet(i, j)
          dir(3) = bcdata(boco)%flowzdirinlet(i, j)
          arg1 = dir(1)**2 + dir(2)**2 + dir(3)**2
          y1 = sqrt(arg1)
          if (eps .lt. y1) then
            max2 = y1
          else
            max2 = eps
          end if
          var = one/max2
          bcdata(boco)%flowxdirinlet(i, j) = var*dir(1)
          bcdata(boco)%flowydirinlet(i, j) = var*dir(2)
          bcdata(boco)%flowzdirinlet(i, j) = var*dir(3)
        end do
      end do
! check if the prescribed direction is an inflow. no halo's
! should be included here and therefore the nodal range
! (with an offset) must be used.
      nn = 0
      do j=bcdata(boco)%jnbeg+1,bcdata(boco)%jnend
        do i=bcdata(boco)%inbeg+1,bcdata(boco)%inend
          var = bcdata(boco)%flowxdirinlet(i, j)*bcdata(boco)%norm(i, j&
&           , 1) + bcdata(boco)%flowydirinlet(i, j)*bcdata(boco)%norm(i&
&           , j, 2) + bcdata(boco)%flowzdirinlet(i, j)*bcdata(boco)%norm&
&           (i, j, 3)
          if (var .gt. zero) nn = nn + 1
        end do
      end do
    end subroutine totalsubsonicinlet_d
!=================================================================
!===============================================================
    subroutine totalsubsonicinlet()
!
!         totalsubsonicinlet converts the prescribed total
!         conditions and velocity direction into a useable format.
!
      use constants
      use communication, only : adflow_comm_world
      use inputphysics, only : rgasdim
      use section, only : sections
      implicit none
!
!        local variables.
!
      integer(kind=inttype) :: i, j, nn
      real(kind=realtype) :: rhot, mult, trans, hdim, tdim
      real(kind=realtype) :: ax, r1, r2, var, wax, wrad, wtheta
      real(kind=realtype), dimension(3) :: xc, dir
      integer :: ierr
      intrinsic max
      intrinsic sqrt
      intrinsic cos
      real(kind=realtype) :: result1
      real(kind=realtype) :: arg1
      real(kind=realtype) :: max2
      real(kind=realtype) :: max1
      real(kind=realtype) :: y1
! set the subsonic inlet treatment to totalconditions.
      bcdata(boco)%subsonicinlettreatment = totalconditions
! if the total pressure is present, convert it to si-units and
! store it.
      if (ptpresent) then
        call sipressure(mass(1), length(1), time(1), mult, trans)
        do j=jbeg,jend
          do i=ibeg,iend
            bcdata(boco)%ptinlet(i, j) = (mult*bcvararray(i, j, 1)+trans&
&             )/pref
          end do
        end do
      end if
! if the total temperature is present, convert it to si-units
! and store it.
      if (ttpresent) then
        call sitemperature(temp(2), mult, trans)
        do j=jbeg,jend
          do i=ibeg,iend
            bcdata(boco)%ttinlet(i, j) = (mult*bcvararray(i, j, 2)+trans&
&             )/tref
          end do
        end do
      end if
! check if the total density is present. if so, it may be used
! to determine the total temperature or pressure if one of these
! variables was not specified.
      if (rhotpresent) then
        call sidensity(mass(3), length(3), mult, trans)
        if (ptpresent .and. (.not.ttpresent)) then
! total pressure is present but total temperature is not.
! convert the total density to si-units and use the perfect
! gas law to obtain the total temperature.
          do j=jbeg,jend
            do i=ibeg,iend
              rhot = mult*bcvararray(i, j, 3) + trans
              bcdata(boco)%ttinlet(i, j) = bcdata(boco)%ptinlet(i, j)*&
&               pref/(rgasdim*rhot)/tref
            end do
          end do
        else if (ttpresent .and. (.not.ptpresent)) then
! total temperature is present but total pressure is not.
! convert the total density to si-units and use the perfect
! gas law to obtain the total pressure.
          do j=jbeg,jend
            do i=ibeg,iend
              rhot = mult*bcvararray(i, j, 3) + trans
              bcdata(boco)%ptinlet(i, j) = rgasdim*rhot*bcdata(boco)%&
&               ttinlet(i, j)*tref/pref
            end do
          end do
        end if
      end if
! determine the velocity direction. there are multiple
! possibilities to specify this direction.
      if (rdirpresent) then
! radial direction specified, i.e. a cylindrical coordinate
! system is used for the velocity direction.
! determine the unit vectors, which define the cylindrical
! coordinate system aligned with the rotation axis.
        call unitvectorscylsystem(boco)
! initialize wtheta to zero. this value will be used if no
! theta velocity component was specified.
        wtheta = zero
! loop over the faces of the subface.
        do j=jbeg,jend
          do i=ibeg,iend
! determine the coordinates of the face center relative to
! the rotation point of this section. normally this is an
! average of i-1, i, j-1, j, but due to the usage of the
! pointer xf and the fact that x originally starts at 0,
! an offset of 1 is introduced and thus the average should
! be taken of i, i+1, j and j+1.
            xc(1) = fourth*(xf(i, j, 1)+xf(i+1, j, 1)+xf(i, j+1, 1)+xf(i&
&             +1, j+1, 1)) - sections(sectionid)%rotcenter(1)
            xc(2) = fourth*(xf(i, j, 2)+xf(i+1, j, 2)+xf(i, j+1, 2)+xf(i&
&             +1, j+1, 2)) - sections(sectionid)%rotcenter(2)
            xc(3) = fourth*(xf(i, j, 3)+xf(i+1, j, 3)+xf(i, j+1, 3)+xf(i&
&             +1, j+1, 3)) - sections(sectionid)%rotcenter(3)
! determine the coordinates in the local cartesian frame,
! i.e. the frame determined by axis, radvec1 and radvec2.
            ax = xc(1)*axis(1) + xc(2)*axis(2) + xc(3)*axis(3)
            r1 = xc(1)*radvec1(1) + xc(2)*radvec1(2) + xc(3)*radvec1(3)
            r2 = xc(1)*radvec2(1) + xc(2)*radvec2(2) + xc(3)*radvec2(3)
! determine the weights of the unit vectors in the local
! cylindrical system.
            wax = bcvararray(i, j, 7)
            wrad = bcvararray(i, j, 10)
            if (tdirpresent) wtheta = bcvararray(i, j, 11)
            if (eps .lt. r1*r1 + r2*r2) then
              max1 = r1*r1 + r2*r2
            else
              max1 = eps
            end if
! determine the direction in the local cartesian frame,
! determined by axis, radvec1 and radvec2.
            result1 = sqrt(max1)
            var = one/result1
            dir(1) = wax
            dir(2) = var*(wrad*r1-wtheta*r2)
            dir(3) = var*(wrad*r2+wtheta*r1)
! transform this direction to the global cartesian frame.
            bcdata(boco)%flowxdirinlet(i, j) = dir(1)*axis(1) + dir(2)*&
&             radvec1(1) + dir(3)*radvec2(1)
            bcdata(boco)%flowydirinlet(i, j) = dir(1)*axis(2) + dir(2)*&
&             radvec1(2) + dir(3)*radvec2(2)
            bcdata(boco)%flowzdirinlet(i, j) = dir(1)*axis(3) + dir(2)*&
&             radvec1(3) + dir(3)*radvec2(3)
          end do
        end do
      else
! cartesian direction specified. either the angle or the
! direction should be present.
! x-direction.
        if (axpresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(4), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowxdirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 4) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowxdirinlet(i, j) = bcvararray(i, j, 7)
            end do
          end do
        end if
! y-direction.
        if (aypresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(5), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowydirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 5) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowydirinlet(i, j) = bcvararray(i, j, 8)
            end do
          end do
        end if
! z-direction.
        if (azpresent) then
! angle specified. convert it to si-units and determine
! the corresponding direction.
          call siangle(angle(6), mult, trans)
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowzdirinlet(i, j) = cos(mult*bcvararray(i, &
&               j, 6) + trans)
            end do
          end do
        else
! direction specified. simply copy it.
          do j=jbeg,jend
            do i=ibeg,iend
              bcdata(boco)%flowzdirinlet(i, j) = bcvararray(i, j, 9)
            end do
          end do
        end if
      end if
! loop over the faces of the subface to compute some
! additional info.
      do j=jbeg,jend
        do i=ibeg,iend
! compute the total enthalpy from the given
! total temperature.
          tdim = bcdata(boco)%ttinlet(i, j)*tref
          call computehtot(tdim, hdim)
          bcdata(boco)%htinlet(i, j) = hdim/href
! determine the unit vector of the flow direction.
          dir(1) = bcdata(boco)%flowxdirinlet(i, j)
          dir(2) = bcdata(boco)%flowydirinlet(i, j)
          dir(3) = bcdata(boco)%flowzdirinlet(i, j)
          arg1 = dir(1)**2 + dir(2)**2 + dir(3)**2
          y1 = sqrt(arg1)
          if (eps .lt. y1) then
            max2 = y1
          else
            max2 = eps
          end if
          var = one/max2
          bcdata(boco)%flowxdirinlet(i, j) = var*dir(1)
          bcdata(boco)%flowydirinlet(i, j) = var*dir(2)
          bcdata(boco)%flowzdirinlet(i, j) = var*dir(3)
        end do
      end do
! check if the prescribed direction is an inflow. no halo's
! should be included here and therefore the nodal range
! (with an offset) must be used.
      nn = 0
      do j=bcdata(boco)%jnbeg+1,bcdata(boco)%jnend
        do i=bcdata(boco)%inbeg+1,bcdata(boco)%inend
          var = bcdata(boco)%flowxdirinlet(i, j)*bcdata(boco)%norm(i, j&
&           , 1) + bcdata(boco)%flowydirinlet(i, j)*bcdata(boco)%norm(i&
&           , j, 2) + bcdata(boco)%flowzdirinlet(i, j)*bcdata(boco)%norm&
&           (i, j, 3)
          if (var .gt. zero) nn = nn + 1
        end do
      end do
    end subroutine totalsubsonicinlet
  end subroutine bcdatasubsonicinflow_d
!  differentiation of bcdatasubsonicoutflow in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.ps)
!   with respect to varying inputs: pref bcvararray
!   rw status of diff variables: pref:in *(*bcdata.ps):out bcvararray:in
!   plus diff mem management of: bcdata:in *bcdata.ps:in
  subroutine bcdatasubsonicoutflow_d(boco, bcvararray, bcvararrayd, ibeg&
&   , iend, jbeg, jend)
!
!       bcdatasubsonicoutflow tries to extract the static pressure
!       for the currently active boundary face, which is a subsonic
!       outflow boundary.
!
    use constants
    use cgnsnames
    use blockpointers, only : bcdata, bcdatad, nbkglobal, bcfaceid
    use utils_d, only : terminate, sipressure
    use flowvarrefstate, only : pref, prefd
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararrayd
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: mult, trans
    character(len=maxstringlen) :: errormessage
    intrinsic trim
    integer :: ii1
! write an error message and terminate if it was not
! possible to determine the static pressure.
    if (.not.bcvarpresent(1)) then
      write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdatasubsonicoutflow', errormessage)
    end if
! convert to si-units and store the pressure in ps.
    call sipressure(mass(1), length(1), time(1), mult, trans)
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%ps = 0.0_8
    end do
    do j=jbeg,jend
      do i=ibeg,iend
        bcdatad(boco)%ps(i, j) = (mult*bcvararrayd(i, j, 1)*pref-(mult*&
&         bcvararray(i, j, 1)+trans)*prefd)/pref**2
        bcdata(boco)%ps(i, j) = (mult*bcvararray(i, j, 1)+trans)/pref
      end do
    end do
 100 format('zone ',a,', boundary subface ',a, &
&          ': static pressure not specified for subsonic outlet')
  end subroutine bcdatasubsonicoutflow_d
  subroutine bcdatasubsonicoutflow(boco, bcvararray, ibeg, iend, jbeg, &
&   jend)
!
!       bcdatasubsonicoutflow tries to extract the static pressure
!       for the currently active boundary face, which is a subsonic
!       outflow boundary.
!
    use constants
    use cgnsnames
    use blockpointers, only : bcdata, nbkglobal, bcfaceid
    use utils_d, only : terminate, sipressure
    use flowvarrefstate, only : pref
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: mult, trans
    character(len=maxstringlen) :: errormessage
    intrinsic trim
! write an error message and terminate if it was not
! possible to determine the static pressure.
    if (.not.bcvarpresent(1)) then
      write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdatasubsonicoutflow', errormessage)
    end if
! convert to si-units and store the pressure in ps.
    call sipressure(mass(1), length(1), time(1), mult, trans)
    do j=jbeg,jend
      do i=ibeg,iend
        bcdata(boco)%ps(i, j) = (mult*bcvararray(i, j, 1)+trans)/pref
      end do
    end do
 100 format('zone ',a,', boundary subface ',a, &
&          ': static pressure not specified for subsonic outlet')
  end subroutine bcdatasubsonicoutflow
  subroutine bcdatasupersonicinflow(boco, bcvararray, ibeg, iend, jbeg, &
&   jend, allflowpresent, allturbpresent)
!
!       bcdatasupersonicinflow tries to extract the primitive state
!       vector for the currently active boundary face, which is a
!       supersonic inflow.
!
    use constants
    use cgnsnames
    use blockpointers, only : bcdata, nbkglobal, bcfaceid, sectionid
    use flowvarrefstate, only : nwt, pinfcorr, winf, uref, rhoref, &
&   pref, muref
    use inputphysics, only : equations, flowtype, veldirfreestream
    use utils_d, only : sidensity, sipressure, sivelocity, sitemperature&
&   , terminate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    logical, intent(inout) :: allflowpresent
    logical, intent(inout) :: allturbpresent
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: i, j, nn
    real(kind=realtype) :: var
    character(len=maxstringlen) :: errormessage
    logical :: rhopresent, ppresent, velpresent
    logical :: velxpresent, velypresent, velzpresent
    logical :: velrpresent, veltpresent
    intrinsic trim
! store the logicals, which indicate success or failure
! a bit more readable.
    rhopresent = bcvarpresent(1)
    ppresent = bcvarpresent(2)
    velxpresent = bcvarpresent(3)
    velypresent = bcvarpresent(4)
    velzpresent = bcvarpresent(5)
    velrpresent = bcvarpresent(6)
    veltpresent = bcvarpresent(7)
! check if a velocity vector is present.
    velpresent = .false.
    if (velxpresent .and. velrpresent) velpresent = .true.
    if (velxpresent .and. velypresent .and. velzpresent) velpresent = &
&       .true.
! check if rho, p and the velocity vector are present.
    if (rhopresent .and. ppresent .and. velpresent) then
! all the variables needed are prescribed. set them.
      call prescribedsupersonicinlet()
    else
! not all variables are present. check what type of flow
! is to be solved.
      select case  (flowtype) 
      case (internalflow) 
! internal flow. data at the inlet must be specified;
! no free stream data can be taken.
        write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), &
&       trim(cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
        call terminate('bcdatasupersonicinflow', errormessage)
      case (externalflow) 
!=============================================================
! external flow. free stream data is used.
        do j=jbeg,jend
          do i=ibeg,iend
            bcdata(boco)%rho(i, j) = winf(irho)
            bcdata(boco)%velx(i, j) = winf(ivx)
            bcdata(boco)%vely(i, j) = winf(ivy)
            bcdata(boco)%velz(i, j) = winf(ivz)
            bcdata(boco)%ps(i, j) = pinfcorr
          end do
        end do
! set the turbulence values
        allturbpresent = setbcvarturb(7_inttype, boco, bcvararray, ibeg&
&         , iend, jbeg, jend, bcdata(boco)%turbinlet)
! set allflowpresent to .false.
        allflowpresent = .false.
      end select
    end if
! check if the prescribed velocity is an inflow. no halo's
! should be included here and therefore the nodal range
! (with an offset) must be used.
    nn = 0
    do j=bcdata(boco)%jnbeg+1,bcdata(boco)%jnend
      do i=bcdata(boco)%inbeg+1,bcdata(boco)%inend
        var = bcdata(boco)%velx(i, j)*bcdata(boco)%norm(i, j, 1) + &
&         bcdata(boco)%vely(i, j)*bcdata(boco)%norm(i, j, 2) + bcdata(&
&         boco)%velz(i, j)*bcdata(boco)%norm(i, j, 3)
        if (var .gt. zero) nn = nn + 1
      end do
    end do
    if (nn .gt. 0) then
      write(errormessage, 102) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdatasupersonicinflow', errormessage)
    end if
 100 format('zone ',a,', boundary subface ',a, &
&          ': not enough data specified for supersonic inlet')
 102 format('zone ',a,', supersonic inlet boundary subface ',a, &
&          ': velocity points out of the domain for some faces.')

  contains
    subroutine prescribedsupersonicinlet()
!
!         prescribedsupersonicinlet sets the variables for this
!         supersonic inlet to prescribed values.
!
      use section, only : sections
      implicit none
!
!        local variables.
!
      integer(kind=inttype) :: i, j
      real(kind=realtype) :: mult, trans
      real(kind=realtype) :: ax, r1, r2, var, vax, vrad, vtheta
      real(kind=realtype), dimension(3) :: xc, vloc
      real(kind=realtype), dimension(3) :: multvel, transvel
      intrinsic max
      intrinsic sqrt
      real(kind=realtype) :: result1
      real(kind=realtype) :: max1
! set the density. take the conversion factor to si-units
! into account.
      call sidensity(mass(1), length(1), mult, trans)
      do j=jbeg,jend
        do i=ibeg,iend
          bcdata(boco)%rho(i, j) = (mult*bcvararray(i, j, 1)+trans)/&
&           rhoref
        end do
      end do
! set the pressure. take the conversion factor to si-units
! into account.
      call sipressure(mass(1), length(2), time(2), mult, trans)
      do j=jbeg,jend
        do i=ibeg,iend
          bcdata(boco)%ps(i, j) = (mult*bcvararray(i, j, 2)+trans)/pref
        end do
      end do
! check the situation we are having here for the velocity.
      if (velrpresent) then
! radial velocity component prescribed. this must be converted
! to cartesian components.
! determine the unit vectors, which define the cylindrical
! coordinate system aligned with the rotation axis.
        call unitvectorscylsystem(boco)
! determine the conversion factor to si-units for the three
! components. note that a test must be made whether the theta
! component is present.
        call sivelocity(length(3), time(3), multvel(1), transvel(1))
        call sivelocity(length(6), time(6), multvel(2), transvel(2))
        if (veltpresent) call sivelocity(length(7), time(7), multvel(3)&
&                                  , transvel(3))
! initialize vtheta to zero. this value will be used
! if no theta velocity component was specified.
        vtheta = zero
! loop over the faces of the subface.
        do j=jbeg,jend
          do i=ibeg,iend
! determine the coordinates of the face center relative to
! the rotation point of this section. normally this is an
! average of i-1, i, j-1, j, but due to the usage of the
! pointer xf and the fact that x originally starts at 0,
! an offset of 1 is introduced and thus the average should
! be taken of i, i+1, j and j+1.
            xc(1) = fourth*(xf(i, j, 1)+xf(i+1, j, 1)+xf(i, j+1, 1)+xf(i&
&             +1, j+1, 1)) - sections(sectionid)%rotcenter(1)
            xc(2) = fourth*(xf(i, j, 2)+xf(i+1, j, 2)+xf(i, j+1, 2)+xf(i&
&             +1, j+1, 2)) - sections(sectionid)%rotcenter(2)
            xc(3) = fourth*(xf(i, j, 3)+xf(i+1, j, 3)+xf(i, j+1, 3)+xf(i&
&             +1, j+1, 3)) - sections(sectionid)%rotcenter(3)
! determine the coordinates in the local cartesian frame,
! i.e. the frame determined by axis, radvec1 and radvec2.
            ax = xc(1)*axis(1) + xc(2)*axis(2) + xc(3)*axis(3)
            r1 = xc(1)*radvec1(1) + xc(2)*radvec1(2) + xc(3)*radvec1(3)
            r2 = xc(1)*radvec2(1) + xc(2)*radvec2(2) + xc(3)*radvec2(3)
! determine the velocity components in the local
! cylindrical system. take the conversion to si units
! into account.
            vax = multvel(1)*bcvararray(i, j, 3) + transvel(1)
            vrad = multvel(2)*bcvararray(i, j, 6) + transvel(2)
            if (veltpresent) vtheta = multvel(3)*bcvararray(i, j, 7) + &
&               transvel(3)
            if (eps .lt. r1*r1 + r2*r2) then
              max1 = r1*r1 + r2*r2
            else
              max1 = eps
            end if
! determine the velocities in the local cartesian
! frame determined by axis, radvec1 and radvec2.
            result1 = sqrt(max1)
            var = one/result1
            vloc(1) = vax
            vloc(2) = var*(vrad*r1-vtheta*r2)
            vloc(3) = var*(vrad*r2+vtheta*r1)
! transform vloc to the global cartesian frame and
! store the values.
            bcdata(boco)%velx(i, j) = (vloc(1)*axis(1)+vloc(2)*radvec1(1&
&             )+vloc(3)*radvec2(1))/uref
            bcdata(boco)%vely(i, j) = (vloc(1)*axis(2)+vloc(2)*radvec1(2&
&             )+vloc(3)*radvec2(2))/uref
            bcdata(boco)%velz(i, j) = (vloc(1)*axis(3)+vloc(2)*radvec1(3&
&             )+vloc(3)*radvec2(3))/uref
          end do
        end do
      else
! cartesian components prescribed.
! determine the conversion factor to si-units for the three
! components.
        call sivelocity(length(3), time(3), multvel(1), transvel(1))
        call sivelocity(length(4), time(4), multvel(2), transvel(2))
        call sivelocity(length(5), time(5), multvel(3), transvel(3))
! set the velocities.
        do j=jbeg,jend
          do i=ibeg,iend
            bcdata(boco)%velx(i, j) = (multvel(1)*bcvararray(i, j, 3)+&
&             transvel(1))/uref
            bcdata(boco)%vely(i, j) = (multvel(2)*bcvararray(i, j, 4)+&
&             transvel(2))/uref
            bcdata(boco)%velz(i, j) = (multvel(3)*bcvararray(i, j, 5)+&
&             transvel(3))/uref
          end do
        end do
      end if
! set the turbulence variables and check if all of them are
! prescribed. if not set allturbpresent to .false.
      allturbpresent = setbcvarturb(7_inttype, boco, bcvararray, ibeg, &
&       iend, jbeg, jend, bcdata(boco)%turbinlet)
    end subroutine prescribedsupersonicinlet
  end subroutine bcdatasupersonicinflow
!  differentiation of bcdatasupersonicinflow in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.turbinlet) *(*bcdata.rho)
!                *(*bcdata.velx) *(*bcdata.vely) *(*bcdata.velz)
!                *(*bcdata.ps)
!   with respect to varying inputs: muref uref winf pinfcorr pref
!                rhoref bcvararray
!   rw status of diff variables: muref:in uref:in winf:in pinfcorr:in
!                pref:in rhoref:in *(*bcdata.turbinlet):out *(*bcdata.rho):out
!                *(*bcdata.velx):out *(*bcdata.vely):out *(*bcdata.velz):out
!                *(*bcdata.ps):out bcvararray:in
!   plus diff mem management of: bcdata:in *bcdata.turbinlet:in-out
!                *bcdata.rho:in *bcdata.velx:in *bcdata.vely:in
!                *bcdata.velz:in *bcdata.ps:in
  subroutine bcdatasupersonicinflow_d(boco, bcvararray, bcvararrayd, &
&   ibeg, iend, jbeg, jend, allflowpresent, allturbpresent)
!
!       bcdatasupersonicinflow tries to extract the primitive state
!       vector for the currently active boundary face, which is a
!       supersonic inflow.
!
    use constants
    use cgnsnames
    use blockpointers, only : bcdata, bcdatad, nbkglobal, bcfaceid, &
&   sectionid
    use flowvarrefstate, only : nwt, pinfcorr, pinfcorrd, winf, winfd,&
&   uref, urefd, rhoref, rhorefd, pref, prefd, muref, murefd
    use inputphysics, only : equations, flowtype, veldirfreestream, &
&   veldirfreestreamd
    use utils_d, only : sidensity, sipressure, sivelocity, sitemperature&
&   , terminate
    use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: boco
    integer(kind=inttype) :: ibeg, iend, jbeg, jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararrayd
    logical, intent(inout) :: allflowpresent
    logical, intent(inout) :: allturbpresent
!
!      local variables.
!
    integer :: ierr
    integer(kind=inttype) :: i, j, nn
    real(kind=realtype) :: var
    character(len=maxstringlen) :: errormessage
    logical :: rhopresent, ppresent, velpresent
    logical :: velxpresent, velypresent, velzpresent
    logical :: velrpresent, veltpresent
    intrinsic trim
    integer :: ii1
! store the logicals, which indicate success or failure
! a bit more readable.
    rhopresent = bcvarpresent(1)
    ppresent = bcvarpresent(2)
    velxpresent = bcvarpresent(3)
    velypresent = bcvarpresent(4)
    velzpresent = bcvarpresent(5)
    velrpresent = bcvarpresent(6)
    veltpresent = bcvarpresent(7)
! check if a velocity vector is present.
    velpresent = .false.
    if (velxpresent .and. velrpresent) velpresent = .true.
    if (velxpresent .and. velypresent .and. velzpresent) velpresent = &
&       .true.
! check if rho, p and the velocity vector are present.
    if (rhopresent .and. ppresent .and. velpresent) then
! all the variables needed are prescribed. set them.
      call prescribedsupersonicinlet_d()
    else
! not all variables are present. check what type of flow
! is to be solved.
      select case  (flowtype) 
      case (internalflow) 
! internal flow. data at the inlet must be specified;
! no free stream data can be taken.
        write(errormessage, 100) trim(cgnsdoms(nbkglobal)%zonename), &
&       trim(cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
        call terminate('bcdatasupersonicinflow', errormessage)
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%turbinlet = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%rho = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velx = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%vely = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velz = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%ps = 0.0_8
        end do
      case (externalflow) 
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%rho = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velx = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%vely = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velz = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%ps = 0.0_8
        end do
!=============================================================
! external flow. free stream data is used.
        do j=jbeg,jend
          do i=ibeg,iend
            bcdatad(boco)%rho(i, j) = winfd(irho)
            bcdata(boco)%rho(i, j) = winf(irho)
            bcdatad(boco)%velx(i, j) = winfd(ivx)
            bcdata(boco)%velx(i, j) = winf(ivx)
            bcdatad(boco)%vely(i, j) = winfd(ivy)
            bcdata(boco)%vely(i, j) = winf(ivy)
            bcdatad(boco)%velz(i, j) = winfd(ivz)
            bcdata(boco)%velz(i, j) = winf(ivz)
            bcdatad(boco)%ps(i, j) = pinfcorrd
            bcdata(boco)%ps(i, j) = pinfcorr
          end do
        end do
! set the turbulence values
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%turbinlet = 0.0_8
        end do
        call setbcvarturb_d(7_inttype, boco, bcvararray, bcvararrayd, &
&                     ibeg, iend, jbeg, jend, bcdata(boco)%turbinlet, &
&                     bcdatad(boco)%turbinlet, allturbpresent)
! set allflowpresent to .false.
        allflowpresent = .false.
      case default
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%turbinlet = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%rho = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velx = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%vely = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velz = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%ps = 0.0_8
        end do
      end select
    end if
! check if the prescribed velocity is an inflow. no halo's
! should be included here and therefore the nodal range
! (with an offset) must be used.
    nn = 0
    do j=bcdata(boco)%jnbeg+1,bcdata(boco)%jnend
      do i=bcdata(boco)%inbeg+1,bcdata(boco)%inend
        var = bcdata(boco)%velx(i, j)*bcdata(boco)%norm(i, j, 1) + &
&         bcdata(boco)%vely(i, j)*bcdata(boco)%norm(i, j, 2) + bcdata(&
&         boco)%velz(i, j)*bcdata(boco)%norm(i, j, 3)
        if (var .gt. zero) nn = nn + 1
      end do
    end do
    if (nn .gt. 0) then
      write(errormessage, 102) trim(cgnsdoms(nbkglobal)%zonename), trim(&
&     cgnsdoms(nbkglobal)%bocoinfo(cgnsboco)%boconame)
      call terminate('bcdatasupersonicinflow', errormessage)
    end if
 100 format('zone ',a,', boundary subface ',a, &
&          ': not enough data specified for supersonic inlet')
 102 format('zone ',a,', supersonic inlet boundary subface ',a, &
&          ': velocity points out of the domain for some faces.')

  contains
!  differentiation of prescribedsupersonicinlet in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *(*bcdata.turbinlet) *(*bcdata.rho)
!                *(*bcdata.velx) *(*bcdata.vely) *(*bcdata.velz)
!                *(*bcdata.ps)
!   with respect to varying inputs: muref uref winf pref rhoref
!                bcvararray
!   plus diff mem management of: bcdata:in *bcdata.turbinlet:in-out
!                *bcdata.rho:in *bcdata.velx:in *bcdata.vely:in
!                *bcdata.velz:in *bcdata.ps:in
    subroutine prescribedsupersonicinlet_d()
!
!         prescribedsupersonicinlet sets the variables for this
!         supersonic inlet to prescribed values.
!
      use section, only : sections
      use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
      implicit none
!
!        local variables.
!
      integer(kind=inttype) :: i, j
      real(kind=realtype) :: mult, trans
      real(kind=realtype) :: ax, r1, r2, var, vax, vrad, vtheta
      real(kind=realtype) :: vaxd, vradd, vthetad
      real(kind=realtype), dimension(3) :: xc, vloc
      real(kind=realtype), dimension(3) :: vlocd
      real(kind=realtype), dimension(3) :: multvel, transvel
      intrinsic max
      intrinsic sqrt
      real(kind=realtype) :: result1
      integer :: ii1
      real(kind=realtype) :: max1
! set the density. take the conversion factor to si-units
! into account.
      call sidensity(mass(1), length(1), mult, trans)
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%rho = 0.0_8
      end do
      do j=jbeg,jend
        do i=ibeg,iend
          bcdatad(boco)%rho(i, j) = (mult*bcvararrayd(i, j, 1)*rhoref-(&
&           mult*bcvararray(i, j, 1)+trans)*rhorefd)/rhoref**2
          bcdata(boco)%rho(i, j) = (mult*bcvararray(i, j, 1)+trans)/&
&           rhoref
        end do
      end do
! set the pressure. take the conversion factor to si-units
! into account.
      call sipressure(mass(1), length(2), time(2), mult, trans)
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%ps = 0.0_8
      end do
      do j=jbeg,jend
        do i=ibeg,iend
          bcdatad(boco)%ps(i, j) = (mult*bcvararrayd(i, j, 2)*pref-(mult&
&           *bcvararray(i, j, 2)+trans)*prefd)/pref**2
          bcdata(boco)%ps(i, j) = (mult*bcvararray(i, j, 2)+trans)/pref
        end do
      end do
! check the situation we are having here for the velocity.
      if (velrpresent) then
! radial velocity component prescribed. this must be converted
! to cartesian components.
! determine the unit vectors, which define the cylindrical
! coordinate system aligned with the rotation axis.
        call unitvectorscylsystem(boco)
! determine the conversion factor to si-units for the three
! components. note that a test must be made whether the theta
! component is present.
        call sivelocity(length(3), time(3), multvel(1), transvel(1))
        call sivelocity(length(6), time(6), multvel(2), transvel(2))
        if (veltpresent) call sivelocity(length(7), time(7), multvel(3)&
&                                  , transvel(3))
! initialize vtheta to zero. this value will be used
! if no theta velocity component was specified.
        vtheta = zero
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velx = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%vely = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velz = 0.0_8
        end do
        vlocd = 0.0_8
        vthetad = 0.0_8
! loop over the faces of the subface.
        do j=jbeg,jend
          do i=ibeg,iend
! determine the coordinates of the face center relative to
! the rotation point of this section. normally this is an
! average of i-1, i, j-1, j, but due to the usage of the
! pointer xf and the fact that x originally starts at 0,
! an offset of 1 is introduced and thus the average should
! be taken of i, i+1, j and j+1.
            xc(1) = fourth*(xf(i, j, 1)+xf(i+1, j, 1)+xf(i, j+1, 1)+xf(i&
&             +1, j+1, 1)) - sections(sectionid)%rotcenter(1)
            xc(2) = fourth*(xf(i, j, 2)+xf(i+1, j, 2)+xf(i, j+1, 2)+xf(i&
&             +1, j+1, 2)) - sections(sectionid)%rotcenter(2)
            xc(3) = fourth*(xf(i, j, 3)+xf(i+1, j, 3)+xf(i, j+1, 3)+xf(i&
&             +1, j+1, 3)) - sections(sectionid)%rotcenter(3)
! determine the coordinates in the local cartesian frame,
! i.e. the frame determined by axis, radvec1 and radvec2.
            ax = xc(1)*axis(1) + xc(2)*axis(2) + xc(3)*axis(3)
            r1 = xc(1)*radvec1(1) + xc(2)*radvec1(2) + xc(3)*radvec1(3)
            r2 = xc(1)*radvec2(1) + xc(2)*radvec2(2) + xc(3)*radvec2(3)
! determine the velocity components in the local
! cylindrical system. take the conversion to si units
! into account.
            vaxd = multvel(1)*bcvararrayd(i, j, 3)
            vax = multvel(1)*bcvararray(i, j, 3) + transvel(1)
            vradd = multvel(2)*bcvararrayd(i, j, 6)
            vrad = multvel(2)*bcvararray(i, j, 6) + transvel(2)
            if (veltpresent) then
              vthetad = multvel(3)*bcvararrayd(i, j, 7)
              vtheta = multvel(3)*bcvararray(i, j, 7) + transvel(3)
            end if
            if (eps .lt. r1*r1 + r2*r2) then
              max1 = r1*r1 + r2*r2
            else
              max1 = eps
            end if
! determine the velocities in the local cartesian
! frame determined by axis, radvec1 and radvec2.
            result1 = sqrt(max1)
            var = one/result1
            vlocd(1) = vaxd
            vloc(1) = vax
            vlocd(2) = var*(r1*vradd-r2*vthetad)
            vloc(2) = var*(vrad*r1-vtheta*r2)
            vlocd(3) = var*(r2*vradd+r1*vthetad)
            vloc(3) = var*(vrad*r2+vtheta*r1)
! transform vloc to the global cartesian frame and
! store the values.
            bcdatad(boco)%velx(i, j) = ((axis(1)*vlocd(1)+radvec1(1)*&
&             vlocd(2)+radvec2(1)*vlocd(3))*uref-(vloc(1)*axis(1)+vloc(2&
&             )*radvec1(1)+vloc(3)*radvec2(1))*urefd)/uref**2
            bcdata(boco)%velx(i, j) = (vloc(1)*axis(1)+vloc(2)*radvec1(1&
&             )+vloc(3)*radvec2(1))/uref
            bcdatad(boco)%vely(i, j) = ((axis(2)*vlocd(1)+radvec1(2)*&
&             vlocd(2)+radvec2(2)*vlocd(3))*uref-(vloc(1)*axis(2)+vloc(2&
&             )*radvec1(2)+vloc(3)*radvec2(2))*urefd)/uref**2
            bcdata(boco)%vely(i, j) = (vloc(1)*axis(2)+vloc(2)*radvec1(2&
&             )+vloc(3)*radvec2(2))/uref
            bcdatad(boco)%velz(i, j) = ((axis(3)*vlocd(1)+radvec1(3)*&
&             vlocd(2)+radvec2(3)*vlocd(3))*uref-(vloc(1)*axis(3)+vloc(2&
&             )*radvec1(3)+vloc(3)*radvec2(3))*urefd)/uref**2
            bcdata(boco)%velz(i, j) = (vloc(1)*axis(3)+vloc(2)*radvec1(3&
&             )+vloc(3)*radvec2(3))/uref
          end do
        end do
      else
! cartesian components prescribed.
! determine the conversion factor to si-units for the three
! components.
        call sivelocity(length(3), time(3), multvel(1), transvel(1))
        call sivelocity(length(4), time(4), multvel(2), transvel(2))
        call sivelocity(length(5), time(5), multvel(3), transvel(3))
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velx = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%vely = 0.0_8
        end do
        do ii1=1,isize1ofdrfbcdata
          bcdatad(ii1)%velz = 0.0_8
        end do
! set the velocities.
        do j=jbeg,jend
          do i=ibeg,iend
            bcdatad(boco)%velx(i, j) = (multvel(1)*bcvararrayd(i, j, 3)*&
&             uref-(multvel(1)*bcvararray(i, j, 3)+transvel(1))*urefd)/&
&             uref**2
            bcdata(boco)%velx(i, j) = (multvel(1)*bcvararray(i, j, 3)+&
&             transvel(1))/uref
            bcdatad(boco)%vely(i, j) = (multvel(2)*bcvararrayd(i, j, 4)*&
&             uref-(multvel(2)*bcvararray(i, j, 4)+transvel(2))*urefd)/&
&             uref**2
            bcdata(boco)%vely(i, j) = (multvel(2)*bcvararray(i, j, 4)+&
&             transvel(2))/uref
            bcdatad(boco)%velz(i, j) = (multvel(3)*bcvararrayd(i, j, 5)*&
&             uref-(multvel(3)*bcvararray(i, j, 5)+transvel(3))*urefd)/&
&             uref**2
            bcdata(boco)%velz(i, j) = (multvel(3)*bcvararray(i, j, 5)+&
&             transvel(3))/uref
          end do
        end do
      end if
! set the turbulence variables and check if all of them are
! prescribed. if not set allturbpresent to .false.
      do ii1=1,isize1ofdrfbcdata
        bcdatad(ii1)%turbinlet = 0.0_8
      end do
      call setbcvarturb_d(7_inttype, boco, bcvararray, bcvararrayd, ibeg&
&                   , iend, jbeg, jend, bcdata(boco)%turbinlet, bcdatad(&
&                   boco)%turbinlet, allturbpresent)
    end subroutine prescribedsupersonicinlet_d
    subroutine prescribedsupersonicinlet()
!
!         prescribedsupersonicinlet sets the variables for this
!         supersonic inlet to prescribed values.
!
      use section, only : sections
      implicit none
!
!        local variables.
!
      integer(kind=inttype) :: i, j
      real(kind=realtype) :: mult, trans
      real(kind=realtype) :: ax, r1, r2, var, vax, vrad, vtheta
      real(kind=realtype), dimension(3) :: xc, vloc
      real(kind=realtype), dimension(3) :: multvel, transvel
      intrinsic max
      intrinsic sqrt
      real(kind=realtype) :: result1
      real(kind=realtype) :: max1
! set the density. take the conversion factor to si-units
! into account.
      call sidensity(mass(1), length(1), mult, trans)
      do j=jbeg,jend
        do i=ibeg,iend
          bcdata(boco)%rho(i, j) = (mult*bcvararray(i, j, 1)+trans)/&
&           rhoref
        end do
      end do
! set the pressure. take the conversion factor to si-units
! into account.
      call sipressure(mass(1), length(2), time(2), mult, trans)
      do j=jbeg,jend
        do i=ibeg,iend
          bcdata(boco)%ps(i, j) = (mult*bcvararray(i, j, 2)+trans)/pref
        end do
      end do
! check the situation we are having here for the velocity.
      if (velrpresent) then
! radial velocity component prescribed. this must be converted
! to cartesian components.
! determine the unit vectors, which define the cylindrical
! coordinate system aligned with the rotation axis.
        call unitvectorscylsystem(boco)
! determine the conversion factor to si-units for the three
! components. note that a test must be made whether the theta
! component is present.
        call sivelocity(length(3), time(3), multvel(1), transvel(1))
        call sivelocity(length(6), time(6), multvel(2), transvel(2))
        if (veltpresent) call sivelocity(length(7), time(7), multvel(3)&
&                                  , transvel(3))
! initialize vtheta to zero. this value will be used
! if no theta velocity component was specified.
        vtheta = zero
! loop over the faces of the subface.
        do j=jbeg,jend
          do i=ibeg,iend
! determine the coordinates of the face center relative to
! the rotation point of this section. normally this is an
! average of i-1, i, j-1, j, but due to the usage of the
! pointer xf and the fact that x originally starts at 0,
! an offset of 1 is introduced and thus the average should
! be taken of i, i+1, j and j+1.
            xc(1) = fourth*(xf(i, j, 1)+xf(i+1, j, 1)+xf(i, j+1, 1)+xf(i&
&             +1, j+1, 1)) - sections(sectionid)%rotcenter(1)
            xc(2) = fourth*(xf(i, j, 2)+xf(i+1, j, 2)+xf(i, j+1, 2)+xf(i&
&             +1, j+1, 2)) - sections(sectionid)%rotcenter(2)
            xc(3) = fourth*(xf(i, j, 3)+xf(i+1, j, 3)+xf(i, j+1, 3)+xf(i&
&             +1, j+1, 3)) - sections(sectionid)%rotcenter(3)
! determine the coordinates in the local cartesian frame,
! i.e. the frame determined by axis, radvec1 and radvec2.
            ax = xc(1)*axis(1) + xc(2)*axis(2) + xc(3)*axis(3)
            r1 = xc(1)*radvec1(1) + xc(2)*radvec1(2) + xc(3)*radvec1(3)
            r2 = xc(1)*radvec2(1) + xc(2)*radvec2(2) + xc(3)*radvec2(3)
! determine the velocity components in the local
! cylindrical system. take the conversion to si units
! into account.
            vax = multvel(1)*bcvararray(i, j, 3) + transvel(1)
            vrad = multvel(2)*bcvararray(i, j, 6) + transvel(2)
            if (veltpresent) vtheta = multvel(3)*bcvararray(i, j, 7) + &
&               transvel(3)
            if (eps .lt. r1*r1 + r2*r2) then
              max1 = r1*r1 + r2*r2
            else
              max1 = eps
            end if
! determine the velocities in the local cartesian
! frame determined by axis, radvec1 and radvec2.
            result1 = sqrt(max1)
            var = one/result1
            vloc(1) = vax
            vloc(2) = var*(vrad*r1-vtheta*r2)
            vloc(3) = var*(vrad*r2+vtheta*r1)
! transform vloc to the global cartesian frame and
! store the values.
            bcdata(boco)%velx(i, j) = (vloc(1)*axis(1)+vloc(2)*radvec1(1&
&             )+vloc(3)*radvec2(1))/uref
            bcdata(boco)%vely(i, j) = (vloc(1)*axis(2)+vloc(2)*radvec1(2&
&             )+vloc(3)*radvec2(2))/uref
            bcdata(boco)%velz(i, j) = (vloc(1)*axis(3)+vloc(2)*radvec1(3&
&             )+vloc(3)*radvec2(3))/uref
          end do
        end do
      else
! cartesian components prescribed.
! determine the conversion factor to si-units for the three
! components.
        call sivelocity(length(3), time(3), multvel(1), transvel(1))
        call sivelocity(length(4), time(4), multvel(2), transvel(2))
        call sivelocity(length(5), time(5), multvel(3), transvel(3))
! set the velocities.
        do j=jbeg,jend
          do i=ibeg,iend
            bcdata(boco)%velx(i, j) = (multvel(1)*bcvararray(i, j, 3)+&
&             transvel(1))/uref
            bcdata(boco)%vely(i, j) = (multvel(2)*bcvararray(i, j, 4)+&
&             transvel(2))/uref
            bcdata(boco)%velz(i, j) = (multvel(3)*bcvararray(i, j, 5)+&
&             transvel(3))/uref
          end do
        end do
      end if
! set the turbulence variables and check if all of them are
! prescribed. if not set allturbpresent to .false.
      allturbpresent = setbcvarturb(7_inttype, boco, bcvararray, ibeg, &
&       iend, jbeg, jend, bcdata(boco)%turbinlet)
    end subroutine prescribedsupersonicinlet
  end subroutine bcdatasupersonicinflow_d
!  differentiation of setbcvarturb in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *turbinlet
!   with respect to varying inputs: muref winf pref rhoref bcvararray
!   plus diff mem management of: turbinlet:in
!=================================================================
  subroutine setbcvarturb_d(offset, boco, bcvararray, bcvararrayd, ibeg&
&   , iend, jbeg, jend, turbinlet, turbinletd, setbcvarturb)
!
!       setbcvarturb sets the array for the turbulent halo data
!       for inlet boundaries. this function returns .true. if all
!       turbulence variables could be interpolated and .false.
!       otherwise.
!
    use constants
    use flowvarrefstate, only : nt1, nt2, muref, murefd, pref, prefd, &
&   rhoref, rhorefd, winf, winfd
    use inputphysics, only : equations, turbmodel
    use utils_d, only : terminate, siturb
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: offset, boco, ibeg, iend, jbeg&
&   , jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararrayd
    real(kind=realtype), dimension(:, :, :), pointer :: turbinlet
    real(kind=realtype), dimension(:, :, :), pointer :: turbinletd
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm, i, j
    real(kind=realtype) :: mult, trans, nuref
    real(kind=realtype) :: nurefd
    real(kind=realtype), dimension(nt1:nt2) :: ref
    real(kind=realtype), dimension(nt1:nt2) :: refd
    logical :: setbcvarturb
! initialize setbcvarturb to .true. and return immediately
! if not the rans equations are solved.
    setbcvarturb = .true.
    if (equations .ne. ransequations) then
      turbinletd = 0.0_8
      return
    else
! set the reference values depending on the turbulence model.
      nurefd = (murefd*rhoref-muref*rhorefd)/rhoref**2
      nuref = muref/rhoref
      select case  (turbmodel) 
      case (spalartallmaras, spalartallmarasedwards) 
        refd = 0.0_8
        refd(itu1) = nurefd
        ref(itu1) = nuref
      case (komegawilcox, komegamodified, mentersst) 
        refd = 0.0_8
        refd(itu1) = (prefd*rhoref-pref*rhorefd)/rhoref**2
        ref(itu1) = pref/rhoref
        refd(itu2) = (refd(itu1)*nuref-ref(itu1)*nurefd)/nuref**2
        ref(itu2) = ref(itu1)/nuref
      case (ktau) 
        refd = 0.0_8
        refd(itu1) = (prefd*rhoref-pref*rhorefd)/rhoref**2
        ref(itu1) = pref/rhoref
        refd(itu2) = (nurefd*ref(itu1)-nuref*refd(itu1))/ref(itu1)**2
        ref(itu2) = nuref/ref(itu1)
      case (v2f) 
        refd = 0.0_8
        refd(itu1) = (prefd*rhoref-pref*rhorefd)/rhoref**2
        ref(itu1) = pref/rhoref
        refd(itu4) = (refd(itu1)*nuref-ref(itu1)*nurefd)/nuref**2
        ref(itu4) = ref(itu1)/nuref
        refd(itu2) = refd(itu1)*ref(itu4) + ref(itu1)*refd(itu4)
        ref(itu2) = ref(itu1)*ref(itu4)
        refd(itu3) = refd(itu1)
        ref(itu3) = ref(itu1)
      case default
        refd = 0.0_8
      end select
! loop over the number of turbulent variables. mm is the counter
! in the arrays bcvararray and bcvarpresent.
      mm = offset
      turbinletd = 0.0_8
turbloop:do nn=nt1,nt2
        mm = mm + 1
! check if the variable is present. if so, use the
! interpolated data.
        if (bcvarpresent(mm)) then
! conversion to si units if possible.
          call siturb(mass(mm), length(mm), time(mm), temp(mm), &
&               bcvarnames(mm), mult, trans)
! set the turbulent variables.
          do j=jbeg,jend
            do i=ibeg,iend
              turbinletd(i, j, nn) = (mult*bcvararrayd(i, j, mm)*ref(nn)&
&               -(mult*bcvararray(i, j, mm)+trans)*refd(nn))/ref(nn)**2
              turbinlet(i, j, nn) = (mult*bcvararray(i, j, mm)+trans)/&
&               ref(nn)
            end do
          end do
        else
! turbulent variable not present. use the free stream data.
          do j=jbeg,jend
            do i=ibeg,iend
              turbinletd(i, j, nn) = winfd(nn)
              turbinlet(i, j, nn) = winf(nn)
            end do
          end do
! set the logical value to false to indicate that indeed not
! all the values were present
          setbcvarturb = .false.
        end if
      end do turbloop
    end if
  end subroutine setbcvarturb_d
!=================================================================
  logical function setbcvarturb(offset, boco, bcvararray, ibeg, iend, &
&   jbeg, jend, turbinlet)
!
!       setbcvarturb sets the array for the turbulent halo data
!       for inlet boundaries. this function returns .true. if all
!       turbulence variables could be interpolated and .false.
!       otherwise.
!
    use constants
    use flowvarrefstate, only : nt1, nt2, muref, pref, rhoref, winf
    use inputphysics, only : equations, turbmodel
    use utils_d, only : terminate, siturb
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: offset, boco, ibeg, iend, jbeg&
&   , jend
    real(kind=realtype), dimension(ibeg:iend, jbeg:jend, nbcvarmax) :: &
&   bcvararray
    real(kind=realtype), dimension(:, :, :), pointer :: turbinlet
!
!      local variables.
!
    integer(kind=inttype) :: nn, mm, i, j
    real(kind=realtype) :: mult, trans, nuref
    real(kind=realtype), dimension(nt1:nt2) :: ref
! initialize setbcvarturb to .true. and return immediately
! if not the rans equations are solved.
    setbcvarturb = .true.
    if (equations .ne. ransequations) then
      return
    else
! set the reference values depending on the turbulence model.
      nuref = muref/rhoref
      select case  (turbmodel) 
      case (spalartallmaras, spalartallmarasedwards) 
        ref(itu1) = nuref
      case (komegawilcox, komegamodified, mentersst) 
        ref(itu1) = pref/rhoref
        ref(itu2) = ref(itu1)/nuref
      case (ktau) 
        ref(itu1) = pref/rhoref
        ref(itu2) = nuref/ref(itu1)
      case (v2f) 
        ref(itu1) = pref/rhoref
        ref(itu4) = ref(itu1)/nuref
        ref(itu2) = ref(itu1)*ref(itu4)
        ref(itu3) = ref(itu1)
      end select
! loop over the number of turbulent variables. mm is the counter
! in the arrays bcvararray and bcvarpresent.
      mm = offset
turbloop:do nn=nt1,nt2
        mm = mm + 1
! check if the variable is present. if so, use the
! interpolated data.
        if (bcvarpresent(mm)) then
! conversion to si units if possible.
          call siturb(mass(mm), length(mm), time(mm), temp(mm), &
&               bcvarnames(mm), mult, trans)
! set the turbulent variables.
          do j=jbeg,jend
            do i=ibeg,iend
              turbinlet(i, j, nn) = (mult*bcvararray(i, j, mm)+trans)/&
&               ref(nn)
            end do
          end do
        else
! turbulent variable not present. use the free stream data.
          do j=jbeg,jend
            do i=ibeg,iend
              turbinlet(i, j, nn) = winf(nn)
            end do
          end do
! set the logical value to false to indicate that indeed not
! all the values were present
          setbcvarturb = .false.
        end if
      end do turbloop
    end if
  end function setbcvarturb
end module bcdata_d

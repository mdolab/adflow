!        generated by tapenade     (inria, ecuador team)
!  tapenade 3.16 (develop) - 13 sep 2023 12:36
!
module sst_d
! this module contains the source code related to the sst turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier.
  use constants
  implicit none
  real(kind=realtype), dimension(:, :, :, :, :), allocatable :: qq
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall

contains
!  differentiation of sstsource in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *scratch
!   rw status of diff variables: *rev:in *w:in *scratch:in-out
!   plus diff mem management of: rev:in w:in scratch:in
  subroutine sstsource_d()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use inputdiscretization, only : approxturb
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rsstgamd, rsstbetad
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: rhoid, ssd, spkd, sdkd
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic min
    real(kind=realtype) :: result1
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
! set model constants
    if (use2003sst) then
      rsstgam1 = 5.0_realtype/9.0_realtype
      rsstgam2 = 0.44_realtype
    else
      result1 = sqrt(rsstbetas)
      rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/result1
      result1 = sqrt(rsstbetas)
      rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/result1
    end if
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstgamd = rsstgam1*t1d + rsstgam2*t2d
          rsstgam = t1*rsstgam1 + t2*rsstgam2
          rsstbetad = rsstbeta1*t1d + rsstbeta2*t2d
          rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          ssd = scratchd(i, j, k, iprod)
          ss = scratch(i, j, k, iprod)
          if (approxturb) then
            spk = zero
            spkd = 0.0_8
          else
            spkd = ss*rhoi*revd(i, j, k) + rev(i, j, k)*(rhoi*ssd+ss*&
&             rhoid)
            spk = rev(i, j, k)*ss*rhoi
          end if
          temp = w(i, j, k, itu2)
          temp0 = w(i, j, k, itu1)
          sdkd = rsstbetas*(temp*wd(i, j, k, itu1)+temp0*wd(i, j, k, &
&           itu2))
          sdk = rsstbetas*(temp0*temp)
          if (spk .gt. pklim*sdk) then
            spkd = pklim*sdkd
            spk = pklim*sdk
          else
            spk = spk
          end if
          scratchd(i, j, k, idvt) = spkd - sdkd
          scratch(i, j, k, idvt) = spk - sdk
          if (use2003sst) then
            temp0 = rsstgam*spk/rev(i, j, k)
            temp = scratch(i, j, k, icd)
            temp1 = w(i, j, k, itu2)
            scratchd(i, j, k, idvt+1) = (spk*rsstgamd+rsstgam*spkd-temp0&
&             *revd(i, j, k))/rev(i, j, k) + two*rsstsigw2*(temp*t2d+t2*&
&             scratchd(i, j, k, icd)) - temp1**2*rsstbetad - rsstbeta*2*&
&             temp1*wd(i, j, k, itu2)
            scratch(i, j, k, idvt+1) = temp0 + two*rsstsigw2*(t2*temp) -&
&             rsstbeta*(temp1*temp1)
          else
            temp1 = scratch(i, j, k, icd)
            temp0 = w(i, j, k, itu2)
            scratchd(i, j, k, idvt+1) = ss*rsstgamd + rsstgam*ssd + two*&
&             rsstsigw2*(temp1*t2d+t2*scratchd(i, j, k, icd)) - temp0**2&
&             *rsstbetad - rsstbeta*2*temp0*wd(i, j, k, itu2)
            scratch(i, j, k, idvt+1) = rsstgam*ss + two*rsstsigw2*(t2*&
&             temp1) - rsstbeta*(temp0*temp0)
          end if
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.

        end do
      end do
    end do
  end subroutine sstsource_d

  subroutine sstsource()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use inputdiscretization, only : approxturb
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic min
    real(kind=realtype) :: result1
! set model constants
    if (use2003sst) then
      rsstgam1 = 5.0_realtype/9.0_realtype
      rsstgam2 = 0.44_realtype
    else
      result1 = sqrt(rsstbetas)
      rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/result1
      result1 = sqrt(rsstbetas)
      rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/result1
    end if
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstgam = t1*rsstgam1 + t2*rsstgam2
          rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
          rhoi = one/w(i, j, k, irho)
          ss = scratch(i, j, k, iprod)
          if (approxturb) then
            spk = zero
          else
            spk = rev(i, j, k)*ss*rhoi
          end if
          sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
          if (spk .gt. pklim*sdk) then
            spk = pklim*sdk
          else
            spk = spk
          end if
          scratch(i, j, k, idvt) = spk - sdk
          if (use2003sst) then
            scratch(i, j, k, idvt+1) = rsstgam*spk/rev(i, j, k) + two*t2&
&             *rsstsigw2*scratch(i, j, k, icd) - rsstbeta*w(i, j, k, &
&             itu2)**2
          else
            scratch(i, j, k, idvt+1) = rsstgam*ss + two*t2*rsstsigw2*&
&             scratch(i, j, k, icd) - rsstbeta*w(i, j, k, itu2)**2
          end if
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.

        end do
      end do
    end do
  end subroutine sstsource

!  differentiation of sstviscous in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   rw status of diff variables: *rev:in *w:in *rlv:in *scratch:in-out
!                *vol:in *si:in *sj:in *sk:in
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                vol:in si:in sj:in sk:in
  subroutine sstviscous_d()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigkp1d, rsstsigkd, rsstsigkm1d
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: rsstsigwp1d, rsstsigwd, rsstsigwm1d
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          temp = one/vol(i, j, k)
          volid = -(temp*vold(i, j, k)/vol(i, j, k))
          voli = temp
          temp = two/(vol(i, j, k)+vol(i, j, k-1))
          volmid = -(temp*(vold(i, j, k)+vold(i, j, k-1))/(vol(i, j, k)+&
&           vol(i, j, k-1)))
          volmi = temp
          temp = two/(vol(i, j, k)+vol(i, j, k+1))
          volpid = -(temp*(vold(i, j, k)+vold(i, j, k+1))/(vol(i, j, k)+&
&           vol(i, j, k+1)))
          volpi = temp
          temp = sk(i, j, k-1, 1)
          xmd = volmi*skd(i, j, k-1, 1) + temp*volmid
          xm = temp*volmi
          temp = sk(i, j, k-1, 2)
          ymd = volmi*skd(i, j, k-1, 2) + temp*volmid
          ym = temp*volmi
          temp = sk(i, j, k-1, 3)
          zmd = volmi*skd(i, j, k-1, 3) + temp*volmid
          zm = temp*volmi
          temp = sk(i, j, k, 1)
          xpd = volpi*skd(i, j, k, 1) + temp*volpid
          xp = temp*volpi
          temp = sk(i, j, k, 2)
          ypd = volpi*skd(i, j, k, 2) + temp*volpid
          yp = temp*volpi
          temp = sk(i, j, k, 3)
          zpd = volpi*skd(i, j, k, 3) + temp*volpid
          zp = temp*volpi
          temp = sk(i, j, k, 1) + sk(i, j, k-1, 1)
          xad = half*(voli*(skd(i, j, k, 1)+skd(i, j, k-1, 1))+temp*&
&           volid)
          xa = half*(temp*voli)
          temp = sk(i, j, k, 2) + sk(i, j, k-1, 2)
          yad = half*(voli*(skd(i, j, k, 2)+skd(i, j, k-1, 2))+temp*&
&           volid)
          ya = half*(temp*voli)
          temp = sk(i, j, k, 3) + sk(i, j, k-1, 3)
          zad = half*(voli*(skd(i, j, k, 3)+skd(i, j, k-1, 3))+temp*&
&           volid)
          za = half*(temp*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
          t1d = scratchd(i, j, k+1, if1sst)
          t1 = scratch(i, j, k+1, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k-1, if1sst)
          t1 = scratch(i, j, k-1, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          mulmd = half*(rlvd(i, j, k-1)+rlvd(i, j, k))
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j, k+1)+rlvd(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          temp = rev(i, j, k-1)
          muemd = half*(temp*rsstsigkm1d+rsstsigkm1*revd(i, j, k-1)+rev(&
&           i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muem = half*(rsstsigkm1*temp+rsstsigk*rev(i, j, k))
          temp = rev(i, j, k+1)
          muepd = half*(temp*rsstsigkp1d+rsstsigkp1*revd(i, j, k+1)+rev(&
&           i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muep = half*(rsstsigkp1*temp+rsstsigk*rev(i, j, k))
          c1md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          temp = rev(i, j, k-1)
          muemd = half*(temp*rsstsigwm1d+rsstsigwm1*revd(i, j, k-1)+rev(&
&           i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muem = half*(rsstsigwm1*temp+rsstsigw*rev(i, j, k))
          temp = rev(i, j, k+1)
          muepd = half*(temp*rsstsigwp1d+rsstsigwp1*revd(i, j, k+1)+rev(&
&           i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muep = half*(rsstsigwp1*temp+rsstsigw*rev(i, j, k))
          c2md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp = w(i, j, k-1, itu1)
          temp0 = w(i, j, k+1, itu1)
          temp1 = w(i, j, k, itu1)
          scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) + temp*c1md &
&           + c1m*wd(i, j, k-1, itu1) + temp0*c1pd + c1p*wd(i, j, k+1, &
&           itu1) - temp1*c10d - c10*wd(i, j, k, itu1)
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*temp + &
&           c1p*temp0 - c10*temp1
          temp1 = w(i, j, k-1, itu2)
          temp0 = w(i, j, k+1, itu2)
          temp = w(i, j, k, itu2)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + temp1*&
&           c2md + c2m*wd(i, j, k-1, itu2) + temp0*c2pd + c2p*wd(i, j, k&
&           +1, itu2) - temp*c20d - c20*wd(i, j, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*&
&           temp1 + c2p*temp0 - c20*temp
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j-1, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i, j-1, k))/(vol(i, j, k)&
&           +vol(i, j-1, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j+1, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i, j+1, k))/(vol(i, j, k)&
&           +vol(i, j+1, k)))
          volpi = temp1
          temp1 = sj(i, j-1, k, 1)
          xmd = volmi*sjd(i, j-1, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = sj(i, j-1, k, 2)
          ymd = volmi*sjd(i, j-1, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = sj(i, j-1, k, 3)
          zmd = volmi*sjd(i, j-1, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = sj(i, j, k, 1)
          xpd = volpi*sjd(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = sj(i, j, k, 2)
          ypd = volpi*sjd(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = sj(i, j, k, 3)
          zpd = volpi*sjd(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = sj(i, j, k, 1) + sj(i, j-1, k, 1)
          xad = half*(voli*(sjd(i, j, k, 1)+sjd(i, j-1, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = sj(i, j, k, 2) + sj(i, j-1, k, 2)
          yad = half*(voli*(sjd(i, j, k, 2)+sjd(i, j-1, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = sj(i, j, k, 3) + sj(i, j-1, k, 3)
          zad = half*(voli*(sjd(i, j, k, 3)+sjd(i, j-1, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
          t1d = scratchd(i, j+1, k, if1sst)
          t1 = scratch(i, j+1, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j-1, k, if1sst)
          t1 = scratch(i, j-1, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i, j-1, k)+rlvd(i, j, k))
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j+1, k)+rlvd(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          temp1 = rev(i, j-1, k)
          muemd = half*(temp1*rsstsigkm1d+rsstsigkm1*revd(i, j-1, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muem = half*(rsstsigkm1*temp1+rsstsigk*rev(i, j, k))
          temp1 = rev(i, j+1, k)
          muepd = half*(temp1*rsstsigkp1d+rsstsigkp1*revd(i, j+1, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muep = half*(rsstsigkp1*temp1+rsstsigk*rev(i, j, k))
          c1md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          temp1 = rev(i, j-1, k)
          muemd = half*(temp1*rsstsigwm1d+rsstsigwm1*revd(i, j-1, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muem = half*(rsstsigwm1*temp1+rsstsigw*rev(i, j, k))
          temp1 = rev(i, j+1, k)
          muepd = half*(temp1*rsstsigwp1d+rsstsigwp1*revd(i, j+1, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muep = half*(rsstsigwp1*temp1+rsstsigw*rev(i, j, k))
          c2md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i, j-1, k, itu1)
          temp0 = w(i, j+1, k, itu1)
          temp = w(i, j, k, itu1)
          scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) + temp1*c1md&
&           + c1m*wd(i, j-1, k, itu1) + temp0*c1pd + c1p*wd(i, j+1, k, &
&           itu1) - temp*c10d - c10*wd(i, j, k, itu1)
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*temp1 + &
&           c1p*temp0 - c10*temp
          temp1 = w(i, j-1, k, itu2)
          temp0 = w(i, j+1, k, itu2)
          temp = w(i, j, k, itu2)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + temp1*&
&           c2md + c2m*wd(i, j-1, k, itu2) + temp0*c2pd + c2p*wd(i, j+1&
&           , k, itu2) - temp*c20d - c20*wd(i, j, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*&
&           temp1 + c2p*temp0 - c20*temp
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i-1, j, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i-1, j, k))/(vol(i, j, k)&
&           +vol(i-1, j, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i+1, j, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i+1, j, k))/(vol(i, j, k)&
&           +vol(i+1, j, k)))
          volpi = temp1
          temp1 = si(i-1, j, k, 1)
          xmd = volmi*sid(i-1, j, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = si(i-1, j, k, 2)
          ymd = volmi*sid(i-1, j, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = si(i-1, j, k, 3)
          zmd = volmi*sid(i-1, j, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = si(i, j, k, 1)
          xpd = volpi*sid(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = si(i, j, k, 2)
          ypd = volpi*sid(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = si(i, j, k, 3)
          zpd = volpi*sid(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = si(i, j, k, 1) + si(i-1, j, k, 1)
          xad = half*(voli*(sid(i, j, k, 1)+sid(i-1, j, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = si(i, j, k, 2) + si(i-1, j, k, 2)
          yad = half*(voli*(sid(i, j, k, 2)+sid(i-1, j, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = si(i, j, k, 3) + si(i-1, j, k, 3)
          zad = half*(voli*(sid(i, j, k, 3)+sid(i-1, j, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
          t1d = scratchd(i+1, j, k, if1sst)
          t1 = scratch(i+1, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i-1, j, k, if1sst)
          t1 = scratch(i-1, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i-1, j, k)+rlvd(i, j, k))
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i+1, j, k)+rlvd(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          temp1 = rev(i-1, j, k)
          muemd = half*(temp1*rsstsigkm1d+rsstsigkm1*revd(i-1, j, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muem = half*(rsstsigkm1*temp1+rsstsigk*rev(i, j, k))
          temp1 = rev(i+1, j, k)
          muepd = half*(temp1*rsstsigkp1d+rsstsigkp1*revd(i+1, j, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muep = half*(rsstsigkp1*temp1+rsstsigk*rev(i, j, k))
          c1md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          temp1 = rev(i-1, j, k)
          muemd = half*(temp1*rsstsigwm1d+rsstsigwm1*revd(i-1, j, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muem = half*(rsstsigwm1*temp1+rsstsigw*rev(i, j, k))
          temp1 = rev(i+1, j, k)
          muepd = half*(temp1*rsstsigwp1d+rsstsigwp1*revd(i+1, j, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muep = half*(rsstsigwp1*temp1+rsstsigw*rev(i, j, k))
          c2md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i-1, j, k, itu1)
          temp0 = w(i+1, j, k, itu1)
          temp = w(i, j, k, itu1)
          scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) + temp1*c1md&
&           + c1m*wd(i-1, j, k, itu1) + temp0*c1pd + c1p*wd(i+1, j, k, &
&           itu1) - temp*c10d - c10*wd(i, j, k, itu1)
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*temp1 + &
&           c1p*temp0 - c10*temp
          temp1 = w(i-1, j, k, itu2)
          temp0 = w(i+1, j, k, itu2)
          temp = w(i, j, k, itu2)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + temp1*&
&           c2md + c2m*wd(i-1, j, k, itu2) + temp0*c2pd + c2p*wd(i+1, j&
&           , k, itu2) - temp*c20d - c20*wd(i, j, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*&
&           temp1 + c2p*temp0 - c20*temp
        end do
      end do
    end do
  end subroutine sstviscous_d

  subroutine sstviscous()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
          t1 = scratch(i, j, k+1, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k-1, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j, &
&           k-1, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j, k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
          t1 = scratch(i, j+1, k, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j-1, k, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j-1&
&           , k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j-1, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
          t1 = scratch(i+1, j, k, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i-1, j, k, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i-1, j&
&           , k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i-&
&           1, j, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i+1, j, k, &
&           itu2)
        end do
      end do
    end do
  end subroutine sstviscous

!  differentiation of sstresscale in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:in
!   plus diff mem management of: dw:in scratch:in
  subroutine sstresscale_d()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
    real(kind=realtype) :: temp
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itu1) = -(temp*scratchd(i, j, k, idvt))
          dw(i, j, k, itu1) = -(temp*scratch(i, j, k, idvt))
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itu2) = -(temp*scratchd(i, j, k, idvt+1))
          dw(i, j, k, itu2) = -(temp*scratch(i, j, k, idvt+1))
        end do
      end do
    end do
  end subroutine sstresscale_d

  subroutine sstresscale()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          dw(i, j, k, itu1) = -(volref(i, j, k)*scratch(i, j, k, idvt)*&
&           rblank)
          dw(i, j, k, itu2) = -(volref(i, j, k)*scratch(i, j, k, idvt+1)&
&           *rblank)
        end do
      end do
    end do
  end subroutine sstresscale

!  differentiation of f1sst in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *w *rlv *scratch *d2wall
!   rw status of diff variables: *w:in *rlv:in *scratch:in-out
!                *d2wall:in
!   plus diff mem management of: w:in rlv:in scratch:in d2wall:in
  subroutine f1sst_d()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    use inputphysics, only : use2003sst
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    integer(kind=inttype) :: isize, ibeg, iend
    integer(kind=inttype) :: jsize, jbeg, jend
    integer(kind=inttype) :: ksize, kbeg, kend
    real(kind=realtype) :: t1, t2, arg1, myeps
    real(kind=realtype) :: t1d, t2d, arg1d
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    real(kind=realtype) :: max1
    real(kind=realtype) :: max1d
    real(kind=realtype) :: max2
    real(kind=realtype) :: max2d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: arg10
    real(kind=realtype) :: arg10d
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp4
    real(kind=realtype) :: temp5
    myeps = 1e-10_realtype/two/rsstsigw2
    ibeg = 1
    jbeg = 1
    kbeg = 1
    iend = ie
    jend = je
    kend = ke
    do nn=1,nbocos
      select case  (bcfaceid(nn)) 
      case (imin) 
        ibeg = 2
      case (imax) 
        iend = il
      case (jmin) 
        jbeg = 2
      case (jmax) 
        jend = jl
      case (kmin) 
        kbeg = 2
      case (kmax) 
        kend = kl
      end select
    end do
! compute the blending function f1 for all owned cells.
    do k=kbeg,kend
      do j=jbeg,jend
        do i=ibeg,iend
          temp = w(i, j, k, itu1)
          temp0 = sqrt(temp)
          if (temp .eq. 0.0_8) then
            result1d = 0.0_8
          else
            result1d = wd(i, j, k, itu1)/(2.0*temp0)
          end if
          result1 = temp0
          temp1 = 0.09_realtype*d2wall(i, j, k)
          temp0 = w(i, j, k, itu2)
          temp = temp0*temp1
          t1d = (result1d-result1*(temp1*wd(i, j, k, itu2)+temp0*&
&           0.09_realtype*d2walld(i, j, k))/temp)/temp
          t1 = result1/temp
          temp0 = d2wall(i, j, k)
          temp = w(i, j, k, itu2)
          temp2 = w(i, j, k, irho)
          temp3 = temp2*temp
          temp4 = temp3*(temp0*temp0)
          temp5 = rlv(i, j, k)/temp4
          t2d = 500.0_realtype*(rlvd(i, j, k)-temp5*(temp0**2*(temp*wd(i&
&           , j, k, irho)+temp2*wd(i, j, k, itu2))+temp3*2*temp0*d2walld&
&           (i, j, k)))/temp4
          t2 = 500.0_realtype*temp5
          if (t1 .lt. t2) then
            t1d = t2d
            t1 = t2
          else
            t1 = t1
          end if
          if (use2003sst) then
            if (myeps/w(i, j, k, irho) .lt. scratch(i, j, k, icd)) then
              max1d = scratchd(i, j, k, icd)
              max1 = scratch(i, j, k, icd)
            else
              temp5 = myeps/w(i, j, k, irho)
              max1d = -(temp5*wd(i, j, k, irho)/w(i, j, k, irho))
              max1 = temp5
            end if
            temp5 = d2wall(i, j, k)*d2wall(i, j, k)
            temp4 = w(i, j, k, itu1)/(max1*temp5)
            t2d = two*(wd(i, j, k, itu1)-temp4*(temp5*max1d+max1*2*&
&             d2wall(i, j, k)*d2walld(i, j, k)))/(max1*temp5)
            t2 = two*temp4
          else
            if (eps .lt. scratch(i, j, k, icd)) then
              max2d = scratchd(i, j, k, icd)
              max2 = scratch(i, j, k, icd)
            else
              max2 = eps
              max2d = 0.0_8
            end if
            temp5 = d2wall(i, j, k)*d2wall(i, j, k)
            temp4 = w(i, j, k, itu1)/(max2*temp5)
            t2d = two*(wd(i, j, k, itu1)-temp4*(temp5*max2d+max2*2*&
&             d2wall(i, j, k)*d2walld(i, j, k)))/(max2*temp5)
            t2 = two*temp4
          end if
          if (t1 .gt. t2) then
            arg1d = t2d
            arg1 = t2
          else
            arg1d = t1d
            arg1 = t1
          end if
          arg10d = 4*arg1**3*arg1d
          arg10 = arg1**4
          scratchd(i, j, k, if1sst) = (1.0-tanh(arg10)**2)*arg10d
          scratch(i, j, k, if1sst) = tanh(arg10)
        end do
      end do
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratchd(1, j, k, if1sst) = scratchd(2, j, k, if1sst)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratchd(ie, j, k, if1sst) = scratchd(il, j, k, if1sst)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, 1, k, if1sst) = scratchd(i, 2, k, if1sst)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, je, k, if1sst) = scratchd(i, jl, k, if1sst)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, j, 1, if1sst) = scratchd(i, j, 2, if1sst)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, j, ke, if1sst) = scratchd(i, j, kl, if1sst)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst_d

  subroutine f1sst()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    use inputphysics, only : use2003sst
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    integer(kind=inttype) :: isize, ibeg, iend
    integer(kind=inttype) :: jsize, jbeg, jend
    integer(kind=inttype) :: ksize, kbeg, kend
    real(kind=realtype) :: t1, t2, arg1, myeps
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    real(kind=realtype) :: max1
    real(kind=realtype) :: max2
    real(kind=realtype) :: result1
    real(kind=realtype) :: arg10
    myeps = 1e-10_realtype/two/rsstsigw2
    ibeg = 1
    jbeg = 1
    kbeg = 1
    iend = ie
    jend = je
    kend = ke
    do nn=1,nbocos
      select case  (bcfaceid(nn)) 
      case (imin) 
        ibeg = 2
      case (imax) 
        iend = il
      case (jmin) 
        jbeg = 2
      case (jmax) 
        jend = jl
      case (kmin) 
        kbeg = 2
      case (kmax) 
        kend = kl
      end select
    end do
! compute the blending function f1 for all owned cells.
    do k=kbeg,kend
      do j=jbeg,jend
        do i=ibeg,iend
          result1 = sqrt(w(i, j, k, itu1))
          t1 = result1/(0.09_realtype*w(i, j, k, itu2)*d2wall(i, j, k))
          t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, &
&           itu2)*d2wall(i, j, k)**2)
          if (t1 .lt. t2) then
            t1 = t2
          else
            t1 = t1
          end if
          if (use2003sst) then
            if (myeps/w(i, j, k, irho) .lt. scratch(i, j, k, icd)) then
              max1 = scratch(i, j, k, icd)
            else
              max1 = myeps/w(i, j, k, irho)
            end if
            t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
          else
            if (eps .lt. scratch(i, j, k, icd)) then
              max2 = scratch(i, j, k, icd)
            else
              max2 = eps
            end if
            t2 = two*w(i, j, k, itu1)/(max2*d2wall(i, j, k)**2)
          end if
          if (t1 .gt. t2) then
            arg1 = t2
          else
            arg1 = t1
          end if
          arg10 = arg1**4
          scratch(i, j, k, if1sst) = tanh(arg10)
        end do
      end do
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst

end module sst_d


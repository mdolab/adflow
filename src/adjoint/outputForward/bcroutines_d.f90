!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!      ******************************************************************
!      *                                                                *
!      * file:          bcroutines.f90                                   *
!      * author:        gaetan k. w. kenway                             *
!      * starting date: 01-23-2015                                      *
!      * last modified: 01-23-2015                                      *
!      *                                                                *
!      ******************************************************************
!
!      ******************************************************************
!      *                                                                *
!      * this module contains data structures *and* routines used       *
!      * for applying *all* boundary conditions for navier stokes part  *
!      * of the code. the reason for using a module to contain the      *
!      * routines is that due to the use of pointers, it eliminates the *
!      * need for using interfaces. all former bc*.f90 routines are now *
!      * included in this module.                                       *
!      *                                                                *
!      ******************************************************************
!
module bcroutines_d
  use constants
  implicit none
  save 
  real(kind=realtype), dimension(:, :, :), pointer :: ww0, ww1, ww2, ww3
  real(kind=realtype), dimension(:, :, :), pointer :: ww0d, ww1d, ww2d, &
& ww3d
  real(kind=realtype), dimension(:, :), pointer :: pp0, pp1, pp2, pp3
  real(kind=realtype), dimension(:, :), pointer :: pp0d, pp1d, pp2d, &
& pp3d
  real(kind=realtype), dimension(:, :), pointer :: rlv0, rlv1, rlv2, &
& rlv3
  real(kind=realtype), dimension(:, :), pointer :: rlv0d, rlv1d, rlv2d, &
& rlv3d
  real(kind=realtype), dimension(:, :), pointer :: rev0, rev1, rev2, &
& rev3
  real(kind=realtype), dimension(:, :), pointer :: rev0d, rev1d, rev2d, &
& rev3d
  real(kind=realtype), dimension(:, :), pointer :: gamma0, gamma1, &
& gamma2, gamma3
  real(kind=realtype), dimension(:, :, :), pointer :: ssi, ssj, ssk
  real(kind=realtype), dimension(:, :, :), pointer :: ssid, ssjd, sskd
  real(kind=realtype), dimension(:, :, :), pointer :: ss, xx
  real(kind=realtype), dimension(:, :, :), pointer :: ssd, xxd
  real(kind=realtype), dimension(:, :), pointer :: dd2wall
  integer(kind=inttype) :: istart, iend, isize
  integer(kind=inttype) :: jstart, jend, jsize

contains
!  differentiation of applyallbc_block in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev *p *w *rlv *rev0 *rev1
!                *pp0 *pp1 *rlv0 *rlv1 *ww0 *ww1
!   with respect to varying inputs: gammainf winf pinfcorr rgas
!                *rev *p *s *w *rlv *si *sj *sk *(*bcdata.norm)
!                *(*bcdata.rface) *(*bcdata.uslip) *rev0 *rev1
!                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
!                *rlv3 *ss *ssi *ssj *ssk *ww0 *ww1 *ww2 *ww3
!   plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
!                sj:in sk:in bcdata:in *bcdata.norm:in *bcdata.rface:in
!                *bcdata.uslip:in xx:in-out rev0:in-out rev1:in-out
!                rev2:in-out rev3:in-out pp0:in-out pp1:in-out
!                pp2:in-out pp3:in-out rlv0:in-out rlv1:in-out
!                rlv2:in-out rlv3:in-out ss:in-out ssi:in-out ssj:in-out
!                ssk:in-out ww0:in-out ww1:in-out ww2:in-out ww3:in-out
  subroutine applyallbc_block_d(secondhalo)
! apply bc's for a single block
    use blockpointers
    use flowvarrefstate
    use inputdiscretization
    use inputtimespectral
    use iteration
    use bctypes
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
! local variables.
    logical :: correctfork
    integer(kind=inttype) :: nn
!
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .le. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
! apply all the boundary conditions. the order is important!  only
! some of them have been ad'ed
! ------------------------------------
!  symmetry boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers_d(nn, .false.)
        call bcsymm1sthalo_d(nn)
        call resetbcpointers(nn, .false.)
      end if
    end do
!$ad ii-loop
    if (secondhalo) then
      do nn=1,nbocos
        if (bctype(nn) .eq. symm) then
          call setbcpointers_d(nn, .false.)
          call bcsymm2ndhalo_d(nn)
          call resetbcpointers(nn, .false.)
        end if
      end do
    end if
! ------------------------------------
!  adibatic wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers_d(nn, .false.)
        call bcnswalladiabatic_d(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  isotermal wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers_d(nn, .false.)
        call bcnswallisothermal_d(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  farfield boundary condition 
! ------------------------------------
    if (precond .eq. turkel .or. precond .eq. choimerkle) call &
&     returnfail('applyallbc', &
&      'farfield turkel and coid/merkle preconditioners not implemented'&
&            )
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers_d(nn, .false.)
        call bcfarfield_d(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  euler wall boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. eulerwall) then
        call setbcpointers_d(nn, .true.)
        call bceulerwall_d(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .true.)
      end if
    end do
  end subroutine applyallbc_block_d
  subroutine applyallbc_block(secondhalo)
! apply bc's for a single block
    use blockpointers
    use flowvarrefstate
    use inputdiscretization
    use inputtimespectral
    use iteration
    use bctypes
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
! local variables.
    logical :: correctfork
    integer(kind=inttype) :: nn
!
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .le. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
! apply all the boundary conditions. the order is important!  only
! some of them have been ad'ed
! ------------------------------------
!  symmetry boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers(nn, .false.)
        call bcsymm1sthalo(nn)
        call resetbcpointers(nn, .false.)
      end if
    end do
!$ad ii-loop
    if (secondhalo) then
      do nn=1,nbocos
        if (bctype(nn) .eq. symm) then
          call setbcpointers(nn, .false.)
          call bcsymm2ndhalo(nn)
          call resetbcpointers(nn, .false.)
        end if
      end do
    end if
! ------------------------------------
!  adibatic wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers(nn, .false.)
        call bcnswalladiabatic(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  isotermal wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers(nn, .false.)
        call bcnswallisothermal(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  farfield boundary condition 
! ------------------------------------
    if (precond .eq. turkel .or. precond .eq. choimerkle) call &
&     returnfail('applyallbc', &
&      'farfield turkel and coid/merkle preconditioners not implemented'&
&            )
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers(nn, .false.)
        call bcfarfield(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  euler wall boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. eulerwall) then
        call setbcpointers(nn, .true.)
        call bceulerwall(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .true.)
      end if
    end do
  end subroutine applyallbc_block
!  differentiation of bcsymm1sthalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev1 *pp1 *rlv1 *ww1
!   with respect to varying inputs: *(*bcdata.norm) *rev1 *rev2
!                *pp1 *pp2 *rlv1 *rlv2 *ww1 *ww2
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev1:in
!                rev2:in pp1:in pp2:in rlv1:in rlv2:in ww1:in ww2:in
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm1sthalo_d(nn)
!
! ******************************************************************
! *                                                                *
! * bcsymm applies the symmetry boundary conditions to a block.    *
! * it is assumed that the pointers in blockpointers are already   *
! * set to the correct block on the correct grid level.            *
! *                                                                *
! * in case also the second halo must be set the loop over the     *
! * boundary subfaces is executed twice. this is the only correct  *
! * way in case the block contains only 1 cell between two         *
! * symmetry planes, i.e. a 2d problem.                            *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
! loop over the generic subface to set the state in the
! 1-st level halos 
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vnd = two*(ww2d(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivx)&
&       *bcdatad(nn)%norm(i, j, 1)+ww2d(i, j, ivy)*bcdata(nn)%norm(i, j&
&       , 2)+ww2(i, j, ivy)*bcdatad(nn)%norm(i, j, 2)+ww2d(i, j, ivz)*&
&       bcdata(nn)%norm(i, j, 3)+ww2(i, j, ivz)*bcdatad(nn)%norm(i, j, 3&
&       ))
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww1d(i, j, irho) = ww2d(i, j, irho)
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1d(i, j, ivx) = ww2d(i, j, ivx) - vnd*bcdata(nn)%norm(i, j, 1) -&
&       vn*bcdatad(nn)%norm(i, j, 1)
      ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww1d(i, j, ivy) = ww2d(i, j, ivy) - vnd*bcdata(nn)%norm(i, j, 2) -&
&       vn*bcdatad(nn)%norm(i, j, 2)
      ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww1d(i, j, ivz) = ww2d(i, j, ivz) - vnd*bcdata(nn)%norm(i, j, 3) -&
&       vn*bcdatad(nn)%norm(i, j, 3)
      ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww1d(i, j, irhoe) = ww2d(i, j, irhoe)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! simply copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1d(i, j, l) = ww2d(i, j, l)
        ww1(i, j, l) = ww2(i, j, l)
      end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma1(i, j) = gamma2(i, j)
      pp1d(i, j) = pp2d(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) then
        rlv1d(i, j) = rlv2d(i, j)
        rlv1(i, j) = rlv2(i, j)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev2d(i, j)
        rev1(i, j) = rev2(i, j)
      end if
    end do
  end subroutine bcsymm1sthalo_d
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm1sthalo(nn)
!
! ******************************************************************
! *                                                                *
! * bcsymm applies the symmetry boundary conditions to a block.    *
! * it is assumed that the pointers in blockpointers are already   *
! * set to the correct block on the correct grid level.            *
! *                                                                *
! * in case also the second halo must be set the loop over the     *
! * boundary subfaces is executed twice. this is the only correct  *
! * way in case the block contains only 1 cell between two         *
! * symmetry planes, i.e. a 2d problem.                            *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! loop over the generic subface to set the state in the
! 1-st level halos 
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! simply copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(i, j, l) = ww2(i, j, l)
      end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma1(i, j) = gamma2(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
  end subroutine bcsymm1sthalo
!  differentiation of bcsymm2ndhalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *pp0 *rlv0 *ww0
!   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev3
!                *pp0 *pp3 *rlv0 *rlv3 *ww0 *ww3
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
!                rev3:in pp0:in pp3:in rlv0:in rlv3:in ww0:in ww3:in
  subroutine bcsymm2ndhalo_d(nn)
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
! if we need the second halo, do everything again, but using ww0,
! ww3 etc instead of ww2 and ww1. 
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      vnd = two*(ww3d(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivx)&
&       *bcdatad(nn)%norm(i, j, 1)+ww3d(i, j, ivy)*bcdata(nn)%norm(i, j&
&       , 2)+ww3(i, j, ivy)*bcdatad(nn)%norm(i, j, 2)+ww3d(i, j, ivz)*&
&       bcdata(nn)%norm(i, j, 3)+ww3(i, j, ivz)*bcdatad(nn)%norm(i, j, 3&
&       ))
      vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww0d(i, j, irho) = ww3d(i, j, irho)
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0d(i, j, ivx) = ww3d(i, j, ivx) - vnd*bcdata(nn)%norm(i, j, 1) -&
&       vn*bcdatad(nn)%norm(i, j, 1)
      ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww0d(i, j, ivy) = ww3d(i, j, ivy) - vnd*bcdata(nn)%norm(i, j, 2) -&
&       vn*bcdatad(nn)%norm(i, j, 2)
      ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww0d(i, j, ivz) = ww3d(i, j, ivz) - vnd*bcdata(nn)%norm(i, j, 3) -&
&       vn*bcdatad(nn)%norm(i, j, 3)
      ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww0d(i, j, irhoe) = ww3d(i, j, irhoe)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
      do l=nt1mg,nt2mg
        ww0d(i, j, l) = ww3d(i, j, l)
        ww0(i, j, l) = ww3(i, j, l)
      end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma0(i, j) = gamma3(i, j)
      pp0d(i, j) = pp3d(i, j)
      pp0(i, j) = pp3(i, j)
      if (viscous) then
        rlv0d(i, j) = rlv3d(i, j)
        rlv0(i, j) = rlv3(i, j)
      end if
      if (eddymodel) then
        rev0d(i, j) = rev3d(i, j)
        rev0(i, j) = rev3(i, j)
      end if
    end do
  end subroutine bcsymm2ndhalo_d
  subroutine bcsymm2ndhalo(nn)
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! if we need the second halo, do everything again, but using ww0,
! ww3 etc instead of ww2 and ww1. 
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
      do l=nt1mg,nt2mg
        ww0(i, j, l) = ww3(i, j, l)
      end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma0(i, j) = gamma3(i, j)
      pp0(i, j) = pp3(i, j)
      if (viscous) rlv0(i, j) = rlv3(i, j)
      if (eddymodel) rev0(i, j) = rev3(i, j)
    end do
  end subroutine bcsymm2ndhalo
!  differentiation of bcnswalladiabatic in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: *(*bcdata.uslip) *rev0 *rev1
!                *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1
!                *ww2
!   plus diff mem management of: bcdata:in *bcdata.uslip:in rev0:in
!                rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in rlv1:in
!                rlv2:in ww0:in ww1:in ww2:in
  subroutine bcnswalladiabatic_d(nn, secondhalo, correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * bcnswalladiabatic applies the viscous adiabatic wall           *
!      * boundary condition the pointers already defined.               *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    real(kind=realtype) :: rhokd
    intrinsic mod
! apply the bcwall in case the turbulent transport equations are
! solved together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.  no need
! to extrapolate the secondary halo's, because this is done in
! extrapolate2ndhalo. this is only necesssary when correcting for
! k. *this is not currently included in ad. it will be required
! for the 2-equation turbulence models. 
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
    rhokd = 0.0_8
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        rhokd = ww2d(i, j, irho)*ww2(i, j, itu1) + ww2(i, j, irho)*ww2d(&
&         i, j, itu1)
        rhok = ww2(i, j, irho)*ww2(i, j, itu1)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1d(i, j, irho) = ww2d(i, j, irho)
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1d(i, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - ww2d(i, j, ivx)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1d(i, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - ww2d(i, j, ivy)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1d(i, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - ww2d(i, j, ivz)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
      pp1d(i, j) = pp2d(i, j) - four*third*rhokd
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1d(i, j) = rlv2d(i, j)
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) then
        rev1d(i, j) = -rev2d(i, j)
        rev1(i, j) = -rev2(i, j)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcnswalladiabatic_d
  subroutine bcnswalladiabatic(nn, secondhalo, correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * bcnswalladiabatic applies the viscous adiabatic wall           *
!      * boundary condition the pointers already defined.               *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    intrinsic mod
! apply the bcwall in case the turbulent transport equations are
! solved together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.  no need
! to extrapolate the secondary halo's, because this is done in
! extrapolate2ndhalo. this is only necesssary when correcting for
! k. *this is not currently included in ad. it will be required
! for the 2-equation turbulence models. 
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswalladiabatic
!  differentiation of bcnswallisothermal in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: rgas *(*bcdata.uslip) *rev0
!                *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0
!                *ww1 *ww2
!   plus diff mem management of: bcdata:in *bcdata.uslip:in rev0:in
!                rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in rlv1:in
!                rlv2:in ww0:in ww1:in ww2:in
  subroutine bcnswallisothermal_d(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bcnswalladiabatic applies the viscous isothermal wall          *
! * boundary condition to a block. it is assumed that the          *
! * bcpointers are already set                                     *
! *                                                                *
! ******************************************************************
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok, t2, t1
    real(kind=realtype) :: rhokd, t2d, t1d
    intrinsic mod
    intrinsic max
    intrinsic min
! in case the turbulent transport equations are solved
! together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.
! no need to extrapolate the secondary halo's, because this
! is done in extrapolate2ndhalo.
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
    rhokd = 0.0_8
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        rhokd = ww2d(i, j, irho)*ww2(i, j, itu1) + ww2(i, j, irho)*ww2d(&
&         i, j, itu1)
        rhok = ww2(i, j, irho)*ww2(i, j, itu1)
      end if
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2d = (pp2d(i, j)*rgas*ww2(i, j, irho)-pp2(i, j)*(rgasd*ww2(i, j, &
&       irho)+rgas*ww2d(i, j, irho)))/(rgas*ww2(i, j, irho))**2
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1d = -t2d
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
        t1d = 0.0_8
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
        t1d = 0.0_8
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1d(i, j) = pp2d(i, j) - four*third*rhokd
      pp1(i, j) = pp2(i, j) - four*third*rhok
      ww1d(i, j, irho) = (pp1d(i, j)*rgas*t1-pp1(i, j)*(rgasd*t1+rgas*&
&       t1d))/(rgas*t1)**2
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1d(i, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - ww2d(i, j, ivx)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1d(i, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - ww2d(i, j, ivy)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1d(i, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - ww2d(i, j, ivz)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1d(i, j) = rlv2d(i, j)
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) then
        rev1d(i, j) = -rev2d(i, j)
        rev1(i, j) = -rev2(i, j)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcnswallisothermal_d
  subroutine bcnswallisothermal(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bcnswalladiabatic applies the viscous isothermal wall          *
! * boundary condition to a block. it is assumed that the          *
! * bcpointers are already set                                     *
! *                                                                *
! ******************************************************************
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok, t2, t1
    intrinsic mod
    intrinsic max
    intrinsic min
! in case the turbulent transport equations are solved
! together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.
! no need to extrapolate the secondary halo's, because this
! is done in extrapolate2ndhalo.
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1(i, j) = pp2(i, j) - four*third*rhok
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswallisothermal
!  differentiation of bceulerwall in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: *(*bcdata.norm) *(*bcdata.rface)
!                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1
!                *rlv2 *ss *ssi *ssj *ssk *ww0 *ww1 *ww2
!   plus diff mem management of: bcdata:in *bcdata.norm:in *bcdata.rface:in
!                rev0:in rev1:in rev2:in pp0:in pp1:in pp2:in pp3:in
!                rlv0:in rlv1:in rlv2:in ss:in ssi:in ssj:in ssk:in
!                ww0:in ww1:in ww2:in
  subroutine bceulerwall_d(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bceulerwall applies the inviscid wall boundary condition to    *
! * a block. it is assumed that the bcpointers are                 *
! * already set to the correct block on the correct grid level.    *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: sixad, siyad, sizad, sjxad, sjyad, sjzad
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: skxad, skyad, skzad
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: rxjd, ryjd, rzjd, rxkd, rykd, rzkd
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: dpjd, dpkd, rid, rjd, rkd, qjd, qkd, vnd
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype) :: uuxd, uuyd, uuzd
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: gradd
    intrinsic mod
    intrinsic max
    intrinsic min
    real(kind=realtype) :: dim
    real(kind=realtype) :: dim_d
    integer(kind=inttype) :: max2
    integer(kind=inttype) :: max1
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = wallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
! **************************************************************
! *                                                            *
! * determine the boundary condition treatment and compute the *
! * undivided pressure gradient accordingly. this gradient is  *
! * temporarily stored in the halo pressure.                   *
! *                                                            *
! **************************************************************
!
    select case  (walltreatment) 
    case (constantpressure) 
! constant pressure. set the gradient to zero.
      grad = zero
      gradd = 0.0_8
    case (linextrapolpressure) 
      gradd = 0.0_8
! linear extrapolation. 
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        gradd(j, k) = pp3d(j, k) - pp2d(j, k)
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
    case (normalmomentum) 
      gradd = 0.0_8
! pressure gradient is computed using the normal momentum
! equation. first set a couple of additional variables for
! the normals, depending on the block face. note that the
! construction 1: should not be used in these pointers,
! because element 0 is needed. consequently there will be
! an offset of 1 for these normals. this is commented in
! the code. for moving faces also the grid velocity of
! the 1st cell center from the wall is needed.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
! store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        if (jstart .lt. km1) then
          km1 = km1
        else
          km1 = jstart
        end if
        kp1 = k + 1
        if (jend .gt. kp1) then
          kp1 = kp1
        else
          kp1 = jend
        end if
        if (1_inttype .lt. kp1 - km1) then
          max1 = kp1 - km1
        else
          max1 = 1_inttype
        end if
! compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
! the indices j+1 and j-1. make sure that they
! do not exceed the range of the arrays.
        jm1 = j - 1
        if (istart .lt. jm1) then
          jm1 = jm1
        else
          jm1 = istart
        end if
        jp1 = j + 1
        if (iend .gt. jp1) then
          jp1 = jp1
        else
          jp1 = iend
        end if
        if (1_inttype .lt. jp1 - jm1) then
          max2 = jp1 - jm1
        else
          max2 = 1_inttype
        end if
! compute the scaling factor for the central
! difference in the j-direction.
        a1 = one/max2
! compute (twice) the average normal in the generic i,
! j and k-direction. note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). however due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
        sixad = two*ssid(j, k, 1)
        sixa = two*ssi(j, k, 1)
        siyad = two*ssid(j, k, 2)
        siya = two*ssi(j, k, 2)
        sizad = two*ssid(j, k, 3)
        siza = two*ssi(j, k, 3)
        sjxad = ssjd(j, k, 1) + ssjd(j+1, k, 1)
        sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
        sjyad = ssjd(j, k, 2) + ssjd(j+1, k, 2)
        sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
        sjzad = ssjd(j, k, 3) + ssjd(j+1, k, 3)
        sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
        skxad = sskd(j, k, 1) + sskd(j, k+1, 1)
        skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
        skyad = sskd(j, k, 2) + sskd(j, k+1, 2)
        skya = ssk(j, k, 2) + ssk(j, k+1, 2)
        skzad = sskd(j, k, 3) + sskd(j, k+1, 3)
        skza = ssk(j, k, 3) + ssk(j, k+1, 3)
! compute the difference of the normal vector and
! pressure in j and k-direction. as the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
        rxjd = a1*(bcdatad(nn)%norm(jp1, k, 1)-bcdatad(nn)%norm(jm1, k, &
&         1))
        rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
        ryjd = a1*(bcdatad(nn)%norm(jp1, k, 2)-bcdatad(nn)%norm(jm1, k, &
&         2))
        ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
        rzjd = a1*(bcdatad(nn)%norm(jp1, k, 3)-bcdatad(nn)%norm(jm1, k, &
&         3))
        rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
        dpjd = a1*(pp2d(jp1, k)-pp2d(jm1, k))
        dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
        rxkd = b1*(bcdatad(nn)%norm(j, kp1, 1)-bcdatad(nn)%norm(j, km1, &
&         1))
        rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
        rykd = b1*(bcdatad(nn)%norm(j, kp1, 2)-bcdatad(nn)%norm(j, km1, &
&         2))
        ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
        rzkd = b1*(bcdatad(nn)%norm(j, kp1, 3)-bcdatad(nn)%norm(j, km1, &
&         3))
        rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
        dpkd = b1*(pp2d(j, kp1)-pp2d(j, km1))
        dpk = b1*(pp2(j, kp1)-pp2(j, km1))
! compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
        rid = bcdatad(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 1)*&
&         sixad + bcdatad(nn)%norm(j, k, 2)*siya + bcdata(nn)%norm(j, k&
&         , 2)*siyad + bcdatad(nn)%norm(j, k, 3)*siza + bcdata(nn)%norm(&
&         j, k, 3)*sizad
        ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
&         siya + bcdata(nn)%norm(j, k, 3)*siza
        rjd = bcdatad(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 1)*&
&         sjxad + bcdatad(nn)%norm(j, k, 2)*sjya + bcdata(nn)%norm(j, k&
&         , 2)*sjyad + bcdatad(nn)%norm(j, k, 3)*sjza + bcdata(nn)%norm(&
&         j, k, 3)*sjzad
        rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
&         sjya + bcdata(nn)%norm(j, k, 3)*sjza
        rkd = bcdatad(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 1)*&
&         skxad + bcdatad(nn)%norm(j, k, 2)*skya + bcdata(nn)%norm(j, k&
&         , 2)*skyad + bcdatad(nn)%norm(j, k, 3)*skza + bcdata(nn)%norm(&
&         j, k, 3)*skzad
        rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
&         skya + bcdata(nn)%norm(j, k, 3)*skza
! store the velocity components in uux, uuy and uuz and
! subtract the mesh velocity if the face is moving.
        uuxd = ww2d(j, k, ivx)
        uux = ww2(j, k, ivx)
        uuyd = ww2d(j, k, ivy)
        uuy = ww2(j, k, ivy)
        uuzd = ww2d(j, k, ivz)
        uuz = ww2(j, k, ivz)
        if (addgridvelocities) then
          uuxd = uuxd - ssd(j, k, 1)
          uux = uux - ss(j, k, 1)
          uuyd = uuyd - ssd(j, k, 2)
          uuy = uuy - ss(j, k, 2)
          uuzd = uuzd - ssd(j, k, 3)
          uuz = uuz - ss(j, k, 3)
        end if
! compute the velocity components in j and
! k-direction.
        qjd = uuxd*sjxa + uux*sjxad + uuyd*sjya + uuy*sjyad + uuzd*sjza &
&         + uuz*sjzad
        qj = uux*sjxa + uuy*sjya + uuz*sjza
        qkd = uuxd*skxa + uux*skxad + uuyd*skya + uuy*skyad + uuzd*skza &
&         + uuz*skzad
        qk = uux*skxa + uuy*skya + uuz*skza
! compute the pressure gradient, which is stored
! in pp1. i'm not entirely sure whether this
! formulation is correct for moving meshes. it could
! be that an additional term is needed there.
        gradd(j, k) = (((qjd*(uux*rxj+uuy*ryj+uuz*rzj)+qj*(uuxd*rxj+uux*&
&         rxjd+uuyd*ryj+uuy*ryjd+uuzd*rzj+uuz*rzjd)+qkd*(uux*rxk+uuy*ryk&
&         +uuz*rzk)+qk*(uuxd*rxk+uux*rxkd+uuyd*ryk+uuy*rykd+uuzd*rzk+uuz&
&         *rzkd))*ww2(j, k, irho)+(qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*&
&         rxk+uuy*ryk+uuz*rzk))*ww2d(j, k, irho)-rjd*dpj-rj*dpjd-rkd*dpk&
&         -rk*dpkd)*ri-((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*&
&         ryk+uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)*rid)/ri**2
        grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
&         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
      end do
    case default
      gradd = 0.0_8
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1d(j, k) = dim_d(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k)&
&       , pp1(j, k))
      vnd = two*(bcdatad(nn)%rface(j, k)-ww2d(j, k, ivx)*bcdata(nn)%norm&
&       (j, k, 1)-ww2(j, k, ivx)*bcdatad(nn)%norm(j, k, 1)-ww2d(j, k, &
&       ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivy)*bcdatad(nn)%norm(j&
&       , k, 2)-ww2d(j, k, ivz)*bcdata(nn)%norm(j, k, 3)-ww2(j, k, ivz)*&
&       bcdatad(nn)%norm(j, k, 3))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1d(j, k, irho) = ww2d(j, k, irho)
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1d(j, k, ivx) = ww2d(j, k, ivx) + vnd*bcdata(nn)%norm(j, k, 1) +&
&       vn*bcdatad(nn)%norm(j, k, 1)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1d(j, k, ivy) = ww2d(j, k, ivy) + vnd*bcdata(nn)%norm(j, k, 2) +&
&       vn*bcdatad(nn)%norm(j, k, 2)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1d(j, k, ivz) = ww2d(j, k, ivz) + vnd*bcdata(nn)%norm(j, k, 3) +&
&       vn*bcdatad(nn)%norm(j, k, 3)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! just copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1d(j, k, l) = ww2d(j, k, l)
        ww1(j, k, l) = ww2(j, k, l)
      end do
! the laminar and eddy viscosity, if present.
      if (viscous) then
        rlv1d(j, k) = rlv2d(j, k)
        rlv1(j, k) = rlv2(j, k)
      end if
      if (eddymodel) then
        rev1d(j, k) = rev2d(j, k)
        rev1(j, k) = rev2(j, k)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bceulerwall_d
  subroutine bceulerwall(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bceulerwall applies the inviscid wall boundary condition to    *
! * a block. it is assumed that the bcpointers are                 *
! * already set to the correct block on the correct grid level.    *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    intrinsic mod
    intrinsic max
    intrinsic min
    real(kind=realtype) :: dim
    integer(kind=inttype) :: max2
    integer(kind=inttype) :: max1
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = wallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
! **************************************************************
! *                                                            *
! * determine the boundary condition treatment and compute the *
! * undivided pressure gradient accordingly. this gradient is  *
! * temporarily stored in the halo pressure.                   *
! *                                                            *
! **************************************************************
!
    select case  (walltreatment) 
    case (constantpressure) 
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation. 
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
    case (normalmomentum) 
! pressure gradient is computed using the normal momentum
! equation. first set a couple of additional variables for
! the normals, depending on the block face. note that the
! construction 1: should not be used in these pointers,
! because element 0 is needed. consequently there will be
! an offset of 1 for these normals. this is commented in
! the code. for moving faces also the grid velocity of
! the 1st cell center from the wall is needed.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
! store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        if (jstart .lt. km1) then
          km1 = km1
        else
          km1 = jstart
        end if
        kp1 = k + 1
        if (jend .gt. kp1) then
          kp1 = kp1
        else
          kp1 = jend
        end if
        if (1_inttype .lt. kp1 - km1) then
          max1 = kp1 - km1
        else
          max1 = 1_inttype
        end if
! compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
! the indices j+1 and j-1. make sure that they
! do not exceed the range of the arrays.
        jm1 = j - 1
        if (istart .lt. jm1) then
          jm1 = jm1
        else
          jm1 = istart
        end if
        jp1 = j + 1
        if (iend .gt. jp1) then
          jp1 = jp1
        else
          jp1 = iend
        end if
        if (1_inttype .lt. jp1 - jm1) then
          max2 = jp1 - jm1
        else
          max2 = 1_inttype
        end if
! compute the scaling factor for the central
! difference in the j-direction.
        a1 = one/max2
! compute (twice) the average normal in the generic i,
! j and k-direction. note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). however due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
        sixa = two*ssi(j, k, 1)
        siya = two*ssi(j, k, 2)
        siza = two*ssi(j, k, 3)
        sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
        sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
        sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
        skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
        skya = ssk(j, k, 2) + ssk(j, k+1, 2)
        skza = ssk(j, k, 3) + ssk(j, k+1, 3)
! compute the difference of the normal vector and
! pressure in j and k-direction. as the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
        rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
        ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
        rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
        dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
        rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
        ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
        rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
        dpk = b1*(pp2(j, kp1)-pp2(j, km1))
! compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
        ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
&         siya + bcdata(nn)%norm(j, k, 3)*siza
        rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
&         sjya + bcdata(nn)%norm(j, k, 3)*sjza
        rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
&         skya + bcdata(nn)%norm(j, k, 3)*skza
! store the velocity components in uux, uuy and uuz and
! subtract the mesh velocity if the face is moving.
        uux = ww2(j, k, ivx)
        uuy = ww2(j, k, ivy)
        uuz = ww2(j, k, ivz)
        if (addgridvelocities) then
          uux = uux - ss(j, k, 1)
          uuy = uuy - ss(j, k, 2)
          uuz = uuz - ss(j, k, 3)
        end if
! compute the velocity components in j and
! k-direction.
        qj = uux*sjxa + uuy*sjya + uuz*sjza
        qk = uux*skxa + uuy*skya + uuz*skza
! compute the pressure gradient, which is stored
! in pp1. i'm not entirely sure whether this
! formulation is correct for moving meshes. it could
! be that an additional term is needed there.
        grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
&         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
      end do
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = dim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! just copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(j, k, l) = ww2(j, k, l)
      end do
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bceulerwall
!  differentiation of bcfarfield in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
!                *rlv1 *ww0 *ww1
!   with respect to varying inputs: gammainf winf pinfcorr *(*bcdata.norm)
!                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
!                *ww0 *ww1 *ww2
!   plus diff mem management of: bcdata:in *bcdata.norm:in *bcdata.rface:in
!                rev0:in rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in
!                rlv1:in rlv2:in ww0:in ww1:in ww2:in
  subroutine bcfarfield_d(nn, secondhalo, correctfork)
!      ******************************************************************
!      *                                                                *
!      * bcfarfield applies the farfield boundary condition to a block. *
!      * it is assumed that the bcpointers are already set              *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: gm1d, ovgm1d, ac1d, ac2d
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: r0d, u0d, v0d, w0d, qn0d, c0d, s0d
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: red, ued, ved, wed, qned, ced
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    real(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
    intrinsic sqrt
    intrinsic mod
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwr1d
    real(kind=realtype) :: pwx1
    real(kind=realtype) :: pwx1d
! some constants needed to compute the riemann invariants.
    gm1d = gammainfd
    gm1 = gammainf - one
    ovgm1d = -(one*gm1d/gm1**2)
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0d = -(one*winfd(irho)/winf(irho)**2)
    r0 = one/winf(irho)
    u0d = winfd(ivx)
    u0 = winf(ivx)
    v0d = winfd(ivy)
    v0 = winf(ivy)
    w0d = winfd(ivz)
    w0 = winf(ivz)
    arg1d = (gammainfd*pinfcorr+gammainf*pinfcorrd)*r0 + gammainf*&
&     pinfcorr*r0d
    arg1 = gammainf*pinfcorr*r0
    if (arg1 .eq. 0.0_8) then
      c0d = 0.0_8
    else
      c0d = arg1d/(2.0*sqrt(arg1))
    end if
    c0 = sqrt(arg1)
    if (winf(irho) .gt. 0.0_8) then
      pwr1d = winf(irho)**gammainf*(log(winf(irho))*gammainfd+gammainf*&
&       winfd(irho)/winf(irho))
    else if (winf(irho) .eq. 0.0_8) then
      if (gammainf .eq. 1.0) then
        pwr1d = winfd(irho)
      else
        pwr1d = 0.0_8
      end if
    else if (gammainf .eq. int(gammainf)) then
      pwr1d = gammainf*winf(irho)**(gammainf-1)*winfd(irho)
    else
      pwr1d = 0.0_8
    end if
    pwr1 = winf(irho)**gammainf
    s0d = (pwr1d*pinfcorr-pwr1*pinfcorrd)/pinfcorr**2
    s0 = pwr1/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0d = u0d*bcdata(nn)%norm(i, j, 1) + u0*bcdatad(nn)%norm(i, j, 1)&
&       + v0d*bcdata(nn)%norm(i, j, 2) + v0*bcdatad(nn)%norm(i, j, 2) + &
&       w0d*bcdata(nn)%norm(i, j, 3) + w0*bcdatad(nn)%norm(i, j, 3)
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      red = -(one*ww2d(i, j, irho)/ww2(i, j, irho)**2)
      re = one/ww2(i, j, irho)
      ued = ww2d(i, j, ivx)
      ue = ww2(i, j, ivx)
      ved = ww2d(i, j, ivy)
      ve = ww2(i, j, ivy)
      wed = ww2d(i, j, ivz)
      we = ww2(i, j, ivz)
      qned = ued*bcdata(nn)%norm(i, j, 1) + ue*bcdatad(nn)%norm(i, j, 1)&
&       + ved*bcdata(nn)%norm(i, j, 2) + ve*bcdatad(nn)%norm(i, j, 2) + &
&       wed*bcdata(nn)%norm(i, j, 3) + we*bcdatad(nn)%norm(i, j, 3)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      arg1d = gamma2(i, j)*(pp2d(i, j)*re+pp2(i, j)*red)
      arg1 = gamma2(i, j)*pp2(i, j)*re
      if (arg1 .eq. 0.0_8) then
        ced = 0.0_8
      else
        ced = arg1d/(2.0*sqrt(arg1))
      end if
      ce = sqrt(arg1)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1d = qned + two*(ovgm1d*ce+ovgm1*ced)
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1d = qn0d + two*(ovgm1d*c0+ovgm1*c0d)
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2d = qned - two*(ovgm1d*ce+ovgm1*ced)
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2d = qn0d - two*(ovgm1d*c0+ovgm1*c0d)
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnfd = half*(ac1d+ac2d)
      qnf = half*(ac1+ac2)
      cfd = fourth*((ac1d-ac2d)*gm1+(ac1-ac2)*gm1d)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        ufd = ued + (qnfd-qned)*bcdata(nn)%norm(i, j, 1) + (qnf-qne)*&
&         bcdatad(nn)%norm(i, j, 1)
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vfd = ved + (qnfd-qned)*bcdata(nn)%norm(i, j, 2) + (qnf-qne)*&
&         bcdatad(nn)%norm(i, j, 2)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wfd = wed + (qnfd-qned)*bcdata(nn)%norm(i, j, 3) + (qnf-qne)*&
&         bcdatad(nn)%norm(i, j, 3)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        if (ww2(i, j, irho) .gt. 0.0_8 .or. (ww2(i, j, irho) .lt. 0.0_8 &
&           .and. gamma2(i, j) .eq. int(gamma2(i, j)))) then
          pwr1d = gamma2(i, j)*ww2(i, j, irho)**(gamma2(i, j)-1)*ww2d(i&
&           , j, irho)
        else if (ww2(i, j, irho) .eq. 0.0_8 .and. gamma2(i, j) .eq. 1.0&
&       ) then
          pwr1d = ww2d(i, j, irho)
        else
          pwr1d = 0.0_8
        end if
        pwr1 = ww2(i, j, irho)**gamma2(i, j)
        sfd = (pwr1d*pp2(i, j)-pwr1*pp2d(i, j))/pp2(i, j)**2
        sf = pwr1/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1d(i, j, l) = ww2d(i, j, l)
          ww1(i, j, l) = ww2(i, j, l)
        end do
      else
! inflow
        ufd = u0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 1) + (qnf-qn0)*&
&         bcdatad(nn)%norm(i, j, 1)
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vfd = v0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 2) + (qnf-qn0)*&
&         bcdatad(nn)%norm(i, j, 2)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wfd = w0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 3) + (qnf-qn0)*&
&         bcdatad(nn)%norm(i, j, 3)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sfd = s0d
        sf = s0
        do l=nt1mg,nt2mg
          ww1d(i, j, l) = winfd(l)
          ww1(i, j, l) = winf(l)
        end do
      end if
! compute the density, velocity and pressure in the
! halo cell.
      ccd = (cfd*cf+cf*cfd)/gamma2(i, j)
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      pwx1d = sfd*cc + sf*ccd
      pwx1 = sf*cc
      if (pwx1 .gt. 0.0_8) then
        ww1d(i, j, irho) = pwx1**ovgm1*(log(pwx1)*ovgm1d+ovgm1*pwx1d/&
&         pwx1)
      else if (pwx1 .eq. 0.0_8) then
        if (ovgm1 .eq. 1.0) then
          ww1d(i, j, irho) = pwx1d
        else
          ww1d(i, j, irho) = 0.0_8
        end if
      else if (ovgm1 .eq. int(ovgm1)) then
        ww1d(i, j, irho) = ovgm1*pwx1**(ovgm1-1)*pwx1d
      else
        ww1d(i, j, irho) = 0.0_8
      end if
      ww1(i, j, irho) = pwx1**ovgm1
      ww1d(i, j, ivx) = ufd
      ww1(i, j, ivx) = uf
      ww1d(i, j, ivy) = vfd
      ww1(i, j, ivy) = vf
      ww1d(i, j, ivz) = wfd
      ww1(i, j, ivz) = wf
      pp1d(i, j) = ww1d(i, j, irho)*cc + ww1(i, j, irho)*ccd
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) then
        rlv1d(i, j) = rlv2d(i, j)
        rlv1(i, j) = rlv2(i, j)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev2d(i, j)
        rev1(i, j) = rev2(i, j)
      end if
    end do
! compute the energy for these halo's.
    call computeetot_d(ww1, ww1d, pp1, pp1d, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_d(correctfork)
  end subroutine bcfarfield_d
  subroutine bcfarfield(nn, secondhalo, correctfork)
!      ******************************************************************
!      *                                                                *
!      * bcfarfield applies the farfield boundary condition to a block. *
!      * it is assumed that the bcpointers are already set              *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    intrinsic sqrt
    intrinsic mod
    real(kind=realtype) :: arg1
    real(kind=realtype) :: pwr1
    real(kind=realtype) :: pwx1
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    arg1 = gammainf*pinfcorr*r0
    c0 = sqrt(arg1)
    pwr1 = winf(irho)**gammainf
    s0 = pwr1/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      arg1 = gamma2(i, j)*pp2(i, j)*re
      ce = sqrt(arg1)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        pwr1 = ww2(i, j, irho)**gamma2(i, j)
        sf = pwr1/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
        end do
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        do l=nt1mg,nt2mg
          ww1(i, j, l) = winf(l)
        end do
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      pwx1 = sf*cc
      ww1(i, j, irho) = pwx1**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcfarfield
!  differentiation of extrapolate2ndhalo in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *rev0 *pp0 *rlv0 *ww0
!   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
!                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
  subroutine extrapolate2ndhalo_d(correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * extrapolate2ndhalo determines the states of the second layer   *
!      * halo cells for the given subface of the block. it is assumed   *
!      * that the appropriate bcpointers are already set
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use constants
    use flowvarrefstate
    use iteration
    use inputphysics
    implicit none
    logical, intent(in) :: correctfork
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0d(i, j, irho) = two*ww1d(i, j, irho) - ww2d(i, j, irho)
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0d(i, j, irho) = factor*ww1d(i, j, irho)
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0d(i, j, ivx) = two*ww1d(i, j, ivx) - ww2d(i, j, ivx)
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0d(i, j, ivy) = two*ww1d(i, j, ivy) - ww2d(i, j, ivy)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0d(i, j, ivz) = two*ww1d(i, j, ivz) - ww2d(i, j, ivz)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0d(i, j) = two*pp1d(i, j) - pp2d(i, j)
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0d(i, j) = factor*pp1d(i, j)
        pp0(i, j) = factor*pp1(i, j)
      end if
! extrapolate the turbulent variables. use constant
! extrapolation.
      do l=nt1mg,nt2mg
        ww0d(i, j, l) = ww1d(i, j, l)
        ww0(i, j, l) = ww1(i, j, l)
      end do
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) then
        rlv0d(i, j) = rlv1d(i, j)
        rlv0(i, j) = rlv1(i, j)
      end if
      if (eddymodel) then
        rev0d(i, j) = rev1d(i, j)
        rev0(i, j) = rev1(i, j)
      end if
    end do
! compute the energy for this halo range.
    call computeetot_d(ww0, ww0d, pp0, pp0d, correctfork)
  end subroutine extrapolate2ndhalo_d
!  differentiation of computeetot in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: ww
!   with respect to varying inputs: ww pp
  subroutine computeetot_d(ww, wwd, pp, ppd, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use flowvarrefstate
    use inputphysics
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :) :: ppd
    real(kind=realtype), dimension(:, :, :) :: ww
    real(kind=realtype), dimension(:, :, :) :: wwd
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
! loop over the given array and compute the energy, possibly
! correcting for k
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          wwd(i, j, irhoe) = ovgm1*ppd(i, j) + half*(wwd(i, j, irho)*(ww&
&           (i, j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)+ww(i, j, &
&           irho)*(2*ww(i, j, ivx)*wwd(i, j, ivx)+2*ww(i, j, ivy)*wwd(i&
&           , j, ivy)+2*ww(i, j, ivz)*wwd(i, j, ivz)))
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
        else
          wwd(i, j, irhoe) = ovgm1*ppd(i, j) + half*(wwd(i, j, irho)*(ww&
&           (i, j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)+ww(i, j, &
&           irho)*(2*ww(i, j, ivx)*wwd(i, j, ivx)+2*ww(i, j, ivy)*wwd(i&
&           , j, ivy)+2*ww(i, j, ivz)*wwd(i, j, ivz))) - factk*(wwd(i, j&
&           , irho)*ww(i, j, itu1)+ww(i, j, irho)*wwd(i, j, itu1))
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
&           j, irho)*ww(i, j, itu1)
        end if
      end do
    case (cptempcurvefits) 
      call returnfail('bcroutines', &
&                  'cptempcurvefits not implemented yet.')
    end select
  end subroutine computeetot_d
  subroutine extrapolate2ndhalo(correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * extrapolate2ndhalo determines the states of the second layer   *
!      * halo cells for the given subface of the block. it is assumed   *
!      * that the appropriate bcpointers are already set
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use constants
    use flowvarrefstate
    use iteration
    use inputphysics
    implicit none
    logical, intent(in) :: correctfork
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! extrapolate the turbulent variables. use constant
! extrapolation.
      do l=nt1mg,nt2mg
        ww0(i, j, l) = ww1(i, j, l)
      end do
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
! compute the energy for this halo range.
    call computeetot(ww0, pp0, correctfork)
  end subroutine extrapolate2ndhalo
  subroutine computeetot(ww, pp, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use flowvarrefstate
    use inputphysics
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :, :) :: ww
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
! loop over the given array and compute the energy, possibly
! correcting for k
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
        else
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
&           j, irho)*ww(i, j, itu1)
        end if
      end do
    case (cptempcurvefits) 
      call returnfail('bcroutines', &
&                  'cptempcurvefits not implemented yet.')
    end select
  end subroutine computeetot
!  differentiation of setbcpointers in forward (tangent) mode (with options i4 dr8 r8):
!   plus diff mem management of: rev:in p:in s:in w:in rlv:in x:in
!                si:in sj:in sk:in bcdata:in xx:in-out rev0:in-out
!                rev1:in-out rev2:in-out rev3:in-out pp0:in-out
!                pp1:in-out pp2:in-out pp3:in-out rlv0:in-out rlv1:in-out
!                rlv2:in-out rlv3:in-out ss:in-out ssi:in-out ssj:in-out
!                ssk:in-out ww0:in-out ww1:in-out ww2:in-out ww3:in-out
  subroutine setbcpointers_d(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * setbcpointers sets the pointers needed for the boundary        *
!      * condition treatment on a general face, such that the boundary  *
!      * routines are only implemented once instead of 6 times.         *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    use inputphysics
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      ww3d => wd(3, 1:, 1:, :)
      ww3 => w(3, 1:, 1:, :)
      ww2d => wd(2, 1:, 1:, :)
      ww2 => w(2, 1:, 1:, :)
      ww1d => wd(1, 1:, 1:, :)
      ww1 => w(1, 1:, 1:, :)
      ww0d => wd(0, 1:, 1:, :)
      ww0 => w(0, 1:, 1:, :)
      pp3d => pd(3, 1:, 1:)
      pp3 => p(3, 1:, 1:)
      pp2d => pd(2, 1:, 1:)
      pp2 => p(2, 1:, 1:)
      pp1d => pd(1, 1:, 1:)
      pp1 => p(1, 1:, 1:)
      pp0d => pd(0, 1:, 1:)
      pp0 => p(0, 1:, 1:)
      rlv3d => rlvd(3, 1:, 1:)
      rlv3 => rlv(3, 1:, 1:)
      rlv2d => rlvd(2, 1:, 1:)
      rlv2 => rlv(2, 1:, 1:)
      rlv1d => rlvd(1, 1:, 1:)
      rlv1 => rlv(1, 1:, 1:)
      rlv0d => rlvd(0, 1:, 1:)
      rlv0 => rlv(0, 1:, 1:)
      rev3d => revd(3, 1:, 1:)
      rev3 => rev(3, 1:, 1:)
      rev2d => revd(2, 1:, 1:)
      rev2 => rev(2, 1:, 1:)
      rev1d => revd(1, 1:, 1:)
      rev1 => rev(1, 1:, 1:)
      rev0d => revd(0, 1:, 1:)
      rev0 => rev(0, 1:, 1:)
      gamma3 => gamma(3, 1:, 1:)
      gamma2 => gamma(2, 1:, 1:)
      gamma1 => gamma(1, 1:, 1:)
      gamma0 => gamma(0, 1:, 1:)
    case (imax) 
!===============================================================
      ww3d => wd(nx, 1:, 1:, :)
      ww3 => w(nx, 1:, 1:, :)
      ww2d => wd(il, 1:, 1:, :)
      ww2 => w(il, 1:, 1:, :)
      ww1d => wd(ie, 1:, 1:, :)
      ww1 => w(ie, 1:, 1:, :)
      ww0d => wd(ib, 1:, 1:, :)
      ww0 => w(ib, 1:, 1:, :)
      pp3d => pd(nx, 1:, 1:)
      pp3 => p(nx, 1:, 1:)
      pp2d => pd(il, 1:, 1:)
      pp2 => p(il, 1:, 1:)
      pp1d => pd(ie, 1:, 1:)
      pp1 => p(ie, 1:, 1:)
      pp0d => pd(ib, 1:, 1:)
      pp0 => p(ib, 1:, 1:)
      rlv3d => rlvd(nx, 1:, 1:)
      rlv3 => rlv(nx, 1:, 1:)
      rlv2d => rlvd(il, 1:, 1:)
      rlv2 => rlv(il, 1:, 1:)
      rlv1d => rlvd(ie, 1:, 1:)
      rlv1 => rlv(ie, 1:, 1:)
      rlv0d => rlvd(ib, 1:, 1:)
      rlv0 => rlv(ib, 1:, 1:)
      rev3d => revd(nx, 1:, 1:)
      rev3 => rev(nx, 1:, 1:)
      rev2d => revd(il, 1:, 1:)
      rev2 => rev(il, 1:, 1:)
      rev1d => revd(ie, 1:, 1:)
      rev1 => rev(ie, 1:, 1:)
      rev0d => revd(ib, 1:, 1:)
      rev0 => rev(ib, 1:, 1:)
      gamma3 => gamma(nx, 1:, 1:)
      gamma2 => gamma(il, 1:, 1:)
      gamma1 => gamma(ie, 1:, 1:)
      gamma0 => gamma(ib, 1:, 1:)
    case (jmin) 
!===============================================================
      ww3d => wd(1:, 3, 1:, :)
      ww3 => w(1:, 3, 1:, :)
      ww2d => wd(1:, 2, 1:, :)
      ww2 => w(1:, 2, 1:, :)
      ww1d => wd(1:, 1, 1:, :)
      ww1 => w(1:, 1, 1:, :)
      ww0d => wd(1:, 0, 1:, :)
      ww0 => w(1:, 0, 1:, :)
      pp3d => pd(1:, 3, 1:)
      pp3 => p(1:, 3, 1:)
      pp2d => pd(1:, 2, 1:)
      pp2 => p(1:, 2, 1:)
      pp1d => pd(1:, 1, 1:)
      pp1 => p(1:, 1, 1:)
      pp0d => pd(1:, 0, 1:)
      pp0 => p(1:, 0, 1:)
      rlv3d => rlvd(1:, 3, 1:)
      rlv3 => rlv(1:, 3, 1:)
      rlv2d => rlvd(1:, 2, 1:)
      rlv2 => rlv(1:, 2, 1:)
      rlv1d => rlvd(1:, 1, 1:)
      rlv1 => rlv(1:, 1, 1:)
      rlv0d => rlvd(1:, 0, 1:)
      rlv0 => rlv(1:, 0, 1:)
      rev3d => revd(1:, 3, 1:)
      rev3 => rev(1:, 3, 1:)
      rev2d => revd(1:, 2, 1:)
      rev2 => rev(1:, 2, 1:)
      rev1d => revd(1:, 1, 1:)
      rev1 => rev(1:, 1, 1:)
      rev0d => revd(1:, 0, 1:)
      rev0 => rev(1:, 0, 1:)
      gamma3 => gamma(1:, 3, 1:)
      gamma2 => gamma(1:, 2, 1:)
      gamma1 => gamma(1:, 1, 1:)
      gamma0 => gamma(1:, 0, 1:)
    case (jmax) 
!===============================================================
      ww3d => wd(1:, ny, 1:, :)
      ww3 => w(1:, ny, 1:, :)
      ww2d => wd(1:, jl, 1:, :)
      ww2 => w(1:, jl, 1:, :)
      ww1d => wd(1:, je, 1:, :)
      ww1 => w(1:, je, 1:, :)
      ww0d => wd(1:, jb, 1:, :)
      ww0 => w(1:, jb, 1:, :)
      pp3d => pd(1:, ny, 1:)
      pp3 => p(1:, ny, 1:)
      pp2d => pd(1:, jl, 1:)
      pp2 => p(1:, jl, 1:)
      pp1d => pd(1:, je, 1:)
      pp1 => p(1:, je, 1:)
      pp0d => pd(1:, jb, 1:)
      pp0 => p(1:, jb, 1:)
      rlv3d => rlvd(1:, ny, 1:)
      rlv3 => rlv(1:, ny, 1:)
      rlv2d => rlvd(1:, jl, 1:)
      rlv2 => rlv(1:, jl, 1:)
      rlv1d => rlvd(1:, je, 1:)
      rlv1 => rlv(1:, je, 1:)
      rlv0d => rlvd(1:, jb, 1:)
      rlv0 => rlv(1:, jb, 1:)
      rev3d => revd(1:, ny, 1:)
      rev3 => rev(1:, ny, 1:)
      rev2d => revd(1:, jl, 1:)
      rev2 => rev(1:, jl, 1:)
      rev1d => revd(1:, je, 1:)
      rev1 => rev(1:, je, 1:)
      rev0d => revd(1:, jb, 1:)
      rev0 => rev(1:, jb, 1:)
      gamma3 => gamma(1:, ny, 1:)
      gamma2 => gamma(1:, jl, 1:)
      gamma1 => gamma(1:, je, 1:)
      gamma0 => gamma(1:, jb, 1:)
    case (kmin) 
!===============================================================
      ww3d => wd(1:, 1:, 3, :)
      ww3 => w(1:, 1:, 3, :)
      ww2d => wd(1:, 1:, 2, :)
      ww2 => w(1:, 1:, 2, :)
      ww1d => wd(1:, 1:, 1, :)
      ww1 => w(1:, 1:, 1, :)
      ww0d => wd(1:, 1:, 0, :)
      ww0 => w(1:, 1:, 0, :)
      pp3d => pd(1:, 1:, 3)
      pp3 => p(1:, 1:, 3)
      pp2d => pd(1:, 1:, 2)
      pp2 => p(1:, 1:, 2)
      pp1d => pd(1:, 1:, 1)
      pp1 => p(1:, 1:, 1)
      pp0d => pd(1:, 1:, 0)
      pp0 => p(1:, 1:, 0)
      rlv3d => rlvd(1:, 1:, 3)
      rlv3 => rlv(1:, 1:, 3)
      rlv2d => rlvd(1:, 1:, 2)
      rlv2 => rlv(1:, 1:, 2)
      rlv1d => rlvd(1:, 1:, 1)
      rlv1 => rlv(1:, 1:, 1)
      rlv0d => rlvd(1:, 1:, 0)
      rlv0 => rlv(1:, 1:, 0)
      rev3d => revd(1:, 1:, 3)
      rev3 => rev(1:, 1:, 3)
      rev2d => revd(1:, 1:, 2)
      rev2 => rev(1:, 1:, 2)
      rev1d => revd(1:, 1:, 1)
      rev1 => rev(1:, 1:, 1)
      rev0d => revd(1:, 1:, 0)
      rev0 => rev(1:, 1:, 0)
      gamma3 => gamma(1:, 1:, 3)
      gamma2 => gamma(1:, 1:, 2)
      gamma1 => gamma(1:, 1:, 1)
      gamma0 => gamma(1:, 1:, 0)
    case (kmax) 
!===============================================================
      ww3d => wd(1:, 1:, nz, :)
      ww3 => w(1:, 1:, nz, :)
      ww2d => wd(1:, 1:, kl, :)
      ww2 => w(1:, 1:, kl, :)
      ww1d => wd(1:, 1:, ke, :)
      ww1 => w(1:, 1:, ke, :)
      ww0d => wd(1:, 1:, kb, :)
      ww0 => w(1:, 1:, kb, :)
      pp3d => pd(1:, 1:, nz)
      pp3 => p(1:, 1:, nz)
      pp2d => pd(1:, 1:, kl)
      pp2 => p(1:, 1:, kl)
      pp1d => pd(1:, 1:, ke)
      pp1 => p(1:, 1:, ke)
      pp0d => pd(1:, 1:, kb)
      pp0 => p(1:, 1:, kb)
      rlv3d => rlvd(1:, 1:, nz)
      rlv3 => rlv(1:, 1:, nz)
      rlv2d => rlvd(1:, 1:, kl)
      rlv2 => rlv(1:, 1:, kl)
      rlv1d => rlvd(1:, 1:, ke)
      rlv1 => rlv(1:, 1:, ke)
      rlv0d => rlvd(1:, 1:, kb)
      rlv0 => rlv(1:, 1:, kb)
      rev3d => revd(1:, 1:, nz)
      rev3 => rev(1:, 1:, nz)
      rev2d => revd(1:, 1:, kl)
      rev2 => rev(1:, 1:, kl)
      rev1d => revd(1:, 1:, ke)
      rev1 => rev(1:, 1:, ke)
      rev0d => revd(1:, 1:, kb)
      rev0 => rev(1:, 1:, kb)
      gamma3 => gamma(1:, 1:, nz)
      gamma2 => gamma(1:, 1:, kl)
      gamma1 => gamma(1:, 1:, ke)
      gamma0 => gamma(1:, 1:, kb)
    end select
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xxd => xd(1, :, :, :)
        xx => x(1, :, :, :)
        ssid => sid(1, :, :, :)
        ssi => si(1, :, :, :)
        ssjd => sjd(2, :, :, :)
        ssj => sj(2, :, :, :)
        sskd => skd(2, :, :, :)
        ssk => sk(2, :, :, :)
        ssd => sd(2, :, :, :)
        ss => s(2, :, :, :)
      case (imax) 
        xxd => xd(il, :, :, :)
        xx => x(il, :, :, :)
        ssid => sid(il, :, :, :)
        ssi => si(il, :, :, :)
        ssjd => sjd(il, :, :, :)
        ssj => sj(il, :, :, :)
        sskd => skd(il, :, :, :)
        ssk => sk(il, :, :, :)
        ssd => sd(il, :, :, :)
        ss => s(il, :, :, :)
      case (jmin) 
        xxd => xd(:, 1, :, :)
        xx => x(:, 1, :, :)
        ssid => sjd(:, 1, :, :)
        ssi => sj(:, 1, :, :)
        ssjd => sid(:, 2, :, :)
        ssj => si(:, 2, :, :)
        sskd => skd(:, 2, :, :)
        ssk => sk(:, 2, :, :)
        ssd => sd(:, 2, :, :)
        ss => s(:, 2, :, :)
      case (jmax) 
        xxd => xd(:, jl, :, :)
        xx => x(:, jl, :, :)
        ssid => sjd(:, jl, :, :)
        ssi => sj(:, jl, :, :)
        ssjd => sid(:, jl, :, :)
        ssj => si(:, jl, :, :)
        sskd => skd(:, jl, :, :)
        ssk => sk(:, jl, :, :)
        ssd => sd(:, jl, :, :)
        ss => s(:, jl, :, :)
      case (kmin) 
        xxd => xd(:, :, 1, :)
        xx => x(:, :, 1, :)
        ssid => skd(:, :, 1, :)
        ssi => sk(:, :, 1, :)
        ssjd => sid(:, :, 2, :)
        ssj => si(:, :, 2, :)
        sskd => sjd(:, :, 2, :)
        ssk => sj(:, :, 2, :)
        ssd => sd(:, :, 2, :)
        ss => s(:, :, 2, :)
      case (kmax) 
        xxd => xd(:, :, kl, :)
        xx => x(:, :, kl, :)
        ssid => skd(:, :, kl, :)
        ssi => sk(:, :, kl, :)
        ssjd => sid(:, :, kl, :)
        ssj => si(:, :, kl, :)
        sskd => sjd(:, :, kl, :)
        ssk => sj(:, :, kl, :)
        ssd => sd(:, :, kl, :)
        ss => s(:, :, kl, :)
      end select
      if (equations .eq. ransequations) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          dd2wall => d2wall(2, :, :)
        case (imax) 
          dd2wall => d2wall(il, :, :)
        case (jmin) 
          dd2wall => d2wall(:, 2, :)
        case (jmax) 
          dd2wall => d2wall(:, jl, :)
        case (kmin) 
          dd2wall => d2wall(:, :, 2)
        case (kmax) 
          dd2wall => d2wall(:, :, kl)
        end select
      end if
    end if
  end subroutine setbcpointers_d
  subroutine setbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * setbcpointers sets the pointers needed for the boundary        *
!      * condition treatment on a general face, such that the boundary  *
!      * routines are only implemented once instead of 6 times.         *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    use inputphysics
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      ww3 => w(3, 1:, 1:, :)
      ww2 => w(2, 1:, 1:, :)
      ww1 => w(1, 1:, 1:, :)
      ww0 => w(0, 1:, 1:, :)
      pp3 => p(3, 1:, 1:)
      pp2 => p(2, 1:, 1:)
      pp1 => p(1, 1:, 1:)
      pp0 => p(0, 1:, 1:)
      rlv3 => rlv(3, 1:, 1:)
      rlv2 => rlv(2, 1:, 1:)
      rlv1 => rlv(1, 1:, 1:)
      rlv0 => rlv(0, 1:, 1:)
      rev3 => rev(3, 1:, 1:)
      rev2 => rev(2, 1:, 1:)
      rev1 => rev(1, 1:, 1:)
      rev0 => rev(0, 1:, 1:)
      gamma3 => gamma(3, 1:, 1:)
      gamma2 => gamma(2, 1:, 1:)
      gamma1 => gamma(1, 1:, 1:)
      gamma0 => gamma(0, 1:, 1:)
    case (imax) 
!===============================================================
      ww3 => w(nx, 1:, 1:, :)
      ww2 => w(il, 1:, 1:, :)
      ww1 => w(ie, 1:, 1:, :)
      ww0 => w(ib, 1:, 1:, :)
      pp3 => p(nx, 1:, 1:)
      pp2 => p(il, 1:, 1:)
      pp1 => p(ie, 1:, 1:)
      pp0 => p(ib, 1:, 1:)
      rlv3 => rlv(nx, 1:, 1:)
      rlv2 => rlv(il, 1:, 1:)
      rlv1 => rlv(ie, 1:, 1:)
      rlv0 => rlv(ib, 1:, 1:)
      rev3 => rev(nx, 1:, 1:)
      rev2 => rev(il, 1:, 1:)
      rev1 => rev(ie, 1:, 1:)
      rev0 => rev(ib, 1:, 1:)
      gamma3 => gamma(nx, 1:, 1:)
      gamma2 => gamma(il, 1:, 1:)
      gamma1 => gamma(ie, 1:, 1:)
      gamma0 => gamma(ib, 1:, 1:)
    case (jmin) 
!===============================================================
      ww3 => w(1:, 3, 1:, :)
      ww2 => w(1:, 2, 1:, :)
      ww1 => w(1:, 1, 1:, :)
      ww0 => w(1:, 0, 1:, :)
      pp3 => p(1:, 3, 1:)
      pp2 => p(1:, 2, 1:)
      pp1 => p(1:, 1, 1:)
      pp0 => p(1:, 0, 1:)
      rlv3 => rlv(1:, 3, 1:)
      rlv2 => rlv(1:, 2, 1:)
      rlv1 => rlv(1:, 1, 1:)
      rlv0 => rlv(1:, 0, 1:)
      rev3 => rev(1:, 3, 1:)
      rev2 => rev(1:, 2, 1:)
      rev1 => rev(1:, 1, 1:)
      rev0 => rev(1:, 0, 1:)
      gamma3 => gamma(1:, 3, 1:)
      gamma2 => gamma(1:, 2, 1:)
      gamma1 => gamma(1:, 1, 1:)
      gamma0 => gamma(1:, 0, 1:)
    case (jmax) 
!===============================================================
      ww3 => w(1:, ny, 1:, :)
      ww2 => w(1:, jl, 1:, :)
      ww1 => w(1:, je, 1:, :)
      ww0 => w(1:, jb, 1:, :)
      pp3 => p(1:, ny, 1:)
      pp2 => p(1:, jl, 1:)
      pp1 => p(1:, je, 1:)
      pp0 => p(1:, jb, 1:)
      rlv3 => rlv(1:, ny, 1:)
      rlv2 => rlv(1:, jl, 1:)
      rlv1 => rlv(1:, je, 1:)
      rlv0 => rlv(1:, jb, 1:)
      rev3 => rev(1:, ny, 1:)
      rev2 => rev(1:, jl, 1:)
      rev1 => rev(1:, je, 1:)
      rev0 => rev(1:, jb, 1:)
      gamma3 => gamma(1:, ny, 1:)
      gamma2 => gamma(1:, jl, 1:)
      gamma1 => gamma(1:, je, 1:)
      gamma0 => gamma(1:, jb, 1:)
    case (kmin) 
!===============================================================
      ww3 => w(1:, 1:, 3, :)
      ww2 => w(1:, 1:, 2, :)
      ww1 => w(1:, 1:, 1, :)
      ww0 => w(1:, 1:, 0, :)
      pp3 => p(1:, 1:, 3)
      pp2 => p(1:, 1:, 2)
      pp1 => p(1:, 1:, 1)
      pp0 => p(1:, 1:, 0)
      rlv3 => rlv(1:, 1:, 3)
      rlv2 => rlv(1:, 1:, 2)
      rlv1 => rlv(1:, 1:, 1)
      rlv0 => rlv(1:, 1:, 0)
      rev3 => rev(1:, 1:, 3)
      rev2 => rev(1:, 1:, 2)
      rev1 => rev(1:, 1:, 1)
      rev0 => rev(1:, 1:, 0)
      gamma3 => gamma(1:, 1:, 3)
      gamma2 => gamma(1:, 1:, 2)
      gamma1 => gamma(1:, 1:, 1)
      gamma0 => gamma(1:, 1:, 0)
    case (kmax) 
!===============================================================
      ww3 => w(1:, 1:, nz, :)
      ww2 => w(1:, 1:, kl, :)
      ww1 => w(1:, 1:, ke, :)
      ww0 => w(1:, 1:, kb, :)
      pp3 => p(1:, 1:, nz)
      pp2 => p(1:, 1:, kl)
      pp1 => p(1:, 1:, ke)
      pp0 => p(1:, 1:, kb)
      rlv3 => rlv(1:, 1:, nz)
      rlv2 => rlv(1:, 1:, kl)
      rlv1 => rlv(1:, 1:, ke)
      rlv0 => rlv(1:, 1:, kb)
      rev3 => rev(1:, 1:, nz)
      rev2 => rev(1:, 1:, kl)
      rev1 => rev(1:, 1:, ke)
      rev0 => rev(1:, 1:, kb)
      gamma3 => gamma(1:, 1:, nz)
      gamma2 => gamma(1:, 1:, kl)
      gamma1 => gamma(1:, 1:, ke)
      gamma0 => gamma(1:, 1:, kb)
    end select
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xx => x(1, :, :, :)
        ssi => si(1, :, :, :)
        ssj => sj(2, :, :, :)
        ssk => sk(2, :, :, :)
        ss => s(2, :, :, :)
      case (imax) 
        xx => x(il, :, :, :)
        ssi => si(il, :, :, :)
        ssj => sj(il, :, :, :)
        ssk => sk(il, :, :, :)
        ss => s(il, :, :, :)
      case (jmin) 
        xx => x(:, 1, :, :)
        ssi => sj(:, 1, :, :)
        ssj => si(:, 2, :, :)
        ssk => sk(:, 2, :, :)
        ss => s(:, 2, :, :)
      case (jmax) 
        xx => x(:, jl, :, :)
        ssi => sj(:, jl, :, :)
        ssj => si(:, jl, :, :)
        ssk => sk(:, jl, :, :)
        ss => s(:, jl, :, :)
      case (kmin) 
        xx => x(:, :, 1, :)
        ssi => sk(:, :, 1, :)
        ssj => si(:, :, 2, :)
        ssk => sj(:, :, 2, :)
        ss => s(:, :, 2, :)
      case (kmax) 
        xx => x(:, :, kl, :)
        ssi => sk(:, :, kl, :)
        ssj => si(:, :, kl, :)
        ssk => sj(:, :, kl, :)
        ss => s(:, :, kl, :)
      end select
      if (equations .eq. ransequations) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          dd2wall => d2wall(2, :, :)
        case (imax) 
          dd2wall => d2wall(il, :, :)
        case (jmin) 
          dd2wall => d2wall(:, 2, :)
        case (jmax) 
          dd2wall => d2wall(:, jl, :)
        case (kmin) 
          dd2wall => d2wall(:, :, 2)
        case (kmax) 
          dd2wall => d2wall(:, :, kl)
        end select
      end if
    end if
  end subroutine setbcpointers
  subroutine resetbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * resetbcpointers nullifyies the boundary pointers. for reverse  *
!      * mode ad it copies the values back in to the respective arrays  *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    implicit none
! for forward mode we are using pointers so we just don't do
! anything.
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
  end subroutine resetbcpointers
end module bcroutines_d

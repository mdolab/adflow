   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of bcsymmnkpc in forward (tangent) mode:
   !   variations   of useful results: padj wadj
   !   with respect to varying inputs: padj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcSymmAdj.f90                                   *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 04-17-2008                                      *
   !      * Last modified: 04-17-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCSYMMNKPC_D(wadj, wadjd, padj, padjd, normadj, icell, jcell&
   &  , kcell, secondhalo, nnn, level, sps, sps2)
   USE FLOWVARREFSTATE
   USE BLOCKPOINTERS, ONLY : ie, ib, il, je, jb, jl, ke, kb, kl, nbocos&
   &  , gamma, bcfaceid, bctype, bcdata
   USE INPUTTIMESPECTRAL
   USE BCTYPES
   USE CONSTANTS
   USE ITERATION
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcSymmAdj applies the symmetry boundary conditions to a single *
   !      * cell stencil.
   !      * It is assumed that the pointers in blockPointers are already   *
   !      * set to the correct block on the correct grid level.            *
   !      *                                                                *
   !      * In case also the second halo must be set the loop over the     *
   !      * boundary subfaces is executed twice. This is the only correct  *
   !      * way in case the block contains only 1 cell between two         *
   !      * symmetry planes, i.e. a 2D problem.                            *
   !      *                                                                *
   !      ******************************************************************
   !
   !nw
   !nt1mg,nt2mg
   !nIntervalTimespectral
   !
   !      Subroutine arguments.
   !
   LOGICAL :: secondhalo
   INTEGER(kind=inttype) :: nnn, level, sps, sps2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadjd
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padjd
   REAL(kind=realtype), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: normadj
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: kk, mm, nn, i, j, l, ii, jj
   REAL(kind=realtype) :: vn, nnx, nny, nnz
   REAL(kind=realtype) :: vnd
   !real(kind=realType), dimension(:,:),   pointer :: gamma1, gamma2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: gamma1, gamma2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj0, wadj1
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj0d, wadj1d
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj2, wadj3
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj2d, wadj3d
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj0, padj1
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj0d, padj1d
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj2, padj3
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj2d, padj3d
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2) :: rlvadj, revadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: rlvadj1, rlvadj2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: revadj1, revadj2
   INTEGER(kind=inttype) :: icell, jcell, kcell
   INTEGER(kind=inttype) :: isbeg, jsbeg, ksbeg, isend, jsend, ksend
   INTEGER(kind=inttype) :: ibbeg, jbbeg, kbbeg, ibend, jbend, kbend
   INTEGER(kind=inttype) :: icbeg, jcbeg, kcbeg, icend, jcend, kcend
   INTEGER(kind=inttype) :: ioffset, joffset, koffset
   LOGICAL :: computebc
   padj0d = 0.0
   padj1d = 0.0
   padj2d = 0.0
   padj3d = 0.0
   wadj0d = 0.0
   wadj1d = 0.0
   wadj2d = 0.0
   wadj3d = 0.0
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nn=1,nbocos
   CALL CHECKOVERLAPNKPC(nn, icell, jcell, kcell, isbeg, jsbeg, &
   &                       ksbeg, isend, jsend, ksend, ibbeg, jbbeg, kbbeg, &
   &                       ibend, jbend, kbend, computebc)
   IF (computebc) THEN
   ! Check for symmetry boundary condition.
   IF (bctype(nn) .EQ. symm) THEN
   !Copy the states and other parameters to subfaces
   CALL EXTRACTBCSTATESNKPC_D(nn, wadj, wadjd, padj, padjd, wadj0, &
   &                             wadj0d, wadj1, wadj1d, wadj2, wadj2d, wadj3&
   &                             , wadj3d, padj0, padj0d, padj1, padj1d, &
   &                             padj2, padj2d, padj3, padj3d, rlvadj, &
   &                             revadj, rlvadj1, rlvadj2, revadj1, revadj2&
   &                             , ioffset, joffset, koffset, icell, jcell, &
   &                             kcell, isbeg, jsbeg, ksbeg, isend, jsend, &
   &                             ksend, ibbeg, jbbeg, kbbeg, ibend, jbend, &
   &                             kbend, icbeg, jcbeg, icend, jcend, &
   &                             secondhalo, nnn, level, sps, sps2)
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   gamma1 = gamma(1, jcell-2:jcell+2, kcell-2:kcell+2)
   gamma2 = gamma(2, jcell-2:jcell+2, kcell-2:kcell+2)
   CASE (imax) 
   gamma1 = gamma(ie, jcell-2:jcell+2, kcell-2:kcell+2)
   gamma2 = gamma(il, jcell-2:jcell+2, kcell-2:kcell+2)
   CASE (jmin) 
   gamma1 = gamma(icell-2:icell+2, 1, kcell-2:kcell+2)
   gamma2 = gamma(icell-2:icell+2, 2, kcell-2:kcell+2)
   CASE (jmax) 
   gamma1 = gamma(icell-2:icell+2, je, kcell-2:kcell+2)
   gamma2 = gamma(icell-2:icell+2, jl, kcell-2:kcell+2)
   CASE (kmin) 
   gamma1 = gamma(icell-2:icell+2, jcell-2:jcell+2, 1)
   gamma2 = gamma(icell-2:icell+2, jcell-2:jcell+2, 2)
   CASE (kmax) 
   gamma1 = gamma(icell-2:icell+2, jcell-2:jcell+2, ke)
   gamma2 = gamma(icell-2:icell+2, jcell-2:jcell+2, kl)
   END SELECT
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO j=jcbeg,jcend
   DO i=icbeg,icend
   ii = i - ioffset
   jj = j - joffset
   ! Store the three components of the unit normal a
   ! bit easier.
   !BCData(nn)%norm(i,j,1)
   nnx = normadj(nn, ii, jj, 1, sps2)
   !BCData(nn)%norm(i,j,2)
   nny = normadj(nn, ii, jj, 2, sps2)
   !BCData(nn)%norm(i,j,3)
   nnz = normadj(nn, ii, jj, 3, sps2)
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vnd = two*(nnx*wadj2d(ii, jj, ivx)+nny*wadj2d(ii, jj, ivy)+&
   &              nnz*wadj2d(ii, jj, ivz))
   vn = two*(wadj2(ii, jj, ivx)*nnx+wadj2(ii, jj, ivy)*nny+&
   &              wadj2(ii, jj, ivz)*nnz)
   ! Determine the flow variables in the halo cell.
   wadj1d(ii, jj, irho) = wadj2d(ii, jj, irho)
   wadj1(ii, jj, irho) = wadj2(ii, jj, irho)
   wadj1d(ii, jj, ivx) = wadj2d(ii, jj, ivx) - nnx*vnd
   wadj1(ii, jj, ivx) = wadj2(ii, jj, ivx) - vn*nnx
   wadj1d(ii, jj, ivy) = wadj2d(ii, jj, ivy) - nny*vnd
   wadj1(ii, jj, ivy) = wadj2(ii, jj, ivy) - vn*nny
   wadj1d(ii, jj, ivz) = wadj2d(ii, jj, ivz) - nnz*vnd
   wadj1(ii, jj, ivz) = wadj2(ii, jj, ivz) - vn*nnz
   wadj1d(ii, jj, irhoe) = wadj2d(ii, jj, irhoe)
   wadj1(ii, jj, irhoe) = wadj2(ii, jj, irhoe)
   ! Simply copy the turbulent variables.
   DO l=nt1mg,nt2mg
   wadj1d(ii, jj, l) = wadj2d(ii, jj, l)
   wadj1(ii, jj, l) = wadj2(ii, jj, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   gamma1(ii, jj) = gamma2(ii, jj)
   padj1d(ii, jj) = padj2d(ii, jj)
   padj1(ii, jj) = padj2(ii, jj)
   IF (viscous) rlvadj1(ii, jj) = rlvadj2(ii, jj)
   IF (eddymodel) revadj1(ii, jj) = revadj2(ii, jj)
   IF (secondhalo) THEN
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vnd = two*(nnx*wadj3d(ii, jj, ivx)+nny*wadj3d(ii, jj, ivy)&
   &                +nnz*wadj3d(ii, jj, ivz))
   vn = two*(wadj3(ii, jj, ivx)*nnx+wadj3(ii, jj, ivy)*nny+&
   &                wadj3(ii, jj, ivz)*nnz)
   ! Determine the flow variables in the halo cell.
   wadj0d(ii, jj, irho) = wadj3d(ii, jj, irho)
   wadj0(ii, jj, irho) = wadj3(ii, jj, irho)
   wadj0d(ii, jj, ivx) = wadj3d(ii, jj, ivx) - nnx*vnd
   wadj0(ii, jj, ivx) = wadj3(ii, jj, ivx) - vn*nnx
   wadj0d(ii, jj, ivy) = wadj3d(ii, jj, ivy) - nny*vnd
   wadj0(ii, jj, ivy) = wadj3(ii, jj, ivy) - vn*nny
   wadj0d(ii, jj, ivz) = wadj3d(ii, jj, ivz) - nnz*vnd
   wadj0(ii, jj, ivz) = wadj3(ii, jj, ivz) - vn*nnz
   wadj0d(ii, jj, irhoe) = wadj3d(ii, jj, irhoe)
   wadj0(ii, jj, irhoe) = wadj3(ii, jj, irhoe)
   ! Simply copy the turbulent variables.
   DO l=nt1mg,nt2mg
   wadj1d(ii, jj, l) = wadj3d(ii, jj, l)
   wadj1(ii, jj, l) = wadj3(ii, jj, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   gamma1(ii, jj) = gamma2(ii, jj)
   padj0d(ii, jj) = padj3d(ii, jj)
   padj0(ii, jj) = padj3(ii, jj)
   END IF
   END DO
   END DO
   CALL REPLACEBCSTATESNKPC_D(nn, wadj0, wadj0d, wadj1, wadj1d, &
   &                             wadj2, wadj3, padj0, padj0d, padj1, padj1d&
   &                             , padj2, padj3, rlvadj1, rlvadj2, revadj1, &
   &                             revadj2, icell, jcell, kcell, wadj, wadjd, &
   &                             padj, padjd, rlvadj, revadj, secondhalo, &
   &                             nnn, level, sps, sps2)
   END IF
   END IF
   END DO bocos
   END SUBROUTINE BCSYMMNKPC_D

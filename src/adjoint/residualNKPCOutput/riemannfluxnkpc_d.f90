   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of riemannfluxnkpc in forward (tangent) mode:
   !   variations   of useful results: flux
   !   with respect to varying inputs: rfil flux left right
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          riemannFluxAdj.f90                              *
   !      * Author:        Edwin van der Weide, C.A.(Sandy) Mader          *
   !      * Starting date: 04-25-2008                                      *
   !      * Last modified: 04-25-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE RIEMANNFLUXNKPC_D(left, leftd, right, rightd, flux, fluxd, &
   &  por, gammaface, correctfork, sx, sy, sz, sface, finegrid)
   USE INPUTDISCRETIZATION
   USE CONSTANTS
   USE ITERATION
   IMPLICIT NONE
   !print *,'riemanflux complete'
   !
   !        ****************************************************************
   !        *                                                              *
   !        * riemannFlux computes the flux for the given face and left    *
   !        * and right states.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   !
   !        Subroutine arguments.
   !
   INTEGER(kind=portype) :: por
   REAL(kind=realtype) :: sx, sy, sz, gammaface
   REAL(kind=realtype) :: sface
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: flux
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: fluxd
   LOGICAL, INTENT(IN) :: finegrid, correctfork
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: etld, etrd, z1ld, z1rd, tmpd
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: uavgd, vavgd, wavgd, havgd, kavgd
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: alphaavgd, a2avgd, aavgd, unavgd
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: ovaavgd, ova2avgd, etad
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: lam1d, lam2d, lam3d
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, abv7d
   INTEGER(kind=inttype) :: limused, riemannused
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: rhotmpd, utmpd, vtmpd, wtmpd
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   REAL(kind=realtype), DIMENSION(2) :: ptmpd, ktmpd, etmpd
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: result1d
   REAL(kind=realtype) :: arg2
   REAL(kind=realtype) :: arg2d
   REAL(kind=realtype) :: result2
   REAL(kind=realtype) :: result2d
   REAL(kind=realtype) :: abs1d
   INTRINSIC MAX
   INTRINSIC ABS
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs2d
   REAL(kind=realtype) :: abs1
   INTRINSIC SQRT
   REAL(realType) :: max1
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   !print *,'adjflux2*****************************',half,rfil
   !stop
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Determine the limiter scheme to be used. On the fine grid the
   ! user specified scheme is used; on the coarse grid a first order
   ! scheme is computed.
   !print *,'selecting limiter',limiter,limused,firstorder,finegrid
   limused = firstorder
   IF (finegrid) limused = limiter
   ! Determine the riemann solver which must be used.
   !print *,'selecting riemann',riemann,riemannused,riemannCoarse,finegrid
   riemannused = riemanncoarse
   IF (finegrid) riemannused = riemann
   ! Abbreviate some expressions in which gamma occurs.
   !print *,'some constantts',gammaface
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   !print *,'using roe solver'
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   IF (left(irho) .EQ. 0.0) THEN
   z1ld = 0.0
   ELSE
   z1ld = leftd(irho)/(2.0*SQRT(left(irho)))
   END IF
   z1l = SQRT(left(irho))
   IF (right(irho) .EQ. 0.0) THEN
   z1rd = 0.0
   ELSE
   z1rd = rightd(irho)/(2.0*SQRT(right(irho)))
   END IF
   z1r = SQRT(right(irho))
   tmpd = -(one*(z1ld+z1rd)/(z1l+z1r)**2)
   tmp = one/(z1l+z1r)
   !print *,'tmp',one,z1l , z1r
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   !print *,'correcting for k'
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmpd(1) = leftd(itu1)
   ktmp(1) = left(itu1)
   ktmpd(2) = rightd(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drkd = rightd(irho)*right(itu1) + right(irho)*rightd(itu1) - &
   &          leftd(irho)*left(itu1) - left(irho)*leftd(itu1)
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavgd = tmpd*(z1l*left(itu1)+z1r*right(itu1)) + tmp*(z1ld*left(&
   &          itu1)+z1l*leftd(itu1)+z1rd*right(itu1)+z1r*rightd(itu1))
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   ELSE
   !print *,'not correcting for k'
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   ktmpd = 0.0
   kavgd = 0.0
   drkd = 0.0
   END IF
   ! Compute the total energy of the left and right state.
   !print *,'calculating temp vaars'
   rhotmpd(1) = leftd(irho)
   rhotmp(1) = left(irho)
   rhotmpd(2) = rightd(irho)
   rhotmp(2) = right(irho)
   utmpd(1) = leftd(ivx)
   utmp(1) = left(ivx)
   utmpd(2) = rightd(ivx)
   utmp(2) = right(ivx)
   vtmpd(1) = leftd(ivy)
   vtmp(1) = left(ivy)
   vtmpd(2) = rightd(ivy)
   vtmp(2) = right(ivy)
   wtmpd(1) = leftd(ivz)
   wtmp(1) = left(ivz)
   wtmpd(2) = rightd(ivz)
   wtmp(2) = right(ivz)
   ptmpd(1) = leftd(irhoe)
   ptmp(1) = left(irhoe)
   ptmpd(2) = rightd(irhoe)
   ptmp(2) = right(irhoe)
   !                 call etotArrayAdj(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, &
   !                                Etmp, correctForK, 2_intType)
   CALL ETOTARRAYNKPC_D(rhotmp, rhotmpd, utmp, utmpd, vtmp, vtmpd, &
   &                     wtmp, wtmpd, ptmp, ptmpd, ktmp, ktmpd, etmp, etmpd&
   &                     , correctfork, 2)
   etld = etmpd(1)
   etl = etmp(1)
   etrd = etmpd(2)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   drd = rightd(irho) - leftd(irho)
   dr = right(irho) - left(irho)
   drud = rightd(irho)*right(ivx) + right(irho)*rightd(ivx) - leftd(&
   &        irho)*left(ivx) - left(irho)*leftd(ivx)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drvd = rightd(irho)*right(ivy) + right(irho)*rightd(ivy) - leftd(&
   &        irho)*left(ivy) - left(irho)*leftd(ivy)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drwd = rightd(irho)*right(ivz) + right(irho)*rightd(ivz) - leftd(&
   &        irho)*left(ivz) - left(irho)*leftd(ivz)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dred = etrd - etld
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   !rAvg = fourth*(z1r + z1l)**2 deadend code!
   uavgd = tmpd*(z1l*left(ivx)+z1r*right(ivx)) + tmp*(z1ld*left(ivx)+&
   &        z1l*leftd(ivx)+z1rd*right(ivx)+z1r*rightd(ivx))
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavgd = tmpd*(z1l*left(ivy)+z1r*right(ivy)) + tmp*(z1ld*left(ivy)+&
   &        z1l*leftd(ivy)+z1rd*right(ivy)+z1r*rightd(ivy))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavgd = tmpd*(z1l*left(ivz)+z1r*right(ivz)) + tmp*(z1ld*left(ivz)+&
   &        z1l*leftd(ivz)+z1rd*right(ivz)+z1r*rightd(ivz))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havgd = tmpd*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r) + tmp*&
   &        (((etld+leftd(irhoe))*z1l-(etl+left(irhoe))*z1ld)/z1l**2+((etrd+&
   &        rightd(irhoe))*z1r-(etr+right(irhoe))*z1rd)/z1r**2)
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   !print *,'uavg',tmp,z1l,left(ivx),z1r,right(ivx)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   arg1 = sx**2 + sy**2 + sz**2
   area = SQRT(arg1)
   IF (1.e-25_realType .LT. area) THEN
   max1 = area
   ELSE
   max1 = 1.e-25_realType
   END IF
   tmp = one/max1
   sx = sx*tmp
   sy = sy*tmp
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avgd = gm1*(havgd-alphaavgd) - gm53*kavgd
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   ELSE
   a2avgd = -(gm1*(havgd-alphaavgd)-gm53*kavgd)
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   END IF
   IF (a2avg .EQ. 0.0) THEN
   aavgd = 0.0
   ELSE
   aavgd = a2avgd/(2.0*SQRT(a2avg))
   END IF
   aavg = SQRT(a2avg)
   unavgd = sx*uavgd + sy*vavgd + sz*wavgd
   unavg = uavg*sx + vavg*sy + wavg*sz
   !print *,'unavg',uAvg,sx,vAvg,sy,wAvg,sz
   ovaavgd = -(one*aavgd/aavg**2)
   ovaavg = one/aavg
   ova2avgd = -(one*a2avgd/a2avg**2)
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) THEN
   unavg = rface
   unavgd = 0.0
   END IF
   x1d = sx*(leftd(ivx)-rightd(ivx)) + sy*(leftd(ivy)-rightd(ivy)) + &
   &        sz*(leftd(ivz)-rightd(ivz))
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (left&
   &        (ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1d = x1d
   abs1 = x1
   ELSE
   abs1d = -x1d
   abs1 = -x1
   END IF
   arg1d = (gammaface*leftd(irhoe)*left(irho)-gammaface*left(irhoe)*&
   &        leftd(irho))/left(irho)**2
   arg1 = gammaface*left(irhoe)/left(irho)
   IF (arg1 .EQ. 0.0) THEN
   result1d = 0.0
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   arg2d = (gammaface*rightd(irhoe)*right(irho)-gammaface*right(irhoe&
   &        )*rightd(irho))/right(irho)**2
   arg2 = gammaface*right(irhoe)/right(irho)
   IF (arg2 .EQ. 0.0) THEN
   result2d = 0.0
   ELSE
   result2d = arg2d/(2.0*SQRT(arg2))
   END IF
   result2 = SQRT(arg2)
   x2d = result1d - result2d
   x2 = result1 - result2
   IF (x2 .GE. 0.) THEN
   abs2d = x2d
   abs2 = x2
   ELSE
   abs2d = -x2d
   abs2 = -x2
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   etad = half*(abs1d+abs2d)
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1d = unavgd + aavgd
   lam1 = unavg - rface + aavg
   ELSE
   lam1d = -(unavgd+aavgd)
   lam1 = -(unavg-rface+aavg)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2d = unavgd - aavgd
   lam2 = unavg - rface - aavg
   ELSE
   lam2d = -(unavgd-aavgd)
   lam2 = -(unavg-rface-aavg)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3d = unavgd
   lam3 = unavg - rface
   ELSE
   lam3d = -unavgd
   lam3 = -(unavg-rface)
   END IF
   !print *,'lam3',unAvg, rFace
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) THEN
   lam1d = etad + (fourth*(lam1d*lam1+lam1*lam1d)*eta-fourth*lam1**&
   &          2*etad)/eta**2
   lam1 = eta + fourth*lam1*lam1/eta
   END IF
   IF (lam2 .LT. tmp) THEN
   lam2d = etad + (fourth*(lam2d*lam2+lam2*lam2d)*eta-fourth*lam2**&
   &          2*etad)/eta**2
   lam2 = eta + fourth*lam2*lam2/eta
   END IF
   IF (lam3 .LT. tmp) THEN
   lam3d = etad + (fourth*(lam3d*lam3+lam3*lam3d)*eta-fourth*lam3**&
   &          2*etad)/eta**2
   lam3 = eta + fourth*lam3*lam3/eta
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   lam1d = area*lam1d
   lam1 = lam1*area
   lam2d = area*lam2d
   lam2 = lam2*area
   lam3d = area*lam3d
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1d = half*(lam1d+lam2d)
   abv1 = half*(lam1+lam2)
   abv2d = half*(lam1d-lam2d)
   abv2 = half*(lam1-lam2)
   abv3d = abv1d - lam3d
   abv3 = abv1 - lam3
   abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-vavgd*&
   &        drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
   abv5d = sx*drud + sy*drvd + sz*drwd - unavgd*dr - unavg*drd
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd + (&
   &        abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   !print *,'abv6',abv3,abv4,ova2Avg,abv2,abv5,ovaAvg
   abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd + abv3d&
   &        *abv5 + abv3*abv5d
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   !print *,'inriemannend',-porFlux,lam3,dr, abv6
   fluxd(irho) = -(porflux*(lam3d*dr+lam3*drd+abv6d))
   flux(irho) = -(porflux*(lam3*dr+abv6))
   fluxd(imx) = -(porflux*(lam3d*dru+lam3*drud+uavgd*abv6+uavg*abv6d+&
   &        sx*abv7d))
   flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
   fluxd(imy) = -(porflux*(lam3d*drv+lam3*drvd+vavgd*abv6+vavg*abv6d+&
   &        sy*abv7d))
   flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
   fluxd(imz) = -(porflux*(lam3d*drw+lam3*drwd+wavgd*abv6+wavg*abv6d+&
   &        sz*abv7d))
   flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
   fluxd(irhoe) = -(porflux*(lam3d*dre+lam3*dred+havgd*abv6+havg*&
   &        abv6d+unavgd*abv7+unavg*abv7d))
   flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
   CASE (turkel) 
   !          tmp = max(lam1,lam2,lam3)
   !          flux(irho)  = -porFlux*(tmp*dr)
   !          flux(imx)   = -porFlux*(tmp*dru)
   !          flux(imy)   = -porFlux*(tmp*drv)
   !          flux(imz)   = -porFlux*(tmp*drw)
   !          flux(irhoE) = -porFlux*(tmp*drE)
   CALL TERMINATE('riemannFlux', &
   &                  'Turkel preconditioner not implemented yet')
   CASE (choimerkle) 
   CALL TERMINATE('riemannFlux', &
   &                  'choi merkle preconditioner not implemented yet')
   END SELECT
   CASE (vanleer) 
   CALL TERMINATE('riemannFlux', 'van leer fvs not implemented yet')
   CASE (ausmdv) 
   CALL TERMINATE('riemannFlux', 'ausmdv fvs not implemented yet')
   END SELECT
   END SUBROUTINE RIEMANNFLUXNKPC_D

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of riemannfluxnkpc in reverse (adjoint) mode:
   !   gradient     of useful results: flux left right
   !   with respect to varying inputs: rfil flux left right
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          riemannFluxAdj.f90                              *
   !      * Author:        Edwin van der Weide, C.A.(Sandy) Mader          *
   !      * Starting date: 04-25-2008                                      *
   !      * Last modified: 04-25-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE RIEMANNFLUXNKPC_B(left, leftb, right, rightb, flux, fluxb, &
   &  por, gammaface, correctfork, sx, sy, sz, sface, finegrid)
   USE INPUTDISCRETIZATION
   USE CONSTANTS
   USE ITERATION
   IMPLICIT NONE
   !print *,'riemanflux complete'
   !
   !        ****************************************************************
   !        *                                                              *
   !        * riemannFlux computes the flux for the given face and left    *
   !        * and right states.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   !
   !        Subroutine arguments.
   !
   INTEGER(kind=portype) :: por
   REAL(kind=realtype) :: sx, sy, sz, gammaface
   REAL(kind=realtype) :: sface
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*) :: leftb, rightb
   REAL(kind=realtype), DIMENSION(*) :: flux
   REAL(kind=realtype), DIMENSION(*) :: fluxb
   LOGICAL, INTENT(IN) :: finegrid, correctfork
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: etlb, etrb, z1lb, z1rb, tmpb
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: drb, drub, drvb, drwb, dreb, drkb
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: uavgb, vavgb, wavgb, havgb, kavgb
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: alphaavgb, a2avgb, aavgb, unavgb
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: ovaavgb, ova2avgb, etab
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: lam1b, lam2b, lam3b
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype) :: abv1b, abv2b, abv3b, abv4b, abv5b, abv6b, abv7b
   INTEGER(kind=inttype) :: limused, riemannused
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: rhotmpb, utmpb, vtmpb, wtmpb
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   REAL(kind=realtype), DIMENSION(2) :: ptmpb, ktmpb, etmpb
   INTEGER :: branch
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: abs1b
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: temp0b
   INTRINSIC MAX
   REAL(kind=realtype) :: temp3b
   INTRINSIC ABS
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x2b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: temp2b
   REAL(kind=realtype) :: x1b
   REAL(kind=realtype) :: temp3b7
   REAL(kind=realtype) :: temp3b6
   REAL(kind=realtype) :: temp3b5
   REAL(kind=realtype) :: temp3b4
   REAL(kind=realtype) :: temp3b3
   REAL(kind=realtype) :: temp3b2
   REAL(kind=realtype) :: temp3b1
   REAL(kind=realtype) :: temp3b0
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: abs2b
   REAL(kind=realtype) :: temp1b
   INTRINSIC SQRT
   REAL(kind=realtype) :: temp
   REAL(realType) :: max1
   REAL(kind=realtype) :: temp1b1
   REAL(kind=realtype) :: temp1b0
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   !print *,'adjflux2*****************************',half,rfil
   !stop
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Determine the riemann solver which must be used.
   !print *,'selecting riemann',riemann,riemannused,riemannCoarse,finegrid
   riemannused = riemanncoarse
   IF (finegrid) riemannused = riemann
   ! Abbreviate some expressions in which gamma occurs.
   !print *,'some constantts',gammaface
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   !print *,'using roe solver'
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   z1l = SQRT(left(irho))
   z1r = SQRT(right(irho))
   tmp = one/(z1l+z1r)
   !print *,'tmp',one,z1l , z1r
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   !print *,'correcting for k'
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmp(1) = left(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   !print *,'not correcting for k'
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   END IF
   ! Compute the total energy of the left and right state.
   !print *,'calculating temp vaars'
   rhotmp(1) = left(irho)
   rhotmp(2) = right(irho)
   utmp(1) = left(ivx)
   utmp(2) = right(ivx)
   vtmp(1) = left(ivy)
   vtmp(2) = right(ivy)
   wtmp(1) = left(ivz)
   wtmp(2) = right(ivz)
   ptmp(1) = left(irhoe)
   ptmp(2) = right(irhoe)
   CALL PUSHREAL8ARRAY(etmp, realtype*2/8)
   !                 call etotArrayAdj(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, &
   !                                Etmp, correctForK, 2_intType)
   CALL ETOTARRAYNKPC(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
   &                      correctfork, 2)
   etl = etmp(1)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   dr = right(irho) - left(irho)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   !rAvg = fourth*(z1r + z1l)**2 deadend code!
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   !print *,'uavg',tmp,z1l,left(ivx),z1r,right(ivx)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   max1 = area
   ELSE
   max1 = 1.e-25_realType
   END IF
   tmp = one/max1
   sx = sx*tmp
   sy = sy*tmp
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   CALL PUSHINTEGER4(1)
   ELSE
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   CALL PUSHINTEGER4(0)
   END IF
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   !print *,'unavg',uAvg,sx,vAvg,sy,wAvg,sz
   ovaavg = one/aavg
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) THEN
   unavg = rface
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (left&
   &        (ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1 = x1
   CALL PUSHINTEGER4(1)
   ELSE
   abs1 = -x1
   CALL PUSHINTEGER4(0)
   END IF
   x2 = SQRT(gammaface*left(irhoe)/left(irho)) - SQRT(gammaface*right&
   &        (irhoe)/right(irho))
   IF (x2 .GE. 0.) THEN
   abs2 = x2
   CALL PUSHINTEGER4(1)
   ELSE
   abs2 = -x2
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1 = unavg - rface + aavg
   CALL PUSHINTEGER4(1)
   ELSE
   lam1 = -(unavg-rface+aavg)
   CALL PUSHINTEGER4(0)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2 = unavg - rface - aavg
   CALL PUSHINTEGER4(1)
   ELSE
   lam2 = -(unavg-rface-aavg)
   CALL PUSHINTEGER4(0)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3 = unavg - rface
   CALL PUSHINTEGER4(1)
   ELSE
   lam3 = -(unavg-rface)
   CALL PUSHINTEGER4(0)
   END IF
   !print *,'lam3',unAvg, rFace
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) THEN
   CALL PUSHREAL8ARRAY(lam1, realtype/8)
   lam1 = eta + fourth*lam1*lam1/eta
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (lam2 .LT. tmp) THEN
   CALL PUSHREAL8ARRAY(lam2, realtype/8)
   lam2 = eta + fourth*lam2*lam2/eta
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (lam3 .LT. tmp) THEN
   CALL PUSHREAL8ARRAY(lam3, realtype/8)
   lam3 = eta + fourth*lam3*lam3/eta
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   lam1 = lam1*area
   lam2 = lam2*area
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   abv2 = half*(lam1-lam2)
   abv3 = abv1 - lam3
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   !print *,'abv6',abv3,abv4,ova2Avg,abv2,abv5,ovaAvg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   !print *,'inriemannend',-porFlux,lam3,dr, abv6
   temp3b2 = -(porflux*fluxb(irhoe))
   fluxb(irhoe) = 0.0
   temp3b3 = -(porflux*fluxb(imz))
   fluxb(imz) = 0.0
   temp3b4 = -(porflux*fluxb(imy))
   fluxb(imy) = 0.0
   temp3b5 = -(porflux*fluxb(imx))
   fluxb(imx) = 0.0
   temp3b6 = -(porflux*fluxb(irho))
   abv6b = wavg*temp3b3 + uavg*temp3b5 + temp3b6 + vavg*temp3b4 + &
   &        havg*temp3b2
   abv7b = sz*temp3b3 + sx*temp3b5 + sy*temp3b4 + unavg*temp3b2
   abv3b = ova2avg*abv4*abv6b + abv5*abv7b
   lam3b = drw*temp3b3 + dru*temp3b5 - abv3b + dr*temp3b6 + drv*&
   &        temp3b4 + dre*temp3b2
   abv4b = ova2avg*abv3*abv6b + ovaavg*abv2*abv7b
   temp3b7 = gm1*abv4b
   dreb = temp3b7 + lam3*temp3b2
   havgb = abv6*temp3b2
   abv5b = ovaavg*abv2*abv6b + abv3*abv7b
   unavgb = abv7*temp3b2 - dr*abv5b
   drwb = sz*abv5b - wavg*temp3b7 + lam3*temp3b3
   wavgb = abv6*temp3b3 - drw*temp3b7
   drvb = sy*abv5b - vavg*temp3b7 + lam3*temp3b4
   vavgb = abv6*temp3b4 - drv*temp3b7
   drub = sx*abv5b - uavg*temp3b7 + lam3*temp3b5
   uavgb = abv6*temp3b5 - dru*temp3b7
   drb = alphaavg*temp3b7 - unavg*abv5b + lam3*temp3b6
   fluxb(irho) = 0.0
   abv2b = ovaavg*abv5*abv6b + ovaavg*abv4*abv7b
   ovaavgb = abv2*abv5*abv6b + abv2*abv4*abv7b
   ova2avgb = abv3*abv4*abv6b
   alphaavgb = dr*temp3b7
   drkb = -(gm53*abv4b)
   abv1b = abv3b
   lam1b = half*abv1b + half*abv2b
   lam2b = half*abv1b - half*abv2b
   lam3b = area*lam3b
   lam2b = area*lam2b
   lam1b = area*lam1b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   etab = 0.0
   ELSE
   CALL POPREAL8ARRAY(lam3, realtype/8)
   temp3b1 = fourth*lam3b/eta
   etab = lam3b - lam3**2*temp3b1/eta
   lam3b = 2*lam3*temp3b1
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(lam2, realtype/8)
   temp3b0 = fourth*lam2b/eta
   etab = etab + lam2b - lam2**2*temp3b0/eta
   lam2b = 2*lam2*temp3b0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(lam1, realtype/8)
   temp3b = fourth*lam1b/eta
   etab = etab + lam1b - lam1**2*temp3b/eta
   lam1b = 2*lam1*temp3b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   unavgb = unavgb - lam3b
   ELSE
   unavgb = unavgb + lam3b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   aavgb = lam2b
   unavgb = unavgb - lam2b
   ELSE
   unavgb = unavgb + lam2b
   aavgb = -lam2b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   unavgb = unavgb - lam1b
   aavgb = aavgb - lam1b
   ELSE
   unavgb = unavgb + lam1b
   aavgb = aavgb + lam1b
   END IF
   abs1b = half*etab
   abs2b = half*etab
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x2b = -abs2b
   ELSE
   x2b = abs2b
   END IF
   temp2 = left(irhoe)/left(irho)
   IF (gammaface*temp2 .EQ. 0.0) THEN
   temp2b = 0.0
   ELSE
   temp2b = gammaface*x2b/(2.0*SQRT(gammaface*temp2)*left(irho))
   END IF
   temp1 = right(irhoe)/right(irho)
   IF (gammaface*temp1 .EQ. 0.0) THEN
   temp1b1 = 0.0
   ELSE
   temp1b1 = -(gammaface*x2b/(2.0*SQRT(gammaface*temp1)*right(irho)&
   &          ))
   END IF
   leftb(irhoe) = leftb(irhoe) + temp2b
   leftb(irho) = leftb(irho) - temp2*temp2b
   rightb(irhoe) = rightb(irhoe) + temp1b1
   rightb(irho) = rightb(irho) - temp1*temp1b1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x1b = -abs1b
   ELSE
   x1b = abs1b
   END IF
   leftb(ivx) = leftb(ivx) + sx*x1b
   rightb(ivx) = rightb(ivx) - sx*x1b
   leftb(ivy) = leftb(ivy) + sy*x1b
   rightb(ivy) = rightb(ivy) - sy*x1b
   leftb(ivz) = leftb(ivz) + sz*x1b
   rightb(ivz) = rightb(ivz) - sz*x1b
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) unavgb = 0.0
   aavgb = aavgb - one*ovaavgb/aavg**2
   IF (a2avg .EQ. 0.0) THEN
   a2avgb = -(one*ova2avgb/a2avg**2)
   ELSE
   a2avgb = aavgb/(2.0*SQRT(a2avg)) - one*ova2avgb/a2avg**2
   END IF
   uavgb = uavgb + sx*unavgb
   vavgb = vavgb + sy*unavgb
   wavgb = wavgb + sz*unavgb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   kavgb = gm53*a2avgb
   havgb = havgb - gm1*a2avgb
   alphaavgb = alphaavgb + gm1*a2avgb
   ELSE
   havgb = havgb + gm1*a2avgb
   alphaavgb = alphaavgb - gm1*a2avgb
   kavgb = -(gm53*a2avgb)
   END IF
   temp1b0 = half*alphaavgb
   uavgb = uavgb + 2*uavg*temp1b0
   vavgb = vavgb + 2*vavg*temp1b0
   wavgb = wavgb + 2*wavg*temp1b0
   tmp = one/(z1l+z1r)
   temp = (etr+right(irhoe))/z1r
   temp0 = (etl+left(irhoe))/z1l
   temp1b = tmp*havgb
   temp0b = temp1b/z1l
   tempb1 = temp1b/z1r
   tmpb = (z1l*left(ivz)+z1r*right(ivz))*wavgb + (z1l*left(ivx)+z1r*&
   &        right(ivx))*uavgb + (z1l*left(ivy)+z1r*right(ivy))*vavgb + (&
   &        temp0+temp)*havgb
   etlb = temp0b - dreb
   leftb(irhoe) = leftb(irhoe) + temp0b
   tempb2 = tmp*wavgb
   tempb3 = tmp*vavgb
   tempb4 = tmp*uavgb
   z1lb = left(ivz)*tempb2 + left(ivx)*tempb4 + left(ivy)*tempb3 - &
   &        temp0*temp0b
   etrb = dreb + tempb1
   rightb(irhoe) = rightb(irhoe) + tempb1
   z1rb = right(ivz)*tempb2 + right(ivx)*tempb4 + right(ivy)*tempb3 -&
   &        temp*tempb1
   leftb(ivz) = leftb(ivz) + z1l*tempb2
   rightb(ivz) = rightb(ivz) + z1r*tempb2
   leftb(ivy) = leftb(ivy) + z1l*tempb3
   rightb(ivy) = rightb(ivy) + z1r*tempb3
   leftb(ivx) = leftb(ivx) + z1l*tempb4
   rightb(ivx) = rightb(ivx) + z1r*tempb4
   rightb(irho) = rightb(irho) + right(ivz)*drwb
   rightb(ivz) = rightb(ivz) + right(irho)*drwb
   leftb(irho) = leftb(irho) - left(ivz)*drwb
   leftb(ivz) = leftb(ivz) - left(irho)*drwb
   rightb(irho) = rightb(irho) + right(ivy)*drvb
   rightb(ivy) = rightb(ivy) + right(irho)*drvb
   leftb(irho) = leftb(irho) - left(ivy)*drvb
   leftb(ivy) = leftb(ivy) - left(irho)*drvb
   rightb(irho) = rightb(irho) + right(ivx)*drub
   rightb(ivx) = rightb(ivx) + right(irho)*drub
   leftb(irho) = leftb(irho) - left(ivx)*drub
   leftb(ivx) = leftb(ivx) - left(irho)*drub
   rightb(irho) = rightb(irho) + drb
   leftb(irho) = leftb(irho) - drb
   etmpb = 0.0
   etmpb(2) = etrb
   etmpb(1) = etmpb(1) + etlb
   CALL POPREAL8ARRAY(etmp, realtype*2/8)
   CALL ETOTARRAYNKPC_B(rhotmp, rhotmpb, utmp, utmpb, vtmp, vtmpb, &
   &                     wtmp, wtmpb, ptmp, ptmpb, ktmp, ktmpb, etmp, etmpb&
   &                     , correctfork, 2)
   rightb(irhoe) = rightb(irhoe) + ptmpb(2)
   ptmpb(2) = 0.0
   leftb(irhoe) = leftb(irhoe) + ptmpb(1)
   rightb(ivz) = rightb(ivz) + wtmpb(2)
   wtmpb(2) = 0.0
   leftb(ivz) = leftb(ivz) + wtmpb(1)
   rightb(ivy) = rightb(ivy) + vtmpb(2)
   vtmpb(2) = 0.0
   leftb(ivy) = leftb(ivy) + vtmpb(1)
   rightb(ivx) = rightb(ivx) + utmpb(2)
   utmpb(2) = 0.0
   leftb(ivx) = leftb(ivx) + utmpb(1)
   rightb(irho) = rightb(irho) + rhotmpb(2)
   rhotmpb(2) = 0.0
   leftb(irho) = leftb(irho) + rhotmpb(1)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   tempb0 = tmp*kavgb
   tmpb = tmpb + (z1l*left(itu1)+z1r*right(itu1))*kavgb
   z1lb = z1lb + left(itu1)*tempb0
   leftb(itu1) = leftb(itu1) + z1l*tempb0
   z1rb = z1rb + right(itu1)*tempb0
   rightb(itu1) = rightb(itu1) + z1r*tempb0
   rightb(irho) = rightb(irho) + right(itu1)*drkb
   rightb(itu1) = rightb(itu1) + ktmpb(2) + right(irho)*drkb
   leftb(irho) = leftb(irho) - left(itu1)*drkb
   ktmpb(2) = 0.0
   leftb(itu1) = leftb(itu1) + ktmpb(1) - left(irho)*drkb
   END IF
   tempb = -(one*tmpb/(z1l+z1r)**2)
   z1lb = z1lb + tempb
   z1rb = z1rb + tempb
   IF (.NOT.right(irho) .EQ. 0.0) rightb(irho) = rightb(irho) + z1rb/&
   &          (2.0*SQRT(right(irho)))
   IF (.NOT.left(irho) .EQ. 0.0) leftb(irho) = leftb(irho) + z1lb/(&
   &          2.0*SQRT(left(irho)))
   END SELECT
   END SELECT

   END SUBROUTINE RIEMANNFLUXNKPC_B

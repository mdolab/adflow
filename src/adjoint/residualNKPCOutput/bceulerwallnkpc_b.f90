   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of bceulerwallnkpc in reverse (adjoint) mode:
   !   gradient     of useful results: padj wadj
   !   with respect to varying inputs: padj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcEulerWallAdj.f90                              *
   !      * Author:        Edwin van der Weide,C.A.(sandy)Mader            *
   !      *                Seongim Choi                                    *
   !      * Starting date: 03-21-2006                                      *
   !      * Last modified: 10-22-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCEULERWALLNKPC_B(secondhalo, wadj, wadjb, padj, padjb, sadj&
   &  , siadj, sjadj, skadj, normadj, rfaceadj, icell, jcell, kcell, nn, &
   &  level, sps, sps2)
   USE BLOCKPOINTERS, ONLY : bcdata, bcfaceid, &
   &  addgridvelocities, nbocos, bctype
   USE INPUTTIMESPECTRAL
   USE BCTYPES
   USE INPUTDISCRETIZATION
   USE CONSTANTS
   USE ITERATION
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcEulerWallAdj pplies the inviscid wall boundary condition to  *
   !      * subface nn of the block to which the pointers in blockPointers *
   !      * currently point.                                               *
   !      *                                                                *
   !      ******************************************************************
   !
   !nIntervalTimespectral
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype) :: nn, level, sps, sps2
   INTEGER(kind=inttype) :: icell, jcell, kcell
   INTEGER(kind=inttype) :: isbeg, jsbeg, ksbeg, isend, jsend, ksend
   INTEGER(kind=inttype) :: ibbeg, jbbeg, kbbeg, ibend, jbend, kbend
   INTEGER(kind=inttype) :: icbeg, jcbeg, kcbeg, icend, jcend, kcend
   INTEGER(kind=inttype) :: ioffset, joffset, koffset
   !  integer(kind=intType) :: icBeg, icEnd, jcBeg, jcEnd
   !  integer(kind=intType) :: iOffset, jOffset
   INTEGER(kind=inttype) :: walltreatment
   LOGICAL :: secondhalo
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj0, wadj1
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj0b, wadj1b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj2, wadj3
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj2b, wadj3b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj0, padj1
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj0b, padj1b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj2, padj3
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj2b, padj3b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2) :: rlvadj, revadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: rlvadj1, rlvadj2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: revadj1, revadj2
   !  real(kind=realType), dimension(-2:2,-2:2,-2:2,3), intent(in) ::siAdj, sjAdj, skAdj
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj, sjadj, skadj
   REAL(kind=realtype), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: normadj
   REAL(kind=realtype), DIMENSION(nbocos, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: rfaceadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadjb
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral) :: padjb
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sadj
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, l, ii, jj, kk, nnbcs
   INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
   INTEGER(kind=inttype) :: jjm1, jjp1, kkm1, kkp1
   REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
   REAL(kind=realtype) :: skxa, skya, skza, a1, b1
   REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
   REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
   REAL(kind=realtype) :: dpjb, dpkb, qjb, qkb, vnb
   REAL(kind=realtype) :: ux, uy, uz, ovgm1, gm53, factk
   REAL(kind=realtype) :: uxb, uyb, uzb
   REAL(kind=realtype) :: rface
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, 3) :: ssi, ssj, ssk
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, 3) :: ssadj
   !  real(kind=realType), dimension(-2:2,-2:2,3) :: ssi, ssj, ssk
   !  real(kind=realType), dimension(:,:,:), pointer :: ss
   LOGICAL :: computebc
   !
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Make sure that on the coarser grids the constant pressure
   ! boundary condition is used.
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: ad_from5
   INTEGER :: ad_to5
   INTEGER :: ad_from6
   INTEGER :: ad_to6
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: temp0b
   INTRINSIC MAX
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tmp0b
   REAL(kind=realtype) :: tempb
   INTRINSIC MIN
   REAL(kind=realtype) :: temp1b
   REAL(kind=realtype) :: temp
   INTEGER(kind=inttype) :: max2
   INTEGER(kind=inttype) :: max1
   REAL(kind=realtype) :: temp1b2
   REAL(kind=realtype) :: temp1b1
   REAL(kind=realtype) :: temp1b0
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nnbcs=1,nbocos
   CALL PUSHINTEGER4ARRAY(kbend, inttype/4)
   CALL PUSHINTEGER4ARRAY(jbend, inttype/4)
   CALL PUSHINTEGER4ARRAY(ibend, inttype/4)
   CALL PUSHINTEGER4ARRAY(kbbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(jbbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(ibbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(ksend, inttype/4)
   CALL PUSHINTEGER4ARRAY(jsend, inttype/4)
   CALL PUSHINTEGER4ARRAY(isend, inttype/4)
   CALL PUSHINTEGER4ARRAY(ksbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(jsbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(isbeg, inttype/4)
   CALL CHECKOVERLAPNKPC(nnbcs, icell, jcell, kcell, isbeg, jsbeg, &
   &                       ksbeg, isend, jsend, ksend, ibbeg, jbbeg, kbbeg, &
   &                       ibend, jbend, kbend, computebc)
   IF (computebc) THEN
   ! Check for Euler wall boundary condition.
   IF (bctype(nnbcs) .EQ. eulerwall) THEN
   CALL PUSHBOOLEAN(secondhalo)
   CALL PUSHINTEGER4ARRAY(jcend, inttype/4)
   CALL PUSHINTEGER4ARRAY(icend, inttype/4)
   CALL PUSHINTEGER4ARRAY(jcbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(icbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(joffset, inttype/4)
   CALL PUSHINTEGER4ARRAY(ioffset, inttype/4)
   CALL PUSHREAL8ARRAY(padj2, realtype*5**2/8)
   CALL PUSHREAL8ARRAY(padj1, realtype*5**2/8)
   CALL PUSHREAL8ARRAY(wadj2, realtype*5**2*nw/8)
   CALL PUSHREAL8ARRAY(wadj1, realtype*5**2*nw/8)
   ! Set the pointers for the unit normal and the normal
   ! velocity to make the code more readable.
   !!?norm  => BCData(nn)%norm
   !!?rface => BCData(nn)%rface
   !Copy the states and other parameters to subfaces
   CALL EXTRACTBCSTATESNKPC(nnbcs, wadj, padj, wadj0, wadj1, &
   &                              wadj2, wadj3, padj0, padj1, padj2, padj3, &
   &                              rlvadj, revadj, rlvadj1, rlvadj2, revadj1&
   &                              , revadj2, ioffset, joffset, koffset, &
   &                              icell, jcell, kcell, isbeg, jsbeg, ksbeg, &
   &                              isend, jsend, ksend, ibbeg, jbbeg, kbbeg, &
   &                              ibend, jbend, kbend, icbeg, jcbeg, icend, &
   &                              jcend, secondhalo, nn, level, sps, sps2)
   ! Some initialization
   ssi = zero
   ssj = zero
   ssk = zero
   ! Easier storage of variables involving gamma.
   ovgm1 = one/(gammainf-one)
   gm53 = gammainf - five*third
   factk = -(ovgm1*gm53)
   ! Determine the boundary condition treatment and compute the
   ! undivided pressure gradient accordingly. This gradient is
   ! temporarily stored in the halo pressure.
   SELECT CASE  (wallbctreatment) 
   CASE (constantpressure) 
   ad_from = jcbeg
   ! Constant pressure. Set the gradient to zero.
   DO j=ad_from,jcend
   ad_from0 = icbeg
   DO i=ad_from0,icend
   CALL PUSHINTEGER4ARRAY(ii, inttype/4)
   ii = i - ioffset
   CALL PUSHINTEGER4ARRAY(jj, inttype/4)
   jj = j - joffset
   padj1(ii, jj) = zero
   END DO
   CALL PUSHINTEGER4ARRAY(i - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4ARRAY(j - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from)
   CALL PUSHINTEGER4(1)
   CASE (linextrapolpressure) 
   ad_from1 = jcbeg
   !===============================================================
   ! Linear extrapolation. Compute the gradient.
   DO j=ad_from1,jcend
   ad_from2 = icbeg
   DO i=ad_from2,icend
   CALL PUSHINTEGER4ARRAY(ii, inttype/4)
   ii = i - ioffset
   CALL PUSHINTEGER4ARRAY(jj, inttype/4)
   jj = j - joffset
   padj1(ii, jj) = padj3(ii, jj) - padj2(ii, jj)
   END DO
   CALL PUSHINTEGER4ARRAY(i - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from2)
   END DO
   CALL PUSHINTEGER4ARRAY(j - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from1)
   CALL PUSHINTEGER4(2)
   CASE (normalmomentum) 
   !!$
   !!$
   !!$              !===============================================================
   !!$
   !!$           case (quadExtrapolPressure)
   !!$
   !!$              ! Quadratic extrapolation. Does not fit within the
   !!$              ! current data structures.
   !!$              
   !!$              !call terminate("bcEulerWallAdj", "Quadratic extrapolation does not fit within the current data structure for th
   !e boundary stuff")
   !!$              call terminate("bcEulerWallAdj", "Quadratic")
   !!$              !print *, "bcEulerWallAdj: quadExtrapolPressure: STOP"
   !!$
   !===============================================================
   !call terminate("bcEulerWallAdj", &
   !               "No normal momentum in this version.")
   !print *, "bcEulerWallAdj: STOP"
   ! Pressure gradient is computed using the normal momentum
   ! equation. First set a couple of additional variables for
   ! the normals, depending on the block face. Note that the
   ! construction 1: should not be used in these pointers,
   ! because element 0 is needed. Consequently there will be
   ! an offset of 1 for these normals. This is commented in
   ! the code. For moving faces also the grid velocity of
   ! the 1st cell center from the wall is needed.
   SELECT CASE  (bcfaceid(nnbcs)) 
   CASE (imin) 
   IF (secondhalo) THEN
   ssi(:, :, :) = siadj(-1, :, :, :, sps2)
   ssj(:, :, :) = sjadj(0, :, :, :, sps2)
   ssk(:, :, :) = skadj(0, :, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(0, :, :, :, &
   &                  sps2)
   ELSE
   ssi(:, :, :) = siadj(-2, :, :, :, sps2)
   ssj(:, :, :) = sjadj(-1, :, :, :, sps2)
   ssk(:, :, :) = skadj(-1, :, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(-1, :, :, :, &
   &                  sps2)
   END IF
   CASE (imax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = siadj(0, :, :, :, sps2)
   ssj(:, :, :) = sjadj(0, :, :, :, sps2)
   ssk(:, :, :) = skadj(0, :, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(0, :, :, :, &
   &                  sps2)
   ELSE
   ssi(:, :, :) = siadj(1, :, :, :, sps2)
   ssj(:, :, :) = sjadj(1, :, :, :, sps2)
   ssk(:, :, :) = skadj(1, :, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(1, :, :, :, &
   &                  sps2)
   END IF
   CASE (jmin) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = sjadj(:, -1, :, :, sps2)
   ssj(:, :, :) = siadj(:, 0, :, :, sps2)
   ssk(:, :, :) = skadj(:, 0, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, 0, :, :, &
   &                  sps2)
   ELSE
   ssi(:, :, :) = sjadj(:, -2, :, :, sps2)
   ssj(:, :, :) = siadj(:, -1, :, :, sps2)
   ssk(:, :, :) = skadj(:, -1, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, -1, :, :, &
   &                  sps2)
   END IF
   CASE (jmax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = sjadj(:, 0, :, :, sps2)
   ssj(:, :, :) = siadj(:, 0, :, :, sps2)
   ssk(:, :, :) = skadj(:, 0, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, 0, :, :, &
   &                  sps2)
   ELSE
   ssi(:, :, :) = sjadj(:, 1, :, :, sps2)
   ssj(:, :, :) = siadj(:, 1, :, :, sps2)
   ssk(:, :, :) = skadj(:, 1, :, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, 1, :, :, &
   &                  sps2)
   END IF
   CASE (kmin) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = skadj(:, :, -1, :, sps2)
   ssj(:, :, :) = siadj(:, :, 0, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 0, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, :, 0, :, &
   &                  sps2)
   ELSE
   ssi(:, :, :) = skadj(:, :, -2, :, sps2)
   ssj(:, :, :) = siadj(:, :, -1, :, sps2)
   ssk(:, :, :) = sjadj(:, :, -1, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, :, -1, :, &
   &                  sps2)
   END IF
   CASE (kmax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = skadj(:, :, 0, :, sps2)
   ssj(:, :, :) = siadj(:, :, 0, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 0, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, :, 0, :, &
   &                  sps2)
   ELSE
   ssi(:, :, :) = skadj(:, :, 1, :, sps2)
   ssj(:, :, :) = siadj(:, :, 1, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 1, :, sps2)
   IF (addgridvelocities) ssadj(:, :, :) = sadj(:, :, 1, :, &
   &                  sps2)
   END IF
   END SELECT
   ad_from3 = jcbeg
   ! Loop over the faces of the generic subface.
   ! Note that now the running indices are j and k. This is
   ! done, because the generic i-direction is assumed to
   ! be the normal direction.
   DO k=ad_from3,jcend
   ! Store the indices k+1, k-1 a bit easier and make
   ! sure that they do not exceed the range of the arrays.
   km1 = k - 1
   IF (bcdata(nnbcs)%jcbeg .LT. km1) THEN
   km1 = km1
   ELSE
   km1 = bcdata(nnbcs)%jcbeg
   END IF
   kp1 = k + 1
   IF (bcdata(nnbcs)%jcend .GT. kp1) THEN
   kp1 = kp1
   ELSE
   kp1 = bcdata(nnbcs)%jcend
   END IF
   IF (1 .LT. kp1 - km1) THEN
   max1 = kp1 - km1
   ELSE
   max1 = 1
   END IF
   CALL PUSHREAL8ARRAY(b1, realtype/8)
   ! Compute the scaling factor for the central difference
   ! in the k-direction.
   b1 = one/max1
   CALL PUSHINTEGER4ARRAY(kk, inttype/4)
   ! Compute the offset indices.
   kk = k - joffset
   CALL PUSHINTEGER4ARRAY(kkm1, inttype/4)
   kkm1 = km1 - joffset
   CALL PUSHINTEGER4ARRAY(kkp1, inttype/4)
   kkp1 = kp1 - joffset
   ad_from4 = icbeg
   ! The generic j-direction.
   DO j=ad_from4,icend
   ! The indices j+1 and j-1. Make sure that they
   ! do not exceed the range of the arrays.
   jm1 = j - 1
   IF (bcdata(nnbcs)%icbeg .LT. jm1) THEN
   jm1 = jm1
   ELSE
   jm1 = bcdata(nnbcs)%icbeg
   END IF
   jp1 = j + 1
   IF (bcdata(nnbcs)%icend .GT. jp1) THEN
   jp1 = jp1
   ELSE
   jp1 = bcdata(nnbcs)%icend
   END IF
   IF (1 .LT. jp1 - jm1) THEN
   max2 = jp1 - jm1
   ELSE
   max2 = 1
   END IF
   CALL PUSHREAL8ARRAY(a1, realtype/8)
   ! Compute the scaling factor for the central
   ! difference in the j-direction.
   a1 = one/max2
   CALL PUSHINTEGER4ARRAY(jj, inttype/4)
   jj = j - ioffset
   CALL PUSHINTEGER4ARRAY(jjm1, inttype/4)
   jjm1 = jm1 - ioffset
   CALL PUSHINTEGER4ARRAY(jjp1, inttype/4)
   jjp1 = jp1 - ioffset
   ! Compute (twice) the average normal in the generic i,
   ! j and k-direction. Note that in j and k-direction
   ! the average in the original indices should be taken
   ! using j-1 and j (and k-1 and k). However due to the
   ! usage of pointers ssj and ssk there is an offset in
   ! the indices of 1 and therefore now the correct
   ! average is obtained with the indices j and j+1
   ! (k and k+1).
   sixa = two*ssi(jj, kk, 1)
   siya = two*ssi(jj, kk, 2)
   siza = two*ssi(jj, kk, 3)
   CALL PUSHREAL8ARRAY(sjxa, realtype/8)
   ! it was ssj(j,k,1) + ssj(j+1,k,1)
   sjxa = ssj(jj-1, kk, 1) + ssj(jj, kk, 1)
   CALL PUSHREAL8ARRAY(sjya, realtype/8)
   ! it was ssj(j,k,2) + ssj(j+1,k,2)
   sjya = ssj(jj-1, kk, 2) + ssj(jj, kk, 2)
   CALL PUSHREAL8ARRAY(sjza, realtype/8)
   ! it was ssj(j,k,3) + ssj(j+1,k,3)
   sjza = ssj(jj-1, kk, 3) + ssj(jj, kk, 3)
   CALL PUSHREAL8ARRAY(skxa, realtype/8)
   ! it was ssk(j,k,1) + ssk(j,k+1,1)
   skxa = ssk(jj, kk-1, 1) + ssk(jj, kk, 1)
   CALL PUSHREAL8ARRAY(skya, realtype/8)
   ! it was ssk(j,k,2) + ssk(j,k+1,2)
   skya = ssk(jj, kk-1, 2) + ssk(jj, kk, 2)
   CALL PUSHREAL8ARRAY(skza, realtype/8)
   ! it was ssk(j,k,3) + ssk(j,k+1,3)
   skza = ssk(jj, kk-1, 3) + ssk(jj, kk, 3)
   CALL PUSHREAL8ARRAY(rxj, realtype/8)
   ! Compute the difference of the normal vector and
   ! pressure in j and k-direction. As the indices are
   ! restricted to the 1st halo-layer, the computation
   ! of the internal halo values is not consistent;
   ! however this is not really a problem, because these
   ! values are overwritten in the communication pattern.
   rxj = a1*(normadj(nnbcs, jjp1, kk, 1, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 1, sps2))
   CALL PUSHREAL8ARRAY(ryj, realtype/8)
   ryj = a1*(normadj(nnbcs, jjp1, kk, 2, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 2, sps2))
   CALL PUSHREAL8ARRAY(rzj, realtype/8)
   rzj = a1*(normadj(nnbcs, jjp1, kk, 3, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 3, sps2))
   !print *, "jjp1,jjm1, kk =", jjp1,jjm1, kk
   dpj = a1*(padj2(jjp1, kk)-padj2(jjm1, kk))
   CALL PUSHREAL8ARRAY(rxk, realtype/8)
   rxk = b1*(normadj(nnbcs, jj, kkp1, 1, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 1, sps2))
   CALL PUSHREAL8ARRAY(ryk, realtype/8)
   ryk = b1*(normadj(nnbcs, jj, kkp1, 2, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 2, sps2))
   CALL PUSHREAL8ARRAY(rzk, realtype/8)
   rzk = b1*(normadj(nnbcs, jj, kkp1, 3, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 3, sps2))
   !print *, "jj, kkp1, kkm1 =", jj, kkp1, kkm1
   dpk = b1*(padj2(jj, kkp1)-padj2(jj, kkm1))
   CALL PUSHREAL8ARRAY(ri, realtype/8)
   ! Compute the dot product between the unit vector
   ! and the normal vectors in i, j and k-direction.
   ri = normadj(nnbcs, jj, kk, 1, sps2)*sixa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*siya + normadj(nnbcs, jj, kk, 3, sps2&
   &                )*siza
   CALL PUSHREAL8ARRAY(rj, realtype/8)
   rj = normadj(nnbcs, jj, kk, 1, sps2)*sjxa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*sjya + normadj(nnbcs, jj, kk, 3, sps2&
   &                )*sjza
   CALL PUSHREAL8ARRAY(rk, realtype/8)
   rk = normadj(nnbcs, jj, kk, 1, sps2)*skxa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*skya + normadj(nnbcs, jj, kk, 3, sps2&
   &                )*skza
   CALL PUSHREAL8ARRAY(ux, realtype/8)
   ! Store the velocity components in ux, uy and uz and
   ! subtract the mesh velocity if the face is moving.
   ux = wadj2(jj, kk, ivx)
   CALL PUSHREAL8ARRAY(uy, realtype/8)
   uy = wadj2(jj, kk, ivy)
   CALL PUSHREAL8ARRAY(uz, realtype/8)
   uz = wadj2(jj, kk, ivz)
   IF (addgridvelocities) THEN
   ux = ux - ssadj(jj, kk, 1)
   uy = uy - ssadj(jj, kk, 2)
   uz = uz - ssadj(jj, kk, 3)
   END IF
   CALL PUSHREAL8ARRAY(qj, realtype/8)
   ! Compute the velocity components in j and
   ! k-direction.
   qj = ux*sjxa + uy*sjya + uz*sjza
   CALL PUSHREAL8ARRAY(qk, realtype/8)
   qk = ux*skxa + uy*skya + uz*skza
   ! Compute the pressure gradient, which is stored
   ! in pAdj1. I'm not entirely sure whether this
   ! formulation is correct for moving meshes. It could
   ! be that an additional term is needed there.
   padj1(jj, kk) = ((qj*(ux*rxj+uy*ryj+uz*rzj)+qk*(ux*rxk+uy*&
   &                ryk+uz*rzk))*wadj2(jj, kk, irho)-rj*dpj-rk*dpk)/ri
   END DO
   CALL PUSHINTEGER4ARRAY(j - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from4)
   END DO
   CALL PUSHINTEGER4ARRAY(k - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from3)
   CALL PUSHINTEGER4(3)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from5 = jcbeg
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO j=ad_from5,jcend
   ad_from6 = icbeg
   DO i=ad_from6,icend
   CALL PUSHINTEGER4ARRAY(ii, inttype/4)
   ii = i - ioffset
   CALL PUSHINTEGER4ARRAY(jj, inttype/4)
   jj = j - joffset
   !BCData(nn)%rface(i,j)
   rface = rfaceadj(nnbcs, ii, jj, sps2)
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   ! max(zero, pAdj2(ii,jj)-pAdj1(ii,jj) )
   padj1(ii, jj) = padj2(ii, jj) - padj1(ii, jj)
   vn = two*(rface-wadj2(ii, jj, ivx)*normadj(nnbcs, ii, jj, 1&
   &              , sps2)-wadj2(ii, jj, ivy)*normadj(nnbcs, ii, jj, 2, sps2)&
   &              -wadj2(ii, jj, ivz)*normadj(nnbcs, ii, jj, 3, sps2))
   CALL PUSHREAL8ARRAY(wadj1(ii, jj, irho), realtype/8)
   wadj1(ii, jj, irho) = wadj2(ii, jj, irho)
   CALL PUSHREAL8ARRAY(wadj1(ii, jj, ivx), realtype/8)
   wadj1(ii, jj, ivx) = wadj2(ii, jj, ivx) + vn*normadj(nnbcs, &
   &              ii, jj, 1, sps2)
   CALL PUSHREAL8ARRAY(wadj1(ii, jj, ivy), realtype/8)
   wadj1(ii, jj, ivy) = wadj2(ii, jj, ivy) + vn*normadj(nnbcs, &
   &              ii, jj, 2, sps2)
   CALL PUSHREAL8ARRAY(wadj1(ii, jj, ivz), realtype/8)
   wadj1(ii, jj, ivz) = wadj2(ii, jj, ivz) + vn*normadj(nnbcs, &
   &              ii, jj, 3, sps2)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   CALL PUSHREAL8ARRAY(wadj1(ii, jj, l), realtype/8)
   wadj1(ii, jj, l) = wadj2(ii, jj, l)
   END DO
   !
   !        Input the viscous effects - rlv1(), and rev1()
   !
   ! Compute the total energy.
   tmp = ovgm1*padj1(ii, jj) + half*wadj1(ii, jj, irho)*(wadj1(&
   &              ii, jj, ivx)**2+wadj1(ii, jj, ivy)**2+wadj1(ii, jj, ivz)**&
   &              2)
   CALL PUSHREAL8ARRAY(wadj1(ii, jj, irhoe), realtype/8)
   wadj1(ii, jj, irhoe) = tmp
   IF (kpresent) THEN
   tmp0 = wadj1(ii, jj, irhoe) - factk*wadj1(ii, jj, irho)*&
   &                wadj1(ii, jj, itu1)
   CALL PUSHREAL8ARRAY(wadj1(ii, jj, irhoe), realtype/8)
   wadj1(ii, jj, irhoe) = tmp0
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO
   CALL PUSHINTEGER4ARRAY(i - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from6)
   END DO
   CALL PUSHINTEGER4ARRAY(j - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from5)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHREAL8ARRAY(padj0, realtype*5**2/8)
   CALL PUSHREAL8ARRAY(wadj0, realtype*5**2*nw/8)
   CALL EXTRAPOLATE2NDHALONKPC(nnbcs, icbeg, icend, jcbeg, &
   &                                   jcend, ioffset, joffset, wadj0, wadj1&
   &                                   , wadj2, padj0, padj1, padj2)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL REPLACEBCSTATESNKPC(nnbcs, wadj0, wadj1, wadj2, wadj3, &
   &                              padj0, padj1, padj2, padj3, rlvadj1, &
   &                              rlvadj2, revadj1, revadj2, icell, jcell, &
   &                              kcell, wadj, padj, rlvadj, revadj, &
   &                              secondhalo, nn, level, sps, sps2)
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO bocos
   padj0b = 0.0
   padj1b = 0.0
   padj2b = 0.0
   padj3b = 0.0
   wadj0b = 0.0
   wadj1b = 0.0
   wadj2b = 0.0
   DO nnbcs=nbocos,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 3) THEN
   CALL REPLACEBCSTATESNKPC_B(nnbcs, wadj0, wadj0b, wadj1, wadj1b, &
   &                           wadj2, wadj3, padj0, padj0b, padj1, padj1b, &
   &                           padj2, padj3, rlvadj1, rlvadj2, revadj1, &
   &                           revadj2, icell, jcell, kcell, wadj, wadjb, &
   &                           padj, padjb, rlvadj, revadj, secondhalo, nn, &
   &                           level, sps, sps2)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(wadj0, realtype*5**2*nw/8)
   CALL POPREAL8ARRAY(padj0, realtype*5**2/8)
   CALL EXTRAPOLATE2NDHALONKPC_B(nnbcs, icbeg, icend, jcbeg, jcend&
   &                                , ioffset, joffset, wadj0, wadj0b, wadj1&
   &                                , wadj1b, wadj2, wadj2b, padj0, padj0b, &
   &                                padj1, padj1b, padj2, padj2b)
   END IF
   gm53 = gammainf - five*third
   ovgm1 = one/(gammainf-one)
   factk = -(ovgm1*gm53)
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO j=ad_to5,ad_from5,-1
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO i=ad_to6,ad_from6,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   CALL POPREAL8ARRAY(wadj1(ii, jj, irhoe), realtype/8)
   tmp0b = wadj1b(ii, jj, irhoe)
   wadj1b(ii, jj, irhoe) = tmp0b
   wadj1b(ii, jj, irho) = wadj1b(ii, jj, irho) - factk*wadj1(ii&
   &              , jj, itu1)*tmp0b
   wadj1b(ii, jj, itu1) = wadj1b(ii, jj, itu1) - factk*wadj1(ii&
   &              , jj, irho)*tmp0b
   END IF
   CALL POPREAL8ARRAY(wadj1(ii, jj, irhoe), realtype/8)
   tmpb = wadj1b(ii, jj, irhoe)
   wadj1b(ii, jj, irhoe) = 0.0
   temp1b2 = half*wadj1(ii, jj, irho)*tmpb
   padj1b(ii, jj) = padj1b(ii, jj) + ovgm1*tmpb
   wadj1b(ii, jj, irho) = wadj1b(ii, jj, irho) + half*(wadj1(ii, &
   &            jj, ivx)**2+wadj1(ii, jj, ivy)**2+wadj1(ii, jj, ivz)**2)*&
   &            tmpb
   wadj1b(ii, jj, ivx) = wadj1b(ii, jj, ivx) + 2*wadj1(ii, jj, &
   &            ivx)*temp1b2
   wadj1b(ii, jj, ivy) = wadj1b(ii, jj, ivy) + 2*wadj1(ii, jj, &
   &            ivy)*temp1b2
   wadj1b(ii, jj, ivz) = wadj1b(ii, jj, ivz) + 2*wadj1(ii, jj, &
   &            ivz)*temp1b2
   DO l=nt2mg,nt1mg,-1
   CALL POPREAL8ARRAY(wadj1(ii, jj, l), realtype/8)
   wadj2b(ii, jj, l) = wadj2b(ii, jj, l) + wadj1b(ii, jj, l)
   wadj1b(ii, jj, l) = 0.0
   END DO
   CALL POPREAL8ARRAY(wadj1(ii, jj, ivz), realtype/8)
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) + wadj1b(ii, jj, ivz&
   &            )
   vnb = normadj(nnbcs, ii, jj, 3, sps2)*wadj1b(ii, jj, ivz)
   wadj1b(ii, jj, ivz) = 0.0
   CALL POPREAL8ARRAY(wadj1(ii, jj, ivy), realtype/8)
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) + wadj1b(ii, jj, ivy&
   &            )
   vnb = vnb + normadj(nnbcs, ii, jj, 2, sps2)*wadj1b(ii, jj, ivy&
   &            )
   wadj1b(ii, jj, ivy) = 0.0
   CALL POPREAL8ARRAY(wadj1(ii, jj, ivx), realtype/8)
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) + wadj1b(ii, jj, ivx&
   &            )
   vnb = vnb + normadj(nnbcs, ii, jj, 1, sps2)*wadj1b(ii, jj, ivx&
   &            )
   wadj1b(ii, jj, ivx) = 0.0
   CALL POPREAL8ARRAY(wadj1(ii, jj, irho), realtype/8)
   wadj2b(ii, jj, irho) = wadj2b(ii, jj, irho) + wadj1b(ii, jj, &
   &            irho)
   wadj1b(ii, jj, irho) = 0.0
   temp1b1 = two*vnb
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) - normadj(nnbcs, ii&
   &            , jj, 1, sps2)*temp1b1
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) - normadj(nnbcs, ii&
   &            , jj, 2, sps2)*temp1b1
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) - normadj(nnbcs, ii&
   &            , jj, 3, sps2)*temp1b1
   padj2b(ii, jj) = padj2b(ii, jj) + padj1b(ii, jj)
   padj1b(ii, jj) = -padj1b(ii, jj)
   CALL POPINTEGER4ARRAY(jj, inttype/4)
   CALL POPINTEGER4ARRAY(ii, inttype/4)
   END DO
   END DO
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (.NOT.branch .LT. 1) THEN
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO j=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO i=ad_to0,ad_from0,-1
   padj1b(ii, jj) = 0.0
   CALL POPINTEGER4ARRAY(jj, inttype/4)
   CALL POPINTEGER4ARRAY(ii, inttype/4)
   END DO
   END DO
   END IF
   ELSE IF (branch .LT. 3) THEN
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO j=ad_to1,ad_from1,-1
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO i=ad_to2,ad_from2,-1
   padj3b(ii, jj) = padj3b(ii, jj) + padj1b(ii, jj)
   padj2b(ii, jj) = padj2b(ii, jj) - padj1b(ii, jj)
   padj1b(ii, jj) = 0.0
   CALL POPINTEGER4ARRAY(jj, inttype/4)
   CALL POPINTEGER4ARRAY(ii, inttype/4)
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO k=ad_to3,ad_from3,-1
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   temp1b = padj1b(jj, kk)/ri
   temp1b0 = wadj2(jj, kk, irho)*temp1b
   temp0 = rxj*ux + ryj*uy + rzj*uz
   temp0b = qj*temp1b0
   temp = rxk*ux + ryk*uy + rzk*uz
   tempb = qk*temp1b0
   qjb = temp0*temp1b0
   qkb = temp*temp1b0
   uxb = skxa*qkb + sjxa*qjb + rxk*tempb + rxj*temp0b
   uyb = skya*qkb + sjya*qjb + ryk*tempb + ryj*temp0b
   uzb = skza*qkb + sjza*qjb + rzk*tempb + rzj*temp0b
   wadj2b(jj, kk, irho) = wadj2b(jj, kk, irho) + (qj*temp0+qk*&
   &              temp)*temp1b
   dpjb = -(rj*temp1b)
   dpkb = -(rk*temp1b)
   padj1b(jj, kk) = 0.0
   CALL POPREAL8ARRAY(qk, realtype/8)
   CALL POPREAL8ARRAY(qj, realtype/8)
   CALL POPREAL8ARRAY(uz, realtype/8)
   wadj2b(jj, kk, ivz) = wadj2b(jj, kk, ivz) + uzb
   CALL POPREAL8ARRAY(uy, realtype/8)
   wadj2b(jj, kk, ivy) = wadj2b(jj, kk, ivy) + uyb
   CALL POPREAL8ARRAY(ux, realtype/8)
   wadj2b(jj, kk, ivx) = wadj2b(jj, kk, ivx) + uxb
   CALL POPREAL8ARRAY(rk, realtype/8)
   CALL POPREAL8ARRAY(rj, realtype/8)
   CALL POPREAL8ARRAY(ri, realtype/8)
   padj2b(jj, kkp1) = padj2b(jj, kkp1) + b1*dpkb
   padj2b(jj, kkm1) = padj2b(jj, kkm1) - b1*dpkb
   CALL POPREAL8ARRAY(rzk, realtype/8)
   CALL POPREAL8ARRAY(ryk, realtype/8)
   CALL POPREAL8ARRAY(rxk, realtype/8)
   padj2b(jjp1, kk) = padj2b(jjp1, kk) + a1*dpjb
   padj2b(jjm1, kk) = padj2b(jjm1, kk) - a1*dpjb
   CALL POPREAL8ARRAY(rzj, realtype/8)
   CALL POPREAL8ARRAY(ryj, realtype/8)
   CALL POPREAL8ARRAY(rxj, realtype/8)
   CALL POPREAL8ARRAY(skza, realtype/8)
   CALL POPREAL8ARRAY(skya, realtype/8)
   CALL POPREAL8ARRAY(skxa, realtype/8)
   CALL POPREAL8ARRAY(sjza, realtype/8)
   CALL POPREAL8ARRAY(sjya, realtype/8)
   CALL POPREAL8ARRAY(sjxa, realtype/8)
   CALL POPINTEGER4ARRAY(jjp1, inttype/4)
   CALL POPINTEGER4ARRAY(jjm1, inttype/4)
   CALL POPINTEGER4ARRAY(jj, inttype/4)
   CALL POPREAL8ARRAY(a1, realtype/8)
   END DO
   CALL POPINTEGER4ARRAY(kkp1, inttype/4)
   CALL POPINTEGER4ARRAY(kkm1, inttype/4)
   CALL POPINTEGER4ARRAY(kk, inttype/4)
   CALL POPREAL8ARRAY(b1, realtype/8)
   END DO
   END IF
   CALL POPREAL8ARRAY(wadj1, realtype*5**2*nw/8)
   CALL POPREAL8ARRAY(wadj2, realtype*5**2*nw/8)
   CALL POPREAL8ARRAY(padj1, realtype*5**2/8)
   CALL POPREAL8ARRAY(padj2, realtype*5**2/8)
   CALL POPINTEGER4ARRAY(ioffset, inttype/4)
   CALL POPINTEGER4ARRAY(joffset, inttype/4)
   CALL POPINTEGER4ARRAY(icbeg, inttype/4)
   CALL POPINTEGER4ARRAY(jcbeg, inttype/4)
   CALL POPINTEGER4ARRAY(icend, inttype/4)
   CALL POPINTEGER4ARRAY(jcend, inttype/4)
   CALL POPBOOLEAN(secondhalo)
   wadj3b = 0.0
   CALL EXTRACTBCSTATESNKPC_B(nnbcs, wadj, wadjb, padj, padjb, wadj0&
   &                           , wadj0b, wadj1, wadj1b, wadj2, wadj2b, wadj3&
   &                           , wadj3b, padj0, padj0b, padj1, padj1b, padj2&
   &                           , padj2b, padj3, padj3b, rlvadj, revadj, &
   &                           rlvadj1, rlvadj2, revadj1, revadj2, ioffset, &
   &                           joffset, koffset, icell, jcell, kcell, isbeg&
   &                           , jsbeg, ksbeg, isend, jsend, ksend, ibbeg, &
   &                           jbbeg, kbbeg, ibend, jbend, kbend, icbeg, &
   &                           jcbeg, icend, jcend, secondhalo, nn, level, &
   &                           sps, sps2)
   END IF
   CALL POPINTEGER4ARRAY(isbeg, inttype/4)
   CALL POPINTEGER4ARRAY(jsbeg, inttype/4)
   CALL POPINTEGER4ARRAY(ksbeg, inttype/4)
   CALL POPINTEGER4ARRAY(isend, inttype/4)
   CALL POPINTEGER4ARRAY(jsend, inttype/4)
   CALL POPINTEGER4ARRAY(ksend, inttype/4)
   CALL POPINTEGER4ARRAY(ibbeg, inttype/4)
   CALL POPINTEGER4ARRAY(jbbeg, inttype/4)
   CALL POPINTEGER4ARRAY(kbbeg, inttype/4)
   CALL POPINTEGER4ARRAY(ibend, inttype/4)
   CALL POPINTEGER4ARRAY(jbend, inttype/4)
   CALL POPINTEGER4ARRAY(kbend, inttype/4)
   END DO
   END SUBROUTINE BCEULERWALLNKPC_B

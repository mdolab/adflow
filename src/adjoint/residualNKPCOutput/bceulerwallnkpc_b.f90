   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of bceulerwallnkpc in reverse (adjoint) mode:
   !   gradient, with respect to input variables: padj wadj
   !   of linear combination of output variables: padj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcEulerWallAdj.f90                              *
   !      * Author:        Edwin van der Weide,C.A.(sandy)Mader            *
   !      *                Seongim Choi                                    *
   !      * Starting date: 03-21-2006                                      *
   !      * Last modified: 10-22-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCEULERWALLNKPC_B(secondhalo, wadj, wadjb, padj, padjb, sadj&
   &  , siadj, sjadj, skadj, normadj, rfaceadj, icell, jcell, kcell, nn, &
   &  level, sps, sps2)
   USE bctypes
   USE blockpointers, ONLY : bcdata, bcfaceid, addgridvelocities, &
   &  nbocos, bctype
   USE constants
   USE flowvarrefstate
   USE inputdiscretization
   USE inputtimespectral
   USE iteration
   IMPLICIT NONE
   INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
   INTEGER(KIND=INTTYPE) :: level, nn, sps, sps2
   REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: normadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2, ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: rfaceadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sadj
   LOGICAL :: secondhalo
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sjadj
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: skadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(KIND=REALTYPE) :: wadjb(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral)
   INTEGER :: ad_from, ad_from0, ad_from1, ad_from2, ad_from3, ad_from4, &
   &  ad_from5, ad_from6, ad_to, ad_to0, ad_to1, ad_to2, ad_to3, ad_to4, &
   &  ad_to5, ad_to6, branch, max1, max2
   REAL(KIND=REALTYPE) :: a1, b1, skxa, skya, skza
   LOGICAL :: computebc
   REAL(KIND=REALTYPE) :: dpj, dpjb, dpk, dpkb, qj, qjb, qk, qkb, ri, rj&
   &  , rk, temp1b1, vn, vnb
   INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
   INTEGER(KIND=INTTYPE) :: icbeg, icend, jcbeg, jcend, kcbeg, kcend
   INTEGER(KIND=INTTYPE) :: ioffset, joffset, koffset
   INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, kk, l, nnbcs
   INTEGER(KIND=INTTYPE) :: jm1, jp1, km1, kp1
   INTEGER(KIND=INTTYPE) :: jjm1, jjp1, kkm1, kkp1
   INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
   REAL(KIND=REALTYPE) :: padj0(-2:2, -2:2), padj0b(-2:2, -2:2), padj1(-2&
   &  :2, -2:2), padj1b(-2:2, -2:2), temp1b, temp1b0
   REAL(KIND=REALTYPE) :: padj2(-2:2, -2:2), padj2b(-2:2, -2:2), padj3(-2&
   &  :2, -2:2), padj3b(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: revadj1(-2:2, -2:2), revadj2(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: rface
   REAL(KIND=REALTYPE) :: revadj(-2:2, -2:2, -2:2), rlvadj(-2:2, -2:2, -2&
   &  :2)
   REAL(KIND=REALTYPE) :: rlvadj1(-2:2, -2:2), rlvadj2(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: sixa, siya, siza, sjxa, sjya, sjza
   REAL(KIND=REALTYPE) :: ssadj(-2:2, -2:2, 3)
   REAL(KIND=REALTYPE) :: ssi(-3:2, -3:2, 3), ssj(-3:2, -3:2, 3), ssk(-3:&
   &  2, -3:2, 3)
   REAL(KIND=REALTYPE) :: rxj, rxk, ryj, ryk, rzj, rzk, temp, temp0, &
   &  temp0b, tempb
   REAL(KIND=REALTYPE) :: factk, gm53, ovgm1, ux, uxb, uy, uyb, uz, uzb
   REAL(KIND=REALTYPE) :: temp1b2, tmp, tmp0, tmp0b, tmpb, wadj0(-2:2, -2&
   &  :2, nw), wadj0b(-2:2, -2:2, nw), wadj1(-2:2, -2:2, nw), wadj1b(-2:2, &
   &  -2:2, nw)
   REAL(KIND=REALTYPE) :: wadj2(-2:2, -2:2, nw), wadj2b(-2:2, -2:2, nw), &
   &  wadj3(-2:2, -2:2, nw), wadj3b(-2:2, -2:2, nw)
   INTEGER(KIND=INTTYPE) :: walltreatment
   INTRINSIC MAX, MIN
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nnbcs=1,nbocos
   CALL PUSHINTEGER4(kbend)
   CALL PUSHINTEGER4(jbend)
   CALL PUSHINTEGER4(ibend)
   CALL PUSHINTEGER4(kbbeg)
   CALL PUSHINTEGER4(jbbeg)
   CALL PUSHINTEGER4(ibbeg)
   CALL PUSHINTEGER4(ksend)
   CALL PUSHINTEGER4(jsend)
   CALL PUSHINTEGER4(isend)
   CALL PUSHINTEGER4(ksbeg)
   CALL PUSHINTEGER4(jsbeg)
   CALL PUSHINTEGER4(isbeg)
   CALL CHECKOVERLAPNKPC(nnbcs, icell, jcell, kcell, isbeg, jsbeg, &
   &                    ksbeg, isend, jsend, ksend, ibbeg, jbbeg, kbbeg, &
   &                    ibend, jbend, kbend, computebc)
   IF (computebc) THEN
   ! Check for Euler wall boundary condition.
   IF (bctype(nnbcs) .EQ. eulerwall) THEN
   CALL PUSHBOOLEAN(secondhalo)
   CALL PUSHINTEGER4(jcend)
   CALL PUSHINTEGER4(icend)
   CALL PUSHINTEGER4(jcbeg)
   CALL PUSHINTEGER4(icbeg)
   CALL PUSHINTEGER4(joffset)
   CALL PUSHINTEGER4(ioffset)
   CALL PUSHREAL8ARRAY(padj2, 5**2)
   CALL PUSHREAL8ARRAY(padj1, 5**2)
   CALL PUSHREAL8ARRAY(wadj2, 5**2*nw)
   CALL PUSHREAL8ARRAY(wadj1, 5**2*nw)
   ! Set the pointers for the unit normal and the normal
   ! velocity to make the code more readable.
   !!?norm  => BCData(nn)%norm
   !!?rface => BCData(nn)%rface
   !Copy the states and other parameters to subfaces
   CALL EXTRACTBCSTATESNKPC(nnbcs, wadj, padj, wadj0, wadj1, wadj2&
   &                           , wadj3, padj0, padj1, padj2, padj3, rlvadj&
   &                           , revadj, rlvadj1, rlvadj2, revadj1, revadj2&
   &                           , ioffset, joffset, koffset, icell, jcell, &
   &                           kcell, isbeg, jsbeg, ksbeg, isend, jsend, &
   &                           ksend, ibbeg, jbbeg, kbbeg, ibend, jbend, &
   &                           kbend, icbeg, jcbeg, icend, jcend, &
   &                           secondhalo, nn, level, sps, sps2)
   ! Some initialization
   ssi = zero
   ssj = zero
   ssk = zero
   CALL PUSHREAL8(ovgm1)
   ! Easier storage of variables involving gamma.
   ovgm1 = one/(gammainf-one)
   gm53 = gammainf - five*third
   CALL PUSHREAL8(factk)
   factk = -(ovgm1*gm53)
   ! Determine the boundary condition treatment and compute the
   ! undivided pressure gradient accordingly. This gradient is
   ! temporarily stored in the halo pressure.
   SELECT CASE  (wallbctreatment) 
   CASE (constantpressure) 
   ad_from = jcbeg
   ! Constant pressure. Set the gradient to zero.
   DO j=ad_from,jcend
   ad_from0 = icbeg
   DO i=ad_from0,icend
   CALL PUSHINTEGER4(ii)
   ii = i - ioffset
   CALL PUSHINTEGER4(jj)
   jj = j - joffset
   padj1(ii, jj) = zero
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from)
   CALL PUSHINTEGER4(1)
   CASE (linextrapolpressure) 
   ad_from1 = jcbeg
   !===============================================================
   ! Linear extrapolation. Compute the gradient.
   DO j=ad_from1,jcend
   ad_from2 = icbeg
   DO i=ad_from2,icend
   CALL PUSHINTEGER4(ii)
   ii = i - ioffset
   CALL PUSHINTEGER4(jj)
   jj = j - joffset
   padj1(ii, jj) = padj3(ii, jj) - padj2(ii, jj)
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from2)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from1)
   CALL PUSHINTEGER4(2)
   CASE (normalmomentum) 
   !!$
   !!$
   !!$              !===============================================================
   !!$
   !!$           case (quadExtrapolPressure)
   !!$
   !!$              ! Quadratic extrapolation. Does not fit within the
   !!$              ! current data structures.
   !!$              
   !!$              !call terminate("bcEulerWallAdj", "Quadratic extrapolation does not fit within the current data structure for th
   !e boundary stuff")
   !!$              call terminate("bcEulerWallAdj", "Quadratic")
   !!$              !print *, "bcEulerWallAdj: quadExtrapolPressure: STOP"
   !!$
   !===============================================================
   !call terminate("bcEulerWallAdj", &
   !               "No normal momentum in this version.")
   !print *, "bcEulerWallAdj: STOP"
   ! Pressure gradient is computed using the normal momentum
   ! equation. First set a couple of additional variables for
   ! the normals, depending on the block face. Note that the
   ! construction 1: should not be used in these pointers,
   ! because element 0 is needed. Consequently there will be
   ! an offset of 1 for these normals. This is commented in
   ! the code. For moving faces also the grid velocity of
   ! the 1st cell center from the wall is needed.
   SELECT CASE  (bcfaceid(nnbcs)) 
   CASE (imin) 
   IF (secondhalo) THEN
   ssi(:, :, :) = siadj(-1, :, :, :, sps2)
   ssj(:, :, :) = sjadj(0, :, :, :, sps2)
   ssk(:, :, :) = skadj(0, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(0, :, :, :, sps2)
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   ELSE
   ssi(:, :, :) = siadj(-2, :, :, :, sps2)
   ssj(:, :, :) = sjadj(-1, :, :, :, sps2)
   ssk(:, :, :) = skadj(-1, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(-1, :, :, :, sps2)
   CALL PUSHINTEGER4(4)
   ELSE
   CALL PUSHINTEGER4(3)
   END IF
   END IF
   CASE (imax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = siadj(0, :, :, :, sps2)
   ssj(:, :, :) = sjadj(0, :, :, :, sps2)
   ssk(:, :, :) = skadj(0, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(0, :, :, :, sps2)
   CALL PUSHINTEGER4(6)
   ELSE
   CALL PUSHINTEGER4(5)
   END IF
   ELSE
   ssi(:, :, :) = siadj(1, :, :, :, sps2)
   ssj(:, :, :) = sjadj(1, :, :, :, sps2)
   ssk(:, :, :) = skadj(1, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(1, :, :, :, sps2)
   CALL PUSHINTEGER4(8)
   ELSE
   CALL PUSHINTEGER4(7)
   END IF
   END IF
   CASE (jmin) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = sjadj(:, -1, :, :, sps2)
   ssj(:, :, :) = siadj(:, 0, :, :, sps2)
   ssk(:, :, :) = skadj(:, 0, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, 0, :, :, sps2)
   CALL PUSHINTEGER4(10)
   ELSE
   CALL PUSHINTEGER4(9)
   END IF
   ELSE
   ssi(:, :, :) = sjadj(:, -2, :, :, sps2)
   ssj(:, :, :) = siadj(:, -1, :, :, sps2)
   ssk(:, :, :) = skadj(:, -1, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, -1, :, :, sps2)
   CALL PUSHINTEGER4(12)
   ELSE
   CALL PUSHINTEGER4(11)
   END IF
   END IF
   CASE (jmax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = sjadj(:, 0, :, :, sps2)
   ssj(:, :, :) = siadj(:, 0, :, :, sps2)
   ssk(:, :, :) = skadj(:, 0, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, 0, :, :, sps2)
   CALL PUSHINTEGER4(14)
   ELSE
   CALL PUSHINTEGER4(13)
   END IF
   ELSE
   ssi(:, :, :) = sjadj(:, 1, :, :, sps2)
   ssj(:, :, :) = siadj(:, 1, :, :, sps2)
   ssk(:, :, :) = skadj(:, 1, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, 1, :, :, sps2)
   CALL PUSHINTEGER4(16)
   ELSE
   CALL PUSHINTEGER4(15)
   END IF
   END IF
   CASE (kmin) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = skadj(:, :, -1, :, sps2)
   ssj(:, :, :) = siadj(:, :, 0, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 0, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, 0, :, sps2)
   CALL PUSHINTEGER4(18)
   ELSE
   CALL PUSHINTEGER4(17)
   END IF
   ELSE
   ssi(:, :, :) = skadj(:, :, -2, :, sps2)
   ssj(:, :, :) = siadj(:, :, -1, :, sps2)
   ssk(:, :, :) = sjadj(:, :, -1, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, -1, :, sps2)
   CALL PUSHINTEGER4(20)
   ELSE
   CALL PUSHINTEGER4(19)
   END IF
   END IF
   CASE (kmax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = skadj(:, :, 0, :, sps2)
   ssj(:, :, :) = siadj(:, :, 0, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 0, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, 0, :, sps2)
   CALL PUSHINTEGER4(22)
   ELSE
   CALL PUSHINTEGER4(21)
   END IF
   ELSE
   ssi(:, :, :) = skadj(:, :, 1, :, sps2)
   ssj(:, :, :) = siadj(:, :, 1, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 1, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, 1, :, sps2)
   CALL PUSHINTEGER4(24)
   ELSE
   CALL PUSHINTEGER4(23)
   END IF
   END IF
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from3 = jcbeg
   ! Loop over the faces of the generic subface.
   ! Note that now the running indices are j and k. This is
   ! done, because the generic i-direction is assumed to
   ! be the normal direction.
   DO k=ad_from3,jcend
   ! Store the indices k+1, k-1 a bit easier and make
   ! sure that they do not exceed the range of the arrays.
   km1 = k - 1
   IF (bcdata(nnbcs)%jcbeg .LT. km1) THEN
   km1 = km1
   CALL PUSHINTEGER4(1)
   ELSE
   km1 = bcdata(nnbcs)%jcbeg
   CALL PUSHINTEGER4(0)
   END IF
   kp1 = k + 1
   IF (bcdata(nnbcs)%jcend .GT. kp1) THEN
   kp1 = kp1
   CALL PUSHINTEGER4(1)
   ELSE
   kp1 = bcdata(nnbcs)%jcend
   CALL PUSHINTEGER4(0)
   END IF
   IF (1 .LT. kp1 - km1) THEN
   max1 = kp1 - km1
   CALL PUSHINTEGER4(1)
   ELSE
   max1 = 1
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(b1)
   ! Compute the scaling factor for the central difference
   ! in the k-direction.
   b1 = one/max1
   CALL PUSHINTEGER4(kk)
   ! Compute the offset indices.
   kk = k - joffset
   CALL PUSHINTEGER4(kkm1)
   kkm1 = km1 - joffset
   CALL PUSHINTEGER4(kkp1)
   kkp1 = kp1 - joffset
   ad_from4 = icbeg
   ! The generic j-direction.
   DO j=ad_from4,icend
   ! The indices j+1 and j-1. Make sure that they
   ! do not exceed the range of the arrays.
   jm1 = j - 1
   IF (bcdata(nnbcs)%icbeg .LT. jm1) THEN
   jm1 = jm1
   CALL PUSHINTEGER4(1)
   ELSE
   jm1 = bcdata(nnbcs)%icbeg
   CALL PUSHINTEGER4(0)
   END IF
   jp1 = j + 1
   IF (bcdata(nnbcs)%icend .GT. jp1) THEN
   jp1 = jp1
   CALL PUSHINTEGER4(1)
   ELSE
   jp1 = bcdata(nnbcs)%icend
   CALL PUSHINTEGER4(0)
   END IF
   IF (1 .LT. jp1 - jm1) THEN
   max2 = jp1 - jm1
   CALL PUSHINTEGER4(1)
   ELSE
   max2 = 1
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(a1)
   ! Compute the scaling factor for the central
   ! difference in the j-direction.
   a1 = one/max2
   CALL PUSHINTEGER4(jj)
   jj = j - ioffset
   CALL PUSHINTEGER4(jjm1)
   jjm1 = jm1 - ioffset
   CALL PUSHINTEGER4(jjp1)
   jjp1 = jp1 - ioffset
   ! Compute (twice) the average normal in the generic i,
   ! j and k-direction. Note that in j and k-direction
   ! the average in the original indices should be taken
   ! using j-1 and j (and k-1 and k). However due to the
   ! usage of pointers ssj and ssk there is an offset in
   ! the indices of 1 and therefore now the correct
   ! average is obtained with the indices j and j+1
   ! (k and k+1).
   sixa = two*ssi(jj, kk, 1)
   siya = two*ssi(jj, kk, 2)
   siza = two*ssi(jj, kk, 3)
   CALL PUSHREAL8(sjxa)
   ! it was ssj(j,k,1) + ssj(j+1,k,1)
   sjxa = ssj(jj-1, kk, 1) + ssj(jj, kk, 1)
   CALL PUSHREAL8(sjya)
   ! it was ssj(j,k,2) + ssj(j+1,k,2)
   sjya = ssj(jj-1, kk, 2) + ssj(jj, kk, 2)
   CALL PUSHREAL8(sjza)
   ! it was ssj(j,k,3) + ssj(j+1,k,3)
   sjza = ssj(jj-1, kk, 3) + ssj(jj, kk, 3)
   CALL PUSHREAL8(skxa)
   ! it was ssk(j,k,1) + ssk(j,k+1,1)
   skxa = ssk(jj, kk-1, 1) + ssk(jj, kk, 1)
   CALL PUSHREAL8(skya)
   ! it was ssk(j,k,2) + ssk(j,k+1,2)
   skya = ssk(jj, kk-1, 2) + ssk(jj, kk, 2)
   CALL PUSHREAL8(skza)
   ! it was ssk(j,k,3) + ssk(j,k+1,3)
   skza = ssk(jj, kk-1, 3) + ssk(jj, kk, 3)
   CALL PUSHREAL8(rxj)
   ! Compute the difference of the normal vector and
   ! pressure in j and k-direction. As the indices are
   ! restricted to the 1st halo-layer, the computation
   ! of the internal halo values is not consistent;
   ! however this is not really a problem, because these
   ! values are overwritten in the communication pattern.
   rxj = a1*(normadj(nnbcs, jjp1, kk, 1, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 1, sps2))
   CALL PUSHREAL8(ryj)
   ryj = a1*(normadj(nnbcs, jjp1, kk, 2, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 2, sps2))
   CALL PUSHREAL8(rzj)
   rzj = a1*(normadj(nnbcs, jjp1, kk, 3, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 3, sps2))
   !print *, "jjp1,jjm1, kk =", jjp1,jjm1, kk
   dpj = a1*(padj2(jjp1, kk)-padj2(jjm1, kk))
   CALL PUSHREAL8(rxk)
   rxk = b1*(normadj(nnbcs, jj, kkp1, 1, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 1, sps2))
   CALL PUSHREAL8(ryk)
   ryk = b1*(normadj(nnbcs, jj, kkp1, 2, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 2, sps2))
   CALL PUSHREAL8(rzk)
   rzk = b1*(normadj(nnbcs, jj, kkp1, 3, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 3, sps2))
   !print *, "jj, kkp1, kkm1 =", jj, kkp1, kkm1
   dpk = b1*(padj2(jj, kkp1)-padj2(jj, kkm1))
   CALL PUSHREAL8(ri)
   ! Compute the dot product between the unit vector
   ! and the normal vectors in i, j and k-direction.
   ri = normadj(nnbcs, jj, kk, 1, sps2)*sixa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*siya + normadj(nnbcs, jj, kk, 3, &
   &                sps2)*siza
   CALL PUSHREAL8(rj)
   rj = normadj(nnbcs, jj, kk, 1, sps2)*sjxa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*sjya + normadj(nnbcs, jj, kk, 3, &
   &                sps2)*sjza
   CALL PUSHREAL8(rk)
   rk = normadj(nnbcs, jj, kk, 1, sps2)*skxa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*skya + normadj(nnbcs, jj, kk, 3, &
   &                sps2)*skza
   CALL PUSHREAL8(ux)
   ! Store the velocity components in ux, uy and uz and
   ! subtract the mesh velocity if the face is moving.
   ux = wadj2(jj, kk, ivx)
   CALL PUSHREAL8(uy)
   uy = wadj2(jj, kk, ivy)
   CALL PUSHREAL8(uz)
   uz = wadj2(jj, kk, ivz)
   IF (addgridvelocities) THEN
   ux = ux - ssadj(jj, kk, 1)
   uy = uy - ssadj(jj, kk, 2)
   uz = uz - ssadj(jj, kk, 3)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(qj)
   ! Compute the velocity components in j and
   ! k-direction.
   qj = ux*sjxa + uy*sjya + uz*sjza
   CALL PUSHREAL8(qk)
   qk = ux*skxa + uy*skya + uz*skza
   ! Compute the pressure gradient, which is stored
   ! in pAdj1. I'm not entirely sure whether this
   ! formulation is correct for moving meshes. It could
   ! be that an additional term is needed there.
   padj1(jj, kk) = ((qj*(ux*rxj+uy*ryj+uz*rzj)+qk*(ux*rxk+uy*&
   &                ryk+uz*rzk))*wadj2(jj, kk, irho)-rj*dpj-rk*dpk)/ri
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from3)
   CALL PUSHINTEGER4(3)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from5 = jcbeg
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO j=ad_from5,jcend
   ad_from6 = icbeg
   DO i=ad_from6,icend
   CALL PUSHINTEGER4(ii)
   ii = i - ioffset
   CALL PUSHINTEGER4(jj)
   jj = j - joffset
   !BCData(nn)%rface(i,j)
   rface = rfaceadj(nnbcs, ii, jj, sps2)
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   ! max(zero, pAdj2(ii,jj)-pAdj1(ii,jj) )
   padj1(ii, jj) = padj2(ii, jj) - padj1(ii, jj)
   vn = two*(rface-wadj2(ii, jj, ivx)*normadj(nnbcs, ii, jj, 1&
   &              , sps2)-wadj2(ii, jj, ivy)*normadj(nnbcs, ii, jj, 2, sps2&
   &              )-wadj2(ii, jj, ivz)*normadj(nnbcs, ii, jj, 3, sps2))
   CALL PUSHREAL8(wadj1(ii, jj, irho))
   wadj1(ii, jj, irho) = wadj2(ii, jj, irho)
   CALL PUSHREAL8(wadj1(ii, jj, ivx))
   wadj1(ii, jj, ivx) = wadj2(ii, jj, ivx) + vn*normadj(nnbcs, &
   &              ii, jj, 1, sps2)
   CALL PUSHREAL8(wadj1(ii, jj, ivy))
   wadj1(ii, jj, ivy) = wadj2(ii, jj, ivy) + vn*normadj(nnbcs, &
   &              ii, jj, 2, sps2)
   CALL PUSHREAL8(wadj1(ii, jj, ivz))
   wadj1(ii, jj, ivz) = wadj2(ii, jj, ivz) + vn*normadj(nnbcs, &
   &              ii, jj, 3, sps2)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   CALL PUSHREAL8(wadj1(ii, jj, l))
   wadj1(ii, jj, l) = wadj2(ii, jj, l)
   END DO
   !
   !        Input the viscous effects - rlv1(), and rev1()
   !
   ! Compute the total energy.
   tmp = ovgm1*padj1(ii, jj) + half*wadj1(ii, jj, irho)*(wadj1(&
   &              ii, jj, ivx)**2+wadj1(ii, jj, ivy)**2+wadj1(ii, jj, ivz)&
   &              **2)
   CALL PUSHREAL8(wadj1(ii, jj, irhoe))
   wadj1(ii, jj, irhoe) = tmp
   IF (kpresent) THEN
   tmp0 = wadj1(ii, jj, irhoe) - factk*wadj1(ii, jj, irho)*&
   &                wadj1(ii, jj, itu1)
   CALL PUSHREAL8(wadj1(ii, jj, irhoe))
   wadj1(ii, jj, irhoe) = tmp0
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from6)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from5)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHREAL8ARRAY(padj0, 5**2)
   CALL PUSHREAL8ARRAY(wadj0, 5**2*nw)
   CALL EXTRAPOLATE2NDHALONKPC(nnbcs, icbeg, icend, jcbeg, jcend&
   &                                , ioffset, joffset, wadj0, wadj1, wadj2&
   &                                , padj0, padj1, padj2)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL REPLACEBCSTATESNKPC(nnbcs, wadj0, wadj1, wadj2, wadj3, &
   &                           padj0, padj1, padj2, padj3, rlvadj1, rlvadj2&
   &                           , revadj1, revadj2, icell, jcell, kcell, &
   &                           wadj, padj, rlvadj, revadj, secondhalo, nn, &
   &                           level, sps, sps2)
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO bocos
   padj0b(-2:2, -2:2) = 0.0
   padj1b(-2:2, -2:2) = 0.0
   padj2b(-2:2, -2:2) = 0.0
   padj3b(-2:2, -2:2) = 0.0
   wadj0b(-2:2, -2:2, 1:nw) = 0.0
   wadj1b(-2:2, -2:2, 1:nw) = 0.0
   wadj2b(-2:2, -2:2, 1:nw) = 0.0
   DO nnbcs=nbocos,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 3) THEN
   CALL REPLACEBCSTATESNKPC_B(nnbcs, wadj0, wadj0b, wadj1, wadj1b, &
   &                           wadj2, wadj3, padj0, padj0b, padj1, padj1b, &
   &                           padj2, padj3, rlvadj1, rlvadj2, revadj1, &
   &                           revadj2, icell, jcell, kcell, wadj, wadjb, &
   &                           padj, padjb, rlvadj, revadj, secondhalo, nn&
   &                           , level, sps, sps2)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(wadj0, 5**2*nw)
   CALL POPREAL8ARRAY(padj0, 5**2)
   CALL EXTRAPOLATE2NDHALONKPC_B(nnbcs, icbeg, icend, jcbeg, jcend&
   &                                , ioffset, joffset, wadj0, wadj0b, &
   &                                wadj1, wadj1b, wadj2, wadj2b, padj0, &
   &                                padj0b, padj1, padj1b, padj2, padj2b)
   END IF
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO j=ad_to5,ad_from5,-1
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO i=ad_to6,ad_from6,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   CALL POPREAL8(wadj1(ii, jj, irhoe))
   tmp0b = wadj1b(ii, jj, irhoe)
   wadj1b(ii, jj, irhoe) = tmp0b
   wadj1b(ii, jj, irho) = wadj1b(ii, jj, irho) - factk*wadj1(ii&
   &              , jj, itu1)*tmp0b
   wadj1b(ii, jj, itu1) = wadj1b(ii, jj, itu1) - factk*wadj1(ii&
   &              , jj, irho)*tmp0b
   END IF
   CALL POPREAL8(wadj1(ii, jj, irhoe))
   tmpb = wadj1b(ii, jj, irhoe)
   wadj1b(ii, jj, irhoe) = 0.0
   temp1b2 = half*wadj1(ii, jj, irho)*tmpb
   padj1b(ii, jj) = padj1b(ii, jj) + ovgm1*tmpb
   wadj1b(ii, jj, irho) = wadj1b(ii, jj, irho) + half*(wadj1(ii, &
   &            jj, ivx)**2+wadj1(ii, jj, ivy)**2+wadj1(ii, jj, ivz)**2)*&
   &            tmpb
   wadj1b(ii, jj, ivx) = wadj1b(ii, jj, ivx) + 2*wadj1(ii, jj, &
   &            ivx)*temp1b2
   wadj1b(ii, jj, ivy) = wadj1b(ii, jj, ivy) + 2*wadj1(ii, jj, &
   &            ivy)*temp1b2
   wadj1b(ii, jj, ivz) = wadj1b(ii, jj, ivz) + 2*wadj1(ii, jj, &
   &            ivz)*temp1b2
   DO l=nt2mg,nt1mg,-1
   CALL POPREAL8(wadj1(ii, jj, l))
   wadj2b(ii, jj, l) = wadj2b(ii, jj, l) + wadj1b(ii, jj, l)
   wadj1b(ii, jj, l) = 0.0
   END DO
   CALL POPREAL8(wadj1(ii, jj, ivz))
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) + wadj1b(ii, jj, ivz&
   &            )
   vnb = normadj(nnbcs, ii, jj, 3, sps2)*wadj1b(ii, jj, ivz)
   wadj1b(ii, jj, ivz) = 0.0
   CALL POPREAL8(wadj1(ii, jj, ivy))
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) + wadj1b(ii, jj, ivy&
   &            )
   vnb = vnb + normadj(nnbcs, ii, jj, 2, sps2)*wadj1b(ii, jj, ivy&
   &            )
   wadj1b(ii, jj, ivy) = 0.0
   CALL POPREAL8(wadj1(ii, jj, ivx))
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) + wadj1b(ii, jj, ivx&
   &            )
   vnb = vnb + normadj(nnbcs, ii, jj, 1, sps2)*wadj1b(ii, jj, ivx&
   &            )
   wadj1b(ii, jj, ivx) = 0.0
   CALL POPREAL8(wadj1(ii, jj, irho))
   wadj2b(ii, jj, irho) = wadj2b(ii, jj, irho) + wadj1b(ii, jj, &
   &            irho)
   wadj1b(ii, jj, irho) = 0.0
   temp1b1 = two*vnb
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) - normadj(nnbcs, ii&
   &            , jj, 1, sps2)*temp1b1
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) - normadj(nnbcs, ii&
   &            , jj, 2, sps2)*temp1b1
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) - normadj(nnbcs, ii&
   &            , jj, 3, sps2)*temp1b1
   padj2b(ii, jj) = padj2b(ii, jj) + padj1b(ii, jj)
   padj1b(ii, jj) = -padj1b(ii, jj)
   CALL POPINTEGER4(jj)
   CALL POPINTEGER4(ii)
   END DO
   END DO
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (.NOT.branch .LT. 1) THEN
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO j=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO i=ad_to0,ad_from0,-1
   padj1b(ii, jj) = 0.0
   CALL POPINTEGER4(jj)
   CALL POPINTEGER4(ii)
   END DO
   END DO
   END IF
   ELSE IF (branch .LT. 3) THEN
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO j=ad_to1,ad_from1,-1
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO i=ad_to2,ad_from2,-1
   padj3b(ii, jj) = padj3b(ii, jj) + padj1b(ii, jj)
   padj2b(ii, jj) = padj2b(ii, jj) - padj1b(ii, jj)
   padj1b(ii, jj) = 0.0
   CALL POPINTEGER4(jj)
   CALL POPINTEGER4(ii)
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO k=ad_to3,ad_from3,-1
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   temp1b = padj1b(jj, kk)/ri
   temp1b0 = wadj2(jj, kk, irho)*temp1b
   temp0 = rxj*ux + ryj*uy + rzj*uz
   temp0b = qj*temp1b0
   temp = rxk*ux + ryk*uy + rzk*uz
   tempb = qk*temp1b0
   qjb = temp0*temp1b0
   qkb = temp*temp1b0
   uxb = sjxa*qjb + skxa*qkb + rxk*tempb + rxj*temp0b
   uyb = sjya*qjb + skya*qkb + ryk*tempb + ryj*temp0b
   uzb = sjza*qjb + skza*qkb + rzk*tempb + rzj*temp0b
   wadj2b(jj, kk, irho) = wadj2b(jj, kk, irho) + (qj*temp0+qk*&
   &              temp)*temp1b
   dpjb = -(rj*temp1b)
   dpkb = -(rk*temp1b)
   padj1b(jj, kk) = 0.0
   CALL POPREAL8(qk)
   CALL POPREAL8(qj)
   CALL POPINTEGER4(branch)
   CALL POPREAL8(uz)
   wadj2b(jj, kk, ivz) = wadj2b(jj, kk, ivz) + uzb
   CALL POPREAL8(uy)
   wadj2b(jj, kk, ivy) = wadj2b(jj, kk, ivy) + uyb
   CALL POPREAL8(ux)
   wadj2b(jj, kk, ivx) = wadj2b(jj, kk, ivx) + uxb
   CALL POPREAL8(rk)
   CALL POPREAL8(rj)
   CALL POPREAL8(ri)
   padj2b(jj, kkp1) = padj2b(jj, kkp1) + b1*dpkb
   padj2b(jj, kkm1) = padj2b(jj, kkm1) - b1*dpkb
   CALL POPREAL8(rzk)
   CALL POPREAL8(ryk)
   CALL POPREAL8(rxk)
   padj2b(jjp1, kk) = padj2b(jjp1, kk) + a1*dpjb
   padj2b(jjm1, kk) = padj2b(jjm1, kk) - a1*dpjb
   CALL POPREAL8(rzj)
   CALL POPREAL8(ryj)
   CALL POPREAL8(rxj)
   CALL POPREAL8(skza)
   CALL POPREAL8(skya)
   CALL POPREAL8(skxa)
   CALL POPREAL8(sjza)
   CALL POPREAL8(sjya)
   CALL POPREAL8(sjxa)
   CALL POPINTEGER4(jjp1)
   CALL POPINTEGER4(jjm1)
   CALL POPINTEGER4(jj)
   CALL POPREAL8(a1)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END DO
   CALL POPINTEGER4(kkp1)
   CALL POPINTEGER4(kkm1)
   CALL POPINTEGER4(kk)
   CALL POPREAL8(b1)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END DO
   CALL POPINTEGER4(branch)
   END IF
   CALL POPREAL8(factk)
   CALL POPREAL8(ovgm1)
   CALL POPREAL8ARRAY(wadj1, 5**2*nw)
   CALL POPREAL8ARRAY(wadj2, 5**2*nw)
   CALL POPREAL8ARRAY(padj1, 5**2)
   CALL POPREAL8ARRAY(padj2, 5**2)
   CALL POPINTEGER4(ioffset)
   CALL POPINTEGER4(joffset)
   CALL POPINTEGER4(icbeg)
   CALL POPINTEGER4(jcbeg)
   CALL POPINTEGER4(icend)
   CALL POPINTEGER4(jcend)
   CALL POPBOOLEAN(secondhalo)
   wadj3b(:, :, :) = 0.0
   CALL EXTRACTBCSTATESNKPC_B(nnbcs, wadj, wadjb, padj, padjb, wadj0&
   &                           , wadj0b, wadj1, wadj1b, wadj2, wadj2b, &
   &                           wadj3, wadj3b, padj0, padj0b, padj1, padj1b&
   &                           , padj2, padj2b, padj3, padj3b, rlvadj, &
   &                           revadj, rlvadj1, rlvadj2, revadj1, revadj2, &
   &                           ioffset, joffset, koffset, icell, jcell, &
   &                           kcell, isbeg, jsbeg, ksbeg, isend, jsend, &
   &                           ksend, ibbeg, jbbeg, kbbeg, ibend, jbend, &
   &                           kbend, icbeg, jcbeg, icend, jcend, &
   &                           secondhalo, nn, level, sps, sps2)
   END IF
   CALL POPINTEGER4(isbeg)
   CALL POPINTEGER4(jsbeg)
   CALL POPINTEGER4(ksbeg)
   CALL POPINTEGER4(isend)
   CALL POPINTEGER4(jsend)
   CALL POPINTEGER4(ksend)
   CALL POPINTEGER4(ibbeg)
   CALL POPINTEGER4(jbbeg)
   CALL POPINTEGER4(kbbeg)
   CALL POPINTEGER4(ibend)
   CALL POPINTEGER4(jbend)
   CALL POPINTEGER4(kbend)
   END DO
   END SUBROUTINE BCEULERWALLNKPC_B

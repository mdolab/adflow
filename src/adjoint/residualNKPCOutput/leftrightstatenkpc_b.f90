   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of leftrightstatenkpc in reverse (adjoint) mode:
   !   gradient     of useful results: left right du1 du2 du3
   !   with respect to varying inputs: left right du1 du2 du3
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATENKPC_B(du1, du1b, du2, du2b, du3, du3b, left, &
   &  leftb, right, rightb, nwint, omk, opk, factminmod, firstorderk)
   USE PRECISION
   USE INPUTDISCRETIZATION
   USE CONSTANTS
   IMPLICIT NONE
   !
   !        ****************************************************************
   !        *                                                              *
   !        * leftRightState computes the differences in the left and      *
   !        * right state compared to the first order interpolation. For a *
   !        * monotonic second order discretization the interpolations     *
   !        * need to be nonlinear. The linear second order scheme can be  *
   !        * stable (depending on the value of kappa), but it will have   *
   !        * oscillations near discontinuities.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   INTEGER(kind=inttype) :: nwint
   REAL(kind=realtype) :: omk, opk, factminmod
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(*) :: du1b, du2b, du3b
   REAL(kind=realtype), DIMENSION(*) :: left, right
   REAL(kind=realtype), DIMENSION(*) :: leftb, rightb
   LOGICAL :: firstorderk
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp
   REAL(kind=realtype) :: rl1b, rl2b, rr1b, rr2b, tmpb
   INTEGER :: branch
   REAL(kind=realtype) :: x3b
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: y1b
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: x6b
   REAL(kind=realtype) :: y4b
   REAL(kind=realtype) :: max2b
   REAL(kind=realtype) :: temp0b
   REAL(kind=realtype) :: max5b
   INTRINSIC MAX
   REAL(kind=realtype) :: x6
   INTRINSIC SIGN
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: temp3b
   INTRINSIC ABS
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x2b
   REAL(kind=realtype) :: temp2b3
   REAL(kind=realtype) :: temp2b2
   REAL(kind=realtype) :: temp2b1
   REAL(kind=realtype) :: temp2b0
   REAL(kind=realtype) :: x5b
   REAL(kind=realtype) :: y3b
   REAL(kind=realtype) :: max1b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: max4b
   REAL(kind=realtype) :: temp2b
   REAL(kind=realtype) :: x1b
   REAL(kind=realtype) :: x4b
   REAL(kind=realtype) :: y2b
   REAL(kind=realtype) :: max3b
   INTRINSIC MIN
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: temp1b
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max6b
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: temp4b
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: temp4
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Linear interpolation; no limiter.
   ! Loop over the number of variables to be interpolated.
   SELECT CASE  (limiter) 
   CASE (nolimiter) 
   CALL PUSHINTEGER4(1)
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1 = du2(l)
   CALL PUSHINTEGER4(1)
   ELSE
   x1 = -du2(l)
   CALL PUSHINTEGER4(0)
   END IF
   IF (x1 .LT. epslim) THEN
   CALL PUSHREAL8ARRAY(max1, realtype/8)
   max1 = epslim
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(max1, realtype/8)
   max1 = x1
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8ARRAY(tmp, realtype/8)
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max1, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3 = du1(l)
   CALL PUSHINTEGER4(1)
   ELSE
   x3 = -du1(l)
   CALL PUSHINTEGER4(0)
   END IF
   IF (x3 .LT. epslim) THEN
   CALL PUSHREAL8ARRAY(max3, realtype/8)
   max3 = epslim
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(max3, realtype/8)
   max3 = x3
   CALL PUSHINTEGER4(1)
   END IF
   y1 = du2(l)/SIGN(max3, du1(l))
   IF (zero .LT. y1) THEN
   CALL PUSHREAL8ARRAY(rl1, realtype/8)
   rl1 = y1
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(rl1, realtype/8)
   rl1 = zero
   CALL PUSHINTEGER4(1)
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   CALL PUSHREAL8ARRAY(rl2, realtype/8)
   rl2 = du1(l)*tmp
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHREAL8ARRAY(rl2, realtype/8)
   rl2 = zero
   CALL PUSHINTEGER4(0)
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   CALL PUSHREAL8ARRAY(rr1, realtype/8)
   rr1 = du3(l)*tmp
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHREAL8ARRAY(rr1, realtype/8)
   rr1 = zero
   CALL PUSHINTEGER4(0)
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4 = du3(l)
   CALL PUSHINTEGER4(1)
   ELSE
   x4 = -du3(l)
   CALL PUSHINTEGER4(0)
   END IF
   IF (x4 .LT. epslim) THEN
   CALL PUSHREAL8ARRAY(max4, realtype/8)
   max4 = epslim
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(max4, realtype/8)
   max4 = x4
   CALL PUSHINTEGER4(1)
   END IF
   y2 = du2(l)/SIGN(max4, du3(l))
   IF (zero .LT. y2) THEN
   CALL PUSHREAL8ARRAY(rr2, realtype/8)
   rr2 = y2
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(rr2, realtype/8)
   rr2 = zero
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8ARRAY(rl1, realtype/8)
   ! Compute the corresponding limiter values.
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   CALL PUSHREAL8ARRAY(rl2, realtype/8)
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   CALL PUSHREAL8ARRAY(rr1, realtype/8)
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   CALL PUSHREAL8ARRAY(rr2, realtype/8)
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   END DO
   CALL PUSHINTEGER4(2)
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2 = du2(l)
   CALL PUSHINTEGER4(1)
   ELSE
   x2 = -du2(l)
   CALL PUSHINTEGER4(0)
   END IF
   IF (x2 .LT. epslim) THEN
   CALL PUSHREAL8ARRAY(max2, realtype/8)
   max2 = epslim
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(max2, realtype/8)
   max2 = x2
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8ARRAY(tmp, realtype/8)
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5 = du1(l)
   CALL PUSHINTEGER4(1)
   ELSE
   x5 = -du1(l)
   CALL PUSHINTEGER4(0)
   END IF
   IF (x5 .LT. epslim) THEN
   CALL PUSHREAL8ARRAY(max5, realtype/8)
   max5 = epslim
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(max5, realtype/8)
   max5 = x5
   CALL PUSHINTEGER4(1)
   END IF
   y3 = du2(l)/SIGN(max5, du1(l))
   IF (zero .LT. y3) THEN
   CALL PUSHREAL8ARRAY(rl1, realtype/8)
   rl1 = y3
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(rl1, realtype/8)
   rl1 = zero
   CALL PUSHINTEGER4(1)
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   CALL PUSHREAL8ARRAY(rl2, realtype/8)
   rl2 = du1(l)*tmp
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHREAL8ARRAY(rl2, realtype/8)
   rl2 = zero
   CALL PUSHINTEGER4(0)
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   CALL PUSHREAL8ARRAY(rr1, realtype/8)
   rr1 = du3(l)*tmp
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHREAL8ARRAY(rr1, realtype/8)
   rr1 = zero
   CALL PUSHINTEGER4(0)
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6 = du3(l)
   CALL PUSHINTEGER4(1)
   ELSE
   x6 = -du3(l)
   CALL PUSHINTEGER4(0)
   END IF
   IF (x6 .LT. epslim) THEN
   CALL PUSHREAL8ARRAY(max6, realtype/8)
   max6 = epslim
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(max6, realtype/8)
   max6 = x6
   CALL PUSHINTEGER4(1)
   END IF
   y4 = du2(l)/SIGN(max6, du3(l))
   IF (zero .LT. y4) THEN
   CALL PUSHREAL8ARRAY(rr2, realtype/8)
   rr2 = y4
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8ARRAY(rr2, realtype/8)
   rr2 = zero
   CALL PUSHINTEGER4(1)
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1 = factminmod*rl1
   CALL PUSHINTEGER4(1)
   ELSE
   rl1 = one
   CALL PUSHINTEGER4(0)
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2 = factminmod*rl2
   CALL PUSHINTEGER4(1)
   ELSE
   rl2 = one
   CALL PUSHINTEGER4(0)
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1 = factminmod*rr1
   CALL PUSHINTEGER4(1)
   ELSE
   rr1 = one
   CALL PUSHINTEGER4(0)
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2 = factminmod*rr2
   CALL PUSHINTEGER4(1)
   ELSE
   rr2 = one
   CALL PUSHINTEGER4(0)
   END IF
   END DO
   CALL PUSHINTEGER4(3)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   rightb(itu1) = 0.0
   leftb(itu1) = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (.NOT.branch .LT. 1) THEN
   DO l=nwint,1,-1
   du3b(l) = du3b(l) - omk*rightb(l)
   du2b(l) = du2b(l) + opk*leftb(l) - opk*rightb(l)
   rightb(l) = 0.0
   du1b(l) = du1b(l) + omk*leftb(l)
   leftb(l) = 0.0
   END DO
   END IF
   ELSE IF (branch .LT. 3) THEN
   DO l=nwint,1,-1
   rr1b = -(opk*du2(l)*rightb(l))
   du2b(l) = du2b(l) + opk*rl2*leftb(l) - opk*rr1*rightb(l)
   rr2b = -(omk*du3(l)*rightb(l))
   du3b(l) = du3b(l) - omk*rr2*rightb(l)
   rightb(l) = 0.0
   rl1b = omk*du1(l)*leftb(l)
   du1b(l) = du1b(l) + omk*rl1*leftb(l)
   rl2b = opk*du2(l)*leftb(l)
   leftb(l) = 0.0
   CALL POPREAL8ARRAY(rr2, realtype/8)
   temp2b = rr2b/(one+rr2**2)
   rr2b = (2*rr2-rr2**2*(one+rr2)*2/(one+rr2**2)+one)*temp2b
   CALL POPREAL8ARRAY(rr1, realtype/8)
   temp2b0 = rr1b/(one+rr1**2)
   rr1b = (2*rr1-rr1**2*(one+rr1)*2/(one+rr1**2)+one)*temp2b0
   CALL POPREAL8ARRAY(rl2, realtype/8)
   temp2b1 = rl2b/(one+rl2**2)
   rl2b = (2*rl2-rl2**2*(one+rl2)*2/(one+rl2**2)+one)*temp2b1
   CALL POPREAL8ARRAY(rl1, realtype/8)
   temp2b2 = rl1b/(one+rl1**2)
   rl1b = (2*rl1-rl1**2*(one+rl1)*2/(one+rl1**2)+one)*temp2b2
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rr2, realtype/8)
   y2b = rr2b
   ELSE
   CALL POPREAL8ARRAY(rr2, realtype/8)
   y2b = 0.0
   END IF
   temp1 = SIGN(max4, du3(l))
   temp1b = -(du2(l)*y2b/temp1**2)
   du2b(l) = du2b(l) + y2b/temp1
   max4b = SIGN(1.d0, max4*du3(l))*temp1b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(max4, realtype/8)
   x4b = 0.0
   ELSE
   CALL POPREAL8ARRAY(max4, realtype/8)
   x4b = max4b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   du3b(l) = du3b(l) - x4b
   ELSE
   du3b(l) = du3b(l) + x4b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rr1, realtype/8)
   tmpb = 0.0
   ELSE
   CALL POPREAL8ARRAY(rr1, realtype/8)
   du3b(l) = du3b(l) + tmp*rr1b
   tmpb = du3(l)*rr1b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rl2, realtype/8)
   ELSE
   CALL POPREAL8ARRAY(rl2, realtype/8)
   du1b(l) = du1b(l) + tmp*rl2b
   tmpb = tmpb + du1(l)*rl2b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rl1, realtype/8)
   y1b = rl1b
   ELSE
   CALL POPREAL8ARRAY(rl1, realtype/8)
   y1b = 0.0
   END IF
   temp0 = SIGN(max3, du1(l))
   temp0b = -(du2(l)*y1b/temp0**2)
   du2b(l) = du2b(l) + y1b/temp0
   max3b = SIGN(1.d0, max3*du1(l))*temp0b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(max3, realtype/8)
   x3b = 0.0
   ELSE
   CALL POPREAL8ARRAY(max3, realtype/8)
   x3b = max3b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   du1b(l) = du1b(l) - x3b
   ELSE
   du1b(l) = du1b(l) + x3b
   END IF
   CALL POPREAL8ARRAY(tmp, realtype/8)
   temp = SIGN(max1, du2(l))
   tempb = -(one*tmpb/temp**2)
   max1b = SIGN(1.d0, max1*du2(l))*tempb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(max1, realtype/8)
   x1b = 0.0
   ELSE
   CALL POPREAL8ARRAY(max1, realtype/8)
   x1b = max1b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   du2b(l) = du2b(l) - x1b
   ELSE
   du2b(l) = du2b(l) + x1b
   END IF
   END DO
   ELSE
   DO l=nwint,1,-1
   rr1b = -(opk*du2(l)*rightb(l))
   du2b(l) = du2b(l) + opk*rl2*leftb(l) - opk*rr1*rightb(l)
   rr2b = -(omk*du3(l)*rightb(l))
   du3b(l) = du3b(l) - omk*rr2*rightb(l)
   rightb(l) = 0.0
   rl1b = omk*du1(l)*leftb(l)
   du1b(l) = du1b(l) + omk*rl1*leftb(l)
   rl2b = opk*du2(l)*leftb(l)
   leftb(l) = 0.0
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   rr2b = 0.0
   ELSE
   rr2b = factminmod*rr2b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   rr1b = 0.0
   ELSE
   rr1b = factminmod*rr1b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   rl2b = 0.0
   ELSE
   rl2b = factminmod*rl2b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   rl1b = 0.0
   ELSE
   rl1b = factminmod*rl1b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rr2, realtype/8)
   y4b = rr2b
   ELSE
   CALL POPREAL8ARRAY(rr2, realtype/8)
   y4b = 0.0
   END IF
   temp4 = SIGN(max6, du3(l))
   temp4b = -(du2(l)*y4b/temp4**2)
   du2b(l) = du2b(l) + y4b/temp4
   max6b = SIGN(1.d0, max6*du3(l))*temp4b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(max6, realtype/8)
   x6b = 0.0
   ELSE
   CALL POPREAL8ARRAY(max6, realtype/8)
   x6b = max6b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   du3b(l) = du3b(l) - x6b
   ELSE
   du3b(l) = du3b(l) + x6b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rr1, realtype/8)
   tmpb = 0.0
   ELSE
   CALL POPREAL8ARRAY(rr1, realtype/8)
   du3b(l) = du3b(l) + tmp*rr1b
   tmpb = du3(l)*rr1b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rl2, realtype/8)
   ELSE
   CALL POPREAL8ARRAY(rl2, realtype/8)
   du1b(l) = du1b(l) + tmp*rl2b
   tmpb = tmpb + du1(l)*rl2b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(rl1, realtype/8)
   y3b = rl1b
   ELSE
   CALL POPREAL8ARRAY(rl1, realtype/8)
   y3b = 0.0
   END IF
   temp3 = SIGN(max5, du1(l))
   temp3b = -(du2(l)*y3b/temp3**2)
   du2b(l) = du2b(l) + y3b/temp3
   max5b = SIGN(1.d0, max5*du1(l))*temp3b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(max5, realtype/8)
   x5b = 0.0
   ELSE
   CALL POPREAL8ARRAY(max5, realtype/8)
   x5b = max5b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   du1b(l) = du1b(l) - x5b
   ELSE
   du1b(l) = du1b(l) + x5b
   END IF
   CALL POPREAL8ARRAY(tmp, realtype/8)
   temp2 = SIGN(max2, du2(l))
   temp2b3 = -(one*tmpb/temp2**2)
   max2b = SIGN(1.d0, max2*du2(l))*temp2b3
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8ARRAY(max2, realtype/8)
   x2b = 0.0
   ELSE
   CALL POPREAL8ARRAY(max2, realtype/8)
   x2b = max2b
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   du2b(l) = du2b(l) - x2b
   ELSE
   du2b(l) = du2b(l) + x2b
   END IF
   END DO
   END IF
   END SUBROUTINE LEFTRIGHTSTATENKPC_B

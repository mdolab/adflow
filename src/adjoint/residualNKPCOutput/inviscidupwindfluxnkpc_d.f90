   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of inviscidupwindfluxnkpc in forward (tangent) mode:
   !   variations   of useful results: dwadj
   !   with respect to varying inputs: gammaconstant padj dwadj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidUpwindFluxAdj.f90                       *
   !      * Author:        Edwin van der Weide                             *
   !      *                Seongim Choi,C.A.(Sandy)Mader                   *
   !      * Starting date: 03-20-2006                                      *
   !      * Last modified: 04-25-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDUPWINDFLUXNKPC_D(wadj, wadjd, padj, padjd, dwadj, &
   &  dwadjd, siadj, sjadj, skadj, sfaceiadj, sfacejadj, sfacekadj, icell, &
   &  jcell, kcell, finegrid, nn, level, sps)
   USE FLOWVARREFSTATE
   USE BLOCKPOINTERS
   USE INPUTTIMESPECTRAL
   USE INPUTPHYSICS
   USE INPUTDISCRETIZATION
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidUpwindFluxAdj computes the artificial dissipation part *
   !      * the Euler fluxes by means of an approximate solution of the 1D *
   !      * Riemann problem on the face. The fluxes are computed for the   *
   !      * given cell of the block to which the variables in              *
   !      * blockPointers currently point to.                              *
   !      *                                                                *
   !      ******************************************************************
   !
   ! sI,sJ,sK
   ! limiter, firstOrder
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype) :: icell, jcell, kcell, nn, level, sps
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadjd
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padjd
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadj
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadjd
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj, sjadj, skadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj, sfacejadj, sfacekadj
   !
   !      Local variables.
   !
   INTEGER(kind=portype) :: por
   INTEGER(kind=inttype) :: nwint
   INTEGER(kind=inttype) :: i, j, k, ii, jj, kk
   REAL(kind=realtype) :: sx, sy, sz, omk, opk, gammaface, gammaface2
   REAL(kind=realtype) :: factminmod, sface, fact
   REAL(kind=realtype), DIMENSION(nw) :: left, right
   REAL(kind=realtype), DIMENSION(nw) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(nw) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(nw) :: du1d, du2d, du3d
   REAL(kind=realtype), DIMENSION(nwf) :: flux
   REAL(kind=realtype), DIMENSION(nwf) :: fluxd
   LOGICAL :: firstorderk, correctfork, finegrid
   INTRINSIC MAX
   REAL(realType) :: max1
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   correctfork = kpresent
   IF (1.e-10_realType .LT. one - kappacoef) THEN
   max1 = one - kappacoef
   ELSE
   max1 = 1.e-10_realType
   END IF
   ! Compute the factor used in the minmod limiter.
   factminmod = (three-kappacoef)/max1
   ! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
   omk = fourth*(one-kappacoef)
   opk = fourth*(one+kappacoef)
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set the number of variables to be interpolated depending
   ! whether or not a k-equation is present. If a k-equation is
   ! present also set the logical firstOrderK. This indicates
   ! whether or not only a first order approximation is to be used
   ! for the turbulent kinetic energy.
   IF (correctfork) THEN
   IF (orderturb .EQ. firstorder) THEN
   nwint = nwf
   firstorderk = .true.
   ELSE
   nwint = itu1
   firstorderk = .false.
   END IF
   ELSE
   nwint = nwf
   firstorderk = .false.
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Flux computation. A distinction is made between first and      *
   !      * second order schemes to avoid the overhead for the first order *
   !      * scheme.                                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   IF (limiter .EQ. firstorder) THEN
   !
   !        ****************************************************************
   !        *                                                              *
   !        * First order reconstruction. The states in the cells are      *
   !        * constant. The left and right states are constructed easily.  *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   i = icell - 1
   j = jcell
   k = kcell
   fact = -one
   fluxd = 0.0
   leftd = 0.0
   rightd = 0.0
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO ii=-1,0
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = siadj(ii, 0, 0, 1, sps)
   sy = siadj(ii, 0, 0, 2, sps)
   sz = siadj(ii, 0, 0, 3, sps)
   por = pori(i, j, k)
   IF (addgridvelocities) sface = sfaceiadj(ii, 0, 0, sps)
   ! Determine the left and right state.
   leftd(irho) = wadjd(ii, 0, 0, irho, sps)
   left(irho) = wadj(ii, 0, 0, irho, sps)
   leftd(ivx) = wadjd(ii, 0, 0, ivx, sps)
   left(ivx) = wadj(ii, 0, 0, ivx, sps)
   leftd(ivy) = wadjd(ii, 0, 0, ivy, sps)
   left(ivy) = wadj(ii, 0, 0, ivy, sps)
   leftd(ivz) = wadjd(ii, 0, 0, ivz, sps)
   left(ivz) = wadj(ii, 0, 0, ivz, sps)
   leftd(irhoe) = padjd(ii, 0, 0, sps)
   left(irhoe) = padj(ii, 0, 0, sps)
   IF (correctfork) THEN
   leftd(itu1) = wadjd(ii, 0, 0, itu1, sps)
   left(itu1) = wadj(ii, 0, 0, itu1, sps)
   END IF
   rightd(irho) = wadjd(ii+1, 0, 0, irho, sps)
   right(irho) = wadj(ii+1, 0, 0, irho, sps)
   rightd(ivx) = wadjd(ii+1, 0, 0, ivx, sps)
   right(ivx) = wadj(ii+1, 0, 0, ivx, sps)
   rightd(ivy) = wadjd(ii+1, 0, 0, ivy, sps)
   right(ivy) = wadj(ii+1, 0, 0, ivy, sps)
   rightd(ivz) = wadjd(ii+1, 0, 0, ivz, sps)
   right(ivz) = wadj(ii+1, 0, 0, ivz, sps)
   rightd(irhoe) = padjd(ii+1, 0, 0, sps)
   right(irhoe) = padj(ii+1, 0, 0, sps)
   IF (correctfork) THEN
   rightd(itu1) = wadjd(ii+1, 0, 0, itu1, sps)
   right(itu1) = wadj(ii+1, 0, 0, itu1, sps)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   gammaface2 = half*(gamma(i, j, k)+gamma(i+1, j, k))
   !print *,'gammaface',gammaface,gammaface2
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left,right,flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXNKPC_D(left, leftd, right, rightd, flux, fluxd, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fluxd(irho)
   dwadj(irho, sps) = dwadj(irho, sps) + fact*flux(irho)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fluxd(imx)
   dwadj(imx, sps) = dwadj(imx, sps) + fact*flux(imx)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fluxd(imy)
   dwadj(imy, sps) = dwadj(imy, sps) + fact*flux(imy)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fluxd(imz)
   dwadj(imz, sps) = dwadj(imz, sps) + fact*flux(imz)
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fluxd(irhoe)
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*flux(irhoe)
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   fact = one
   END DO
   ! Fluxes in j-direction.
   i = icell
   j = jcell - 1
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = sjadj(0, jj, 0, 1, sps)
   sy = sjadj(0, jj, 0, 2, sps)
   sz = sjadj(0, jj, 0, 3, sps)
   por = porj(i, j, k)
   IF (addgridvelocities) sface = sfacejadj(0, jj, 0, sps)
   ! Determine the left and right state.
   leftd(irho) = wadjd(0, jj, 0, irho, sps)
   left(irho) = wadj(0, jj, 0, irho, sps)
   leftd(ivx) = wadjd(0, jj, 0, ivx, sps)
   left(ivx) = wadj(0, jj, 0, ivx, sps)
   leftd(ivy) = wadjd(0, jj, 0, ivy, sps)
   left(ivy) = wadj(0, jj, 0, ivy, sps)
   leftd(ivz) = wadjd(0, jj, 0, ivz, sps)
   left(ivz) = wadj(0, jj, 0, ivz, sps)
   leftd(irhoe) = padjd(0, jj, 0, sps)
   left(irhoe) = padj(0, jj, 0, sps)
   IF (correctfork) THEN
   leftd(itu1) = wadjd(0, jj, 0, itu1, sps)
   left(itu1) = wadj(0, jj, 0, itu1, sps)
   END IF
   rightd(irho) = wadjd(0, jj+1, 0, irho, sps)
   right(irho) = wadj(0, jj+1, 0, irho, sps)
   rightd(ivx) = wadjd(0, jj+1, 0, ivx, sps)
   right(ivx) = wadj(0, jj+1, 0, ivx, sps)
   rightd(ivy) = wadjd(0, jj+1, 0, ivy, sps)
   right(ivy) = wadj(0, jj+1, 0, ivy, sps)
   rightd(ivz) = wadjd(0, jj+1, 0, ivz, sps)
   right(ivz) = wadj(0, jj+1, 0, ivz, sps)
   rightd(irhoe) = padjd(0, jj+1, 0, sps)
   right(irhoe) = padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   rightd(itu1) = wadjd(0, jj+1, 0, itu1, sps)
   right(itu1) = wadj(0, jj+1, 0, itu1, sps)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXNKPC_D(left, leftd, right, rightd, flux, fluxd, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fluxd(irho)
   dwadj(irho, sps) = dwadj(irho, sps) + fact*flux(irho)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fluxd(imx)
   dwadj(imx, sps) = dwadj(imx, sps) + fact*flux(imx)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fluxd(imy)
   dwadj(imy, sps) = dwadj(imy, sps) + fact*flux(imy)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fluxd(imz)
   dwadj(imz, sps) = dwadj(imz, sps) + fact*flux(imz)
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fluxd(irhoe)
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*flux(irhoe)
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   fact = one
   END DO
   ! Fluxes in k-direction.
   i = icell
   j = jcell
   k = kcell - 1
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = skadj(0, 0, kk, 1, sps)
   sy = skadj(0, 0, kk, 2, sps)
   sz = skadj(0, 0, kk, 3, sps)
   por = pork(i, j, k)
   IF (addgridvelocities) sface = sfacekadj(0, 0, kk, sps)
   ! Determine the left and right state.
   leftd(irho) = wadjd(0, 0, kk, irho, sps)
   left(irho) = wadj(0, 0, kk, irho, sps)
   leftd(ivx) = wadjd(0, 0, kk, ivx, sps)
   left(ivx) = wadj(0, 0, kk, ivx, sps)
   leftd(ivy) = wadjd(0, 0, kk, ivy, sps)
   left(ivy) = wadj(0, 0, kk, ivy, sps)
   leftd(ivz) = wadjd(0, 0, kk, ivz, sps)
   left(ivz) = wadj(0, 0, kk, ivz, sps)
   leftd(irhoe) = padjd(0, 0, kk, sps)
   left(irhoe) = padj(0, 0, kk, sps)
   IF (correctfork) THEN
   leftd(itu1) = wadjd(0, 0, kk, itu1, sps)
   left(itu1) = wadj(0, 0, kk, itu1, sps)
   END IF
   rightd(irho) = wadjd(0, 0, kk+1, irho, sps)
   right(irho) = wadj(0, 0, kk+1, irho, sps)
   rightd(ivx) = wadjd(0, 0, kk+1, ivx, sps)
   right(ivx) = wadj(0, 0, kk+1, ivx, sps)
   rightd(ivy) = wadjd(0, 0, kk+1, ivy, sps)
   right(ivy) = wadj(0, 0, kk+1, ivy, sps)
   rightd(ivz) = wadjd(0, 0, kk+1, ivz, sps)
   right(ivz) = wadj(0, 0, kk+1, ivz, sps)
   rightd(irhoe) = padjd(0, 0, kk+1, sps)
   right(irhoe) = padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   rightd(itu1) = wadjd(0, 0, kk+1, itu1, sps)
   right(itu1) = wadj(0, 0, kk+1, itu1, sps)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXNKPC_D(left, leftd, right, rightd, flux, fluxd, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fluxd(irho)
   dwadj(irho, sps) = dwadj(irho, sps) + fact*flux(irho)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fluxd(imx)
   dwadj(imx, sps) = dwadj(imx, sps) + fact*flux(imx)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fluxd(imy)
   dwadj(imy, sps) = dwadj(imy, sps) + fact*flux(imy)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fluxd(imz)
   dwadj(imz, sps) = dwadj(imz, sps) + fact*flux(imz)
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fluxd(irhoe)
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*flux(irhoe)
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   fact = one
   END DO
   ELSE
   !      ==================================================================
   !PRINT *,'limiter',limiter
   !      ==================================================================
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Second order reconstruction of the left and right state.     *
   !        * The three differences used in the, possibly nonlinear,       *
   !        * interpolation are constructed here; the actual left and      *
   !        * right states, or at least the differences from the first     *
   !        * order interpolation, are computed in the subroutine          *
   !        * leftRightState.                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   i = icell - 1
   j = jcell
   k = kcell
   fact = -one
   fluxd = 0.0
   leftd = 0.0
   rightd = 0.0
   du1d = 0.0
   du2d = 0.0
   du3d = 0.0
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO ii=-1,0
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1d(irho) = wadjd(ii, 0, 0, irho, sps) - wadjd(ii-1, 0, 0, irho, &
   &        sps)
   du1(irho) = wadj(ii, 0, 0, irho, sps) - wadj(ii-1, 0, 0, irho, sps&
   &        )
   du2d(irho) = wadjd(ii+1, 0, 0, irho, sps) - wadjd(ii, 0, 0, irho, &
   &        sps)
   du2(irho) = wadj(ii+1, 0, 0, irho, sps) - wadj(ii, 0, 0, irho, sps&
   &        )
   du3d(irho) = wadjd(ii+2, 0, 0, irho, sps) - wadjd(ii+1, 0, 0, irho&
   &        , sps)
   du3(irho) = wadj(ii+2, 0, 0, irho, sps) - wadj(ii+1, 0, 0, irho, &
   &        sps)
   du1d(ivx) = wadjd(ii, 0, 0, ivx, sps) - wadjd(ii-1, 0, 0, ivx, sps&
   &        )
   du1(ivx) = wadj(ii, 0, 0, ivx, sps) - wadj(ii-1, 0, 0, ivx, sps)
   du2d(ivx) = wadjd(ii+1, 0, 0, ivx, sps) - wadjd(ii, 0, 0, ivx, sps&
   &        )
   du2(ivx) = wadj(ii+1, 0, 0, ivx, sps) - wadj(ii, 0, 0, ivx, sps)
   du3d(ivx) = wadjd(ii+2, 0, 0, ivx, sps) - wadjd(ii+1, 0, 0, ivx, &
   &        sps)
   du3(ivx) = wadj(ii+2, 0, 0, ivx, sps) - wadj(ii+1, 0, 0, ivx, sps)
   du1d(ivy) = wadjd(ii, 0, 0, ivy, sps) - wadjd(ii-1, 0, 0, ivy, sps&
   &        )
   du1(ivy) = wadj(ii, 0, 0, ivy, sps) - wadj(ii-1, 0, 0, ivy, sps)
   du2d(ivy) = wadjd(ii+1, 0, 0, ivy, sps) - wadjd(ii, 0, 0, ivy, sps&
   &        )
   du2(ivy) = wadj(ii+1, 0, 0, ivy, sps) - wadj(ii, 0, 0, ivy, sps)
   du3d(ivy) = wadjd(ii+2, 0, 0, ivy, sps) - wadjd(ii+1, 0, 0, ivy, &
   &        sps)
   du3(ivy) = wadj(ii+2, 0, 0, ivy, sps) - wadj(ii+1, 0, 0, ivy, sps)
   du1d(ivz) = wadjd(ii, 0, 0, ivz, sps) - wadjd(ii-1, 0, 0, ivz, sps&
   &        )
   du1(ivz) = wadj(ii, 0, 0, ivz, sps) - wadj(ii-1, 0, 0, ivz, sps)
   du2d(ivz) = wadjd(ii+1, 0, 0, ivz, sps) - wadjd(ii, 0, 0, ivz, sps&
   &        )
   du2(ivz) = wadj(ii+1, 0, 0, ivz, sps) - wadj(ii, 0, 0, ivz, sps)
   du3d(ivz) = wadjd(ii+2, 0, 0, ivz, sps) - wadjd(ii+1, 0, 0, ivz, &
   &        sps)
   du3(ivz) = wadj(ii+2, 0, 0, ivz, sps) - wadj(ii+1, 0, 0, ivz, sps)
   du1d(irhoe) = padjd(ii, 0, 0, sps) - padjd(ii-1, 0, 0, sps)
   du1(irhoe) = padj(ii, 0, 0, sps) - padj(ii-1, 0, 0, sps)
   du2d(irhoe) = padjd(ii+1, 0, 0, sps) - padjd(ii, 0, 0, sps)
   du2(irhoe) = padj(ii+1, 0, 0, sps) - padj(ii, 0, 0, sps)
   du3d(irhoe) = padjd(ii+2, 0, 0, sps) - padjd(ii+1, 0, 0, sps)
   du3(irhoe) = padj(ii+2, 0, 0, sps) - padj(ii+1, 0, 0, sps)
   !!$           print *,'pAdj',p(i,  j,k) - p(i-1,j,k),pAdj(ii,  0,0) - pAdj(ii-1,0,0),p(i,  j,k),p(i-1,j,k),pAdj(ii,  0,0), pAdj(i
   !i-1,0,0),p(i,  j,k) -pAdj(ii,  0,0),p(i,  j,k) - p(i-1,j,k)-(pAdj(ii,  0,0) - pAdj(ii-1,0,0))
   IF (correctfork) THEN
   du1d(itu1) = wadjd(ii, 0, 0, itu1, sps) - wadjd(ii-1, 0, 0, itu1&
   &          , sps)
   du1(itu1) = wadj(ii, 0, 0, itu1, sps) - wadj(ii-1, 0, 0, itu1, &
   &          sps)
   du2d(itu1) = wadjd(ii+1, 0, 0, itu1, sps) - wadjd(ii, 0, 0, itu1&
   &          , sps)
   du2(itu1) = wadj(ii+1, 0, 0, itu1, sps) - wadj(ii, 0, 0, itu1, &
   &          sps)
   du3d(itu1) = wadjd(ii+2, 0, 0, itu1, sps) - wadjd(ii+1, 0, 0, &
   &          itu1, sps)
   du3(itu1) = wadj(ii+2, 0, 0, itu1, sps) - wadj(ii+1, 0, 0, itu1&
   &          , sps)
   END IF
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATENKPC_D(du1, du1d, du2, du2d, du3, du3d, left, &
   &                          leftd, right, rightd, nwint, omk, opk, &
   &                          factminmod, firstorderk)
   !print *,'leftrightadj',left,right,icell,jcell,kcell
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   leftd(irho) = leftd(irho) + wadjd(ii, 0, 0, irho, sps)
   left(irho) = left(irho) + wadj(ii, 0, 0, irho, sps)
   !print *,'left',left(irho),wAdj(ii,0,0,irho)
   leftd(ivx) = leftd(ivx) + wadjd(ii, 0, 0, ivx, sps)
   left(ivx) = left(ivx) + wadj(ii, 0, 0, ivx, sps)
   leftd(ivy) = leftd(ivy) + wadjd(ii, 0, 0, ivy, sps)
   left(ivy) = left(ivy) + wadj(ii, 0, 0, ivy, sps)
   leftd(ivz) = leftd(ivz) + wadjd(ii, 0, 0, ivz, sps)
   left(ivz) = left(ivz) + wadj(ii, 0, 0, ivz, sps)
   leftd(irhoe) = leftd(irhoe) + padjd(ii, 0, 0, sps)
   left(irhoe) = left(irhoe) + padj(ii, 0, 0, sps)
   rightd(irho) = rightd(irho) + wadjd(ii+1, 0, 0, irho, sps)
   right(irho) = right(irho) + wadj(ii+1, 0, 0, irho, sps)
   rightd(ivx) = rightd(ivx) + wadjd(ii+1, 0, 0, ivx, sps)
   right(ivx) = right(ivx) + wadj(ii+1, 0, 0, ivx, sps)
   rightd(ivy) = rightd(ivy) + wadjd(ii+1, 0, 0, ivy, sps)
   right(ivy) = right(ivy) + wadj(ii+1, 0, 0, ivy, sps)
   rightd(ivz) = rightd(ivz) + wadjd(ii+1, 0, 0, ivz, sps)
   right(ivz) = right(ivz) + wadj(ii+1, 0, 0, ivz, sps)
   rightd(irhoe) = rightd(irhoe) + padjd(ii+1, 0, 0, sps)
   right(irhoe) = right(irhoe) + padj(ii+1, 0, 0, sps)
   IF (correctfork) THEN
   leftd(itu1) = leftd(itu1) + wadjd(ii, 0, 0, itu1, sps)
   left(itu1) = left(itu1) + wadj(ii, 0, 0, itu1, sps)
   rightd(itu1) = rightd(itu1) + wadjd(ii+1, 0, 0, itu1, sps)
   right(itu1) = right(itu1) + wadj(ii+1, 0, 0, itu1, sps)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = siadj(ii, 0, 0, 1, sps)
   sy = siadj(ii, 0, 0, 2, sps)
   sz = siadj(ii, 0, 0, 3, sps)
   por = pori(i, j, k)
   IF (addgridvelocities) sface = sfaceiadj(ii, 0, 0, sps)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   gammaface2 = half*(gamma(i, j, k)+gamma(i+1, j, k))
   !print *,'gammaface',gammaface,gammaface2
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           print *,'leftrightadj',left,right
   !stop
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   !          print *,'riemanninputI',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
   CALL RIEMANNFLUXNKPC_D(left, leftd, right, rightd, flux, fluxd, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   !         print *,'fluxadjI',flux,icell,jcell,kcell
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fluxd(irho)
   dwadj(irho, sps) = dwadj(irho, sps) + fact*flux(irho)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fluxd(imx)
   dwadj(imx, sps) = dwadj(imx, sps) + fact*flux(imx)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fluxd(imy)
   dwadj(imy, sps) = dwadj(imy, sps) + fact*flux(imy)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fluxd(imz)
   dwadj(imz, sps) = dwadj(imz, sps) + fact*flux(imz)
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fluxd(irhoe)
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*flux(irhoe)
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   fact = one
   END DO
   ! Fluxes in the j-direction.
   i = icell
   j = jcell - 1
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1d(irho) = wadjd(0, jj, 0, irho, sps) - wadjd(0, jj-1, 0, irho, &
   &        sps)
   du1(irho) = wadj(0, jj, 0, irho, sps) - wadj(0, jj-1, 0, irho, sps&
   &        )
   du2d(irho) = wadjd(0, jj+1, 0, irho, sps) - wadjd(0, jj, 0, irho, &
   &        sps)
   du2(irho) = wadj(0, jj+1, 0, irho, sps) - wadj(0, jj, 0, irho, sps&
   &        )
   du3d(irho) = wadjd(0, jj+2, 0, irho, sps) - wadjd(0, jj+1, 0, irho&
   &        , sps)
   du3(irho) = wadj(0, jj+2, 0, irho, sps) - wadj(0, jj+1, 0, irho, &
   &        sps)
   du1d(ivx) = wadjd(0, jj, 0, ivx, sps) - wadjd(0, jj-1, 0, ivx, sps&
   &        )
   du1(ivx) = wadj(0, jj, 0, ivx, sps) - wadj(0, jj-1, 0, ivx, sps)
   du2d(ivx) = wadjd(0, jj+1, 0, ivx, sps) - wadjd(0, jj, 0, ivx, sps&
   &        )
   du2(ivx) = wadj(0, jj+1, 0, ivx, sps) - wadj(0, jj, 0, ivx, sps)
   du3d(ivx) = wadjd(0, jj+2, 0, ivx, sps) - wadjd(0, jj+1, 0, ivx, &
   &        sps)
   du3(ivx) = wadj(0, jj+2, 0, ivx, sps) - wadj(0, jj+1, 0, ivx, sps)
   du1d(ivy) = wadjd(0, jj, 0, ivy, sps) - wadjd(0, jj-1, 0, ivy, sps&
   &        )
   du1(ivy) = wadj(0, jj, 0, ivy, sps) - wadj(0, jj-1, 0, ivy, sps)
   du2d(ivy) = wadjd(0, jj+1, 0, ivy, sps) - wadjd(0, jj, 0, ivy, sps&
   &        )
   du2(ivy) = wadj(0, jj+1, 0, ivy, sps) - wadj(0, jj, 0, ivy, sps)
   du3d(ivy) = wadjd(0, jj+2, 0, ivy, sps) - wadjd(0, jj+1, 0, ivy, &
   &        sps)
   du3(ivy) = wadj(0, jj+2, 0, ivy, sps) - wadj(0, jj+1, 0, ivy, sps)
   du1d(ivz) = wadjd(0, jj, 0, ivz, sps) - wadjd(0, jj-1, 0, ivz, sps&
   &        )
   du1(ivz) = wadj(0, jj, 0, ivz, sps) - wadj(0, jj-1, 0, ivz, sps)
   du2d(ivz) = wadjd(0, jj+1, 0, ivz, sps) - wadjd(0, jj, 0, ivz, sps&
   &        )
   du2(ivz) = wadj(0, jj+1, 0, ivz, sps) - wadj(0, jj, 0, ivz, sps)
   du3d(ivz) = wadjd(0, jj+2, 0, ivz, sps) - wadjd(0, jj+1, 0, ivz, &
   &        sps)
   du3(ivz) = wadj(0, jj+2, 0, ivz, sps) - wadj(0, jj+1, 0, ivz, sps)
   du1d(irhoe) = padjd(0, jj, 0, sps) - padjd(0, jj-1, 0, sps)
   du1(irhoe) = padj(0, jj, 0, sps) - padj(0, jj-1, 0, sps)
   du2d(irhoe) = padjd(0, jj+1, 0, sps) - padjd(0, jj, 0, sps)
   du2(irhoe) = padj(0, jj+1, 0, sps) - padj(0, jj, 0, sps)
   du3d(irhoe) = padjd(0, jj+2, 0, sps) - padjd(0, jj+1, 0, sps)
   du3(irhoe) = padj(0, jj+2, 0, sps) - padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   du1d(itu1) = wadjd(0, jj, 0, itu1, sps) - wadjd(0, jj-1, 0, itu1&
   &          , sps)
   du1(itu1) = wadj(0, jj, 0, itu1, sps) - wadj(0, jj-1, 0, itu1, &
   &          sps)
   du2d(itu1) = wadjd(0, jj+1, 0, itu1, sps) - wadjd(0, jj, 0, itu1&
   &          , sps)
   du2(itu1) = wadj(0, jj+1, 0, itu1, sps) - wadj(0, jj, 0, itu1, &
   &          sps)
   du3d(itu1) = wadjd(0, jj+2, 0, itu1, sps) - wadjd(0, jj+1, 0, &
   &          itu1, sps)
   du3(itu1) = wadj(0, jj+2, 0, itu1, sps) - wadj(0, jj+1, 0, itu1&
   &          , sps)
   END IF
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATENKPC_D(du1, du1d, du2, du2d, du3, du3d, left, &
   &                          leftd, right, rightd, nwint, omk, opk, &
   &                          factminmod, firstorderk)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   leftd(irho) = leftd(irho) + wadjd(0, jj, 0, irho, sps)
   left(irho) = left(irho) + wadj(0, jj, 0, irho, sps)
   leftd(ivx) = leftd(ivx) + wadjd(0, jj, 0, ivx, sps)
   left(ivx) = left(ivx) + wadj(0, jj, 0, ivx, sps)
   leftd(ivy) = leftd(ivy) + wadjd(0, jj, 0, ivy, sps)
   left(ivy) = left(ivy) + wadj(0, jj, 0, ivy, sps)
   leftd(ivz) = leftd(ivz) + wadjd(0, jj, 0, ivz, sps)
   left(ivz) = left(ivz) + wadj(0, jj, 0, ivz, sps)
   leftd(irhoe) = leftd(irhoe) + padjd(0, jj, 0, sps)
   left(irhoe) = left(irhoe) + padj(0, jj, 0, sps)
   rightd(irho) = rightd(irho) + wadjd(0, jj+1, 0, irho, sps)
   right(irho) = right(irho) + wadj(0, jj+1, 0, irho, sps)
   rightd(ivx) = rightd(ivx) + wadjd(0, jj+1, 0, ivx, sps)
   right(ivx) = right(ivx) + wadj(0, jj+1, 0, ivx, sps)
   rightd(ivy) = rightd(ivy) + wadjd(0, jj+1, 0, ivy, sps)
   right(ivy) = right(ivy) + wadj(0, jj+1, 0, ivy, sps)
   rightd(ivz) = rightd(ivz) + wadjd(0, jj+1, 0, ivz, sps)
   right(ivz) = right(ivz) + wadj(0, jj+1, 0, ivz, sps)
   rightd(irhoe) = rightd(irhoe) + padjd(0, jj+1, 0, sps)
   right(irhoe) = right(irhoe) + padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   leftd(itu1) = leftd(itu1) + wadjd(0, jj, 0, itu1, sps)
   left(itu1) = left(itu1) + wadj(0, jj, 0, itu1, sps)
   rightd(itu1) = rightd(itu1) + wadjd(0, jj+1, 0, itu1, sps)
   right(itu1) = right(itu1) + wadj(0, jj+1, 0, itu1, sps)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = sjadj(0, jj, 0, 1, sps)
   sy = sjadj(0, jj, 0, 2, sps)
   sz = sjadj(0, jj, 0, 3, sps)
   por = porj(i, j, k)
   IF (addgridvelocities) sface = sfacejadj(0, jj, 0, sps)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXNKPC_D(left, leftd, right, rightd, flux, fluxd, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fluxd(irho)
   dwadj(irho, sps) = dwadj(irho, sps) + fact*flux(irho)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fluxd(imx)
   dwadj(imx, sps) = dwadj(imx, sps) + fact*flux(imx)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fluxd(imy)
   dwadj(imy, sps) = dwadj(imy, sps) + fact*flux(imy)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fluxd(imz)
   dwadj(imz, sps) = dwadj(imz, sps) + fact*flux(imz)
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fluxd(irhoe)
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*flux(irhoe)
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   fact = one
   END DO
   ! Fluxes in the k-direction.
   i = icell
   j = jcell
   k = kcell - 1
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1d(irho) = wadjd(0, 0, kk, irho, sps) - wadjd(0, 0, kk-1, irho, &
   &        sps)
   du1(irho) = wadj(0, 0, kk, irho, sps) - wadj(0, 0, kk-1, irho, sps&
   &        )
   du2d(irho) = wadjd(0, 0, kk+1, irho, sps) - wadjd(0, 0, kk, irho, &
   &        sps)
   du2(irho) = wadj(0, 0, kk+1, irho, sps) - wadj(0, 0, kk, irho, sps&
   &        )
   du3d(irho) = wadjd(0, 0, kk+2, irho, sps) - wadjd(0, 0, kk+1, irho&
   &        , sps)
   du3(irho) = wadj(0, 0, kk+2, irho, sps) - wadj(0, 0, kk+1, irho, &
   &        sps)
   du1d(ivx) = wadjd(0, 0, kk, ivx, sps) - wadjd(0, 0, kk-1, ivx, sps&
   &        )
   du1(ivx) = wadj(0, 0, kk, ivx, sps) - wadj(0, 0, kk-1, ivx, sps)
   du2d(ivx) = wadjd(0, 0, kk+1, ivx, sps) - wadjd(0, 0, kk, ivx, sps&
   &        )
   du2(ivx) = wadj(0, 0, kk+1, ivx, sps) - wadj(0, 0, kk, ivx, sps)
   du3d(ivx) = wadjd(0, 0, kk+2, ivx, sps) - wadjd(0, 0, kk+1, ivx, &
   &        sps)
   du3(ivx) = wadj(0, 0, kk+2, ivx, sps) - wadj(0, 0, kk+1, ivx, sps)
   du1d(ivy) = wadjd(0, 0, kk, ivy, sps) - wadjd(0, 0, kk-1, ivy, sps&
   &        )
   du1(ivy) = wadj(0, 0, kk, ivy, sps) - wadj(0, 0, kk-1, ivy, sps)
   du2d(ivy) = wadjd(0, 0, kk+1, ivy, sps) - wadjd(0, 0, kk, ivy, sps&
   &        )
   du2(ivy) = wadj(0, 0, kk+1, ivy, sps) - wadj(0, 0, kk, ivy, sps)
   du3d(ivy) = wadjd(0, 0, kk+2, ivy, sps) - wadjd(0, 0, kk+1, ivy, &
   &        sps)
   du3(ivy) = wadj(0, 0, kk+2, ivy, sps) - wadj(0, 0, kk+1, ivy, sps)
   du1d(ivz) = wadjd(0, 0, kk, ivz, sps) - wadjd(0, 0, kk-1, ivz, sps&
   &        )
   du1(ivz) = wadj(0, 0, kk, ivz, sps) - wadj(0, 0, kk-1, ivz, sps)
   du2d(ivz) = wadjd(0, 0, kk+1, ivz, sps) - wadjd(0, 0, kk, ivz, sps&
   &        )
   du2(ivz) = wadj(0, 0, kk+1, ivz, sps) - wadj(0, 0, kk, ivz, sps)
   du3d(ivz) = wadjd(0, 0, kk+2, ivz, sps) - wadjd(0, 0, kk+1, ivz, &
   &        sps)
   du3(ivz) = wadj(0, 0, kk+2, ivz, sps) - wadj(0, 0, kk+1, ivz, sps)
   du1d(irhoe) = padjd(0, 0, kk, sps) - padjd(0, 0, kk-1, sps)
   du1(irhoe) = padj(0, 0, kk, sps) - padj(0, 0, kk-1, sps)
   du2d(irhoe) = padjd(0, 0, kk+1, sps) - padjd(0, 0, kk, sps)
   du2(irhoe) = padj(0, 0, kk+1, sps) - padj(0, 0, kk, sps)
   du3d(irhoe) = padjd(0, 0, kk+2, sps) - padjd(0, 0, kk+1, sps)
   du3(irhoe) = padj(0, 0, kk+2, sps) - padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   du1d(itu1) = wadjd(0, 0, kk, itu1, sps) - wadjd(0, 0, kk-1, itu1&
   &          , sps)
   du1(itu1) = wadj(0, 0, kk, itu1, sps) - wadj(0, 0, kk-1, itu1, &
   &          sps)
   du2d(itu1) = wadjd(0, 0, kk+1, itu1, sps) - wadjd(0, 0, kk, itu1&
   &          , sps)
   du2(itu1) = wadj(0, 0, kk+1, itu1, sps) - wadj(0, 0, kk, itu1, &
   &          sps)
   du3d(itu1) = wadjd(0, 0, kk+2, itu1, sps) - wadjd(0, 0, kk+1, &
   &          itu1, sps)
   du3(itu1) = wadj(0, 0, kk+2, itu1, sps) - wadj(0, 0, kk+1, itu1&
   &          , sps)
   END IF
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATENKPC_D(du1, du1d, du2, du2d, du3, du3d, left, &
   &                          leftd, right, rightd, nwint, omk, opk, &
   &                          factminmod, firstorderk)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   leftd(irho) = leftd(irho) + wadjd(0, 0, kk, irho, sps)
   left(irho) = left(irho) + wadj(0, 0, kk, irho, sps)
   leftd(ivx) = leftd(ivx) + wadjd(0, 0, kk, ivx, sps)
   left(ivx) = left(ivx) + wadj(0, 0, kk, ivx, sps)
   leftd(ivy) = leftd(ivy) + wadjd(0, 0, kk, ivy, sps)
   left(ivy) = left(ivy) + wadj(0, 0, kk, ivy, sps)
   leftd(ivz) = leftd(ivz) + wadjd(0, 0, kk, ivz, sps)
   left(ivz) = left(ivz) + wadj(0, 0, kk, ivz, sps)
   leftd(irhoe) = leftd(irhoe) + padjd(0, 0, kk, sps)
   left(irhoe) = left(irhoe) + padj(0, 0, kk, sps)
   rightd(irho) = rightd(irho) + wadjd(0, 0, kk+1, irho, sps)
   right(irho) = right(irho) + wadj(0, 0, kk+1, irho, sps)
   rightd(ivx) = rightd(ivx) + wadjd(0, 0, kk+1, ivx, sps)
   right(ivx) = right(ivx) + wadj(0, 0, kk+1, ivx, sps)
   rightd(ivy) = rightd(ivy) + wadjd(0, 0, kk+1, ivy, sps)
   right(ivy) = right(ivy) + wadj(0, 0, kk+1, ivy, sps)
   rightd(ivz) = rightd(ivz) + wadjd(0, 0, kk+1, ivz, sps)
   right(ivz) = right(ivz) + wadj(0, 0, kk+1, ivz, sps)
   rightd(irhoe) = rightd(irhoe) + padjd(0, 0, kk+1, sps)
   right(irhoe) = right(irhoe) + padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   leftd(itu1) = leftd(itu1) + wadjd(0, 0, kk, itu1, sps)
   left(itu1) = left(itu1) + wadj(0, 0, kk, itu1, sps)
   rightd(itu1) = rightd(itu1) + wadjd(0, 0, kk+1, itu1, sps)
   right(itu1) = right(itu1) + wadj(0, 0, kk+1, itu1, sps)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = skadj(0, 0, kk, 1, sps)
   sy = skadj(0, 0, kk, 2, sps)
   sz = skadj(0, 0, kk, 3, sps)
   por = pork(i, j, k)
   IF (addgridvelocities) sface = sfacekadj(0, 0, kk, sps)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   !           print *,'riemanninputk',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
   CALL RIEMANNFLUXNKPC_D(left, leftd, right, rightd, flux, fluxd, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fluxd(irho)
   dwadj(irho, sps) = dwadj(irho, sps) + fact*flux(irho)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fluxd(imx)
   dwadj(imx, sps) = dwadj(imx, sps) + fact*flux(imx)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fluxd(imy)
   dwadj(imy, sps) = dwadj(imy, sps) + fact*flux(imy)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fluxd(imz)
   dwadj(imz, sps) = dwadj(imz, sps) + fact*flux(imz)
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fluxd(irhoe)
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*flux(irhoe)
   !print *,'dwupwind',dwadj,'fact',fact,'flux',flux
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   fact = one
   END DO
   END IF
   END SUBROUTINE INVISCIDUPWINDFLUXNKPC_D

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of initresnkpc in reverse (adjoint) mode:
   !   gradient     of useful results: dwadj wadj
   !   with respect to varying inputs: dwadj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          initres.f90                                     *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-18-2003                                      *
   !      * Last modified: 06-28-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INITRESNKPC_B(varstart, varend, wadj, wadjb, voladj, dwadj, &
   &  dwadjb, nn, level, sps)
   USE INPUTITERATION
   USE BLOCKPOINTERS
   USE INPUTTIMESPECTRAL
   USE INPUTUNSTEADY
   USE INPUTPHYSICS
   USE ITERATION
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * initres initializes the given range of the residual. Either to *
   !      * zero, steady computation, or to an unsteady term for the time  *
   !      * spectral and unsteady modes. For the coarser grid levels the   *
   !      * residual forcing term is taken into account.                   *
   !      *                                                                *
   !      * This is a local routine, so assume that pointers are already   *
   !      * set.                                                           *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: varstart, varend
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadjb
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadj
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral) :: dwadjb
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: voladj
   INTEGER(kind=inttype), INTENT(IN) :: nn, level, sps
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm, ll, ii, jj, i, j, k, l, m
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw) :: wspadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw) :: wspadjb
   REAL(kind=realtype) :: volspadj
   !unsteady and timespectral variables
   REAL(kind=realtype) :: oneoverdt, tmp
   REAL(kind=realtype) :: tmpb
   INTEGER :: branch
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately of no variables are in the range.
   IF (.NOT.varend .LT. varstart) THEN
   ! Determine the equation mode and act accordingly.
   !print *,'equation Mode',equationMode,'ref',steady,timespectral,unsteady
   !switch to if statments. this particular case setup doesn't work
   !with tapenade. The steady case dissappears and Tapenade doesn't
   !know how to handle the empty case....
   !           select case (equationMode)
   !             case (steady)
   IF (equationmode .EQ. steady) THEN
   ! Steady state computation.
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   DO l=varend,varstart,-1
   dwadjb(l, :) = 0.0
   END DO
   END IF
   ELSE IF (equationmode .EQ. unsteady) THEN
   !===========================================================
   !case (unsteady)
   ! Unsteady computation.
   ! A further distinction must be made.
   SELECT CASE  (timeintegrationscheme) 
   CASE (explicitrk) 
   DO l=varend,varstart,-1
   dwadjb(l, :) = 0.0
   END DO
   END SELECT
   ELSE IF (equationmode .EQ. timespectral) THEN
   !===========================================================
   ! Time spectral computation. The time derivative of the
   ! current solution is given by a linear combination of
   ! all other solutions, i.e. a matrix vector product.
   ! First store the section to which this block belongs
   ! in jj.
   jj = sectionid
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   ! Loop over the number of terms which contribute
   ! to the time derivative.
   timeloopfine:DO mm=1,ntimeintervalsspectral
   CALL PUSHREAL8ARRAY(wspadj, realtype*5**3*nw/8)
   ! Store the pointer for the variable to be used to
   ! compute the unsteady source term and the volume.
   ! Also store in ii the offset needed for vector
   ! quantities.
   wspadj = wadj(:, :, :, :, mm)
   CALL PUSHREAL8ARRAY(volspadj, realtype/8)
   !(:,:,:,mm)
   volspadj = voladj(mm)
   CALL PUSHINTEGER4ARRAY(ii, inttype/4)
   ii = 3*(mm-1)
   ! Loop over the number of variables to be set.
   varloopfine:DO l=varstart,varend
   ! Test for a momentum variable.
   IF ((l .EQ. ivx .OR. l .EQ. ivy) .OR. l .EQ. ivz) THEN
   ! Momentum variable. A special treatment is
   ! needed because it is a vector and the velocities
   ! are stored instead of the momentum. Set the
   ! coefficient ll, which defines the row of the
   ! matrix used later on.
   IF (l .EQ. ivx) THEN
   CALL PUSHINTEGER4ARRAY(ll, inttype/4)
   ll = 3*sps - 2
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (l .EQ. ivy) THEN
   CALL PUSHINTEGER4ARRAY(ll, inttype/4)
   ll = 3*sps - 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (l .EQ. ivz) THEN
   CALL PUSHINTEGER4ARRAY(ll, inttype/4)
   ll = 3*sps
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(tmp, realtype/8)
   ! Loop over the owned cell centers to add the
   ! contribution from wsp.
   ! Store the matrix vector product with the
   ! velocity in tmp.
   tmp = dvector(jj, ll, ii+1)*wspadj(0, 0, 0, ivx) + dvector&
   &                (jj, ll, ii+2)*wspadj(0, 0, 0, ivy) + dvector(jj, ll, ii&
   &                +3)*wspadj(0, 0, 0, ivz)
   ! Update the residual. Note the
   ! multiplication with the density to obtain
   ! the correct time derivative for the
   ! momentum variable.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   END DO varloopfine
   END DO timeloopfine
   DO mm=ntimeintervalsspectral,1,-1
   wspadjb = 0.0
   DO l=varend,varstart,-1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   tmpb = volspadj*wspadj(0, 0, 0, irho)*dwadjb(l, sps)
   wspadjb(0, 0, 0, irho) = wspadjb(0, 0, 0, irho) + volspadj&
   &                *tmp*dwadjb(l, sps)
   CALL POPREAL8ARRAY(tmp, realtype/8)
   wspadjb(0, 0, 0, ivx) = wspadjb(0, 0, 0, ivx) + dvector(jj&
   &                , ll, ii+1)*tmpb
   wspadjb(0, 0, 0, ivy) = wspadjb(0, 0, 0, ivy) + dvector(jj&
   &                , ll, ii+2)*tmpb
   wspadjb(0, 0, 0, ivz) = wspadjb(0, 0, 0, ivz) + dvector(jj&
   &                , ll, ii+3)*tmpb
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4ARRAY(ll, inttype/&
   &                                                      4)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4ARRAY(ll, inttype/&
   &                                                      4)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4ARRAY(ll, inttype/&
   &                                                      4)
   ELSE
   wspadjb(0, 0, 0, l) = wspadjb(0, 0, 0, l) + dscalar(jj, &
   &                sps, mm)*volspadj*dwadjb(l, sps)
   END IF
   END DO
   CALL POPINTEGER4ARRAY(ii, inttype/4)
   CALL POPREAL8ARRAY(volspadj, realtype/8)
   CALL POPREAL8ARRAY(wspadj, realtype*5**3*nw/8)
   wadjb(:, :, :, :, mm) = wadjb(:, :, :, :, mm) + wspadjb
   END DO
   DO l=varend,varstart,-1
   dwadjb(l, sps) = 0.0
   END DO
   END IF
   END IF
   END IF
   END SUBROUTINE INITRESNKPC_B

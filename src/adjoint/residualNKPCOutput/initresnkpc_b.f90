!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of initresnkpc in reverse (adjoint) mode:
!   gradient, with respect to input variables: wadj
!   of linear combination of output variables: dwadj wadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          initres.f90                                     *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-18-2003                                      *
!      * Last modified: 06-28-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INITRESNKPC_B(varstart, varend, wadj, wadjb, voladj, dwadj, &
     &  dwadjb, nn, level, sps)
  USE blockpointers
  USE flowvarrefstate
  USE inputiteration
  USE inputphysics
  USE inputtimespectral
  USE inputunsteady
  USE iteration
  IMPLICIT NONE
  REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
       &  ntimeintervalsspectral)
  INTEGER(KIND=INTTYPE), INTENT(IN) :: level
  INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
  INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
  INTEGER(KIND=INTTYPE), INTENT(IN) :: varend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: varstart
  REAL(KIND=REALTYPE) :: voladj(ntimeintervalsspectral)
  REAL(KIND=REALTYPE) :: wadj(-2:2, -2:2, -2:2, nw, &
       &  ntimeintervalsspectral), wadjb(-2:2, -2:2, -2:2, nw, &
       &  ntimeintervalsspectral)
  INTEGER :: branch
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, l, ll, m, mm
  REAL(KIND=REALTYPE) :: oneoverdt, tmp, tmpb
  REAL(KIND=REALTYPE) :: volspadj
  REAL(KIND=REALTYPE) :: wspadj(-2:2, -2:2, -2:2, nw), wspadjb(-2:2, -2:&
       &  2, -2:2, nw)
  !
  !      ******************************************************************
  !      *                                                                *
  !      * initres initializes the given range of the residual. Either to *
  !      * zero, steady computation, or to an unsteady term for the time  *
  !      * spectral and unsteady modes. For the coarser grid levels the   *
  !      * residual forcing term is taken into account.                   *
  !      *                                                                *
  !      * This is a local routine, so assume that pointers are already   *
  !      * set.                                                           *
  !      *                                                                *
  !      ******************************************************************
  !
  !
  !      Subroutine arguments.
  !
  !
  !      Local variables.
  !
  !unsteady and timespectral variables
  !
  !      ******************************************************************
  !      *                                                                *
  !      * Begin execution                                                *
  !      *                                                                *
  !      ******************************************************************
  !
  ! Return immediately of no variables are in the range.
  IF (.NOT.varend .LT. varstart) THEN
     ! Determine the equation mode and act accordingly.
     !print *,'equation Mode',equationMode,'ref',steady,timespectral,unsteady
     !switch to if statments. this particular case setup doesn't work
     !with tapenade. The steady case dissappears and Tapenade doesn't
     !know how to handle the empty case....
     !           select case (equationMode)
     !             case (steady)
     IF (.NOT.equationmode .EQ. steady) THEN
        !===========================================================
        IF (.NOT.equationmode .EQ. unsteady) THEN
           !===========================================================
           IF (equationmode .EQ. timespectral) THEN
              ! Time spectral computation. The time derivative of the
              ! current solution is given by a linear combination of
              ! all other solutions, i.e. a matrix vector product.
              ! First store the section to which this block belongs
              ! in jj.
              jj = sectionid
              ! Determine the currently active multigrid level.
              IF (currentlevel .EQ. groundlevel) THEN
                 ! Loop over the number of terms which contribute
                 ! to the time derivative.
                 timeloopfine:DO mm=1,ntimeintervalsspectral
                    CALL PUSHREAL8ARRAY(wspadj, 5**3*nw)
                    ! Store the pointer for the variable to be used to
                    ! compute the unsteady source term and the volume.
                    ! Also store in ii the offset needed for vector
                    ! quantities.
                    wspadj = wadj(:, :, :, :, mm)
                    CALL PUSHREAL8(volspadj)
                    !(:,:,:,mm)
                    volspadj = voladj(mm)
                    CALL PUSHINTEGER4(ii)
                    ii = 3*(mm-1)
                    ! Loop over the number of variables to be set.
                    varloopfine: DO l=varstart,varend
                       ! Test for a momentum variable.
                       IF (l .EQ. ivx .OR. l .EQ. ivy .OR. l .EQ. ivz) THEN
                          ! Momentum variable. A special treatment is
                          ! needed because it is a vector and the velocities
                          ! are stored instead of the momentum. Set the
                          ! coefficient ll, which defines the row of the
                          ! matrix used later on.
                          IF (l .EQ. ivx) THEN
                             CALL PUSHINTEGER4(ll)
                             ll = 3*sps - 2
                             CALL PUSHINTEGER4(1)
                          ELSE
                             CALL PUSHINTEGER4(0)
                          END IF
                          IF (l .EQ. ivy) THEN
                             CALL PUSHINTEGER4(ll)
                             ll = 3*sps - 1
                             CALL PUSHINTEGER4(1)
                          ELSE
                             CALL PUSHINTEGER4(0)
                          END IF
                          IF (l .EQ. ivz) THEN
                             CALL PUSHINTEGER4(ll)
                             ll = 3*sps
                             CALL PUSHINTEGER4(1)
                          ELSE
                             CALL PUSHINTEGER4(0)
                          END IF
                          CALL PUSHREAL8(tmp)
                          ! Loop over the owned cell centers to add the
                          ! contribution from wsp.
                          ! Store the matrix vector product with the
                          ! velocity in tmp.
                          tmp = dvector(jj, ll, ii+1)*wspadj(0, 0, 0, ivx) + &
                               &                    dvector(jj, ll, ii+2)*wspadj(0, 0, 0, ivy) + &
                               &                    dvector(jj, ll, ii+3)*wspadj(0, 0, 0, ivz)
                          ! Update the residual. Note the
                          ! multiplication with the density to obtain
                          ! the correct time derivative for the
                          ! momentum variable.
                          CALL PUSHINTEGER4(1)
                       ELSE
                          CALL PUSHINTEGER4(2)
                       END IF
                    END DO varloopfine
                 END DO timeloopfine
                 DO mm=ntimeintervalsspectral,1,-1
                    wspadjb(-2:2, -2:2, -2:2, 1:nw) = 0.0
                    DO l=varend,varstart,-1
                       CALL POPINTEGER4(branch)
                       IF (branch .LT. 2) THEN
                          tmpb = volspadj*wspadj(0, 0, 0, irho)*dwadjb(l, sps)
                          wspadjb(0, 0, 0, irho) = wspadjb(0, 0, 0, irho) + &
                               &                    volspadj*tmp*dwadjb(l, sps)
                          CALL POPREAL8(tmp)
                          wspadjb(0, 0, 0, ivx) = wspadjb(0, 0, 0, ivx) + &
                               &                    dvector(jj, ll, ii+1)*tmpb
                          wspadjb(0, 0, 0, ivy) = wspadjb(0, 0, 0, ivy) + &
                               &                    dvector(jj, ll, ii+2)*tmpb
                          wspadjb(0, 0, 0, ivz) = wspadjb(0, 0, 0, ivz) + &
                               &                    dvector(jj, ll, ii+3)*tmpb
                          CALL POPINTEGER4(branch)
                          IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
                          CALL POPINTEGER4(branch)
                          IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
                          CALL POPINTEGER4(branch)
                          IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
                       ELSE
                          wspadjb(0, 0, 0, l) = wspadjb(0, 0, 0, l) + dscalar(jj&
                               &                    , sps, mm)*volspadj*dwadjb(l, sps)
                       END IF
                    END DO
                    CALL POPINTEGER4(ii)
                    CALL POPREAL8(volspadj)
                    CALL POPREAL8ARRAY(wspadj, 5**3*nw)
                    wadjb(:, :, :, :, mm) = wadjb(:, :, :, :, mm) + wspadjb
                 END DO
              END IF
           END IF
        END IF
     END IF
  END IF
END SUBROUTINE INITRESNKPC_B

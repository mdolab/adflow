   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of inviscidupwindfluxnkpc in reverse (adjoint) mode:
   !   gradient     of useful results: dwadj
   !   with respect to varying inputs: gammaconstant padj dwadj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidUpwindFluxAdj.f90                       *
   !      * Author:        Edwin van der Weide                             *
   !      *                Seongim Choi,C.A.(Sandy)Mader                   *
   !      * Starting date: 03-20-2006                                      *
   !      * Last modified: 04-25-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDUPWINDFLUXNKPC_B(wadj, wadjb, padj, padjb, dwadj, &
   &  dwadjb, siadj, sjadj, skadj, sfaceiadj, sfacejadj, sfacekadj, icell, &
   &  jcell, kcell, finegrid, nn, level, sps)
   USE BLOCKPOINTERS
   USE INPUTTIMESPECTRAL
   USE INPUTPHYSICS
   USE INPUTDISCRETIZATION
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidUpwindFluxAdj computes the artificial dissipation part *
   !      * the Euler fluxes by means of an approximate solution of the 1D *
   !      * Riemann problem on the face. The fluxes are computed for the   *
   !      * given cell of the block to which the variables in              *
   !      * blockPointers currently point to.                              *
   !      *                                                                *
   !      ******************************************************************
   !
   ! sI,sJ,sK
   ! limiter, firstOrder
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype) :: icell, jcell, kcell, nn, level, sps
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadjb
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral) :: padjb
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadj
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral) :: dwadjb
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj, sjadj, skadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj, sfacejadj, sfacekadj
   !
   !      Local variables.
   !
   INTEGER(kind=portype) :: por
   INTEGER(kind=inttype) :: nwint
   INTEGER(kind=inttype) :: i, j, k, ii, jj, kk
   REAL(kind=realtype) :: sx, sy, sz, omk, opk, gammaface, gammaface2
   REAL(kind=realtype) :: factminmod, sface, fact
   REAL(kind=realtype), DIMENSION(nw) :: left, right
   REAL(kind=realtype), DIMENSION(nw) :: leftb, rightb
   REAL(kind=realtype), DIMENSION(nw) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(nw) :: du1b, du2b, du3b
   REAL(kind=realtype), DIMENSION(nwf) :: flux
   REAL(kind=realtype), DIMENSION(nwf) :: fluxb
   LOGICAL :: firstorderk, correctfork, finegrid
   INTEGER :: branch
   INTRINSIC MAX
   REAL(realType) :: max1
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   correctfork = kpresent
   IF (1.e-10_realType .LT. one - kappacoef) THEN
   max1 = one - kappacoef
   ELSE
   max1 = 1.e-10_realType
   END IF
   ! Compute the factor used in the minmod limiter.
   factminmod = (three-kappacoef)/max1
   ! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
   omk = fourth*(one-kappacoef)
   opk = fourth*(one+kappacoef)
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set the number of variables to be interpolated depending
   ! whether or not a k-equation is present. If a k-equation is
   ! present also set the logical firstOrderK. This indicates
   ! whether or not only a first order approximation is to be used
   ! for the turbulent kinetic energy.
   IF (correctfork) THEN
   IF (orderturb .EQ. firstorder) THEN
   nwint = nwf
   firstorderk = .true.
   ELSE
   nwint = itu1
   firstorderk = .false.
   END IF
   ELSE
   nwint = nwf
   firstorderk = .false.
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Flux computation. A distinction is made between first and      *
   !      * second order schemes to avoid the overhead for the first order *
   !      * scheme.                                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   IF (limiter .EQ. firstorder) THEN
   !
   !        ****************************************************************
   !        *                                                              *
   !        * First order reconstruction. The states in the cells are      *
   !        * constant. The left and right states are constructed easily.  *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   i = icell - 1
   j = jcell
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO ii=-1,0
   CALL PUSHREAL8ARRAY(sx, realtype/8)
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = siadj(ii, 0, 0, 1, sps)
   CALL PUSHREAL8ARRAY(sy, realtype/8)
   sy = siadj(ii, 0, 0, 2, sps)
   CALL PUSHREAL8ARRAY(sz, realtype/8)
   sz = siadj(ii, 0, 0, 3, sps)
   CALL PUSHINTEGER4ARRAY(por, portype/4)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8ARRAY(sface, realtype/8)
   sface = sfaceiadj(ii, 0, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(left(irho), realtype/8)
   ! Determine the left and right state.
   left(irho) = wadj(ii, 0, 0, irho, sps)
   CALL PUSHREAL8ARRAY(left(ivx), realtype/8)
   left(ivx) = wadj(ii, 0, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(left(ivy), realtype/8)
   left(ivy) = wadj(ii, 0, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(left(ivz), realtype/8)
   left(ivz) = wadj(ii, 0, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(left(irhoe), realtype/8)
   left(irhoe) = padj(ii, 0, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(left(itu1), realtype/8)
   left(itu1) = wadj(ii, 0, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right(irho), realtype/8)
   right(irho) = wadj(ii+1, 0, 0, irho, sps)
   CALL PUSHREAL8ARRAY(right(ivx), realtype/8)
   right(ivx) = wadj(ii+1, 0, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(right(ivy), realtype/8)
   right(ivy) = wadj(ii+1, 0, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(right(ivz), realtype/8)
   right(ivz) = wadj(ii+1, 0, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(right(irhoe), realtype/8)
   right(irhoe) = padj(ii+1, 0, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(right(itu1), realtype/8)
   right(itu1) = wadj(ii+1, 0, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   !print *,'gammaface',gammaface,gammaface2
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left,right,flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = one
   END DO
   ! Fluxes in j-direction.
   i = icell
   j = jcell - 1
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   CALL PUSHREAL8ARRAY(sx, realtype/8)
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = sjadj(0, jj, 0, 1, sps)
   CALL PUSHREAL8ARRAY(sy, realtype/8)
   sy = sjadj(0, jj, 0, 2, sps)
   CALL PUSHREAL8ARRAY(sz, realtype/8)
   sz = sjadj(0, jj, 0, 3, sps)
   CALL PUSHINTEGER4ARRAY(por, portype/4)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8ARRAY(sface, realtype/8)
   sface = sfacejadj(0, jj, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(left(irho), realtype/8)
   ! Determine the left and right state.
   left(irho) = wadj(0, jj, 0, irho, sps)
   CALL PUSHREAL8ARRAY(left(ivx), realtype/8)
   left(ivx) = wadj(0, jj, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(left(ivy), realtype/8)
   left(ivy) = wadj(0, jj, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(left(ivz), realtype/8)
   left(ivz) = wadj(0, jj, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(left(irhoe), realtype/8)
   left(irhoe) = padj(0, jj, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(left(itu1), realtype/8)
   left(itu1) = wadj(0, jj, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right(irho), realtype/8)
   right(irho) = wadj(0, jj+1, 0, irho, sps)
   CALL PUSHREAL8ARRAY(right(ivx), realtype/8)
   right(ivx) = wadj(0, jj+1, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(right(ivy), realtype/8)
   right(ivy) = wadj(0, jj+1, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(right(ivz), realtype/8)
   right(ivz) = wadj(0, jj+1, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(right(irhoe), realtype/8)
   right(irhoe) = padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(right(itu1), realtype/8)
   right(itu1) = wadj(0, jj+1, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = one
   END DO
   ! Fluxes in k-direction.
   i = icell
   j = jcell
   k = kcell - 1
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   CALL PUSHREAL8ARRAY(sx, realtype/8)
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = skadj(0, 0, kk, 1, sps)
   CALL PUSHREAL8ARRAY(sy, realtype/8)
   sy = skadj(0, 0, kk, 2, sps)
   CALL PUSHREAL8ARRAY(sz, realtype/8)
   sz = skadj(0, 0, kk, 3, sps)
   CALL PUSHINTEGER4ARRAY(por, portype/4)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8ARRAY(sface, realtype/8)
   sface = sfacekadj(0, 0, kk, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(left(irho), realtype/8)
   ! Determine the left and right state.
   left(irho) = wadj(0, 0, kk, irho, sps)
   CALL PUSHREAL8ARRAY(left(ivx), realtype/8)
   left(ivx) = wadj(0, 0, kk, ivx, sps)
   CALL PUSHREAL8ARRAY(left(ivy), realtype/8)
   left(ivy) = wadj(0, 0, kk, ivy, sps)
   CALL PUSHREAL8ARRAY(left(ivz), realtype/8)
   left(ivz) = wadj(0, 0, kk, ivz, sps)
   CALL PUSHREAL8ARRAY(left(irhoe), realtype/8)
   left(irhoe) = padj(0, 0, kk, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(left(itu1), realtype/8)
   left(itu1) = wadj(0, 0, kk, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right(irho), realtype/8)
   right(irho) = wadj(0, 0, kk+1, irho, sps)
   CALL PUSHREAL8ARRAY(right(ivx), realtype/8)
   right(ivx) = wadj(0, 0, kk+1, ivx, sps)
   CALL PUSHREAL8ARRAY(right(ivy), realtype/8)
   right(ivy) = wadj(0, 0, kk+1, ivy, sps)
   CALL PUSHREAL8ARRAY(right(ivz), realtype/8)
   right(ivz) = wadj(0, 0, kk+1, ivz, sps)
   CALL PUSHREAL8ARRAY(right(irhoe), realtype/8)
   right(irhoe) = padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(right(itu1), realtype/8)
   right(itu1) = wadj(0, 0, kk+1, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = one
   END DO
   padjb = 0.0
   wadjb = 0.0
   fluxb = 0.0
   leftb = 0.0
   rightb = 0.0
   DO kk=0,-1,-1
   CALL POPREAL8ARRAY(fact, realtype/8)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   gammaface = gammaconstant
   CALL RIEMANNFLUXNKPC_B(left, leftb, right, rightb, flux, fluxb, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(right(itu1), realtype/8)
   wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
   &          rightb(itu1)
   rightb(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(right(irhoe), realtype/8)
   padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + rightb(irhoe)
   rightb(irhoe) = 0.0
   CALL POPREAL8ARRAY(right(ivz), realtype/8)
   wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + rightb&
   &        (ivz)
   rightb(ivz) = 0.0
   CALL POPREAL8ARRAY(right(ivy), realtype/8)
   wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + rightb&
   &        (ivy)
   rightb(ivy) = 0.0
   CALL POPREAL8ARRAY(right(ivx), realtype/8)
   wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + rightb&
   &        (ivx)
   rightb(ivx) = 0.0
   CALL POPREAL8ARRAY(right(irho), realtype/8)
   wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + &
   &        rightb(irho)
   rightb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(left(itu1), realtype/8)
   wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + leftb(&
   &          itu1)
   leftb(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(left(irhoe), realtype/8)
   padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + leftb(irhoe)
   leftb(irhoe) = 0.0
   CALL POPREAL8ARRAY(left(ivz), realtype/8)
   wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + leftb(ivz)
   leftb(ivz) = 0.0
   CALL POPREAL8ARRAY(left(ivy), realtype/8)
   wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + leftb(ivy)
   leftb(ivy) = 0.0
   CALL POPREAL8ARRAY(left(ivx), realtype/8)
   wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + leftb(ivx)
   leftb(ivx) = 0.0
   CALL POPREAL8ARRAY(left(irho), realtype/8)
   wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + leftb(&
   &        irho)
   leftb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPREAL8ARRAY(sface, realtype/8)
   CALL POPINTEGER4ARRAY(por, portype/4)
   CALL POPREAL8ARRAY(sz, realtype/8)
   CALL POPREAL8ARRAY(sy, realtype/8)
   CALL POPREAL8ARRAY(sx, realtype/8)
   END DO
   i = icell
   k = kcell
   DO jj=0,-1,-1
   CALL POPREAL8ARRAY(fact, realtype/8)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   gammaface = gammaconstant
   CALL RIEMANNFLUXNKPC_B(left, leftb, right, rightb, flux, fluxb, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(right(itu1), realtype/8)
   wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
   &          rightb(itu1)
   rightb(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(right(irhoe), realtype/8)
   padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + rightb(irhoe)
   rightb(irhoe) = 0.0
   CALL POPREAL8ARRAY(right(ivz), realtype/8)
   wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + rightb&
   &        (ivz)
   rightb(ivz) = 0.0
   CALL POPREAL8ARRAY(right(ivy), realtype/8)
   wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + rightb&
   &        (ivy)
   rightb(ivy) = 0.0
   CALL POPREAL8ARRAY(right(ivx), realtype/8)
   wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + rightb&
   &        (ivx)
   rightb(ivx) = 0.0
   CALL POPREAL8ARRAY(right(irho), realtype/8)
   wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + &
   &        rightb(irho)
   rightb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(left(itu1), realtype/8)
   wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + leftb(&
   &          itu1)
   leftb(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(left(irhoe), realtype/8)
   padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + leftb(irhoe)
   leftb(irhoe) = 0.0
   CALL POPREAL8ARRAY(left(ivz), realtype/8)
   wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + leftb(ivz)
   leftb(ivz) = 0.0
   CALL POPREAL8ARRAY(left(ivy), realtype/8)
   wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + leftb(ivy)
   leftb(ivy) = 0.0
   CALL POPREAL8ARRAY(left(ivx), realtype/8)
   wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + leftb(ivx)
   leftb(ivx) = 0.0
   CALL POPREAL8ARRAY(left(irho), realtype/8)
   wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + leftb(&
   &        irho)
   leftb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPREAL8ARRAY(sface, realtype/8)
   CALL POPINTEGER4ARRAY(por, portype/4)
   CALL POPREAL8ARRAY(sz, realtype/8)
   CALL POPREAL8ARRAY(sy, realtype/8)
   CALL POPREAL8ARRAY(sx, realtype/8)
   END DO
   j = jcell
   k = kcell
   DO ii=0,-1,-1
   CALL POPREAL8ARRAY(fact, realtype/8)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   gammaface = gammaconstant
   CALL RIEMANNFLUXNKPC_B(left, leftb, right, rightb, flux, fluxb, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(right(itu1), realtype/8)
   wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
   &          rightb(itu1)
   rightb(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(right(irhoe), realtype/8)
   padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + rightb(irhoe)
   rightb(irhoe) = 0.0
   CALL POPREAL8ARRAY(right(ivz), realtype/8)
   wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + rightb&
   &        (ivz)
   rightb(ivz) = 0.0
   CALL POPREAL8ARRAY(right(ivy), realtype/8)
   wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + rightb&
   &        (ivy)
   rightb(ivy) = 0.0
   CALL POPREAL8ARRAY(right(ivx), realtype/8)
   wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + rightb&
   &        (ivx)
   rightb(ivx) = 0.0
   CALL POPREAL8ARRAY(right(irho), realtype/8)
   wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + &
   &        rightb(irho)
   rightb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(left(itu1), realtype/8)
   wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + leftb(&
   &          itu1)
   leftb(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(left(irhoe), realtype/8)
   padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + leftb(irhoe)
   leftb(irhoe) = 0.0
   CALL POPREAL8ARRAY(left(ivz), realtype/8)
   wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + leftb(ivz)
   leftb(ivz) = 0.0
   CALL POPREAL8ARRAY(left(ivy), realtype/8)
   wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + leftb(ivy)
   leftb(ivy) = 0.0
   CALL POPREAL8ARRAY(left(ivx), realtype/8)
   wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + leftb(ivx)
   leftb(ivx) = 0.0
   CALL POPREAL8ARRAY(left(irho), realtype/8)
   wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + leftb(&
   &        irho)
   leftb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPREAL8ARRAY(sface, realtype/8)
   CALL POPINTEGER4ARRAY(por, portype/4)
   CALL POPREAL8ARRAY(sz, realtype/8)
   CALL POPREAL8ARRAY(sy, realtype/8)
   CALL POPREAL8ARRAY(sx, realtype/8)
   END DO
   ELSE
   !      ==================================================================
   !PRINT *,'limiter',limiter
   !      ==================================================================
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Second order reconstruction of the left and right state.     *
   !        * The three differences used in the, possibly nonlinear,       *
   !        * interpolation are constructed here; the actual left and      *
   !        * right states, or at least the differences from the first     *
   !        * order interpolation, are computed in the subroutine          *
   !        * leftRightState.                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   i = icell - 1
   j = jcell
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO ii=-1,0
   CALL PUSHREAL8ARRAY(du1(irho), realtype/8)
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = wadj(ii, 0, 0, irho, sps) - wadj(ii-1, 0, 0, irho, sps&
   &        )
   CALL PUSHREAL8ARRAY(du2(irho), realtype/8)
   du2(irho) = wadj(ii+1, 0, 0, irho, sps) - wadj(ii, 0, 0, irho, sps&
   &        )
   CALL PUSHREAL8ARRAY(du3(irho), realtype/8)
   du3(irho) = wadj(ii+2, 0, 0, irho, sps) - wadj(ii+1, 0, 0, irho, &
   &        sps)
   CALL PUSHREAL8ARRAY(du1(ivx), realtype/8)
   du1(ivx) = wadj(ii, 0, 0, ivx, sps) - wadj(ii-1, 0, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(du2(ivx), realtype/8)
   du2(ivx) = wadj(ii+1, 0, 0, ivx, sps) - wadj(ii, 0, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(du3(ivx), realtype/8)
   du3(ivx) = wadj(ii+2, 0, 0, ivx, sps) - wadj(ii+1, 0, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(du1(ivy), realtype/8)
   du1(ivy) = wadj(ii, 0, 0, ivy, sps) - wadj(ii-1, 0, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(du2(ivy), realtype/8)
   du2(ivy) = wadj(ii+1, 0, 0, ivy, sps) - wadj(ii, 0, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(du3(ivy), realtype/8)
   du3(ivy) = wadj(ii+2, 0, 0, ivy, sps) - wadj(ii+1, 0, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(du1(ivz), realtype/8)
   du1(ivz) = wadj(ii, 0, 0, ivz, sps) - wadj(ii-1, 0, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(du2(ivz), realtype/8)
   du2(ivz) = wadj(ii+1, 0, 0, ivz, sps) - wadj(ii, 0, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(du3(ivz), realtype/8)
   du3(ivz) = wadj(ii+2, 0, 0, ivz, sps) - wadj(ii+1, 0, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(du1(irhoe), realtype/8)
   du1(irhoe) = padj(ii, 0, 0, sps) - padj(ii-1, 0, 0, sps)
   CALL PUSHREAL8ARRAY(du2(irhoe), realtype/8)
   du2(irhoe) = padj(ii+1, 0, 0, sps) - padj(ii, 0, 0, sps)
   CALL PUSHREAL8ARRAY(du3(irhoe), realtype/8)
   du3(irhoe) = padj(ii+2, 0, 0, sps) - padj(ii+1, 0, 0, sps)
   !!$           print *,'pAdj',p(i,  j,k) - p(i-1,j,k),pAdj(ii,  0,0) - pAdj(ii-1,0,0),p(i,  j,k),p(i-1,j,k),pAdj(ii,  0,0), pAdj(i
   !i-1,0,0),p(i,  j,k) -pAdj(ii,  0,0),p(i,  j,k) - p(i-1,j,k)-(pAdj(ii,  0,0) - pAdj(ii-1,0,0))
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(du1(itu1), realtype/8)
   du1(itu1) = wadj(ii, 0, 0, itu1, sps) - wadj(ii-1, 0, 0, itu1, &
   &          sps)
   CALL PUSHREAL8ARRAY(du2(itu1), realtype/8)
   du2(itu1) = wadj(ii+1, 0, 0, itu1, sps) - wadj(ii, 0, 0, itu1, &
   &          sps)
   CALL PUSHREAL8ARRAY(du3(itu1), realtype/8)
   du3(itu1) = wadj(ii+2, 0, 0, itu1, sps) - wadj(ii+1, 0, 0, itu1&
   &          , sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right, realtype*nw/8)
   CALL PUSHREAL8ARRAY(left, realtype*nw/8)
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATENKPC(du1, du2, du3, left, right, nwint, omk&
   &                           , opk, factminmod, firstorderk)
   !print *,'leftrightadj',left,right,icell,jcell,kcell
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + wadj(ii, 0, 0, irho, sps)
   !print *,'left',left(irho),wAdj(ii,0,0,irho)
   left(ivx) = left(ivx) + wadj(ii, 0, 0, ivx, sps)
   left(ivy) = left(ivy) + wadj(ii, 0, 0, ivy, sps)
   left(ivz) = left(ivz) + wadj(ii, 0, 0, ivz, sps)
   left(irhoe) = left(irhoe) + padj(ii, 0, 0, sps)
   right(irho) = right(irho) + wadj(ii+1, 0, 0, irho, sps)
   right(ivx) = right(ivx) + wadj(ii+1, 0, 0, ivx, sps)
   right(ivy) = right(ivy) + wadj(ii+1, 0, 0, ivy, sps)
   right(ivz) = right(ivz) + wadj(ii+1, 0, 0, ivz, sps)
   right(irhoe) = right(irhoe) + padj(ii+1, 0, 0, sps)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + wadj(ii, 0, 0, itu1, sps)
   right(itu1) = right(itu1) + wadj(ii+1, 0, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(sx, realtype/8)
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = siadj(ii, 0, 0, 1, sps)
   CALL PUSHREAL8ARRAY(sy, realtype/8)
   sy = siadj(ii, 0, 0, 2, sps)
   CALL PUSHREAL8ARRAY(sz, realtype/8)
   sz = siadj(ii, 0, 0, 3, sps)
   CALL PUSHINTEGER4ARRAY(por, portype/4)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8ARRAY(sface, realtype/8)
   sface = sfaceiadj(ii, 0, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   !print *,'gammaface',gammaface,gammaface2
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           print *,'leftrightadj',left,right
   !stop
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   !          print *,'riemanninputI',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
   !         print *,'fluxadjI',flux,icell,jcell,kcell
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = one
   END DO
   ! Fluxes in the j-direction.
   i = icell
   j = jcell - 1
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   CALL PUSHREAL8ARRAY(du1(irho), realtype/8)
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = wadj(0, jj, 0, irho, sps) - wadj(0, jj-1, 0, irho, sps&
   &        )
   CALL PUSHREAL8ARRAY(du2(irho), realtype/8)
   du2(irho) = wadj(0, jj+1, 0, irho, sps) - wadj(0, jj, 0, irho, sps&
   &        )
   CALL PUSHREAL8ARRAY(du3(irho), realtype/8)
   du3(irho) = wadj(0, jj+2, 0, irho, sps) - wadj(0, jj+1, 0, irho, &
   &        sps)
   CALL PUSHREAL8ARRAY(du1(ivx), realtype/8)
   du1(ivx) = wadj(0, jj, 0, ivx, sps) - wadj(0, jj-1, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(du2(ivx), realtype/8)
   du2(ivx) = wadj(0, jj+1, 0, ivx, sps) - wadj(0, jj, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(du3(ivx), realtype/8)
   du3(ivx) = wadj(0, jj+2, 0, ivx, sps) - wadj(0, jj+1, 0, ivx, sps)
   CALL PUSHREAL8ARRAY(du1(ivy), realtype/8)
   du1(ivy) = wadj(0, jj, 0, ivy, sps) - wadj(0, jj-1, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(du2(ivy), realtype/8)
   du2(ivy) = wadj(0, jj+1, 0, ivy, sps) - wadj(0, jj, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(du3(ivy), realtype/8)
   du3(ivy) = wadj(0, jj+2, 0, ivy, sps) - wadj(0, jj+1, 0, ivy, sps)
   CALL PUSHREAL8ARRAY(du1(ivz), realtype/8)
   du1(ivz) = wadj(0, jj, 0, ivz, sps) - wadj(0, jj-1, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(du2(ivz), realtype/8)
   du2(ivz) = wadj(0, jj+1, 0, ivz, sps) - wadj(0, jj, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(du3(ivz), realtype/8)
   du3(ivz) = wadj(0, jj+2, 0, ivz, sps) - wadj(0, jj+1, 0, ivz, sps)
   CALL PUSHREAL8ARRAY(du1(irhoe), realtype/8)
   du1(irhoe) = padj(0, jj, 0, sps) - padj(0, jj-1, 0, sps)
   CALL PUSHREAL8ARRAY(du2(irhoe), realtype/8)
   du2(irhoe) = padj(0, jj+1, 0, sps) - padj(0, jj, 0, sps)
   CALL PUSHREAL8ARRAY(du3(irhoe), realtype/8)
   du3(irhoe) = padj(0, jj+2, 0, sps) - padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(du1(itu1), realtype/8)
   du1(itu1) = wadj(0, jj, 0, itu1, sps) - wadj(0, jj-1, 0, itu1, &
   &          sps)
   CALL PUSHREAL8ARRAY(du2(itu1), realtype/8)
   du2(itu1) = wadj(0, jj+1, 0, itu1, sps) - wadj(0, jj, 0, itu1, &
   &          sps)
   CALL PUSHREAL8ARRAY(du3(itu1), realtype/8)
   du3(itu1) = wadj(0, jj+2, 0, itu1, sps) - wadj(0, jj+1, 0, itu1&
   &          , sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right, realtype*nw/8)
   CALL PUSHREAL8ARRAY(left, realtype*nw/8)
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATENKPC(du1, du2, du3, left, right, nwint, omk&
   &                           , opk, factminmod, firstorderk)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + wadj(0, jj, 0, irho, sps)
   left(ivx) = left(ivx) + wadj(0, jj, 0, ivx, sps)
   left(ivy) = left(ivy) + wadj(0, jj, 0, ivy, sps)
   left(ivz) = left(ivz) + wadj(0, jj, 0, ivz, sps)
   left(irhoe) = left(irhoe) + padj(0, jj, 0, sps)
   right(irho) = right(irho) + wadj(0, jj+1, 0, irho, sps)
   right(ivx) = right(ivx) + wadj(0, jj+1, 0, ivx, sps)
   right(ivy) = right(ivy) + wadj(0, jj+1, 0, ivy, sps)
   right(ivz) = right(ivz) + wadj(0, jj+1, 0, ivz, sps)
   right(irhoe) = right(irhoe) + padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + wadj(0, jj, 0, itu1, sps)
   right(itu1) = right(itu1) + wadj(0, jj+1, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(sx, realtype/8)
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = sjadj(0, jj, 0, 1, sps)
   CALL PUSHREAL8ARRAY(sy, realtype/8)
   sy = sjadj(0, jj, 0, 2, sps)
   CALL PUSHREAL8ARRAY(sz, realtype/8)
   sz = sjadj(0, jj, 0, 3, sps)
   CALL PUSHINTEGER4ARRAY(por, portype/4)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8ARRAY(sface, realtype/8)
   sface = sfacejadj(0, jj, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = one
   END DO
   ! Fluxes in the k-direction.
   i = icell
   j = jcell
   k = kcell - 1
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   CALL PUSHREAL8ARRAY(du1(irho), realtype/8)
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = wadj(0, 0, kk, irho, sps) - wadj(0, 0, kk-1, irho, sps&
   &        )
   CALL PUSHREAL8ARRAY(du2(irho), realtype/8)
   du2(irho) = wadj(0, 0, kk+1, irho, sps) - wadj(0, 0, kk, irho, sps&
   &        )
   CALL PUSHREAL8ARRAY(du3(irho), realtype/8)
   du3(irho) = wadj(0, 0, kk+2, irho, sps) - wadj(0, 0, kk+1, irho, &
   &        sps)
   CALL PUSHREAL8ARRAY(du1(ivx), realtype/8)
   du1(ivx) = wadj(0, 0, kk, ivx, sps) - wadj(0, 0, kk-1, ivx, sps)
   CALL PUSHREAL8ARRAY(du2(ivx), realtype/8)
   du2(ivx) = wadj(0, 0, kk+1, ivx, sps) - wadj(0, 0, kk, ivx, sps)
   CALL PUSHREAL8ARRAY(du3(ivx), realtype/8)
   du3(ivx) = wadj(0, 0, kk+2, ivx, sps) - wadj(0, 0, kk+1, ivx, sps)
   CALL PUSHREAL8ARRAY(du1(ivy), realtype/8)
   du1(ivy) = wadj(0, 0, kk, ivy, sps) - wadj(0, 0, kk-1, ivy, sps)
   CALL PUSHREAL8ARRAY(du2(ivy), realtype/8)
   du2(ivy) = wadj(0, 0, kk+1, ivy, sps) - wadj(0, 0, kk, ivy, sps)
   CALL PUSHREAL8ARRAY(du3(ivy), realtype/8)
   du3(ivy) = wadj(0, 0, kk+2, ivy, sps) - wadj(0, 0, kk+1, ivy, sps)
   CALL PUSHREAL8ARRAY(du1(ivz), realtype/8)
   du1(ivz) = wadj(0, 0, kk, ivz, sps) - wadj(0, 0, kk-1, ivz, sps)
   CALL PUSHREAL8ARRAY(du2(ivz), realtype/8)
   du2(ivz) = wadj(0, 0, kk+1, ivz, sps) - wadj(0, 0, kk, ivz, sps)
   CALL PUSHREAL8ARRAY(du3(ivz), realtype/8)
   du3(ivz) = wadj(0, 0, kk+2, ivz, sps) - wadj(0, 0, kk+1, ivz, sps)
   CALL PUSHREAL8ARRAY(du1(irhoe), realtype/8)
   du1(irhoe) = padj(0, 0, kk, sps) - padj(0, 0, kk-1, sps)
   CALL PUSHREAL8ARRAY(du2(irhoe), realtype/8)
   du2(irhoe) = padj(0, 0, kk+1, sps) - padj(0, 0, kk, sps)
   CALL PUSHREAL8ARRAY(du3(irhoe), realtype/8)
   du3(irhoe) = padj(0, 0, kk+2, sps) - padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8ARRAY(du1(itu1), realtype/8)
   du1(itu1) = wadj(0, 0, kk, itu1, sps) - wadj(0, 0, kk-1, itu1, &
   &          sps)
   CALL PUSHREAL8ARRAY(du2(itu1), realtype/8)
   du2(itu1) = wadj(0, 0, kk+1, itu1, sps) - wadj(0, 0, kk, itu1, &
   &          sps)
   CALL PUSHREAL8ARRAY(du3(itu1), realtype/8)
   du3(itu1) = wadj(0, 0, kk+2, itu1, sps) - wadj(0, 0, kk+1, itu1&
   &          , sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right, realtype*nw/8)
   CALL PUSHREAL8ARRAY(left, realtype*nw/8)
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATENKPC(du1, du2, du3, left, right, nwint, omk&
   &                           , opk, factminmod, firstorderk)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + wadj(0, 0, kk, irho, sps)
   left(ivx) = left(ivx) + wadj(0, 0, kk, ivx, sps)
   left(ivy) = left(ivy) + wadj(0, 0, kk, ivy, sps)
   left(ivz) = left(ivz) + wadj(0, 0, kk, ivz, sps)
   left(irhoe) = left(irhoe) + padj(0, 0, kk, sps)
   right(irho) = right(irho) + wadj(0, 0, kk+1, irho, sps)
   right(ivx) = right(ivx) + wadj(0, 0, kk+1, ivx, sps)
   right(ivy) = right(ivy) + wadj(0, 0, kk+1, ivy, sps)
   right(ivz) = right(ivz) + wadj(0, 0, kk+1, ivz, sps)
   right(irhoe) = right(irhoe) + padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + wadj(0, 0, kk, itu1, sps)
   right(itu1) = right(itu1) + wadj(0, 0, kk+1, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(sx, realtype/8)
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = skadj(0, 0, kk, 1, sps)
   CALL PUSHREAL8ARRAY(sy, realtype/8)
   sy = skadj(0, 0, kk, 2, sps)
   CALL PUSHREAL8ARRAY(sz, realtype/8)
   sz = skadj(0, 0, kk, 3, sps)
   CALL PUSHINTEGER4ARRAY(por, portype/4)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8ARRAY(sface, realtype/8)
   sface = sfacekadj(0, 0, kk, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   !           print *,'riemanninputk',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
   !print *,'dwupwind',dwadj,'fact',fact,'flux',flux
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = one
   END DO
   padjb = 0.0
   wadjb = 0.0
   fluxb = 0.0
   leftb = 0.0
   rightb = 0.0
   du1b = 0.0
   du2b = 0.0
   du3b = 0.0
   DO kk=0,-1,-1
   CALL POPREAL8ARRAY(fact, realtype/8)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   gammaface = gammaconstant
   CALL RIEMANNFLUXNKPC_B(left, leftb, right, rightb, flux, fluxb, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPREAL8ARRAY(sface, realtype/8)
   CALL POPINTEGER4ARRAY(por, portype/4)
   CALL POPREAL8ARRAY(sz, realtype/8)
   CALL POPREAL8ARRAY(sy, realtype/8)
   CALL POPREAL8ARRAY(sx, realtype/8)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
   &          rightb(itu1)
   wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + leftb(&
   &          itu1)
   END IF
   padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + rightb(irhoe)
   wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + rightb&
   &        (ivz)
   wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + rightb&
   &        (ivy)
   wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + rightb&
   &        (ivx)
   wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + &
   &        rightb(irho)
   padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + leftb(irhoe)
   wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + leftb(ivz)
   wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + leftb(ivy)
   wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + leftb(ivx)
   wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + leftb(&
   &        irho)
   CALL POPREAL8ARRAY(left, realtype*nw/8)
   CALL POPREAL8ARRAY(right, realtype*nw/8)
   CALL LEFTRIGHTSTATENKPC_B(du1, du1b, du2, du2b, du3, du3b, left, &
   &                          leftb, right, rightb, nwint, omk, opk, &
   &                          factminmod, firstorderk)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(du3(itu1), realtype/8)
   wadjb(0, 0, kk+2, itu1, sps) = wadjb(0, 0, kk+2, itu1, sps) + &
   &          du3b(itu1)
   wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
   &          du2b(itu1) - du3b(itu1)
   du3b(itu1) = 0.0
   CALL POPREAL8ARRAY(du2(itu1), realtype/8)
   wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + du1b(&
   &          itu1) - du2b(itu1)
   du2b(itu1) = 0.0
   CALL POPREAL8ARRAY(du1(itu1), realtype/8)
   wadjb(0, 0, kk-1, itu1, sps) = wadjb(0, 0, kk-1, itu1, sps) - &
   &          du1b(itu1)
   du1b(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(du3(irhoe), realtype/8)
   padjb(0, 0, kk+2, sps) = padjb(0, 0, kk+2, sps) + du3b(irhoe)
   padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + du2b(irhoe) - &
   &        du3b(irhoe)
   du3b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du2(irhoe), realtype/8)
   padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + du1b(irhoe) - du2b(&
   &        irhoe)
   du2b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du1(irhoe), realtype/8)
   padjb(0, 0, kk-1, sps) = padjb(0, 0, kk-1, sps) - du1b(irhoe)
   du1b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du3(ivz), realtype/8)
   wadjb(0, 0, kk+2, ivz, sps) = wadjb(0, 0, kk+2, ivz, sps) + du3b(&
   &        ivz)
   wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + du2b(&
   &        ivz) - du3b(ivz)
   du3b(ivz) = 0.0
   CALL POPREAL8ARRAY(du2(ivz), realtype/8)
   wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + du1b(ivz) &
   &        - du2b(ivz)
   du2b(ivz) = 0.0
   CALL POPREAL8ARRAY(du1(ivz), realtype/8)
   wadjb(0, 0, kk-1, ivz, sps) = wadjb(0, 0, kk-1, ivz, sps) - du1b(&
   &        ivz)
   du1b(ivz) = 0.0
   CALL POPREAL8ARRAY(du3(ivy), realtype/8)
   wadjb(0, 0, kk+2, ivy, sps) = wadjb(0, 0, kk+2, ivy, sps) + du3b(&
   &        ivy)
   wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + du2b(&
   &        ivy) - du3b(ivy)
   du3b(ivy) = 0.0
   CALL POPREAL8ARRAY(du2(ivy), realtype/8)
   wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + du1b(ivy) &
   &        - du2b(ivy)
   du2b(ivy) = 0.0
   CALL POPREAL8ARRAY(du1(ivy), realtype/8)
   wadjb(0, 0, kk-1, ivy, sps) = wadjb(0, 0, kk-1, ivy, sps) - du1b(&
   &        ivy)
   du1b(ivy) = 0.0
   CALL POPREAL8ARRAY(du3(ivx), realtype/8)
   wadjb(0, 0, kk+2, ivx, sps) = wadjb(0, 0, kk+2, ivx, sps) + du3b(&
   &        ivx)
   wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + du2b(&
   &        ivx) - du3b(ivx)
   du3b(ivx) = 0.0
   CALL POPREAL8ARRAY(du2(ivx), realtype/8)
   wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + du1b(ivx) &
   &        - du2b(ivx)
   du2b(ivx) = 0.0
   CALL POPREAL8ARRAY(du1(ivx), realtype/8)
   wadjb(0, 0, kk-1, ivx, sps) = wadjb(0, 0, kk-1, ivx, sps) - du1b(&
   &        ivx)
   du1b(ivx) = 0.0
   CALL POPREAL8ARRAY(du3(irho), realtype/8)
   wadjb(0, 0, kk+2, irho, sps) = wadjb(0, 0, kk+2, irho, sps) + du3b&
   &        (irho)
   wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + du2b&
   &        (irho) - du3b(irho)
   du3b(irho) = 0.0
   CALL POPREAL8ARRAY(du2(irho), realtype/8)
   wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + du1b(&
   &        irho) - du2b(irho)
   du2b(irho) = 0.0
   CALL POPREAL8ARRAY(du1(irho), realtype/8)
   wadjb(0, 0, kk-1, irho, sps) = wadjb(0, 0, kk-1, irho, sps) - du1b&
   &        (irho)
   du1b(irho) = 0.0
   END DO
   i = icell
   k = kcell
   DO jj=0,-1,-1
   CALL POPREAL8ARRAY(fact, realtype/8)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   gammaface = gammaconstant
   CALL RIEMANNFLUXNKPC_B(left, leftb, right, rightb, flux, fluxb, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPREAL8ARRAY(sface, realtype/8)
   CALL POPINTEGER4ARRAY(por, portype/4)
   CALL POPREAL8ARRAY(sz, realtype/8)
   CALL POPREAL8ARRAY(sy, realtype/8)
   CALL POPREAL8ARRAY(sx, realtype/8)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
   &          rightb(itu1)
   wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + leftb(&
   &          itu1)
   END IF
   padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + rightb(irhoe)
   wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + rightb&
   &        (ivz)
   wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + rightb&
   &        (ivy)
   wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + rightb&
   &        (ivx)
   wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + &
   &        rightb(irho)
   padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + leftb(irhoe)
   wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + leftb(ivz)
   wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + leftb(ivy)
   wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + leftb(ivx)
   wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + leftb(&
   &        irho)
   CALL POPREAL8ARRAY(left, realtype*nw/8)
   CALL POPREAL8ARRAY(right, realtype*nw/8)
   CALL LEFTRIGHTSTATENKPC_B(du1, du1b, du2, du2b, du3, du3b, left, &
   &                          leftb, right, rightb, nwint, omk, opk, &
   &                          factminmod, firstorderk)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(du3(itu1), realtype/8)
   wadjb(0, jj+2, 0, itu1, sps) = wadjb(0, jj+2, 0, itu1, sps) + &
   &          du3b(itu1)
   wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
   &          du2b(itu1) - du3b(itu1)
   du3b(itu1) = 0.0
   CALL POPREAL8ARRAY(du2(itu1), realtype/8)
   wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + du1b(&
   &          itu1) - du2b(itu1)
   du2b(itu1) = 0.0
   CALL POPREAL8ARRAY(du1(itu1), realtype/8)
   wadjb(0, jj-1, 0, itu1, sps) = wadjb(0, jj-1, 0, itu1, sps) - &
   &          du1b(itu1)
   du1b(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(du3(irhoe), realtype/8)
   padjb(0, jj+2, 0, sps) = padjb(0, jj+2, 0, sps) + du3b(irhoe)
   padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + du2b(irhoe) - &
   &        du3b(irhoe)
   du3b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du2(irhoe), realtype/8)
   padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + du1b(irhoe) - du2b(&
   &        irhoe)
   du2b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du1(irhoe), realtype/8)
   padjb(0, jj-1, 0, sps) = padjb(0, jj-1, 0, sps) - du1b(irhoe)
   du1b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du3(ivz), realtype/8)
   wadjb(0, jj+2, 0, ivz, sps) = wadjb(0, jj+2, 0, ivz, sps) + du3b(&
   &        ivz)
   wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + du2b(&
   &        ivz) - du3b(ivz)
   du3b(ivz) = 0.0
   CALL POPREAL8ARRAY(du2(ivz), realtype/8)
   wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + du1b(ivz) &
   &        - du2b(ivz)
   du2b(ivz) = 0.0
   CALL POPREAL8ARRAY(du1(ivz), realtype/8)
   wadjb(0, jj-1, 0, ivz, sps) = wadjb(0, jj-1, 0, ivz, sps) - du1b(&
   &        ivz)
   du1b(ivz) = 0.0
   CALL POPREAL8ARRAY(du3(ivy), realtype/8)
   wadjb(0, jj+2, 0, ivy, sps) = wadjb(0, jj+2, 0, ivy, sps) + du3b(&
   &        ivy)
   wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + du2b(&
   &        ivy) - du3b(ivy)
   du3b(ivy) = 0.0
   CALL POPREAL8ARRAY(du2(ivy), realtype/8)
   wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + du1b(ivy) &
   &        - du2b(ivy)
   du2b(ivy) = 0.0
   CALL POPREAL8ARRAY(du1(ivy), realtype/8)
   wadjb(0, jj-1, 0, ivy, sps) = wadjb(0, jj-1, 0, ivy, sps) - du1b(&
   &        ivy)
   du1b(ivy) = 0.0
   CALL POPREAL8ARRAY(du3(ivx), realtype/8)
   wadjb(0, jj+2, 0, ivx, sps) = wadjb(0, jj+2, 0, ivx, sps) + du3b(&
   &        ivx)
   wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + du2b(&
   &        ivx) - du3b(ivx)
   du3b(ivx) = 0.0
   CALL POPREAL8ARRAY(du2(ivx), realtype/8)
   wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + du1b(ivx) &
   &        - du2b(ivx)
   du2b(ivx) = 0.0
   CALL POPREAL8ARRAY(du1(ivx), realtype/8)
   wadjb(0, jj-1, 0, ivx, sps) = wadjb(0, jj-1, 0, ivx, sps) - du1b(&
   &        ivx)
   du1b(ivx) = 0.0
   CALL POPREAL8ARRAY(du3(irho), realtype/8)
   wadjb(0, jj+2, 0, irho, sps) = wadjb(0, jj+2, 0, irho, sps) + du3b&
   &        (irho)
   wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + du2b&
   &        (irho) - du3b(irho)
   du3b(irho) = 0.0
   CALL POPREAL8ARRAY(du2(irho), realtype/8)
   wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + du1b(&
   &        irho) - du2b(irho)
   du2b(irho) = 0.0
   CALL POPREAL8ARRAY(du1(irho), realtype/8)
   wadjb(0, jj-1, 0, irho, sps) = wadjb(0, jj-1, 0, irho, sps) - du1b&
   &        (irho)
   du1b(irho) = 0.0
   END DO
   j = jcell
   k = kcell
   DO ii=0,-1,-1
   CALL POPREAL8ARRAY(fact, realtype/8)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   gammaface = gammaconstant
   CALL RIEMANNFLUXNKPC_B(left, leftb, right, rightb, flux, fluxb, &
   &                       por, gammaface, correctfork, sx, sy, sz, sface, &
   &                       finegrid)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPREAL8ARRAY(sface, realtype/8)
   CALL POPINTEGER4ARRAY(por, portype/4)
   CALL POPREAL8ARRAY(sz, realtype/8)
   CALL POPREAL8ARRAY(sy, realtype/8)
   CALL POPREAL8ARRAY(sx, realtype/8)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
   &          rightb(itu1)
   wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + leftb(&
   &          itu1)
   END IF
   padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + rightb(irhoe)
   wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + rightb&
   &        (ivz)
   wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + rightb&
   &        (ivy)
   wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + rightb&
   &        (ivx)
   wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + &
   &        rightb(irho)
   padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + leftb(irhoe)
   wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + leftb(ivz)
   wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + leftb(ivy)
   wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + leftb(ivx)
   wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + leftb(&
   &        irho)
   CALL POPREAL8ARRAY(left, realtype*nw/8)
   CALL POPREAL8ARRAY(right, realtype*nw/8)
   CALL LEFTRIGHTSTATENKPC_B(du1, du1b, du2, du2b, du3, du3b, left, &
   &                          leftb, right, rightb, nwint, omk, opk, &
   &                          factminmod, firstorderk)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(du3(itu1), realtype/8)
   wadjb(ii+2, 0, 0, itu1, sps) = wadjb(ii+2, 0, 0, itu1, sps) + &
   &          du3b(itu1)
   wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
   &          du2b(itu1) - du3b(itu1)
   du3b(itu1) = 0.0
   CALL POPREAL8ARRAY(du2(itu1), realtype/8)
   wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + du1b(&
   &          itu1) - du2b(itu1)
   du2b(itu1) = 0.0
   CALL POPREAL8ARRAY(du1(itu1), realtype/8)
   wadjb(ii-1, 0, 0, itu1, sps) = wadjb(ii-1, 0, 0, itu1, sps) - &
   &          du1b(itu1)
   du1b(itu1) = 0.0
   END IF
   CALL POPREAL8ARRAY(du3(irhoe), realtype/8)
   padjb(ii+2, 0, 0, sps) = padjb(ii+2, 0, 0, sps) + du3b(irhoe)
   padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + du2b(irhoe) - &
   &        du3b(irhoe)
   du3b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du2(irhoe), realtype/8)
   padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + du1b(irhoe) - du2b(&
   &        irhoe)
   du2b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du1(irhoe), realtype/8)
   padjb(ii-1, 0, 0, sps) = padjb(ii-1, 0, 0, sps) - du1b(irhoe)
   du1b(irhoe) = 0.0
   CALL POPREAL8ARRAY(du3(ivz), realtype/8)
   wadjb(ii+2, 0, 0, ivz, sps) = wadjb(ii+2, 0, 0, ivz, sps) + du3b(&
   &        ivz)
   wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + du2b(&
   &        ivz) - du3b(ivz)
   du3b(ivz) = 0.0
   CALL POPREAL8ARRAY(du2(ivz), realtype/8)
   wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + du1b(ivz) &
   &        - du2b(ivz)
   du2b(ivz) = 0.0
   CALL POPREAL8ARRAY(du1(ivz), realtype/8)
   wadjb(ii-1, 0, 0, ivz, sps) = wadjb(ii-1, 0, 0, ivz, sps) - du1b(&
   &        ivz)
   du1b(ivz) = 0.0
   CALL POPREAL8ARRAY(du3(ivy), realtype/8)
   wadjb(ii+2, 0, 0, ivy, sps) = wadjb(ii+2, 0, 0, ivy, sps) + du3b(&
   &        ivy)
   wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + du2b(&
   &        ivy) - du3b(ivy)
   du3b(ivy) = 0.0
   CALL POPREAL8ARRAY(du2(ivy), realtype/8)
   wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + du1b(ivy) &
   &        - du2b(ivy)
   du2b(ivy) = 0.0
   CALL POPREAL8ARRAY(du1(ivy), realtype/8)
   wadjb(ii-1, 0, 0, ivy, sps) = wadjb(ii-1, 0, 0, ivy, sps) - du1b(&
   &        ivy)
   du1b(ivy) = 0.0
   CALL POPREAL8ARRAY(du3(ivx), realtype/8)
   wadjb(ii+2, 0, 0, ivx, sps) = wadjb(ii+2, 0, 0, ivx, sps) + du3b(&
   &        ivx)
   wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + du2b(&
   &        ivx) - du3b(ivx)
   du3b(ivx) = 0.0
   CALL POPREAL8ARRAY(du2(ivx), realtype/8)
   wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + du1b(ivx) &
   &        - du2b(ivx)
   du2b(ivx) = 0.0
   CALL POPREAL8ARRAY(du1(ivx), realtype/8)
   wadjb(ii-1, 0, 0, ivx, sps) = wadjb(ii-1, 0, 0, ivx, sps) - du1b(&
   &        ivx)
   du1b(ivx) = 0.0
   CALL POPREAL8ARRAY(du3(irho), realtype/8)
   wadjb(ii+2, 0, 0, irho, sps) = wadjb(ii+2, 0, 0, irho, sps) + du3b&
   &        (irho)
   wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + du2b&
   &        (irho) - du3b(irho)
   du3b(irho) = 0.0
   CALL POPREAL8ARRAY(du2(irho), realtype/8)
   wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + du1b(&
   &        irho) - du2b(irho)
   du2b(irho) = 0.0
   CALL POPREAL8ARRAY(du1(irho), realtype/8)
   wadjb(ii-1, 0, 0, irho, sps) = wadjb(ii-1, 0, 0, irho, sps) - du1b&
   &        (irho)
   du1b(irho) = 0.0
   END DO
   END IF

   END SUBROUTINE INVISCIDUPWINDFLUXNKPC_B

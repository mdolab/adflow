   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of residualnkpc in forward (tangent) mode:
   !   variations   of useful results: dwadj wadj
   !   with respect to varying inputs: *cdisrk vis4 kappacoef vis2
   !                padj radkadj radjadj dwadj wadj radiadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          residual.f90                                    *
   !      * Author:        C.A.(Sandy) Mader                               *
   !      * Starting date: 04-21-2008                                      *
   !      * Last modified: 04-28-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE RESIDUALNKPC_D(wadj, wadjd, padj, padjd, siadj, sjadj, skadj&
   &  , voladj, normadj, sfaceiadj, sfacejadj, sfacekadj, radiadj, radiadjd&
   &  , radjadj, radjadjd, radkadj, radkadjd, dwadj, dwadjd, icell, jcell, &
   &  kcell, rotrateadj, correctfork, nn, level, sps)
   USE FLOWVARREFSTATE
   USE INPUTITERATION
   USE CGNSGRID
   USE BLOCKPOINTERS
   USE INPUTTIMESPECTRAL
   USE INPUTDISCRETIZATION
   USE ITERATION
   IMPLICIT NONE
   !
   !          if( viscous ) call viscousFlux
   ! Add the dissipative and possibly viscous fluxes to the
   ! Euler fluxes. Loop over the owned cells and add fw to dw.
   ! Also multiply by iblank so that no updates occur in holes
   ! or on the overset boundary.
   ! ADD VISCOUS FLUXES HERE
   !            do l=1,nwf
   !               dwAdj(l,sps) =dwAdj(l,sps) + 
   !            enddo
   !
   !      ******************************************************************
   !      *                                                                *
   !      * residual computes the residual of the mean flow equations on   *
   !      * the current MG level.                                          *
   !      *                                                                *
   !      ******************************************************************
   !
   !       Subroutine Variables
   INTEGER(kind=inttype) :: icell, jcell, kcell, nn, level, sps
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(INOUT) :: siadj, sjadj, skadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj, sfacejadj, sfacekadj
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: rotrateadj
   REAL(kind=realtype), DIMENSION(0:0, 0:0, 0:0, ntimeintervalsspectral),&
   &  INTENT(INOUT) :: voladj
   REAL(kind=realtype), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(INOUT) :: normadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(INOUT) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(INOUT) :: wadjd
   REAL(kind=realtype), DIMENSION(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral) :: radiadj, radjadj, radkadj
   REAL(kind=realtype), DIMENSION(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral) :: radiadjd, radjadjd, radkadjd
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadj
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadjd
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral) :: dwadj2
   !integer(kind=intType), intent(in) :: discr
   LOGICAL, INTENT(IN) :: correctfork
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padjd
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral) :: fwadj
   !
   !      Local variables.
   !
   !sps, nn, discr
   INTEGER(kind=inttype) :: discr
   INTEGER(kind=inttype) :: i, j, k, l
   LOGICAL :: finegrid
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   !   Come back to this later....
   !!$       ! Add the source terms from the level 0 cooling model.
   !!$
   !!$       call level0CoolingModel
   ! Set the value of rFil, which controls the fraction of the old
   ! dissipation residual to be used. This is only for the runge-kutta
   ! schemes; for other smoothers rFil is simply set to 1.0.
   ! Note the index rkStage+1 for cdisRK. The reason is that the
   ! residual computation is performed before rkStage is incremented.
   IF (smoother .EQ. rungekutta) THEN
   rfil = cdisrk(rkstage+1)
   ELSE
   rfil = one
   END IF
   ! Initialize the local arrays to monitor the massflows to zero.
   !!massFlowFamilyInv  = zero
   !!massFlowFamilyDiss = zero
   ! Set the value of the discretization, depending on the grid level,
   ! and the logical fineGrid, which indicates whether or not this
   ! is the finest grid level of the current mg cycle.
   discr = spacediscrcoarse
   IF (currentlevel .EQ. 1) discr = spacediscr
   finegrid = .false.
   IF (currentlevel .EQ. groundlevel) finegrid = .true.
   CALL INVISCIDCENTRALFLUXNKPC_D(wadj, wadjd, padj, padjd, dwadj, dwadjd&
   &                           , siadj, sjadj, skadj, voladj, sfaceiadj, &
   &                           sfacejadj, sfacekadj, rotrateadj, icell, &
   &                           jcell, kcell, nn, level, sps)
   ! Compute the artificial dissipation fluxes.
   ! This depends on the parameter discr.
   SELECT CASE  (discr) 
   CASE (dissscalar) 
   ! Standard scalar dissipation scheme.
   IF (finegrid) THEN
   CALL INVISCIDDISSFLUXSCALARNKPC_D(wadj, wadjd, padj, padjd, dwadj&
   &                                  , dwadjd, radiadj, radiadjd, radjadj, &
   &                                  radjadjd, radkadj, radkadjd, icell, &
   &                                  jcell, kcell, nn, level, sps)
   ELSE
   CALL TERMINATE('residualAdj', &
   &                  'ADjoint does not function on coarse grid level')
   !call inviscidDissFluxScalarCoarse
   END IF
   CASE (upwind) 
   !===========================================================
   !!$!             case (dissMatrix) ! Matrix dissipation scheme.
   !!$!
   !!$!               if( fineGrid ) then
   !!$!                 call inviscidDissFluxMatrixAdj()
   !!$!               else
   !!$!                 call terminate("residualAdj", &
   !!$!                        "ADjoint does not function on coarse grid level")
   !!$!                 !call inviscidDissFluxMatrixCoarse
   !!$!               endif
   !===========================================================
   !!$ !            case (dissCusp) ! Cusp dissipation scheme.
   !!$!
   !!$!               if( fineGrid ) then
   !!$!                 call inviscidDissFluxCuspAdj()
   !!$!               else
   !!$!                 call terminate("residualAdj", &
   !!$!                        "ADjoint does not function on coarse grid level")
   !!$!                 !call inviscidDissFluxCuspCoarse
   !!$!               endif
   !===========================================================
   ! Dissipation via an upwind scheme.
   CALL INVISCIDUPWINDFLUXNKPC_D(wadj, wadjd, padj, padjd, dwadj, &
   &                            dwadjd, siadj, sjadj, skadj, sfaceiadj, &
   &                            sfacejadj, sfacekadj, icell, jcell, kcell, &
   &                            finegrid, nn, level, sps)
   END SELECT
   END SUBROUTINE RESIDUALNKPC_D

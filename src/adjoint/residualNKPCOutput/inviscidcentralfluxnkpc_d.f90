   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of inviscidcentralfluxnkpc in forward (tangent) mode:
   !   variations   of useful results: dwadj
   !   with respect to varying inputs: padj dwadj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidCentralFluxAdj.f90                      *
   !      * Author:        Edwin van der Weide, C.A.(Sandy) Mader          *
   !      *                Seongim Choi                                    *
   !      * Starting date: 11-21-2007                                      *
   !      * Last modified: 10-22-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDCENTRALFLUXNKPC_D(wadj, wadjd, padj, padjd, dwadj, &
   &  dwadjd, siadj, sjadj, skadj, voladj, sfaceiadj, sfacejadj, sfacekadj, &
   &  rotrateadj, icell, jcell, kcell, nn, level, sps)
   USE FLOWVARREFSTATE
   USE CGNSGRID
   USE BLOCKPOINTERS
   USE INPUTTIMESPECTRAL
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidCentralFluxAdj computes the Euler fluxes using a       *
   !      * central discretization for the cell iCell, jCell, kCell of the *
   !      * block to which the variables in blockPointers currently point  *
   !      * to.                                                            *
   !      *                                                                *
   !      ******************************************************************
   !
   ! sFaceI,sFaceJ,sFaceK,sI,sJ,sK,blockismoving,addgridvelocities
   ! vol, nbkGlobal
   ! constants (irho, ivx, ivy, imx,..), timeRef
   ! equationMode, steady
   !
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments
   !
   INTEGER(kind=inttype) :: icell, jcell, kcell, nn, level, sps
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadjd
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padjd
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadj
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadjd
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj, sjadj, skadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj, sfacejadj, sfacekadj
   REAL(kind=realtype), DIMENSION(0:0, 0:0, 0:0, ntimeintervalsspectral),&
   &  INTENT(IN) :: voladj
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: rotrateadj
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ii, jj, kk
   REAL(kind=realtype) :: qsp, qsm, rqsp, rqsm, porvel, porflux
   REAL(kind=realtype) :: qspd, qsmd, rqspd, rqsmd
   REAL(kind=realtype) :: pa, fs, sface, vnp, vnm, fact
   REAL(kind=realtype) :: pad, fsd, vnpd, vnmd
   REAL(kind=realtype) :: wx, wy, wz, rvol
   REAL(kind=realtype) :: rvold
   !     testing vars
   REAL(kind=realtype) :: wx2, wy2, wz2, rvol2
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = 0.0
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Advective fluxes in the i-direction.                           *
   !      *                                                                *
   !      ******************************************************************
   !
   i = icell - 1
   j = jcell
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO ii=-1,0
   ! Set the dot product of the grid velocity and the
   ! normal in i-direction for a moving face.
   IF (addgridvelocities) sface = sfaceiadj(ii, 0, 0, sps)
   ! Compute the normal velocities of the left and right state.
   vnpd = siadj(ii, 0, 0, 1, sps)*wadjd(ii+1, 0, 0, ivx, sps) + siadj(&
   &      ii, 0, 0, 2, sps)*wadjd(ii+1, 0, 0, ivy, sps) + siadj(ii, 0, 0, 3&
   &      , sps)*wadjd(ii+1, 0, 0, ivz, sps)
   vnp = wadj(ii+1, 0, 0, ivx, sps)*siadj(ii, 0, 0, 1, sps) + wadj(ii+1&
   &      , 0, 0, ivy, sps)*siadj(ii, 0, 0, 2, sps) + wadj(ii+1, 0, 0, ivz, &
   &      sps)*siadj(ii, 0, 0, 3, sps)
   vnmd = siadj(ii, 0, 0, 1, sps)*wadjd(ii, 0, 0, ivx, sps) + siadj(ii&
   &      , 0, 0, 2, sps)*wadjd(ii, 0, 0, ivy, sps) + siadj(ii, 0, 0, 3, sps&
   &      )*wadjd(ii, 0, 0, ivz, sps)
   vnm = wadj(ii, 0, 0, ivx, sps)*siadj(ii, 0, 0, 1, sps) + wadj(ii, 0&
   &      , 0, ivy, sps)*siadj(ii, 0, 0, 2, sps) + wadj(ii, 0, 0, ivz, sps)*&
   &      siadj(ii, 0, 0, 3, sps)
   !print *,'vnp',wAdj(ii+1,0,0,ivx,sps),sIAdj(ii,0,0,1,sps),sps
   ! Set the values of the porosities for this face.
   ! porVel defines the porosity w.r.t. velocity;
   ! porFlux defines the porosity w.r.t. the entire flux.
   ! The latter is only zero for a discontinuous block
   ! boundary that must be treated conservatively.
   ! The default value of porFlux is 0.5, such that the
   ! correct central flux is scattered to both cells.
   ! In case of a boundFlux the normal velocity is set
   ! to sFace.
   porvel = one
   porflux = half
   IF (pori(i, j, k) .EQ. noflux) porflux = 0.0
   IF (pori(i, j, k) .EQ. boundflux) THEN
   porvel = 0.0
   vnp = sface
   vnm = sface
   vnmd = 0.0
   vnpd = 0.0
   END IF
   ! Incorporate porFlux in porVel.
   porvel = porvel*porflux
   ! Compute the normal velocities relative to the grid for
   ! the face as well as the mass fluxes.
   qspd = porvel*vnpd
   qsp = (vnp-sface)*porvel
   qsmd = porvel*vnmd
   qsm = (vnm-sface)*porvel
   rqspd = qspd*wadj(ii+1, 0, 0, irho, sps) + qsp*wadjd(ii+1, 0, 0, &
   &      irho, sps)
   rqsp = qsp*wadj(ii+1, 0, 0, irho, sps)
   rqsmd = qsmd*wadj(ii, 0, 0, irho, sps) + qsm*wadjd(ii, 0, 0, irho, &
   &      sps)
   rqsm = qsm*wadj(ii, 0, 0, irho, sps)
   ! Compute the sum of the pressure multiplied by porFlux.
   ! For the default value of porFlux, 0.5, this leads to
   ! the average pressure.
   pad = porflux*(padjd(ii+1, 0, 0, sps)+padjd(ii, 0, 0, sps))
   pa = porflux*(padj(ii+1, 0, 0, sps)+padj(ii, 0, 0, sps))
   ! Compute the fluxes through this face.
   fsd = rqspd + rqsmd
   fs = rqsp + rqsm
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fsd
   dwadj(irho, sps) = dwadj(irho, sps) + fact*fs
   fsd = rqspd*wadj(ii+1, 0, 0, ivx, sps) + rqsp*wadjd(ii+1, 0, 0, ivx&
   &      , sps) + rqsmd*wadj(ii, 0, 0, ivx, sps) + rqsm*wadjd(ii, 0, 0, ivx&
   &      , sps) + siadj(ii, 0, 0, 1, sps)*pad
   fs = rqsp*wadj(ii+1, 0, 0, ivx, sps) + rqsm*wadj(ii, 0, 0, ivx, sps)&
   &      + pa*siadj(ii, 0, 0, 1, sps)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fsd
   dwadj(imx, sps) = dwadj(imx, sps) + fact*fs
   fsd = rqspd*wadj(ii+1, 0, 0, ivy, sps) + rqsp*wadjd(ii+1, 0, 0, ivy&
   &      , sps) + rqsmd*wadj(ii, 0, 0, ivy, sps) + rqsm*wadjd(ii, 0, 0, ivy&
   &      , sps) + siadj(ii, 0, 0, 2, sps)*pad
   fs = rqsp*wadj(ii+1, 0, 0, ivy, sps) + rqsm*wadj(ii, 0, 0, ivy, sps)&
   &      + pa*siadj(ii, 0, 0, 2, sps)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fsd
   dwadj(imy, sps) = dwadj(imy, sps) + fact*fs
   fsd = rqspd*wadj(ii+1, 0, 0, ivz, sps) + rqsp*wadjd(ii+1, 0, 0, ivz&
   &      , sps) + rqsmd*wadj(ii, 0, 0, ivz, sps) + rqsm*wadjd(ii, 0, 0, ivz&
   &      , sps) + siadj(ii, 0, 0, 3, sps)*pad
   fs = rqsp*wadj(ii+1, 0, 0, ivz, sps) + rqsm*wadj(ii, 0, 0, ivz, sps)&
   &      + pa*siadj(ii, 0, 0, 3, sps)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fsd
   dwadj(imz, sps) = dwadj(imz, sps) + fact*fs
   fsd = qspd*wadj(ii+1, 0, 0, irhoe, sps) + qsp*wadjd(ii+1, 0, 0, &
   &      irhoe, sps) + qsmd*wadj(ii, 0, 0, irhoe, sps) + qsm*wadjd(ii, 0, 0&
   &      , irhoe, sps) + porflux*(vnpd*padj(ii+1, 0, 0, sps)+vnp*padjd(ii+1&
   &      , 0, 0, sps)+vnmd*padj(ii, 0, 0, sps)+vnm*padjd(ii, 0, 0, sps))
   fs = qsp*wadj(ii+1, 0, 0, irhoe, sps) + qsm*wadj(ii, 0, 0, irhoe, &
   &      sps) + porflux*(vnp*padj(ii+1, 0, 0, sps)+vnm*padj(ii, 0, 0, sps))
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fsd
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*fs
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   fact = one
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Advective fluxes in the j-direction.                           *
   !      *                                                                *
   !      ******************************************************************
   !
   i = icell
   j = jcell - 1
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   ! Set the dot product of the grid velocity and the
   ! normal in j-direction for a moving face.
   IF (addgridvelocities) sface = sfacejadj(0, jj, 0, sps)
   ! Compute the normal velocities of the left and right state.
   vnpd = sjadj(0, jj, 0, 1, sps)*wadjd(0, jj+1, 0, ivx, sps) + sjadj(0&
   &      , jj, 0, 2, sps)*wadjd(0, jj+1, 0, ivy, sps) + sjadj(0, jj, 0, 3, &
   &      sps)*wadjd(0, jj+1, 0, ivz, sps)
   vnp = wadj(0, jj+1, 0, ivx, sps)*sjadj(0, jj, 0, 1, sps) + wadj(0, &
   &      jj+1, 0, ivy, sps)*sjadj(0, jj, 0, 2, sps) + wadj(0, jj+1, 0, ivz&
   &      , sps)*sjadj(0, jj, 0, 3, sps)
   vnmd = sjadj(0, jj, 0, 1, sps)*wadjd(0, jj, 0, ivx, sps) + sjadj(0, &
   &      jj, 0, 2, sps)*wadjd(0, jj, 0, ivy, sps) + sjadj(0, jj, 0, 3, sps)&
   &      *wadjd(0, jj, 0, ivz, sps)
   vnm = wadj(0, jj, 0, ivx, sps)*sjadj(0, jj, 0, 1, sps) + wadj(0, jj&
   &      , 0, ivy, sps)*sjadj(0, jj, 0, 2, sps) + wadj(0, jj, 0, ivz, sps)*&
   &      sjadj(0, jj, 0, 3, sps)
   ! Set the values of the porosities for this face.
   ! porVel defines the porosity w.r.t. velocity;
   ! porFlux defines the porosity w.r.t. the entire flux.
   ! The latter is only zero for a discontinuous block
   ! boundary that must be treated conservatively.
   ! The default value of porFlux is 0.5, such that the
   ! correct central flux is scattered to both cells.
   ! In case of a boundFlux the normal velocity is set
   ! to sFace.
   porvel = one
   porflux = half
   IF (porj(i, j, k) .EQ. noflux) porflux = 0.0
   IF (porj(i, j, k) .EQ. boundflux) THEN
   porvel = 0.0
   vnp = sface
   vnm = sface
   vnmd = 0.0
   vnpd = 0.0
   END IF
   ! Incorporate porFlux in porVel.
   porvel = porvel*porflux
   ! Compute the normal velocities relative to the grid for
   ! the face as well as the mass fluxes.
   qspd = porvel*vnpd
   qsp = (vnp-sface)*porvel
   qsmd = porvel*vnmd
   qsm = (vnm-sface)*porvel
   rqspd = qspd*wadj(0, jj+1, 0, irho, sps) + qsp*wadjd(0, jj+1, 0, &
   &      irho, sps)
   rqsp = qsp*wadj(0, jj+1, 0, irho, sps)
   rqsmd = qsmd*wadj(0, jj, 0, irho, sps) + qsm*wadjd(0, jj, 0, irho, &
   &      sps)
   rqsm = qsm*wadj(0, jj, 0, irho, sps)
   ! Compute the sum of the pressure multiplied by porFlux.
   ! For the default value of porFlux, 0.5, this leads to
   ! the average pressure.
   pad = porflux*(padjd(0, jj+1, 0, sps)+padjd(0, jj, 0, sps))
   pa = porflux*(padj(0, jj+1, 0, sps)+padj(0, jj, 0, sps))
   ! Compute the fluxes through this face.
   fsd = rqspd + rqsmd
   fs = rqsp + rqsm
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fsd
   dwadj(irho, sps) = dwadj(irho, sps) + fact*fs
   fsd = rqspd*wadj(0, jj+1, 0, ivx, sps) + rqsp*wadjd(0, jj+1, 0, ivx&
   &      , sps) + rqsmd*wadj(0, jj, 0, ivx, sps) + rqsm*wadjd(0, jj, 0, ivx&
   &      , sps) + sjadj(0, jj, 0, 1, sps)*pad
   fs = rqsp*wadj(0, jj+1, 0, ivx, sps) + rqsm*wadj(0, jj, 0, ivx, sps)&
   &      + pa*sjadj(0, jj, 0, 1, sps)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fsd
   dwadj(imx, sps) = dwadj(imx, sps) + fact*fs
   fsd = rqspd*wadj(0, jj+1, 0, ivy, sps) + rqsp*wadjd(0, jj+1, 0, ivy&
   &      , sps) + rqsmd*wadj(0, jj, 0, ivy, sps) + rqsm*wadjd(0, jj, 0, ivy&
   &      , sps) + sjadj(0, jj, 0, 2, sps)*pad
   fs = rqsp*wadj(0, jj+1, 0, ivy, sps) + rqsm*wadj(0, jj, 0, ivy, sps)&
   &      + pa*sjadj(0, jj, 0, 2, sps)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fsd
   dwadj(imy, sps) = dwadj(imy, sps) + fact*fs
   fsd = rqspd*wadj(0, jj+1, 0, ivz, sps) + rqsp*wadjd(0, jj+1, 0, ivz&
   &      , sps) + rqsmd*wadj(0, jj, 0, ivz, sps) + rqsm*wadjd(0, jj, 0, ivz&
   &      , sps) + sjadj(0, jj, 0, 3, sps)*pad
   fs = rqsp*wadj(0, jj+1, 0, ivz, sps) + rqsm*wadj(0, jj, 0, ivz, sps)&
   &      + pa*sjadj(0, jj, 0, 3, sps)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fsd
   dwadj(imz, sps) = dwadj(imz, sps) + fact*fs
   fsd = qspd*wadj(0, jj+1, 0, irhoe, sps) + qsp*wadjd(0, jj+1, 0, &
   &      irhoe, sps) + qsmd*wadj(0, jj, 0, irhoe, sps) + qsm*wadjd(0, jj, 0&
   &      , irhoe, sps) + porflux*(vnpd*padj(0, jj+1, 0, sps)+vnp*padjd(0, &
   &      jj+1, 0, sps)+vnmd*padj(0, jj, 0, sps)+vnm*padjd(0, jj, 0, sps))
   fs = qsp*wadj(0, jj+1, 0, irhoe, sps) + qsm*wadj(0, jj, 0, irhoe, &
   &      sps) + porflux*(vnp*padj(0, jj+1, 0, sps)+vnm*padj(0, jj, 0, sps))
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fsd
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*fs
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   fact = one
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Advective fluxes in the k-direction.                           *
   !      *                                                                *
   !      ******************************************************************
   !
   !       should this be inside, have k=kCell+kk?
   i = icell
   j = jcell
   k = kcell - 1
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   ! Set the dot product of the grid velocity and the
   ! normal in k-direction for a moving face.
   IF (addgridvelocities) sface = sfacekadj(0, 0, kk, sps)
   ! Compute the normal velocities of the left and right state.
   vnpd = skadj(0, 0, kk, 1, sps)*wadjd(0, 0, kk+1, ivx, sps) + skadj(0&
   &      , 0, kk, 2, sps)*wadjd(0, 0, kk+1, ivy, sps) + skadj(0, 0, kk, 3, &
   &      sps)*wadjd(0, 0, kk+1, ivz, sps)
   vnp = wadj(0, 0, kk+1, ivx, sps)*skadj(0, 0, kk, 1, sps) + wadj(0, 0&
   &      , kk+1, ivy, sps)*skadj(0, 0, kk, 2, sps) + wadj(0, 0, kk+1, ivz, &
   &      sps)*skadj(0, 0, kk, 3, sps)
   vnmd = skadj(0, 0, kk, 1, sps)*wadjd(0, 0, kk, ivx, sps) + skadj(0, &
   &      0, kk, 2, sps)*wadjd(0, 0, kk, ivy, sps) + skadj(0, 0, kk, 3, sps)&
   &      *wadjd(0, 0, kk, ivz, sps)
   vnm = wadj(0, 0, kk, ivx, sps)*skadj(0, 0, kk, 1, sps) + wadj(0, 0, &
   &      kk, ivy, sps)*skadj(0, 0, kk, 2, sps) + wadj(0, 0, kk, ivz, sps)*&
   &      skadj(0, 0, kk, 3, sps)
   ! Set the values of the porosities for this face.
   ! porVel defines the porosity w.r.t. velocity;
   ! porFlux defines the porosity w.r.t. the entire flux.
   ! The latter is only zero for a discontinuous block
   ! boundary that must be treated conservatively.
   ! The default value of porFlux is 0.5, such that the
   ! correct central flux is scattered to both cells.
   ! In case of a boundFlux the normal velocity is set
   ! to sFace.
   porvel = one
   porflux = half
   IF (pork(i, j, k) .EQ. noflux) porflux = 0.0
   IF (pork(i, j, k) .EQ. boundflux) THEN
   porvel = 0.0
   vnp = sface
   vnm = sface
   vnmd = 0.0
   vnpd = 0.0
   END IF
   ! Incorporate porFlux in porVel.
   porvel = porvel*porflux
   ! Compute the normal velocities relative to the grid for
   ! the face as well as the mass fluxes.
   qspd = porvel*vnpd
   qsp = (vnp-sface)*porvel
   qsmd = porvel*vnmd
   qsm = (vnm-sface)*porvel
   rqspd = qspd*wadj(0, 0, kk+1, irho, sps) + qsp*wadjd(0, 0, kk+1, &
   &      irho, sps)
   rqsp = qsp*wadj(0, 0, kk+1, irho, sps)
   rqsmd = qsmd*wadj(0, 0, kk, irho, sps) + qsm*wadjd(0, 0, kk, irho, &
   &      sps)
   rqsm = qsm*wadj(0, 0, kk, irho, sps)
   ! Compute the sum of the pressure multiplied by porFlux.
   ! For the default value of porFlux, 0.5, this leads to
   ! the average pressure.
   pad = porflux*(padjd(0, 0, kk+1, sps)+padjd(0, 0, kk, sps))
   pa = porflux*(padj(0, 0, kk+1, sps)+padj(0, 0, kk, sps))
   ! Compute the fluxes through this face.
   fsd = rqspd + rqsmd
   fs = rqsp + rqsm
   dwadjd(irho, sps) = dwadjd(irho, sps) + fact*fsd
   dwadj(irho, sps) = dwadj(irho, sps) + fact*fs
   fsd = rqspd*wadj(0, 0, kk+1, ivx, sps) + rqsp*wadjd(0, 0, kk+1, ivx&
   &      , sps) + rqsmd*wadj(0, 0, kk, ivx, sps) + rqsm*wadjd(0, 0, kk, ivx&
   &      , sps) + skadj(0, 0, kk, 1, sps)*pad
   fs = rqsp*wadj(0, 0, kk+1, ivx, sps) + rqsm*wadj(0, 0, kk, ivx, sps)&
   &      + pa*skadj(0, 0, kk, 1, sps)
   dwadjd(imx, sps) = dwadjd(imx, sps) + fact*fsd
   dwadj(imx, sps) = dwadj(imx, sps) + fact*fs
   fsd = rqspd*wadj(0, 0, kk+1, ivy, sps) + rqsp*wadjd(0, 0, kk+1, ivy&
   &      , sps) + rqsmd*wadj(0, 0, kk, ivy, sps) + rqsm*wadjd(0, 0, kk, ivy&
   &      , sps) + skadj(0, 0, kk, 2, sps)*pad
   fs = rqsp*wadj(0, 0, kk+1, ivy, sps) + rqsm*wadj(0, 0, kk, ivy, sps)&
   &      + pa*skadj(0, 0, kk, 2, sps)
   dwadjd(imy, sps) = dwadjd(imy, sps) + fact*fsd
   dwadj(imy, sps) = dwadj(imy, sps) + fact*fs
   fsd = rqspd*wadj(0, 0, kk+1, ivz, sps) + rqsp*wadjd(0, 0, kk+1, ivz&
   &      , sps) + rqsmd*wadj(0, 0, kk, ivz, sps) + rqsm*wadjd(0, 0, kk, ivz&
   &      , sps) + skadj(0, 0, kk, 3, sps)*pad
   fs = rqsp*wadj(0, 0, kk+1, ivz, sps) + rqsm*wadj(0, 0, kk, ivz, sps)&
   &      + pa*skadj(0, 0, kk, 3, sps)
   dwadjd(imz, sps) = dwadjd(imz, sps) + fact*fsd
   dwadj(imz, sps) = dwadj(imz, sps) + fact*fs
   fsd = qspd*wadj(0, 0, kk+1, irhoe, sps) + qsp*wadjd(0, 0, kk+1, &
   &      irhoe, sps) + qsmd*wadj(0, 0, kk, irhoe, sps) + qsm*wadjd(0, 0, kk&
   &      , irhoe, sps) + porflux*(vnpd*padj(0, 0, kk+1, sps)+vnp*padjd(0, 0&
   &      , kk+1, sps)+vnmd*padj(0, 0, kk, sps)+vnm*padjd(0, 0, kk, sps))
   fs = qsp*wadj(0, 0, kk+1, irhoe, sps) + qsm*wadj(0, 0, kk, irhoe, &
   &      sps) + porflux*(vnp*padj(0, 0, kk+1, sps)+vnm*padj(0, 0, kk, sps))
   dwadjd(irhoe, sps) = dwadjd(irhoe, sps) + fact*fsd
   dwadj(irhoe, sps) = dwadj(irhoe, sps) + fact*fs
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   fact = one
   END DO
   ! Add the rotational source terms for a moving block in a
   ! steady state computation. These source terms account for the
   ! centrifugal acceleration and the coriolis term. However, as
   ! the equations are solved in the inertial frame and not
   ! in the moving frame, the form is different than what you
   ! normally find in a text book.
   IF (blockismoving .AND. equationmode .EQ. steady) THEN
   !          wx = timeRef*rotRateAdj(1)
   !          wy = timeRef*rotRateAdj(2)
   !          wz = timeRef*rotRateAdj(3)
   !timeref is taken into account in copyAdjointStencil...
   wx = rotrateadj(1)
   wy = rotrateadj(2)
   wz = rotrateadj(3)
   rvold = voladj(0, 0, 0, sps)*wadjd(0, 0, 0, irho, sps)
   rvol = wadj(0, 0, 0, irho, sps)*voladj(0, 0, 0, sps)
   dwadjd(imx, sps) = dwadjd(imx, sps) + rvold*(wy*wadj(0, 0, 0, ivz, &
   &      sps)-wz*wadj(0, 0, 0, ivy, sps)) + rvol*(wy*wadjd(0, 0, 0, ivz, &
   &      sps)-wz*wadjd(0, 0, 0, ivy, sps))
   dwadj(imx, sps) = dwadj(imx, sps) + rvol*(wy*wadj(0, 0, 0, ivz, sps)&
   &      -wz*wadj(0, 0, 0, ivy, sps))
   dwadjd(imy, sps) = dwadjd(imy, sps) + rvold*(wz*wadj(0, 0, 0, ivx, &
   &      sps)-wx*wadj(0, 0, 0, ivz, sps)) + rvol*(wz*wadjd(0, 0, 0, ivx, &
   &      sps)-wx*wadjd(0, 0, 0, ivz, sps))
   dwadj(imy, sps) = dwadj(imy, sps) + rvol*(wz*wadj(0, 0, 0, ivx, sps)&
   &      -wx*wadj(0, 0, 0, ivz, sps))
   dwadjd(imz, sps) = dwadjd(imz, sps) + rvold*(wx*wadj(0, 0, 0, ivy, &
   &      sps)-wy*wadj(0, 0, 0, ivx, sps)) + rvol*(wx*wadjd(0, 0, 0, ivy, &
   &      sps)-wy*wadjd(0, 0, 0, ivx, sps))
   dwadj(imz, sps) = dwadj(imz, sps) + rvol*(wx*wadj(0, 0, 0, ivy, sps)&
   &      -wy*wadj(0, 0, 0, ivx, sps))
   END IF
   END SUBROUTINE INVISCIDCENTRALFLUXNKPC_D

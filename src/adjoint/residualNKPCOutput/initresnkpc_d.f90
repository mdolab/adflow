   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of initresnkpc in forward (tangent) mode:
   !   variations   of useful results: dwadj
   !   with respect to varying inputs: wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          initres.f90                                     *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-18-2003                                      *
   !      * Last modified: 06-28-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INITRESNKPC_D(varstart, varend, wadj, wadjd, voladj, dwadj, &
   &  dwadjd, nn, level, sps)
   USE FLOWVARREFSTATE
   USE INPUTITERATION
   USE BLOCKPOINTERS
   USE INPUTTIMESPECTRAL
   USE INPUTUNSTEADY
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * initres initializes the given range of the residual. Either to *
   !      * zero, steady computation, or to an unsteady term for the time  *
   !      * spectral and unsteady modes. For the coarser grid levels the   *
   !      * residual forcing term is taken into account.                   *
   !      *                                                                *
   !      * This is a local routine, so assume that pointers are already   *
   !      * set.                                                           *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: varstart, varend
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadjd
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadj
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadjd
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: voladj
   INTEGER(kind=inttype), INTENT(IN) :: nn, level, sps
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm, ll, ii, jj, i, j, k, l, m
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw) :: wspadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw) :: wspadjd
   REAL(kind=realtype) :: volspadj
   !unsteady and timespectral variables
   REAL(kind=realtype) :: oneoverdt, tmp
   REAL(kind=realtype) :: tmpd
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately of no variables are in the range.
   IF (varend .LT. varstart) THEN
   dwadjd = 0.0
   RETURN
   ELSE IF (equationmode .EQ. steady) THEN
   ! Determine the equation mode and act accordingly.
   !print *,'equation Mode',equationMode,'ref',steady,timespectral,unsteady
   !switch to if statments. this particular case setup doesn't work
   !with tapenade. The steady case dissappears and Tapenade doesn't
   !know how to handle the empty case....
   !           select case (equationMode)
   !             case (steady)
   ! Steady state computation.
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   DO l=varstart,varend
   dwadjd(l, :) = 0.0
   dwadj(l, :) = zero
   END DO
   dwadjd = 0.0
   ELSE
   CALL TERMINATE('initResAD', &
   &                  'ADjoint does not function on coarse grid level')
   dwadjd = 0.0
   END IF
   ELSE IF (equationmode .EQ. unsteady) THEN
   !===========================================================
   !case (unsteady)
   ! Unsteady computation.
   ! A further distinction must be made.
   SELECT CASE  (timeintegrationscheme) 
   CASE (explicitrk) 
   DO l=varstart,varend
   dwadjd(l, :) = 0.0
   dwadj(l, :) = zero
   END DO
   dwadjd = 0.0
   CASE (implicitrk) 
   !=======================================================
   CALL TERMINATE('initRes', 'Implicit RK not implemented yet')
   dwadjd = 0.0
   CASE (bdf) 
   !=======================================================
   CALL TERMINATE('initRes', 'BDF ADjoint not yet implemented')
   dwadjd = 0.0
   CASE DEFAULT
   dwadjd = 0.0
   END SELECT
   ELSE IF (equationmode .EQ. timespectral) THEN
   !===========================================================
   ! Time spectral computation. The time derivative of the
   ! current solution is given by a linear combination of
   ! all other solutions, i.e. a matrix vector product.
   ! First store the section to which this block belongs
   ! in jj.
   jj = sectionid
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   ! Finest multigrid level. The residual must be
   ! initialized to the time derivative.
   ! Initialize it to zero.
   DO l=varstart,varend
   dwadjd(l, sps) = 0.0
   dwadj(l, sps) = zero
   END DO
   dwadjd = 0.0
   ! Loop over the number of terms which contribute
   ! to the time derivative.
   timeloopfine:DO mm=1,ntimeintervalsspectral
   ! Store the pointer for the variable to be used to
   ! compute the unsteady source term and the volume.
   ! Also store in ii the offset needed for vector
   ! quantities.
   wspadjd = wadjd(:, :, :, :, mm)
   wspadj = wadj(:, :, :, :, mm)
   !(:,:,:,mm)
   volspadj = voladj(mm)
   ii = 3*(mm-1)
   ! Loop over the number of variables to be set.
   varloopfine:DO l=varstart,varend
   ! Test for a momentum variable.
   IF ((l .EQ. ivx .OR. l .EQ. ivy) .OR. l .EQ. ivz) THEN
   ! Momentum variable. A special treatment is
   ! needed because it is a vector and the velocities
   ! are stored instead of the momentum. Set the
   ! coefficient ll, which defines the row of the
   ! matrix used later on.
   IF (l .EQ. ivx) ll = 3*sps - 2
   IF (l .EQ. ivy) ll = 3*sps - 1
   IF (l .EQ. ivz) ll = 3*sps
   ! Loop over the owned cell centers to add the
   ! contribution from wsp.
   ! Store the matrix vector product with the
   ! velocity in tmp.
   tmpd = dvector(jj, ll, ii+1)*wspadjd(0, 0, 0, ivx) + dvector&
   &              (jj, ll, ii+2)*wspadjd(0, 0, 0, ivy) + dvector(jj, ll, ii+&
   &              3)*wspadjd(0, 0, 0, ivz)
   tmp = dvector(jj, ll, ii+1)*wspadj(0, 0, 0, ivx) + dvector(&
   &              jj, ll, ii+2)*wspadj(0, 0, 0, ivy) + dvector(jj, ll, ii+3)&
   &              *wspadj(0, 0, 0, ivz)
   ! Update the residual. Note the
   ! multiplication with the density to obtain
   ! the correct time derivative for the
   ! momentum variable.
   dwadjd(l, sps) = dwadjd(l, sps) + volspadj*(tmpd*wspadj(0, 0&
   &              , 0, irho)+tmp*wspadjd(0, 0, 0, irho))
   dwadj(l, sps) = dwadj(l, sps) + tmp*volspadj*wspadj(0, 0, 0&
   &              , irho)
   ELSE
   ! Scalar variable.  Loop over the owned cells to
   ! add the contribution of wsp to the time
   ! derivative.
   dwadjd(l, sps) = dwadjd(l, sps) + dscalar(jj, sps, mm)*&
   &              volspadj*wspadjd(0, 0, 0, l)
   dwadj(l, sps) = dwadj(l, sps) + dscalar(jj, sps, mm)*&
   &              volspadj*wspadj(0, 0, 0, l)
   END IF
   END DO varloopfine
   END DO timeloopfine
   ELSE
   CALL TERMINATE('initRes', &
   &                  'Coarse levels not supported in ADjoint...')
   dwadjd = 0.0
   END IF
   ELSE
   CALL TERMINATE('initResAdj', 'Not a valid equation Mode...')
   dwadjd = 0.0
   END IF
   END SUBROUTINE INITRESNKPC_D

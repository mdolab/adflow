   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of residualnkpc in reverse (adjoint) mode:
   !   gradient, with respect to input variables: padj radkadj radjadj
   !                dwadj wadj radiadj vis2 vis4 cdisrk
   !   of linear combination of output variables: dwadj massflowfamilydiss
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          residual.f90                                    *
   !      * Author:        C.A.(Sandy) Mader                               *
   !      * Starting date: 04-21-2008                                      *
   !      * Last modified: 04-28-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE RESIDUALNKPC_B(wadj, wadjb, padj, padjb, siadj, sjadj, skadj&
   &  , voladj, normadj, sfaceiadj, sfacejadj, sfacekadj, radiadj, radiadjb&
   &  , radjadj, radjadjb, radkadj, radkadjb, dwadj, dwadjb, icell, jcell, &
   &  kcell, rotrateadj, correctfork, nn, level, sps)
   USE blockpointers
   USE cgnsgrid
   USE flowvarrefstate
   USE inputdiscretization
   USE inputiteration
   USE inputtimespectral
   USE iteration
   IMPLICIT NONE
   !
   !          if( viscous ) call viscousFlux
   ! Add the dissipative and possibly viscous fluxes to the
   ! Euler fluxes. Loop over the owned cells and add fw to dw.
   ! Also multiply by iblank so that no updates occur in holes
   ! or on the overset boundary.
   ! ADD VISCOUS FLUXES HERE
   !            do l=1,nwf
   !               dwAdj(l,sps) =dwAdj(l,sps) + 
   !            enddo
   LOGICAL, INTENT(IN) :: correctfork
   REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
   &  ntimeintervalsspectral)
   INTEGER(KIND=INTTYPE) :: icell, jcell, kcell, level, nn, sps
   REAL(KIND=REALTYPE) :: normadj(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2, ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: radiadj(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radiadjb(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radjadj(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radjadjb(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radkadj(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radkadjb(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: rotrateadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfacejadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfacekadj
   REAL(KIND=REALTYPE) :: siadj(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), sjadj(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), skadj(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: voladj(0:0, 0:0, 0:0, ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: wadj(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), wadjb(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral)
   INTEGER :: branch
   INTEGER(KIND=INTTYPE) :: discr
   REAL(KIND=REALTYPE) :: dwadj2(nw, ntimeintervalsspectral)
   LOGICAL :: finegrid
   REAL(KIND=REALTYPE) :: fwadj(nw, ntimeintervalsspectral)
   INTEGER(KIND=INTTYPE) :: i, j, k, l
   !
   !      ******************************************************************
   !      *                                                                *
   !      * residual computes the residual of the mean flow equations on   *
   !      * the current MG level.                                          *
   !      *                                                                *
   !      ******************************************************************
   !
   !       Subroutine Variables
   !integer(kind=intType), intent(in) :: discr
   !
   !      Local variables.
   !
   !sps, nn, discr
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   !   Come back to this later....
   !!$       ! Add the source terms from the level 0 cooling model.
   !!$
   !!$       call level0CoolingModel
   ! Set the value of rFil, which controls the fraction of the old
   ! dissipation residual to be used. This is only for the runge-kutta
   ! schemes; for other smoothers rFil is simply set to 1.0.
   ! Note the index rkStage+1 for cdisRK. The reason is that the
   ! residual computation is performed before rkStage is incremented.
   IF (smoother .EQ. rungekutta) THEN
   rfil = cdisrk(rkstage+1)
   CALL PUSHINTEGER4(0)
   ELSE
   rfil = one
   CALL PUSHINTEGER4(1)
   END IF
   ! Initialize the local arrays to monitor the massflows to zero.
   !!massFlowFamilyInv  = zero
   !!massFlowFamilyDiss = zero
   ! Set the value of the discretization, depending on the grid level,
   ! and the logical fineGrid, which indicates whether or not this
   ! is the finest grid level of the current mg cycle.
   discr = spacediscrcoarse
   IF (currentlevel .EQ. 1) THEN
   discr = spacediscr
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   finegrid = .false.
   IF (currentlevel .EQ. groundlevel) THEN
   finegrid = .true.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL INVISCIDCENTRALFLUXNKPC(wadj, padj, dwadj, siadj, sjadj, skadj, &
   &                         voladj, sfaceiadj, sfacejadj, sfacekadj, &
   &                         rotrateadj, icell, jcell, kcell, nn, level, &
   &                         sps)
   !      call inviscidUpwindFluxNKPC(wAdj,  pAdj,  dwAdj, &
   !           siAdj, sjAdj, skAdj, &
   !           sFaceIAdj,sFaceJAdj,sFaceKAdj,&
   !           iCell, jCell, kCell,finegrid,nn,level,sps)
   ! Compute the artificial dissipation fluxes.
   ! This depends on the parameter discr.
   SELECT CASE  (discr) 
   CASE (dissscalar) 
   ! Standard scalar dissipation scheme.
   IF (finegrid) THEN
   CALL INVISCIDDISSFLUXSCALARNKPC_B(wadj, wadjb, padj, padjb, dwadj&
   &                                  , dwadjb, radiadj, radiadjb, radjadj&
   &                                  , radjadjb, radkadj, radkadjb, icell&
   &                                  , jcell, kcell, nn, level, sps)
   ELSE
   padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   radkadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   radjadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
   radiadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   END IF
   CASE (upwind) 
   padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   radkadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   radjadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
   radiadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   CASE DEFAULT
   padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   radkadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   radjadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
   radiadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   END SELECT
   CALL INVISCIDCENTRALFLUXNKPC_B(wadj, wadjb, padj, padjb, dwadj, dwadjb&
   &                           , siadj, sjadj, skadj, voladj, sfaceiadj, &
   &                           sfacejadj, sfacekadj, rotrateadj, icell, &
   &                           jcell, kcell, nn, level, sps)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)

   END SUBROUTINE RESIDUALNKPC_B

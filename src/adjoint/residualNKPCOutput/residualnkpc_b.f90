   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of residualnkpc in reverse (adjoint) mode:
   !   gradient     of useful results: dwadj
   !   with respect to varying inputs: *cdisrk vis4 kappacoef vis2
   !                padj radkadj radjadj dwadj wadj radiadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          residual.f90                                    *
   !      * Author:        C.A.(Sandy) Mader                               *
   !      * Starting date: 04-21-2008                                      *
   !      * Last modified: 04-28-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE RESIDUALNKPC_B(wadj, wadjb, padj, padjb, siadj, sjadj, skadj&
   &  , voladj, normadj, sfaceiadj, sfacejadj, sfacekadj, radiadj, radiadjb&
   &  , radjadj, radjadjb, radkadj, radkadjb, dwadj, dwadjb, icell, jcell, &
   &  kcell, rotrateadj, correctfork, nn, level, sps)
   USE INPUTITERATION
   USE CGNSGRID
   USE BLOCKPOINTERS
   USE INPUTTIMESPECTRAL
   USE INPUTDISCRETIZATION
   USE ITERATION
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !
   !          if( viscous ) call viscousFlux
   ! Add the dissipative and possibly viscous fluxes to the
   ! Euler fluxes. Loop over the owned cells and add fw to dw.
   ! Also multiply by iblank so that no updates occur in holes
   ! or on the overset boundary.
   ! ADD VISCOUS FLUXES HERE
   !            do l=1,nwf
   !               dwAdj(l,sps) =dwAdj(l,sps) + 
   !            enddo
   !
   !      ******************************************************************
   !      *                                                                *
   !      * residual computes the residual of the mean flow equations on   *
   !      * the current MG level.                                          *
   !      *                                                                *
   !      ******************************************************************
   !
   !       Subroutine Variables
   INTEGER(kind=inttype) :: icell, jcell, kcell, nn, level, sps
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(INOUT) :: siadj, sjadj, skadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj, sfacejadj, sfacekadj
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: rotrateadj
   REAL(kind=realtype), DIMENSION(0:0, 0:0, 0:0, ntimeintervalsspectral),&
   &  INTENT(INOUT) :: voladj
   REAL(kind=realtype), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(INOUT) :: normadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(INOUT) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadjb
   REAL(kind=realtype), DIMENSION(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral) :: radiadj, radjadj, radkadj
   REAL(kind=realtype), DIMENSION(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral) :: radiadjb, radjadjb, radkadjb
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral), INTENT(&
   &  INOUT) :: dwadj
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral) :: dwadjb
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral) :: dwadj2
   !integer(kind=intType), intent(in) :: discr
   LOGICAL, INTENT(IN) :: correctfork
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral) :: padjb
   REAL(kind=realtype), DIMENSION(nw, ntimeintervalsspectral) :: fwadj
   !
   !      Local variables.
   !
   !sps, nn, discr
   INTEGER(kind=inttype) :: discr
   INTEGER(kind=inttype) :: i, j, k, l
   LOGICAL :: finegrid
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   !   Come back to this later....
   !!$       ! Add the source terms from the level 0 cooling model.
   !!$
   !!$       call level0CoolingModel
   ! Set the value of rFil, which controls the fraction of the old
   ! dissipation residual to be used. This is only for the runge-kutta
   ! schemes; for other smoothers rFil is simply set to 1.0.
   ! Note the index rkStage+1 for cdisRK. The reason is that the
   ! residual computation is performed before rkStage is incremented.
   IF (smoother .EQ. rungekutta) THEN
   rfil = cdisrk(rkstage+1)
   ELSE
   rfil = one
   END IF
   ! Initialize the local arrays to monitor the massflows to zero.
   !!massFlowFamilyInv  = zero
   !!massFlowFamilyDiss = zero
   ! Set the value of the discretization, depending on the grid level,
   ! and the logical fineGrid, which indicates whether or not this
   ! is the finest grid level of the current mg cycle.
   discr = spacediscrcoarse
   IF (currentlevel .EQ. 1) discr = spacediscr
   finegrid = .false.
   IF (currentlevel .EQ. groundlevel) finegrid = .true.
   ! Compute the artificial dissipation fluxes.
   ! This depends on the parameter discr.
   SELECT CASE  (discr) 
   CASE (dissscalar) 
   ! Standard scalar dissipation scheme.
   IF (finegrid) THEN
   CALL INVISCIDDISSFLUXSCALARNKPC_B(wadj, wadjb, padj, padjb, dwadj&
   &                                  , dwadjb, radiadj, radiadjb, radjadj, &
   &                                  radjadjb, radkadj, radkadjb, icell, &
   &                                  jcell, kcell, nn, level, sps)
   ELSE
   padjb = 0.0
   radkadjb = 0.0
   radjadjb = 0.0
   wadjb = 0.0
   radiadjb = 0.0
   END IF
   CASE (upwind) 
   CALL INVISCIDUPWINDFLUXNKPC_B(wadj, wadjb, padj, padjb, dwadj, &
   &                            dwadjb, siadj, sjadj, skadj, sfaceiadj, &
   &                            sfacejadj, sfacekadj, icell, jcell, kcell, &
   &                            finegrid, nn, level, sps)
   radkadjb = 0.0
   radjadjb = 0.0
   radiadjb = 0.0
   END SELECT
   100 CALL INVISCIDCENTRALFLUXNKPC_B(wadj, wadjb, padj, padjb, dwadj, &
   &                              dwadjb, siadj, sjadj, skadj, voladj, &
   &                              sfaceiadj, sfacejadj, sfacekadj, &
   &                              rotrateadj, icell, jcell, kcell, nn, level&
   &                              , sps)
   END SUBROUTINE RESIDUALNKPC_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of timestepnkpc in forward (tangent) mode:
   !   variations   of useful results: radkadj radjadj radiadj
   !   with respect to varying inputs: adis padj radkadj radjadj wadj
   !                radiadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          timeStepAdj.f90                                 *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 08-05-2009                                      *
   !      * Last modified: 08-05-2009                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE TIMESTEPNKPC_D(onlyradii, wadj, wadjd, padj, padjd, siadj, &
   &  sjadj, skadj, sfaceiadj, sfacejadj, sfacekadj, voladj, radiadj, &
   &  radiadjd, radjadj, radjadjd, radkadj, radkadjd, icell, jcell, kcell, &
   &  pinfcorradj, rhoinfadj, nn, level, sps, sps2)
   USE FLOWVARREFSTATE
   USE INPUTITERATION
   USE BLOCKPOINTERS
   USE SECTION
   USE INPUTTIMESPECTRAL
   USE INPUTPHYSICS
   USE INPUTDISCRETIZATION
   USE CONSTANTS
   USE ITERATION
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * timeStep computes the time step, or more precisely the time    *
   !      * step divided by the volume per unit CFL, in the owned cells.   *
   !      * However, for the artificial dissipation schemes, the spectral  *
   !      * radIi in the halo's are needed. Therefore the loop is taken    *
   !      * over the the first level of halo cells. The spectral radIi are *
   !      * stored and possibly modified for high aspect ratio cells.      *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine argument.
   !
   LOGICAL, INTENT(IN) :: onlyradii
   INTEGER(kind=inttype), INTENT(IN) :: icell, jcell, kcell, nn, level, &
   &  sps, sps2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadjd
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral) :: padjd
   REAL(kind=realtype), DIMENSION(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral) :: radiadj, radjadj, radkadj
   REAL(kind=realtype), DIMENSION(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral) :: radiadjd, radjadjd, radkadjd
   REAL(kind=realtype), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral) :: siadj, sjadj, skadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral) :: sfaceiadj, sfacejadj, sfacekadj
   REAL(kind=realtype) :: pinfcorradj, rhoinfadj
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: voladj
   !
   !      Local parameters.
   !
   REAL(kind=realtype), PARAMETER :: b=2.0_realType
   !
   !      Local variables.
   !
   !integer(kind=intType) :: sps, nn, i, j, k
   INTEGER(kind=inttype) :: i, j, k, ii, jj, kk
   REAL(kind=realtype) :: plim, rlim, clim2
   REAL(kind=realtype) :: ux, uy, uz, cc2, qs, sx, sy, sz, rmu
   REAL(kind=realtype) :: uxd, uyd, uzd, cc2d, qsd
   REAL(kind=realtype) :: ri, rj, rk, rij, rjk, rki
   REAL(kind=realtype) :: rid, rjd, rkd, rijd, rjkd, rkid
   REAL(kind=realtype) :: vsi, vsj, vsk, rfl, dpi, dpj, dpk
   REAL(kind=realtype) :: sface, tmp
   REAL(kind=realtype) :: dtladj
   LOGICAL :: radiineeded
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: result1d
   REAL(kind=realtype) :: pwx1
   REAL(kind=realtype) :: pwx1d
   REAL(kind=realtype) :: abs1d
   REAL(kind=realtype) :: abs4d
   INTRINSIC MAX
   INTRINSIC ABS
   REAL(kind=realtype) :: abs3d
   REAL(kind=realtype) :: abs6d
   REAL(kind=realtype) :: abs9
   REAL(kind=realtype) :: abs8
   REAL(kind=realtype) :: abs7
   REAL(kind=realtype) :: abs6
   REAL(kind=realtype) :: abs5
   REAL(kind=realtype) :: abs4
   REAL(kind=realtype) :: abs3
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs2d
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: abs5d
   INTRINSIC SQRT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine whether or not the spectral radii are needed for the
   ! flux computation.
   radiineeded = radiineededcoarse
   IF (currentlevel .LE. groundlevel) radiineeded = radiineededfine
   ! Return immediately if only the spectral radii must be computed
   ! and these are not needed for the flux computation.
   IF (onlyradii .AND. (.NOT.radiineeded)) THEN
   RETURN
   ELSE
   ! Set the value of plim. To be fully consistent this must have
   ! the dimension of a pressure. Therefore a fraction of pInfCorr
   ! is used. Idem for rlim; compute clim2 as well.
   plim = 0.001_realType*pinfcorradj
   rlim = 0.001_realType*rhoinfadj
   clim2 = 0.000001_realType*gammainf*pinfcorradj/rhoinfadj
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   !
   !          **************************************************************
   !          *                                                            *
   !          * Inviscid contribution, depending on the preconditioner.    *
   !          * Compute the cell centered values of the spectral radii.    *
   !          *                                                            *
   !          **************************************************************
   !
   !print *,'precond:',precond
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner. Simply the standard spectral radius.
   ! Loop over the cells, including the first level halo.
   DO k=-1,1
   DO j=-1,1
   DO i=-1,1
   ii = icell + i
   jj = jcell + j
   kk = kcell + k
   ! Compute the velocities and speed of sound squared.
   uxd = wadjd(i, j, k, ivx, sps2)
   ux = wadj(i, j, k, ivx, sps2)
   uyd = wadjd(i, j, k, ivy, sps2)
   uy = wadj(i, j, k, ivy, sps2)
   uzd = wadjd(i, j, k, ivz, sps2)
   uz = wadj(i, j, k, ivz, sps2)
   cc2d = (gamma(ii, jj, kk)*padjd(i, j, k, sps2)*wadj(i, j, k&
   &              , irho, sps2)-gamma(ii, jj, kk)*padj(i, j, k, sps2)*wadjd(&
   &              i, j, k, irho, sps2))/wadj(i, j, k, irho, sps2)**2
   cc2 = gamma(ii, jj, kk)*padj(i, j, k, sps2)/wadj(i, j, k, &
   &              irho, sps2)
   IF (cc2 .LT. clim2) THEN
   cc2 = clim2
   cc2d = 0.0
   ELSE
   cc2 = cc2
   END IF
   ! Set the dot product of the grid velocity and the
   ! normal in i-direction for a moving face. To avoid
   ! a number of multiplications by 0.5 simply the sum
   ! is taken.
   IF (addgridvelocities) sface = sfaceiadj(i-1, j, k, sps2) + &
   &                sfaceiadj(i, j, k, sps2)
   ! Spectral radius in i-direction.
   sx = siadj(i-1, j, k, 1, sps2) + siadj(i, j, k, 1, sps2)
   sy = siadj(i-1, j, k, 2, sps2) + siadj(i, j, k, 2, sps2)
   sz = siadj(i-1, j, k, 3, sps2) + siadj(i, j, k, 3, sps2)
   qsd = sx*uxd + sy*uyd + sz*uzd
   qs = ux*sx + uy*sy + uz*sz - sface
   IF ((sx**2 .GT. zero .OR. sy**2 .GT. zero) .OR. sz**2 .GT. &
   &                zero) THEN
   IF (qs .GE. 0.) THEN
   abs1d = qsd
   abs1 = qs
   ELSE
   abs1d = -qsd
   abs1 = -qs
   END IF
   arg1d = (sx**2+sy**2+sz**2)*cc2d
   arg1 = cc2*(sx**2+sy**2+sz**2)
   IF (arg1 .EQ. 0.0) THEN
   result1d = 0.0
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   radiadjd(i, j, k, sps2) = half*(abs1d+result1d)
   radiadj(i, j, k, sps2) = half*(abs1+result1)
   ELSE
   IF (qs .GE. 0.) THEN
   abs2d = qsd
   abs2 = qs
   ELSE
   abs2d = -qsd
   abs2 = -qs
   END IF
   radiadjd(i, j, k, sps2) = half*abs2d
   radiadj(i, j, k, sps2) = half*abs2
   END IF
   ! The grid velocity in j-direction.
   IF (addgridvelocities) sface = sfacejadj(i, j-1, k, sps2) + &
   &                sfacejadj(i, j, k, sps2)
   ! Spectral radius in j-direction.
   sx = sjadj(i, j-1, k, 1, sps2) + sjadj(i, j, k, 1, sps2)
   sy = sjadj(i, j-1, k, 2, sps2) + sjadj(i, j, k, 2, sps2)
   sz = sjadj(i, j-1, k, 3, sps2) + sjadj(i, j, k, 3, sps2)
   qsd = sx*uxd + sy*uyd + sz*uzd
   qs = ux*sx + uy*sy + uz*sz - sface
   IF ((sx**2 .GT. zero .OR. sy**2 .GT. zero) .OR. sz**2 .GT. &
   &                zero) THEN
   IF (qs .GE. 0.) THEN
   abs3d = qsd
   abs3 = qs
   ELSE
   abs3d = -qsd
   abs3 = -qs
   END IF
   arg1d = (sx**2+sy**2+sz**2)*cc2d
   arg1 = cc2*(sx**2+sy**2+sz**2)
   IF (arg1 .EQ. 0.0) THEN
   result1d = 0.0
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   radjadjd(i, j, k, sps2) = half*(abs3d+result1d)
   radjadj(i, j, k, sps2) = half*(abs3+result1)
   ELSE
   IF (qs .GE. 0.) THEN
   abs4d = qsd
   abs4 = qs
   ELSE
   abs4d = -qsd
   abs4 = -qs
   END IF
   radjadjd(i, j, k, sps2) = half*abs4d
   radjadj(i, j, k, sps2) = half*abs4
   END IF
   ! The grid velocity in k-direction.
   IF (addgridvelocities) sface = sfacekadj(i, j, k-1, sps2) + &
   &                sfacekadj(i, j, k, sps2)
   ! Spectral radius in k-direction.
   sx = skadj(i, j, k-1, 1, sps2) + skadj(i, j, k, 1, sps2)
   sy = skadj(i, j, k-1, 2, sps2) + skadj(i, j, k, 2, sps2)
   sz = skadj(i, j, k-1, 3, sps2) + skadj(i, j, k, 3, sps2)
   qsd = sx*uxd + sy*uyd + sz*uzd
   qs = ux*sx + uy*sy + uz*sz - sface
   IF ((sx**2 .GT. zero .OR. sy**2 .GT. zero) .OR. sz**2 .GT. &
   &                zero) THEN
   IF (qs .GE. 0.) THEN
   abs5d = qsd
   abs5 = qs
   ELSE
   abs5d = -qsd
   abs5 = -qs
   END IF
   arg1d = (sx**2+sy**2+sz**2)*cc2d
   arg1 = cc2*(sx**2+sy**2+sz**2)
   IF (arg1 .EQ. 0.0) THEN
   result1d = 0.0
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   radkadjd(i, j, k, sps2) = half*(abs5d+result1d)
   radkadj(i, j, k, sps2) = half*(abs5+result1)
   ELSE
   IF (qs .GE. 0.) THEN
   abs6d = qsd
   abs6 = qs
   ELSE
   abs6d = -qsd
   abs6 = -qs
   END IF
   radkadjd(i, j, k, sps2) = half*abs6d
   radkadj(i, j, k, sps2) = half*abs6
   END IF
   ! Compute the inviscid contribution to the time step.
   dtladj = radiadj(i, j, k, sps2) + radjadj(i, j, k, sps2) + &
   &              radkadj(i, j, k, sps2)
   END DO
   END DO
   END DO
   CASE (turkel) 
   CALL TERMINATE('timeStep', &
   &                  'Turkel preconditioner not implemented yet')
   CASE (choimerkle) 
   CALL TERMINATE('timeStep', &
   &                  'choi merkle preconditioner not implemented yet')
   END SELECT
   !
   !          **************************************************************
   !          *                                                            *
   !          * Adapt the spectral radii if directional scaling must be    *
   !          * applied.                                                   *
   !          *                                                            *
   !          **************************************************************
   !
   IF (dirscaling .AND. currentlevel .LE. groundlevel) THEN
   DO k=-1,1
   DO j=-1,1
   DO i=-1,1
   IF (radiadj(i, j, k, sps2) .LT. eps) THEN
   ri = eps
   rid = 0.0
   ELSE
   rid = radiadjd(i, j, k, sps2)
   ri = radiadj(i, j, k, sps2)
   END IF
   IF (radjadj(i, j, k, sps2) .LT. eps) THEN
   rj = eps
   rjd = 0.0
   ELSE
   rjd = radjadjd(i, j, k, sps2)
   rj = radjadj(i, j, k, sps2)
   END IF
   IF (radkadj(i, j, k, sps2) .LT. eps) THEN
   rk = eps
   rkd = 0.0
   ELSE
   rkd = radkadjd(i, j, k, sps2)
   rk = radkadj(i, j, k, sps2)
   END IF
   ! Compute the scaling in the three coordinate
   ! directions.
   pwx1d = (rid*rj-ri*rjd)/rj**2
   pwx1 = ri/rj
   IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. adis .EQ. INT(&
   &                adis))) THEN
   rijd = adis*pwx1**(adis-1)*pwx1d
   ELSE IF (pwx1 .EQ. 0.0 .AND. adis .EQ. 1.0) THEN
   rijd = pwx1d
   ELSE
   rijd = 0.0
   END IF
   rij = pwx1**adis
   pwx1d = (rjd*rk-rj*rkd)/rk**2
   pwx1 = rj/rk
   IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. adis .EQ. INT(&
   &                adis))) THEN
   rjkd = adis*pwx1**(adis-1)*pwx1d
   ELSE IF (pwx1 .EQ. 0.0 .AND. adis .EQ. 1.0) THEN
   rjkd = pwx1d
   ELSE
   rjkd = 0.0
   END IF
   rjk = pwx1**adis
   pwx1d = (rkd*ri-rk*rid)/ri**2
   pwx1 = rk/ri
   IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. adis .EQ. INT(&
   &                adis))) THEN
   rkid = adis*pwx1**(adis-1)*pwx1d
   ELSE IF (pwx1 .EQ. 0.0 .AND. adis .EQ. 1.0) THEN
   rkid = pwx1d
   ELSE
   rkid = 0.0
   END IF
   rki = pwx1**adis
   ! Create the scaled versions of the aspect ratios.
   ! Note that the multiplication is done with radi, radJ
   ! and radK, such that the influence of the clipping
   ! is negligible.
   !   radi(i,j,k) = third*radi(i,j,k)*(one + one/rij + rki)
   !   radJ(i,j,k) = third*radJ(i,j,k)*(one + one/rjk + rij)
   !   radK(i,j,k) = third*radK(i,j,k)*(one + one/rki + rjk)
   radiadjd(i, j, k, sps2) = radiadjd(i, j, k, sps2)*(one+one/&
   &              rij+rki) + radiadj(i, j, k, sps2)*(rkid-one*rijd/rij**2)
   radiadj(i, j, k, sps2) = radiadj(i, j, k, sps2)*(one+one/rij&
   &              +rki)
   radjadjd(i, j, k, sps2) = radjadjd(i, j, k, sps2)*(one+one/&
   &              rjk+rij) + radjadj(i, j, k, sps2)*(rijd-one*rjkd/rjk**2)
   radjadj(i, j, k, sps2) = radjadj(i, j, k, sps2)*(one+one/rjk&
   &              +rij)
   radkadjd(i, j, k, sps2) = radkadjd(i, j, k, sps2)*(one+one/&
   &              rki+rjk) + radkadj(i, j, k, sps2)*(rjkd-one*rkid/rki**2)
   radkadj(i, j, k, sps2) = radkadj(i, j, k, sps2)*(one+one/rki&
   &              +rjk)
   END DO
   END DO
   END DO
   END IF
   ! The rest of this file can be skipped if only the spectral
   ! radii need to be computed.
   IF (.NOT.onlyradii) THEN
   ! The viscous contribution, if needed.
   IF (viscous) THEN
   PRINT*, 'Viscous not yet implemented'
   STOP
   ELSE
   ! For the spectral mode an additional term term must be
   ! taken into account, which corresponds to the contribution
   ! of the highest frequency.
   IF (equationmode .EQ. timespectral) THEN
   PRINT*, 'time spectral not yet implemented'
   tmp = ntimeintervalsspectral*pi*timeref/sections(sectionid)%&
   &            timeperiod
   ! Loop over the owned cell centers and add the term.
   dtladj = dtladj + tmp*voladj(sps2)
   END IF
   ! Currently the inverse of dt/vol is stored in dtl. Invert
   ! this value such that the time step per unit cfl number is
   ! stored and correct in cases of high gradients.
   DO k=-1,1
   DO j=-1,1
   DO i=-1,1
   IF (padj(i+1, j, k, sps2) - two*padj(i, j, k, sps2) + padj&
   &                  (i-1, j, k, sps2) .GE. 0.) THEN
   abs7 = padj(i+1, j, k, sps2) - two*padj(i, j, k, sps2) +&
   &                  padj(i-1, j, k, sps2)
   ELSE
   abs7 = -(padj(i+1, j, k, sps2)-two*padj(i, j, k, sps2)+&
   &                  padj(i-1, j, k, sps2))
   END IF
   dpi = abs7/(padj(i+1, j, k, sps2)+two*padj(i, j, k, sps2)+&
   &                padj(i-1, j, k, sps2)+plim)
   IF (padj(i, j+1, k, sps2) - two*padj(i, j, k, sps2) + padj&
   &                  (i, j-1, k, sps2) .GE. 0.) THEN
   abs8 = padj(i, j+1, k, sps2) - two*padj(i, j, k, sps2) +&
   &                  padj(i, j-1, k, sps2)
   ELSE
   abs8 = -(padj(i, j+1, k, sps2)-two*padj(i, j, k, sps2)+&
   &                  padj(i, j-1, k, sps2))
   END IF
   dpj = abs8/(padj(i, j+1, k, sps2)+two*padj(i, j, k, sps2)+&
   &                padj(i, j-1, k, sps2)+plim)
   IF (padj(i, j, k+1, sps2) - two*padj(i, j, k, sps2) + padj&
   &                  (i, j, k-1, sps2) .GE. 0.) THEN
   abs9 = padj(i, j, k+1, sps2) - two*padj(i, j, k, sps2) +&
   &                  padj(i, j, k-1, sps2)
   ELSE
   abs9 = -(padj(i, j, k+1, sps2)-two*padj(i, j, k, sps2)+&
   &                  padj(i, j, k-1, sps2))
   END IF
   dpk = abs9/(padj(i, j, k+1, sps2)+two*padj(i, j, k, sps2)+&
   &                padj(i, j, k-1, sps2)+plim)
   rfl = one/(one+b*(dpi+dpj+dpk))
   dtladj = rfl/dtladj
   END DO
   END DO
   END DO
   END IF
   END IF
   END IF
   END SUBROUTINE TIMESTEPNKPC_D

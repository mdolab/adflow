   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of leftrightstatenkpc in forward (tangent) mode:
   !   variations   of useful results: left right
   !   with respect to varying inputs: left right du1 du2 du3
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATENKPC_D(du1, du1d, du2, du2d, du3, du3d, left, &
   &  leftd, right, rightd, nwint, omk, opk, factminmod, firstorderk)
   USE PRECISION
   USE INPUTDISCRETIZATION
   USE CONSTANTS
   IMPLICIT NONE
   !
   !        ****************************************************************
   !        *                                                              *
   !        * leftRightState computes the differences in the left and      *
   !        * right state compared to the first order interpolation. For a *
   !        * monotonic second order discretization the interpolations     *
   !        * need to be nonlinear. The linear second order scheme can be  *
   !        * stable (depending on the value of kappa), but it will have   *
   !        * oscillations near discontinuities.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   INTEGER(kind=inttype) :: nwint
   REAL(kind=realtype) :: omk, opk, factminmod
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: du1d, du2d, du3d
   REAL(kind=realtype), DIMENSION(*) :: left, right
   REAL(kind=realtype), DIMENSION(*) :: leftd, rightd
   LOGICAL :: firstorderk
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp
   REAL(kind=realtype) :: rl1d, rl2d, rr1d, rr2d, tmpd
   REAL(kind=realtype) :: x6d
   REAL(kind=realtype) :: y4d
   REAL(kind=realtype) :: max2d
   REAL(kind=realtype) :: max5d
   INTRINSIC MAX
   REAL(kind=realtype) :: x6
   INTRINSIC SIGN
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   INTRINSIC ABS
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x5d
   REAL(kind=realtype) :: y3d
   REAL(kind=realtype) :: max1d
   REAL(kind=realtype) :: max4d
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: x4d
   REAL(kind=realtype) :: y2d
   REAL(kind=realtype) :: max3d
   INTRINSIC MIN
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max6d
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: x3d
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: y1d
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Linear interpolation; no limiter.
   ! Loop over the number of variables to be interpolated.
   SELECT CASE  (limiter) 
   CASE (nolimiter) 
   DO l=1,nwint
   leftd(l) = omk*du1d(l) + opk*du2d(l)
   left(l) = omk*du1(l) + opk*du2(l)
   rightd(l) = -(omk*du3d(l)) - opk*du2d(l)
   right(l) = -(omk*du3(l)) - opk*du2(l)
   END DO
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1d = du2d(l)
   x1 = du2(l)
   ELSE
   x1d = -du2d(l)
   x1 = -du2(l)
   END IF
   IF (x1 .LT. epslim) THEN
   max1 = epslim
   max1d = 0.0
   ELSE
   max1d = x1d
   max1 = x1
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmpd = -(one*max1d*SIGN(1.d0, max1*du2(l))/SIGN(max1, du2(l))**2)
   tmp = one/SIGN(max1, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3d = du1d(l)
   x3 = du1(l)
   ELSE
   x3d = -du1d(l)
   x3 = -du1(l)
   END IF
   IF (x3 .LT. epslim) THEN
   max3 = epslim
   max3d = 0.0
   ELSE
   max3d = x3d
   max3 = x3
   END IF
   y1d = (du2d(l)*SIGN(max3, du1(l))-du2(l)*max3d*SIGN(1.d0, max3*du1&
   &        (l)))/SIGN(max3, du1(l))**2
   y1 = du2(l)/SIGN(max3, du1(l))
   IF (zero .LT. y1) THEN
   rl1d = y1d
   rl1 = y1
   ELSE
   rl1 = zero
   rl1d = 0.0
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2d = du1d(l)*tmp + du1(l)*tmpd
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   rl2d = 0.0
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1d = du3d(l)*tmp + du3(l)*tmpd
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   rr1d = 0.0
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4d = du3d(l)
   x4 = du3(l)
   ELSE
   x4d = -du3d(l)
   x4 = -du3(l)
   END IF
   IF (x4 .LT. epslim) THEN
   max4 = epslim
   max4d = 0.0
   ELSE
   max4d = x4d
   max4 = x4
   END IF
   y2d = (du2d(l)*SIGN(max4, du3(l))-du2(l)*max4d*SIGN(1.d0, max4*du3&
   &        (l)))/SIGN(max4, du3(l))**2
   y2 = du2(l)/SIGN(max4, du3(l))
   IF (zero .LT. y2) THEN
   rr2d = y2d
   rr2 = y2
   ELSE
   rr2 = zero
   rr2d = 0.0
   END IF
   ! Compute the corresponding limiter values.
   rl1d = ((rl1d*(rl1+one)+rl1*rl1d)*(rl1*rl1+one)-rl1*(rl1+one)*(&
   &        rl1d*rl1+rl1*rl1d))/(rl1*rl1+one)**2
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   rl2d = ((rl2d*(rl2+one)+rl2*rl2d)*(rl2*rl2+one)-rl2*(rl2+one)*(&
   &        rl2d*rl2+rl2*rl2d))/(rl2*rl2+one)**2
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   rr1d = ((rr1d*(rr1+one)+rr1*rr1d)*(rr1*rr1+one)-rr1*(rr1+one)*(&
   &        rr1d*rr1+rr1*rr1d))/(rr1*rr1+one)**2
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   rr2d = ((rr2d*(rr2+one)+rr2*rr2d)*(rr2*rr2+one)-rr2*(rr2+one)*(&
   &        rr2d*rr2+rr2*rr2d))/(rr2*rr2+one)**2
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+rl2*&
   &        du2d(l))
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l)+&
   &        rr2*du3d(l))
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2d = du2d(l)
   x2 = du2(l)
   ELSE
   x2d = -du2d(l)
   x2 = -du2(l)
   END IF
   IF (x2 .LT. epslim) THEN
   max2 = epslim
   max2d = 0.0
   ELSE
   max2d = x2d
   max2 = x2
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmpd = -(one*max2d*SIGN(1.d0, max2*du2(l))/SIGN(max2, du2(l))**2)
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5d = du1d(l)
   x5 = du1(l)
   ELSE
   x5d = -du1d(l)
   x5 = -du1(l)
   END IF
   IF (x5 .LT. epslim) THEN
   max5 = epslim
   max5d = 0.0
   ELSE
   max5d = x5d
   max5 = x5
   END IF
   y3d = (du2d(l)*SIGN(max5, du1(l))-du2(l)*max5d*SIGN(1.d0, max5*du1&
   &        (l)))/SIGN(max5, du1(l))**2
   y3 = du2(l)/SIGN(max5, du1(l))
   IF (zero .LT. y3) THEN
   rl1d = y3d
   rl1 = y3
   ELSE
   rl1 = zero
   rl1d = 0.0
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2d = du1d(l)*tmp + du1(l)*tmpd
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   rl2d = 0.0
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1d = du3d(l)*tmp + du3(l)*tmpd
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   rr1d = 0.0
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6d = du3d(l)
   x6 = du3(l)
   ELSE
   x6d = -du3d(l)
   x6 = -du3(l)
   END IF
   IF (x6 .LT. epslim) THEN
   max6 = epslim
   max6d = 0.0
   ELSE
   max6d = x6d
   max6 = x6
   END IF
   y4d = (du2d(l)*SIGN(max6, du3(l))-du2(l)*max6d*SIGN(1.d0, max6*du3&
   &        (l)))/SIGN(max6, du3(l))**2
   y4 = du2(l)/SIGN(max6, du3(l))
   IF (zero .LT. y4) THEN
   rr2d = y4d
   rr2 = y4
   ELSE
   rr2 = zero
   rr2d = 0.0
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1d = factminmod*rl1d
   rl1 = factminmod*rl1
   ELSE
   rl1 = one
   rl1d = 0.0
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2d = factminmod*rl2d
   rl2 = factminmod*rl2
   ELSE
   rl2 = one
   rl2d = 0.0
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1d = factminmod*rr1d
   rr1 = factminmod*rr1
   ELSE
   rr1 = one
   rr1d = 0.0
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2d = factminmod*rr2d
   rr2 = factminmod*rr2
   ELSE
   rr2 = one
   rr2d = 0.0
   END IF
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+rl2*&
   &        du2d(l))
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l)+&
   &        rr2*du3d(l))
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   leftd(itu1) = 0.0
   left(itu1) = zero
   rightd(itu1) = 0.0
   right(itu1) = zero
   END IF
   END SUBROUTINE LEFTRIGHTSTATENKPC_D

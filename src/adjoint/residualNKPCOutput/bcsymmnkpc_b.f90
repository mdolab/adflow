   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of bcsymmnkpc in reverse (adjoint) mode:
   !   gradient, with respect to input variables: padj wadj
   !   of linear combination of output variables: padj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcSymmAdj.f90                                   *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 04-17-2008                                      *
   !      * Last modified: 04-17-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCSYMMNKPC_B(wadj, wadjb, padj, padjb, normadj, icell, jcell&
   &  , kcell, secondhalo, nnn, level, sps, sps2)
   USE bctypes
   USE blockpointers, ONLY : ie, ib, il, je, jb, jl, ke, kb, kl, nbocos&
   &  , gamma, bcfaceid, bctype, bcdata
   USE constants
   USE flowvarrefstate
   USE inputtimespectral
   USE iteration
   IMPLICIT NONE
   INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
   INTEGER(KIND=INTTYPE) :: level, nnn, sps, sps2
   REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: normadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2, ntimeintervalsspectral)
   LOGICAL :: secondhalo
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(KIND=REALTYPE) :: wadjb(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral)
   INTEGER :: ad_from, ad_from0, ad_to, ad_to0, branch
   LOGICAL :: computebc
   REAL(KIND=REALTYPE) :: gamma1(-2:2, -2:2), gamma2(-2:2, -2:2)
   INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
   INTEGER(KIND=INTTYPE) :: icbeg, icend, jcbeg, jcend, kcbeg, kcend
   INTEGER(KIND=INTTYPE) :: ioffset, joffset, koffset
   INTEGER(KIND=INTTYPE) :: i, ii, j, jj, kk, l, mm, nn
   INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
   REAL(KIND=REALTYPE) :: padj0(-2:2, -2:2), padj0b(-2:2, -2:2), padj1(-2&
   &  :2, -2:2), padj1b(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: padj2(-2:2, -2:2), padj2b(-2:2, -2:2), padj3(-2&
   &  :2, -2:2), padj3b(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: revadj1(-2:2, -2:2), revadj2(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: revadj(-2:2, -2:2, -2:2), rlvadj(-2:2, -2:2, -2&
   &  :2)
   REAL(KIND=REALTYPE) :: rlvadj1(-2:2, -2:2), rlvadj2(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: nnx, nny, nnz, tempb, tempb0, vn, vnb
   REAL(KIND=REALTYPE) :: wadj0(-2:2, -2:2, nw), wadj0b(-2:2, -2:2, nw), &
   &  wadj1(-2:2, -2:2, nw), wadj1b(-2:2, -2:2, nw)
   REAL(KIND=REALTYPE) :: wadj2(-2:2, -2:2, nw), wadj2b(-2:2, -2:2, nw), &
   &  wadj3(-2:2, -2:2, nw), wadj3b(-2:2, -2:2, nw)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcSymmAdj applies the symmetry boundary conditions to a single *
   !      * cell stencil.
   !      * It is assumed that the pointers in blockPointers are already   *
   !      * set to the correct block on the correct grid level.            *
   !      *                                                                *
   !      * In case also the second halo must be set the loop over the     *
   !      * boundary subfaces is executed twice. This is the only correct  *
   !      * way in case the block contains only 1 cell between two         *
   !      * symmetry planes, i.e. a 2D problem.                            *
   !      *                                                                *
   !      ******************************************************************
   !
   !nw
   !nt1mg,nt2mg
   !nIntervalTimespectral
   !
   !      Subroutine arguments.
   !
   !
   !      Local variables.
   !
   !real(kind=realType), dimension(:,:),   pointer :: gamma1, gamma2
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nn=1,nbocos
   CALL PUSHINTEGER4(kbend)
   CALL PUSHINTEGER4(jbend)
   CALL PUSHINTEGER4(ibend)
   CALL PUSHINTEGER4(kbbeg)
   CALL PUSHINTEGER4(jbbeg)
   CALL PUSHINTEGER4(ibbeg)
   CALL PUSHINTEGER4(ksend)
   CALL PUSHINTEGER4(jsend)
   CALL PUSHINTEGER4(isend)
   CALL PUSHINTEGER4(ksbeg)
   CALL PUSHINTEGER4(jsbeg)
   CALL PUSHINTEGER4(isbeg)
   CALL CHECKOVERLAPNKPC(nn, icell, jcell, kcell, isbeg, jsbeg, ksbeg, &
   &                    isend, jsend, ksend, ibbeg, jbbeg, kbbeg, ibend, &
   &                    jbend, kbend, computebc)
   IF (computebc) THEN
   ! Check for symmetry boundary condition.
   IF (bctype(nn) .EQ. symm) THEN
   CALL PUSHBOOLEAN(secondhalo)
   !Copy the states and other parameters to subfaces
   CALL EXTRACTBCSTATESNKPC(nn, wadj, padj, wadj0, wadj1, wadj2, &
   &                           wadj3, padj0, padj1, padj2, padj3, rlvadj, &
   &                           revadj, rlvadj1, rlvadj2, revadj1, revadj2, &
   &                           ioffset, joffset, koffset, icell, jcell, &
   &                           kcell, isbeg, jsbeg, ksbeg, isend, jsend, &
   &                           ksend, ibbeg, jbbeg, kbbeg, ibend, jbend, &
   &                           kbend, icbeg, jcbeg, icend, jcend, &
   &                           secondhalo, nnn, level, sps, sps2)
   ad_from = jcbeg
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO j=ad_from,jcend
   ad_from0 = icbeg
   DO i=ad_from0,icend
   CALL PUSHINTEGER4(ii)
   ii = i - ioffset
   CALL PUSHINTEGER4(jj)
   jj = j - joffset
   CALL PUSHREAL8(nnx)
   ! Store the three components of the unit normal a
   ! bit easier.
   !BCData(nn)%norm(i,j,1)
   nnx = normadj(nn, ii, jj, 1, sps2)
   CALL PUSHREAL8(nny)
   !BCData(nn)%norm(i,j,2)
   nny = normadj(nn, ii, jj, 2, sps2)
   CALL PUSHREAL8(nnz)
   !BCData(nn)%norm(i,j,3)
   nnz = normadj(nn, ii, jj, 3, sps2)
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   ! Determine the flow variables in the halo cell.
   IF (secondhalo) THEN
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from)
   CALL PUSHREAL8ARRAY(wadj, 5**3*nw*ntimeintervalsspectral)
   CALL REPLACEBCSTATESNKPC(nn, wadj0, wadj1, wadj2, wadj3, padj0, &
   &                           padj1, padj2, padj3, rlvadj1, rlvadj2, &
   &                           revadj1, revadj2, icell, jcell, kcell, wadj&
   &                           , padj, rlvadj, revadj, secondhalo, nnn, &
   &                           level, sps, sps2)
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO bocos
   padj0b(-2:2, -2:2) = 0.0
   padj1b(-2:2, -2:2) = 0.0
   padj2b(-2:2, -2:2) = 0.0
   padj3b(-2:2, -2:2) = 0.0
   wadj0b(-2:2, -2:2, 1:nw) = 0.0
   wadj1b(-2:2, -2:2, 1:nw) = 0.0
   wadj2b(-2:2, -2:2, 1:nw) = 0.0
   wadj3b(-2:2, -2:2, 1:nw) = 0.0
   DO nn=nbocos,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 3) THEN
   CALL POPREAL8ARRAY(wadj, 5**3*nw*ntimeintervalsspectral)
   CALL REPLACEBCSTATESNKPC_B(nn, wadj0, wadj0b, wadj1, wadj1b, wadj2&
   &                           , wadj3, padj0, padj0b, padj1, padj1b, padj2&
   &                           , padj3, rlvadj1, rlvadj2, revadj1, revadj2&
   &                           , icell, jcell, kcell, wadj, wadjb, padj, &
   &                           padjb, rlvadj, revadj, secondhalo, nnn, &
   &                           level, sps, sps2)
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO j=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO i=ad_to0,ad_from0,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   padj3b(ii, jj) = padj3b(ii, jj) + padj0b(ii, jj)
   padj0b(ii, jj) = 0.0
   DO l=nt2mg,nt1mg,-1
   wadj3b(ii, jj, l) = wadj3b(ii, jj, l) + wadj1b(ii, jj, l)
   wadj1b(ii, jj, l) = 0.0
   END DO
   wadj3b(ii, jj, irhoe) = wadj3b(ii, jj, irhoe) + wadj0b(ii, &
   &              jj, irhoe)
   wadj0b(ii, jj, irhoe) = 0.0
   wadj3b(ii, jj, ivz) = wadj3b(ii, jj, ivz) + wadj0b(ii, jj, &
   &              ivz)
   vnb = -(nnz*wadj0b(ii, jj, ivz))
   wadj0b(ii, jj, ivz) = 0.0
   wadj3b(ii, jj, ivy) = wadj3b(ii, jj, ivy) + wadj0b(ii, jj, &
   &              ivy)
   vnb = vnb - nny*wadj0b(ii, jj, ivy)
   wadj0b(ii, jj, ivy) = 0.0
   wadj3b(ii, jj, ivx) = wadj3b(ii, jj, ivx) + wadj0b(ii, jj, &
   &              ivx)
   vnb = vnb - nnx*wadj0b(ii, jj, ivx)
   wadj0b(ii, jj, ivx) = 0.0
   wadj3b(ii, jj, irho) = wadj3b(ii, jj, irho) + wadj0b(ii, jj&
   &              , irho)
   wadj0b(ii, jj, irho) = 0.0
   tempb0 = two*vnb
   wadj3b(ii, jj, ivx) = wadj3b(ii, jj, ivx) + nnx*tempb0
   wadj3b(ii, jj, ivy) = wadj3b(ii, jj, ivy) + nny*tempb0
   wadj3b(ii, jj, ivz) = wadj3b(ii, jj, ivz) + nnz*tempb0
   END IF
   padj2b(ii, jj) = padj2b(ii, jj) + padj1b(ii, jj)
   padj1b(ii, jj) = 0.0
   DO l=nt2mg,nt1mg,-1
   wadj2b(ii, jj, l) = wadj2b(ii, jj, l) + wadj1b(ii, jj, l)
   wadj1b(ii, jj, l) = 0.0
   END DO
   wadj2b(ii, jj, irhoe) = wadj2b(ii, jj, irhoe) + wadj1b(ii, jj&
   &            , irhoe)
   wadj1b(ii, jj, irhoe) = 0.0
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) + wadj1b(ii, jj, ivz&
   &            )
   vnb = -(nnz*wadj1b(ii, jj, ivz))
   wadj1b(ii, jj, ivz) = 0.0
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) + wadj1b(ii, jj, ivy&
   &            )
   vnb = vnb - nny*wadj1b(ii, jj, ivy)
   wadj1b(ii, jj, ivy) = 0.0
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) + wadj1b(ii, jj, ivx&
   &            )
   vnb = vnb - nnx*wadj1b(ii, jj, ivx)
   wadj1b(ii, jj, ivx) = 0.0
   wadj2b(ii, jj, irho) = wadj2b(ii, jj, irho) + wadj1b(ii, jj, &
   &            irho)
   wadj1b(ii, jj, irho) = 0.0
   tempb = two*vnb
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) + nnx*tempb
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) + nny*tempb
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) + nnz*tempb
   CALL POPREAL8(nnz)
   CALL POPREAL8(nny)
   CALL POPREAL8(nnx)
   CALL POPINTEGER4(jj)
   CALL POPINTEGER4(ii)
   END DO
   END DO
   CALL POPBOOLEAN(secondhalo)
   CALL EXTRACTBCSTATESNKPC_B(nn, wadj, wadjb, padj, padjb, wadj0, &
   &                           wadj0b, wadj1, wadj1b, wadj2, wadj2b, wadj3&
   &                           , wadj3b, padj0, padj0b, padj1, padj1b, &
   &                           padj2, padj2b, padj3, padj3b, rlvadj, revadj&
   &                           , rlvadj1, rlvadj2, revadj1, revadj2, &
   &                           ioffset, joffset, koffset, icell, jcell, &
   &                           kcell, isbeg, jsbeg, ksbeg, isend, jsend, &
   &                           ksend, ibbeg, jbbeg, kbbeg, ibend, jbend, &
   &                           kbend, icbeg, jcbeg, icend, jcend, &
   &                           secondhalo, nnn, level, sps, sps2)
   END IF
   CALL POPINTEGER4(isbeg)
   CALL POPINTEGER4(jsbeg)
   CALL POPINTEGER4(ksbeg)
   CALL POPINTEGER4(isend)
   CALL POPINTEGER4(jsend)
   CALL POPINTEGER4(ksend)
   CALL POPINTEGER4(ibbeg)
   CALL POPINTEGER4(jbbeg)
   CALL POPINTEGER4(kbbeg)
   CALL POPINTEGER4(ibend)
   CALL POPINTEGER4(jbend)
   CALL POPINTEGER4(kbend)
   END DO
   END SUBROUTINE BCSYMMNKPC_B

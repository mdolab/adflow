   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of bcsymmnkpc in reverse (adjoint) mode:
   !   gradient     of useful results: padj wadj
   !   with respect to varying inputs: padj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcSymmAdj.f90                                   *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 04-17-2008                                      *
   !      * Last modified: 04-17-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCSYMMNKPC_B(wadj, wadjb, padj, padjb, normadj, icell, jcell&
   &  , kcell, secondhalo, nnn, level, sps, sps2)
   USE BLOCKPOINTERS, ONLY : ie, ib, il, je, jb, jl, ke, kb, kl, nbocos&
   &  , gamma, bcfaceid, bctype, bcdata
   USE INPUTTIMESPECTRAL
   USE BCTYPES
   USE CONSTANTS
   USE ITERATION
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcSymmAdj applies the symmetry boundary conditions to a single *
   !      * cell stencil.
   !      * It is assumed that the pointers in blockPointers are already   *
   !      * set to the correct block on the correct grid level.            *
   !      *                                                                *
   !      * In case also the second halo must be set the loop over the     *
   !      * boundary subfaces is executed twice. This is the only correct  *
   !      * way in case the block contains only 1 cell between two         *
   !      * symmetry planes, i.e. a 2D problem.                            *
   !      *                                                                *
   !      ******************************************************************
   !
   !nw
   !nt1mg,nt2mg
   !nIntervalTimespectral
   !
   !      Subroutine arguments.
   !
   LOGICAL :: secondhalo
   INTEGER(kind=inttype) :: nnn, level, sps, sps2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral) :: wadjb
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral) :: padjb
   REAL(kind=realtype), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: normadj
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: kk, mm, nn, i, j, l, ii, jj
   REAL(kind=realtype) :: vn, nnx, nny, nnz
   REAL(kind=realtype) :: vnb
   !real(kind=realType), dimension(:,:),   pointer :: gamma1, gamma2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: gamma1, gamma2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj0, wadj1
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj0b, wadj1b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj2, wadj3
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, nw) :: wadj2b, wadj3b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj0, padj1
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj0b, padj1b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj2, padj3
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: padj2b, padj3b
   REAL(kind=realtype), DIMENSION(-2:2, -2:2, -2:2) :: rlvadj, revadj
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: rlvadj1, rlvadj2
   REAL(kind=realtype), DIMENSION(-2:2, -2:2) :: revadj1, revadj2
   INTEGER(kind=inttype) :: icell, jcell, kcell
   INTEGER(kind=inttype) :: isbeg, jsbeg, ksbeg, isend, jsend, ksend
   INTEGER(kind=inttype) :: ibbeg, jbbeg, kbbeg, ibend, jbend, kbend
   INTEGER(kind=inttype) :: icbeg, jcbeg, kcbeg, icend, jcend, kcend
   INTEGER(kind=inttype) :: ioffset, joffset, koffset
   LOGICAL :: computebc
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nn=1,nbocos
   CALL PUSHINTEGER4ARRAY(kbend, inttype/4)
   CALL PUSHINTEGER4ARRAY(jbend, inttype/4)
   CALL PUSHINTEGER4ARRAY(ibend, inttype/4)
   CALL PUSHINTEGER4ARRAY(kbbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(jbbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(ibbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(ksend, inttype/4)
   CALL PUSHINTEGER4ARRAY(jsend, inttype/4)
   CALL PUSHINTEGER4ARRAY(isend, inttype/4)
   CALL PUSHINTEGER4ARRAY(ksbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(jsbeg, inttype/4)
   CALL PUSHINTEGER4ARRAY(isbeg, inttype/4)
   CALL CHECKOVERLAPNKPC(nn, icell, jcell, kcell, isbeg, jsbeg, &
   &                       ksbeg, isend, jsend, ksend, ibbeg, jbbeg, kbbeg, &
   &                       ibend, jbend, kbend, computebc)
   IF (computebc) THEN
   ! Check for symmetry boundary condition.
   IF (bctype(nn) .EQ. symm) THEN
   CALL PUSHBOOLEAN(secondhalo)
   !Copy the states and other parameters to subfaces
   CALL EXTRACTBCSTATESNKPC(nn, wadj, padj, wadj0, wadj1, wadj2&
   &                              , wadj3, padj0, padj1, padj2, padj3, &
   &                              rlvadj, revadj, rlvadj1, rlvadj2, revadj1&
   &                              , revadj2, ioffset, joffset, koffset, &
   &                              icell, jcell, kcell, isbeg, jsbeg, ksbeg, &
   &                              isend, jsend, ksend, ibbeg, jbbeg, kbbeg, &
   &                              ibend, jbend, kbend, icbeg, jcbeg, icend, &
   &                              jcend, secondhalo, nnn, level, sps, sps2)
   ad_from = jcbeg
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO j=ad_from,jcend
   ad_from0 = icbeg
   DO i=ad_from0,icend
   CALL PUSHINTEGER4ARRAY(ii, inttype/4)
   ii = i - ioffset
   CALL PUSHINTEGER4ARRAY(jj, inttype/4)
   jj = j - joffset
   CALL PUSHREAL8ARRAY(nnx, realtype/8)
   ! Store the three components of the unit normal a
   ! bit easier.
   !BCData(nn)%norm(i,j,1)
   nnx = normadj(nn, ii, jj, 1, sps2)
   CALL PUSHREAL8ARRAY(nny, realtype/8)
   !BCData(nn)%norm(i,j,2)
   nny = normadj(nn, ii, jj, 2, sps2)
   CALL PUSHREAL8ARRAY(nnz, realtype/8)
   !BCData(nn)%norm(i,j,3)
   nnz = normadj(nn, ii, jj, 3, sps2)
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vn = two*(wadj2(ii, jj, ivx)*nnx+wadj2(ii, jj, ivy)*nny+&
   &              wadj2(ii, jj, ivz)*nnz)
   ! Determine the flow variables in the halo cell.
   wadj1(ii, jj, irho) = wadj2(ii, jj, irho)
   wadj1(ii, jj, ivx) = wadj2(ii, jj, ivx) - vn*nnx
   wadj1(ii, jj, ivy) = wadj2(ii, jj, ivy) - vn*nny
   wadj1(ii, jj, ivz) = wadj2(ii, jj, ivz) - vn*nnz
   wadj1(ii, jj, irhoe) = wadj2(ii, jj, irhoe)
   ! Simply copy the turbulent variables.
   DO l=nt1mg,nt2mg
   wadj1(ii, jj, l) = wadj2(ii, jj, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   padj1(ii, jj) = padj2(ii, jj)
   IF (viscous) rlvadj1(ii, jj) = rlvadj2(ii, jj)
   IF (eddymodel) revadj1(ii, jj) = revadj2(ii, jj)
   IF (secondhalo) THEN
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vn = two*(wadj3(ii, jj, ivx)*nnx+wadj3(ii, jj, ivy)*nny+&
   &                wadj3(ii, jj, ivz)*nnz)
   ! Determine the flow variables in the halo cell.
   wadj0(ii, jj, irho) = wadj3(ii, jj, irho)
   wadj0(ii, jj, ivx) = wadj3(ii, jj, ivx) - vn*nnx
   wadj0(ii, jj, ivy) = wadj3(ii, jj, ivy) - vn*nny
   wadj0(ii, jj, ivz) = wadj3(ii, jj, ivz) - vn*nnz
   wadj0(ii, jj, irhoe) = wadj3(ii, jj, irhoe)
   ! Simply copy the turbulent variables.
   DO l=nt1mg,nt2mg
   wadj1(ii, jj, l) = wadj3(ii, jj, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   padj0(ii, jj) = padj3(ii, jj)
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO
   CALL PUSHINTEGER4ARRAY(i - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4ARRAY(j - 1, inttype/4)
   CALL PUSHINTEGER4(ad_from)
   CALL PUSHREAL8ARRAY(wadj, realtype*5**3*nw*&
   &                      ntimeintervalsspectral/8)
   CALL REPLACEBCSTATESNKPC(nn, wadj0, wadj1, wadj2, wadj3, &
   &                              padj0, padj1, padj2, padj3, rlvadj1, &
   &                              rlvadj2, revadj1, revadj2, icell, jcell, &
   &                              kcell, wadj, padj, rlvadj, revadj, &
   &                              secondhalo, nnn, level, sps, sps2)
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO bocos
   padj0b = 0.0
   padj1b = 0.0
   padj2b = 0.0
   padj3b = 0.0
   wadj0b = 0.0
   wadj1b = 0.0
   wadj2b = 0.0
   wadj3b = 0.0
   DO nn=nbocos,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 3) THEN
   CALL POPREAL8ARRAY(wadj, realtype*5**3*nw*ntimeintervalsspectral/8&
   &                  )
   CALL REPLACEBCSTATESNKPC_B(nn, wadj0, wadj0b, wadj1, wadj1b, wadj2&
   &                           , wadj3, padj0, padj0b, padj1, padj1b, padj2&
   &                           , padj3, rlvadj1, rlvadj2, revadj1, revadj2, &
   &                           icell, jcell, kcell, wadj, wadjb, padj, padjb&
   &                           , rlvadj, revadj, secondhalo, nnn, level, sps&
   &                           , sps2)
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO j=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO i=ad_to0,ad_from0,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   padj3b(ii, jj) = padj3b(ii, jj) + padj0b(ii, jj)
   padj0b(ii, jj) = 0.0
   DO l=nt2mg,nt1mg,-1
   wadj3b(ii, jj, l) = wadj3b(ii, jj, l) + wadj1b(ii, jj, l)
   wadj1b(ii, jj, l) = 0.0
   END DO
   wadj3b(ii, jj, irhoe) = wadj3b(ii, jj, irhoe) + wadj0b(ii, &
   &              jj, irhoe)
   wadj0b(ii, jj, irhoe) = 0.0
   wadj3b(ii, jj, ivz) = wadj3b(ii, jj, ivz) + wadj0b(ii, jj, &
   &              ivz)
   vnb = -(nnz*wadj0b(ii, jj, ivz))
   wadj0b(ii, jj, ivz) = 0.0
   wadj3b(ii, jj, ivy) = wadj3b(ii, jj, ivy) + wadj0b(ii, jj, &
   &              ivy)
   vnb = vnb - nny*wadj0b(ii, jj, ivy)
   wadj0b(ii, jj, ivy) = 0.0
   wadj3b(ii, jj, ivx) = wadj3b(ii, jj, ivx) + wadj0b(ii, jj, &
   &              ivx)
   vnb = vnb - nnx*wadj0b(ii, jj, ivx)
   wadj0b(ii, jj, ivx) = 0.0
   wadj3b(ii, jj, irho) = wadj3b(ii, jj, irho) + wadj0b(ii, jj&
   &              , irho)
   wadj0b(ii, jj, irho) = 0.0
   tempb0 = two*vnb
   wadj3b(ii, jj, ivx) = wadj3b(ii, jj, ivx) + nnx*tempb0
   wadj3b(ii, jj, ivy) = wadj3b(ii, jj, ivy) + nny*tempb0
   wadj3b(ii, jj, ivz) = wadj3b(ii, jj, ivz) + nnz*tempb0
   END IF
   padj2b(ii, jj) = padj2b(ii, jj) + padj1b(ii, jj)
   padj1b(ii, jj) = 0.0
   DO l=nt2mg,nt1mg,-1
   wadj2b(ii, jj, l) = wadj2b(ii, jj, l) + wadj1b(ii, jj, l)
   wadj1b(ii, jj, l) = 0.0
   END DO
   wadj2b(ii, jj, irhoe) = wadj2b(ii, jj, irhoe) + wadj1b(ii, jj&
   &            , irhoe)
   wadj1b(ii, jj, irhoe) = 0.0
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) + wadj1b(ii, jj, ivz&
   &            )
   vnb = -(nnz*wadj1b(ii, jj, ivz))
   wadj1b(ii, jj, ivz) = 0.0
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) + wadj1b(ii, jj, ivy&
   &            )
   vnb = vnb - nny*wadj1b(ii, jj, ivy)
   wadj1b(ii, jj, ivy) = 0.0
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) + wadj1b(ii, jj, ivx&
   &            )
   vnb = vnb - nnx*wadj1b(ii, jj, ivx)
   wadj1b(ii, jj, ivx) = 0.0
   wadj2b(ii, jj, irho) = wadj2b(ii, jj, irho) + wadj1b(ii, jj, &
   &            irho)
   wadj1b(ii, jj, irho) = 0.0
   tempb = two*vnb
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) + nnx*tempb
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) + nny*tempb
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) + nnz*tempb
   CALL POPREAL8ARRAY(nnz, realtype/8)
   CALL POPREAL8ARRAY(nny, realtype/8)
   CALL POPREAL8ARRAY(nnx, realtype/8)
   CALL POPINTEGER4ARRAY(jj, inttype/4)
   CALL POPINTEGER4ARRAY(ii, inttype/4)
   END DO
   END DO
   CALL POPBOOLEAN(secondhalo)
   CALL EXTRACTBCSTATESNKPC_B(nn, wadj, wadjb, padj, padjb, wadj0, &
   &                           wadj0b, wadj1, wadj1b, wadj2, wadj2b, wadj3, &
   &                           wadj3b, padj0, padj0b, padj1, padj1b, padj2, &
   &                           padj2b, padj3, padj3b, rlvadj, revadj, &
   &                           rlvadj1, rlvadj2, revadj1, revadj2, ioffset, &
   &                           joffset, koffset, icell, jcell, kcell, isbeg&
   &                           , jsbeg, ksbeg, isend, jsend, ksend, ibbeg, &
   &                           jbbeg, kbbeg, ibend, jbend, kbend, icbeg, &
   &                           jcbeg, icend, jcend, secondhalo, nnn, level, &
   &                           sps, sps2)
   END IF
   CALL POPINTEGER4ARRAY(isbeg, inttype/4)
   CALL POPINTEGER4ARRAY(jsbeg, inttype/4)
   CALL POPINTEGER4ARRAY(ksbeg, inttype/4)
   CALL POPINTEGER4ARRAY(isend, inttype/4)
   CALL POPINTEGER4ARRAY(jsend, inttype/4)
   CALL POPINTEGER4ARRAY(ksend, inttype/4)
   CALL POPINTEGER4ARRAY(ibbeg, inttype/4)
   CALL POPINTEGER4ARRAY(jbbeg, inttype/4)
   CALL POPINTEGER4ARRAY(kbbeg, inttype/4)
   CALL POPINTEGER4ARRAY(ibend, inttype/4)
   CALL POPINTEGER4ARRAY(jbend, inttype/4)
   CALL POPINTEGER4ARRAY(kbend, inttype/4)
   END DO
   END SUBROUTINE BCSYMMNKPC_B

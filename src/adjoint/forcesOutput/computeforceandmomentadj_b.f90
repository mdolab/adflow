   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.3 (r3163) - 09/25/2009 09:03
   !
   !  Differentiation of computeforceandmomentadj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: pointrefadj moment
   !                wblock lengthrefadj lift surfacerefadj cforce
   !                alphaadj pts betaadj drag force cd cl machcoefadj
   !                cmoment
   !   of linear combination of output variables: moment lift cforce
   !                drag force cd cl cmoment
   SUBROUTINE COMPUTEFORCEANDMOMENTADJ_B(force, forceb, cforce, cforceb, &
   &  lift, liftb, drag, dragb, cl, clb, cd, cdb, moment, momentb, cmoment, &
   &  cmomentb, alphaadj, alphaadjb, betaadj, betaadjb, liftindex, &
   &  machcoefadj, machcoefadjb, pointrefadj, pointrefadjb, lengthrefadj, &
   &  lengthrefadjb, surfacerefadj, surfacerefadjb, pts, ptsb, npts, wblock&
   &  , wblockb, righthandedadj, faceid, ibeg, iend, jbeg, jend, ii_start, &
   &  sps)
   USE BLOCKPOINTERS
   USE SECTION
   USE INPUTTIMESPECTRAL
   USE INPUTTSSTABDERIV
   USE BCTYPES
   USE INPUTPHYSICS
   USE INPUTDISCRETIZATION
   USE INPUTMOTION
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !     ******************************************************************
   !     *                                                                *
   !     * Compute the sum of the forces and moments on all blocks on     *
   !     * this processor. This function can be AD'd                      *
   !     *                                                                *
   !     ******************************************************************
   !
   ! equations
   ! nw
   ! spaceDiscr, useCompactDiss
   !imin,imax,jmin,jmax,kmin,kmax
   !TSStability
   !nTimeIntervalsSpectral
   !degreePol etc...
   !TimeunsteadyRestart
   !nSections
   !myID
   ! Subroutine Arguments
   ! Output
   REAL(kind=realtype) :: force(3), cforce(3)
   REAL(kind=realtype) :: forceb(3), cforceb(3)
   REAL(kind=realtype) :: lift, drag, cl, cd
   REAL(kind=realtype) :: liftb, dragb, clb, cdb
   REAL(kind=realtype) :: moment(3), cmoment(3)
   REAL(kind=realtype) :: momentb(3), cmomentb(3)
   ! Input
   REAL(kind=realtype), INTENT(IN) :: alphaadj, betaadj
   REAL(kind=realtype) :: alphaadjb, betaadjb
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   REAL(kind=realtype), INTENT(IN) :: machcoefadj
   REAL(kind=realtype) :: machcoefadjb
   REAL(kind=realtype), INTENT(IN) :: pointrefadj(3)
   REAL(kind=realtype) :: pointrefadjb(3)
   REAL(kind=realtype), INTENT(IN) :: lengthrefadj, surfacerefadj
   REAL(kind=realtype) :: lengthrefadjb, surfacerefadjb
   INTEGER(kind=inttype), INTENT(IN) :: npts
   REAL(kind=realtype), INTENT(IN) :: pts(3, npts)
   REAL(kind=realtype) :: ptsb(3, npts)
   REAL(kind=realtype), INTENT(IN) :: wblock(0:ib, 0:jb, 0:kb, nw)
   REAL(kind=realtype) :: wblockb(0:ib, 0:jb, 0:kb, nw)
   LOGICAL, INTENT(IN) :: righthandedadj
   INTEGER(kind=inttype), INTENT(IN) :: faceid
   INTEGER(kind=inttype), INTENT(IN) :: ibeg, iend, jbeg, jend, ii_start&
   &  , sps
   ! Local Variables
   INTEGER(kind=inttype) :: ii
   REAL(kind=realtype) :: addforce(3), addmoment(3), refpoint(3)
   REAL(kind=realtype) :: addforceb(3), addmomentb(3)
   REAL(kind=realtype) :: liftdir(3), dragdir(3), freestreamdir(3)
   REAL(kind=realtype) :: liftdirb(3), dragdirb(3)
   REAL(kind=realtype) :: grid_pts(3, 3, 3), wadj(2, 2, 2, nw)
   REAL(kind=realtype) :: grid_ptsb(3, 3, 3), wadjb(2, 2, 2, nw)
   INTEGER(kind=inttype) :: istride, jstride, i, j
   INTEGER(kind=inttype) :: iii, jjj, kkk
   INTEGER(kind=inttype) :: lower_left, lower_right, upper_left, &
   &  upper_right
   REAL(kind=realtype) :: fact
   REAL(kind=realtype) :: factb
   REAL(kind=realtype) :: veldirfreestreamadj(3)
   !TS variables
   REAL(kind=realtype), DIMENSION(nsections) :: t
   INTEGER(kind=inttype) :: nn
   REAL(kind=realtype) :: liftdirtmp(3), dragdirtmp(3)
   REAL(kind=realtype) :: liftdirtmpb(3), dragdirtmpb(3)
   REAL(kind=realtype) :: tnew, told
   REAL(kind=realtype) :: alphats, alphaincrement, betats, betaincrement
   REAL(kind=realtype) :: alphatsb, betatsb
   !Rotation variables
   REAL(kind=realtype), DIMENSION(3) :: rotationpoint
   REAL(kind=realtype), DIMENSION(3, 3) :: rotationmatrix, &
   &  derivrotationmatrix
   !Function Definitions
   REAL(kind=realtype) :: TSALPHA, TSBETA
   INTEGER :: branch
   REAL(kind=realtype) :: temp0
   REAL :: timeunsteady
   INTEGER :: myid
   REAL(kind=realtype) :: tempb
   REAL :: timeunsteadyrestart
   REAL(kind=realtype) :: temp1b
   REAL(kind=realtype) :: temp
   ! Only need to zero force and moment -> these are summed again
   force = 0.0
   moment = 0.0
   istride = iend - ibeg + 1
   ii = ii_start
   DO j=jbeg,jend
   DO i=ibeg,iend
   CALL PUSHREAL8ARRAY(grid_pts, realtype*3**3/8)
   grid_pts(:, :, :) = 0.0
   CALL PUSHREAL8ARRAY(wadj, realtype*2**3*nw/8)
   wadj(:, :, :, :) = 0.0
   DO iii=1,2
   DO jjj=1,2
   CALL PUSHINTEGER4ARRAY(lower_left, inttype/4)
   lower_left = ii + iii + (jjj-1)*istride - istride - 1
   CALL PUSHINTEGER4ARRAY(lower_right, inttype/4)
   lower_right = ii + iii + (jjj-1)*istride - istride
   CALL PUSHINTEGER4ARRAY(upper_left, inttype/4)
   upper_left = ii + iii + jjj*istride - istride - 1
   CALL PUSHINTEGER4ARRAY(upper_right, inttype/4)
   upper_right = ii + iii + jjj*istride - istride
   IF (lower_left .GT. 0 .AND. lower_left .LE. npts) THEN
   grid_pts(:, iii, jjj) = pts(:, lower_left)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (lower_right .GT. 0 .AND. lower_right .LE. npts) THEN
   grid_pts(:, iii+1, jjj) = pts(:, lower_right)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (upper_left .GT. 0 .AND. upper_left .LE. npts) THEN
   grid_pts(:, iii, jjj+1) = pts(:, upper_left)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (upper_right .GT. 0 .AND. upper_right .LE. npts) THEN
   grid_pts(:, iii+1, jjj+1) = pts(:, upper_right)
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO
   END DO
   !Copy over the states
   SELECT CASE  (faceid) 
   CASE (imin) 
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = -1_realType
   DO kkk=1,2
   wadj(kkk, 1, 1, :) = wblock(kkk+1, i, j, :)
   wadj(kkk, 2, 1, :) = wblock(kkk+1, i+1, j, :)
   wadj(kkk, 1, 2, :) = wblock(kkk+1, i, j+1, :)
   wadj(kkk, 2, 2, :) = wblock(kkk+1, i+1, j+1, :)
   END DO
   CALL PUSHINTEGER4(1)
   CASE (imax) 
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = 1_realType
   DO kkk=1,2
   wadj(kkk, 1, 1, :) = wblock(ib-kkk-1, i, j, :)
   wadj(kkk, 2, 1, :) = wblock(ib-kkk-1, i+1, j, :)
   wadj(kkk, 1, 2, :) = wblock(ib-kkk-1, i, j+1, :)
   wadj(kkk, 2, 2, :) = wblock(ib-kkk-1, i+1, j+1, :)
   END DO
   CALL PUSHINTEGER4(2)
   CASE (jmin) 
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = 1_realType
   DO kkk=1,2
   wadj(kkk, 1, 1, :) = wblock(i, kkk+1, j, :)
   wadj(kkk, 2, 1, :) = wblock(i+1, kkk+1, j, :)
   wadj(kkk, 1, 2, :) = wblock(i, kkk+1, j+1, :)
   wadj(kkk, 2, 2, :) = wblock(i+1, kkk+1, j+1, :)
   END DO
   CALL PUSHINTEGER4(3)
   CASE (jmax) 
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = -1_realType
   DO kkk=1,2
   wadj(kkk, 1, 1, :) = wblock(i, jb-kkk-1, j, :)
   wadj(kkk, 2, 1, :) = wblock(i+1, jb-kkk-1, j, :)
   wadj(kkk, 1, 2, :) = wblock(i, jb-kkk-1, j+1, :)
   wadj(kkk, 2, 2, :) = wblock(i+1, jb-kkk-1, j+1, :)
   END DO
   CALL PUSHINTEGER4(4)
   CASE (kmin) 
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = -1_realType
   DO kkk=1,2
   wadj(kkk, 1, 1, :) = wblock(i, j, kkk+1, :)
   wadj(kkk, 2, 1, :) = wblock(i+1, j, kkk+1, :)
   wadj(kkk, 1, 2, :) = wblock(i, j+1, kkk+1, :)
   wadj(kkk, 2, 2, :) = wblock(i+1, j+1, kkk+1, :)
   END DO
   CALL PUSHINTEGER4(5)
   CASE (kmax) 
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   fact = 1_realType
   DO kkk=1,2
   wadj(kkk, 1, 1, :) = wblock(i, j, kb-kkk-1, :)
   wadj(kkk, 2, 1, :) = wblock(i+1, j, kb-kkk-1, :)
   wadj(kkk, 1, 2, :) = wblock(i, j+1, kb-kkk-1, :)
   wadj(kkk, 2, 2, :) = wblock(i+1, j+1, kb-kkk-1, :)
   END DO
   CALL PUSHINTEGER4(6)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   CALL COMPUTEFORCESADJ(addforce, addmoment, grid_pts, wadj, &
   &                         pointrefadj, fact, ibeg, iend, jbeg, jend, i, j&
   &                         , righthandedadj)
   ii = ii + 1
   force = force + addforce
   moment = moment + addmoment
   END DO
   END DO
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   ! Now we know the sum of the force and moment contribution from this block
   ! First get cForce -> Coefficient of FOrce
   fact = two/(gammainf*pinf*pref*machcoefadj*machcoefadj*surfacerefadj*&
   &    lref*lref)
   !fact = two/(gammaInf*pInf*pRef*MachCoefAdj*MachCoefAdj*surfaceRef*LRef*LRef)
   ! To get Lift,Drag,Cl and Cd get lift and drag directions
   !if(myID==0) print *,'liftindex sub1',liftindex
   CALL ADJUSTINFLOWANGLEFORCESADJ(alphaadj, betaadj, &
   &                               veldirfreestreamadj, liftdir, dragdir, &
   &                               liftindex)
   !This computation is time dependent for TSStability so update for time instance
   IF (tsstability) THEN
   !update the lift vector and drag vector to account for changing 
   !angles of attack
   ! compute the time of this interval
   t = timeunsteadyrestart
   IF (equationmode .EQ. timespectral) THEN
   DO nn=1,nsections
   t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/&
   &          ntimeintervalsspectral*1.0
   END DO
   END IF
   ! Determine the time values of the old and new time level.
   ! It is assumed that the rigid body rotation of the mesh is only
   ! used when only 1 section is present.
   tnew = timeunsteady + timeunsteadyrestart
   told = tnew - t(1)
   IF ((tspmode .OR. tsqmode) .OR. tsrmode) THEN
   ! Compute the rotation matrix of the rigid body rotation as
   ! well as the rotation point; the latter may vary in time due
   ! to rigid body translation.
   CALL ROTMATRIXRIGIDBODY(tnew, told, rotationmatrix, &
   &                           rotationpoint)
   liftdirtmp(1) = rotationmatrix(1, 1)*liftdir(1) + rotationmatrix(1&
   &        , 2)*liftdir(2) + rotationmatrix(1, 3)*liftdir(3)
   liftdirtmp(2) = rotationmatrix(2, 1)*liftdir(1) + rotationmatrix(2&
   &        , 2)*liftdir(2) + rotationmatrix(2, 3)*liftdir(3)
   liftdirtmp(3) = rotationmatrix(3, 1)*liftdir(1) + rotationmatrix(3&
   &        , 2)*liftdir(2) + rotationmatrix(3, 3)*liftdir(3)
   dragdirtmp(1) = rotationmatrix(1, 1)*dragdir(1) + rotationmatrix(1&
   &        , 2)*dragdir(2) + rotationmatrix(1, 3)*dragdir(3)
   dragdirtmp(2) = rotationmatrix(2, 1)*dragdir(1) + rotationmatrix(2&
   &        , 2)*dragdir(2) + rotationmatrix(2, 3)*dragdir(3)
   dragdirtmp(3) = rotationmatrix(3, 1)*dragdir(1) + rotationmatrix(3&
   &        , 2)*dragdir(2) + rotationmatrix(3, 3)*dragdir(3)
   liftdir = liftdirtmp
   dragdir = dragdirtmp
   CALL PUSHINTEGER4(1)
   ELSE IF (tsalphamode) THEN
   !Determine the alpha for this time instance
   alphaincrement = TSALPHA(degreepolalpha, coefpolalpha, &
   &        degreefouralpha, omegafouralpha, coscoeffouralpha, &
   &        sincoeffouralpha, t(1))
   alphats = alphaadj + alphaincrement
   !Determine the grid velocity for this alpha
   !if(myID==0) print *,'liftindex sub2',liftindex
   CALL ADJUSTINFLOWANGLEFORCESADJ(alphats, betaadj, &
   &                                   veldirfreestreamadj, liftdir, dragdir&
   &                                   , liftindex)
   !do I need to update the lift direction and drag direction as well? yes!!!
   CALL PUSHINTEGER4(2)
   ELSE IF (tsbetamode) THEN
   !Determine the alpha for this time instance
   betaincrement = TSBETA(degreepolbeta, coefpolbeta, &
   &        degreefourbeta, omegafourbeta, coscoeffourbeta, sincoeffourbeta&
   &        , t(1))
   betats = betaadj + betaincrement
   IF (myid .EQ. 0) PRINT*, 'liftindex sub3', liftindex
   !Determine the grid velocity for this alpha
   CALL ADJUSTINFLOWANGLEFORCESADJ(alphaadj, betats, &
   &                                   veldirfreestreamadj, liftdir, dragdir&
   &                                   , liftindex)
   CALL PUSHINTEGER4(4)
   ELSE
   CALL PUSHINTEGER4(3)
   END IF
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Take Dot Products ... this won't AD properly so we will write explictly
   !Lift = dot_product(Force,liftDir)
   !Drag = dot_product(Force,dragDir)
   lift = force(1)*liftdir(1) + force(2)*liftdir(2) + force(3)*liftdir(3)
   drag = force(1)*dragdir(1) + force(2)*dragdir(2) + force(3)*dragdir(3)
   CALL PUSHREAL8ARRAY(fact, realtype/8)
   ! Update fact for moment normalization
   fact = fact/(lengthrefadj*lref)
   !fact = fact/(lengthRef*LRef)
   momentb = momentb + fact*cmomentb
   factb = SUM(moment*cmomentb)
   CALL POPREAL8ARRAY(fact, realtype/8)
   temp1b = factb/(lref*lengthrefadj)
   lengthrefadjb = -(fact*temp1b/lengthrefadj)
   factb = drag*cdb + lift*clb + temp1b
   dragb = dragb + fact*cdb
   liftb = liftb + fact*clb
   dragdirb = 0.0
   forceb(1) = forceb(1) + dragdir(1)*dragb
   dragdirb(1) = force(1)*dragb
   forceb(2) = forceb(2) + dragdir(2)*dragb
   dragdirb(2) = force(2)*dragb
   forceb(3) = forceb(3) + dragdir(3)*dragb
   dragdirb(3) = force(3)*dragb
   liftdirb = 0.0
   forceb(1) = forceb(1) + liftdir(1)*liftb
   liftdirb(1) = force(1)*liftb
   forceb(2) = forceb(2) + liftdir(2)*liftb
   liftdirb(2) = force(2)*liftb
   forceb(3) = forceb(3) + liftdir(3)*liftb
   liftdirb(3) = force(3)*liftb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 3) THEN
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   alphaadjb = 0.0
   betaadjb = 0.0
   ELSE
   dragdirtmpb = 0.0
   dragdirtmpb = dragdirb
   liftdirtmpb = 0.0
   liftdirtmpb = liftdirb
   dragdirb = 0.0
   dragdirb(1) = rotationmatrix(3, 1)*dragdirtmpb(3)
   dragdirb(2) = rotationmatrix(3, 2)*dragdirtmpb(3)
   dragdirb(3) = rotationmatrix(3, 3)*dragdirtmpb(3)
   dragdirtmpb(3) = 0.0
   dragdirb(1) = dragdirb(1) + rotationmatrix(2, 1)*dragdirtmpb(2)
   dragdirb(2) = dragdirb(2) + rotationmatrix(2, 2)*dragdirtmpb(2)
   dragdirb(3) = dragdirb(3) + rotationmatrix(2, 3)*dragdirtmpb(2)
   dragdirtmpb(2) = 0.0
   dragdirb(1) = dragdirb(1) + rotationmatrix(1, 1)*dragdirtmpb(1)
   dragdirb(2) = dragdirb(2) + rotationmatrix(1, 2)*dragdirtmpb(1)
   dragdirb(3) = dragdirb(3) + rotationmatrix(1, 3)*dragdirtmpb(1)
   liftdirb = 0.0
   liftdirb(1) = rotationmatrix(3, 1)*liftdirtmpb(3)
   liftdirb(2) = rotationmatrix(3, 2)*liftdirtmpb(3)
   liftdirb(3) = rotationmatrix(3, 3)*liftdirtmpb(3)
   liftdirtmpb(3) = 0.0
   liftdirb(1) = liftdirb(1) + rotationmatrix(2, 1)*liftdirtmpb(2)
   liftdirb(2) = liftdirb(2) + rotationmatrix(2, 2)*liftdirtmpb(2)
   liftdirb(3) = liftdirb(3) + rotationmatrix(2, 3)*liftdirtmpb(2)
   liftdirtmpb(2) = 0.0
   liftdirb(1) = liftdirb(1) + rotationmatrix(1, 1)*liftdirtmpb(1)
   liftdirb(2) = liftdirb(2) + rotationmatrix(1, 2)*liftdirtmpb(1)
   liftdirb(3) = liftdirb(3) + rotationmatrix(1, 3)*liftdirtmpb(1)
   alphaadjb = 0.0
   betaadjb = 0.0
   END IF
   ELSE
   alphatsb = 0.0
   betaadjb = 0.0
   CALL ADJUSTINFLOWANGLEFORCESADJ_B(alphats, alphatsb, betaadj, &
   &                                  betaadjb, veldirfreestreamadj, liftdir&
   &                                  , liftdirb, dragdir, dragdirb, &
   &                                  liftindex)
   alphaadjb = alphatsb
   END IF
   ELSE IF (branch .LT. 4) THEN
   alphaadjb = 0.0
   betaadjb = 0.0
   ELSE
   alphaadjb = 0.0
   betatsb = 0.0
   CALL ADJUSTINFLOWANGLEFORCESADJ_B(alphaadj, alphaadjb, betats, &
   &                                betatsb, veldirfreestreamadj, liftdir, &
   &                                liftdirb, dragdir, dragdirb, liftindex)
   betaadjb = betatsb
   END IF
   CALL ADJUSTINFLOWANGLEFORCESADJ_B(alphaadj, alphaadjb, betaadj, &
   &                              betaadjb, veldirfreestreamadj, liftdir, &
   &                              liftdirb, dragdir, dragdirb, liftindex)
   factb = factb + SUM(force*cforceb)
   forceb = forceb + fact*cforceb
   CALL POPREAL8ARRAY(fact, realtype/8)
   temp0 = gammainf*pinf*pref*lref**2
   temp = temp0*machcoefadj**2*surfacerefadj
   tempb = -(two*temp0*factb/temp**2)
   machcoefadjb = surfacerefadj*2*machcoefadj*tempb
   surfacerefadjb = machcoefadj**2*tempb
   pointrefadjb = 0.0
   wblockb = 0.0
   ptsb = 0.0
   addforceb = 0.0
   DO j=jend,jbeg,-1
   DO i=iend,ibeg,-1
   addmomentb = 0.0
   addmomentb = momentb
   addforceb = addforceb + forceb
   CALL COMPUTEFORCESADJ_B(addforce, addforceb, addmoment, addmomentb&
   &                        , grid_pts, grid_ptsb, wadj, wadjb, pointrefadj&
   &                        , pointrefadjb, fact, ibeg, iend, jbeg, jend, i&
   &                        , j, righthandedadj)
   addforceb = 0.0
   CALL POPINTEGER4(branch)
   IF (branch .LT. 4) THEN
   IF (branch .LT. 2) THEN
   IF (.NOT.branch .LT. 1) THEN
   DO kkk=2,1,-1
   wblockb(kkk+1, i+1, j+1, :) = wblockb(kkk+1, i+1, j+1, :) &
   &                + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   wblockb(kkk+1, i, j+1, :) = wblockb(kkk+1, i, j+1, :) + &
   &                wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   wblockb(kkk+1, i+1, j, :) = wblockb(kkk+1, i+1, j, :) + &
   &                wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   wblockb(kkk+1, i, j, :) = wblockb(kkk+1, i, j, :) + wadjb(&
   &                kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8ARRAY(fact, realtype/8)
   END IF
   ELSE IF (branch .LT. 3) THEN
   DO kkk=2,1,-1
   wblockb(ib-kkk-1, i+1, j+1, :) = wblockb(ib-kkk-1, i+1, j+1&
   &              , :) + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   wblockb(ib-kkk-1, i, j+1, :) = wblockb(ib-kkk-1, i, j+1, :) &
   &              + wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   wblockb(ib-kkk-1, i+1, j, :) = wblockb(ib-kkk-1, i+1, j, :) &
   &              + wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   wblockb(ib-kkk-1, i, j, :) = wblockb(ib-kkk-1, i, j, :) + &
   &              wadjb(kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8ARRAY(fact, realtype/8)
   ELSE
   DO kkk=2,1,-1
   wblockb(i+1, kkk+1, j+1, :) = wblockb(i+1, kkk+1, j+1, :) + &
   &              wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   wblockb(i, kkk+1, j+1, :) = wblockb(i, kkk+1, j+1, :) + &
   &              wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   wblockb(i+1, kkk+1, j, :) = wblockb(i+1, kkk+1, j, :) + &
   &              wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   wblockb(i, kkk+1, j, :) = wblockb(i, kkk+1, j, :) + wadjb(&
   &              kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8ARRAY(fact, realtype/8)
   END IF
   ELSE IF (branch .LT. 6) THEN
   IF (branch .LT. 5) THEN
   DO kkk=2,1,-1
   wblockb(i+1, jb-kkk-1, j+1, :) = wblockb(i+1, jb-kkk-1, j+1&
   &              , :) + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   wblockb(i, jb-kkk-1, j+1, :) = wblockb(i, jb-kkk-1, j+1, :) &
   &              + wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   wblockb(i+1, jb-kkk-1, j, :) = wblockb(i+1, jb-kkk-1, j, :) &
   &              + wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   wblockb(i, jb-kkk-1, j, :) = wblockb(i, jb-kkk-1, j, :) + &
   &              wadjb(kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8ARRAY(fact, realtype/8)
   ELSE
   DO kkk=2,1,-1
   wblockb(i+1, j+1, kkk+1, :) = wblockb(i+1, j+1, kkk+1, :) + &
   &              wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   wblockb(i, j+1, kkk+1, :) = wblockb(i, j+1, kkk+1, :) + &
   &              wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   wblockb(i+1, j, kkk+1, :) = wblockb(i+1, j, kkk+1, :) + &
   &              wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   wblockb(i, j, kkk+1, :) = wblockb(i, j, kkk+1, :) + wadjb(&
   &              kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8ARRAY(fact, realtype/8)
   END IF
   ELSE
   DO kkk=2,1,-1
   wblockb(i+1, j+1, kb-kkk-1, :) = wblockb(i+1, j+1, kb-kkk-1, :&
   &            ) + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   wblockb(i, j+1, kb-kkk-1, :) = wblockb(i, j+1, kb-kkk-1, :) + &
   &            wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   wblockb(i+1, j, kb-kkk-1, :) = wblockb(i+1, j, kb-kkk-1, :) + &
   &            wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   wblockb(i, j, kb-kkk-1, :) = wblockb(i, j, kb-kkk-1, :) + &
   &            wadjb(kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8ARRAY(fact, realtype/8)
   END IF
   DO iii=2,1,-1
   DO jjj=2,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   ptsb(:, upper_right) = ptsb(:, upper_right) + grid_ptsb(:, &
   &              iii+1, jjj+1)
   grid_ptsb(:, iii+1, jjj+1) = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   ptsb(:, upper_left) = ptsb(:, upper_left) + grid_ptsb(:, iii&
   &              , jjj+1)
   grid_ptsb(:, iii, jjj+1) = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   ptsb(:, lower_right) = ptsb(:, lower_right) + grid_ptsb(:, &
   &              iii+1, jjj)
   grid_ptsb(:, iii+1, jjj) = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   ptsb(:, lower_left) = ptsb(:, lower_left) + grid_ptsb(:, iii&
   &              , jjj)
   grid_ptsb(:, iii, jjj) = 0.0
   END IF
   CALL POPINTEGER4ARRAY(upper_right, inttype/4)
   CALL POPINTEGER4ARRAY(upper_left, inttype/4)
   CALL POPINTEGER4ARRAY(lower_right, inttype/4)
   CALL POPINTEGER4ARRAY(lower_left, inttype/4)
   END DO
   END DO
   CALL POPREAL8ARRAY(wadj, realtype*2**3*nw/8)
   CALL POPREAL8ARRAY(grid_pts, realtype*3**3/8)
   END DO
   END DO
   momentb = 0.0
   liftb = 0.0
   cforceb = 0.0
   dragb = 0.0
   forceb = 0.0
   cdb = 0.0
   clb = 0.0
   cmomentb = 0.0
   END SUBROUTINE COMPUTEFORCEANDMOMENTADJ_B

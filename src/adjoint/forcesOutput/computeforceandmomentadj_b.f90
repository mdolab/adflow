   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of computeforceandmomentadj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: pointrefadj moment
   !                wblock lengthrefadj lift surfacerefadj cforce
   !                alphaadj pts betaadj drag force cd cl machcoefadj
   !                cmoment
   !   of linear combination of output variables: moment lift cforce
   !                drag force cd cl cmoment
   SUBROUTINE COMPUTEFORCEANDMOMENTADJ_B(force, forceb, cforce, cforceb, &
   &  lift, liftb, drag, dragb, cl, clb, cd, cdb, moment, momentb, cmoment&
   &  , cmomentb, alphaadj, alphaadjb, betaadj, betaadjb, liftindex, &
   &  machcoefadj, machcoefadjb, pointrefadj, pointrefadjb, lengthrefadj, &
   &  lengthrefadjb, surfacerefadj, surfacerefadjb, pts, ptsb, npts, wblock&
   &  , wblockb, righthandedadj, faceid, ibeg, iend, jbeg, jend, ii_start, &
   &  sps)
   USE bctypes_b
   USE blockpointers_b
   USE flowvarrefstate_b
   USE inputdiscretization_b
   USE inputmotion_b
   USE inputphysics_b
   USE inputtimespectral_b
   USE inputtsstabderiv_b
   IMPLICIT NONE
   REAL(KIND=REALTYPE), INTENT(IN) :: alphaadj
   REAL(KIND=REALTYPE), INTENT(IN) :: betaadj
   REAL(KIND=REALTYPE) :: alphaadjb, betaadjb
   REAL(KIND=REALTYPE) :: cd, cdb, cl, clb, drag, dragb, lift, liftb
   REAL(KIND=REALTYPE) :: cmoment(3), cmomentb(3), moment(3), momentb(3)
   INTEGER(KIND=INTTYPE), INTENT(IN) :: faceid
   REAL(KIND=REALTYPE) :: cforce(3), cforceb(3), force(3), forceb(3)
   INTEGER(KIND=INTTYPE), INTENT(IN) :: ibeg
   INTEGER(KIND=INTTYPE), INTENT(IN) :: iend
   INTEGER(KIND=INTTYPE), INTENT(IN) :: ii_start
   INTEGER(KIND=INTTYPE), INTENT(IN) :: jbeg
   INTEGER(KIND=INTTYPE), INTENT(IN) :: jend
   REAL(KIND=REALTYPE), INTENT(IN) :: lengthrefadj
   REAL(KIND=REALTYPE) :: lengthrefadjb, surfacerefadjb
   INTEGER(KIND=INTTYPE), INTENT(IN) :: liftindex
   REAL(KIND=REALTYPE), INTENT(IN) :: machcoefadj
   REAL(KIND=REALTYPE) :: machcoefadjb
   INTEGER(KIND=INTTYPE), INTENT(IN) :: npts
   REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: pointrefadj
   REAL(KIND=REALTYPE) :: pointrefadjb(3)
   REAL(KIND=REALTYPE), DIMENSION(3, npts), INTENT(IN) :: pts
   REAL(KIND=REALTYPE) :: ptsb(3, npts)
   LOGICAL, INTENT(IN) :: righthandedadj
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   REAL(KIND=REALTYPE), INTENT(IN) :: surfacerefadj
   REAL(KIND=REALTYPE), DIMENSION(0:ib, 0:jb, 0:kb, nw), INTENT(IN) :: &
   &  wblock
   REAL(KIND=REALTYPE) :: wblockb(0:ib, 0:jb, 0:kb, nw)
   TYPE UNKNOWNDERIVEDTYPE0
   REAL :: timeperiod
   END TYPE UNKNOWNDERIVEDTYPE0
   REAL(KIND=REALTYPE) :: addforce(3), addforceb(3), addmoment(3), &
   &  addmomentb(3), refpoint(3)
   REAL(KIND=REALTYPE) :: alphaincrement, alphats, alphatsb, &
   &  betaincrement, betats, betatsb
   INTEGER :: branch
   REAL(KIND=REALTYPE) :: dragdir(3), dragdirb(3), freestreamdir(3), &
   &  liftdir(3), liftdirb(3)
   REAL(KIND=REALTYPE) :: fact, factb, temp1b, tempb
   INTEGER(KIND=INTTYPE) :: ii
   INTEGER(KIND=INTTYPE) :: iii, jjj, kkk
   INTEGER(KIND=INTTYPE) :: i, istride, j, jstride
   REAL(KIND=REALTYPE) :: dragdirtmp(3), dragdirtmpb(3), liftdirtmp(3), &
   &  liftdirtmpb(3)
   INTEGER(KIND=INTTYPE) :: nn
   INTEGER :: nsections
   TYPE(UNKNOWNDERIVEDTYPE0) :: res, result1, SECTIONS
   REAL(KIND=REALTYPE) :: derivrotationmatrix(3, 3), rotationmatrix(3, 3)
   REAL(KIND=REALTYPE) :: rotationpoint(3)
   REAL(KIND=REALTYPE) :: t(nsections)
   REAL(KIND=REALTYPE) :: temp, temp0
   REAL :: timeunsteady
   REAL :: timeunsteadyrestart
   REAL(KIND=REALTYPE) :: tnew, told
   REAL(KIND=REALTYPE) :: TSALPHA, TSBETA
   INTEGER(KIND=INTTYPE) :: lower_left, lower_right, upper_left, &
   &  upper_right
   REAL(KIND=REALTYPE) :: veldirfreestreamadj(3), veldirfreestreamadjb(3)
   REAL(KIND=REALTYPE) :: grid_pts(3, 3, 3), grid_ptsb(3, 3, 3), wadj(2, &
   &  2, 2, nw), wadjb(2, 2, 2, nw)
   EXTERNAL TSALPHA, ADJUSTINFLOWANGLEADJ, ROTMATRIXRIGIDBODY, &
   &      ADJUSTINFLOWANGLEADJ_B, SECTIONS, TSBETA
   !     ******************************************************************
   !     *                                                                *
   !     * Compute the sum of the forces and moments on all blocks on     *
   !     * this processor. This function can be AD'd                      *
   !     *                                                                *
   !     ******************************************************************
   !
   ! equations
   ! nw
   ! spaceDiscr, useCompactDiss
   !imin,imax,jmin,jmax,kmin,kmax
   !TSStability
   !nTimeIntervalsSpectral
   !degreePol etc...
   !TimeunsteadyRestart
   !nSections
   ! Subroutine Arguments
   ! Output
   ! Input
   ! Local Variables
   !TS variables
   !Rotation variables
   !Function Definitions
   ! Only need to zero force and moment -> these are summed again
   force = 0.0
   moment = 0.0
   istride = iend - ibeg + 1
   ii = ii_start
   DO j=jbeg,jend
   DO i=ibeg,iend
   CALL PUSHREAL8ARRAY(grid_pts, 3**3)
   grid_pts(:, :, :) = 0.0
   CALL PUSHREAL8ARRAY(wadj, 2**3*nw)
   wadj(:, :, :, :) = 0.0
   DO iii=1,2
   DO jjj=1,2
   CALL PUSHINTEGER4(lower_left)
   lower_left = ii + iii + (jjj-1)*istride - istride - 1
   CALL PUSHINTEGER4(lower_right)
   lower_right = ii + iii + (jjj-1)*istride - istride
   CALL PUSHINTEGER4(upper_left)
   upper_left = ii + iii + jjj*istride - istride - 1
   CALL PUSHINTEGER4(upper_right)
   upper_right = ii + iii + jjj*istride - istride
   IF (lower_left .GT. 0 .AND. lower_left .LE. npts) THEN
   CALL PUSHREAL8ARRAY(grid_pts(:, iii, jjj), 3)
   grid_pts(:, iii, jjj) = pts(:, lower_left)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (lower_right .GT. 0 .AND. lower_right .LE. npts) THEN
   CALL PUSHREAL8ARRAY(grid_pts(:, iii+1, jjj), 3)
   grid_pts(:, iii+1, jjj) = pts(:, lower_right)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (upper_left .GT. 0 .AND. upper_left .LE. npts) THEN
   CALL PUSHREAL8ARRAY(grid_pts(:, iii, jjj+1), 3)
   grid_pts(:, iii, jjj+1) = pts(:, upper_left)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (upper_right .GT. 0 .AND. upper_right .LE. npts) THEN
   CALL PUSHREAL8ARRAY(grid_pts(:, iii+1, jjj+1), 3)
   grid_pts(:, iii+1, jjj+1) = pts(:, upper_right)
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO
   END DO
   !Copy over the states
   SELECT CASE  (faceid) 
   CASE (imin) 
   CALL PUSHREAL8(fact)
   fact = -1_realType
   DO kkk=1,2
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wadj(kkk, 1, 1, :) = wblock(kkk+1, i, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wadj(kkk, 2, 1, :) = wblock(kkk+1, i+1, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wadj(kkk, 1, 2, :) = wblock(kkk+1, i, j+1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wadj(kkk, 2, 2, :) = wblock(kkk+1, i+1, j+1, :)
   END DO
   CALL PUSHINTEGER4(1)
   CASE (imax) 
   CALL PUSHREAL8(fact)
   fact = 1_realType
   DO kkk=1,2
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wadj(kkk, 1, 1, :) = wblock(ib-kkk-1, i, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wadj(kkk, 2, 1, :) = wblock(ib-kkk-1, i+1, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wadj(kkk, 1, 2, :) = wblock(ib-kkk-1, i, j+1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wadj(kkk, 2, 2, :) = wblock(ib-kkk-1, i+1, j+1, :)
   END DO
   CALL PUSHINTEGER4(2)
   CASE (jmin) 
   CALL PUSHREAL8(fact)
   fact = 1_realType
   DO kkk=1,2
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wadj(kkk, 1, 1, :) = wblock(i, kkk+1, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wadj(kkk, 2, 1, :) = wblock(i+1, kkk+1, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wadj(kkk, 1, 2, :) = wblock(i, kkk+1, j+1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wadj(kkk, 2, 2, :) = wblock(i+1, kkk+1, j+1, :)
   END DO
   CALL PUSHINTEGER4(3)
   CASE (jmax) 
   CALL PUSHREAL8(fact)
   fact = -1_realType
   DO kkk=1,2
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wadj(kkk, 1, 1, :) = wblock(i, jb-kkk-1, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wadj(kkk, 2, 1, :) = wblock(i+1, jb-kkk-1, j, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wadj(kkk, 1, 2, :) = wblock(i, jb-kkk-1, j+1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wadj(kkk, 2, 2, :) = wblock(i+1, jb-kkk-1, j+1, :)
   END DO
   CALL PUSHINTEGER4(4)
   CASE (kmin) 
   CALL PUSHREAL8(fact)
   fact = -1_realType
   DO kkk=1,2
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wadj(kkk, 1, 1, :) = wblock(i, j, kkk+1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wadj(kkk, 2, 1, :) = wblock(i+1, j, kkk+1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wadj(kkk, 1, 2, :) = wblock(i, j+1, kkk+1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wadj(kkk, 2, 2, :) = wblock(i+1, j+1, kkk+1, :)
   END DO
   CALL PUSHINTEGER4(5)
   CASE (kmax) 
   CALL PUSHREAL8(fact)
   fact = 1_realType
   DO kkk=1,2
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wadj(kkk, 1, 1, :) = wblock(i, j, kb-kkk-1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wadj(kkk, 2, 1, :) = wblock(i+1, j, kb-kkk-1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wadj(kkk, 1, 2, :) = wblock(i, j+1, kb-kkk-1, :)
   CALL PUSHREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wadj(kkk, 2, 2, :) = wblock(i+1, j+1, kb-kkk-1, :)
   END DO
   CALL PUSHINTEGER4(6)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   CALL COMPUTEFORCESADJ(addforce, addmoment, grid_pts, wadj, &
   &                      pointrefadj, fact, ibeg, iend, jbeg, jend, i, j, &
   &                      righthandedadj)
   ii = ii + 1
   force = force + addforce
   moment = moment + addmoment
   END DO
   END DO
   CALL PUSHREAL8(fact)
   ! Now we know the sum of the force and moment contribution from this block
   ! First get cForce -> Coefficient of FOrce
   fact = two/(gammainf*pinf*pref*machcoefadj*machcoefadj*surfacerefadj*&
   &    lref*lref)
   ! To get Lift,Drag,Cl and Cd get lift and drag directions
   CALL ADJUSTINFLOWANGLEFORCESADJ(alphaadj, betaadj, veldirfreestreamadj&
   &                            , liftdir, dragdir, liftindex)
   !This computation is time dependent for TSStability so update for time instance
   IF (tsstability) THEN
   !update the lift vector and drag vector to account for changing 
   !angles of attack
   ! compute the time of this interval
   t = timeunsteadyrestart
   IF (equationmode .EQ. timespectral) THEN
   DO nn=1,nsections
   res = SECTIONS(nn)
   t(nn) = t(nn) + (sps-1)*result1%timeperiod/&
   &          ntimeintervalsspectral*1.0
   CALL PUSHINTEGER4(nn)
   END DO
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Determine the time values of the old and new time level.
   ! It is assumed that the rigid body rotation of the mesh is only
   ! used when only 1 section is present.
   IF (tspmode .OR. tsqmode .OR. tsrmode) THEN
   ! Compute the rotation matrix of the rigid body rotation as
   ! well as the rotation point; the latter may vary in time due
   ! to rigid body translation.
   CALL ROTMATRIXRIGIDBODY(tnew, told, rotationmatrix, rotationpoint)
   liftdirtmp(1) = rotationmatrix(1, 1)*liftdir(1) + rotationmatrix(1&
   &        , 2)*liftdir(2) + rotationmatrix(1, 3)*liftdir(3)
   liftdirtmp(2) = rotationmatrix(2, 1)*liftdir(1) + rotationmatrix(2&
   &        , 2)*liftdir(2) + rotationmatrix(2, 3)*liftdir(3)
   liftdirtmp(3) = rotationmatrix(3, 1)*liftdir(1) + rotationmatrix(3&
   &        , 2)*liftdir(2) + rotationmatrix(3, 3)*liftdir(3)
   dragdirtmp(1) = rotationmatrix(1, 1)*dragdir(1) + rotationmatrix(1&
   &        , 2)*dragdir(2) + rotationmatrix(1, 3)*dragdir(3)
   dragdirtmp(2) = rotationmatrix(2, 1)*dragdir(1) + rotationmatrix(2&
   &        , 2)*dragdir(2) + rotationmatrix(2, 3)*dragdir(3)
   dragdirtmp(3) = rotationmatrix(3, 1)*dragdir(1) + rotationmatrix(3&
   &        , 2)*dragdir(2) + rotationmatrix(3, 3)*dragdir(3)
   liftdir = liftdirtmp
   dragdir = dragdirtmp
   CALL PUSHINTEGER4(1)
   ELSE IF (tsalphamode) THEN
   !Determine the alpha for this time instance
   alphaincrement = TSALPHA(degreepolalpha, coefpolalpha, &
   &        degreefouralpha, omegafouralpha, coscoeffouralpha, &
   &        sincoeffouralpha, t(1))
   alphats = alphaadj + alphaincrement
   CALL PUSHINTEGER4(liftindex)
   CALL PUSHREAL8(betaadj)
   CALL PUSHREAL8ARRAY(dragdir, 3)
   CALL PUSHREAL8ARRAY(liftdir, 3)
   CALL PUSHREAL8ARRAY(veldirfreestreamadj, 3)
   CALL PUSHREAL8(alphats)
   !Determine the grid velocity for this alpha
   CALL ADJUSTINFLOWANGLEADJ(alphats, betaadj, veldirfreestreamadj, &
   &                          liftdir, dragdir, liftindex)
   !do I need to update the lift direction and drag direction as well? yes!!!
   CALL PUSHINTEGER4(2)
   ELSE IF (tsbetamode) THEN
   !Determine the alpha for this time instance
   betaincrement = TSBETA(degreepolbeta, coefpolbeta, degreefourbeta&
   &        , omegafourbeta, coscoeffourbeta, sincoeffourbeta, t(1))
   betats = betaadj + betaincrement
   CALL PUSHINTEGER4(liftindex)
   CALL PUSHREAL8(alphaadj)
   CALL PUSHREAL8ARRAY(dragdir, 3)
   CALL PUSHREAL8ARRAY(liftdir, 3)
   CALL PUSHREAL8ARRAY(veldirfreestreamadj, 3)
   CALL PUSHREAL8(betats)
   !Determine the grid velocity for this alpha
   CALL ADJUSTINFLOWANGLEADJ(alphaadj, betats, veldirfreestreamadj, &
   &                          liftdir, dragdir, liftindex)
   CALL PUSHINTEGER4(4)
   ELSE
   CALL PUSHINTEGER4(3)
   END IF
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Take Dot Products ... this won't AD properly so we will write explictly
   !Lift = dot_product(Force,liftDir)
   !Drag = dot_product(Force,dragDir)
   lift = force(1)*liftdir(1) + force(2)*liftdir(2) + force(3)*liftdir(3)
   drag = force(1)*dragdir(1) + force(2)*dragdir(2) + force(3)*dragdir(3)
   CALL PUSHREAL8(fact)
   ! Update fact for moment normalization
   fact = fact/(lengthrefadj*lref)
   momentb = momentb + fact*cmomentb
   factb = SUM(moment*cmomentb)
   CALL POPREAL8(fact)
   temp1b = factb/(lref*lengthrefadj)
   lengthrefadjb = -(fact*temp1b/lengthrefadj)
   factb = lift*clb + drag*cdb + temp1b
   dragb = dragb + fact*cdb
   liftb = liftb + fact*clb
   dragdirb(1:3) = 0.0
   forceb(1) = forceb(1) + dragdir(1)*dragb
   dragdirb(1) = force(1)*dragb
   forceb(2) = forceb(2) + dragdir(2)*dragb
   dragdirb(2) = force(2)*dragb
   forceb(3) = forceb(3) + dragdir(3)*dragb
   dragdirb(3) = force(3)*dragb
   liftdirb(1:3) = 0.0
   forceb(1) = forceb(1) + liftdir(1)*liftb
   liftdirb(1) = force(1)*liftb
   forceb(2) = forceb(2) + liftdir(2)*liftb
   liftdirb(2) = force(2)*liftb
   forceb(3) = forceb(3) + liftdir(3)*liftb
   liftdirb(3) = force(3)*liftb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 3) THEN
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   alphaadjb = 0.0
   betaadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   GOTO 100
   ELSE
   dragdirtmpb(1:3) = 0.0
   dragdirtmpb = dragdirb
   liftdirtmpb(1:3) = 0.0
   liftdirtmpb = liftdirb
   dragdirb(1:3) = 0.0
   dragdirb(1) = rotationmatrix(3, 1)*dragdirtmpb(3)
   dragdirb(2) = rotationmatrix(3, 2)*dragdirtmpb(3)
   dragdirb(3) = rotationmatrix(3, 3)*dragdirtmpb(3)
   dragdirtmpb(3) = 0.0
   dragdirb(1) = dragdirb(1) + rotationmatrix(2, 1)*dragdirtmpb(2)
   dragdirb(2) = dragdirb(2) + rotationmatrix(2, 2)*dragdirtmpb(2)
   dragdirb(3) = dragdirb(3) + rotationmatrix(2, 3)*dragdirtmpb(2)
   dragdirtmpb(2) = 0.0
   dragdirb(1) = dragdirb(1) + rotationmatrix(1, 1)*dragdirtmpb(1)
   dragdirb(2) = dragdirb(2) + rotationmatrix(1, 2)*dragdirtmpb(1)
   dragdirb(3) = dragdirb(3) + rotationmatrix(1, 3)*dragdirtmpb(1)
   liftdirb(1:3) = 0.0
   liftdirb(1) = rotationmatrix(3, 1)*liftdirtmpb(3)
   liftdirb(2) = rotationmatrix(3, 2)*liftdirtmpb(3)
   liftdirb(3) = rotationmatrix(3, 3)*liftdirtmpb(3)
   liftdirtmpb(3) = 0.0
   liftdirb(1) = liftdirb(1) + rotationmatrix(2, 1)*liftdirtmpb(2)
   liftdirb(2) = liftdirb(2) + rotationmatrix(2, 2)*liftdirtmpb(2)
   liftdirb(3) = liftdirb(3) + rotationmatrix(2, 3)*liftdirtmpb(2)
   liftdirtmpb(2) = 0.0
   liftdirb(1) = liftdirb(1) + rotationmatrix(1, 1)*liftdirtmpb(1)
   liftdirb(2) = liftdirb(2) + rotationmatrix(1, 2)*liftdirtmpb(1)
   liftdirb(3) = liftdirb(3) + rotationmatrix(1, 3)*liftdirtmpb(1)
   alphaadjb = 0.0
   betaadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   END IF
   ELSE
   CALL POPREAL8(alphats)
   CALL POPREAL8ARRAY(veldirfreestreamadj, 3)
   CALL POPREAL8ARRAY(liftdir, 3)
   CALL POPREAL8ARRAY(dragdir, 3)
   CALL LOOKREAL8(betaadj)
   CALL LOOKINTEGER4(liftindex)
   veldirfreestreamadjb(:) = 0.0
   betaadjb = 0.0
   alphatsb = 0.0
   CALL ADJUSTINFLOWANGLEADJ_B(alphats, alphatsb, betaadj, betaadjb, &
   &                            veldirfreestreamadj, veldirfreestreamadjb, &
   &                            liftdir, liftdirb, dragdir, dragdirb, &
   &                            liftindex)
   CALL POPREAL8(betaadj)
   CALL POPINTEGER4(liftindex)
   alphaadjb = alphatsb
   END IF
   ELSE IF (branch .LT. 4) THEN
   alphaadjb = 0.0
   betaadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   ELSE
   CALL POPREAL8(betats)
   CALL POPREAL8ARRAY(veldirfreestreamadj, 3)
   CALL POPREAL8ARRAY(liftdir, 3)
   CALL POPREAL8ARRAY(dragdir, 3)
   CALL LOOKREAL8(alphaadj)
   CALL LOOKINTEGER4(liftindex)
   veldirfreestreamadjb(:) = 0.0
   betatsb = 0.0
   alphaadjb = 0.0
   CALL ADJUSTINFLOWANGLEADJ_B(alphaadj, alphaadjb, betats, betatsb, &
   &                          veldirfreestreamadj, veldirfreestreamadjb, &
   &                          liftdir, liftdirb, dragdir, dragdirb, &
   &                          liftindex)
   CALL POPREAL8(alphaadj)
   CALL POPINTEGER4(liftindex)
   betaadjb = betatsb
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   DO nn=nsections,1,-1
   CALL POPINTEGER4(nn)
   END DO
   END IF
   100 CALL ADJUSTINFLOWANGLEFORCESADJ_B(alphaadj, alphaadjb, betaadj, &
   &                                 betaadjb, veldirfreestreamadj, &
   &                                 veldirfreestreamadjb, liftdir, &
   &                                 liftdirb, dragdir, dragdirb, liftindex&
   &                                )
   factb = factb + SUM(force*cforceb)
   forceb = forceb + fact*cforceb
   CALL POPREAL8(fact)
   temp0 = gammainf*pinf*pref*lref**2
   temp = temp0*machcoefadj**2*surfacerefadj
   tempb = -(two*temp0*factb/temp**2)
   machcoefadjb = surfacerefadj*2*machcoefadj*tempb
   surfacerefadjb = machcoefadj**2*tempb
   pointrefadjb(1:3) = 0.0
   wblockb(0:ib, 0:jb, 0:kb, 1:nw) = 0.0
   ptsb(1:3, 1:npts) = 0.0
   addforceb(1:3) = 0.0
   grid_ptsb(1:3, 1:3, 1:3) = 0.0
   wadjb(1:2, 1:2, 1:2, 1:nw) = 0.0
   addmomentb(1:3) = 0.0
   DO j=jend,jbeg,-1
   DO i=iend,ibeg,-1
   addmomentb = addmomentb + momentb
   addforceb = addforceb + forceb
   CALL COMPUTEFORCESADJ_B(addforce, addforceb, addmoment, addmomentb&
   &                        , grid_pts, grid_ptsb, wadj, wadjb, pointrefadj&
   &                        , pointrefadjb, fact, ibeg, iend, jbeg, jend, i&
   &                        , j, righthandedadj)
   CALL POPINTEGER4(branch)
   IF (branch .LT. 4) THEN
   IF (branch .LT. 2) THEN
   IF (.NOT.branch .LT. 1) THEN
   DO kkk=2,1,-1
   CALL POPREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wblockb(kkk+1, i+1, j+1, :) = wblockb(kkk+1, i+1, j+1, :) &
   &                + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wblockb(kkk+1, i, j+1, :) = wblockb(kkk+1, i, j+1, :) + &
   &                wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wblockb(kkk+1, i+1, j, :) = wblockb(kkk+1, i+1, j, :) + &
   &                wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wblockb(kkk+1, i, j, :) = wblockb(kkk+1, i, j, :) + wadjb(&
   &                kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8(fact)
   END IF
   ELSE IF (branch .LT. 3) THEN
   DO kkk=2,1,-1
   CALL POPREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wblockb(ib-kkk-1, i+1, j+1, :) = wblockb(ib-kkk-1, i+1, j+1&
   &              , :) + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wblockb(ib-kkk-1, i, j+1, :) = wblockb(ib-kkk-1, i, j+1, :) &
   &              + wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wblockb(ib-kkk-1, i+1, j, :) = wblockb(ib-kkk-1, i+1, j, :) &
   &              + wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wblockb(ib-kkk-1, i, j, :) = wblockb(ib-kkk-1, i, j, :) + &
   &              wadjb(kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8(fact)
   ELSE
   DO kkk=2,1,-1
   CALL POPREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wblockb(i+1, kkk+1, j+1, :) = wblockb(i+1, kkk+1, j+1, :) + &
   &              wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wblockb(i, kkk+1, j+1, :) = wblockb(i, kkk+1, j+1, :) + &
   &              wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wblockb(i+1, kkk+1, j, :) = wblockb(i+1, kkk+1, j, :) + &
   &              wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wblockb(i, kkk+1, j, :) = wblockb(i, kkk+1, j, :) + wadjb(&
   &              kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8(fact)
   END IF
   ELSE IF (branch .LT. 6) THEN
   IF (branch .LT. 5) THEN
   DO kkk=2,1,-1
   CALL POPREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wblockb(i+1, jb-kkk-1, j+1, :) = wblockb(i+1, jb-kkk-1, j+1&
   &              , :) + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wblockb(i, jb-kkk-1, j+1, :) = wblockb(i, jb-kkk-1, j+1, :) &
   &              + wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wblockb(i+1, jb-kkk-1, j, :) = wblockb(i+1, jb-kkk-1, j, :) &
   &              + wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wblockb(i, jb-kkk-1, j, :) = wblockb(i, jb-kkk-1, j, :) + &
   &              wadjb(kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8(fact)
   ELSE
   DO kkk=2,1,-1
   CALL POPREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wblockb(i+1, j+1, kkk+1, :) = wblockb(i+1, j+1, kkk+1, :) + &
   &              wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wblockb(i, j+1, kkk+1, :) = wblockb(i, j+1, kkk+1, :) + &
   &              wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wblockb(i+1, j, kkk+1, :) = wblockb(i+1, j, kkk+1, :) + &
   &              wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wblockb(i, j, kkk+1, :) = wblockb(i, j, kkk+1, :) + wadjb(&
   &              kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8(fact)
   END IF
   ELSE
   DO kkk=2,1,-1
   CALL POPREAL8ARRAY(wadj(kkk, 2, 2, :), nw)
   wblockb(i+1, j+1, kb-kkk-1, :) = wblockb(i+1, j+1, kb-kkk-1, :&
   &            ) + wadjb(kkk, 2, 2, :)
   wadjb(kkk, 2, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 2, :), nw)
   wblockb(i, j+1, kb-kkk-1, :) = wblockb(i, j+1, kb-kkk-1, :) + &
   &            wadjb(kkk, 1, 2, :)
   wadjb(kkk, 1, 2, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 2, 1, :), nw)
   wblockb(i+1, j, kb-kkk-1, :) = wblockb(i+1, j, kb-kkk-1, :) + &
   &            wadjb(kkk, 2, 1, :)
   wadjb(kkk, 2, 1, :) = 0.0
   CALL POPREAL8ARRAY(wadj(kkk, 1, 1, :), nw)
   wblockb(i, j, kb-kkk-1, :) = wblockb(i, j, kb-kkk-1, :) + &
   &            wadjb(kkk, 1, 1, :)
   wadjb(kkk, 1, 1, :) = 0.0
   END DO
   CALL POPREAL8(fact)
   END IF
   DO iii=2,1,-1
   DO jjj=2,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   CALL POPREAL8ARRAY(grid_pts(:, iii+1, jjj+1), 3)
   ptsb(:, upper_right) = ptsb(:, upper_right) + grid_ptsb(:, &
   &              iii+1, jjj+1)
   grid_ptsb(:, iii+1, jjj+1) = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(grid_pts(:, iii, jjj+1), 3)
   ptsb(:, upper_left) = ptsb(:, upper_left) + grid_ptsb(:, iii&
   &              , jjj+1)
   grid_ptsb(:, iii, jjj+1) = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(grid_pts(:, iii+1, jjj), 3)
   ptsb(:, lower_right) = ptsb(:, lower_right) + grid_ptsb(:, &
   &              iii+1, jjj)
   grid_ptsb(:, iii+1, jjj) = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(grid_pts(:, iii, jjj), 3)
   ptsb(:, lower_left) = ptsb(:, lower_left) + grid_ptsb(:, iii&
   &              , jjj)
   grid_ptsb(:, iii, jjj) = 0.0
   END IF
   CALL POPINTEGER4(upper_right)
   CALL POPINTEGER4(upper_left)
   CALL POPINTEGER4(lower_right)
   CALL POPINTEGER4(lower_left)
   END DO
   END DO
   CALL POPREAL8ARRAY(wadj, 2**3*nw)
   wadjb(:, :, :, :) = 0.0
   CALL POPREAL8ARRAY(grid_pts, 3**3)
   grid_ptsb(:, :, :) = 0.0
   END DO
   END DO
   momentb(1:3) = 0.0
   liftb = 0.0
   cforceb(1:3) = 0.0
   dragb = 0.0
   forceb(1:3) = 0.0
   cdb = 0.0
   clb = 0.0
   cmomentb(1:3) = 0.0
   END SUBROUTINE COMPUTEFORCEANDMOMENTADJ_B

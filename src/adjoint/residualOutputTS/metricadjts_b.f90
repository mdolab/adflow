   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of metricadjts in reverse (adjoint) mode:
   !   gradient, with respect to input variables: xadj
   !   of linear combination of output variables: voladj xadj skadj
   !                sjadj siadj normadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          metricAdj.f90                                   *
   !      * Author:        Edwin van der Weide                             *
   !      *                Seongim Choi,C.A.(Sandy) Mader                  *
   !      * Starting date: 12-15-2007                                      *
   !      * Last modified: 12-26-2007                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE METRICADJTS_B(xadj, xadjb, siadj, siadjb, sjadj, sjadjb, &
   &  skadj, skadjb, voladj, voladjb, normadj, normadjb, icell, jcell, &
   &  kcell, nn, level, sps)
   USE bctypes
   USE blockpointers
   USE cgnsgrid
   USE communication
   USE constants
   USE inputtimespectral
   USE section
   IMPLICIT NONE
   !                   call terminate("metric", &
   !                   "Normals do not sum up to 0")
   INTEGER(KIND=INTTYPE), INTENT(IN) :: icell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: jcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: kcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: level
   INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
   REAL(KIND=REALTYPE) :: normadj(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), normadjb(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: siadj(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), siadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), sjadj(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), sjadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), skadj(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), skadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   REAL(KIND=REALTYPE) :: voladj(ntimeintervalsspectral), voladjb(&
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: xadj
   REAL(KIND=REALTYPE) :: xadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), PARAMETER :: thresvolume=1.e-2_realType
   INTEGER :: ad_from, ad_from0, ad_from1, ad_from2, ad_from3, ad_from4, &
   &  ad_from5, ad_from6, ad_to, ad_to0, ad_to1, ad_to2, ad_to3, ad_to4, &
   &  ad_to5, ad_to6, branch, ierr
   LOGICAL :: badvolume, checkall, checki, checkj, checkk, ioverlap, &
   &  joverlap, koverlap, secondhalo, volumeisneg
   REAL(KIND=REALTYPE) :: fact, factb, mult, tempb12
   INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
   CHARACTER(len=10) :: integerstring
   INTEGER(KIND=INTTYPE) :: i, ien, ist, j, jen, jj, jst, k, kk, l, m, n
   INTEGER(KIND=INTTYPE) :: irbeg, irend, jrbeg, jrend, krbeg, krend
   INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
   INTEGER(KIND=INTTYPE) :: iend, istart, jend, jstart, kend, kstart
   INTEGER(KIND=INTTYPE) :: mm, ntime
   INTEGER(KIND=INTTYPE) :: nvolbad, nvolbadglobal
   INTEGER(KIND=INTTYPE) :: nvolneg, nvolpos
   REAL(KIND=REALTYPE) :: ss(-2:2, -2:2, 3), ssb(-2:2, -2:2, 3)
   REAL(KIND=REALTYPE) :: temp, temp0, temp0b, temp1, temp10, temp11, &
   &  temp12, temp13, temp14, temp15, temp16, temp17, temp18, temp19, &
   &  temp1b, temp2, temp20, temp21, temp22, temp23, temp24, temp25, temp26&
   &  , temp27, temp28, temp29, temp2b, temp3, temp3b, temp4, temp4b, temp5&
   &  , temp5b, temp6, temp7, temp8, temp9, tempb10, tempb11, tempb13, &
   &  tempb3, tempb4, tempb5, tempb6, tempb7, tempb8, tempb9
   REAL(KIND=REALTYPE) :: abs1, tempb
   REAL(KIND=REALTYPE) :: v1(3), v1b(3), v2(3), v2b(3)
   REAL(KIND=REALTYPE) :: abs2, abs3, abs4, abs5, abs6, abs7, tempb0, &
   &  tempb1, tempb2, vp1, vp1b, vp2, vp2b, vp3, vp3b, vp4, vp4b, vp5, vp5b&
   &  , vp6, vp6b, xp, xpb, yp, ypb, zp, zpb
   INTRINSIC MAX, ABS, MIN, SQRT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * metric computes the face normals and the volume for the given  *
   !      * grid level for all spectral solutions. First the volumes are   *
   !      * computed assuming that the block is right handed. Then the     *
   !      * number of positive and negative volumes are determined. If all *
   !      * volumes are positive the block is indeed right handed; if all  *
   !      * volumes are negative the block is left handed and both the     *
   !      * volumes and the normals must be negated (for the normals this  *
   !      * is done by the introduction of fact, which is either -0.5 or   *
   !      * 0.5); if there are both positive and negative volumes the mesh *
   !      * is not valid.                                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments.
   !
   !       real(kind=realType), dimension(-2:3,-2:3,-2:3,3), intent(in) :: xAdj
   !       real(kind=realType), dimension(-2:2,-2:2,-2:2,3), intent(out) :: siAdj, sjAdj, skAdj
   !
   !      Local parameter.
   !
   !
   !      Local variables.
   !
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   ! Some initialization for siAdj,sjAdj,skAdj,normAdj 
   ! Volume needs only one stencil so it does not need initialization
   siadj(:, :, :, :, sps) = zero
   sjadj(:, :, :, :, sps) = zero
   skadj(:, :, :, :, sps) = zero
   !!$       do n = 1,3
   !!$          do i = -3,2
   !!$             do j = -3,2
   !!$                do k = -3,2
   !!$                   print *,'xadj',xadj(i,j,k,n),i,j,k,n
   !!$                enddo
   !!$             enddo
   !!$          end do
   !!$       end do
   !
   !
   !      **************************************************************
   !      *                                                            *
   !      * Volume computation
   !      *                                                            *
   !      **************************************************************
   !
   ! Initialize the number of positive and negative volumes for
   ! this block to 0.Needed to catch right/lefthanded blocks
   nvolpos = 0
   ! Compute the volumes. The hexahedron is split into 6 pyramids
   ! whose volumes are computed. The volume is positive for a
   ! right handed block.
   ! Initialize the volumes to zero. The reasons is that the second
   ! level halo's must be initialized to zero and for convenience
   ! all the volumes are set to zero.
   k = 0
   j = 0
   i = 0
   n = k - 1
   m = j - 1
   l = i - 1
   ! always check the volume of changed cell
   checkall = .true.
   ! Compute the coordinates of the center of gravity.
   xp = eighth*(xadj(i, j, k, 1, sps)+xadj(i, m, k, 1, sps)+xadj(i, m, n&
   &    , 1, sps)+xadj(i, j, n, 1, sps)+xadj(l, j, k, 1, sps)+xadj(l, m, k&
   &    , 1, sps)+xadj(l, m, n, 1, sps)+xadj(l, j, n, 1, sps))
   yp = eighth*(xadj(i, j, k, 2, sps)+xadj(i, m, k, 2, sps)+xadj(i, m, n&
   &    , 2, sps)+xadj(i, j, n, 2, sps)+xadj(l, j, k, 2, sps)+xadj(l, m, k&
   &    , 2, sps)+xadj(l, m, n, 2, sps)+xadj(l, j, n, 2, sps))
   zp = eighth*(xadj(i, j, k, 3, sps)+xadj(i, m, k, 3, sps)+xadj(i, m, n&
   &    , 3, sps)+xadj(i, j, n, 3, sps)+xadj(l, j, k, 3, sps)+xadj(l, m, k&
   &    , 3, sps)+xadj(l, m, n, 3, sps)+xadj(l, j, n, 3, sps))
   ! Compute the volumes of the 6 sub pyramids. The
   ! arguments of volpym must be such that for a (regular)
   ! right handed hexahedron all volumes are positive.
   CALL VOLPYM4(xadj(i, j, k, 1, sps), xadj(i, j, k, 2, sps), xadj(i, j, &
   &         k, 3, sps), xadj(i, j, n, 1, sps), xadj(i, j, n, 2, sps), xadj&
   &         (i, j, n, 3, sps), xadj(i, m, n, 1, sps), xadj(i, m, n, 2, sps&
   &         ), xadj(i, m, n, 3, sps), xadj(i, m, k, 1, sps), xadj(i, m, k&
   &         , 2, sps), xadj(i, m, k, 3, sps), xp, yp, zp, vp1)
   CALL VOLPYM4(xadj(l, j, k, 1, sps), xadj(l, j, k, 2, sps), xadj(l, j, &
   &         k, 3, sps), xadj(l, m, k, 1, sps), xadj(l, m, k, 2, sps), xadj&
   &         (l, m, k, 3, sps), xadj(l, m, n, 1, sps), xadj(l, m, n, 2, sps&
   &         ), xadj(l, m, n, 3, sps), xadj(l, j, n, 1, sps), xadj(l, j, n&
   &         , 2, sps), xadj(l, j, n, 3, sps), xp, yp, zp, vp2)
   CALL VOLPYM4(xadj(i, j, k, 1, sps), xadj(i, j, k, 2, sps), xadj(i, j, &
   &         k, 3, sps), xadj(l, j, k, 1, sps), xadj(l, j, k, 2, sps), xadj&
   &         (l, j, k, 3, sps), xadj(l, j, n, 1, sps), xadj(l, j, n, 2, sps&
   &         ), xadj(l, j, n, 3, sps), xadj(i, j, n, 1, sps), xadj(i, j, n&
   &         , 2, sps), xadj(i, j, n, 3, sps), xp, yp, zp, vp3)
   CALL VOLPYM4(xadj(i, m, k, 1, sps), xadj(i, m, k, 2, sps), xadj(i, m, &
   &         k, 3, sps), xadj(i, m, n, 1, sps), xadj(i, m, n, 2, sps), xadj&
   &         (i, m, n, 3, sps), xadj(l, m, n, 1, sps), xadj(l, m, n, 2, sps&
   &         ), xadj(l, m, n, 3, sps), xadj(l, m, k, 1, sps), xadj(l, m, k&
   &         , 2, sps), xadj(l, m, k, 3, sps), xp, yp, zp, vp4)
   CALL VOLPYM4(xadj(i, j, k, 1, sps), xadj(i, j, k, 2, sps), xadj(i, j, &
   &         k, 3, sps), xadj(i, m, k, 1, sps), xadj(i, m, k, 2, sps), xadj&
   &         (i, m, k, 3, sps), xadj(l, m, k, 1, sps), xadj(l, m, k, 2, sps&
   &         ), xadj(l, m, k, 3, sps), xadj(l, j, k, 1, sps), xadj(l, j, k&
   &         , 2, sps), xadj(l, j, k, 3, sps), xp, yp, zp, vp5)
   CALL VOLPYM4(xadj(i, j, n, 1, sps), xadj(i, j, n, 2, sps), xadj(i, j, &
   &         n, 3, sps), xadj(l, j, n, 1, sps), xadj(l, j, n, 2, sps), xadj&
   &         (l, j, n, 3, sps), xadj(l, m, n, 1, sps), xadj(l, m, n, 2, sps&
   &         ), xadj(l, m, n, 3, sps), xadj(i, m, n, 1, sps), xadj(i, m, n&
   &         , 2, sps), xadj(i, m, n, 3, sps), xp, yp, zp, vp6)
   ! Set the volume to 1/6 of the sum of the volumes of the
   ! pyramid. Remember that volpym computes 6 times the
   ! volume.
   voladj(sps) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
   ! Check the volume and update the number of positive
   ! and negative volumes if needed.
   IF (checkall) THEN
   ! Update either the number of negative or positive
   ! volumes. Negative volumes should only occur for left
   ! handed blocks. This is checked later.
   ! Set the logical volumeIsNeg accordingly.
   IF (voladj(sps) .LT. zero) THEN
   CALL PUSHINTEGER4(1)
   ELSE
   nvolpos = nvolpos + 1
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (voladj(sps) .GE. 0.) THEN
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   !!$           ! Some additional safety stuff for halo volumes.
   !!$
   !!$           do k=2,kl
   !!$             do j=2,jl
   !!$               if(vol(1, j,k) <= eps) vol(1, j,k) = vol(2, j,k)
   !!$               if(vol(ie,j,k) <= eps) vol(ie,j,k) = vol(il,j,k)
   !!$             enddo
   !!$           enddo
   !!$
   !!$           do k=2,kl
   !!$             do i=1,ie
   !!$               if(vol(i,1, k) <= eps) vol(i,1, k) = vol(i,2, k)
   !!$               if(vol(i,je,k) <= eps) vol(i,je,k) = vol(i,jl,k)
   !!$             enddo
   !!$           enddo
   !!$
   !!$           do j=1,je
   !!$             do i=1,ie
   !!$               if(vol(i,j,1)  <= eps) vol(i,j,1)  = vol(i,j,2)
   !!$               if(vol(i,j,ke) <= eps) vol(i,j,ke) = vol(i,j,kl)
   !!$             enddo
   !!$           enddo
   ! Determine the orientation of the block. For the fine level
   ! this is based on the number of positive and negative
   ! volumes; on the coarse levels the corresponding fine level
   ! value is taken. If both positive and negative volumes are
   ! present it is assumed that the block was intended to be
   ! right handed. The code will terminate later on anyway.
   IF (level .EQ. 1) THEN
   IF (nvolpos .EQ. 0) THEN
   ! Left handed block.
   righthanded = .false.
   CALL PUSHINTEGER4(0)
   ELSE
   ! Right handed (or bad) block.
   righthanded = .true.
   CALL PUSHINTEGER4(1)
   END IF
   !
   !          **************************************************************
   !          *                                                            *
   !          * Computation of the face normals in i-, j- and k-direction. *
   !          * Formula's are valid for a right handed block; for a left   *
   !          * handed block the correct orientation is obtained via fact. *
   !          * The normals point in the direction of increasing index.    *
   !          * The absolute value of fact is 0.5, because the cross       *
   !          * product of the two diagonals is twice the normal vector.   *
   !          *                                                            *
   !          * Note that also the normals of the first level halo cells   *
   !          * are computed. These are needed for the viscous fluxes.     *
   !          *                                                            *
   !          **************************************************************
   !
   IF (righthanded) THEN
   fact = half
   CALL PUSHINTEGER4(0)
   ELSE
   fact = -half
   CALL PUSHINTEGER4(1)
   END IF
   ! Projected areas of cell faces in the i direction.
   kstart = -2
   kend = 2
   jstart = -2
   jend = 2
   istart = -3
   iend = 2
   IF (icell .EQ. il) THEN
   iend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. 2) THEN
   istart = -2
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. 2) THEN
   jstart = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   jend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   kstart = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   kend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ad_from = kstart
   CALL PUSHINTEGER4(k)
   !-2,2
   DO k=ad_from,kend
   CALL PUSHINTEGER4(n)
   n = k - 1
   ad_from0 = jstart
   CALL PUSHINTEGER4(j)
   !-2,2
   DO j=ad_from0,jend
   CALL PUSHINTEGER4(m)
   m = j - 1
   ad_from1 = istart
   CALL PUSHINTEGER4(i)
   !-2,2
   DO i=ad_from1,iend
   CALL PUSHREAL8(v1(1))
   ! Determine the two diagonal vectors of the face.
   v1(1) = xadj(i, j, n, 1, sps) - xadj(i, m, k, 1, sps)
   CALL PUSHREAL8(v1(2))
   v1(2) = xadj(i, j, n, 2, sps) - xadj(i, m, k, 2, sps)
   CALL PUSHREAL8(v1(3))
   v1(3) = xadj(i, j, n, 3, sps) - xadj(i, m, k, 3, sps)
   CALL PUSHREAL8(v2(1))
   v2(1) = xadj(i, j, k, 1, sps) - xadj(i, m, n, 1, sps)
   CALL PUSHREAL8(v2(2))
   v2(2) = xadj(i, j, k, 2, sps) - xadj(i, m, n, 2, sps)
   CALL PUSHREAL8(v2(3))
   v2(3) = xadj(i, j, k, 3, sps) - xadj(i, m, n, 3, sps)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   siadj(i, j, k, 1, sps) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   siadj(i, j, k, 2, sps) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   siadj(i, j, k, 3, sps) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from)
   ! Projected areas of cell faces in the j direction.
   kstart = -2
   kend = 2
   jstart = -3
   jend = 2
   istart = -2
   iend = 2
   IF (icell .EQ. 2) THEN
   istart = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   iend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   jend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. 2) THEN
   jstart = -2
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   kstart = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   kend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ad_from2 = kstart
   !-2,2
   DO k=ad_from2,kend
   CALL PUSHINTEGER4(n)
   n = k - 1
   ad_from3 = jstart
   CALL PUSHINTEGER4(j)
   !-2,2
   DO j=ad_from3,jend
   ad_from4 = istart
   CALL PUSHINTEGER4(i)
   !-2,2
   DO i=ad_from4,iend
   CALL PUSHINTEGER4(l)
   l = i - 1
   CALL PUSHREAL8(v1(1))
   ! Determine the two diagonal vectors of the face.
   v1(1) = xadj(i, j, n, 1, sps) - xadj(l, j, k, 1, sps)
   CALL PUSHREAL8(v1(2))
   v1(2) = xadj(i, j, n, 2, sps) - xadj(l, j, k, 2, sps)
   CALL PUSHREAL8(v1(3))
   v1(3) = xadj(i, j, n, 3, sps) - xadj(l, j, k, 3, sps)
   CALL PUSHREAL8(v2(1))
   v2(1) = xadj(l, j, n, 1, sps) - xadj(i, j, k, 1, sps)
   CALL PUSHREAL8(v2(2))
   v2(2) = xadj(l, j, n, 2, sps) - xadj(i, j, k, 2, sps)
   CALL PUSHREAL8(v2(3))
   v2(3) = xadj(l, j, n, 3, sps) - xadj(i, j, k, 3, sps)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   sjadj(i, j, k, 1, sps) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   sjadj(i, j, k, 2, sps) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   sjadj(i, j, k, 3, sps) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from4)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from2)
   !print *,'sj2', sjAdj(i,j,k,2),sj(icell+i,jcell+j,kcell+k,2),i,j,k,icell+i,jcell+j,kcell+k
   ! Projected areas of cell faces in the k direction.
   kstart = -3
   kend = 2
   jstart = -2
   jend = 2
   istart = -2
   iend = 2
   IF (icell .EQ. 2) THEN
   istart = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   iend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. 2) THEN
   jstart = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   jend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   kend = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   kstart = -2
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   !-2,2
   DO k=kstart,kend
   CALL PUSHINTEGER4(j)
   !-2,2
   DO j=jstart,jend
   CALL PUSHINTEGER4(m)
   m = j - 1
   CALL PUSHINTEGER4(i)
   !-2,2
   DO i=istart,iend
   CALL PUSHINTEGER4(l)
   l = i - 1
   CALL PUSHREAL8(v1(1))
   ! Determine the two diagonal vectors of the face.
   v1(1) = xadj(i, j, k, 1, sps) - xadj(l, m, k, 1, sps)
   CALL PUSHREAL8(v1(2))
   v1(2) = xadj(i, j, k, 2, sps) - xadj(l, m, k, 2, sps)
   CALL PUSHREAL8(v1(3))
   v1(3) = xadj(i, j, k, 3, sps) - xadj(l, m, k, 3, sps)
   CALL PUSHREAL8(v2(1))
   v2(1) = xadj(l, j, k, 1, sps) - xadj(i, m, k, 1, sps)
   CALL PUSHREAL8(v2(2))
   v2(2) = xadj(l, j, k, 2, sps) - xadj(i, m, k, 2, sps)
   CALL PUSHREAL8(v2(3))
   v2(3) = xadj(l, j, k, 3, sps) - xadj(i, m, k, 3, sps)
   !print *,'in metric',v2,'x',xAdj(l,j,k,sps),xAdj(i,m,k,sps)
   !print *,'indices',l,j,k,i,m,k
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   skadj(i, j, k, 1, sps) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   skadj(i, j, k, 2, sps) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   skadj(i, j, k, 3, sps) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   !
   !        **************************************************************
   !        *                                                            *
   !        * If the considering cell is on the subfaces, then compute   *
   !        * normAdj(-2:2,-2:2,-2:2,3). Otherwise return!               *
   !        *                                                            *
   !        * The unit normals on the boundary faces. These always point *
   !        *  out of the domain, so a multiplication by -1 is needed for *
   !        * the iMin, jMin and kMin boundaries.                        *
   !        *                                                            *
   !        **************************************************************
   !
   ! Determine the range of the stencil for the given cell.
   isbeg = icell - 2
   isend = icell + 2
   jsbeg = jcell - 2
   jsend = jcell + 2
   ksbeg = kcell - 2
   ksend = kcell + 2
   ! Loop over the number of physical boundary subfaces of the block.
   bocoloop:DO mm=1,nbocos
   ! Determine the range of halo cells which this boundary subface
   ! will change.
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   ibbeg = 0
   ibend = 1
   jbbeg = bcdata(mm)%icbeg
   jbend = bcdata(mm)%icend
   kbbeg = bcdata(mm)%jcbeg
   kbend = bcdata(mm)%jcend
   CALL PUSHINTEGER4(1)
   CASE (imax) 
   !=============================================================
   ibbeg = ie
   ibend = ib
   jbbeg = bcdata(mm)%icbeg
   jbend = bcdata(mm)%icend
   kbbeg = bcdata(mm)%jcbeg
   kbend = bcdata(mm)%jcend
   CALL PUSHINTEGER4(2)
   CASE (jmin) 
   !=============================================================
   ibbeg = bcdata(mm)%icbeg
   ibend = bcdata(mm)%icend
   jbbeg = 0
   jbend = 1
   kbbeg = bcdata(mm)%jcbeg
   kbend = bcdata(mm)%jcend
   CALL PUSHINTEGER4(3)
   CASE (jmax) 
   !=============================================================
   ibbeg = bcdata(mm)%icbeg
   ibend = bcdata(mm)%icend
   jbbeg = je
   jbend = jb
   kbbeg = bcdata(mm)%jcbeg
   kbend = bcdata(mm)%jcend
   CALL PUSHINTEGER4(4)
   CASE (kmin) 
   !=============================================================
   ibbeg = bcdata(mm)%icbeg
   ibend = bcdata(mm)%icend
   jbbeg = bcdata(mm)%jcbeg
   jbend = bcdata(mm)%jcend
   kbbeg = 0
   kbend = 1
   CALL PUSHINTEGER4(5)
   CASE (kmax) 
   !=============================================================
   ibbeg = bcdata(mm)%icbeg
   ibend = bcdata(mm)%icend
   jbbeg = bcdata(mm)%jcbeg
   jbend = bcdata(mm)%jcend
   kbbeg = ke
   kbend = kb
   CALL PUSHINTEGER4(6)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ! Check for an overlap between the stencil range and the
   ! halo cells influenced by this boundary subface.
   ioverlap = .false.
   IF (isbeg .LE. ibend .AND. isend .GE. ibbeg) THEN
   ioverlap = .true.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   joverlap = .false.
   IF (jsbeg .LE. jbend .AND. jsend .GE. jbbeg) THEN
   joverlap = .true.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   koverlap = .false.
   IF (ksbeg .LE. kbend .AND. ksend .GE. kbbeg) THEN
   koverlap = .true.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (ioverlap .AND. joverlap .AND. koverlap) THEN
   IF (isbeg .LT. ibbeg) THEN
   irbeg = ibbeg
   CALL PUSHINTEGER4(1)
   ELSE
   irbeg = isbeg
   CALL PUSHINTEGER4(0)
   END IF
   IF (isend .GT. ibend) THEN
   irend = ibend
   CALL PUSHINTEGER4(1)
   ELSE
   irend = isend
   CALL PUSHINTEGER4(0)
   END IF
   IF (jsbeg .LT. jbbeg) THEN
   jrbeg = jbbeg
   CALL PUSHINTEGER4(1)
   ELSE
   jrbeg = jsbeg
   CALL PUSHINTEGER4(0)
   END IF
   IF (jsend .GT. jbend) THEN
   jrend = jbend
   CALL PUSHINTEGER4(1)
   ELSE
   jrend = jsend
   CALL PUSHINTEGER4(0)
   END IF
   IF (ksbeg .LT. kbbeg) THEN
   krbeg = kbbeg
   CALL PUSHINTEGER4(1)
   ELSE
   krbeg = ksbeg
   CALL PUSHINTEGER4(0)
   END IF
   IF (ksend .GT. kbend) THEN
   krend = kbend
   CALL PUSHINTEGER4(1)
   ELSE
   krend = ksend
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHINTEGER4(ist)
   ist = -2
   CALL PUSHINTEGER4(ien)
   ien = 2
   CALL PUSHINTEGER4(jst)
   jst = -2
   CALL PUSHINTEGER4(jen)
   jen = 2
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   IF (jcell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (irbeg .EQ. irend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = -one
   ss(ist:ien, jst:jen, :) = siadj(-1, ist:ien, jst:jen, :, sps&
   &              )
   CALL PUSHINTEGER4(11)
   ELSE
   CALL PUSHREAL8(mult)
   mult = -one
   ss(ist:ien, jst:jen, :) = siadj(-2, ist:ien, jst:jen, :, sps&
   &              )
   CALL PUSHINTEGER4(12)
   END IF
   CASE (imax) 
   IF (jcell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (irbeg .EQ. irend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = one
   ss(ist:ien, jst:jen, :) = siadj(0, ist:ien, jst:jen, :, sps)
   CALL PUSHINTEGER4(9)
   ELSE
   CALL PUSHREAL8(mult)
   mult = one
   ss(ist:ien, jst:jen, :) = siadj(1, ist:ien, jst:jen, :, sps)
   CALL PUSHINTEGER4(10)
   END IF
   CASE (jmin) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (jrbeg .EQ. jrend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = -one
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -1, jst:jen, :, sps&
   &              )
   CALL PUSHINTEGER4(7)
   ELSE
   CALL PUSHREAL8(mult)
   mult = -one
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -2, jst:jen, :, sps&
   &              )
   CALL PUSHINTEGER4(8)
   END IF
   CASE (jmax) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (jrbeg .EQ. jrend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = one
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 0, jst:jen, :, sps)
   CALL PUSHINTEGER4(5)
   ELSE
   CALL PUSHREAL8(mult)
   mult = one
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 1, jst:jen, :, sps)
   CALL PUSHINTEGER4(6)
   END IF
   CASE (kmin) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (krbeg .EQ. krend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = -one
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -1, :, sps&
   &              )
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHREAL8(mult)
   mult = -one
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -2, :, sps&
   &              )
   CALL PUSHINTEGER4(4)
   END IF
   CASE (kmax) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (krbeg .EQ. krend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = one
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 0, :, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHREAL8(mult)
   mult = one
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 1, :, sps)
   CALL PUSHINTEGER4(2)
   END IF
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from5 = jst
   DO kk=ad_from5,jen
   ad_from6 = ist
   DO jj=ad_from6,ien
   CALL PUSHREAL8(xp)
   ! Compute the inverse of the length of the normal vector
   ! and possibly correct for inward pointing.
   xp = ss(jj, kk, 1)
   CALL PUSHREAL8(yp)
   yp = ss(jj, kk, 2)
   CALL PUSHREAL8(zp)
   zp = ss(jj, kk, 3)
   !!$                       fact = sqrt(xp*xp + yp*yp + zp*zp)
   !!$                       if(fact > zero) fact = mult/fact
   !!$                       
   !!$                       ! Compute the unit normal.
   !!$                       
   !!$                       normAdj(mm,jj,kk,1) = fact*xp
   !!$                       normAdj(mm,jj,kk,2) = fact*yp
   !!$                       normAdj(mm,jj,kk,3) = fact*zp
   !alternate form to allow inclusion of degenrate halos???
   IF (xp**2 .GT. zero .OR. yp**2 .GT. zero .OR. zp**2 .GT. &
   &                zero) THEN
   CALL PUSHREAL8(fact)
   !if (fact > zero)then
   !compute length
   fact = SQRT(xp*xp + yp*yp + zp*zp)
   CALL PUSHREAL8(fact)
   !set factor to 1/length
   fact = mult/fact
   !compute unit normal...
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   END DO
   CALL PUSHINTEGER4(jj - 1)
   CALL PUSHINTEGER4(ad_from6)
   END DO
   CALL PUSHINTEGER4(kk - 1)
   CALL PUSHINTEGER4(ad_from5)
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO bocoloop
   !
   !          **************************************************************
   !          *                                                            *
   !          * Check in debug mode the sum of the normals of the cells.   *
   !          * If everything is correct this should sum up to zero.       *
   !          *                                                            *
   !          **************************************************************
   !
   IF (debug) THEN
   CALL PUSHINTEGER4(i)
   ! Loop over the cells including the 1st level halo's.
   i = 0
   CALL PUSHINTEGER4(j)
   j = 0
   k = 0
   CALL PUSHINTEGER4(l)
   l = i - 1
   CALL PUSHINTEGER4(m)
   m = j - 1
   CALL PUSHINTEGER4(n)
   n = k - 1
   ! Store the sum of the outward pointing surrounding
   ! normals in v1. Due to the outward convention the
   ! normals with the lowest index get a negative sign;
   ! normals point in the direction of the higher index.
   ! Store the inverse of the sum of the areas of the
   ! six faces in fact.
   temp29 = skadj(i, j, n, 3, sps)
   temp28 = skadj(i, j, n, 2, sps)
   temp27 = skadj(i, j, n, 1, sps)
   temp = temp27**2 + temp28**2 + temp29**2
   temp26 = SQRT(temp)
   temp25 = skadj(i, j, k, 3, sps)
   temp24 = skadj(i, j, k, 2, sps)
   temp23 = skadj(i, j, k, 1, sps)
   temp0 = temp23**2 + temp24**2 + temp25**2
   temp22 = SQRT(temp0)
   temp21 = sjadj(i, m, k, 3, sps)
   temp20 = sjadj(i, m, k, 2, sps)
   temp19 = sjadj(i, m, k, 1, sps)
   temp1 = temp19**2 + temp20**2 + temp21**2
   temp18 = SQRT(temp1)
   temp17 = sjadj(i, j, k, 3, sps)
   temp16 = sjadj(i, j, k, 2, sps)
   temp15 = sjadj(i, j, k, 1, sps)
   temp2 = temp15**2 + temp16**2 + temp17**2
   temp14 = SQRT(temp2)
   temp13 = siadj(l, j, k, 3, sps)
   temp12 = siadj(l, j, k, 2, sps)
   temp11 = siadj(l, j, k, 1, sps)
   temp3 = temp11**2 + temp12**2 + temp13**2
   temp10 = SQRT(temp3)
   temp9 = siadj(i, j, k, 3, sps)
   temp8 = siadj(i, j, k, 2, sps)
   temp7 = siadj(i, j, k, 1, sps)
   temp4 = temp7**2 + temp8**2 + temp9**2
   temp6 = SQRT(temp4)
   temp5 = temp6 + temp10 + temp14 + temp18 + temp22 + temp26
   temp5b = -(one*factb/temp5**2)
   temp4b = temp5b/(2.0*temp6)
   temp3b = temp5b/(2.0*temp10)
   temp2b = temp5b/(2.0*temp14)
   temp1b = temp5b/(2.0*temp18)
   temp0b = temp5b/(2.0*temp22)
   tempb13 = temp5b/(2.0*temp26)
   CALL POPINTEGER4(n)
   CALL POPINTEGER4(m)
   CALL POPINTEGER4(l)
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(i)
   END IF
   ssb(-2:2, -2:2, 1:3) = 0.0
   DO mm=nbocos,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO kk=ad_to5,ad_from5,-1
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO jj=ad_to6,ad_from6,-1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   factb = zp*normadjb(mm, jj, kk, 3, sps)
   zpb = fact*normadjb(mm, jj, kk, 3, sps)
   normadjb(mm, jj, kk, 3, sps) = 0.0
   factb = factb + yp*normadjb(mm, jj, kk, 2, sps)
   ypb = fact*normadjb(mm, jj, kk, 2, sps)
   normadjb(mm, jj, kk, 2, sps) = 0.0
   factb = factb + xp*normadjb(mm, jj, kk, 1, sps)
   xpb = fact*normadjb(mm, jj, kk, 1, sps)
   normadjb(mm, jj, kk, 1, sps) = 0.0
   CALL POPREAL8(fact)
   factb = -(mult*factb/fact**2)
   CALL POPREAL8(fact)
   tempb12 = factb/(2.0*SQRT(xp**2+yp**2+zp**2))
   xpb = xpb + 2*xp*tempb12
   ypb = ypb + 2*yp*tempb12
   zpb = zpb + 2*zp*tempb12
   ELSE
   normadjb(mm, jj, kk, :, sps) = 0.0
   xpb = 0.0
   ypb = 0.0
   zpb = 0.0
   END IF
   CALL POPREAL8(zp)
   ssb(jj, kk, 3) = ssb(jj, kk, 3) + zpb
   CALL POPREAL8(yp)
   ssb(jj, kk, 2) = ssb(jj, kk, 2) + ypb
   CALL POPREAL8(xp)
   ssb(jj, kk, 1) = ssb(jj, kk, 1) + xpb
   END DO
   END DO
   CALL POPINTEGER4(branch)
   IF (branch .LT. 7) THEN
   IF (branch .LT. 4) THEN
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   GOTO 120
   ELSE
   skadjb(ist:ien, jst:jen, 0, :, sps) = skadjb(ist:ien, &
   &                  jst:jen, 0, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .LT. 3) THEN
   skadjb(ist:ien, jst:jen, 1, :, sps) = skadjb(ist:ien, jst:&
   &                jen, 1, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   ELSE
   skadjb(ist:ien, jst:jen, -1, :, sps) = skadjb(ist:ien, jst&
   &                :jen, -1, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   GOTO 100
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   ELSE
   IF (branch .LT. 6) THEN
   IF (branch .LT. 5) THEN
   skadjb(ist:ien, jst:jen, -2, :, sps) = skadjb(ist:ien, &
   &                  jst:jen, -2, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   GOTO 100
   ELSE
   sjadjb(ist:ien, 0, jst:jen, :, sps) = sjadjb(ist:ien, 0&
   &                  , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE
   sjadjb(ist:ien, 1, jst:jen, :, sps) = sjadjb(ist:ien, 1, &
   &                jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END IF
   GOTO 120
   100      CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   ELSE
   IF (branch .LT. 10) THEN
   IF (branch .LT. 9) THEN
   IF (branch .LT. 8) THEN
   sjadjb(ist:ien, -1, jst:jen, :, sps) = sjadjb(ist:ien, -&
   &                  1, jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   ELSE
   sjadjb(ist:ien, -2, jst:jen, :, sps) = sjadjb(ist:ien, -&
   &                  2, jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   GOTO 120
   ELSE
   siadjb(0, ist:ien, jst:jen, :, sps) = siadjb(0, ist:ien, &
   &                jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE
   IF (branch .LT. 12) THEN
   IF (branch .LT. 11) THEN
   siadjb(1, ist:ien, jst:jen, :, sps) = siadjb(1, ist:ien&
   &                  , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   GOTO 110
   ELSE
   siadjb(-1, ist:ien, jst:jen, :, sps) = siadjb(-1, ist:&
   &                  ien, jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE
   siadjb(-2, ist:ien, jst:jen, :, sps) = siadjb(-2, ist:ien&
   &                , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   GOTO 120
   END IF
   110      CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END IF
   120    CALL POPINTEGER4(jen)
   CALL POPINTEGER4(jst)
   CALL POPINTEGER4(ien)
   CALL POPINTEGER4(ist)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END DO
   v1b(1:3) = 0.0
   v2b(1:3) = 0.0
   DO k=kend,kstart,-1
   DO j=jend,jstart,-1
   DO i=iend,istart,-1
   tempb9 = fact*skadjb(i, j, k, 3, sps)
   v1b(1) = v1b(1) + v2(2)*tempb9
   v2b(2) = v2b(2) + v1(1)*tempb9
   v1b(2) = v1b(2) - v2(1)*tempb9
   skadjb(i, j, k, 3, sps) = 0.0
   tempb10 = fact*skadjb(i, j, k, 2, sps)
   v2b(1) = v2b(1) + v1(3)*tempb10 - v1(2)*tempb9
   v1b(3) = v1b(3) + v2(1)*tempb10
   v1b(1) = v1b(1) - v2(3)*tempb10
   skadjb(i, j, k, 2, sps) = 0.0
   tempb11 = fact*skadjb(i, j, k, 1, sps)
   v2b(3) = v2b(3) + v1(2)*tempb11 - v1(1)*tempb10
   v1b(2) = v1b(2) + v2(3)*tempb11
   v1b(3) = v1b(3) - v2(2)*tempb11
   v2b(2) = v2b(2) - v1(3)*tempb11
   skadjb(i, j, k, 1, sps) = 0.0
   CALL POPREAL8(v2(3))
   xadjb(l, j, k, 3, sps) = xadjb(l, j, k, 3, sps) + v2b(3)
   xadjb(i, m, k, 3, sps) = xadjb(i, m, k, 3, sps) - v2b(3)
   v2b(3) = 0.0
   CALL POPREAL8(v2(2))
   xadjb(l, j, k, 2, sps) = xadjb(l, j, k, 2, sps) + v2b(2)
   xadjb(i, m, k, 2, sps) = xadjb(i, m, k, 2, sps) - v2b(2)
   v2b(2) = 0.0
   CALL POPREAL8(v2(1))
   xadjb(l, j, k, 1, sps) = xadjb(l, j, k, 1, sps) + v2b(1)
   xadjb(i, m, k, 1, sps) = xadjb(i, m, k, 1, sps) - v2b(1)
   v2b(1) = 0.0
   CALL POPREAL8(v1(3))
   xadjb(i, j, k, 3, sps) = xadjb(i, j, k, 3, sps) + v1b(3)
   xadjb(l, m, k, 3, sps) = xadjb(l, m, k, 3, sps) - v1b(3)
   v1b(3) = 0.0
   CALL POPREAL8(v1(2))
   xadjb(i, j, k, 2, sps) = xadjb(i, j, k, 2, sps) + v1b(2)
   xadjb(l, m, k, 2, sps) = xadjb(l, m, k, 2, sps) - v1b(2)
   v1b(2) = 0.0
   CALL POPREAL8(v1(1))
   xadjb(i, j, k, 1, sps) = xadjb(i, j, k, 1, sps) + v1b(1)
   xadjb(l, m, k, 1, sps) = xadjb(l, m, k, 1, sps) - v1b(1)
   v1b(1) = 0.0
   CALL POPINTEGER4(l)
   END DO
   CALL POPINTEGER4(i)
   CALL POPINTEGER4(m)
   END DO
   CALL POPINTEGER4(j)
   END DO
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO k=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO j=ad_to3,ad_from3,-1
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO i=ad_to4,ad_from4,-1
   tempb6 = fact*sjadjb(i, j, k, 3, sps)
   v1b(1) = v1b(1) + v2(2)*tempb6
   v2b(2) = v2b(2) + v1(1)*tempb6
   v1b(2) = v1b(2) - v2(1)*tempb6
   sjadjb(i, j, k, 3, sps) = 0.0
   tempb7 = fact*sjadjb(i, j, k, 2, sps)
   v2b(1) = v2b(1) + v1(3)*tempb7 - v1(2)*tempb6
   v1b(3) = v1b(3) + v2(1)*tempb7
   v1b(1) = v1b(1) - v2(3)*tempb7
   sjadjb(i, j, k, 2, sps) = 0.0
   tempb8 = fact*sjadjb(i, j, k, 1, sps)
   v2b(3) = v2b(3) + v1(2)*tempb8 - v1(1)*tempb7
   v1b(2) = v1b(2) + v2(3)*tempb8
   v1b(3) = v1b(3) - v2(2)*tempb8
   v2b(2) = v2b(2) - v1(3)*tempb8
   sjadjb(i, j, k, 1, sps) = 0.0
   CALL POPREAL8(v2(3))
   xadjb(l, j, n, 3, sps) = xadjb(l, j, n, 3, sps) + v2b(3)
   xadjb(i, j, k, 3, sps) = xadjb(i, j, k, 3, sps) - v2b(3)
   v2b(3) = 0.0
   CALL POPREAL8(v2(2))
   xadjb(l, j, n, 2, sps) = xadjb(l, j, n, 2, sps) + v2b(2)
   xadjb(i, j, k, 2, sps) = xadjb(i, j, k, 2, sps) - v2b(2)
   v2b(2) = 0.0
   CALL POPREAL8(v2(1))
   xadjb(l, j, n, 1, sps) = xadjb(l, j, n, 1, sps) + v2b(1)
   xadjb(i, j, k, 1, sps) = xadjb(i, j, k, 1, sps) - v2b(1)
   v2b(1) = 0.0
   CALL POPREAL8(v1(3))
   xadjb(i, j, n, 3, sps) = xadjb(i, j, n, 3, sps) + v1b(3)
   xadjb(l, j, k, 3, sps) = xadjb(l, j, k, 3, sps) - v1b(3)
   v1b(3) = 0.0
   CALL POPREAL8(v1(2))
   xadjb(i, j, n, 2, sps) = xadjb(i, j, n, 2, sps) + v1b(2)
   xadjb(l, j, k, 2, sps) = xadjb(l, j, k, 2, sps) - v1b(2)
   v1b(2) = 0.0
   CALL POPREAL8(v1(1))
   xadjb(i, j, n, 1, sps) = xadjb(i, j, n, 1, sps) + v1b(1)
   xadjb(l, j, k, 1, sps) = xadjb(l, j, k, 1, sps) - v1b(1)
   v1b(1) = 0.0
   CALL POPINTEGER4(l)
   END DO
   CALL POPINTEGER4(i)
   END DO
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(n)
   END DO
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO k=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   tempb3 = fact*siadjb(i, j, k, 3, sps)
   v1b(1) = v1b(1) + v2(2)*tempb3
   v2b(2) = v2b(2) + v1(1)*tempb3
   v1b(2) = v1b(2) - v2(1)*tempb3
   siadjb(i, j, k, 3, sps) = 0.0
   tempb4 = fact*siadjb(i, j, k, 2, sps)
   v2b(1) = v2b(1) + v1(3)*tempb4 - v1(2)*tempb3
   v1b(3) = v1b(3) + v2(1)*tempb4
   v1b(1) = v1b(1) - v2(3)*tempb4
   siadjb(i, j, k, 2, sps) = 0.0
   tempb5 = fact*siadjb(i, j, k, 1, sps)
   v2b(3) = v2b(3) + v1(2)*tempb5 - v1(1)*tempb4
   v1b(2) = v1b(2) + v2(3)*tempb5
   v1b(3) = v1b(3) - v2(2)*tempb5
   v2b(2) = v2b(2) - v1(3)*tempb5
   siadjb(i, j, k, 1, sps) = 0.0
   CALL POPREAL8(v2(3))
   xadjb(i, j, k, 3, sps) = xadjb(i, j, k, 3, sps) + v2b(3)
   xadjb(i, m, n, 3, sps) = xadjb(i, m, n, 3, sps) - v2b(3)
   v2b(3) = 0.0
   CALL POPREAL8(v2(2))
   xadjb(i, j, k, 2, sps) = xadjb(i, j, k, 2, sps) + v2b(2)
   xadjb(i, m, n, 2, sps) = xadjb(i, m, n, 2, sps) - v2b(2)
   v2b(2) = 0.0
   CALL POPREAL8(v2(1))
   xadjb(i, j, k, 1, sps) = xadjb(i, j, k, 1, sps) + v2b(1)
   xadjb(i, m, n, 1, sps) = xadjb(i, m, n, 1, sps) - v2b(1)
   v2b(1) = 0.0
   CALL POPREAL8(v1(3))
   xadjb(i, j, n, 3, sps) = xadjb(i, j, n, 3, sps) + v1b(3)
   xadjb(i, m, k, 3, sps) = xadjb(i, m, k, 3, sps) - v1b(3)
   v1b(3) = 0.0
   CALL POPREAL8(v1(2))
   xadjb(i, j, n, 2, sps) = xadjb(i, j, n, 2, sps) + v1b(2)
   xadjb(i, m, k, 2, sps) = xadjb(i, m, k, 2, sps) - v1b(2)
   v1b(2) = 0.0
   CALL POPREAL8(v1(1))
   xadjb(i, j, n, 1, sps) = xadjb(i, j, n, 1, sps) + v1b(1)
   xadjb(i, m, k, 1, sps) = xadjb(i, m, k, 1, sps) - v1b(1)
   v1b(1) = 0.0
   END DO
   CALL POPINTEGER4(i)
   CALL POPINTEGER4(m)
   END DO
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(n)
   END DO
   CALL POPINTEGER4(k)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) voladjb(sps) = -voladjb(sps)
   CALL POPINTEGER4(branch)
   tempb = sixth*voladjb(sps)
   vp1b = tempb
   vp2b = tempb
   vp3b = tempb
   vp4b = tempb
   vp5b = tempb
   vp6b = tempb
   zpb = 0.0
   ypb = 0.0
   xpb = 0.0
   CALL VOLPYM4_B(xadj(i, j, n, 1, sps), xadjb(i, j, n, 1, sps), xadj(i&
   &             , j, n, 2, sps), xadjb(i, j, n, 2, sps), xadj(i, j, n, 3, &
   &             sps), xadjb(i, j, n, 3, sps), xadj(l, j, n, 1, sps), xadjb&
   &             (l, j, n, 1, sps), xadj(l, j, n, 2, sps), xadjb(l, j, n, 2&
   &             , sps), xadj(l, j, n, 3, sps), xadjb(l, j, n, 3, sps), &
   &             xadj(l, m, n, 1, sps), xadjb(l, m, n, 1, sps), xadj(l, m, &
   &             n, 2, sps), xadjb(l, m, n, 2, sps), xadj(l, m, n, 3, sps)&
   &             , xadjb(l, m, n, 3, sps), xadj(i, m, n, 1, sps), xadjb(i, &
   &             m, n, 1, sps), xadj(i, m, n, 2, sps), xadjb(i, m, n, 2, &
   &             sps), xadj(i, m, n, 3, sps), xadjb(i, m, n, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp6, vp6b)
   CALL VOLPYM4_B(xadj(i, j, k, 1, sps), xadjb(i, j, k, 1, sps), xadj(i&
   &             , j, k, 2, sps), xadjb(i, j, k, 2, sps), xadj(i, j, k, 3, &
   &             sps), xadjb(i, j, k, 3, sps), xadj(i, m, k, 1, sps), xadjb&
   &             (i, m, k, 1, sps), xadj(i, m, k, 2, sps), xadjb(i, m, k, 2&
   &             , sps), xadj(i, m, k, 3, sps), xadjb(i, m, k, 3, sps), &
   &             xadj(l, m, k, 1, sps), xadjb(l, m, k, 1, sps), xadj(l, m, &
   &             k, 2, sps), xadjb(l, m, k, 2, sps), xadj(l, m, k, 3, sps)&
   &             , xadjb(l, m, k, 3, sps), xadj(l, j, k, 1, sps), xadjb(l, &
   &             j, k, 1, sps), xadj(l, j, k, 2, sps), xadjb(l, j, k, 2, &
   &             sps), xadj(l, j, k, 3, sps), xadjb(l, j, k, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp5, vp5b)
   CALL VOLPYM4_B(xadj(i, m, k, 1, sps), xadjb(i, m, k, 1, sps), xadj(i&
   &             , m, k, 2, sps), xadjb(i, m, k, 2, sps), xadj(i, m, k, 3, &
   &             sps), xadjb(i, m, k, 3, sps), xadj(i, m, n, 1, sps), xadjb&
   &             (i, m, n, 1, sps), xadj(i, m, n, 2, sps), xadjb(i, m, n, 2&
   &             , sps), xadj(i, m, n, 3, sps), xadjb(i, m, n, 3, sps), &
   &             xadj(l, m, n, 1, sps), xadjb(l, m, n, 1, sps), xadj(l, m, &
   &             n, 2, sps), xadjb(l, m, n, 2, sps), xadj(l, m, n, 3, sps)&
   &             , xadjb(l, m, n, 3, sps), xadj(l, m, k, 1, sps), xadjb(l, &
   &             m, k, 1, sps), xadj(l, m, k, 2, sps), xadjb(l, m, k, 2, &
   &             sps), xadj(l, m, k, 3, sps), xadjb(l, m, k, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp4, vp4b)
   CALL VOLPYM4_B(xadj(i, j, k, 1, sps), xadjb(i, j, k, 1, sps), xadj(i&
   &             , j, k, 2, sps), xadjb(i, j, k, 2, sps), xadj(i, j, k, 3, &
   &             sps), xadjb(i, j, k, 3, sps), xadj(l, j, k, 1, sps), xadjb&
   &             (l, j, k, 1, sps), xadj(l, j, k, 2, sps), xadjb(l, j, k, 2&
   &             , sps), xadj(l, j, k, 3, sps), xadjb(l, j, k, 3, sps), &
   &             xadj(l, j, n, 1, sps), xadjb(l, j, n, 1, sps), xadj(l, j, &
   &             n, 2, sps), xadjb(l, j, n, 2, sps), xadj(l, j, n, 3, sps)&
   &             , xadjb(l, j, n, 3, sps), xadj(i, j, n, 1, sps), xadjb(i, &
   &             j, n, 1, sps), xadj(i, j, n, 2, sps), xadjb(i, j, n, 2, &
   &             sps), xadj(i, j, n, 3, sps), xadjb(i, j, n, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp3, vp3b)
   CALL VOLPYM4_B(xadj(l, j, k, 1, sps), xadjb(l, j, k, 1, sps), xadj(l&
   &             , j, k, 2, sps), xadjb(l, j, k, 2, sps), xadj(l, j, k, 3, &
   &             sps), xadjb(l, j, k, 3, sps), xadj(l, m, k, 1, sps), xadjb&
   &             (l, m, k, 1, sps), xadj(l, m, k, 2, sps), xadjb(l, m, k, 2&
   &             , sps), xadj(l, m, k, 3, sps), xadjb(l, m, k, 3, sps), &
   &             xadj(l, m, n, 1, sps), xadjb(l, m, n, 1, sps), xadj(l, m, &
   &             n, 2, sps), xadjb(l, m, n, 2, sps), xadj(l, m, n, 3, sps)&
   &             , xadjb(l, m, n, 3, sps), xadj(l, j, n, 1, sps), xadjb(l, &
   &             j, n, 1, sps), xadj(l, j, n, 2, sps), xadjb(l, j, n, 2, &
   &             sps), xadj(l, j, n, 3, sps), xadjb(l, j, n, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp2, vp2b)
   CALL VOLPYM4_B(xadj(i, j, k, 1, sps), xadjb(i, j, k, 1, sps), xadj(i&
   &             , j, k, 2, sps), xadjb(i, j, k, 2, sps), xadj(i, j, k, 3, &
   &             sps), xadjb(i, j, k, 3, sps), xadj(i, j, n, 1, sps), xadjb&
   &             (i, j, n, 1, sps), xadj(i, j, n, 2, sps), xadjb(i, j, n, 2&
   &             , sps), xadj(i, j, n, 3, sps), xadjb(i, j, n, 3, sps), &
   &             xadj(i, m, n, 1, sps), xadjb(i, m, n, 1, sps), xadj(i, m, &
   &             n, 2, sps), xadjb(i, m, n, 2, sps), xadj(i, m, n, 3, sps)&
   &             , xadjb(i, m, n, 3, sps), xadj(i, m, k, 1, sps), xadjb(i, &
   &             m, k, 1, sps), xadj(i, m, k, 2, sps), xadjb(i, m, k, 2, &
   &             sps), xadj(i, m, k, 3, sps), xadjb(i, m, k, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp1, vp1b)
   tempb0 = eighth*zpb
   xadjb(i, j, k, 3, sps) = xadjb(i, j, k, 3, sps) + tempb0
   xadjb(i, m, k, 3, sps) = xadjb(i, m, k, 3, sps) + tempb0
   xadjb(i, m, n, 3, sps) = xadjb(i, m, n, 3, sps) + tempb0
   xadjb(i, j, n, 3, sps) = xadjb(i, j, n, 3, sps) + tempb0
   xadjb(l, j, k, 3, sps) = xadjb(l, j, k, 3, sps) + tempb0
   xadjb(l, m, k, 3, sps) = xadjb(l, m, k, 3, sps) + tempb0
   xadjb(l, m, n, 3, sps) = xadjb(l, m, n, 3, sps) + tempb0
   xadjb(l, j, n, 3, sps) = xadjb(l, j, n, 3, sps) + tempb0
   tempb1 = eighth*ypb
   xadjb(i, j, k, 2, sps) = xadjb(i, j, k, 2, sps) + tempb1
   xadjb(i, m, k, 2, sps) = xadjb(i, m, k, 2, sps) + tempb1
   xadjb(i, m, n, 2, sps) = xadjb(i, m, n, 2, sps) + tempb1
   xadjb(i, j, n, 2, sps) = xadjb(i, j, n, 2, sps) + tempb1
   xadjb(l, j, k, 2, sps) = xadjb(l, j, k, 2, sps) + tempb1
   xadjb(l, m, k, 2, sps) = xadjb(l, m, k, 2, sps) + tempb1
   xadjb(l, m, n, 2, sps) = xadjb(l, m, n, 2, sps) + tempb1
   xadjb(l, j, n, 2, sps) = xadjb(l, j, n, 2, sps) + tempb1
   tempb2 = eighth*xpb
   xadjb(i, j, k, 1, sps) = xadjb(i, j, k, 1, sps) + tempb2
   xadjb(i, m, k, 1, sps) = xadjb(i, m, k, 1, sps) + tempb2
   xadjb(i, m, n, 1, sps) = xadjb(i, m, n, 1, sps) + tempb2
   xadjb(i, j, n, 1, sps) = xadjb(i, j, n, 1, sps) + tempb2
   xadjb(l, j, k, 1, sps) = xadjb(l, j, k, 1, sps) + tempb2
   xadjb(l, m, k, 1, sps) = xadjb(l, m, k, 1, sps) + tempb2
   xadjb(l, m, n, 1, sps) = xadjb(l, m, n, 1, sps) + tempb2
   xadjb(l, j, n, 1, sps) = xadjb(l, j, n, 1, sps) + tempb2
   END IF
   END SUBROUTINE METRICADJTS_B

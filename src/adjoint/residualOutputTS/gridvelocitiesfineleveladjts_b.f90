   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of gridvelocitiesfineleveladjts in reverse (adjoint) mode:
   !   gradient, with respect to input variables: rotrateadj alphaadj
   !                rotpointadj xadj betaadj machgridadj skadj rotcenteradj
   !                sjadj veldirfreestreamadj siadj sincoeffouralpha
   !                coscoeffouryrot sincoeffourbeta coscoeffourxrot
   !                coefpolmach coefpolzrot omegafourmach omegafouralpha
   !                omegafourzrot coefpolyrot omegafouryrot coefpolxrot
   !                coefpolalpha sincoeffourmach omegafourxrot sincoeffourzrot
   !                coscoeffourbeta sincoeffouryrot sincoeffourxrot
   !                coscoeffouralpha coefpolbeta omegafourbeta coscoeffourmach
   !                coscoeffourzrot
   !   of linear combination of output variables: rotrateadj xadj
   !                sfacekadj skadj sfacejadj sjadj sfaceiadj sadj
   !                siadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          gridVelocities.f90                              *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 02-23-2004                                      *
   !      * Last modified: 10-22-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE GRIDVELOCITIESFINELEVELADJTS_B(useoldcoor, t, sps, xadj, &
   &  xadjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, rotcenteradj, &
   &  rotcenteradjb, rotrateadj, rotrateadjb, sadj, sadjb, sfaceiadj, &
   &  sfaceiadjb, sfacejadj, sfacejadjb, sfacekadj, sfacekadjb, machgridadj&
   &  , machgridadjb, veldirfreestreamadj, veldirfreestreamadjb, &
   &  liftdirectionadj, alphaadj, alphaadjb, betaadj, betaadjb, liftindex, &
   &  icell, jcell, kcell, pointrefadj, rotpointadj, rotpointadjb, nn, &
   &  level)
   USE blockpointers
   USE cgnsgrid
   USE flowvarrefstate
   USE inputmotion
   USE inputphysics
   USE inputtimespectral
   USE inputtsstabderiv
   USE inputunsteady
   USE iteration
   USE monitor
   IMPLICIT NONE
   !      enddo domains
   REAL(KIND=REALTYPE) :: alphaadj, alphaadjb, betaadj, betaadjb
   INTEGER(KIND=INTTYPE), INTENT(IN) :: icell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: jcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: kcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: level
   REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: liftdirectionadj
   INTEGER(KIND=INTTYPE) :: liftindex
   REAL(KIND=REALTYPE), INTENT(IN) :: machgridadj
   REAL(KIND=REALTYPE) :: machgridadjb
   INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
   REAL(KIND=REALTYPE) :: pointrefadj(3)
   REAL(KIND=REALTYPE) :: rotcenteradj(3), rotcenteradjb(3), rotrateadj(3&
   &  ), rotrateadjb(3)
   REAL(KIND=REALTYPE) :: rotpointadj(3), rotpointadjb(3)
   REAL(KIND=REALTYPE) :: sadj(-2:2, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), sadjb(-2:2, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: sfaceiadj(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfaceiadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacejadj(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacejadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacekadj(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacekadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj
   REAL(KIND=REALTYPE) :: siadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), sjadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), skadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sjadj
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: skadj
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   REAL(KIND=REALTYPE), DIMENSION(*), INTENT(IN) :: t
   LOGICAL, INTENT(IN) :: useoldcoor
   REAL(KIND=REALTYPE), DIMENSION(3), INTENT(IN) :: veldirfreestreamadj
   REAL(KIND=REALTYPE) :: veldirfreestreamadjb(3)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: xadj
   REAL(KIND=REALTYPE) :: xadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   INTEGER :: ad_from, ad_from0, ad_from1, ad_from2, ad_from3, ad_from4, &
   &  ad_to, ad_to0, ad_to1, ad_to2, ad_to3, ad_to4, branch
   REAL(KIND=REALTYPE) :: alphaincrement, alphats, alphatsb, &
   &  betaincrement, betats, betatsb, intervalmach, tnew, told
   REAL(KIND=REALTYPE) :: alpha, alphab, beta, betab
   REAL(KIND=REALTYPE) :: derivrotationmatrixadj(3, 3)
   REAL(KIND=REALTYPE) :: dragdir(3), liftdir(3), veldir(3), veldirb(3)
   INTEGER(KIND=INTTYPE) :: i, ii, iie, j, jje, k, kke
   INTEGER(KIND=INTTYPE) :: iend, istart, jend, jstart, kend, kstart
   INTEGER(KIND=INTTYPE) :: mm
   REAL(KIND=REALTYPE) :: offsetvector(3), offsetvectorb(3)
   REAL(KIND=REALTYPE) :: oneover4dt, oneover8dt
   REAL(KIND=REALTYPE) :: rotationmatrixadj(3, 3)
   REAL(KIND=REALTYPE) :: rotationpointadj(3), rotationpointadjb(3)
   REAL(KIND=REALTYPE) :: rotratetemp(3), rotratetempb(3)
   REAL(KIND=REALTYPE) :: rotratetrans(3, 3), rotratetransb(3, 3)
   REAL(KIND=REALTYPE) :: sfaceadj(-2:2, -2:2), sfaceadjb(-2:2, -2:2)
   REAL(KIND=REALTYPE), DIMENSION(:, :, :), POINTER :: ss, xx
   REAL(KIND=REALTYPE) :: ssadj(-3:2, -3:2, 3), ssadjb(-3:2, -3:2, 3), &
   &  xxadj(-3:2, -3:2, 3), xxadjb(-3:2, -3:2, 3)
   REAL(KIND=REALTYPE) :: TSALPHA
   REAL(KIND=REALTYPE) :: TSBETA
   REAL(KIND=REALTYPE) :: TSMACH
   REAL(KIND=REALTYPE) :: ainf, velxgrid, velxgridb, velygrid, velygridb&
   &  , velzgrid, velzgridb
   REAL(KIND=REALTYPE) :: velxgrid0, velxgrid0b, velygrid0, velygrid0b, &
   &  velzgrid0, velzgrid0b
   REAL(KIND=REALTYPE) :: sc(3), scb(3), tempb, tempb0, tempb1, tempb2, &
   &  tempb3, tempb4, xc(3), xcb(3), xxc(3), xxcb(3)
   REAL(KIND=REALTYPE), DIMENSION(:, :, :, :), POINTER :: xxold
   INTRINSIC COS, SIN, SQRT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * gridVelocitiesFineLevel computes the grid velocities for       *
   !      * the cell centers and the normal grid velocities for the faces  *
   !      * of moving blocks for the currently finest grid, i.e.           *
   !      * groundLevel. The velocities are computed at time t for         *
   !      * spectral mode sps. If useOldCoor is .true. the velocities      *
   !      * are determined using the unsteady time integrator in           *
   !      * combination with the old coordinates; otherwise the analytic   *
   !      * form is used.                                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments.
   !
   !real(kind=realType), dimension(:,:), intent(out) :: sFace
   !new ADjoint variables
   !real(kind=realType) :: volAdj
   !real(kind=realType), dimension(nBocos,-2:2,-2:2,3), intent(out) :: normAdj
   !
   !      Local variables.
   !
   !real(kind=realType), dimension(:,:), pointer :: sFace
   !real(kind=realType)::alpha,beta
   !function definitions
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the mesh velocity from the given mesh Mach number.
   !  aInf = sqrt(gammaInf*pInf/rhoInf)
   !  velxGrid = aInf*MachGrid(1)
   !  velyGrid = aInf*MachGrid(2)
   !  velzGrid = aInf*MachGrid(3)acg[i][j]
   !velxGrid = zero
   !velyGrid = zero
   !velzGrid = zero
   ainf = SQRT(gammainf*pinf/rhoinf)
   velxgrid0 = ainf*machgridadj*(-veldirfreestreamadj(1))
   velygrid0 = ainf*machgridadj*(-veldirfreestreamadj(2))
   velzgrid0 = ainf*machgridadj*(-veldirfreestreamadj(3))
   ! Compute the derivative of the rotation matrix and the rotation
   ! point; needed for velocity due to the rigid body rotation of
   ! the entire grid. It is assumed that the rigid body motion of
   ! the grid is only specified if there is only 1 section present.
   CALL DERIVATIVEROTMATRIXRIGIDADJTS(derivrotationmatrixadj, &
   &                               rotationpointadj, rotpointadj, t(1))
   !compute the rotation matrix to update the velocities for the time
   !spectral stability derivative case...
   IF (tsstability) THEN
   ! Determine the time values of the old and new time level.
   ! It is assumed that the rigid body rotation of the mesh is only
   ! used when only 1 section is present.
   tnew = timeunsteady + timeunsteadyrestart
   told = tnew - t(1)
   !print *,'Time',t(1)
   IF (tspmode .OR. tsqmode .OR. tsrmode) THEN
   ! Compute the rotation matrix of the rigid body rotation as
   ! well as the rotation point; the latter may vary in time due
   ! to rigid body translation.
   CALL ROTMATRIXRIGIDBODYADJTS(tnew, told, rotationmatrixadj, &
   &                             rotationpointadj, rotpointadj)
   velxgrid0 = rotationmatrixadj(1, 1)*velxgrid0 + rotationmatrixadj(&
   &        1, 2)*velygrid0 + rotationmatrixadj(1, 3)*velzgrid0
   velygrid0 = rotationmatrixadj(2, 1)*velxgrid0 + rotationmatrixadj(&
   &        2, 2)*velygrid0 + rotationmatrixadj(2, 3)*velzgrid0
   velzgrid0 = rotationmatrixadj(3, 1)*velxgrid0 + rotationmatrixadj(&
   &        3, 2)*velygrid0 + rotationmatrixadj(3, 3)*velzgrid0
   CALL PUSHINTEGER4(1)
   ELSE IF (tsalphamode) THEN
   ! ! get the baseline alpha and determine the liftIndex
   ! call getDirAngle(velDirFreestreamAdj,liftDirectionAdj,&
   !      liftIndex,alpha,beta)
   !Determine the alpha for this time instance
   alphaincrement = TSALPHA(degreepolalpha, coefpolalpha, &
   &        degreefouralpha, omegafouralpha, coscoeffouralpha, &
   &        sincoeffouralpha, t(1))
   alphats = alphaadj + alphaincrement
   !Determine the grid velocity for this alpha
   CALL ADJUSTINFLOWANGLEADJTS(alphats, betaadj, veldir, liftdir, &
   &                            dragdir, liftindex)
   !do I need to update the lift direction and drag direction as well?
   !set the effictive grid velocity for this time interval
   velxgrid0 = ainf*machgridadj*(-veldir(1))
   velygrid0 = ainf*machgridadj*(-veldir(2))
   velzgrid0 = ainf*machgridadj*(-veldir(3))
   !print *,'base velocity',machgrid, velxGrid0 , velyGrid0 , velzGrid0 
   CALL PUSHINTEGER4(2)
   ELSE IF (tsbetamode) THEN
   !! get the baseline alpha and determine the liftIndex
   !call getDirAngle(velDirFreestreamAdj,liftDirectionAdj,liftIndex,alpha,beta)
   !Determine the alpha for this time instance
   betaincrement = TSBETA(degreepolbeta, coefpolbeta, degreefourbeta&
   &        , omegafourbeta, coscoeffourbeta, sincoeffourbeta, t(1))
   betats = betaadj + betaincrement
   !Determine the grid velocity for this alpha
   CALL ADJUSTINFLOWANGLEADJTS(alphaadj, betats, veldir, liftdir, &
   &                            dragdir, liftindex)
   !do I need to update the lift direction and drag direction as well?
   !set the effictive grid velocity for this time interval
   velxgrid0 = ainf*machgridadj*(-veldir(1))
   velygrid0 = ainf*machgridadj*(-veldir(2))
   velzgrid0 = ainf*machgridadj*(-veldir(3))
   CALL PUSHINTEGER4(3)
   ELSE IF (tsmachmode) THEN
   !determine the mach number at this time interval
   intervalmach = TSMACH(degreepolmach, coefpolmach, degreefourmach, &
   &        omegafourmach, coscoeffourmach, sincoeffourmach, t(1))
   !set the effective grid velocity
   velxgrid0 = ainf*(intervalmach+machgridadj)*(-veldirfreestreamadj(&
   &        1))
   velygrid0 = ainf*(intervalmach+machgridadj)*(-veldirfreestreamadj(&
   &        2))
   velzgrid0 = ainf*(intervalmach+machgridadj)*(-veldirfreestreamadj(&
   &        3))
   CALL PUSHINTEGER4(4)
   ELSE
   CALL PUSHINTEGER4(5)
   END IF
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   !!$!       ! Loop over the number of local blocks.
   !!$!
   !!$!       domains: do nn=1,nDom!
   !!$!
   !!$!         ! Set the pointers for this block.!
   !!$
   !!$!         call setPointers(nn, groundLevel, sps)!
   !!$!
   ! Check for a moving block.
   IF (blockismoving) THEN
   ! Determine the situation we are having here.
   IF (useoldcoor) THEN
   alphaadjb = 0.0
   rotpointadjb(1:3) = 0.0
   betaadjb = 0.0
   rotcenteradjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   rotationpointadjb(1:3) = 0.0
   velygrid0b = 0.0
   ELSE
   !
   !            ************************************************************
   !            *                                                          *
   !            * The velocities must be determined analytically.          *
   !            *                                                          *
   !            ************************************************************
   !
   !!! Pass these in, set them in copyADjointStencil.f90
   !!$
   !!$             ! Store the rotation center and determine the
   !!$             ! nonDimensional rotation rate of this block. As the
   !!$             ! reference length is 1 timeRef == 1/uRef and at the end
   !!$             ! the nonDimensional velocity is computed.
   !!$
   !!$             j = nbkGlobal
   !!$
   !!$             rotCenter = cgnsDoms(j)%rotCenter
   !!$             rotRate   = timeRef*cgnsDoms(j)%rotRate
   offsetvector = rotcenteradj - rotpointadj
   IF (usewindaxis) THEN
   alpha = alphaadj
   beta = betaadj
   !Rotate the rotation rate from the wind axis back to the local body axis
   IF (liftindex .EQ. 2) THEN
   ! different coordinate system for aerosurf
   ! Wing is in z- direction
   rotratetrans(1, 1) = COS(alpha)*COS(beta)
   rotratetrans(1, 2) = -SIN(alpha)
   rotratetrans(1, 3) = -(COS(alpha)*SIN(beta))
   rotratetrans(2, 1) = SIN(alpha)*COS(beta)
   rotratetrans(2, 2) = COS(alpha)
   rotratetrans(2, 3) = -(SIN(alpha)*SIN(beta))
   rotratetrans(3, 1) = SIN(beta)
   rotratetrans(3, 2) = 0.0
   rotratetrans(3, 3) = COS(beta)
   CALL PUSHINTEGER4(0)
   ELSE IF (liftindex .EQ. 3) THEN
   ! Wing is in y- direction
   !Rotate the rotation rate from the wind axis back to the local body axis
   rotratetrans(1, 1) = COS(alpha)*COS(beta)
   rotratetrans(1, 2) = -(COS(alpha)*SIN(beta))
   rotratetrans(1, 3) = -SIN(alpha)
   rotratetrans(2, 1) = SIN(beta)
   rotratetrans(2, 2) = COS(beta)
   rotratetrans(2, 3) = 0.0
   rotratetrans(3, 1) = SIN(alpha)*COS(beta)
   rotratetrans(3, 2) = -(SIN(alpha)*SIN(beta))
   rotratetrans(3, 3) = COS(alpha)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   !!$                rotRateTrans(1,1)=cos(alpha)*cos(beta)
   !!$                 rotRateTrans(1,2)=-cos(alpha)*sin(beta)
   !!$                 rotRateTrans(1,3)=-sin(alpha)
   !!$                 rotRateTrans(2,1)=sin(beta)
   !!$                 rotRateTrans(2,2)=cos(beta)
   !!$                 rotRateTrans(2,3)=0.0
   !!$                 rotRateTrans(3,1)=sin(alpha)*cos(beta)
   !!$                 rotRateTrans(3,2)=-sin(alpha)*sin(beta)
   !!$                 rotRateTrans(3,3)=cos(alpha)
   rotratetemp = rotrateadj
   rotrateadj = 0.0
   DO i=1,3
   DO j=1,3
   rotrateadj(i) = rotrateadj(i) + rotratetemp(j)*rotratetrans(&
   &              i, j)
   END DO
   END DO
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   !subtract off the rotational velocity of the center gravity of the grid
   ! to account for the added overall velocity.
   velxgrid = velxgrid0 + 1*(rotrateadj(2)*offsetvector(3)-rotrateadj&
   &        (3)*offsetvector(2)) + derivrotationmatrixadj(1, 1)*&
   &        offsetvector(1) + derivrotationmatrixadj(1, 2)*offsetvector(2) &
   &        + derivrotationmatrixadj(1, 3)*offsetvector(3)
   velygrid = velygrid0 + 1*(rotrateadj(3)*offsetvector(1)-rotrateadj&
   &        (1)*offsetvector(3)) + derivrotationmatrixadj(2, 1)*&
   &        offsetvector(1) + derivrotationmatrixadj(2, 2)*offsetvector(2) &
   &        + derivrotationmatrixadj(2, 3)*offsetvector(3)
   velzgrid = velzgrid0 + 1*(rotrateadj(1)*offsetvector(2)-rotrateadj&
   &        (2)*offsetvector(1)) + derivrotationmatrixadj(3, 1)*&
   &        offsetvector(1) + derivrotationmatrixadj(3, 2)*offsetvector(2) &
   &        + derivrotationmatrixadj(3, 3)*offsetvector(3)
   !
   !            ************************************************************
   !            *                                                          *
   !            * Grid velocities of the cell centers, including the       *
   !            * 1st level halo cells.                                    *
   !            *                                                          *
   !            ************************************************************
   !
   ! Loop over the cells, including the 1st level halo's.
   kstart = -2
   kend = 2
   jstart = -2
   jend = 2
   istart = -2
   iend = 2
   ad_from = kstart
   !-2,2
   DO k=ad_from,kend
   ad_from0 = jstart
   !-2,2
   DO j=ad_from0,jend
   ad_from1 = istart
   !-2,2
   DO i=ad_from1,iend
   !!$             do k=1,ke
   !!$               do j=1,je
   !!$                 do i=1,ie
   ! Determine the coordinates of the cell center,
   ! which are stored in xc.
   xc(1) = eighth*(xadj(i-1, j-1, k-1, 1, sps)+xadj(i, j-1, k-1&
   &              , 1, sps)+xadj(i-1, j, k-1, 1, sps)+xadj(i, j, k-1, 1, &
   &              sps)+xadj(i-1, j-1, k, 1, sps)+xadj(i, j-1, k, 1, sps)+&
   &              xadj(i-1, j, k, 1, sps)+xadj(i, j, k, 1, sps))
   xc(2) = eighth*(xadj(i-1, j-1, k-1, 2, sps)+xadj(i, j-1, k-1&
   &              , 2, sps)+xadj(i-1, j, k-1, 2, sps)+xadj(i, j, k-1, 2, &
   &              sps)+xadj(i-1, j-1, k, 2, sps)+xadj(i, j-1, k, 2, sps)+&
   &              xadj(i-1, j, k, 2, sps)+xadj(i, j, k, 2, sps))
   xc(3) = eighth*(xadj(i-1, j-1, k-1, 3, sps)+xadj(i, j-1, k-1&
   &              , 3, sps)+xadj(i-1, j, k-1, 3, sps)+xadj(i, j, k-1, 3, &
   &              sps)+xadj(i-1, j-1, k, 3, sps)+xadj(i, j-1, k, 3, sps)+&
   &              xadj(i-1, j, k, 3, sps)+xadj(i, j, k, 3, sps))
   CALL PUSHREAL8(xxc(1))
   ! Determine the coordinates relative to the
   ! center of rotation.
   xxc(1) = xc(1) - rotcenteradj(1)
   CALL PUSHREAL8(xxc(2))
   xxc(2) = xc(2) - rotcenteradj(2)
   CALL PUSHREAL8(xxc(3))
   xxc(3) = xc(3) - rotcenteradj(3)
   ! Determine the rotation speed of the cell center,
   ! which is omega*r.
   sc(1) = rotrateadj(2)*xxc(3) - rotrateadj(3)*xxc(2)
   sc(2) = rotrateadj(3)*xxc(1) - rotrateadj(1)*xxc(3)
   sc(3) = rotrateadj(1)*xxc(2) - rotrateadj(2)*xxc(1)
   CALL PUSHREAL8(xxc(1))
   ! Determine the coordinates relative to the
   ! rigid body rotation point.
   xxc(1) = xc(1) - rotationpointadj(1)
   CALL PUSHREAL8(xxc(2))
   xxc(2) = xc(2) - rotationpointadj(2)
   CALL PUSHREAL8(xxc(3))
   xxc(3) = xc(3) - rotationpointadj(3)
   ! Determine the total velocity of the cell center.
   ! This is a combination of rotation speed of this
   ! block and the entire rigid body rotation.
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from)
   !
   !            ************************************************************
   !            *                                                          *
   !            * Normal grid velocities of the faces.                     *
   !            *                                                          *
   !            ************************************************************
   !
   ! Loop over the three directions.
   loopdirection:DO mm=1,3
   kstart = -2
   kend = 2
   jstart = -2
   jend = 2
   istart = -2
   iend = 2
   !if(iCell==2)  iStart=-1
   !if(iCell==il) iEnd=1
   !if(jCell==2)  jStart=-1
   !if(jCell==jl) jEnd=1 
   !if(kCell==kl) kEnd=1
   !if(kCell==2)  kStart=-2
   ! Set the upper boundaries depending on the direction.
   ad_from2 = istart
   !
   !              **********************************************************
   !              *                                                        *
   !              * Normal grid velocities in generalized i-direction.     *
   !              * mm == 1: i-direction                                   *
   !              * mm == 2: j-direction                                   *
   !              * mm == 3: k-direction                                   *
   !              *                                                        *
   !              **********************************************************
   !
   !do i=0,iie
   DO i=ad_from2,iend
   ! Set the pointers for the coordinates, normals and
   ! normal velocities for this generalized i-plane.
   ! This depends on the value of mm.
   SELECT CASE  (mm) 
   CASE (1_intType) 
   ! normals in i-direction
   xxadj = xadj(i, :, :, :, sps)
   CALL PUSHREAL8ARRAY(ssadj, 6**2*3)
   ssadj = siadj(i, :, :, :, sps)
   CALL PUSHINTEGER4(1)
   CASE (2_intType) 
   ! normals in j-direction
   xxadj = xadj(:, i, :, :, sps)
   CALL PUSHREAL8ARRAY(ssadj, 6**2*3)
   ssadj = sjadj(:, i, :, :, sps)
   CALL PUSHINTEGER4(2)
   CASE (3_intType) 
   ! normals in k-direction
   xxadj = xadj(:, :, i, :, sps)
   CALL PUSHREAL8ARRAY(ssadj, 6**2*3)
   ssadj = skadj(:, :, i, :, sps)
   CALL PUSHINTEGER4(3)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from3 = kstart
   ! Loop over the k and j-direction of this generalized
   ! i-face. Note that due to the usage of the pointer
   ! xx an offset of +1 must be used in the coordinate
   ! array, because x originally starts at 0 for the
   ! i, j and k indices.
   !do k=1,kke
   ! do j=1,jje
   DO k=ad_from3,kend
   ad_from4 = jstart
   DO j=ad_from4,jend
   ! Determine the coordinates of the face center,
   ! which are stored in xc.
   !xc(1) = fourth*(xxAdj(j+1,k+1,1) + xxAdj(j,k+1,1) &
   !      +         xxAdj(j+1,k,  1) + xxAdj(j,k,  1))
   !xc(2) = fourth*(xxAdj(j+1,k+1,2) + xxAdj(j,k+1,2) &
   !      +         xxAdj(j+1,k,  2) + xxAdj(j,k,  2))
   !xc(3) = fourth*(xxAdj(j+1,k+1,3) + xxAdj(j,k+1,3) &
   !      +         xxAdj(j+1,k,  3) + xxAdj(j,k,  3))
   xc(1) = fourth*(xxadj(j, k, 1)+xxadj(j-1, k, 1)+xxadj(j, k&
   &                -1, 1)+xxadj(j-1, k-1, 1))
   xc(2) = fourth*(xxadj(j, k, 2)+xxadj(j-1, k, 2)+xxadj(j, k&
   &                -1, 2)+xxadj(j-1, k-1, 2))
   xc(3) = fourth*(xxadj(j, k, 3)+xxadj(j-1, k, 3)+xxadj(j, k&
   &                -1, 3)+xxadj(j-1, k-1, 3))
   CALL PUSHREAL8(xxc(1))
   ! Determine the coordinates relative to the
   ! center of rotation.
   xxc(1) = xc(1) - rotcenteradj(1)
   CALL PUSHREAL8(xxc(2))
   xxc(2) = xc(2) - rotcenteradj(2)
   CALL PUSHREAL8(xxc(3))
   xxc(3) = xc(3) - rotcenteradj(3)
   CALL PUSHREAL8(sc(1))
   ! Determine the rotation speed of the face center,
   ! which is omega*r.
   sc(1) = rotrateadj(2)*xxc(3) - rotrateadj(3)*xxc(2)
   CALL PUSHREAL8(sc(2))
   sc(2) = rotrateadj(3)*xxc(1) - rotrateadj(1)*xxc(3)
   CALL PUSHREAL8(sc(3))
   sc(3) = rotrateadj(1)*xxc(2) - rotrateadj(2)*xxc(1)
   CALL PUSHREAL8(xxc(1))
   ! Determine the coordinates relative to the
   ! rigid body rotation point.
   xxc(1) = xc(1) - rotationpointadj(1)
   CALL PUSHREAL8(xxc(2))
   xxc(2) = xc(2) - rotationpointadj(2)
   CALL PUSHREAL8(xxc(3))
   xxc(3) = xc(3) - rotationpointadj(3)
   CALL PUSHREAL8(sc(1))
   ! Determine the total velocity of the cell face.
   ! This is a combination of rotation speed of this
   ! block and the entire rigid body rotation.
   sc(1) = sc(1) + velxgrid + derivrotationmatrixadj(1, 1)*&
   &                xxc(1) + derivrotationmatrixadj(1, 2)*xxc(2) + &
   &                derivrotationmatrixadj(1, 3)*xxc(3)
   CALL PUSHREAL8(sc(2))
   sc(2) = sc(2) + velygrid + derivrotationmatrixadj(2, 1)*&
   &                xxc(1) + derivrotationmatrixadj(2, 2)*xxc(2) + &
   &                derivrotationmatrixadj(2, 3)*xxc(3)
   CALL PUSHREAL8(sc(3))
   sc(3) = sc(3) + velzgrid + derivrotationmatrixadj(3, 1)*&
   &                xxc(1) + derivrotationmatrixadj(3, 2)*xxc(2) + &
   &                derivrotationmatrixadj(3, 3)*xxc(3)
   ! Store the dot product of grid velocity sc and
   ! the normal ss in sFace.
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from3)
   SELECT CASE  (mm) 
   CASE (1_intType) 
   CALL PUSHINTEGER4(2)
   CASE (2_intType) 
   CALL PUSHINTEGER4(3)
   CASE (3_intType) 
   CALL PUSHINTEGER4(4)
   CASE DEFAULT
   CALL PUSHINTEGER4(1)
   END SELECT
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from2)
   END DO loopdirection
   rotcenteradjb(1:3) = 0.0
   ssadjb(-3:2, -3:2, 1:3) = 0.0
   velygridb = 0.0
   xcb(1:3) = 0.0
   xxcb(1:3) = 0.0
   velzgridb = 0.0
   rotationpointadjb(1:3) = 0.0
   xxadjb(-3:2, -3:2, 1:3) = 0.0
   scb(1:3) = 0.0
   velxgridb = 0.0
   sfaceadjb(-2:2, -2:2) = 0.0
   DO mm=3,1,-1
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO i=ad_to2,ad_from2,-1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 3) THEN
   IF (.NOT.branch .LT. 2) THEN
   sfaceadjb = sfaceadjb + sfaceiadjb(i, :, :, sps)
   sfaceiadjb(i, :, :, sps) = 0.0
   END IF
   ELSE IF (branch .LT. 4) THEN
   sfaceadjb = sfaceadjb + sfacejadjb(:, i, :, sps)
   sfacejadjb(:, i, :, sps) = 0.0
   ELSE
   sfaceadjb = sfaceadjb + sfacekadjb(:, :, i, sps)
   sfacekadjb(:, :, i, sps) = 0.0
   END IF
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO k=ad_to3,ad_from3,-1
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   scb(1) = scb(1) + ssadj(j, k, 1)*sfaceadjb(j, k)
   ssadjb(j, k, 1) = ssadjb(j, k, 1) + sc(1)*sfaceadjb(j, k)
   scb(2) = scb(2) + ssadj(j, k, 2)*sfaceadjb(j, k)
   ssadjb(j, k, 2) = ssadjb(j, k, 2) + sc(2)*sfaceadjb(j, k)
   scb(3) = scb(3) + ssadj(j, k, 3)*sfaceadjb(j, k)
   ssadjb(j, k, 3) = ssadjb(j, k, 3) + sc(3)*sfaceadjb(j, k)
   sfaceadjb(j, k) = 0.0
   CALL POPREAL8(sc(3))
   velzgridb = velzgridb + scb(3)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(3, 1)*scb(3)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(3, 2)*scb(3)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(3, 3)*scb(3)
   CALL POPREAL8(sc(2))
   velygridb = velygridb + scb(2)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(2, 1)*scb(2)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(2, 2)*scb(2)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(2, 3)*scb(2)
   CALL POPREAL8(sc(1))
   velxgridb = velxgridb + scb(1)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(1, 1)*scb(1)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(1, 2)*scb(1)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(1, 3)*scb(1)
   CALL POPREAL8(xxc(3))
   xcb(3) = xcb(3) + xxcb(3)
   rotationpointadjb(3) = rotationpointadjb(3) - xxcb(3)
   xxcb(3) = 0.0
   CALL POPREAL8(xxc(2))
   xcb(2) = xcb(2) + xxcb(2)
   rotationpointadjb(2) = rotationpointadjb(2) - xxcb(2)
   xxcb(2) = 0.0
   CALL POPREAL8(xxc(1))
   xcb(1) = xcb(1) + xxcb(1)
   rotationpointadjb(1) = rotationpointadjb(1) - xxcb(1)
   xxcb(1) = 0.0
   CALL POPREAL8(sc(3))
   rotrateadjb(1) = rotrateadjb(1) + xxc(2)*scb(3)
   xxcb(2) = xxcb(2) + rotrateadj(1)*scb(3)
   rotrateadjb(2) = rotrateadjb(2) - xxc(1)*scb(3)
   xxcb(1) = xxcb(1) - rotrateadj(2)*scb(3)
   scb(3) = 0.0
   CALL POPREAL8(sc(2))
   rotrateadjb(3) = rotrateadjb(3) + xxc(1)*scb(2)
   xxcb(1) = xxcb(1) + rotrateadj(3)*scb(2)
   rotrateadjb(1) = rotrateadjb(1) - xxc(3)*scb(2)
   xxcb(3) = xxcb(3) - rotrateadj(1)*scb(2)
   scb(2) = 0.0
   CALL POPREAL8(sc(1))
   rotrateadjb(2) = rotrateadjb(2) + xxc(3)*scb(1)
   xxcb(3) = xxcb(3) + rotrateadj(2)*scb(1)
   rotrateadjb(3) = rotrateadjb(3) - xxc(2)*scb(1)
   xxcb(2) = xxcb(2) - rotrateadj(3)*scb(1)
   scb(1) = 0.0
   CALL POPREAL8(xxc(3))
   xcb(3) = xcb(3) + xxcb(3)
   rotcenteradjb(3) = rotcenteradjb(3) - xxcb(3)
   xxcb(3) = 0.0
   CALL POPREAL8(xxc(2))
   xcb(2) = xcb(2) + xxcb(2)
   rotcenteradjb(2) = rotcenteradjb(2) - xxcb(2)
   xxcb(2) = 0.0
   CALL POPREAL8(xxc(1))
   xcb(1) = xcb(1) + xxcb(1)
   rotcenteradjb(1) = rotcenteradjb(1) - xxcb(1)
   xxcb(1) = 0.0
   tempb2 = fourth*xcb(3)
   xxadjb(j, k, 3) = xxadjb(j, k, 3) + tempb2
   xxadjb(j-1, k, 3) = xxadjb(j-1, k, 3) + tempb2
   xxadjb(j, k-1, 3) = xxadjb(j, k-1, 3) + tempb2
   xxadjb(j-1, k-1, 3) = xxadjb(j-1, k-1, 3) + tempb2
   xcb(3) = 0.0
   tempb3 = fourth*xcb(2)
   xxadjb(j, k, 2) = xxadjb(j, k, 2) + tempb3
   xxadjb(j-1, k, 2) = xxadjb(j-1, k, 2) + tempb3
   xxadjb(j, k-1, 2) = xxadjb(j, k-1, 2) + tempb3
   xxadjb(j-1, k-1, 2) = xxadjb(j-1, k-1, 2) + tempb3
   xcb(2) = 0.0
   tempb4 = fourth*xcb(1)
   xxadjb(j, k, 1) = xxadjb(j, k, 1) + tempb4
   xxadjb(j-1, k, 1) = xxadjb(j-1, k, 1) + tempb4
   xxadjb(j, k-1, 1) = xxadjb(j, k-1, 1) + tempb4
   xxadjb(j-1, k-1, 1) = xxadjb(j-1, k-1, 1) + tempb4
   xcb(1) = 0.0
   END DO
   END DO
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(ssadj, 6**2*3)
   siadjb(i, :, :, :, sps) = siadjb(i, :, :, :, sps) + ssadjb
   xadjb(i, :, :, :, sps) = xadjb(i, :, :, :, sps) + xxadjb
   ssadjb(-3:2, -3:2, 1:3) = 0.0
   xxadjb(-3:2, -3:2, 1:3) = 0.0
   END IF
   ELSE IF (branch .LT. 3) THEN
   CALL POPREAL8ARRAY(ssadj, 6**2*3)
   sjadjb(:, i, :, :, sps) = sjadjb(:, i, :, :, sps) + ssadjb
   xadjb(:, i, :, :, sps) = xadjb(:, i, :, :, sps) + xxadjb
   ssadjb(-3:2, -3:2, 1:3) = 0.0
   xxadjb(-3:2, -3:2, 1:3) = 0.0
   ELSE
   CALL POPREAL8ARRAY(ssadj, 6**2*3)
   skadjb(:, :, i, :, sps) = skadjb(:, :, i, :, sps) + ssadjb
   xadjb(:, :, i, :, sps) = xadjb(:, :, i, :, sps) + xxadjb
   ssadjb(-3:2, -3:2, 1:3) = 0.0
   xxadjb(-3:2, -3:2, 1:3) = 0.0
   END IF
   END DO
   END DO
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO k=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   scb(3) = scb(3) + sadjb(i, j, k, 3, sps)
   velzgridb = velzgridb + sadjb(i, j, k, 3, sps)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(3, 1)*sadjb(i, j&
   &              , k, 3, sps)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(3, 2)*sadjb(i, j&
   &              , k, 3, sps)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(3, 3)*sadjb(i, j&
   &              , k, 3, sps)
   sadjb(i, j, k, 3, sps) = 0.0
   scb(2) = scb(2) + sadjb(i, j, k, 2, sps)
   velygridb = velygridb + sadjb(i, j, k, 2, sps)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(2, 1)*sadjb(i, j&
   &              , k, 2, sps)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(2, 2)*sadjb(i, j&
   &              , k, 2, sps)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(2, 3)*sadjb(i, j&
   &              , k, 2, sps)
   sadjb(i, j, k, 2, sps) = 0.0
   scb(1) = scb(1) + sadjb(i, j, k, 1, sps)
   velxgridb = velxgridb + sadjb(i, j, k, 1, sps)
   xxcb(1) = xxcb(1) + derivrotationmatrixadj(1, 1)*sadjb(i, j&
   &              , k, 1, sps)
   xxcb(2) = xxcb(2) + derivrotationmatrixadj(1, 2)*sadjb(i, j&
   &              , k, 1, sps)
   xxcb(3) = xxcb(3) + derivrotationmatrixadj(1, 3)*sadjb(i, j&
   &              , k, 1, sps)
   sadjb(i, j, k, 1, sps) = 0.0
   CALL POPREAL8(xxc(3))
   xcb(3) = xcb(3) + xxcb(3)
   rotationpointadjb(3) = rotationpointadjb(3) - xxcb(3)
   xxcb(3) = 0.0
   CALL POPREAL8(xxc(2))
   xcb(2) = xcb(2) + xxcb(2)
   rotationpointadjb(2) = rotationpointadjb(2) - xxcb(2)
   xxcb(2) = 0.0
   CALL POPREAL8(xxc(1))
   xcb(1) = xcb(1) + xxcb(1)
   rotationpointadjb(1) = rotationpointadjb(1) - xxcb(1)
   xxcb(1) = 0.0
   rotrateadjb(1) = rotrateadjb(1) + xxc(2)*scb(3)
   xxcb(2) = xxcb(2) + rotrateadj(1)*scb(3)
   rotrateadjb(2) = rotrateadjb(2) - xxc(1)*scb(3)
   xxcb(1) = xxcb(1) - rotrateadj(2)*scb(3)
   scb(3) = 0.0
   rotrateadjb(3) = rotrateadjb(3) + xxc(1)*scb(2)
   xxcb(1) = xxcb(1) + rotrateadj(3)*scb(2)
   rotrateadjb(1) = rotrateadjb(1) - xxc(3)*scb(2)
   xxcb(3) = xxcb(3) - rotrateadj(1)*scb(2)
   scb(2) = 0.0
   rotrateadjb(2) = rotrateadjb(2) + xxc(3)*scb(1)
   xxcb(3) = xxcb(3) + rotrateadj(2)*scb(1)
   rotrateadjb(3) = rotrateadjb(3) - xxc(2)*scb(1)
   xxcb(2) = xxcb(2) - rotrateadj(3)*scb(1)
   scb(1) = 0.0
   CALL POPREAL8(xxc(3))
   xcb(3) = xcb(3) + xxcb(3)
   rotcenteradjb(3) = rotcenteradjb(3) - xxcb(3)
   xxcb(3) = 0.0
   CALL POPREAL8(xxc(2))
   xcb(2) = xcb(2) + xxcb(2)
   rotcenteradjb(2) = rotcenteradjb(2) - xxcb(2)
   xxcb(2) = 0.0
   CALL POPREAL8(xxc(1))
   xcb(1) = xcb(1) + xxcb(1)
   rotcenteradjb(1) = rotcenteradjb(1) - xxcb(1)
   xxcb(1) = 0.0
   tempb = eighth*xcb(3)
   xadjb(i-1, j-1, k-1, 3, sps) = xadjb(i-1, j-1, k-1, 3, sps) &
   &              + tempb
   xadjb(i, j-1, k-1, 3, sps) = xadjb(i, j-1, k-1, 3, sps) + &
   &              tempb
   xadjb(i-1, j, k-1, 3, sps) = xadjb(i-1, j, k-1, 3, sps) + &
   &              tempb
   xadjb(i, j, k-1, 3, sps) = xadjb(i, j, k-1, 3, sps) + tempb
   xadjb(i-1, j-1, k, 3, sps) = xadjb(i-1, j-1, k, 3, sps) + &
   &              tempb
   xadjb(i, j-1, k, 3, sps) = xadjb(i, j-1, k, 3, sps) + tempb
   xadjb(i-1, j, k, 3, sps) = xadjb(i-1, j, k, 3, sps) + tempb
   xadjb(i, j, k, 3, sps) = xadjb(i, j, k, 3, sps) + tempb
   xcb(3) = 0.0
   tempb0 = eighth*xcb(2)
   xadjb(i-1, j-1, k-1, 2, sps) = xadjb(i-1, j-1, k-1, 2, sps) &
   &              + tempb0
   xadjb(i, j-1, k-1, 2, sps) = xadjb(i, j-1, k-1, 2, sps) + &
   &              tempb0
   xadjb(i-1, j, k-1, 2, sps) = xadjb(i-1, j, k-1, 2, sps) + &
   &              tempb0
   xadjb(i, j, k-1, 2, sps) = xadjb(i, j, k-1, 2, sps) + tempb0
   xadjb(i-1, j-1, k, 2, sps) = xadjb(i-1, j-1, k, 2, sps) + &
   &              tempb0
   xadjb(i, j-1, k, 2, sps) = xadjb(i, j-1, k, 2, sps) + tempb0
   xadjb(i-1, j, k, 2, sps) = xadjb(i-1, j, k, 2, sps) + tempb0
   xadjb(i, j, k, 2, sps) = xadjb(i, j, k, 2, sps) + tempb0
   xcb(2) = 0.0
   tempb1 = eighth*xcb(1)
   xadjb(i-1, j-1, k-1, 1, sps) = xadjb(i-1, j-1, k-1, 1, sps) &
   &              + tempb1
   xadjb(i, j-1, k-1, 1, sps) = xadjb(i, j-1, k-1, 1, sps) + &
   &              tempb1
   xadjb(i-1, j, k-1, 1, sps) = xadjb(i-1, j, k-1, 1, sps) + &
   &              tempb1
   xadjb(i, j, k-1, 1, sps) = xadjb(i, j, k-1, 1, sps) + tempb1
   xadjb(i-1, j-1, k, 1, sps) = xadjb(i-1, j-1, k, 1, sps) + &
   &              tempb1
   xadjb(i, j-1, k, 1, sps) = xadjb(i, j-1, k, 1, sps) + tempb1
   xadjb(i-1, j, k, 1, sps) = xadjb(i-1, j, k, 1, sps) + tempb1
   xadjb(i, j, k, 1, sps) = xadjb(i, j, k, 1, sps) + tempb1
   xcb(1) = 0.0
   END DO
   END DO
   END DO
   offsetvectorb(1:3) = 0.0
   velzgrid0b = velzgridb
   rotrateadjb(1) = rotrateadjb(1) + offsetvector(2)*velzgridb
   offsetvectorb(2) = (derivrotationmatrixadj(3, 2)+rotrateadj(1))*&
   &        velzgridb
   rotrateadjb(2) = rotrateadjb(2) - offsetvector(1)*velzgridb
   offsetvectorb(1) = (derivrotationmatrixadj(3, 1)-rotrateadj(2))*&
   &        velzgridb
   offsetvectorb(3) = derivrotationmatrixadj(3, 3)*velzgridb
   velygrid0b = velygridb
   rotrateadjb(3) = rotrateadjb(3) + offsetvector(1)*velygridb
   offsetvectorb(1) = offsetvectorb(1) + (derivrotationmatrixadj(2, 1&
   &        )+rotrateadj(3))*velygridb
   rotrateadjb(1) = rotrateadjb(1) - offsetvector(3)*velygridb
   offsetvectorb(3) = offsetvectorb(3) + (derivrotationmatrixadj(2, 3&
   &        )-rotrateadj(1))*velygridb
   offsetvectorb(2) = offsetvectorb(2) + derivrotationmatrixadj(2, 2)&
   &        *velygridb
   velxgrid0b = velxgridb
   rotrateadjb(2) = rotrateadjb(2) + offsetvector(3)*velxgridb
   offsetvectorb(3) = offsetvectorb(3) + (derivrotationmatrixadj(1, 3&
   &        )+rotrateadj(2))*velxgridb
   rotrateadjb(3) = rotrateadjb(3) - offsetvector(2)*velxgridb
   offsetvectorb(2) = offsetvectorb(2) + (derivrotationmatrixadj(1, 2&
   &        )-rotrateadj(3))*velxgridb
   offsetvectorb(1) = offsetvectorb(1) + derivrotationmatrixadj(1, 1)&
   &        *velxgridb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   alphaadjb = 0.0
   betaadjb = 0.0
   ELSE
   rotratetransb(1:3, 1:3) = 0.0
   rotratetempb(1:3) = 0.0
   DO i=3,1,-1
   DO j=3,1,-1
   rotratetempb(j) = rotratetempb(j) + rotratetrans(i, j)*&
   &              rotrateadjb(i)
   rotratetransb(i, j) = rotratetransb(i, j) + rotratetemp(j)*&
   &              rotrateadjb(i)
   END DO
   END DO
   rotrateadjb(1:3) = 0.0
   rotrateadjb = rotratetempb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   betab = -(SIN(beta)*rotratetransb(3, 3))
   rotratetransb(3, 3) = 0.0
   rotratetransb(3, 2) = 0.0
   betab = betab + COS(beta)*rotratetransb(3, 1)
   rotratetransb(3, 1) = 0.0
   alphab = -(SIN(beta)*COS(alpha)*rotratetransb(2, 3))
   betab = betab - SIN(alpha)*COS(beta)*rotratetransb(2, 3)
   rotratetransb(2, 3) = 0.0
   alphab = alphab - SIN(alpha)*rotratetransb(2, 2)
   rotratetransb(2, 2) = 0.0
   alphab = alphab + COS(beta)*COS(alpha)*rotratetransb(2, 1)
   betab = betab - SIN(alpha)*SIN(beta)*rotratetransb(2, 1)
   rotratetransb(2, 1) = 0.0
   alphab = alphab + SIN(beta)*SIN(alpha)*rotratetransb(1, 3)
   betab = betab - COS(alpha)*COS(beta)*rotratetransb(1, 3)
   rotratetransb(1, 3) = 0.0
   alphab = alphab - COS(alpha)*rotratetransb(1, 2)
   rotratetransb(1, 2) = 0.0
   alphab = alphab - COS(beta)*SIN(alpha)*rotratetransb(1, 1)
   betab = betab - COS(alpha)*SIN(beta)*rotratetransb(1, 1)
   ELSE
   alphab = -(SIN(alpha)*rotratetransb(3, 3))
   rotratetransb(3, 3) = 0.0
   alphab = alphab - SIN(beta)*COS(alpha)*rotratetransb(3, 2)
   betab = -(SIN(alpha)*COS(beta)*rotratetransb(3, 2))
   rotratetransb(3, 2) = 0.0
   alphab = alphab + COS(beta)*COS(alpha)*rotratetransb(3, 1)
   betab = betab - SIN(alpha)*SIN(beta)*rotratetransb(3, 1)
   rotratetransb(3, 1) = 0.0
   rotratetransb(2, 3) = 0.0
   betab = betab - SIN(beta)*rotratetransb(2, 2)
   rotratetransb(2, 2) = 0.0
   betab = betab + COS(beta)*rotratetransb(2, 1)
   rotratetransb(2, 1) = 0.0
   alphab = alphab - COS(alpha)*rotratetransb(1, 3)
   rotratetransb(1, 3) = 0.0
   alphab = alphab + SIN(beta)*SIN(alpha)*rotratetransb(1, 2)
   betab = betab - COS(alpha)*COS(beta)*rotratetransb(1, 2)
   rotratetransb(1, 2) = 0.0
   alphab = alphab - COS(beta)*SIN(alpha)*rotratetransb(1, 1)
   betab = betab - COS(alpha)*SIN(beta)*rotratetransb(1, 1)
   END IF
   ELSE
   alphab = 0.0
   betab = 0.0
   END IF
   betaadjb = betab
   alphaadjb = alphab
   END IF
   rotpointadjb(1:3) = 0.0
   rotcenteradjb = rotcenteradjb + offsetvectorb
   rotpointadjb = -offsetvectorb
   END IF
   ELSE
   alphaadjb = 0.0
   rotpointadjb(1:3) = 0.0
   betaadjb = 0.0
   rotcenteradjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   rotationpointadjb(1:3) = 0.0
   velygrid0b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 3) THEN
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   machgridadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   ELSE
   velygrid0b = velygrid0b + rotationmatrixadj(3, 2)*velzgrid0b
   velxgrid0b = velxgrid0b + rotationmatrixadj(2, 1)*velygrid0b + &
   &          rotationmatrixadj(3, 1)*velzgrid0b
   velzgrid0b = rotationmatrixadj(1, 3)*velxgrid0b + &
   &          rotationmatrixadj(2, 3)*velygrid0b + rotationmatrixadj(3, 3)*&
   &          velzgrid0b
   velygrid0b = rotationmatrixadj(1, 2)*velxgrid0b + &
   &          rotationmatrixadj(2, 2)*velygrid0b
   velxgrid0b = rotationmatrixadj(1, 1)*velxgrid0b
   CALL ROTMATRIXRIGIDBODYADJTS_B(tnew, told, rotationmatrixadj, &
   &                                 rotationpointadj, rotationpointadjb, &
   &                                 rotpointadj, rotpointadjb)
   machgridadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   END IF
   ELSE
   veldirb(1:3) = 0.0
   machgridadjb = -(ainf*veldir(1)*velxgrid0b) - ainf*veldir(2)*&
   &        velygrid0b - ainf*veldir(3)*velzgrid0b
   veldirb(3) = -(ainf*machgridadj*velzgrid0b)
   veldirb(2) = veldirb(2) - ainf*machgridadj*velygrid0b
   veldirb(1) = veldirb(1) - ainf*machgridadj*velxgrid0b
   alphatsb = 0.0
   CALL ADJUSTINFLOWANGLEADJTS_B(alphats, alphatsb, betaadj, betaadjb&
   &                              , veldir, veldirb, liftdir, dragdir, &
   &                              liftindex)
   alphaadjb = alphaadjb + alphatsb
   veldirfreestreamadjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   velygrid0b = 0.0
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .LT. 4) THEN
   veldirb(1:3) = 0.0
   machgridadjb = -(ainf*veldir(1)*velxgrid0b) - ainf*veldir(2)*&
   &        velygrid0b - ainf*veldir(3)*velzgrid0b
   veldirb(3) = -(ainf*machgridadj*velzgrid0b)
   veldirb(2) = veldirb(2) - ainf*machgridadj*velygrid0b
   veldirb(1) = veldirb(1) - ainf*machgridadj*velxgrid0b
   betatsb = 0.0
   CALL ADJUSTINFLOWANGLEADJTS_B(alphaadj, alphaadjb, betats, betatsb&
   &                              , veldir, veldirb, liftdir, dragdir, &
   &                              liftindex)
   betaadjb = betaadjb + betatsb
   veldirfreestreamadjb(1:3) = 0.0
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   velygrid0b = 0.0
   ELSE
   veldirfreestreamadjb(1:3) = 0.0
   machgridadjb = -(ainf*veldirfreestreamadj(1)*velxgrid0b) - ainf*&
   &        veldirfreestreamadj(2)*velygrid0b - ainf*veldirfreestreamadj(3)&
   &        *velzgrid0b
   veldirfreestreamadjb(3) = -(ainf*(intervalmach+machgridadj)*&
   &        velzgrid0b)
   veldirfreestreamadjb(2) = veldirfreestreamadjb(2) - ainf*(&
   &        intervalmach+machgridadj)*velygrid0b
   veldirfreestreamadjb(1) = veldirfreestreamadjb(1) - ainf*(&
   &        intervalmach+machgridadj)*velxgrid0b
   velxgrid0b = 0.0
   velzgrid0b = 0.0
   velygrid0b = 0.0
   END IF
   ELSE
   machgridadjb = 0.0
   veldirfreestreamadjb(1:3) = 0.0
   END IF
   CALL DERIVATIVEROTMATRIXRIGIDADJTS_B(derivrotationmatrixadj, &
   &                                 rotationpointadj, rotationpointadjb, &
   &                                 rotpointadj, rotpointadjb, t(1))
   machgridadjb = machgridadjb - ainf*veldirfreestreamadj(1)*velxgrid0b -&
   &   ainf*veldirfreestreamadj(2)*velygrid0b - ainf*veldirfreestreamadj(3)&
   &    *velzgrid0b
   veldirfreestreamadjb(3) = veldirfreestreamadjb(3) - ainf*machgridadj*&
   &    velzgrid0b
   veldirfreestreamadjb(2) = veldirfreestreamadjb(2) - ainf*machgridadj*&
   &    velygrid0b
   veldirfreestreamadjb(1) = veldirfreestreamadjb(1) - ainf*machgridadj*&
   &    velxgrid0b
!!$   coscoeffourzrotb(:) = 0.0
!!$   coscoeffourmachb0(:) = 0.0
!!$   omegafourbetab0 = 0.0
!!$   coefpolbetab0(:) = 0.0
!!$   coscoeffouralphab0(:) = 0.0
!!$   sincoeffourxrotb(:) = 0.0
!!$   sincoeffouryrotb(:) = 0.0
!!$   coscoeffourbetab0(:) = 0.0
!!$   sincoeffourzrotb(:) = 0.0
!!$   omegafourxrotb0 = 0.0
!!$   sincoeffourmachb0(:) = 0.0
!!$   coefpolalphab0(:) = 0.0
!!$   coefpolxrotb(:) = 0.0
!!$   omegafouryrotb0 = 0.0
!!$   coefpolyrotb(:) = 0.0
!!$   omegafourzrotb0 = 0.0
!!$   omegafouralphab0 = 0.0
!!$   omegafourmachb0 = 0.0
!!$   coefpolzrotb(:) = 0.0
!!$   coefpolmachb0(:) = 0.0
!!$   coscoeffourxrotb(:) = 0.0
!!$   sincoeffourbetab0(:) = 0.0
!!$   coscoeffouryrotb(:) = 0.0
!!$   sincoeffouralphab0(:) = 0.0
   END SUBROUTINE GRIDVELOCITIESFINELEVELADJTS_B

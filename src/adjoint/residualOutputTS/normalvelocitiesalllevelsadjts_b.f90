   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of normalvelocitiesalllevelsadjts in reverse (adjoint) mode:
   !   gradient, with respect to input variables: sfacekadj skadj
   !                sfacejadj sjadj sfaceiadj siadj
   !   of linear combination of output variables: rfaceadj sfacekadj
   !                skadj sfacejadj sjadj sfaceiadj siadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          normalVelocitiesAdj.f90                         *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 02-23-2004                                      *
   !      * Last modified: 10-25-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE NORMALVELOCITIESALLLEVELSADJTS_B(sps, icell, jcell, kcell, &
   &  sfaceiadj, sfaceiadjb, sfacejadj, sfacejadjb, sfacekadj, sfacekadjb, &
   &  siadj, siadjb, sjadj, sjadjb, skadj, skadjb, rfaceadj, rfaceadjb, nn&
   &  , level)
   USE bctypes
   USE blockpointers
   USE inputtimespectral
   USE iteration
   IMPLICIT NONE
   !         enddo domains
   !       enddo levelLoop
   INTEGER(KIND=INTTYPE), INTENT(IN) :: icell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: jcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: kcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: level
   INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
   REAL(KIND=REALTYPE) :: rfaceadj(nbocos, -2:2, -2:2, &
   &  ntimeintervalsspectral), rfaceadjb(nbocos, -2:2, -2:2, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfacejadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfacekadj
   REAL(KIND=REALTYPE) :: sfaceiadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacejadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacekadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj
   REAL(KIND=REALTYPE) :: siadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), sjadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), skadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sjadj
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: skadj
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   INTEGER :: ad_from, ad_from0, ad_to, ad_to0, branch
   INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
   INTEGER(KIND=INTTYPE) :: ien, ii, ist, jen, jj, jst
   INTEGER(KIND=INTTYPE) :: irbeg, irend, jrbeg, jrend, krbeg, krend
   INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
   INTEGER(KIND=INTTYPE) :: i, j, l, m
   INTEGER(KIND=INTTYPE) :: mm, nlevels
   LOGICAL :: computebc, secondhalo
   REAL(KIND=REALTYPE) :: sfaceadj(-2:2, -2:2), sfaceadjb(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: ss(-3:2, -3:2, 3), ssb(-3:2, -3:2, 3)
   REAL(KIND=REALTYPE) :: mult, tempb, weight, weightb
   INTRINSIC MAX, MIN, SQRT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * normalVelocitiesAllLevels computes the normal grid             *
   !      * velocities of some boundary faces of the moving blocks for     *
   !      * spectral mode sps. All grid levels from ground level to the    *
   !      * coarsest level are considered.                                 *
   !      *                                                                *
   !      ******************************************************************
   !
   !nIntervalTimespectral
   !
   !      Subroutine arguments.
   !
   !
   !      Local variables.
   !
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! since rface normally isn't allocate for all BC's set to zero by 
   ! default, then let it get filled in.
   !!Governed Outside computeRAdj!
   !!$       ! Loop over the number of grid levels, starting at groundLevel,
   !!$       ! the currently finest mesh.
   !!$
   !!$       nLevels = ubound(flowDoms,2)
   !!$       levelLoop: do level=groundLevel,nLevels
   !!$
   !!$         ! Loop over the number of local blocks.
   !!$
   !!$         domains: do nn=1,nDom
   !!$
   !!$           ! Set the pointers for this block.
   !!$
   !!$           call setPointers(nn, level, sps)
   ! Check for a moving block. As it is possible that in a
   ! multidisicplinary environment additional grid velocities
   ! are set, the test should be done on addGridVelocities
   ! and not on blockIsMoving.
   IF (addgridvelocities) THEN
   !
   !            ************************************************************
   !            *                                                          *
   !            * Determine the normal grid velocities of the boundaries.  *
   !            * As these values are based on the unit normal. A division *
   !            * by the length of the normal is needed.                   *
   !            * Furthermore the boundary unit normals are per definition *
   !            * outward pointing, while on the iMin, jMin and kMin       *
   !            * boundaries the face normals are inward pointing. This    *
   !            * is taken into account by the factor mult.                *
   !            *                                                          *
   !            ************************************************************
   !
   ! Loop over the boundary subfaces.
   bocoloop:DO mm=1,nbocos
   CALL CHECKOVERLAPADJTS(mm, icell, jcell, kcell, isbeg, jsbeg, &
   &                       ksbeg, isend, jsend, ksend, ibbeg, jbbeg, kbbeg&
   &                       , ibend, jbend, kbend, computebc)
   IF (computebc) THEN
   IF (isbeg .LT. ibbeg) THEN
   irbeg = ibbeg
   CALL PUSHINTEGER4(1)
   ELSE
   irbeg = isbeg
   CALL PUSHINTEGER4(0)
   END IF
   IF (isend .GT. ibend) THEN
   irend = ibend
   CALL PUSHINTEGER4(1)
   ELSE
   irend = isend
   CALL PUSHINTEGER4(0)
   END IF
   IF (jsbeg .LT. jbbeg) THEN
   jrbeg = jbbeg
   CALL PUSHINTEGER4(1)
   ELSE
   jrbeg = jsbeg
   CALL PUSHINTEGER4(0)
   END IF
   IF (jsend .GT. jbend) THEN
   jrend = jbend
   CALL PUSHINTEGER4(1)
   ELSE
   jrend = jsend
   CALL PUSHINTEGER4(0)
   END IF
   IF (ksbeg .LT. kbbeg) THEN
   krbeg = kbbeg
   CALL PUSHINTEGER4(1)
   ELSE
   krbeg = ksbeg
   CALL PUSHINTEGER4(0)
   END IF
   IF (ksend .GT. kbend) THEN
   krend = kbend
   CALL PUSHINTEGER4(1)
   ELSE
   krend = ksend
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHINTEGER4(ist)
   ist = -2
   CALL PUSHINTEGER4(ien)
   ien = 2
   CALL PUSHINTEGER4(jst)
   jst = -2
   CALL PUSHINTEGER4(jen)
   jen = 2
   ! Check whether rFace is allocated.
   !testAssoc: if( associated(BCData(mm)%rFace) ) then
   IF (bctype(mm) .EQ. farfield .OR. bctype(mm) .EQ. eulerwall) &
   &        THEN
   ! Determine the block face on which the subface is
   ! located and set some variables accordingly.
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   IF (jcell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (irbeg .EQ. irend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = siadj(-1, ist:ien, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfaceiadj(-1, ist:ien, jst:&
   &                jen, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = siadj(-2, ist:ien, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfaceiadj(-2, ist:ien, jst:&
   &                jen, sps)
   CALL PUSHINTEGER4(2)
   END IF
   CASE (imax) 
   IF (jcell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (irbeg .EQ. irend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = siadj(0, ist:ien, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfaceiadj(0, ist:ien, jst:jen&
   &                , sps)
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = siadj(1, ist:ien, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfaceiadj(1, ist:ien, jst:jen&
   &                , sps)
   CALL PUSHINTEGER4(4)
   END IF
   CASE (jmin) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (jrbeg .EQ. jrend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -1, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacejadj(ist:ien, -1, jst:&
   &                jen, sps)
   CALL PUSHINTEGER4(5)
   ELSE
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -2, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacejadj(ist:ien, -2, jst:&
   &                jen, sps)
   CALL PUSHINTEGER4(6)
   END IF
   CASE (jmax) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (kcell .EQ. kl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (jrbeg .EQ. jrend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 0, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacejadj(ist:ien, 0, jst:jen&
   &                , sps)
   CALL PUSHINTEGER4(7)
   ELSE
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 1, jst:jen, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacejadj(ist:ien, 1, jst:jen&
   &                , sps)
   CALL PUSHINTEGER4(8)
   END IF
   CASE (kmin) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (krbeg .EQ. krend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -1, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacekadj(ist:ien, jst:jen, -&
   &                1, sps)
   CALL PUSHINTEGER4(9)
   ELSE
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -2, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacekadj(ist:ien, jst:jen, -&
   &                2, sps)
   CALL PUSHINTEGER4(10)
   END IF
   CASE (kmax) 
   IF (icell .EQ. 2) THEN
   ist = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (icell .EQ. il) THEN
   ien = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. 2) THEN
   jst = -1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (jcell .EQ. jl) THEN
   jen = 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   secondhalo = .true.
   IF (krbeg .EQ. krend) THEN
   secondhalo = .false.
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (secondhalo) THEN
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 0, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacekadj(ist:ien, jst:jen, 0&
   &                , sps)
   CALL PUSHINTEGER4(11)
   ELSE
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                            jen-jst+1)*3)
   ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 1, :, &
   &                sps)
   CALL PUSHREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1&
   &                            )*(jen-jst+1))
   sfaceadj(ist:ien, jst:jen) = sfacekadj(ist:ien, jst:jen, 1&
   &                , sps)
   CALL PUSHINTEGER4(12)
   END IF
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from = jst
   ! Loop over the faces of the subface.
   DO jj=ad_from,jen
   ad_from0 = ist
   DO ii=ad_from0,ien
   !do j=jcBeg, jcEnd
   !  do i=icBeg, icEnd
   ! Compute the inverse of the length of the normal
   ! vector and possibly correct for inward pointing.
   IF (ss(ii, jj, 1)**2 .GT. zero .OR. ss(ii, jj, 2)**2 .GT. &
   &                  zero .OR. ss(ii, jj, 3)**2 .GT. zero) THEN
   CALL PUSHREAL8(weight)
   weight = SQRT(ss(ii, jj, 1)**2 + ss(ii, jj, 2)**2 + ss(&
   &                  ii, jj, 3)**2)
   CALL PUSHREAL8(weight)
   !if(weight > zero) weight = mult/weight
   weight = mult/weight
   ! Compute the normal velocity based on the outward
   ! pointing unit normal.
   !BCData(mm)%rFace(i,j) = weight*sFace(i,j)
   !!$                     if (abs(BCData(mm)%rFace(l+ii,m+jj)-rFaceAdj(mm,ii,jj))>1e-16)then
   !!$                        print *,'indices',mm,ii,jj,l,m
   !!$                        print *,'rface',BCData(mm)%rFace(l+ii,m+jj),rFaceAdj(mm,ii,jj),BCData(mm)%rFace(l+ii,m+jj)-rFaceAdj(mm
   !,ii,jj)
   !!$                     endif
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   END DO
   CALL PUSHINTEGER4(ii - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4(jj - 1)
   CALL PUSHINTEGER4(ad_from)
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO bocoloop
   ssb(-3:2, -3:2, 1:3) = 0.0
   sfaceadjb(-2:2, -2:2) = 0.0
   DO mm=nbocos,1,-1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 3) THEN
   IF (branch .LT. 2) GOTO 130
   ELSE
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO jj=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO ii=ad_to0,ad_from0,-1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   weightb = sfaceadj(ii, jj)*rfaceadjb(mm, ii, jj, sps)
   sfaceadjb(ii, jj) = sfaceadjb(ii, jj) + weight*rfaceadjb(&
   &                mm, ii, jj, sps)
   rfaceadjb(mm, ii, jj, sps) = 0.0
   CALL POPREAL8(weight)
   weightb = -(mult*weightb/weight**2)
   CALL POPREAL8(weight)
   tempb = weightb/(2.0*SQRT(ss(ii, jj, 1)**2+ss(ii, jj, 2)**&
   &                2+ss(ii, jj, 3)**2))
   ssb(ii, jj, 1) = ssb(ii, jj, 1) + 2*ss(ii, jj, 1)*tempb
   ssb(ii, jj, 2) = ssb(ii, jj, 2) + 2*ss(ii, jj, 2)*tempb
   ssb(ii, jj, 3) = ssb(ii, jj, 3) + 2*ss(ii, jj, 3)*tempb
   ELSE
   rfaceadjb(mm, ii, jj, sps) = 0.0
   END IF
   END DO
   END DO
   CALL POPINTEGER4(branch)
   IF (branch .LT. 7) THEN
   IF (branch .LT. 4) THEN
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   GOTO 120
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+&
   &                             1)*(jen-jst+1))
   sfaceiadjb(-1, ist:ien, jst:jen, sps) = sfaceiadjb(-1, &
   &                  ist:ien, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*&
   &                             (jen-jst+1)*3)
   siadjb(-1, ist:ien, jst:jen, :, sps) = siadjb(-1, ist:&
   &                  ien, jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .LT. 3) THEN
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1)&
   &                           *(jen-jst+1))
   sfaceiadjb(-2, ist:ien, jst:jen, sps) = sfaceiadjb(-2, ist&
   &                :ien, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                           jen-jst+1)*3)
   siadjb(-2, ist:ien, jst:jen, :, sps) = siadjb(-2, ist:ien&
   &                , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1)&
   &                           *(jen-jst+1))
   sfaceiadjb(0, ist:ien, jst:jen, sps) = sfaceiadjb(0, ist:&
   &                ien, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                           jen-jst+1)*3)
   siadjb(0, ist:ien, jst:jen, :, sps) = siadjb(0, ist:ien, &
   &                jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   GOTO 100
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   ELSE
   IF (branch .LT. 6) THEN
   IF (branch .LT. 5) THEN
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+&
   &                             1)*(jen-jst+1))
   sfaceiadjb(1, ist:ien, jst:jen, sps) = sfaceiadjb(1, ist&
   &                  :ien, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*&
   &                             (jen-jst+1)*3)
   siadjb(1, ist:ien, jst:jen, :, sps) = siadjb(1, ist:ien&
   &                  , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   GOTO 100
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+&
   &                             1)*(jen-jst+1))
   sfacejadjb(ist:ien, -1, jst:jen, sps) = sfacejadjb(ist:&
   &                  ien, -1, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*&
   &                             (jen-jst+1)*3)
   sjadjb(ist:ien, -1, jst:jen, :, sps) = sjadjb(ist:ien, -&
   &                  1, jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1)&
   &                           *(jen-jst+1))
   sfacejadjb(ist:ien, -2, jst:jen, sps) = sfacejadjb(ist:ien&
   &                , -2, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                           jen-jst+1)*3)
   sjadjb(ist:ien, -2, jst:jen, :, sps) = sjadjb(ist:ien, -2&
   &                , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END IF
   GOTO 120
   100      CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   ELSE
   IF (branch .LT. 10) THEN
   IF (branch .LT. 9) THEN
   IF (branch .LT. 8) THEN
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+&
   &                             1)*(jen-jst+1))
   sfacejadjb(ist:ien, 0, jst:jen, sps) = sfacejadjb(ist:&
   &                  ien, 0, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*&
   &                             (jen-jst+1)*3)
   sjadjb(ist:ien, 0, jst:jen, :, sps) = sjadjb(ist:ien, 0&
   &                  , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+&
   &                             1)*(jen-jst+1))
   sfacejadjb(ist:ien, 1, jst:jen, sps) = sfacejadjb(ist:&
   &                  ien, 1, jst:jen, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*&
   &                             (jen-jst+1)*3)
   sjadjb(ist:ien, 1, jst:jen, :, sps) = sjadjb(ist:ien, 1&
   &                  , jst:jen, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   GOTO 120
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1)&
   &                           *(jen-jst+1))
   sfacekadjb(ist:ien, jst:jen, -1, sps) = sfacekadjb(ist:ien&
   &                , jst:jen, -1, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                           jen-jst+1)*3)
   skadjb(ist:ien, jst:jen, -1, :, sps) = skadjb(ist:ien, jst&
   &                :jen, -1, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE
   IF (branch .LT. 12) THEN
   IF (branch .LT. 11) THEN
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+&
   &                             1)*(jen-jst+1))
   sfacekadjb(ist:ien, jst:jen, -2, sps) = sfacekadjb(ist:&
   &                  ien, jst:jen, -2, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*&
   &                             (jen-jst+1)*3)
   skadjb(ist:ien, jst:jen, -2, :, sps) = skadjb(ist:ien, &
   &                  jst:jen, -2, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   GOTO 110
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+&
   &                             1)*(jen-jst+1))
   sfacekadjb(ist:ien, jst:jen, 0, sps) = sfacekadjb(ist:&
   &                  ien, jst:jen, 0, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*&
   &                             (jen-jst+1)*3)
   skadjb(ist:ien, jst:jen, 0, :, sps) = skadjb(ist:ien, &
   &                  jst:jen, 0, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   ELSE
   CALL POPREAL8ARRAY(sfaceadj(ist:ien, jst:jen), (ien-ist+1)&
   &                           *(jen-jst+1))
   sfacekadjb(ist:ien, jst:jen, 1, sps) = sfacekadjb(ist:ien&
   &                , jst:jen, 1, sps) + sfaceadjb(ist:ien, jst:jen)
   sfaceadjb(ist:ien, jst:jen) = 0.0
   CALL POPREAL8ARRAY(ss(ist:ien, jst:jen, :), (ien-ist+1)*(&
   &                           jen-jst+1)*3)
   skadjb(ist:ien, jst:jen, 1, :, sps) = skadjb(ist:ien, jst:&
   &                jen, 1, :, sps) + ssb(ist:ien, jst:jen, :)
   ssb(ist:ien, jst:jen, :) = 0.0
   CALL POPREAL8(mult)
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   GOTO 120
   END IF
   110      CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END IF
   END IF
   120  CALL POPINTEGER4(jen)
   CALL POPINTEGER4(jst)
   CALL POPINTEGER4(ien)
   CALL POPINTEGER4(ist)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   130  CONTINUE
   END DO
   END IF
   END SUBROUTINE NORMALVELOCITIESALLLEVELSADJTS_B

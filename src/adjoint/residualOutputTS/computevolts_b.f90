   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of computevolts in reverse (adjoint) mode:
   !   gradient, with respect to input variables: voladj xadj
   !   of linear combination of output variables: voladj xadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          computeVolTS.f90                                *
   !      * Author:        C.A.(Sandy) Mader                               *
   !      * Starting date: 09-15-2011                                      *
   !      * Last modified: 09-15-2011                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE COMPUTEVOLTS_B(xadj, xadjb, voladj, voladjb, icell, jcell, &
   &  kcell, nn, level, sps)
   USE bctypes
   USE blockpointers
   USE cgnsgrid
   USE communication
   USE constants
   USE inputtimespectral
   USE section
   IMPLICIT NONE
   INTEGER(KIND=INTTYPE), INTENT(IN) :: icell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: jcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: kcell
   INTEGER(KIND=INTTYPE), INTENT(IN) :: level
   INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   REAL(KIND=REALTYPE) :: voladj(ntimeintervalsspectral), voladjb(&
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: xadj
   REAL(KIND=REALTYPE) :: xadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), PARAMETER :: thresvolume=1.e-2_realType
   LOGICAL :: badvolume, checkall, checki, checkj, checkk, ioverlap, &
   &  joverlap, koverlap, secondhalo, volumeisneg
   REAL(KIND=REALTYPE) :: fact, mult
   INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
   INTEGER :: branch, ierr
   CHARACTER(len=10) :: integerstring
   INTEGER(KIND=INTTYPE) :: i, ien, ist, j, jen, jj, jst, k, kk, l, m, n
   INTEGER(KIND=INTTYPE) :: irbeg, irend, jrbeg, jrend, krbeg, krend
   INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
   INTEGER(KIND=INTTYPE) :: iend, istart, jend, jstart, kend, kstart
   INTEGER(KIND=INTTYPE) :: mm, ntime
   INTEGER(KIND=INTTYPE) :: nvolbad, nvolbadglobal
   INTEGER(KIND=INTTYPE) :: nvolneg, nvolpos
   REAL(KIND=REALTYPE) :: ss(-2:2, -2:2, 3)
   REAL(KIND=REALTYPE) :: abs1, tempb
   REAL(KIND=REALTYPE) :: v1(3), v2(3)
   REAL(KIND=REALTYPE) :: abs2, abs3, abs4, abs5, abs6, abs7, tempb0, &
   &  tempb1, tempb2, vp1, vp1b, vp2, vp2b, vp3, vp3b, vp4, vp4b, vp5, vp5b&
   &  , vp6, vp6b, xp, xpb, yp, ypb, zp, zpb
   INTRINSIC ABS
   !
   !      ******************************************************************
   !      *                                                                *
   !      * computes the volume necessary for the given grid level for all *
   !      * spectral solutions. First the volumes are                      *
   !      * computed assuming that the block is right handed. Then the     *
   !      * number of positive and negative volumes are determined. If all *
   !      * volumes are positive the block is indeed right handed; if all  *
   !      * volumes are negative the block is left handed and both the     *
   !      * volumes and the normals must be negated (for the normals this  *
   !      * is done by the introduction of fact, which is either -0.5 or   *
   !      * 0.5); if there are both positive and negative volumes the mesh *
   !      * is not valid.                                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments.
   !
   !
   !      Local parameter.
   !
   !
   !      Local variables.
   !
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   !      **************************************************************
   !      *                                                            *
   !      * Volume computation
   !      *                                                            *
   !      **************************************************************
   !
   ! Initialize the number of positive and negative volumes for
   ! this block to 0.Needed to catch right/lefthanded blocks
   ! Compute the volumes. The hexahedron is split into 6 pyramids
   ! whose volumes are computed. The volume is positive for a
   ! right handed block.
   ! Initialize the volumes to zero. The reasons is that the second
   ! level halo's must be initialized to zero and for convenience
   ! all the volumes are set to zero.
   k = 0
   j = 0
   i = 0
   n = k - 1
   m = j - 1
   l = i - 1
   ! always check the volume of changed cell
   ! Compute the coordinates of the center of gravity.
   xp = eighth*(xadj(i, j, k, 1, sps)+xadj(i, m, k, 1, sps)+xadj(i, m, n&
   &    , 1, sps)+xadj(i, j, n, 1, sps)+xadj(l, j, k, 1, sps)+xadj(l, m, k&
   &    , 1, sps)+xadj(l, m, n, 1, sps)+xadj(l, j, n, 1, sps))
   yp = eighth*(xadj(i, j, k, 2, sps)+xadj(i, m, k, 2, sps)+xadj(i, m, n&
   &    , 2, sps)+xadj(i, j, n, 2, sps)+xadj(l, j, k, 2, sps)+xadj(l, m, k&
   &    , 2, sps)+xadj(l, m, n, 2, sps)+xadj(l, j, n, 2, sps))
   zp = eighth*(xadj(i, j, k, 3, sps)+xadj(i, m, k, 3, sps)+xadj(i, m, n&
   &    , 3, sps)+xadj(i, j, n, 3, sps)+xadj(l, j, k, 3, sps)+xadj(l, m, k&
   &    , 3, sps)+xadj(l, m, n, 3, sps)+xadj(l, j, n, 3, sps))
   ! Compute the volumes of the 6 sub pyramids. The
   ! arguments of volpym must be such that for a (regular)
   ! right handed hexahedron all volumes are positive.
   CALL VOLPYM3(xadj(i, j, k, 1, sps), xadj(i, j, k, 2, sps), xadj(i, j, &
   &         k, 3, sps), xadj(i, j, n, 1, sps), xadj(i, j, n, 2, sps), xadj&
   &         (i, j, n, 3, sps), xadj(i, m, n, 1, sps), xadj(i, m, n, 2, sps&
   &         ), xadj(i, m, n, 3, sps), xadj(i, m, k, 1, sps), xadj(i, m, k&
   &         , 2, sps), xadj(i, m, k, 3, sps), xp, yp, zp, vp1)
   CALL VOLPYM3(xadj(l, j, k, 1, sps), xadj(l, j, k, 2, sps), xadj(l, j, &
   &         k, 3, sps), xadj(l, m, k, 1, sps), xadj(l, m, k, 2, sps), xadj&
   &         (l, m, k, 3, sps), xadj(l, m, n, 1, sps), xadj(l, m, n, 2, sps&
   &         ), xadj(l, m, n, 3, sps), xadj(l, j, n, 1, sps), xadj(l, j, n&
   &         , 2, sps), xadj(l, j, n, 3, sps), xp, yp, zp, vp2)
   CALL VOLPYM3(xadj(i, j, k, 1, sps), xadj(i, j, k, 2, sps), xadj(i, j, &
   &         k, 3, sps), xadj(l, j, k, 1, sps), xadj(l, j, k, 2, sps), xadj&
   &         (l, j, k, 3, sps), xadj(l, j, n, 1, sps), xadj(l, j, n, 2, sps&
   &         ), xadj(l, j, n, 3, sps), xadj(i, j, n, 1, sps), xadj(i, j, n&
   &         , 2, sps), xadj(i, j, n, 3, sps), xp, yp, zp, vp3)
   CALL VOLPYM3(xadj(i, m, k, 1, sps), xadj(i, m, k, 2, sps), xadj(i, m, &
   &         k, 3, sps), xadj(i, m, n, 1, sps), xadj(i, m, n, 2, sps), xadj&
   &         (i, m, n, 3, sps), xadj(l, m, n, 1, sps), xadj(l, m, n, 2, sps&
   &         ), xadj(l, m, n, 3, sps), xadj(l, m, k, 1, sps), xadj(l, m, k&
   &         , 2, sps), xadj(l, m, k, 3, sps), xp, yp, zp, vp4)
   CALL VOLPYM3(xadj(i, j, k, 1, sps), xadj(i, j, k, 2, sps), xadj(i, j, &
   &         k, 3, sps), xadj(i, m, k, 1, sps), xadj(i, m, k, 2, sps), xadj&
   &         (i, m, k, 3, sps), xadj(l, m, k, 1, sps), xadj(l, m, k, 2, sps&
   &         ), xadj(l, m, k, 3, sps), xadj(l, j, k, 1, sps), xadj(l, j, k&
   &         , 2, sps), xadj(l, j, k, 3, sps), xp, yp, zp, vp5)
   CALL VOLPYM3(xadj(i, j, n, 1, sps), xadj(i, j, n, 2, sps), xadj(i, j, &
   &         n, 3, sps), xadj(l, j, n, 1, sps), xadj(l, j, n, 2, sps), xadj&
   &         (l, j, n, 3, sps), xadj(l, m, n, 1, sps), xadj(l, m, n, 2, sps&
   &         ), xadj(l, m, n, 3, sps), xadj(i, m, n, 1, sps), xadj(i, m, n&
   &         , 2, sps), xadj(i, m, n, 3, sps), xp, yp, zp, vp6)
   ! Set the volume to 1/6 of the sum of the volumes of the
   ! pyramid. Remember that volpym computes 6 times the
   ! volume.
   voladj(sps) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
   ! Check the volume and update the number of positive
   ! and negative volumes if needed.
   IF (voladj(sps) .GE. 0.) THEN
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   !!$           ! Some additional safety stuff for halo volumes.
   !!$
   !!$           do k=2,kl
   !!$             do j=2,jl
   !!$               if(vol(1, j,k) <= eps) vol(1, j,k) = vol(2, j,k)
   !!$               if(vol(ie,j,k) <= eps) vol(ie,j,k) = vol(il,j,k)
   !!$             enddo
   !!$           enddo
   !!$
   !!$           do k=2,kl
   !!$             do i=1,ie
   !!$               if(vol(i,1, k) <= eps) vol(i,1, k) = vol(i,2, k)
   !!$               if(vol(i,je,k) <= eps) vol(i,je,k) = vol(i,jl,k)
   !!$             enddo
   !!$           enddo
   !!$
   !!$           do j=1,je
   !!$             do i=1,ie
   !!$               if(vol(i,j,1)  <= eps) vol(i,j,1)  = vol(i,j,2)
   !!$               if(vol(i,j,ke) <= eps) vol(i,j,ke) = vol(i,j,kl)
   !!$             enddo
   !!$           enddo
   ! Determine the orientation of the block. For the fine level
   ! this is based on the number of positive and negative
   ! volumes; on the coarse levels the corresponding fine level
   ! value is taken. If both positive and negative volumes are
   ! present it is assumed that the block was intended to be
   ! right handed. The code will terminate later on anyway.
   IF (level .EQ. 1) THEN
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) voladjb(sps) = -voladjb(sps)
   tempb = sixth*voladjb(sps)
   vp1b = tempb
   vp2b = tempb
   vp3b = tempb
   vp4b = tempb
   vp5b = tempb
   vp6b = tempb
   voladjb(sps) = 0.0
   zpb = 0.0
   ypb = 0.0
   xpb = 0.0
   CALL VOLPYM3_B(xadj(i, j, n, 1, sps), xadjb(i, j, n, 1, sps), xadj(i&
   &             , j, n, 2, sps), xadjb(i, j, n, 2, sps), xadj(i, j, n, 3, &
   &             sps), xadjb(i, j, n, 3, sps), xadj(l, j, n, 1, sps), xadjb&
   &             (l, j, n, 1, sps), xadj(l, j, n, 2, sps), xadjb(l, j, n, 2&
   &             , sps), xadj(l, j, n, 3, sps), xadjb(l, j, n, 3, sps), &
   &             xadj(l, m, n, 1, sps), xadjb(l, m, n, 1, sps), xadj(l, m, &
   &             n, 2, sps), xadjb(l, m, n, 2, sps), xadj(l, m, n, 3, sps)&
   &             , xadjb(l, m, n, 3, sps), xadj(i, m, n, 1, sps), xadjb(i, &
   &             m, n, 1, sps), xadj(i, m, n, 2, sps), xadjb(i, m, n, 2, &
   &             sps), xadj(i, m, n, 3, sps), xadjb(i, m, n, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp6, vp6b)
   CALL VOLPYM3_B(xadj(i, j, k, 1, sps), xadjb(i, j, k, 1, sps), xadj(i&
   &             , j, k, 2, sps), xadjb(i, j, k, 2, sps), xadj(i, j, k, 3, &
   &             sps), xadjb(i, j, k, 3, sps), xadj(i, m, k, 1, sps), xadjb&
   &             (i, m, k, 1, sps), xadj(i, m, k, 2, sps), xadjb(i, m, k, 2&
   &             , sps), xadj(i, m, k, 3, sps), xadjb(i, m, k, 3, sps), &
   &             xadj(l, m, k, 1, sps), xadjb(l, m, k, 1, sps), xadj(l, m, &
   &             k, 2, sps), xadjb(l, m, k, 2, sps), xadj(l, m, k, 3, sps)&
   &             , xadjb(l, m, k, 3, sps), xadj(l, j, k, 1, sps), xadjb(l, &
   &             j, k, 1, sps), xadj(l, j, k, 2, sps), xadjb(l, j, k, 2, &
   &             sps), xadj(l, j, k, 3, sps), xadjb(l, j, k, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp5, vp5b)
   CALL VOLPYM3_B(xadj(i, m, k, 1, sps), xadjb(i, m, k, 1, sps), xadj(i&
   &             , m, k, 2, sps), xadjb(i, m, k, 2, sps), xadj(i, m, k, 3, &
   &             sps), xadjb(i, m, k, 3, sps), xadj(i, m, n, 1, sps), xadjb&
   &             (i, m, n, 1, sps), xadj(i, m, n, 2, sps), xadjb(i, m, n, 2&
   &             , sps), xadj(i, m, n, 3, sps), xadjb(i, m, n, 3, sps), &
   &             xadj(l, m, n, 1, sps), xadjb(l, m, n, 1, sps), xadj(l, m, &
   &             n, 2, sps), xadjb(l, m, n, 2, sps), xadj(l, m, n, 3, sps)&
   &             , xadjb(l, m, n, 3, sps), xadj(l, m, k, 1, sps), xadjb(l, &
   &             m, k, 1, sps), xadj(l, m, k, 2, sps), xadjb(l, m, k, 2, &
   &             sps), xadj(l, m, k, 3, sps), xadjb(l, m, k, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp4, vp4b)
   CALL VOLPYM3_B(xadj(i, j, k, 1, sps), xadjb(i, j, k, 1, sps), xadj(i&
   &             , j, k, 2, sps), xadjb(i, j, k, 2, sps), xadj(i, j, k, 3, &
   &             sps), xadjb(i, j, k, 3, sps), xadj(l, j, k, 1, sps), xadjb&
   &             (l, j, k, 1, sps), xadj(l, j, k, 2, sps), xadjb(l, j, k, 2&
   &             , sps), xadj(l, j, k, 3, sps), xadjb(l, j, k, 3, sps), &
   &             xadj(l, j, n, 1, sps), xadjb(l, j, n, 1, sps), xadj(l, j, &
   &             n, 2, sps), xadjb(l, j, n, 2, sps), xadj(l, j, n, 3, sps)&
   &             , xadjb(l, j, n, 3, sps), xadj(i, j, n, 1, sps), xadjb(i, &
   &             j, n, 1, sps), xadj(i, j, n, 2, sps), xadjb(i, j, n, 2, &
   &             sps), xadj(i, j, n, 3, sps), xadjb(i, j, n, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp3, vp3b)
   CALL VOLPYM3_B(xadj(l, j, k, 1, sps), xadjb(l, j, k, 1, sps), xadj(l&
   &             , j, k, 2, sps), xadjb(l, j, k, 2, sps), xadj(l, j, k, 3, &
   &             sps), xadjb(l, j, k, 3, sps), xadj(l, m, k, 1, sps), xadjb&
   &             (l, m, k, 1, sps), xadj(l, m, k, 2, sps), xadjb(l, m, k, 2&
   &             , sps), xadj(l, m, k, 3, sps), xadjb(l, m, k, 3, sps), &
   &             xadj(l, m, n, 1, sps), xadjb(l, m, n, 1, sps), xadj(l, m, &
   &             n, 2, sps), xadjb(l, m, n, 2, sps), xadj(l, m, n, 3, sps)&
   &             , xadjb(l, m, n, 3, sps), xadj(l, j, n, 1, sps), xadjb(l, &
   &             j, n, 1, sps), xadj(l, j, n, 2, sps), xadjb(l, j, n, 2, &
   &             sps), xadj(l, j, n, 3, sps), xadjb(l, j, n, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp2, vp2b)
   CALL VOLPYM3_B(xadj(i, j, k, 1, sps), xadjb(i, j, k, 1, sps), xadj(i&
   &             , j, k, 2, sps), xadjb(i, j, k, 2, sps), xadj(i, j, k, 3, &
   &             sps), xadjb(i, j, k, 3, sps), xadj(i, j, n, 1, sps), xadjb&
   &             (i, j, n, 1, sps), xadj(i, j, n, 2, sps), xadjb(i, j, n, 2&
   &             , sps), xadj(i, j, n, 3, sps), xadjb(i, j, n, 3, sps), &
   &             xadj(i, m, n, 1, sps), xadjb(i, m, n, 1, sps), xadj(i, m, &
   &             n, 2, sps), xadjb(i, m, n, 2, sps), xadj(i, m, n, 3, sps)&
   &             , xadjb(i, m, n, 3, sps), xadj(i, m, k, 1, sps), xadjb(i, &
   &             m, k, 1, sps), xadj(i, m, k, 2, sps), xadjb(i, m, k, 2, &
   &             sps), xadj(i, m, k, 3, sps), xadjb(i, m, k, 3, sps), xp, &
   &             xpb, yp, ypb, zp, zpb, vp1, vp1b)
   tempb0 = eighth*zpb
   xadjb(i, j, k, 3, sps) = xadjb(i, j, k, 3, sps) + tempb0
   xadjb(i, m, k, 3, sps) = xadjb(i, m, k, 3, sps) + tempb0
   xadjb(i, m, n, 3, sps) = xadjb(i, m, n, 3, sps) + tempb0
   xadjb(i, j, n, 3, sps) = xadjb(i, j, n, 3, sps) + tempb0
   xadjb(l, j, k, 3, sps) = xadjb(l, j, k, 3, sps) + tempb0
   xadjb(l, m, k, 3, sps) = xadjb(l, m, k, 3, sps) + tempb0
   xadjb(l, m, n, 3, sps) = xadjb(l, m, n, 3, sps) + tempb0
   xadjb(l, j, n, 3, sps) = xadjb(l, j, n, 3, sps) + tempb0
   tempb1 = eighth*ypb
   xadjb(i, j, k, 2, sps) = xadjb(i, j, k, 2, sps) + tempb1
   xadjb(i, m, k, 2, sps) = xadjb(i, m, k, 2, sps) + tempb1
   xadjb(i, m, n, 2, sps) = xadjb(i, m, n, 2, sps) + tempb1
   xadjb(i, j, n, 2, sps) = xadjb(i, j, n, 2, sps) + tempb1
   xadjb(l, j, k, 2, sps) = xadjb(l, j, k, 2, sps) + tempb1
   xadjb(l, m, k, 2, sps) = xadjb(l, m, k, 2, sps) + tempb1
   xadjb(l, m, n, 2, sps) = xadjb(l, m, n, 2, sps) + tempb1
   xadjb(l, j, n, 2, sps) = xadjb(l, j, n, 2, sps) + tempb1
   tempb2 = eighth*xpb
   xadjb(i, j, k, 1, sps) = xadjb(i, j, k, 1, sps) + tempb2
   xadjb(i, m, k, 1, sps) = xadjb(i, m, k, 1, sps) + tempb2
   xadjb(i, m, n, 1, sps) = xadjb(i, m, n, 1, sps) + tempb2
   xadjb(i, j, n, 1, sps) = xadjb(i, j, n, 1, sps) + tempb2
   xadjb(l, j, k, 1, sps) = xadjb(l, j, k, 1, sps) + tempb2
   xadjb(l, m, k, 1, sps) = xadjb(l, m, k, 1, sps) + tempb2
   xadjb(l, m, n, 1, sps) = xadjb(l, m, n, 1, sps) + tempb2
   xadjb(l, j, n, 1, sps) = xadjb(l, j, n, 1, sps) + tempb2
   END IF
   END SUBROUTINE COMPUTEVOLTS_B

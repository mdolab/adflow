   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of initresadjts in reverse (adjoint) mode:
   !   gradient, with respect to input variables: voladj wadj
   !   of linear combination of output variables: dwadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          initres.f90                                     *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-18-2003                                      *
   !      * Last modified: 06-28-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INITRESADJTS_B(varstart, varend, wadj, wadjb, voladj, voladjb&
   &  , dwadj, dwadjb, nn, level, sps)
   USE blockpointers
   USE flowvarrefstate
   USE inputiteration
   USE inputphysics
   USE inputtimespectral
   USE inputunsteady
   USE iteration
   IMPLICIT NONE
   !end select
   !redundent calculation. The entire stencil is zeroed above. May need to be corrected for more complex initalizaitons....
   !!$           ! Set the residual in the halo cells to zero. This is just
   !!$           ! to avoid possible problems. Their values do not matter.
   !!$
   !!$           do l=varStart,varEnd
   !!$             do k=-2,2!0,kb
   !!$               do j=-2,2!0,jb
   !!$                  
   !!$                 dw(0,j,k,l)  = zero
   !!$                 dw(1,j,k,l)  = zero
   !!$                 dw(ie,j,k,l) = zero
   !!$                 dw(ib,j,k,l) = zero
   !!$               enddo
   !!$             enddo
   !!$
   !!$             do k=0,kb
   !!$               do i=2,il
   !!$                 dw(i,0,k,l)  = zero
   !!$                 dw(i,1,k,l)  = zero
   !!$                 dw(i,je,k,l) = zero
   !!$                 dw(i,jb,k,l) = zero
   !!$               enddo
   !!$             enddo
   !!$
   !!$             do j=2,jl
   !!$               do i=2,il
   !!$                 dw(i,j,0,l)  = zero
   !!$                 dw(i,j,1,l)  = zero
   !!$                 dw(i,j,ke,l) = zero
   !!$                 dw(i,j,kb,l) = zero
   !!$               enddo
   !!$             enddo
   !!$           enddo
   REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
   &  ntimeintervalsspectral)
   INTEGER(KIND=INTTYPE), INTENT(IN) :: level
   INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   INTEGER(KIND=INTTYPE), INTENT(IN) :: varend
   INTEGER(KIND=INTTYPE), INTENT(IN) :: varstart
   REAL(KIND=REALTYPE) :: voladj(ntimeintervalsspectral), voladjb(&
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: wadj(nw, ntimeintervalsspectral), wadjb(nw, &
   &  ntimeintervalsspectral)
   INTEGER :: branch
   INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, l, ll, m, mm
   REAL(KIND=REALTYPE) :: tempb
   REAL(KIND=REALTYPE) :: oneoverdt, tmp, tmpb
   REAL(KIND=REALTYPE) :: volspadj, volspadjb
   REAL(KIND=REALTYPE) :: wspadj(nw), wspadjb(nw)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * initres initializes the given range of the residual. Either to *
   !      * zero, steady computation, or to an unsteady term for the time  *
   !      * spectral and unsteady modes. For the coarser grid levels the   *
   !      * residual forcing term is taken into account.                   *
   !      *                                                                *
   !      * This is a local routine, so assume that pointers are already   *
   !      * set.                                                           *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   !real(kind=realType),dimension(-2:2,-2:2,-2:2,nw,nTimeIntervalsSpectral):: wAdj
   !
   !      Local variables.
   !
   !unsteady and timespectral variables
   !!$
   !!$       real(kind=realType), dimension(:,:,:,:), pointer :: ww, wsp, wsp1
   !!$       real(kind=realType), dimension(:,:,:),   pointer :: volsp
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately of no variables are in the range.
   IF (varend .LT. varstart) THEN
   voladjb(1:ntimeintervalsspectral) = 0.0
   wadjb(1:nw, 1:ntimeintervalsspectral) = 0.0
   ELSE IF (equationmode .EQ. steady) THEN
   !moveed outside
   !!$
   !!$       ! Loop over the number of spectral solutions and domains.
   !!$
   !!$       spectralLoop: do sps=1,nTimeIntervalsSpectral
   !!$
   !!$         domains: do nn=1,nDom
   !!$
   !!$           ! Set the pointers to this block.
   !!$
   !!$           call setPointers(nn, currentLevel, sps)
   ! Determine the equation mode and act accordingly.
   !print *,'equation Mode',equationMode,'ref',steady,timespectral,unsteady
   !switch to if statments. this particular case setup doesn't work
   !with tapenade. The steady case dissappears and Tapenade doesn't
   !know how to handle the empty case....
   !           select case (equationMode)
   !             case (steady)
   voladjb(1:ntimeintervalsspectral) = 0.0
   wadjb(1:nw, 1:ntimeintervalsspectral) = 0.0
   ELSE IF (equationmode .EQ. unsteady) THEN
   !===========================================================
   voladjb(1:ntimeintervalsspectral) = 0.0
   wadjb(1:nw, 1:ntimeintervalsspectral) = 0.0
   ELSE IF (equationmode .EQ. timespectral) THEN
   !case (timeSpectral)
   !!$!
   !!$!                call terminate("initRes", &
   !!$!                                  "Time Spectral ADjoint not yet implemented")
   ! Time spectral computation. The time derivative of the
   ! current solution is given by a linear combination of
   ! all other solutions, i.e. a matrix vector product.
   ! First store the section to which this block belongs
   ! in jj.
   jj = sectionid
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   ! Loop over the number of terms which contribute
   ! to the time derivative.
   timeloopfine:DO mm=1,ntimeintervalsspectral
   CALL PUSHREAL8ARRAY(wspadj, nw)
   ! Store the pointer for the variable to be used to
   ! compute the unsteady source term and the volume.
   ! Also store in ii the offset needed for vector
   ! quantities.
   wspadj = wadj(:, mm)
   CALL PUSHREAL8(volspadj)
   !(:,:,:,mm)
   volspadj = voladj(mm)
   CALL PUSHINTEGER4(ii)
   ii = 3*(mm-1)
   ! Loop over the number of variables to be set.
   varloopfine:DO l=varstart,varend
   ! Test for a momentum variable.
   IF (l .EQ. ivx .OR. l .EQ. ivy .OR. l .EQ. ivz) THEN
   ! Momentum variable. A special treatment is
   ! needed because it is a vector and the velocities
   ! are stored instead of the momentum. Set the
   ! coefficient ll, which defines the row of the
   ! matrix used later on.
   IF (l .EQ. ivx) THEN
   CALL PUSHINTEGER4(ll)
   ll = 3*sps - 2
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (l .EQ. ivy) THEN
   CALL PUSHINTEGER4(ll)
   ll = 3*sps - 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (l .EQ. ivz) THEN
   CALL PUSHINTEGER4(ll)
   ll = 3*sps
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(tmp)
   ! Loop over the owned cell centers to add the
   ! contribution from wsp.
   !do k=2,kl
   !  do j=2,jl
   !    do i=2,il
   ! Store the matrix vector product with the
   ! velocity in tmp.
   !tmp = dvector(jj,ll,ii+1)*wsp(i,j,k,ivx) &
   !          + dvector(jj,ll,ii+2)*wsp(i,j,k,ivy) &
   !          + dvector(jj,ll,ii+3)*wsp(i,j,k,ivz)
   tmp = dvector(jj, ll, ii+1)*wspadj(ivx) + dvector(jj, ll, ii&
   &              +2)*wspadj(ivy) + dvector(jj, ll, ii+3)*wspadj(ivz)
   ! Update the residual. Note the
   ! multiplication with the density to obtain
   ! the correct time derivative for the
   ! momentum variable.
   !dw(i,j,k,l) = dw(i,j,k,l) &
   !     + tmp*volsp(i,j,k)*wsp(i,j,k,irho)
   !dwAdj(l,mm) = dwAdj(l,mm) &
   !     enddo
   !   enddo
   ! enddo
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   END DO varloopfine
   END DO timeloopfine
   voladjb(1:ntimeintervalsspectral) = 0.0
   wadjb(1:nw, 1:ntimeintervalsspectral) = 0.0
   DO mm=ntimeintervalsspectral,1,-1
   wspadjb(1:nw) = 0.0
   volspadjb = 0.0
   DO l=varend,varstart,-1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   tmpb = wspadj(irho)*volspadj*dwadjb(l, sps)
   volspadjb = volspadjb + wspadj(irho)*tmp*dwadjb(l, sps)
   wspadjb(irho) = wspadjb(irho) + tmp*volspadj*dwadjb(l, sps)
   CALL POPREAL8(tmp)
   wspadjb(ivx) = wspadjb(ivx) + dvector(jj, ll, ii+1)*tmpb
   wspadjb(ivy) = wspadjb(ivy) + dvector(jj, ll, ii+2)*tmpb
   wspadjb(ivz) = wspadjb(ivz) + dvector(jj, ll, ii+3)*tmpb
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
   ELSE
   tempb = dscalar(jj, sps, mm)*dwadjb(l, sps)
   volspadjb = volspadjb + wspadj(l)*tempb
   wspadjb(l) = wspadjb(l) + volspadj*tempb
   END IF
   END DO
   CALL POPINTEGER4(ii)
   CALL POPREAL8(volspadj)
   voladjb(mm) = voladjb(mm) + volspadjb
   CALL POPREAL8ARRAY(wspadj, nw)
   wadjb(:, mm) = wadjb(:, mm) + wspadjb
   END DO
   ELSE
   voladjb(1:ntimeintervalsspectral) = 0.0
   wadjb(1:nw, 1:ntimeintervalsspectral) = 0.0
   END IF
   ELSE
   voladjb(1:ntimeintervalsspectral) = 0.0
   wadjb(1:nw, 1:ntimeintervalsspectral) = 0.0
   END IF
   END SUBROUTINE INITRESADJTS_B

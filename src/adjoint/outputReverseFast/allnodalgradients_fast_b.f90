!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of allnodalgradients in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *aa *wx *wy *wz *w *qx *qy
!                *qz *ux *uy *uz *vx *vy *vz
!   with respect to varying inputs: *aa *wx *wy *wz *w *qx *qy
!                *qz *ux *uy *uz *vx *vy *vz
!   rw status of diff variables: *aa:incr *wx:in-zero *wy:in-zero
!                *wz:in-zero *w:incr *qx:in-zero *qy:in-zero *qz:in-zero
!                *ux:in-zero *uy:in-zero *uz:in-zero *vx:in-zero
!                *vy:in-zero *vz:in-zero
!   plus diff mem management of: aa:in wx:in wy:in wz:in w:in qx:in
!                qy:in qz:in ux:in uy:in uz:in vx:in vy:in vz:in
subroutine allnodalgradients_fast_b()
!
!        ****************************************************************
!        *                                                              *
!        * nodalgradients computes the nodal velocity gradients and     *
!        * minus the gradient of the speed of sound squared. the minus  *
!        * sign is present, because this is the definition of the heat  *
!        * flux. these gradients are computed for all nodes.            * 
!        *                                                              *
!        ****************************************************************
!
  use constants
  use blockpointers
  implicit none
!        local variables.
  integer(kind=inttype) :: i, j, k
  integer(kind=inttype) :: k1, kk
  integer(kind=inttype) :: istart, iend, isize, ii
  integer(kind=inttype) :: jstart, jend, jsize
  integer(kind=inttype) :: kstart, kend, ksize
  real(kind=realtype) :: oneoverv, ubar, vbar, wbar, a2
  real(kind=realtype) :: ubard, vbard, wbard, a2d
  real(kind=realtype) :: sx, sx1, sy, sy1, sz, sz1
  intrinsic mod
!
!        ****************************************************************
!        *                                                              *
!        * begin execution                                              *
!        *                                                              *
!        ****************************************************************
!
! zero all nodeal gradients:
  integer :: branch
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  do ii=0,il*jl*kl-1
    i = mod(ii, il) + 1
    j = mod(ii/il, jl) + 1
    k = ii/(il*jl) + 1
! compute the inverse of 8 times the volume for this node.
    oneoverv = one/(vol(i, j, k)+vol(i, j, k+1)+vol(i+1, j, k)+vol(i+1, &
&     j, k+1)+vol(i, j+1, k)+vol(i, j+1, k+1)+vol(i+1, j+1, k)+vol(i+1, &
&     j+1, k+1))
! compute the correct velocity gradients and "unit" heat
! fluxes. the velocity gradients are stored in ux, etc.
    qzd(i, j, k) = oneoverv*qzd(i, j, k)
    qyd(i, j, k) = oneoverv*qyd(i, j, k)
    qxd(i, j, k) = oneoverv*qxd(i, j, k)
    wzd(i, j, k) = oneoverv*wzd(i, j, k)
    wyd(i, j, k) = oneoverv*wyd(i, j, k)
    wxd(i, j, k) = oneoverv*wxd(i, j, k)
    vzd(i, j, k) = oneoverv*vzd(i, j, k)
    vyd(i, j, k) = oneoverv*vyd(i, j, k)
    vxd(i, j, k) = oneoverv*vxd(i, j, k)
    uzd(i, j, k) = oneoverv*uzd(i, j, k)
    uyd(i, j, k) = oneoverv*uyd(i, j, k)
    uxd(i, j, k) = oneoverv*uxd(i, j, k)
  end do
  do ii=0,ie*jl*kl-1
    i = mod(ii, ie) + 1
    j = mod(ii/ie, jl) + 1
    k = ii/(ie*jl) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = si(i-1, j, k, 1) + si(i-1, j+1, k, 1) + si(i-1, j, k+1, 1) + si&
&     (i-1, j+1, k+1, 1) + si(i, j, k, 1) + si(i, j+1, k, 1) + si(i, j, &
&     k+1, 1) + si(i, j+1, k+1, 1)
    sy = si(i-1, j, k, 2) + si(i-1, j+1, k, 2) + si(i-1, j, k+1, 2) + si&
&     (i-1, j+1, k+1, 2) + si(i, j, k, 2) + si(i, j+1, k, 2) + si(i, j, &
&     k+1, 2) + si(i, j+1, k+1, 2)
    sz = si(i-1, j, k, 3) + si(i-1, j+1, k, 3) + si(i-1, j, k+1, 3) + si&
&     (i-1, j+1, k+1, 3) + si(i, j, k, 3) + si(i, j+1, k, 3) + si(i, j, &
&     k+1, 3) + si(i, j+1, k+1, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (i .gt. 1) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
    else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
    end if
    if (i .lt. ie) then
      a2d = sy*qyd(i, j, k) + sx*qxd(i, j, k) + sz*qzd(i, j, k)
      wbard = -(sy*wyd(i, j, k)) - sx*wxd(i, j, k) - sz*wzd(i, j, k)
      vbard = -(sy*vyd(i, j, k)) - sx*vxd(i, j, k) - sz*vzd(i, j, k)
      ubard = -(sy*uyd(i, j, k)) - sx*uxd(i, j, k) - sz*uzd(i, j, k)
    else
      wbard = 0.0_8
      vbard = 0.0_8
      ubard = 0.0_8
      a2d = 0.0_8
    end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
    if (branch .eq. 0) then
      a2d = a2d - sy*qyd(i-1, j, k) - sx*qxd(i-1, j, k) - sz*qzd(i-1, j&
&       , k)
      wbard = wbard + sy*wyd(i-1, j, k) + sx*wxd(i-1, j, k) + sz*wzd(i-1&
&       , j, k)
      vbard = vbard + sy*vyd(i-1, j, k) + sx*vxd(i-1, j, k) + sz*vzd(i-1&
&       , j, k)
      ubard = ubard + sy*uyd(i-1, j, k) + sx*uxd(i-1, j, k) + sz*uzd(i-1&
&       , j, k)
    end if
    tempd7 = fourth*a2d
    aad(i, j, k) = aad(i, j, k) + tempd7
    aad(i, j+1, k) = aad(i, j+1, k) + tempd7
    aad(i, j, k+1) = aad(i, j, k+1) + tempd7
    aad(i, j+1, k+1) = aad(i, j+1, k+1) + tempd7
    tempd8 = fourth*wbard
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + tempd8
    wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + tempd8
    wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + tempd8
    wd(i, j+1, k+1, ivz) = wd(i, j+1, k+1, ivz) + tempd8
    tempd9 = fourth*vbard
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + tempd9
    wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + tempd9
    wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + tempd9
    wd(i, j+1, k+1, ivy) = wd(i, j+1, k+1, ivy) + tempd9
    tempd10 = fourth*ubard
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + tempd10
    wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + tempd10
    wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + tempd10
    wd(i, j+1, k+1, ivx) = wd(i, j+1, k+1, ivx) + tempd10
  end do
  do ii=0,il*je*kl-1
    i = mod(ii, il) + 1
    j = mod(ii/il, je) + 1
    k = ii/(il*je) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = sj(i, j-1, k, 1) + sj(i+1, j-1, k, 1) + sj(i, j-1, k+1, 1) + sj&
&     (i+1, j-1, k+1, 1) + sj(i, j, k, 1) + sj(i+1, j, k, 1) + sj(i, j, &
&     k+1, 1) + sj(i+1, j, k+1, 1)
    sy = sj(i, j-1, k, 2) + sj(i+1, j-1, k, 2) + sj(i, j-1, k+1, 2) + sj&
&     (i+1, j-1, k+1, 2) + sj(i, j, k, 2) + sj(i+1, j, k, 2) + sj(i, j, &
&     k+1, 2) + sj(i+1, j, k+1, 2)
    sz = sj(i, j-1, k, 3) + sj(i+1, j-1, k, 3) + sj(i, j-1, k+1, 3) + sj&
&     (i+1, j-1, k+1, 3) + sj(i, j, k, 3) + sj(i+1, j, k, 3) + sj(i, j, &
&     k+1, 3) + sj(i+1, j, k+1, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (j .gt. 1) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
    else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
    end if
    if (j .lt. je) then
      a2d = sy*qyd(i, j, k) + sx*qxd(i, j, k) + sz*qzd(i, j, k)
      wbard = -(sy*wyd(i, j, k)) - sx*wxd(i, j, k) - sz*wzd(i, j, k)
      vbard = -(sy*vyd(i, j, k)) - sx*vxd(i, j, k) - sz*vzd(i, j, k)
      ubard = -(sy*uyd(i, j, k)) - sx*uxd(i, j, k) - sz*uzd(i, j, k)
    else
      wbard = 0.0_8
      vbard = 0.0_8
      ubard = 0.0_8
      a2d = 0.0_8
    end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
    if (branch .eq. 0) then
      a2d = a2d - sy*qyd(i, j-1, k) - sx*qxd(i, j-1, k) - sz*qzd(i, j-1&
&       , k)
      wbard = wbard + sy*wyd(i, j-1, k) + sx*wxd(i, j-1, k) + sz*wzd(i, &
&       j-1, k)
      vbard = vbard + sy*vyd(i, j-1, k) + sx*vxd(i, j-1, k) + sz*vzd(i, &
&       j-1, k)
      ubard = ubard + sy*uyd(i, j-1, k) + sx*uxd(i, j-1, k) + sz*uzd(i, &
&       j-1, k)
    end if
    tempd3 = fourth*a2d
    aad(i, j, k) = aad(i, j, k) + tempd3
    aad(i+1, j, k) = aad(i+1, j, k) + tempd3
    aad(i, j, k+1) = aad(i, j, k+1) + tempd3
    aad(i+1, j, k+1) = aad(i+1, j, k+1) + tempd3
    tempd4 = fourth*wbard
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + tempd4
    wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + tempd4
    wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + tempd4
    wd(i+1, j, k+1, ivz) = wd(i+1, j, k+1, ivz) + tempd4
    tempd5 = fourth*vbard
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + tempd5
    wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + tempd5
    wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + tempd5
    wd(i+1, j, k+1, ivy) = wd(i+1, j, k+1, ivy) + tempd5
    tempd6 = fourth*ubard
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + tempd6
    wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + tempd6
    wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + tempd6
    wd(i+1, j, k+1, ivx) = wd(i+1, j, k+1, ivx) + tempd6
  end do
  do ii=0,il*jl*ke-1
    i = mod(ii, il) + 1
    j = mod(ii/il, jl) + 1
    k = ii/(il*jl) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = sk(i, j, k-1, 1) + sk(i+1, j, k-1, 1) + sk(i, j+1, k-1, 1) + sk&
&     (i+1, j+1, k-1, 1) + sk(i, j, k, 1) + sk(i+1, j, k, 1) + sk(i, j+1&
&     , k, 1) + sk(i+1, j+1, k, 1)
    sy = sk(i, j, k-1, 2) + sk(i+1, j, k-1, 2) + sk(i, j+1, k-1, 2) + sk&
&     (i+1, j+1, k-1, 2) + sk(i, j, k, 2) + sk(i+1, j, k, 2) + sk(i, j+1&
&     , k, 2) + sk(i+1, j+1, k, 2)
    sz = sk(i, j, k-1, 3) + sk(i+1, j, k-1, 3) + sk(i, j+1, k-1, 3) + sk&
&     (i+1, j+1, k-1, 3) + sk(i, j, k, 3) + sk(i+1, j, k, 3) + sk(i, j+1&
&     , k, 3) + sk(i+1, j+1, k, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (k .gt. 1) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
    else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
    end if
    if (k .lt. ke) then
      a2d = sy*qyd(i, j, k) + sx*qxd(i, j, k) + sz*qzd(i, j, k)
      wbard = -(sy*wyd(i, j, k)) - sx*wxd(i, j, k) - sz*wzd(i, j, k)
      vbard = -(sy*vyd(i, j, k)) - sx*vxd(i, j, k) - sz*vzd(i, j, k)
      ubard = -(sy*uyd(i, j, k)) - sx*uxd(i, j, k) - sz*uzd(i, j, k)
    else
      wbard = 0.0_8
      vbard = 0.0_8
      ubard = 0.0_8
      a2d = 0.0_8
    end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
    if (branch .eq. 0) then
      a2d = a2d - sy*qyd(i, j, k-1) - sx*qxd(i, j, k-1) - sz*qzd(i, j, k&
&       -1)
      wbard = wbard + sy*wyd(i, j, k-1) + sx*wxd(i, j, k-1) + sz*wzd(i, &
&       j, k-1)
      vbard = vbard + sy*vyd(i, j, k-1) + sx*vxd(i, j, k-1) + sz*vzd(i, &
&       j, k-1)
      ubard = ubard + sy*uyd(i, j, k-1) + sx*uxd(i, j, k-1) + sz*uzd(i, &
&       j, k-1)
    end if
    tempd = fourth*a2d
    aad(i, j, k) = aad(i, j, k) + tempd
    aad(i+1, j, k) = aad(i+1, j, k) + tempd
    aad(i, j+1, k) = aad(i, j+1, k) + tempd
    aad(i+1, j+1, k) = aad(i+1, j+1, k) + tempd
    tempd0 = fourth*wbard
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + tempd0
    wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + tempd0
    wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + tempd0
    wd(i+1, j+1, k, ivz) = wd(i+1, j+1, k, ivz) + tempd0
    tempd1 = fourth*vbard
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + tempd1
    wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + tempd1
    wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + tempd1
    wd(i+1, j+1, k, ivy) = wd(i+1, j+1, k, ivy) + tempd1
    tempd2 = fourth*ubard
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + tempd2
    wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + tempd2
    wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + tempd2
    wd(i+1, j+1, k, ivx) = wd(i+1, j+1, k, ivx) + tempd2
  end do
  wxd = 0.0_8
  wyd = 0.0_8
  wzd = 0.0_8
  qxd = 0.0_8
  qyd = 0.0_8
  qzd = 0.0_8
  uxd = 0.0_8
  uyd = 0.0_8
  uzd = 0.0_8
  vxd = 0.0_8
  vyd = 0.0_8
  vzd = 0.0_8
end subroutine allnodalgradients_fast_b

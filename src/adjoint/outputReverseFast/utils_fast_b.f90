!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module utils_fast_b
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
  function tsbeta(degreepolbeta, coefpolbeta, degreefourbeta, &
&   omegafourbeta, coscoeffourbeta, sincoeffourbeta, t)
!
!       tsbeta computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsbeta
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolbeta
    integer(kind=inttype), intent(in) :: degreefourbeta
    real(kind=realtype), intent(in) :: omegafourbeta, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolbeta
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourbeta
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourbeta
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: beta, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsbeta = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      beta = coefpolbeta(0)
      do nn=1,degreepolbeta
        beta = beta + coefpolbeta(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      beta = beta + coscoeffourbeta(0)
      do nn=1,degreefourbeta
        val = nn*omegafourbeta*t
        beta = beta + coscoeffourbeta(nn)*cos(val) + sincoeffourbeta(nn)&
&         *sin(val)
      end do
! set tsbeta to phi.
      tsbeta = beta
    end if
  end function tsbeta
  function tsbetadot(degreepolbeta, coefpolbeta, degreefourbeta, &
&   omegafourbeta, coscoeffourbeta, sincoeffourbeta, t)
!
!       tsbeta computes the angle of attack for a given time interval  
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsbetadot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolbeta
    integer(kind=inttype), intent(in) :: degreefourbeta
    real(kind=realtype), intent(in) :: omegafourbeta, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolbeta
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourbeta
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourbeta
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: betadot, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsbetadot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      betadot = zero
      do nn=1,degreepolbeta
        betadot = betadot + nn*coefpolbeta(nn)*t**(nn-1)
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefourbeta
        val = nn*omegafourbeta
        betadot = betadot - val*coscoeffourbeta(nn)*sin(val*t) + val*&
&         sincoeffourbeta(nn)*cos(val*t)
      end do
! set tsbeta to phi.
      tsbetadot = betadot
    end if
  end function tsbetadot
  function tsmach(degreepolmach, coefpolmach, degreefourmach, &
&   omegafourmach, coscoeffourmach, sincoeffourmach, t)
!
!       tsmach computes the mach number for a given time interval      
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsmach
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolmach
    integer(kind=inttype), intent(in) :: degreefourmach
    real(kind=realtype), intent(in) :: omegafourmach, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolmach
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourmach
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourmach
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: intervalmach, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsmach = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      intervalmach = coefpolmach(0)
      do nn=1,degreepolmach
        intervalmach = intervalmach + coefpolmach(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      intervalmach = intervalmach + coscoeffourmach(0)
      do nn=1,degreefourmach
        val = nn*omegafourmach*t
        intervalmach = intervalmach + coscoeffourmach(nn)*cos(val) + &
&         sincoeffourmach(nn)*sin(val)
      end do
      print*, 'intsmach', intervalmach, nn, val, t
! set tsmach to phi.
      tsmach = intervalmach
    end if
  end function tsmach
  function tsmachdot(degreepolmach, coefpolmach, degreefourmach, &
&   omegafourmach, coscoeffourmach, sincoeffourmach, t)
!
!       tsmach computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsmachdot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolmach
    integer(kind=inttype), intent(in) :: degreefourmach
    real(kind=realtype), intent(in) :: omegafourmach, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolmach
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourmach
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourmach
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: machdot, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsmachdot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      machdot = zero
      do nn=1,degreepolmach
        machdot = machdot + nn*coefpolmach(nn)*t**(nn-1)
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefourmach
        val = nn*omegafourmach
        machdot = machdot - val*coscoeffourmach(nn)*sin(val*t) + val*&
&         sincoeffourmach(nn)*cos(val*t)
      end do
! set tsmach to phi.
      tsmachdot = machdot
    end if
  end function tsmachdot
  function tsalpha(degreepolalpha, coefpolalpha, degreefouralpha, &
&   omegafouralpha, coscoeffouralpha, sincoeffouralpha, t)
!
!       tsalpha computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsalpha
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolalpha
    integer(kind=inttype), intent(in) :: degreefouralpha
    real(kind=realtype), intent(in) :: omegafouralpha, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolalpha
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffouralpha
    real(kind=realtype), dimension(*), intent(in) :: sincoeffouralpha
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: alpha, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsalpha = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      alpha = coefpolalpha(0)
      do nn=1,degreepolalpha
        alpha = alpha + coefpolalpha(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      alpha = alpha + coscoeffouralpha(0)
      do nn=1,degreefouralpha
        val = nn*omegafouralpha*t
        alpha = alpha + coscoeffouralpha(nn)*cos(val) + sincoeffouralpha&
&         (nn)*sin(val)
      end do
!print *,'intsalpha',alpha,nn,val,t
! set tsalpha to phi.
      tsalpha = alpha
    end if
  end function tsalpha
  function tsalphadot(degreepolalpha, coefpolalpha, degreefouralpha, &
&   omegafouralpha, coscoeffouralpha, sincoeffouralpha, t)
!
!       tsalpha computes the angle of attack for a given time interval 
!       in a time spectral solution.                                   
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsalphadot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolalpha
    integer(kind=inttype), intent(in) :: degreefouralpha
    real(kind=realtype), intent(in) :: omegafouralpha, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolalpha
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffouralpha
    real(kind=realtype), dimension(*), intent(in) :: sincoeffouralpha
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: alphadot, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsalphadot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      alphadot = zero
      do nn=1,degreepolalpha
        alphadot = alphadot + nn*coefpolalpha(nn)*t**(nn-1)
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefouralpha
        val = nn*omegafouralpha
        alphadot = alphadot - val*coscoeffouralpha(nn)*sin(val*t) + val*&
&         sincoeffouralpha(nn)*cos(val*t)
      end do
! set tsalpha to phi.
      tsalphadot = alphadot
    end if
  end function tsalphadot
  function derivativerigidrotangle(degreepolrot, coefpolrot, &
&   degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!       derivativerigidrotangle computes the time derivative of the    
!       rigid body rotation angle at the given time for the given      
!       arguments. the angle is described by a combination of a        
!       polynomial and fourier series.                                 
!
    use constants
    use inputphysics, only : equationmode
    use flowvarrefstate, only : timeref
    implicit none
!
!      function type
!
    real(kind=realtype) :: derivativerigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: dphi, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      derivativerigidrotangle = zero
      return
    else
! compute the polynomial contribution.
      dphi = zero
      do nn=1,degreepolrot
        dphi = dphi + nn*coefpolrot(nn)*t**(nn-1)
      end do
! compute the fourier contribution.
      do nn=1,degreefourrot
        val = nn*omegafourrot
        dphi = dphi - val*coscoeffourrot(nn)*sin(val*t)
        dphi = dphi + val*sincoeffourrot(nn)*cos(val*t)
      end do
! set derivativerigidrotangle to dphi. multiply by timeref
! to obtain the correct non-dimensional value.
      derivativerigidrotangle = timeref*dphi
    end if
  end function derivativerigidrotangle
!  differentiation of mydim in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: x y mydim
!   with respect to varying inputs: x y
  subroutine mydim_fast_b(x, xd, y, yd, mydimd)
    use constants
    implicit none
    real(kind=realtype) :: x, y
    real(kind=realtype) :: xd, yd
    real(kind=realtype) :: mydim
    real(kind=realtype) :: mydimd
    mydim = x - y
    if (mydim .lt. 0.0) mydimd = 0.0_8
    xd = xd + mydimd
    yd = yd - mydimd
  end subroutine mydim_fast_b
  function mydim(x, y)
    use constants
    implicit none
    real(kind=realtype) :: x, y
    real(kind=realtype) :: mydim
    mydim = x - y
    if (mydim .lt. 0.0) mydim = 0.0
  end function mydim
  function getcorrectfork()
    use constants
    use flowvarrefstate, only : kpresent
    use iteration, only : currentlevel, groundlevel
    implicit none
    logical :: getcorrectfork
    if (kpresent .and. currentlevel .le. groundlevel) then
      getcorrectfork = .true.
    else
      getcorrectfork = .false.
    end if
  end function getcorrectfork
  subroutine terminate(routinename, errormessage)
!
!       terminate writes an error message to standard output and       
!       terminates the execution of the program.                       
!
    use constants
    use communication, only : sumb_comm_world, myid
    implicit none
!
!      subroutine arguments
!
    character(len=*), intent(in) :: routinename
    character(len=*), intent(in) :: errormessage
  end subroutine terminate
  subroutine rotmatrixrigidbody(tnew, told, rotationmatrix, &
&   rotationpoint)
!
!       rotmatrixrigidbody determines the rotation matrix and the      
!       rotation point to determine the coordinates of the new time    
!       level starting from the coordinates of the old time level.     
!
    use constants
    use inputmotion
    use flowvarrefstate, only : lref
    implicit none
!
!      subroutine arguments.
!
    real(kind=realtype), intent(in) :: tnew, told
    real(kind=realtype), dimension(3), intent(out) :: rotationpoint
    real(kind=realtype), dimension(3, 3), intent(out) :: rotationmatrix
!
!      local variables.
!
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: phi
    real(kind=realtype) :: cosx, cosy, cosz, sinx, siny, sinz
    real(kind=realtype), dimension(3, 3) :: mnew, mold
    intrinsic sin
    intrinsic cos
! determine the rotation angle around the x-axis for the new
! time level and the corresponding values of the sine and cosine.
    phi = rigidrotangle(degreepolxrot, coefpolxrot, degreefourxrot, &
&     omegafourxrot, coscoeffourxrot, sincoeffourxrot, tnew)
    sinx = sin(phi)
    cosx = cos(phi)
! idem for the y-axis.
    phi = rigidrotangle(degreepolyrot, coefpolyrot, degreefouryrot, &
&     omegafouryrot, coscoeffouryrot, sincoeffouryrot, tnew)
    siny = sin(phi)
    cosy = cos(phi)
! idem for the z-axis.
    phi = rigidrotangle(degreepolzrot, coefpolzrot, degreefourzrot, &
&     omegafourzrot, coscoeffourzrot, sincoeffourzrot, tnew)
    sinz = sin(phi)
    cosz = cos(phi)
! construct the transformation matrix at the new time level.
! it is assumed that the sequence of rotation is first around the
! x-axis then around the y-axis and finally around the z-axis.
    mnew(1, 1) = cosy*cosz
    mnew(2, 1) = cosy*sinz
    mnew(3, 1) = -siny
    mnew(1, 2) = sinx*siny*cosz - cosx*sinz
    mnew(2, 2) = sinx*siny*sinz + cosx*cosz
    mnew(3, 2) = sinx*cosy
    mnew(1, 3) = cosx*siny*cosz + sinx*sinz
    mnew(2, 3) = cosx*siny*sinz - sinx*cosz
    mnew(3, 3) = cosx*cosy
! determine the rotation angle around the x-axis for the old
! time level and the corresponding values of the sine and cosine.
    phi = rigidrotangle(degreepolxrot, coefpolxrot, degreefourxrot, &
&     omegafourxrot, coscoeffourxrot, sincoeffourxrot, told)
    sinx = sin(phi)
    cosx = cos(phi)
! idem for the y-axis.
    phi = rigidrotangle(degreepolyrot, coefpolyrot, degreefouryrot, &
&     omegafouryrot, coscoeffouryrot, sincoeffouryrot, told)
    siny = sin(phi)
    cosy = cos(phi)
! idem for the z-axis.
    phi = rigidrotangle(degreepolzrot, coefpolzrot, degreefourzrot, &
&     omegafourzrot, coscoeffourzrot, sincoeffourzrot, told)
    sinz = sin(phi)
    cosz = cos(phi)
! construct the transformation matrix at the old time level.
    mold(1, 1) = cosy*cosz
    mold(2, 1) = cosy*sinz
    mold(3, 1) = -siny
    mold(1, 2) = sinx*siny*cosz - cosx*sinz
    mold(2, 2) = sinx*siny*sinz + cosx*cosz
    mold(3, 2) = sinx*cosy
    mold(1, 3) = cosx*siny*cosz + sinx*sinz
    mold(2, 3) = cosx*siny*sinz - sinx*cosz
    mold(3, 3) = cosx*cosy
! construct the transformation matrix between the new and the
! old time level. this is mnew*inverse(mold). however the
! inverse of mold is the transpose.
    do j=1,3
      do i=1,3
        rotationmatrix(i, j) = mnew(i, 1)*mold(j, 1) + mnew(i, 2)*mold(j&
&         , 2) + mnew(i, 3)*mold(j, 3)
      end do
    end do
! determine the rotation point at the old time level; it is
! possible that this value changes due to translation of the grid.
!  ainf = sqrt(gammainf*pinf/rhoinf)
!  rotationpoint(1) = lref*rotpoint(1) &
!                   + machgrid(1)*ainf*told/timeref
!  rotationpoint(2) = lref*rotpoint(2) &
!                   + machgrid(2)*ainf*told/timeref
!  rotationpoint(3) = lref*rotpoint(3) &
!                   + machgrid(3)*ainf*told/timeref
    rotationpoint(1) = lref*rotpoint(1)
    rotationpoint(2) = lref*rotpoint(2)
    rotationpoint(3) = lref*rotpoint(3)
  end subroutine rotmatrixrigidbody
  function secondderivativerigidrotangle(degreepolrot, coefpolrot, &
&   degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!       2ndderivativerigidrotangle computes the 2nd time derivative of 
!       the rigid body rotation angle at the given time for the given  
!       arguments. the angle is described by a combination of a        
!       polynomial and fourier series.                                 
!
    use constants
    use flowvarrefstate, only : timeref
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: secondderivativerigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: dphi, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      secondderivativerigidrotangle = zero
      return
    else
! compute the polynomial contribution.
      dphi = zero
      do nn=2,degreepolrot
        dphi = dphi + (nn-1)*nn*coefpolrot(nn)*t**(nn-2)
      end do
! compute the fourier contribution.
      do nn=1,degreefourrot
        val = nn*omegafourrot
        dphi = dphi - val**2*sincoeffourrot(nn)*sin(val*t)
        dphi = dphi - val**2*coscoeffourrot(nn)*cos(val*t)
      end do
! set derivativerigidrotangle to dphi. multiply by timeref
! to obtain the correct non-dimensional value.
      secondderivativerigidrotangle = timeref**2*dphi
    end if
  end function secondderivativerigidrotangle
  function rigidrotangle(degreepolrot, coefpolrot, degreefourrot, &
&   omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!       rigidrotangle computes the rigid body rotation angle at the    
!       given time for the given arguments. the angle is described by  
!       a combination of a polynomial and fourier series.              
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: rigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: phi, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      rigidrotangle = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      phi = coefpolrot(0)
      do nn=1,degreepolrot
        phi = phi + coefpolrot(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      phi = phi + coscoeffourrot(0)
      do nn=1,degreefourrot
        val = nn*omegafourrot*t
        phi = phi + coscoeffourrot(nn)*cos(val) + sincoeffourrot(nn)*sin&
&         (val)
      end do
! set rigidrotangle to phi.
      rigidrotangle = phi
    end if
  end function rigidrotangle
  subroutine setbcpointers(nn, spatialpointers)
!
!       setbcpointers sets the pointers needed for the boundary        
!       condition treatment on a general face, such that the boundary  
!       routines are only implemented once instead of 6 times.         
!
    use constants
    use blockpointers, only : w, p, rlv, rev, gamma, x, d2wall, si, sj&
&   , sk, s, globalcell, bcdata, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid
    use bcpointers_fast_b, only : ww0, ww1, ww2, ww3, pp0, pp1, pp2, pp3, &
&   rlv0, rlv1, rlv2, rlv3, rev0, rev1, rev2, rev3, gamma0, gamma1, &
&   gamma2, gamma3, gcp, xx, ss, ssi, ssj, ssk, dd2wall, istart, iend, &
&   jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      ww3 => w(3, 1:, 1:, :)
      ww2 => w(2, 1:, 1:, :)
      ww1 => w(1, 1:, 1:, :)
      ww0 => w(0, 1:, 1:, :)
      pp3 => p(3, 1:, 1:)
      pp2 => p(2, 1:, 1:)
      pp1 => p(1, 1:, 1:)
      pp0 => p(0, 1:, 1:)
      rlv3 => rlv(3, 1:, 1:)
      rlv2 => rlv(2, 1:, 1:)
      rlv1 => rlv(1, 1:, 1:)
      rlv0 => rlv(0, 1:, 1:)
      rev3 => rev(3, 1:, 1:)
      rev2 => rev(2, 1:, 1:)
      rev1 => rev(1, 1:, 1:)
      rev0 => rev(0, 1:, 1:)
      gamma3 => gamma(3, 1:, 1:)
      gamma2 => gamma(2, 1:, 1:)
      gamma1 => gamma(1, 1:, 1:)
      gamma0 => gamma(0, 1:, 1:)
      gcp => globalcell(2, 1:, 1:)
    case (imax) 
!===============================================================
      ww3 => w(nx, 1:, 1:, :)
      ww2 => w(il, 1:, 1:, :)
      ww1 => w(ie, 1:, 1:, :)
      ww0 => w(ib, 1:, 1:, :)
      pp3 => p(nx, 1:, 1:)
      pp2 => p(il, 1:, 1:)
      pp1 => p(ie, 1:, 1:)
      pp0 => p(ib, 1:, 1:)
      rlv3 => rlv(nx, 1:, 1:)
      rlv2 => rlv(il, 1:, 1:)
      rlv1 => rlv(ie, 1:, 1:)
      rlv0 => rlv(ib, 1:, 1:)
      rev3 => rev(nx, 1:, 1:)
      rev2 => rev(il, 1:, 1:)
      rev1 => rev(ie, 1:, 1:)
      rev0 => rev(ib, 1:, 1:)
      gamma3 => gamma(nx, 1:, 1:)
      gamma2 => gamma(il, 1:, 1:)
      gamma1 => gamma(ie, 1:, 1:)
      gamma0 => gamma(ib, 1:, 1:)
      gcp => globalcell(il, 1:, 1:)
    case (jmin) 
!===============================================================
      ww3 => w(1:, 3, 1:, :)
      ww2 => w(1:, 2, 1:, :)
      ww1 => w(1:, 1, 1:, :)
      ww0 => w(1:, 0, 1:, :)
      pp3 => p(1:, 3, 1:)
      pp2 => p(1:, 2, 1:)
      pp1 => p(1:, 1, 1:)
      pp0 => p(1:, 0, 1:)
      rlv3 => rlv(1:, 3, 1:)
      rlv2 => rlv(1:, 2, 1:)
      rlv1 => rlv(1:, 1, 1:)
      rlv0 => rlv(1:, 0, 1:)
      rev3 => rev(1:, 3, 1:)
      rev2 => rev(1:, 2, 1:)
      rev1 => rev(1:, 1, 1:)
      rev0 => rev(1:, 0, 1:)
      gamma3 => gamma(1:, 3, 1:)
      gamma2 => gamma(1:, 2, 1:)
      gamma1 => gamma(1:, 1, 1:)
      gamma0 => gamma(1:, 0, 1:)
      gcp => globalcell(1:, 2, 1:)
    case (jmax) 
!===============================================================
      ww3 => w(1:, ny, 1:, :)
      ww2 => w(1:, jl, 1:, :)
      ww1 => w(1:, je, 1:, :)
      ww0 => w(1:, jb, 1:, :)
      pp3 => p(1:, ny, 1:)
      pp2 => p(1:, jl, 1:)
      pp1 => p(1:, je, 1:)
      pp0 => p(1:, jb, 1:)
      rlv3 => rlv(1:, ny, 1:)
      rlv2 => rlv(1:, jl, 1:)
      rlv1 => rlv(1:, je, 1:)
      rlv0 => rlv(1:, jb, 1:)
      rev3 => rev(1:, ny, 1:)
      rev2 => rev(1:, jl, 1:)
      rev1 => rev(1:, je, 1:)
      rev0 => rev(1:, jb, 1:)
      gamma3 => gamma(1:, ny, 1:)
      gamma2 => gamma(1:, jl, 1:)
      gamma1 => gamma(1:, je, 1:)
      gamma0 => gamma(1:, jb, 1:)
      gcp => globalcell(1:, jl, 1:)
    case (kmin) 
!===============================================================
      ww3 => w(1:, 1:, 3, :)
      ww2 => w(1:, 1:, 2, :)
      ww1 => w(1:, 1:, 1, :)
      ww0 => w(1:, 1:, 0, :)
      pp3 => p(1:, 1:, 3)
      pp2 => p(1:, 1:, 2)
      pp1 => p(1:, 1:, 1)
      pp0 => p(1:, 1:, 0)
      rlv3 => rlv(1:, 1:, 3)
      rlv2 => rlv(1:, 1:, 2)
      rlv1 => rlv(1:, 1:, 1)
      rlv0 => rlv(1:, 1:, 0)
      rev3 => rev(1:, 1:, 3)
      rev2 => rev(1:, 1:, 2)
      rev1 => rev(1:, 1:, 1)
      rev0 => rev(1:, 1:, 0)
      gamma3 => gamma(1:, 1:, 3)
      gamma2 => gamma(1:, 1:, 2)
      gamma1 => gamma(1:, 1:, 1)
      gamma0 => gamma(1:, 1:, 0)
      gcp => globalcell(1:, 1:, 2)
    case (kmax) 
!===============================================================
      ww3 => w(1:, 1:, nz, :)
      ww2 => w(1:, 1:, kl, :)
      ww1 => w(1:, 1:, ke, :)
      ww0 => w(1:, 1:, kb, :)
      pp3 => p(1:, 1:, nz)
      pp2 => p(1:, 1:, kl)
      pp1 => p(1:, 1:, ke)
      pp0 => p(1:, 1:, kb)
      rlv3 => rlv(1:, 1:, nz)
      rlv2 => rlv(1:, 1:, kl)
      rlv1 => rlv(1:, 1:, ke)
      rlv0 => rlv(1:, 1:, kb)
      rev3 => rev(1:, 1:, nz)
      rev2 => rev(1:, 1:, kl)
      rev1 => rev(1:, 1:, ke)
      rev0 => rev(1:, 1:, kb)
      gamma3 => gamma(1:, 1:, nz)
      gamma2 => gamma(1:, 1:, kl)
      gamma1 => gamma(1:, 1:, ke)
      gamma0 => gamma(1:, 1:, kb)
      gcp => globalcell(1:, 1:, kl)
    end select
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xx => x(1, :, :, :)
        ssi => si(1, :, :, :)
        ssj => sj(2, :, :, :)
        ssk => sk(2, :, :, :)
        ss => s(2, :, :, :)
      case (imax) 
        xx => x(il, :, :, :)
        ssi => si(il, :, :, :)
        ssj => sj(il, :, :, :)
        ssk => sk(il, :, :, :)
        ss => s(il, :, :, :)
      case (jmin) 
        xx => x(:, 1, :, :)
        ssi => sj(:, 1, :, :)
        ssj => si(:, 2, :, :)
        ssk => sk(:, 2, :, :)
        ss => s(:, 2, :, :)
      case (jmax) 
        xx => x(:, jl, :, :)
        ssi => sj(:, jl, :, :)
        ssj => si(:, jl, :, :)
        ssk => sk(:, jl, :, :)
        ss => s(:, jl, :, :)
      case (kmin) 
        xx => x(:, :, 1, :)
        ssi => sk(:, :, 1, :)
        ssj => si(:, :, 2, :)
        ssk => sj(:, :, 2, :)
        ss => s(:, :, 2, :)
      case (kmax) 
        xx => x(:, :, kl, :)
        ssi => sk(:, :, kl, :)
        ssj => si(:, :, kl, :)
        ssk => sj(:, :, kl, :)
        ss => s(:, :, kl, :)
      end select
      if (equations .eq. ransequations) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          dd2wall => d2wall(2, :, :)
        case (imax) 
          dd2wall => d2wall(il, :, :)
        case (jmin) 
          dd2wall => d2wall(:, 2, :)
        case (jmax) 
          dd2wall => d2wall(:, jl, :)
        case (kmin) 
          dd2wall => d2wall(:, :, 2)
        case (kmax) 
          dd2wall => d2wall(:, :, kl)
        end select
      end if
    end if
  end subroutine setbcpointers
  subroutine resetbcpointers(nn, spatialpointers)
!
!       resetbcpointers nullifyies the boundary pointers. for reverse  
!       mode ad it copies the values back in to the respective arrays  
!
    use constants
    use blockpointers, only : w, p, rlv, rev, gamma, x, d2wall, si, sj&
&   , sk, s, globalcell, bcdata, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid
    use bcpointers_fast_b, only : ww0, ww1, ww2, ww3, pp0, pp1, pp2, pp3, &
&   rlv0, rlv1, rlv2, rlv3, rev0, rev1, rev2, rev3, gamma0, gamma1, &
&   gamma2, gamma3, gcp, xx, ss, ssi, ssj, ssk, dd2wall, istart, iend, &
&   jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      w(3, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(2, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(1, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(0, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(3, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(2, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(1, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(0, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(3, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(2, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(1, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(0, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(3, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(2, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(1, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(0, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(3, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(2, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(1, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(0, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (imax) 
!===============================================================
      w(nx, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(il, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(ie, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(ib, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(nx, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(il, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(ie, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(ib, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(nx, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(il, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(ie, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(ib, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(nx, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(il, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(ie, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(ib, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(nx, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(il, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(ie, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(ib, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (jmin) 
!===============================================================
      w(1:ie, 3, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, 2, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, 1, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, 0, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, 3, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, 2, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, 1, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, 0, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, 3, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, 2, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, 1, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, 0, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, 3, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, 2, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, 1, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, 0, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, 3, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, 2, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, 1, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, 0, 1:ke) = gamma0(1:ie, 1:ke)
    case (jmax) 
!===============================================================
      w(1:ie, ny, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, jl, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, je, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, jb, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, ny, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, jl, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, je, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, jb, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, ny, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, jl, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, je, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, jb, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, ny, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, jl, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, je, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, jb, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, ny, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, jl, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, je, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, jb, 1:ke) = gamma0(1:ie, 1:ke)
    case (kmin) 
!===============================================================
      w(1:ie, 1:je, 3, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, 2, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, 1, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, 0, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, 3) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, 2) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, 1) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, 0) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, 3) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, 2) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, 1) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, 0) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, 3) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, 2) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, 1) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, 0) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, 3) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, 2) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, 1) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, 0) = gamma0(1:ie, 1:je)
    case (kmax) 
!===============================================================
      w(1:ie, 1:je, nz, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, kl, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, ke, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, kb, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, nz) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, kl) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, ke) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, kb) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, nz) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, kl) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, ke) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, kb) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, nz) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, kl) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, ke) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, kb) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, nz) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, kl) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, ke) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, kb) = gamma0(1:ie, 1:je)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        x(1, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(1, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (imax) 
        x(il, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(il, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (jmin) 
        x(0:ie, 1, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, 1, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (jmax) 
        x(0:ie, jl, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, jl, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (kmin) 
        x(0:ie, 0:je, 1, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, 1, :) = ssi(1:ie, 1:je, :)
      case (kmax) 
        x(0:ie, 0:je, kl, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, kl, :) = ssi(1:ie, 1:je, :)
      end select
    end if
  end subroutine resetbcpointers
end module utils_fast_b

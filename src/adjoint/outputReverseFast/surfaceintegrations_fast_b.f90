!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module surfaceintegrations_fast_b
  implicit none

contains
  subroutine forcesandmoments(cfp, cfv, cmp, cmv, yplusmax, sepsensor, &
&   sepsensoravg, cavitation)
!
!       forcesandmoments computes the contribution of the block        
!       given by the pointers in blockpointers to the force and        
!       moment coefficients of the geometry. a distinction is made     
!       between the inviscid and viscous parts. in case the maximum    
!       yplus value must be monitored (only possible for rans), this   
!       value is also computed. the separation sensor and the cavita-  
!       tion sensor is also computed                                   
!       here.                                                          
!
    use constants
    use communication
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use bcroutines_fast_b
    use costfunctions
    use surfacefamilies
    use sorting, only : bsearchintegers
    use utils_fast_b, only : setbcpointers, resetbcpointers
    use bcpointers_fast_b
    implicit none
!
!      subroutine arguments
!
    real(kind=realtype), dimension(3), intent(out) :: cfp, cfv
    real(kind=realtype), dimension(3), intent(out) :: cmp, cmv
    real(kind=realtype), intent(out) :: yplusmax, sepsensor
    real(kind=realtype), intent(out) :: sepsensoravg(3), cavitation
!
!      local variables.
!
    integer(kind=inttype) :: nn, i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
    real(kind=realtype) :: xc, yc, zc, qf(3)
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: scaledim, v(3), sensor, sensor1, cp, tmp, &
&   plocal
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype) :: mx, my, mz, cellarea
    logical :: viscoussubface
    intrinsic size
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
! set the actual scaling factor such that actual forces are computed
    scaledim = pref/pinf
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
    cfp(1) = zero
    cfp(2) = zero
    cfp(3) = zero
    cfv(1) = zero
    cfv(2) = zero
    cfv(3) = zero
    cmp(1) = zero
    cmp(2) = zero
    cmp(3) = zero
    cmv(1) = zero
    cmv(2) = zero
    cmv(3) = zero
    yplusmax = zero
    sepsensor = zero
    cavitation = zero
    sepsensoravg = zero
! loop over the boundary subfaces of this block.
bocos:do nn=1,nbocos
!
!         integrate the inviscid contribution over the solid walls,    
!         either inviscid or viscous. the integration is done with     
!         cp. for closed contours this is equal to the integration     
!         of p; for open contours this is not the case anymore.        
!         question is whether a force for an open contour is           
!         meaningful anyway.                                           
!
      if (bsearchintegers(bcdata(nn)%famid, famgroups, size(famgroups)) &
&         .gt. 0) then
        if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&           nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! subface is a wall. check if it is a viscous wall.
          viscoussubface = .true.
          if (bctype(nn) .eq. eulerwall) viscoussubface = .false.
! set a bunch of pointers depending on the face id to make
! a generic treatment possible. the routine setbcpointers
! is not used, because quite a few other ones are needed.
          call setbcpointers(nn, .true.)
          select case  (bcfaceid(nn)) 
          case (imin) 
            fact = -one
          case (imax) 
            fact = one
          case (jmin) 
            fact = -one
          case (jmax) 
            fact = one
          case (kmin) 
            fact = -one
          case (kmax) 
            fact = one
          end select
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(nn)%jnbeg+1),bcdata(nn)%jnend
!    do i=(bcdata(nn)%inbeg+1),bcdata(nn)%inend
          do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
&             bcdata(nn)%inbeg)-1
            i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn&
&             )%inbeg + 1
            j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&             jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
            pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*scaledim
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1)) - refpoint(1)
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2)) - refpoint(2)
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3)) - refpoint(3)
            if (bcdata(nn)%iblank(i, j) .lt. 0) then
              blk = 0
            else
              blk = bcdata(nn)%iblank(i, j)
            end if
            fx = pm1*ssi(i, j, 1)
            fy = pm1*ssi(i, j, 2)
            fz = pm1*ssi(i, j, 3)
! iblank forces
            fx = fx*blk
            fy = fy*blk
            fz = fz*blk
! update the inviscid force and moment coefficients.
            cfp(1) = cfp(1) + fx
            cfp(2) = cfp(2) + fy
            cfp(3) = cfp(3) + fz
            mx = yc*fz - zc*fy
            my = zc*fx - xc*fz
            mz = xc*fy - yc*fx
            cmp(1) = cmp(1) + mx
            cmp(2) = cmp(2) + my
            cmp(3) = cmp(3) + mz
! save the face-based forces and area
            bcdata(nn)%fp(i, j, 1) = fx
            bcdata(nn)%fp(i, j, 2) = fy
            bcdata(nn)%fp(i, j, 3) = fz
            cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j&
&             , 3)**2)
            bcdata(nn)%area(i, j) = cellarea
! get normalized surface velocity:
            v(1) = ww2(i, j, ivx)
            v(2) = ww2(i, j, ivy)
            v(3) = ww2(i, j, ivz)
            v = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
! dot product with free stream
            sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)&
&             +v(3)*veldirfreestream(3))
!now run through a smooth heaviside function:
            sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&             sepsensoroffset))))
! and integrate over the area of this cell and save:
            sensor = sensor*cellarea
            sepsensor = sepsensor + sensor
! also accumulate into the sepsensoravg
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1))
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2))
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3))
            sepsensoravg(1) = sepsensoravg(1) + sensor*xc
            sepsensoravg(2) = sepsensoravg(2) + sensor*yc
            sepsensoravg(3) = sepsensoravg(3) + sensor*zc
            plocal = pp2(i, j)
            tmp = two/(gammainf*pinf*machcoef*machcoef)
            cp = tmp*(plocal-pinf)
            sigma = 1.4
            sensor1 = -cp - sigma
            sensor1 = one/(one+exp(-(2*10*sensor1)))
            sensor1 = sensor1*cellarea
            cavitation = cavitation + sensor1
          end do
!
!           integration of the viscous forces.                         
!           only for viscous boundaries.                               
!
          if (viscoussubface) then
! initialize dwall for the laminar case and set the pointer
! for the unit normals.
            dwall = zero
! replace norm with bcdata norm - peter lyu
!norm => bcdata(nn)%norm
! loop over the quadrilateral faces of the subface and
! compute the viscous contribution to the force and
! moment and update the maximum value of y+.
            do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%&
&               inend-bcdata(nn)%inbeg)-1
              i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(&
&               nn)%inbeg + 1
              j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&               jnbeg + 1
              if (bcdata(nn)%iblank(i, j) .lt. 0) then
                blk = 0
              else
                blk = bcdata(nn)%iblank(i, j)
              end if
              tauxx = viscsubface(nn)%tau(i, j, 1)
              tauyy = viscsubface(nn)%tau(i, j, 2)
              tauzz = viscsubface(nn)%tau(i, j, 3)
              tauxy = viscsubface(nn)%tau(i, j, 4)
              tauxz = viscsubface(nn)%tau(i, j, 5)
              tauyz = viscsubface(nn)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
              fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*&
&               ssi(i, j, 3))*scaledim)
              fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*&
&               ssi(i, j, 3))*scaledim)
              fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*&
&               ssi(i, j, 3))*scaledim)
! iblank forces after saving for zipper mesh
              tauxx = tauxx*blk
              tauyy = tauyy*blk
              tauzz = tauzz*blk
              tauxy = tauxy*blk
              tauxz = tauxz*blk
              tauyz = tauyz*blk
              fx = fx*blk
              fy = fy*blk
              fz = fz*blk
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
              xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+&
&               1, j+1, 1)) - refpoint(1)
              yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+&
&               1, j+1, 2)) - refpoint(2)
              zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+&
&               1, j+1, 3)) - refpoint(3)
! update the viscous force and moment coefficients.
              cfv(1) = cfv(1) + fx
              cfv(2) = cfv(2) + fy
              cfv(3) = cfv(3) + fz
              mx = yc*fz - zc*fy
              my = zc*fx - xc*fz
              mz = xc*fy - yc*fx
              cmv(1) = cmv(1) + mx
              cmv(2) = cmv(2) + my
              cmv(3) = cmv(3) + mz
! save the face based forces for the slice operations
              bcdata(nn)%fv(i, j, 1) = fx
              bcdata(nn)%fv(i, j, 2) = fy
              bcdata(nn)%fv(i, j, 3) = fz
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
              fx = tauxx*bcdata(nn)%norm(i, j, 1) + tauxy*bcdata(nn)%&
&               norm(i, j, 2) + tauxz*bcdata(nn)%norm(i, j, 3)
              fy = tauxy*bcdata(nn)%norm(i, j, 1) + tauyy*bcdata(nn)%&
&               norm(i, j, 2) + tauyz*bcdata(nn)%norm(i, j, 3)
              fz = tauxz*bcdata(nn)%norm(i, j, 1) + tauyz*bcdata(nn)%&
&               norm(i, j, 2) + tauzz*bcdata(nn)%norm(i, j, 3)
              fn = fx*bcdata(nn)%norm(i, j, 1) + fy*bcdata(nn)%norm(i, j&
&               , 2) + fz*bcdata(nn)%norm(i, j, 3)
              fx = fx - fn*bcdata(nn)%norm(i, j, 1)
              fy = fy - fn*bcdata(nn)%norm(i, j, 2)
              fz = fz - fn*bcdata(nn)%norm(i, j, 3)
            end do
          else
! compute the local value of y+. due to the usage
! of pointers there is on offset of -1 in dd2wall..
! if we had no viscous force, set the viscous component to zero
            bcdata(nn)%fv = zero
          end if
          call resetbcpointers(nn, .true.)
        end if
      else if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&         nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! if it wasn't included, but still a wall...zero
        bcdata(nn)%area = zero
        bcdata(nn)%fp = zero
        bcdata(nn)%fv = zero
      end if
    end do bocos
! currently the coefficients only contain the surface integral
! of the pressure tensor. these values must be scaled to
! obtain the correct coefficients.
    fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
&     scaledim)
    cfp(1) = cfp(1)*fact
    cfp(2) = cfp(2)*fact
    cfp(3) = cfp(3)*fact
    cfv(1) = cfv(1)*fact
    cfv(2) = cfv(2)*fact
    cfv(3) = cfv(3)*fact
    fact = fact/(lengthref*lref)
    cmp(1) = cmp(1)*fact
    cmp(2) = cmp(2)*fact
    cmp(3) = cmp(3)*fact
    cmv(1) = cmv(1)*fact
    cmv(2) = cmv(2)*fact
    cmv(3) = cmv(3)*fact
  end subroutine forcesandmoments
end module surfaceintegrations_fast_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module surfaceintegrations_fast_b
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
  subroutine flowproperties(localvalues)
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use bcroutines_fast_b
    use costfunctions
    use surfacefamilies
    use sorting, only : bsearchintegers
    use utils_fast_b, only : setbcpointers, resetbcpointers
    use flowutils_fast_b, only : computeptot, computettot
    use bcpointers_fast_b
    implicit none
!
!      subroutine arguments
!
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
! local variables
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps
    integer(kind=inttype) :: nn, i, j, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: sf, vnm, vxm, vym, vzm
    real(kind=realtype) :: pm, ptot, ttot, rhom, massflowratelocal, tmp
    intrinsic size
    intrinsic mod
    massflowrate = zero
    mass_ptot = zero
    mass_ttot = zero
    mass_ps = zero
    sf = zero
bocos:do nn=1,nbocos
      if (bsearchintegers(bcdata(nn)%famid, famgroups, size(famgroups)) &
&         .gt. 0) then
        call setbcpointers(nn, .true.)
        if (((bctype(nn) .eq. subsonicinflow .or. bctype(nn) .eq. &
&           supersonicinflow) .or. bctype(nn) .eq. subsonicoutflow) .or.&
&           bctype(nn) .eq. supersonicoutflow) then
          select case  (bcfaceid(nn)) 
          case (imin) 
            fact = -one
          case (imax) 
            fact = one
          case (jmin) 
            fact = -one
          case (jmax) 
            fact = one
          case (kmin) 
            fact = -one
          case (kmax) 
            fact = one
          end select
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(nn)%jnbeg+1),bcdata(nn)%jnend
!    do i=(bcdata(nn)%inbeg+1),bcdata(nn)%inend
          do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
&             bcdata(nn)%inbeg)-1
            i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn&
&             )%inbeg + 1
            j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&             jnbeg + 1
            if (addgridvelocities) sf = sface(i, j)
            vxm = half*(ww1(i, j, ivx)+ww2(i, j, ivx))
            vym = half*(ww1(i, j, ivy)+ww2(i, j, ivy))
            vzm = half*(ww1(i, j, ivz)+ww2(i, j, ivz))
            rhom = half*(ww1(i, j, irho)+ww2(i, j, irho))
            pm = half*(pp1(i, j)+pp2(i, j))
            vnm = vxm*ssi(i, j, 1) + vym*ssi(i, j, 2) + vzm*ssi(i, j, 3)&
&             - sf
            massflowratelocal = rhom*vnm
            massflowrate = massflowrate + massflowratelocal
            call computeptot(rhom, vxm, vym, vzm, pm, ptot)
            call computettot(rhom, vxm, vym, vzm, pm, ttot)
            mass_ptot = mass_ptot + ptot*massflowratelocal
            mass_ttot = mass_ttot + ttot*massflowratelocal
            mass_ps = mass_ps + pm*massflowratelocal
          end do
          massflowrate = massflowrate*fact
          mass_ptot = mass_ptot*fact
          mass_ttot = mass_ttot*fact
          mass_ps = mass_ps*fact
        end if
      end if
    end do bocos
! increment the local values array with what we computed here
    localvalues(imassflow) = localvalues(imassflow) + massflowrate
    localvalues(imassptot) = localvalues(imassptot) + mass_ptot
    localvalues(imassttot) = localvalues(imassttot) + mass_ttot
    localvalues(imassps) = localvalues(imassps) + mass_ps
  end subroutine flowproperties
  subroutine forcesandmoments(localvalues)
!
!       forcesandmoments computes the contribution of the block
!       given by the pointers in blockpointers to the force and
!       moment of the geometry. a distinction is made
!       between the inviscid and viscous parts. in case the maximum
!       yplus value must be monitored (only possible for rans), this
!       value is also computed. the separation sensor and the cavita-
!       tion sensor is also computed
!       here.
!
    use constants
    use communication
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use bcroutines_fast_b
    use costfunctions
    use surfacefamilies
    use sorting, only : bsearchintegers
    use utils_fast_b, only : setbcpointers, resetbcpointers
    use bcpointers_fast_b
    implicit none
!
!      subroutine arguments
!
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
!
!      local variables.
!
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype) :: yplusmax, sepsensor, sepsensoravg(3), &
&   cavitation
    integer(kind=inttype) :: nn, i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
    real(kind=realtype) :: xc, yc, zc, qf(3)
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: v(3), sensor, sensor1, cp, tmp, plocal
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype) :: mx, my, mz, cellarea
    logical :: viscoussubface
    intrinsic size
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
    fp = zero
    fv = zero
    mp = zero
    mv = zero
    yplusmax = zero
    sepsensor = zero
    cavitation = zero
    sepsensoravg = zero
! loop over the boundary subfaces of this block.
bocos:do nn=1,nbocos
!
!         integrate the inviscid contribution over the solid walls,
!         either inviscid or viscous. the integration is done with
!         cp. for closed contours this is equal to the integration
!         of p; for open contours this is not the case anymore.
!         question is whether a force for an open contour is
!         meaningful anyway.
!
      if (bsearchintegers(bcdata(nn)%famid, famgroups, size(famgroups)) &
&         .gt. 0) then
        if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&           nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! subface is a wall. check if it is a viscous wall.
          viscoussubface = .true.
          if (bctype(nn) .eq. eulerwall) viscoussubface = .false.
! set a bunch of pointers depending on the face id to make
! a generic treatment possible. the routine setbcpointers
! is not used, because quite a few other ones are needed.
          call setbcpointers(nn, .true.)
          select case  (bcfaceid(nn)) 
          case (imin) 
            fact = -one
          case (imax) 
            fact = one
          case (jmin) 
            fact = -one
          case (jmax) 
            fact = one
          case (kmin) 
            fact = -one
          case (kmax) 
            fact = one
          end select
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(nn)%jnbeg+1),bcdata(nn)%jnend
!    do i=(bcdata(nn)%inbeg+1),bcdata(nn)%inend
          do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
&             bcdata(nn)%inbeg)-1
            i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn&
&             )%inbeg + 1
            j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&             jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
            pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1)) - refpoint(1)
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2)) - refpoint(2)
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3)) - refpoint(3)
            if (bcdata(nn)%iblank(i, j) .lt. 0) then
              blk = 0
            else
              blk = bcdata(nn)%iblank(i, j)
            end if
            fx = pm1*ssi(i, j, 1)
            fy = pm1*ssi(i, j, 2)
            fz = pm1*ssi(i, j, 3)
! iblank forces
            fx = fx*blk
            fy = fy*blk
            fz = fz*blk
! update the inviscid force and moment coefficients.
            fp(1) = fp(1) + fx
            fp(2) = fp(2) + fy
            fp(3) = fp(3) + fz
            mx = yc*fz - zc*fy
            my = zc*fx - xc*fz
            mz = xc*fy - yc*fx
            mp(1) = mp(1) + mx
            mp(2) = mp(2) + my
            mp(3) = mp(3) + mz
! save the face-based forces and area
            bcdata(nn)%fp(i, j, 1) = fx
            bcdata(nn)%fp(i, j, 2) = fy
            bcdata(nn)%fp(i, j, 3) = fz
            cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j&
&             , 3)**2)
            bcdata(nn)%area(i, j) = cellarea
! get normalized surface velocity:
            v(1) = ww2(i, j, ivx)
            v(2) = ww2(i, j, ivy)
            v(3) = ww2(i, j, ivz)
            v = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
! dot product with free stream
            sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)&
&             +v(3)*veldirfreestream(3))
!now run through a smooth heaviside function:
            sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&             sepsensoroffset))))
! and integrate over the area of this cell and save:
            sensor = sensor*cellarea
            sepsensor = sepsensor + sensor
! also accumulate into the sepsensoravg
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1))
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2))
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3))
            sepsensoravg(1) = sepsensoravg(1) + sensor*xc
            sepsensoravg(2) = sepsensoravg(2) + sensor*yc
            sepsensoravg(3) = sepsensoravg(3) + sensor*zc
            plocal = pp2(i, j)
            tmp = two/(gammainf*machcoef*machcoef)
            cp = tmp*(plocal-pinf)
            sigma = 1.4
            sensor1 = -cp - sigma
            sensor1 = one/(one+exp(-(2*10*sensor1)))
            sensor1 = sensor1*cellarea
            cavitation = cavitation + sensor1
          end do
!
!           integration of the viscous forces.
!           only for viscous boundaries.
!
          if (viscoussubface) then
! initialize dwall for the laminar case and set the pointer
! for the unit normals.
            dwall = zero
! replace norm with bcdata norm - peter lyu
!norm => bcdata(nn)%norm
! loop over the quadrilateral faces of the subface and
! compute the viscous contribution to the force and
! moment and update the maximum value of y+.
            do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%&
&               inend-bcdata(nn)%inbeg)-1
              i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(&
&               nn)%inbeg + 1
              j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&               jnbeg + 1
              if (bcdata(nn)%iblank(i, j) .lt. 0) then
                blk = 0
              else
                blk = bcdata(nn)%iblank(i, j)
              end if
              tauxx = viscsubface(nn)%tau(i, j, 1)
              tauyy = viscsubface(nn)%tau(i, j, 2)
              tauzz = viscsubface(nn)%tau(i, j, 3)
              tauxy = viscsubface(nn)%tau(i, j, 4)
              tauxz = viscsubface(nn)%tau(i, j, 5)
              tauyz = viscsubface(nn)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
              fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*&
&               ssi(i, j, 3))*pref)
              fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*&
&               ssi(i, j, 3))*pref)
              fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*&
&               ssi(i, j, 3))*pref)
! iblank forces after saving for zipper mesh
              tauxx = tauxx*blk
              tauyy = tauyy*blk
              tauzz = tauzz*blk
              tauxy = tauxy*blk
              tauxz = tauxz*blk
              tauyz = tauyz*blk
              fx = fx*blk
              fy = fy*blk
              fz = fz*blk
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
              xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+&
&               1, j+1, 1)) - refpoint(1)
              yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+&
&               1, j+1, 2)) - refpoint(2)
              zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+&
&               1, j+1, 3)) - refpoint(3)
! update the viscous force and moment coefficients.
              fv(1) = fv(1) + fx
              fv(2) = fv(2) + fy
              fv(3) = fv(3) + fz
              mx = yc*fz - zc*fy
              my = zc*fx - xc*fz
              mz = xc*fy - yc*fx
              mv(1) = mv(1) + mx
              mv(2) = mv(2) + my
              mv(3) = mv(3) + mz
! save the face based forces for the slice operations
              bcdata(nn)%fv(i, j, 1) = fx
              bcdata(nn)%fv(i, j, 2) = fy
              bcdata(nn)%fv(i, j, 3) = fz
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
              fx = tauxx*bcdata(nn)%norm(i, j, 1) + tauxy*bcdata(nn)%&
&               norm(i, j, 2) + tauxz*bcdata(nn)%norm(i, j, 3)
              fy = tauxy*bcdata(nn)%norm(i, j, 1) + tauyy*bcdata(nn)%&
&               norm(i, j, 2) + tauyz*bcdata(nn)%norm(i, j, 3)
              fz = tauxz*bcdata(nn)%norm(i, j, 1) + tauyz*bcdata(nn)%&
&               norm(i, j, 2) + tauzz*bcdata(nn)%norm(i, j, 3)
              fn = fx*bcdata(nn)%norm(i, j, 1) + fy*bcdata(nn)%norm(i, j&
&               , 2) + fz*bcdata(nn)%norm(i, j, 3)
              fx = fx - fn*bcdata(nn)%norm(i, j, 1)
              fy = fy - fn*bcdata(nn)%norm(i, j, 2)
              fz = fz - fn*bcdata(nn)%norm(i, j, 3)
            end do
          else
! compute the local value of y+. due to the usage
! of pointers there is on offset of -1 in dd2wall..
! if we had no viscous force, set the viscous component to zero
            bcdata(nn)%fv = zero
          end if
          call resetbcpointers(nn, .true.)
        end if
      else if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&         nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! if it wasn't included, but still a wall...zero
        bcdata(nn)%area = zero
        bcdata(nn)%fp = zero
        bcdata(nn)%fv = zero
      end if
    end do bocos
! increment the local values array with the values we computed here.
    localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
    localvalues(ifv:ifv+2) = localvalues(ifv:ifv+2) + fv
    localvalues(imp:imp+2) = localvalues(imp:imp+2) + mp
    localvalues(imv:imv+2) = localvalues(imv:imv+2) + mv
    localvalues(isepsensor) = localvalues(isepsensor) + sepsensor
    localvalues(icavitation) = localvalues(icavitation) + cavitation
    localvalues(isepavg:isepavg+2) = localvalues(isepavg:isepavg+2) + &
&     sepsensoravg
  end subroutine forcesandmoments
end module surfaceintegrations_fast_b

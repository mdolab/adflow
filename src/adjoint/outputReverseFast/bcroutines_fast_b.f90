!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!      ******************************************************************
!      *                                                                *
!      * file:          bcroutines.f90                                   *
!      * author:        gaetan k. w. kenway                             *
!      * starting date: 01-23-2015                                      *
!      * last modified: 01-23-2015                                      *
!      *                                                                *
!      ******************************************************************
!
!      ******************************************************************
!      *                                                                *
!      * this module contains data structures *and* routines used       *
!      * for applying *all* boundary conditions for navier stokes part  *
!      * of the code. the reason for using a module to contain the      *
!      * routines is that due to the use of pointers, it eliminates the *
!      * need for using interfaces. all former bc*.f90 routines are now *
!      * included in this module.                                       *
!      *                                                                *
!      ******************************************************************
!
module bcroutines_fast_b
  use myPushPopLib
  use constants
  implicit none
  save 
  real(kind=realtype), dimension(:, :, :), pointer :: ww0, ww1, ww2, ww3
  real(kind=realtype), dimension(:, :, :), pointer :: ww0d, ww1d, ww2d, &
& ww3d
  real(kind=realtype), dimension(:, :), pointer :: pp0, pp1, pp2, pp3
  real(kind=realtype), dimension(:, :), pointer :: pp0d, pp1d, pp2d, &
& pp3d
  real(kind=realtype), dimension(:, :), pointer :: rlv0, rlv1, rlv2, &
& rlv3
  real(kind=realtype), dimension(:, :), pointer :: rlv0d, rlv1d, rlv2d, &
& rlv3d
  real(kind=realtype), dimension(:, :), pointer :: rev0, rev1, rev2, &
& rev3
  real(kind=realtype), dimension(:, :), pointer :: rev0d, rev1d, rev2d, &
& rev3d
  real(kind=realtype), dimension(:, :), pointer :: gamma0, gamma1, &
& gamma2, gamma3
  real(kind=realtype), dimension(:, :, :), pointer :: ssi, ssj, ssk
  real(kind=realtype), dimension(:, :, :), pointer :: ss, xx
  real(kind=realtype), dimension(:, :), pointer :: dd2wall
  integer(kind=inttype) :: istart, iend, isize
  integer(kind=inttype) :: jstart, jend, jsize

contains
  subroutine applyallbc_block(secondhalo)
! apply bc's for a single block
    use blockpointers
    use flowvarrefstate
    use inputdiscretization
    use inputtimespectral
    use iteration
    use bctypes
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
! local variables.
    logical :: correctfork
    integer(kind=inttype) :: nn
!
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .le. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
! apply all the boundary conditions. the order is important!  only
! some of them have been ad'ed
! ------------------------------------
!  symmetry boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers(nn, .false.)
        call bcsymm(nn, secondhalo)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  adibatic wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers(nn, .false.)
        call bcnswalladiabatic(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  isotermal wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers(nn, .false.)
        call bcnswallisothermal(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  farfield boundary condition 
! ------------------------------------
    if (precond .eq. turkel .or. precond .eq. choimerkle) call &
&     terminate('applyallbc', &
&      'farfield turkel and coid/merkle preconditioners not implemented'&
&           )
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers(nn, .false.)
        call bcfarfield(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  euler wall boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. eulerwall) then
        call setbcpointers(nn, .true.)
        call bceulerwall(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .true.)
      end if
    end do
  end subroutine applyallbc_block
!  differentiation of bcsymm in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *rev2 *rev3 *pp0
!                *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ww0 *ww1
!                *ww2 *ww3
!   with respect to varying inputs: *rev0 *rev1 *rev2 *rev3 *pp0
!                *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ww0 *ww1
!                *ww2 *ww3
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:incr
!                *rev3:incr *pp0:in-out *pp1:in-out *pp2:incr *pp3:incr
!                *rlv0:in-out *rlv1:in-out *rlv2:incr *rlv3:incr
!                *ww0:in-out *ww1:in-out *ww2:incr *ww3:incr
!   plus diff mem management of: rev0:in rev1:in rev2:in rev3:in
!                pp0:in pp1:in pp2:in pp3:in rlv0:in rlv1:in rlv2:in
!                rlv3:in ww0:in ww1:in ww2:in ww3:in
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm_fast_b(nn, secondhalo)
!
! ******************************************************************
! *                                                                *
! * bcsymm applies the symmetry boundary conditions to a block.    *
! * it is assumed that the pointers in blockpointers are already   *
! * set to the correct block on the correct grid level.            *
! *                                                                *
! * in case also the second halo must be set the loop over the     *
! * boundary subfaces is executed twice. this is the only correct  *
! * way in case the block contains only 1 cell between two         *
! * symmetry planes, i.e. a 2d problem.                            *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
    if (secondhalo) then
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! determine the flow variables in the halo cell.
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
        if (viscous) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
        else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
        end if
        if (eddymodel) then
          rev3d(i, j) = rev3d(i, j) + rev0d(i, j)
          rev0d(i, j) = 0.0_8
        end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
        if (branch .eq. 0) then
          rlv3d(i, j) = rlv3d(i, j) + rlv0d(i, j)
          rlv0d(i, j) = 0.0_8
        end if
        pp3d(i, j) = pp3d(i, j) + pp0d(i, j)
        pp0d(i, j) = 0.0_8
        do l=nt1mg,nt2mg
          ww3d(i, j, l) = ww3d(i, j, l) + ww0d(i, j, l)
          ww0d(i, j, l) = 0.0_8
        end do
        ww3d(i, j, irhoe) = ww3d(i, j, irhoe) + ww0d(i, j, irhoe)
        ww0d(i, j, irhoe) = 0.0_8
        ww3d(i, j, ivz) = ww3d(i, j, ivz) + ww0d(i, j, ivz)
        vnd = -(bcdata(nn)%norm(i, j, 3)*ww0d(i, j, ivz))
        ww0d(i, j, ivz) = 0.0_8
        ww3d(i, j, ivy) = ww3d(i, j, ivy) + ww0d(i, j, ivy)
        vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww0d(i, j, ivy)
        ww0d(i, j, ivy) = 0.0_8
        ww3d(i, j, ivx) = ww3d(i, j, ivx) + ww0d(i, j, ivx)
        vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww0d(i, j, ivx)
        ww0d(i, j, ivx) = 0.0_8
        ww3d(i, j, irho) = ww3d(i, j, irho) + ww0d(i, j, irho)
        ww0d(i, j, irho) = 0.0_8
        tempd0 = two*vnd
        ww3d(i, j, ivx) = ww3d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*&
&         tempd0
        ww3d(i, j, ivy) = ww3d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*&
&         tempd0
        ww3d(i, j, ivz) = ww3d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*&
&         tempd0
      end do
    end if
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
! determine the flow variables in the halo cell.
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      if (viscous) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
        rlv1d(i, j) = 0.0_8
      end if
      pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
      pp1d(i, j) = 0.0_8
      do l=nt1mg,nt2mg
        ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
        ww1d(i, j, l) = 0.0_8
      end do
      ww2d(i, j, irhoe) = ww2d(i, j, irhoe) + ww1d(i, j, irhoe)
      ww1d(i, j, irhoe) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + ww1d(i, j, ivz)
      vnd = -(bcdata(nn)%norm(i, j, 3)*ww1d(i, j, ivz))
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + ww1d(i, j, ivy)
      vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + ww1d(i, j, ivx)
      vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
      ww1d(i, j, irho) = 0.0_8
      tempd = two*vnd
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*tempd
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*tempd
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*tempd
    end do
  end subroutine bcsymm_fast_b
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm(nn, secondhalo)
!
! ******************************************************************
! *                                                                *
! * bcsymm applies the symmetry boundary conditions to a block.    *
! * it is assumed that the pointers in blockpointers are already   *
! * set to the correct block on the correct grid level.            *
! *                                                                *
! * in case also the second halo must be set the loop over the     *
! * boundary subfaces is executed twice. this is the only correct  *
! * way in case the block contains only 1 cell between two         *
! * symmetry planes, i.e. a 2d problem.                            *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! loop over the generic subface to set the state in the
! 1-st level halos 
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! simply copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(i, j, l) = ww2(i, j, l)
      end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma1(i, j) = gamma2(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
    if (secondhalo) then
! if we need the second halo, do everything again, but using ww0,
! ww3 etc instead of ww2 and ww1. 
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
&         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
&         , 3))
! determine the flow variables in the halo cell.
        ww0(i, j, irho) = ww3(i, j, irho)
        ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
        ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
        ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
        ww0(i, j, irhoe) = ww3(i, j, irhoe)
        do l=nt1mg,nt2mg
          ww0(i, j, l) = ww3(i, j, l)
        end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
        gamma0(i, j) = gamma3(i, j)
        pp0(i, j) = pp3(i, j)
        if (viscous) rlv0(i, j) = rlv3(i, j)
        if (eddymodel) rev0(i, j) = rev3(i, j)
      end do
    end if
  end subroutine bcsymm
!  differentiation of bcnswalladiabatic in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:incr
!                *pp0:in-out *pp1:in-out *pp2:incr *rlv0:in-out
!                *rlv1:in-out *rlv2:incr *ww0:in-out *ww1:in-out
!                *ww2:incr
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in
  subroutine bcnswalladiabatic_fast_b(nn, secondhalo, correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * bcnswalladiabatic applies the viscous adiabatic wall           *
!      * boundary condition the pointers already defined.               *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    real(kind=realtype) :: rhokd
    intrinsic mod
    integer :: branch
! apply the bcwall in case the turbulent transport equations are
! solved together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.  no need
! to extrapolate the secondary halo's, because this is done in
! extrapolate2ndhalo. this is only necesssary when correcting for
! k. *this is not currently included in ad. it will be required
! for the 2-equation turbulence models. 
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_fast_b(correctfork)
    call computeetot_fast_b(ww1, ww1d, pp1, pp1d, correctfork)
    rhokd = 0.0_8
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
      rlv1d(i, j) = 0.0_8
      pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
      rhokd = rhokd - four*third*pp1d(i, j)
      pp1d(i, j) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
      ww1d(i, j, irho) = 0.0_8
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
        ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
        rhokd = 0.0_8
      end if
    end do
  end subroutine bcnswalladiabatic_fast_b
  subroutine bcnswalladiabatic(nn, secondhalo, correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * bcnswalladiabatic applies the viscous adiabatic wall           *
!      * boundary condition the pointers already defined.               *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    intrinsic mod
! apply the bcwall in case the turbulent transport equations are
! solved together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.  no need
! to extrapolate the secondary halo's, because this is done in
! extrapolate2ndhalo. this is only necesssary when correcting for
! k. *this is not currently included in ad. it will be required
! for the 2-equation turbulence models. 
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswalladiabatic
!  differentiation of bcnswallisothermal in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:incr
!                *pp0:in-out *pp1:in-out *pp2:incr *rlv0:in-out
!                *rlv1:in-out *rlv2:incr *ww0:in-out *ww1:in-out
!                *ww2:incr
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in
  subroutine bcnswallisothermal_fast_b(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bcnswalladiabatic applies the viscous isothermal wall          *
! * boundary condition to a block. it is assumed that the          *
! * bcpointers are already set                                     *
! *                                                                *
! ******************************************************************
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok, t2, t1
    real(kind=realtype) :: rhokd, t2d, t1d
    intrinsic mod
    intrinsic max
    intrinsic min
    integer :: branch
    real(kind=realtype) :: tempd
    real(kind=realtype) :: temp
! in case the turbulent transport equations are solved
! together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.
! no need to extrapolate the secondary halo's, because this
! is done in extrapolate2ndhalo.
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1(i, j) = pp2(i, j) - four*third*rhok
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_fast_b(correctfork)
    call computeetot_fast_b(ww1, ww1d, pp1, pp1d, correctfork)
    rhokd = 0.0_8
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        rhok = ww2(i, j, irho)*ww2(i, j, itu1)
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      end if
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
      rlv1d(i, j) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      tempd = ww1d(i, j, irho)/(rgas*t1)
      pp1d(i, j) = pp1d(i, j) + tempd
      t1d = -(pp1(i, j)*tempd/t1)
      ww1d(i, j, irho) = 0.0_8
      pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
      rhokd = rhokd - four*third*pp1d(i, j)
      pp1d(i, j) = 0.0_8
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .ne. 0) t1d = 0.0_8
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .ne. 0) t1d = 0.0_8
      t2d = -t1d
      temp = rgas*ww2(i, j, irho)
      pp2d(i, j) = pp2d(i, j) + t2d/temp
      ww2d(i, j, irho) = ww2d(i, j, irho) - pp2(i, j)*rgas*t2d/temp**2
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .ne. 0) then
        ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
        ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
        rhokd = 0.0_8
      end if
    end do
  end subroutine bcnswallisothermal_fast_b
  subroutine bcnswallisothermal(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bcnswalladiabatic applies the viscous isothermal wall          *
! * boundary condition to a block. it is assumed that the          *
! * bcpointers are already set                                     *
! *                                                                *
! ******************************************************************
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok, t2, t1
    intrinsic mod
    intrinsic max
    intrinsic min
! in case the turbulent transport equations are solved
! together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.
! no need to extrapolate the secondary halo's, because this
! is done in extrapolate2ndhalo.
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1(i, j) = pp2(i, j) - four*third*rhok
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswallisothermal
!  differentiation of bceulerwall in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:incr
!                *pp0:in-out *pp1:in-out *pp2:incr *pp3:incr *rlv0:in-out
!                *rlv1:in-out *rlv2:incr *ww0:in-out *ww1:in-out
!                *ww2:incr
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in pp3:in rlv0:in rlv1:in rlv2:in ww0:in
!                ww1:in ww2:in
  subroutine bceulerwall_fast_b(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bceulerwall applies the inviscid wall boundary condition to    *
! * a block. it is assumed that the bcpointers are                 *
! * already set to the correct block on the correct grid level.    *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: vnd
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype), dimension(isize, jsize) :: grad
    real(kind=realtype), dimension(isize, jsize) :: gradd
    intrinsic mod
    real(kind=realtype) :: dim
    integer :: branch
    real(kind=realtype) :: tempd
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = wallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
! **************************************************************
! *                                                            *
! * determine the boundary condition treatment and compute the *
! * undivided pressure gradient accordingly. this gradient is  *
! * temporarily stored in the halo pressure.                   *
! *                                                            *
! **************************************************************
!
    select case  (walltreatment) 
    case (constantpressure) 
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation. 
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
    case default
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = dim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! just copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(j, k, l) = ww2(j, k, l)
      end do
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_fast_b(correctfork)
    call computeetot_fast_b(ww1, ww1d, pp1, pp1d, correctfork)
    gradd = 0.0_8
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
! the laminar and eddy viscosity, if present.
      if (viscous) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (eddymodel) then
        rev2d(j, k) = rev2d(j, k) + rev1d(j, k)
        rev1d(j, k) = 0.0_8
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        rlv2d(j, k) = rlv2d(j, k) + rlv1d(j, k)
        rlv1d(j, k) = 0.0_8
      end if
      do l=nt2mg,nt1mg,-1
        ww2d(j, k, l) = ww2d(j, k, l) + ww1d(j, k, l)
        ww1d(j, k, l) = 0.0_8
      end do
      ww2d(j, k, ivz) = ww2d(j, k, ivz) + ww1d(j, k, ivz)
      vnd = bcdata(nn)%norm(j, k, 3)*ww1d(j, k, ivz)
      ww1d(j, k, ivz) = 0.0_8
      ww2d(j, k, ivy) = ww2d(j, k, ivy) + ww1d(j, k, ivy)
      vnd = vnd + bcdata(nn)%norm(j, k, 2)*ww1d(j, k, ivy)
      ww1d(j, k, ivy) = 0.0_8
      ww2d(j, k, ivx) = ww2d(j, k, ivx) + ww1d(j, k, ivx)
      vnd = vnd + bcdata(nn)%norm(j, k, 1)*ww1d(j, k, ivx)
      ww1d(j, k, ivx) = 0.0_8
      ww2d(j, k, irho) = ww2d(j, k, irho) + ww1d(j, k, irho)
      ww1d(j, k, irho) = 0.0_8
      tempd = two*vnd
      ww2d(j, k, ivx) = ww2d(j, k, ivx) - bcdata(nn)%norm(j, k, 1)*tempd
      ww2d(j, k, ivy) = ww2d(j, k, ivy) - bcdata(nn)%norm(j, k, 2)*tempd
      ww2d(j, k, ivz) = ww2d(j, k, ivz) - bcdata(nn)%norm(j, k, 3)*tempd
      call dim_fast_b(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k), &
&               pp1d(j, k))
      pp1d(j, k) = 0.0_8
    end do
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
    if (branch .eq. 0) then
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        pp3d(j, k) = pp3d(j, k) + gradd(j, k)
        pp2d(j, k) = pp2d(j, k) - gradd(j, k)
        gradd(j, k) = 0.0_8
      end do
    end if
  end subroutine bceulerwall_fast_b
  subroutine bceulerwall(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bceulerwall applies the inviscid wall boundary condition to    *
! * a block. it is assumed that the bcpointers are                 *
! * already set to the correct block on the correct grid level.    *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype), dimension(isize, jsize) :: grad
    intrinsic mod
    real(kind=realtype) :: dim
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = wallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
! **************************************************************
! *                                                            *
! * determine the boundary condition treatment and compute the *
! * undivided pressure gradient accordingly. this gradient is  *
! * temporarily stored in the halo pressure.                   *
! *                                                            *
! **************************************************************
!
    select case  (walltreatment) 
    case (constantpressure) 
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation. 
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = dim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! just copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(j, k, l) = ww2(j, k, l)
      end do
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bceulerwall
!  differentiation of bcfarfield in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:incr
!                *pp0:in-out *pp1:in-out *pp2:incr *rlv0:in-out
!                *rlv1:in-out *rlv2:incr *ww0:in-out *ww1:in-out
!                *ww2:incr
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in
  subroutine bcfarfield_fast_b(nn, secondhalo, correctfork)
!      ******************************************************************
!      *                                                                *
!      * bcfarfield applies the farfield boundary condition to a block. *
!      * it is assumed that the bcpointers are already set              *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: ac1d, ac2d
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: red, ued, ved, wed, qned, ced
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    real(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
    intrinsic sqrt
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    c0 = sqrt(gammainf*pinfcorr*r0)
    s0 = winf(irho)**gammainf/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
        end do
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        do l=nt1mg,nt2mg
          ww1(i, j, l) = winf(l)
        end do
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_fast_b(correctfork)
    call computeetot_fast_b(ww1, ww1d, pp1, pp1d, correctfork)
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
        end do
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        do l=nt1mg,nt2mg
          ww1(i, j, l) = winf(l)
        end do
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
        rlv1d(i, j) = 0.0_8
      end if
      ww1d(i, j, irho) = ww1d(i, j, irho) + cc*pp1d(i, j)
      ccd = ww1(i, j, irho)*pp1d(i, j)
      pp1d(i, j) = 0.0_8
      wfd = ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      vfd = ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ufd = ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      if (sf*cc .le. 0.0_8 .and. (ovgm1 .eq. 0.0_8 .or. ovgm1 .ne. int(&
&         ovgm1))) then
        tempd5 = 0.0
      else
        tempd5 = ovgm1*(sf*cc)**(ovgm1-1)*ww1d(i, j, irho)
      end if
      sfd = cc*tempd5
      ccd = ccd + sf*tempd5
      ww1d(i, j, irho) = 0.0_8
      cfd = 2*cf*ccd/gamma2(i, j)
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        do l=nt1mg,nt2mg
          ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
          ww1d(i, j, l) = 0.0_8
        end do
        tempd4 = bcdata(nn)%norm(i, j, 1)*ufd
        tempd3 = bcdata(nn)%norm(i, j, 2)*vfd
        tempd1 = sfd/pp2(i, j)
        temp = gamma2(i, j)
        if (.not.(ww2(i, j, irho) .le. 0.0_8 .and. (temp .eq. 0.0_8 .or.&
&           temp .ne. int(temp)))) ww2d(i, j, irho) = ww2d(i, j, irho) +&
&           temp*ww2(i, j, irho)**(temp-1)*tempd1
        pp2d(i, j) = pp2d(i, j) - ww2(i, j, irho)**temp*tempd1/pp2(i, j)
        tempd2 = bcdata(nn)%norm(i, j, 3)*wfd
        wed = wfd
        qnfd = tempd3 + tempd4 + tempd2
        qned = -tempd3 - tempd4 - tempd2
        ved = vfd
        ued = ufd
      else
        do l=nt1mg,nt2mg
          ww1d(i, j, l) = 0.0_8
        end do
        qnfd = bcdata(nn)%norm(i, j, 2)*vfd + bcdata(nn)%norm(i, j, 1)*&
&         ufd + bcdata(nn)%norm(i, j, 3)*wfd
        qned = 0.0_8
        ued = 0.0_8
        ved = 0.0_8
        wed = 0.0_8
      end if
      tempd0 = fourth*gm1*cfd
      ac1d = half*qnfd + tempd0
      ac2d = half*qnfd - tempd0
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        qned = qned + ac2d
        ced = -(two*ovgm1*ac2d)
      else
        ced = 0.0_8
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        qned = qned + ac1d
        ced = ced + two*ovgm1*ac1d
      end if
      if (gamma2(i, j)*(pp2(i, j)*re) .eq. 0.0_8) then
        tempd = 0.0
      else
        tempd = gamma2(i, j)*ced/(2.0*sqrt(gamma2(i, j)*(pp2(i, j)*re)))
      end if
      pp2d(i, j) = pp2d(i, j) + re*tempd
      red = pp2(i, j)*tempd
      ued = ued + bcdata(nn)%norm(i, j, 1)*qned
      ved = ved + bcdata(nn)%norm(i, j, 2)*qned
      wed = wed + bcdata(nn)%norm(i, j, 3)*qned
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + wed
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + ved
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + ued
      ww2d(i, j, irho) = ww2d(i, j, irho) - one*red/ww2(i, j, irho)**2
    end do
  end subroutine bcfarfield_fast_b
  subroutine bcfarfield(nn, secondhalo, correctfork)
!      ******************************************************************
!      *                                                                *
!      * bcfarfield applies the farfield boundary condition to a block. *
!      * it is assumed that the bcpointers are already set              *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    intrinsic sqrt
    intrinsic mod
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    c0 = sqrt(gammainf*pinfcorr*r0)
    s0 = winf(irho)**gammainf/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
        end do
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        do l=nt1mg,nt2mg
          ww1(i, j, l) = winf(l)
        end do
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcfarfield
!  differentiation of extrapolate2ndhalo in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
!                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
  subroutine extrapolate2ndhalo_fast_b(correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * extrapolate2ndhalo determines the states of the second layer   *
!      * halo cells for the given subface of the block. it is assumed   *
!      * that the appropriate bcpointers are already set
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use constants
    use flowvarrefstate
    use iteration
    use inputphysics
    implicit none
    logical, intent(in) :: correctfork
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
    integer :: branch
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! extrapolate the turbulent variables. use constant
! extrapolation.
      do l=nt1mg,nt2mg
        ww0(i, j, l) = ww1(i, j, l)
      end do
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
    call computeetot_fast_b(ww0, ww0d, pp0, pp0d, correctfork)
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) then
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (eddymodel) then
        rev1d(i, j) = rev1d(i, j) + rev0d(i, j)
        rev0d(i, j) = 0.0_8
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        rlv1d(i, j) = rlv1d(i, j) + rlv0d(i, j)
        rlv0d(i, j) = 0.0_8
      end if
      do l=nt1mg,nt2mg
        ww1d(i, j, l) = ww1d(i, j, l) + ww0d(i, j, l)
        ww0d(i, j, l) = 0.0_8
      end do
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        pp1d(i, j) = pp1d(i, j) + two*pp0d(i, j)
        pp2d(i, j) = pp2d(i, j) - pp0d(i, j)
        pp0d(i, j) = 0.0_8
      else
        pp1d(i, j) = pp1d(i, j) + factor*pp0d(i, j)
        pp0d(i, j) = 0.0_8
      end if
      ww1d(i, j, ivz) = ww1d(i, j, ivz) + two*ww0d(i, j, ivz)
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww0d(i, j, ivz)
      ww0d(i, j, ivz) = 0.0_8
      ww1d(i, j, ivy) = ww1d(i, j, ivy) + two*ww0d(i, j, ivy)
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww0d(i, j, ivy)
      ww0d(i, j, ivy) = 0.0_8
      ww1d(i, j, ivx) = ww1d(i, j, ivx) + two*ww0d(i, j, ivx)
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww0d(i, j, ivx)
      ww0d(i, j, ivx) = 0.0_8
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .ne. 0) then
        ww1d(i, j, irho) = ww1d(i, j, irho) + factor*ww0d(i, j, irho)
        ww0d(i, j, irho) = 0.0_8
      end if
      ww1d(i, j, irho) = ww1d(i, j, irho) + two*ww0d(i, j, irho)
      ww2d(i, j, irho) = ww2d(i, j, irho) - ww0d(i, j, irho)
      ww0d(i, j, irho) = 0.0_8
    end do
  end subroutine extrapolate2ndhalo_fast_b
!  differentiation of computeetot in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: ww pp
!   with respect to varying inputs: ww pp
  subroutine computeetot_fast_b(ww, wwd, pp, ppd, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use flowvarrefstate
    use inputphysics
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :) :: ppd
    real(kind=realtype), dimension(:, :, :) :: ww
    real(kind=realtype), dimension(:, :, :) :: wwd
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd0
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          tmpd = wwd(i, j, irhoe)
          wwd(i, j, irhoe) = 0.0_8
          tempd = half*ww(i, j, irho)*tmpd
          ppd(i, j) = ppd(i, j) + ovgm1*tmpd
          wwd(i, j, irho) = wwd(i, j, irho) + half*(ww(i, j, ivx)**2+ww(&
&           i, j, ivy)**2+ww(i, j, ivz)**2)*tmpd
          wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd
          wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd
          wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd
        else
          tmpd0 = wwd(i, j, irhoe)
          wwd(i, j, irhoe) = 0.0_8
          tempd0 = half*ww(i, j, irho)*tmpd0
          ppd(i, j) = ppd(i, j) + ovgm1*tmpd0
          wwd(i, j, irho) = wwd(i, j, irho) + (half*(ww(i, j, ivx)**2+ww&
&           (i, j, ivy)**2+ww(i, j, ivz)**2)-factk*ww(i, j, itu1))*tmpd0
          wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd0
          wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd0
          wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd0
          wwd(i, j, itu1) = wwd(i, j, itu1) - factk*ww(i, j, irho)*tmpd0
        end if
      end do
    end select
  end subroutine computeetot_fast_b
  subroutine extrapolate2ndhalo(correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * extrapolate2ndhalo determines the states of the second layer   *
!      * halo cells for the given subface of the block. it is assumed   *
!      * that the appropriate bcpointers are already set
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use constants
    use flowvarrefstate
    use iteration
    use inputphysics
    implicit none
    logical, intent(in) :: correctfork
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! extrapolate the turbulent variables. use constant
! extrapolation.
      do l=nt1mg,nt2mg
        ww0(i, j, l) = ww1(i, j, l)
      end do
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
! compute the energy for this halo range.
    call computeetot(ww0, pp0, correctfork)
  end subroutine extrapolate2ndhalo
  subroutine computeetot(ww, pp, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use flowvarrefstate
    use inputphysics
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :, :) :: ww
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
! loop over the given array and compute the energy, possibly
! correcting for k
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
        else
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
&           j, irho)*ww(i, j, itu1)
        end if
      end do
    case (cptempcurvefits) 
      call terminate('bcroutines', &
&                 'cptempcurvefits not implemented yet.')
    end select
  end subroutine computeetot
  subroutine setbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * setbcpointers sets the pointers needed for the boundary        *
!      * condition treatment on a general face, such that the boundary  *
!      * routines are only implemented once instead of 6 times.         *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      ww3 => w(3, 1:, 1:, :)
      ww2 => w(2, 1:, 1:, :)
      ww1 => w(1, 1:, 1:, :)
      ww0 => w(0, 1:, 1:, :)
      pp3 => p(3, 1:, 1:)
      pp2 => p(2, 1:, 1:)
      pp1 => p(1, 1:, 1:)
      pp0 => p(0, 1:, 1:)
      rlv3 => rlv(3, 1:, 1:)
      rlv2 => rlv(2, 1:, 1:)
      rlv1 => rlv(1, 1:, 1:)
      rlv0 => rlv(0, 1:, 1:)
      rev3 => rev(3, 1:, 1:)
      rev2 => rev(2, 1:, 1:)
      rev1 => rev(1, 1:, 1:)
      rev0 => rev(0, 1:, 1:)
      gamma3 => gamma(3, 1:, 1:)
      gamma2 => gamma(2, 1:, 1:)
      gamma1 => gamma(1, 1:, 1:)
      gamma0 => gamma(0, 1:, 1:)
    case (imax) 
!===============================================================
      ww3 => w(nx, 1:, 1:, :)
      ww2 => w(il, 1:, 1:, :)
      ww1 => w(ie, 1:, 1:, :)
      ww0 => w(ib, 1:, 1:, :)
      pp3 => p(nx, 1:, 1:)
      pp2 => p(il, 1:, 1:)
      pp1 => p(ie, 1:, 1:)
      pp0 => p(ib, 1:, 1:)
      rlv3 => rlv(nx, 1:, 1:)
      rlv2 => rlv(il, 1:, 1:)
      rlv1 => rlv(ie, 1:, 1:)
      rlv0 => rlv(ib, 1:, 1:)
      rev3 => rev(nx, 1:, 1:)
      rev2 => rev(il, 1:, 1:)
      rev1 => rev(ie, 1:, 1:)
      rev0 => rev(ib, 1:, 1:)
      gamma3 => gamma(nx, 1:, 1:)
      gamma2 => gamma(il, 1:, 1:)
      gamma1 => gamma(ie, 1:, 1:)
      gamma0 => gamma(ib, 1:, 1:)
    case (jmin) 
!===============================================================
      ww3 => w(1:, 3, 1:, :)
      ww2 => w(1:, 2, 1:, :)
      ww1 => w(1:, 1, 1:, :)
      ww0 => w(1:, 0, 1:, :)
      pp3 => p(1:, 3, 1:)
      pp2 => p(1:, 2, 1:)
      pp1 => p(1:, 1, 1:)
      pp0 => p(1:, 0, 1:)
      rlv3 => rlv(1:, 3, 1:)
      rlv2 => rlv(1:, 2, 1:)
      rlv1 => rlv(1:, 1, 1:)
      rlv0 => rlv(1:, 0, 1:)
      rev3 => rev(1:, 3, 1:)
      rev2 => rev(1:, 2, 1:)
      rev1 => rev(1:, 1, 1:)
      rev0 => rev(1:, 0, 1:)
      gamma3 => gamma(1:, 3, 1:)
      gamma2 => gamma(1:, 2, 1:)
      gamma1 => gamma(1:, 1, 1:)
      gamma0 => gamma(1:, 0, 1:)
    case (jmax) 
!===============================================================
      ww3 => w(1:, ny, 1:, :)
      ww2 => w(1:, jl, 1:, :)
      ww1 => w(1:, je, 1:, :)
      ww0 => w(1:, jb, 1:, :)
      pp3 => p(1:, ny, 1:)
      pp2 => p(1:, jl, 1:)
      pp1 => p(1:, je, 1:)
      pp0 => p(1:, jb, 1:)
      rlv3 => rlv(1:, ny, 1:)
      rlv2 => rlv(1:, jl, 1:)
      rlv1 => rlv(1:, je, 1:)
      rlv0 => rlv(1:, jb, 1:)
      rev3 => rev(1:, ny, 1:)
      rev2 => rev(1:, jl, 1:)
      rev1 => rev(1:, je, 1:)
      rev0 => rev(1:, jb, 1:)
      gamma3 => gamma(1:, ny, 1:)
      gamma2 => gamma(1:, jl, 1:)
      gamma1 => gamma(1:, je, 1:)
      gamma0 => gamma(1:, jb, 1:)
    case (kmin) 
!===============================================================
      ww3 => w(1:, 1:, 3, :)
      ww2 => w(1:, 1:, 2, :)
      ww1 => w(1:, 1:, 1, :)
      ww0 => w(1:, 1:, 0, :)
      pp3 => p(1:, 1:, 3)
      pp2 => p(1:, 1:, 2)
      pp1 => p(1:, 1:, 1)
      pp0 => p(1:, 1:, 0)
      rlv3 => rlv(1:, 1:, 3)
      rlv2 => rlv(1:, 1:, 2)
      rlv1 => rlv(1:, 1:, 1)
      rlv0 => rlv(1:, 1:, 0)
      rev3 => rev(1:, 1:, 3)
      rev2 => rev(1:, 1:, 2)
      rev1 => rev(1:, 1:, 1)
      rev0 => rev(1:, 1:, 0)
      gamma3 => gamma(1:, 1:, 3)
      gamma2 => gamma(1:, 1:, 2)
      gamma1 => gamma(1:, 1:, 1)
      gamma0 => gamma(1:, 1:, 0)
    case (kmax) 
!===============================================================
      ww3 => w(1:, 1:, nz, :)
      ww2 => w(1:, 1:, kl, :)
      ww1 => w(1:, 1:, ke, :)
      ww0 => w(1:, 1:, kb, :)
      pp3 => p(1:, 1:, nz)
      pp2 => p(1:, 1:, kl)
      pp1 => p(1:, 1:, ke)
      pp0 => p(1:, 1:, kb)
      rlv3 => rlv(1:, 1:, nz)
      rlv2 => rlv(1:, 1:, kl)
      rlv1 => rlv(1:, 1:, ke)
      rlv0 => rlv(1:, 1:, kb)
      rev3 => rev(1:, 1:, nz)
      rev2 => rev(1:, 1:, kl)
      rev1 => rev(1:, 1:, ke)
      rev0 => rev(1:, 1:, kb)
      gamma3 => gamma(1:, 1:, nz)
      gamma2 => gamma(1:, 1:, kl)
      gamma1 => gamma(1:, 1:, ke)
      gamma0 => gamma(1:, 1:, kb)
    end select
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xx => x(1, :, :, :)
        ssi => si(1, :, :, :)
        ssj => sj(2, :, :, :)
        ssk => sk(2, :, :, :)
        ss => s(2, :, :, :)
        dd2wall => d2wall(2, :, :)
      case (imax) 
        xx => x(il, :, :, :)
        ssi => si(il, :, :, :)
        ssj => sj(il, :, :, :)
        ssk => sk(il, :, :, :)
        ss => s(il, :, :, :)
        dd2wall => d2wall(il, :, :)
      case (jmin) 
        xx => x(:, 1, :, :)
        ssi => sj(:, 1, :, :)
        ssj => si(:, 2, :, :)
        ssk => sk(:, 2, :, :)
        ss => s(:, 2, :, :)
        dd2wall => d2wall(:, 2, :)
      case (jmax) 
        xx => x(:, jl, :, :)
        ssi => sj(:, jl, :, :)
        ssj => si(:, jl, :, :)
        ssk => sk(:, jl, :, :)
        ss => s(:, jl, :, :)
        dd2wall => d2wall(:, jl, :)
      case (kmin) 
        xx => x(:, :, 1, :)
        ssi => sk(:, :, 1, :)
        ssj => si(:, :, 2, :)
        ssk => sj(:, :, 2, :)
        ss => s(:, :, 2, :)
        dd2wall => d2wall(:, :, 2)
      case (kmax) 
        xx => x(:, :, kl, :)
        ssi => sk(:, :, kl, :)
        ssj => si(:, :, kl, :)
        ssk => sj(:, :, kl, :)
        ss => s(:, :, kl, :)
        dd2wall => d2wall(:, :, kl)
      end select
    end if
  end subroutine setbcpointers
  subroutine resetbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * resetbcpointers nullifyies the boundary pointers. for reverse  *
!      * mode ad it copies the values back in to the respective arrays  *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      w(3, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(2, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(1, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(0, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(3, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(2, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(1, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(0, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(3, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(2, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(1, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(0, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(3, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(2, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(1, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(0, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(3, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(2, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(1, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(0, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (imax) 
!===============================================================
      w(nx, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(il, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(ie, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(ib, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(nx, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(il, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(ie, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(ib, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(nx, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(il, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(ie, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(ib, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(nx, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(il, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(ie, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(ib, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(nx, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(il, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(ie, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(ib, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (jmin) 
!===============================================================
      w(1:ie, 3, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, 2, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, 1, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, 0, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, 3, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, 2, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, 1, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, 0, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, 3, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, 2, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, 1, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, 0, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, 3, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, 2, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, 1, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, 0, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, 3, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, 2, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, 1, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, 0, 1:ke) = gamma0(1:ie, 1:ke)
    case (jmax) 
!===============================================================
      w(1:ie, ny, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, jl, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, je, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, jb, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, ny, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, jl, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, je, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, jb, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, ny, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, jl, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, je, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, jb, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, ny, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, jl, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, je, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, jb, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, ny, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, jl, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, je, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, jb, 1:ke) = gamma0(1:ie, 1:ke)
    case (kmin) 
!===============================================================
      w(1:ie, 1:je, 3, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, 2, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, 1, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, 0, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, 3) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, 2) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, 1) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, 0) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, 3) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, 2) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, 1) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, 0) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, 3) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, 2) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, 1) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, 0) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, 3) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, 2) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, 1) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, 0) = gamma0(1:ie, 1:je)
    case (kmax) 
!===============================================================
      w(1:ie, 1:je, nz, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, kl, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, ke, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, kb, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, nz) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, kl) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, ke) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, kb) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, nz) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, kl) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, ke) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, kb) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, nz) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, kl) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, ke) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, kb) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, nz) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, kl) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, ke) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, kb) = gamma0(1:ie, 1:je)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        x(1, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(1, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (imax) 
        x(il, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(il, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (jmin) 
        x(0:ie, 1, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, 1, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (jmax) 
        x(0:ie, jl, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, jl, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (kmin) 
        x(0:ie, 0:je, 1, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, 1, :) = ssi(1:ie, 1:je, :)
      case (kmax) 
        x(0:ie, 0:je, kl, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, kl, :) = ssi(1:ie, 1:je, :)
      end select
    end if
  end subroutine resetbcpointers
end module bcroutines_fast_b

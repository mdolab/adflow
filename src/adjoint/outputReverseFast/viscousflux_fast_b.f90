!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of viscousflux in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev *aa *w *rlv *fw
!   with respect to varying inputs: *rev *aa *wx *wy *wz *w *rlv
!                *qx *qy *qz *ux *uy *uz *vx *vy *vz *fw
!   rw status of diff variables: *rev:incr *aa:incr *wx:out *wy:out
!                *wz:out *w:incr *rlv:incr *qx:out *qy:out *qz:out
!                *ux:out *uy:out *uz:out *vx:out *vy:out *vz:out
!                *fw:in-out
!   plus diff mem management of: rev:in aa:in wx:in wy:in wz:in
!                w:in rlv:in qx:in qy:in qz:in ux:in uy:in uz:in
!                vx:in vy:in vz:in fw:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          viscousflux.f90                                 *
!      * author:        edwin van der weide                             *
!      * starting date: 03-21-2003                                      *
!      * last modified: 04-18-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine viscousflux_fast_b()
!
!      ******************************************************************
!      *                                                                *
!      * viscousflux computes the viscous fluxes using a central        *
!      * difference scheme for a block.                                 *
!      * it is assumed that the pointers in block pointer already point *
!      * to the correct block.                                          *
!      *                                                                *
!      ******************************************************************
!
  use myPushPopLib
  use blockpointers
  use flowvarrefstate
  use inputphysics
  use iteration
  implicit none
! possibly correct the wall shear stress.
! wall function is not aded
!
!      local parameter.
!
  real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ii
  real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
  real(kind=realtype) :: muld, mued, mutd, heatcoefd
  real(kind=realtype) :: gm1, factlamheat, factturbheat
  real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
  real(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, w_yd&
& , w_zd
  real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
  real(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
  real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
  real(kind=realtype) :: corrd, fracdivd
  real(kind=realtype) :: tauxx, tauyy, tauzz
  real(kind=realtype) :: tauxxd, tauyyd, tauzzd
  real(kind=realtype) :: tauxy, tauxz, tauyz
  real(kind=realtype) :: tauxyd, tauxzd, tauyzd
  real(kind=realtype) :: fmx, fmy, fmz, frhoe
  real(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
  logical :: correctfork, storewalltensor
  intrinsic abs
  intrinsic mod
  intrinsic sqrt
  integer :: branch
  real(kind=realtype) :: tempd14
  real(kind=realtype) :: tempd13
  real(kind=realtype) :: tempd12
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: tempd46
  real(kind=realtype) :: tempd45
  real(kind=realtype) :: tempd44
  real(kind=realtype) :: tempd43
  real(kind=realtype) :: tempd42
  real(kind=realtype) :: tempd41
  real(kind=realtype) :: tempd40
  real(kind=realtype) :: tempd39
  real(kind=realtype) :: tempd38
  real(kind=realtype) :: tempd37
  real(kind=realtype) :: tempd36
  real(kind=realtype) :: tempd35
  real(kind=realtype) :: tempd34
  real(kind=realtype) :: tempd33
  real(kind=realtype) :: tempd32
  real(kind=realtype) :: tempd31
  real(kind=realtype) :: tempd30
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: tempd29
  real(kind=realtype) :: tempd28
  real(kind=realtype) :: tempd27
  real(kind=realtype) :: tempd26
  real(kind=realtype) :: tempd25
  real(kind=realtype) :: tempd24
  real(kind=realtype) :: tempd23
  real(kind=realtype) :: tempd22
  real(kind=realtype) :: tempd21
  real(kind=realtype) :: tempd20
  real(kind=realtype) :: abs0
  real(kind=realtype) :: tempd19
  real(kind=realtype) :: tempd18
  real(kind=realtype) :: tempd17
  real(kind=realtype) :: tempd16
  real(kind=realtype) :: tempd15
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
! set rfilv to rfil to indicate that this is the viscous part.
! if rfilv == 0 the viscous residuals need not to be computed
! and a return can be made.
  rfilv = rfil
  if (rfilv .ge. 0.) then
    abs0 = rfilv
  else
    abs0 = -rfilv
  end if
  if (abs0 .lt. thresholdreal) then
    wxd = 0.0_8
    wyd = 0.0_8
    wzd = 0.0_8
    qxd = 0.0_8
    qyd = 0.0_8
    qzd = 0.0_8
    uxd = 0.0_8
    uyd = 0.0_8
    uzd = 0.0_8
    vxd = 0.0_8
    vyd = 0.0_8
    vzd = 0.0_8
  else
    wxd = 0.0_8
    wyd = 0.0_8
    wzd = 0.0_8
    qxd = 0.0_8
    qyd = 0.0_8
    qzd = 0.0_8
    uxd = 0.0_8
    uyd = 0.0_8
    uzd = 0.0_8
    vxd = 0.0_8
    vyd = 0.0_8
    vzd = 0.0_8
    mued = 0.0_8
    mue = zero
    wxd = 0.0_8
    wyd = 0.0_8
    wzd = 0.0_8
    qxd = 0.0_8
    qyd = 0.0_8
    qzd = 0.0_8
    uxd = 0.0_8
    uyd = 0.0_8
    uzd = 0.0_8
    vxd = 0.0_8
    vyd = 0.0_8
    vzd = 0.0_8
    mued = 0.0_8
    do ii=0,il*ny*nz-1
      i = mod(ii, il) + 1
      j = mod(ii/il, ny) + 2
      k = ii/(il*ny) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
      por = half*rfilv
      if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
      mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
      if (eddymodel) then
        mue = por*(rev(i, j, k)+rev(i+1, j, k))
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      mut = mul + mue
      gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
      factlamheat = one/(prandtl*gm1)
      factturbheat = one/(prandtlturb*gm1)
      heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
      u_x = fourth*(ux(i, j-1, k-1)+ux(i, j, k-1)+ux(i, j-1, k)+ux(i, j&
&       , k))
      u_y = fourth*(uy(i, j-1, k-1)+uy(i, j, k-1)+uy(i, j-1, k)+uy(i, j&
&       , k))
      u_z = fourth*(uz(i, j-1, k-1)+uz(i, j, k-1)+uz(i, j-1, k)+uz(i, j&
&       , k))
      v_x = fourth*(vx(i, j-1, k-1)+vx(i, j, k-1)+vx(i, j-1, k)+vx(i, j&
&       , k))
      v_y = fourth*(vy(i, j-1, k-1)+vy(i, j, k-1)+vy(i, j-1, k)+vy(i, j&
&       , k))
      v_z = fourth*(vz(i, j-1, k-1)+vz(i, j, k-1)+vz(i, j-1, k)+vz(i, j&
&       , k))
      w_x = fourth*(wx(i, j-1, k-1)+wx(i, j, k-1)+wx(i, j-1, k)+wx(i, j&
&       , k))
      w_y = fourth*(wy(i, j-1, k-1)+wy(i, j, k-1)+wy(i, j-1, k)+wy(i, j&
&       , k))
      w_z = fourth*(wz(i, j-1, k-1)+wz(i, j, k-1)+wz(i, j-1, k)+wz(i, j&
&       , k))
      q_x = fourth*(qx(i, j-1, k-1)+qx(i, j, k-1)+qx(i, j-1, k)+qx(i, j&
&       , k))
      q_y = fourth*(qy(i, j-1, k-1)+qy(i, j, k-1)+qy(i, j-1, k)+qy(i, j&
&       , k))
      q_z = fourth*(qz(i, j-1, k-1)+qz(i, j, k-1)+qz(i, j-1, k)+qz(i, j&
&       , k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center i to cell center i+1.
      ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j-1, &
&       k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1, 1)+x(i+&
&       1, j, k, 1)-x(i-1, j, k, 1))
      ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j-1, &
&       k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1, 2)+x(i+&
&       1, j, k, 2)-x(i-1, j, k, 2))
      ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j-1, &
&       k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1, 3)+x(i+&
&       1, j, k, 3)-x(i-1, j, k, 3))
! determine the length of this vector and create the
! unit normal.
      ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
      ssx = ss*ssx
      ssy = ss*ssy
      ssz = ss*ssz
! correct the gradients.
      corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j, k&
&       , ivx))*ss
      u_x = u_x - corr*ssx
      u_y = u_y - corr*ssy
      u_z = u_z - corr*ssz
      corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j, k&
&       , ivy))*ss
      v_x = v_x - corr*ssx
      v_y = v_y - corr*ssy
      v_z = v_z - corr*ssz
      corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j, k&
&       , ivz))*ss
      w_x = w_x - corr*ssx
      w_y = w_y - corr*ssy
      w_z = w_z - corr*ssz
      corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i+1, j, k)-aa(i, j, k))*&
&       ss
      q_x = q_x - corr*ssx
      q_y = q_y - corr*ssy
      q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
      fracdiv = twothird*(u_x+v_y+w_z)
      tauxx = mut*(two*u_x-fracdiv)
      tauyy = mut*(two*v_y-fracdiv)
      tauzz = mut*(two*w_z-fracdiv)
      tauxy = mut*(u_y+v_x)
      tauxz = mut*(u_z+w_x)
      tauyz = mut*(v_z+w_y)
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
      ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
      vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
      wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
! update the residuals of cell i and i+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases i == 1
! and i == il must be tested.
      frhoed = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
      fmzd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
      fmyd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
      fmxd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
      tempd31 = si(i, j, k, 1)*frhoed
      tempd32 = si(i, j, k, 2)*frhoed
      tempd33 = si(i, j, k, 3)*frhoed
      ubard = tauxz*tempd33 + tauxy*tempd32 + tauxx*tempd31
      tauxxd = si(i, j, k, 1)*fmxd + ubar*tempd31
      vbard = tauyz*tempd33 + tauyy*tempd32 + tauxy*tempd31
      tauxyd = si(i, j, k, 1)*fmyd + si(i, j, k, 2)*fmxd + ubar*tempd32 &
&       + vbar*tempd31
      wbard = tauzz*tempd33 + tauyz*tempd32 + tauxz*tempd31
      tauxzd = si(i, j, k, 1)*fmzd + si(i, j, k, 3)*fmxd + ubar*tempd33 &
&       + wbar*tempd31
      tauyyd = si(i, j, k, 2)*fmyd + vbar*tempd32
      tauyzd = si(i, j, k, 2)*fmzd + si(i, j, k, 3)*fmyd + vbar*tempd33 &
&       + wbar*tempd32
      tauzzd = si(i, j, k, 3)*fmzd + wbar*tempd33
      q_xd = -(si(i, j, k, 1)*frhoed)
      q_yd = -(si(i, j, k, 2)*frhoed)
      q_zd = -(si(i, j, k, 3)*frhoed)
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wbard
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vbard
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*ubard
      heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
      q_zd = heatcoef*q_zd
      q_yd = heatcoef*q_yd
      q_xd = heatcoef*q_xd
      mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&       fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*tauxyd + &
&       (v_z+w_y)*tauyzd
      v_zd = mut*tauyzd
      w_yd = mut*tauyzd
      u_zd = mut*tauxzd
      w_xd = mut*tauxzd
      u_yd = mut*tauxyd
      v_xd = mut*tauxyd
      fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
      tempd34 = twothird*fracdivd
      w_zd = tempd34 + mut*two*tauzzd
      v_yd = tempd34 + mut*two*tauyyd
      u_xd = tempd34 + mut*two*tauxxd
      corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
      q_xd = q_xd + ssx*corrd
      q_yd = q_yd + ssy*corrd
      q_zd = q_zd + ssz*corrd
      aad(i+1, j, k) = aad(i+1, j, k) + ss*corrd
      aad(i, j, k) = aad(i, j, k) - ss*corrd
      corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
      w_xd = w_xd + ssx*corrd
      w_yd = w_yd + ssy*corrd
      w_zd = w_zd + ssz*corrd
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) - ss*corrd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
      corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
      v_xd = v_xd + ssx*corrd
      v_yd = v_yd + ssy*corrd
      v_zd = v_zd + ssz*corrd
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) - ss*corrd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
      corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
      u_xd = u_xd + ssx*corrd
      u_yd = u_yd + ssy*corrd
      u_zd = u_zd + ssz*corrd
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) - ss*corrd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
      tempd35 = fourth*q_zd
      qzd(i, j-1, k-1) = qzd(i, j-1, k-1) + tempd35
      qzd(i, j, k-1) = qzd(i, j, k-1) + tempd35
      qzd(i, j-1, k) = qzd(i, j-1, k) + tempd35
      qzd(i, j, k) = qzd(i, j, k) + tempd35
      tempd36 = fourth*q_yd
      qyd(i, j-1, k-1) = qyd(i, j-1, k-1) + tempd36
      qyd(i, j, k-1) = qyd(i, j, k-1) + tempd36
      qyd(i, j-1, k) = qyd(i, j-1, k) + tempd36
      qyd(i, j, k) = qyd(i, j, k) + tempd36
      tempd37 = fourth*q_xd
      qxd(i, j-1, k-1) = qxd(i, j-1, k-1) + tempd37
      qxd(i, j, k-1) = qxd(i, j, k-1) + tempd37
      qxd(i, j-1, k) = qxd(i, j-1, k) + tempd37
      qxd(i, j, k) = qxd(i, j, k) + tempd37
      tempd38 = fourth*w_zd
      wzd(i, j-1, k-1) = wzd(i, j-1, k-1) + tempd38
      wzd(i, j, k-1) = wzd(i, j, k-1) + tempd38
      wzd(i, j-1, k) = wzd(i, j-1, k) + tempd38
      wzd(i, j, k) = wzd(i, j, k) + tempd38
      tempd39 = fourth*w_yd
      wyd(i, j-1, k-1) = wyd(i, j-1, k-1) + tempd39
      wyd(i, j, k-1) = wyd(i, j, k-1) + tempd39
      wyd(i, j-1, k) = wyd(i, j-1, k) + tempd39
      wyd(i, j, k) = wyd(i, j, k) + tempd39
      tempd40 = fourth*w_xd
      wxd(i, j-1, k-1) = wxd(i, j-1, k-1) + tempd40
      wxd(i, j, k-1) = wxd(i, j, k-1) + tempd40
      wxd(i, j-1, k) = wxd(i, j-1, k) + tempd40
      wxd(i, j, k) = wxd(i, j, k) + tempd40
      tempd41 = fourth*v_zd
      vzd(i, j-1, k-1) = vzd(i, j-1, k-1) + tempd41
      vzd(i, j, k-1) = vzd(i, j, k-1) + tempd41
      vzd(i, j-1, k) = vzd(i, j-1, k) + tempd41
      vzd(i, j, k) = vzd(i, j, k) + tempd41
      tempd42 = fourth*v_yd
      vyd(i, j-1, k-1) = vyd(i, j-1, k-1) + tempd42
      vyd(i, j, k-1) = vyd(i, j, k-1) + tempd42
      vyd(i, j-1, k) = vyd(i, j-1, k) + tempd42
      vyd(i, j, k) = vyd(i, j, k) + tempd42
      tempd43 = fourth*v_xd
      vxd(i, j-1, k-1) = vxd(i, j-1, k-1) + tempd43
      vxd(i, j, k-1) = vxd(i, j, k-1) + tempd43
      vxd(i, j-1, k) = vxd(i, j-1, k) + tempd43
      vxd(i, j, k) = vxd(i, j, k) + tempd43
      tempd44 = fourth*u_zd
      uzd(i, j-1, k-1) = uzd(i, j-1, k-1) + tempd44
      uzd(i, j, k-1) = uzd(i, j, k-1) + tempd44
      uzd(i, j-1, k) = uzd(i, j-1, k) + tempd44
      uzd(i, j, k) = uzd(i, j, k) + tempd44
      tempd45 = fourth*u_yd
      uyd(i, j-1, k-1) = uyd(i, j-1, k-1) + tempd45
      uyd(i, j, k-1) = uyd(i, j, k-1) + tempd45
      uyd(i, j-1, k) = uyd(i, j-1, k) + tempd45
      uyd(i, j, k) = uyd(i, j, k) + tempd45
      tempd46 = fourth*u_xd
      uxd(i, j-1, k-1) = uxd(i, j-1, k-1) + tempd46
      uxd(i, j, k-1) = uxd(i, j, k-1) + tempd46
      uxd(i, j-1, k) = uxd(i, j-1, k) + tempd46
      uxd(i, j, k) = uxd(i, j, k) + tempd46
      muld = mutd + factlamheat*heatcoefd
      mued = mued + mutd + factturbheat*heatcoefd
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        revd(i, j, k) = revd(i, j, k) + por*mued
        revd(i+1, j, k) = revd(i+1, j, k) + por*mued
        mued = 0.0_8
      end if
      rlvd(i, j, k) = rlvd(i, j, k) + por*muld
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + por*muld
    end do
    mued = 0.0_8
    mue = zero
    mued = 0.0_8
    do ii=0,nx*jl*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, jl) + 1
      k = ii/(nx*jl) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
      por = half*rfilv
      if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
      mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
      if (eddymodel) then
        mue = por*(rev(i, j, k)+rev(i, j+1, k))
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      mut = mul + mue
      gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
      factlamheat = one/(prandtl*gm1)
      factturbheat = one/(prandtlturb*gm1)
      heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
      u_x = fourth*(ux(i-1, j, k-1)+ux(i, j, k-1)+ux(i-1, j, k)+ux(i, j&
&       , k))
      u_y = fourth*(uy(i-1, j, k-1)+uy(i, j, k-1)+uy(i-1, j, k)+uy(i, j&
&       , k))
      u_z = fourth*(uz(i-1, j, k-1)+uz(i, j, k-1)+uz(i-1, j, k)+uz(i, j&
&       , k))
      v_x = fourth*(vx(i-1, j, k-1)+vx(i, j, k-1)+vx(i-1, j, k)+vx(i, j&
&       , k))
      v_y = fourth*(vy(i-1, j, k-1)+vy(i, j, k-1)+vy(i-1, j, k)+vy(i, j&
&       , k))
      v_z = fourth*(vz(i-1, j, k-1)+vz(i, j, k-1)+vz(i-1, j, k)+vz(i, j&
&       , k))
      w_x = fourth*(wx(i-1, j, k-1)+wx(i, j, k-1)+wx(i-1, j, k)+wx(i, j&
&       , k))
      w_y = fourth*(wy(i-1, j, k-1)+wy(i, j, k-1)+wy(i-1, j, k)+wy(i, j&
&       , k))
      w_z = fourth*(wz(i-1, j, k-1)+wz(i, j, k-1)+wz(i-1, j, k)+wz(i, j&
&       , k))
      q_x = fourth*(qx(i-1, j, k-1)+qx(i, j, k-1)+qx(i-1, j, k)+qx(i, j&
&       , k))
      q_y = fourth*(qy(i-1, j, k-1)+qy(i, j, k-1)+qy(i-1, j, k)+qy(i, j&
&       , k))
      q_z = fourth*(qz(i-1, j, k-1)+qz(i, j, k-1)+qz(i-1, j, k)+qz(i, j&
&       , k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center j to cell center j+1.
      ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j+1, &
&       k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1, 1)+x(i&
&       , j+1, k, 1)-x(i, j-1, k, 1))
      ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j+1, &
&       k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1, 2)+x(i&
&       , j+1, k, 2)-x(i, j-1, k, 2))
      ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j+1, &
&       k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1, 3)+x(i&
&       , j+1, k, 3)-x(i, j-1, k, 3))
! determine the length of this vector and create the
! unit normal.
      ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
      ssx = ss*ssx
      ssy = ss*ssy
      ssz = ss*ssz
! correct the gradients.
      corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j, k&
&       , ivx))*ss
      u_x = u_x - corr*ssx
      u_y = u_y - corr*ssy
      u_z = u_z - corr*ssz
      corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j, k&
&       , ivy))*ss
      v_x = v_x - corr*ssx
      v_y = v_y - corr*ssy
      v_z = v_z - corr*ssz
      corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j, k&
&       , ivz))*ss
      w_x = w_x - corr*ssx
      w_y = w_y - corr*ssy
      w_z = w_z - corr*ssz
      corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j+1, k)-aa(i, j, k))*&
&       ss
      q_x = q_x - corr*ssx
      q_y = q_y - corr*ssy
      q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
      fracdiv = twothird*(u_x+v_y+w_z)
      tauxx = mut*(two*u_x-fracdiv)
      tauyy = mut*(two*v_y-fracdiv)
      tauzz = mut*(two*w_z-fracdiv)
      tauxy = mut*(u_y+v_x)
      tauxz = mut*(u_z+w_x)
      tauyz = mut*(v_z+w_y)
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
      ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
      vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
      wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
! update the residuals of cell j and j+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases j == 1
! and j == jl must be tested.
      frhoed = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
      fmzd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
      fmyd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
      fmxd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
      tempd15 = sj(i, j, k, 1)*frhoed
      tempd16 = sj(i, j, k, 2)*frhoed
      tempd17 = sj(i, j, k, 3)*frhoed
      ubard = tauxz*tempd17 + tauxy*tempd16 + tauxx*tempd15
      tauxxd = sj(i, j, k, 1)*fmxd + ubar*tempd15
      vbard = tauyz*tempd17 + tauyy*tempd16 + tauxy*tempd15
      tauxyd = sj(i, j, k, 1)*fmyd + sj(i, j, k, 2)*fmxd + ubar*tempd16 &
&       + vbar*tempd15
      wbard = tauzz*tempd17 + tauyz*tempd16 + tauxz*tempd15
      tauxzd = sj(i, j, k, 1)*fmzd + sj(i, j, k, 3)*fmxd + ubar*tempd17 &
&       + wbar*tempd15
      tauyyd = sj(i, j, k, 2)*fmyd + vbar*tempd16
      tauyzd = sj(i, j, k, 2)*fmzd + sj(i, j, k, 3)*fmyd + vbar*tempd17 &
&       + wbar*tempd16
      tauzzd = sj(i, j, k, 3)*fmzd + wbar*tempd17
      q_xd = -(sj(i, j, k, 1)*frhoed)
      q_yd = -(sj(i, j, k, 2)*frhoed)
      q_zd = -(sj(i, j, k, 3)*frhoed)
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wbard
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vbard
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*ubard
      heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
      q_zd = heatcoef*q_zd
      q_yd = heatcoef*q_yd
      q_xd = heatcoef*q_xd
      mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&       fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*tauxyd + &
&       (v_z+w_y)*tauyzd
      v_zd = mut*tauyzd
      w_yd = mut*tauyzd
      u_zd = mut*tauxzd
      w_xd = mut*tauxzd
      u_yd = mut*tauxyd
      v_xd = mut*tauxyd
      fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
      tempd18 = twothird*fracdivd
      w_zd = tempd18 + mut*two*tauzzd
      v_yd = tempd18 + mut*two*tauyyd
      u_xd = tempd18 + mut*two*tauxxd
      corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
      q_xd = q_xd + ssx*corrd
      q_yd = q_yd + ssy*corrd
      q_zd = q_zd + ssz*corrd
      aad(i, j+1, k) = aad(i, j+1, k) + ss*corrd
      aad(i, j, k) = aad(i, j, k) - ss*corrd
      corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
      w_xd = w_xd + ssx*corrd
      w_yd = w_yd + ssy*corrd
      w_zd = w_zd + ssz*corrd
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) - ss*corrd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
      corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
      v_xd = v_xd + ssx*corrd
      v_yd = v_yd + ssy*corrd
      v_zd = v_zd + ssz*corrd
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) - ss*corrd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
      corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
      u_xd = u_xd + ssx*corrd
      u_yd = u_yd + ssy*corrd
      u_zd = u_zd + ssz*corrd
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) - ss*corrd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
      tempd19 = fourth*q_zd
      qzd(i-1, j, k-1) = qzd(i-1, j, k-1) + tempd19
      qzd(i, j, k-1) = qzd(i, j, k-1) + tempd19
      qzd(i-1, j, k) = qzd(i-1, j, k) + tempd19
      qzd(i, j, k) = qzd(i, j, k) + tempd19
      tempd20 = fourth*q_yd
      qyd(i-1, j, k-1) = qyd(i-1, j, k-1) + tempd20
      qyd(i, j, k-1) = qyd(i, j, k-1) + tempd20
      qyd(i-1, j, k) = qyd(i-1, j, k) + tempd20
      qyd(i, j, k) = qyd(i, j, k) + tempd20
      tempd21 = fourth*q_xd
      qxd(i-1, j, k-1) = qxd(i-1, j, k-1) + tempd21
      qxd(i, j, k-1) = qxd(i, j, k-1) + tempd21
      qxd(i-1, j, k) = qxd(i-1, j, k) + tempd21
      qxd(i, j, k) = qxd(i, j, k) + tempd21
      tempd22 = fourth*w_zd
      wzd(i-1, j, k-1) = wzd(i-1, j, k-1) + tempd22
      wzd(i, j, k-1) = wzd(i, j, k-1) + tempd22
      wzd(i-1, j, k) = wzd(i-1, j, k) + tempd22
      wzd(i, j, k) = wzd(i, j, k) + tempd22
      tempd23 = fourth*w_yd
      wyd(i-1, j, k-1) = wyd(i-1, j, k-1) + tempd23
      wyd(i, j, k-1) = wyd(i, j, k-1) + tempd23
      wyd(i-1, j, k) = wyd(i-1, j, k) + tempd23
      wyd(i, j, k) = wyd(i, j, k) + tempd23
      tempd24 = fourth*w_xd
      wxd(i-1, j, k-1) = wxd(i-1, j, k-1) + tempd24
      wxd(i, j, k-1) = wxd(i, j, k-1) + tempd24
      wxd(i-1, j, k) = wxd(i-1, j, k) + tempd24
      wxd(i, j, k) = wxd(i, j, k) + tempd24
      tempd25 = fourth*v_zd
      vzd(i-1, j, k-1) = vzd(i-1, j, k-1) + tempd25
      vzd(i, j, k-1) = vzd(i, j, k-1) + tempd25
      vzd(i-1, j, k) = vzd(i-1, j, k) + tempd25
      vzd(i, j, k) = vzd(i, j, k) + tempd25
      tempd26 = fourth*v_yd
      vyd(i-1, j, k-1) = vyd(i-1, j, k-1) + tempd26
      vyd(i, j, k-1) = vyd(i, j, k-1) + tempd26
      vyd(i-1, j, k) = vyd(i-1, j, k) + tempd26
      vyd(i, j, k) = vyd(i, j, k) + tempd26
      tempd27 = fourth*v_xd
      vxd(i-1, j, k-1) = vxd(i-1, j, k-1) + tempd27
      vxd(i, j, k-1) = vxd(i, j, k-1) + tempd27
      vxd(i-1, j, k) = vxd(i-1, j, k) + tempd27
      vxd(i, j, k) = vxd(i, j, k) + tempd27
      tempd28 = fourth*u_zd
      uzd(i-1, j, k-1) = uzd(i-1, j, k-1) + tempd28
      uzd(i, j, k-1) = uzd(i, j, k-1) + tempd28
      uzd(i-1, j, k) = uzd(i-1, j, k) + tempd28
      uzd(i, j, k) = uzd(i, j, k) + tempd28
      tempd29 = fourth*u_yd
      uyd(i-1, j, k-1) = uyd(i-1, j, k-1) + tempd29
      uyd(i, j, k-1) = uyd(i, j, k-1) + tempd29
      uyd(i-1, j, k) = uyd(i-1, j, k) + tempd29
      uyd(i, j, k) = uyd(i, j, k) + tempd29
      tempd30 = fourth*u_xd
      uxd(i-1, j, k-1) = uxd(i-1, j, k-1) + tempd30
      uxd(i, j, k-1) = uxd(i, j, k-1) + tempd30
      uxd(i-1, j, k) = uxd(i-1, j, k) + tempd30
      uxd(i, j, k) = uxd(i, j, k) + tempd30
      muld = mutd + factlamheat*heatcoefd
      mued = mued + mutd + factturbheat*heatcoefd
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        revd(i, j, k) = revd(i, j, k) + por*mued
        revd(i, j+1, k) = revd(i, j+1, k) + por*mued
        mued = 0.0_8
      end if
      rlvd(i, j, k) = rlvd(i, j, k) + por*muld
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + por*muld
    end do
    mued = 0.0_8
!
!        ****************************************************************
!        *                                                              *
!        * viscous fluxes in the k-direction.                           *
!        *                                                              *
!        ****************************************************************
!
    mue = zero
    mued = 0.0_8
    do ii=0,nx*ny*kl-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 1
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
      por = half*rfilv
      if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
      mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
      if (eddymodel) then
        mue = por*(rev(i, j, k)+rev(i, j, k+1))
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      mut = mul + mue
      gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
      factlamheat = one/(prandtl*gm1)
      factturbheat = one/(prandtlturb*gm1)
      heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
      u_x = fourth*(ux(i-1, j-1, k)+ux(i, j-1, k)+ux(i-1, j, k)+ux(i, j&
&       , k))
      u_y = fourth*(uy(i-1, j-1, k)+uy(i, j-1, k)+uy(i-1, j, k)+uy(i, j&
&       , k))
      u_z = fourth*(uz(i-1, j-1, k)+uz(i, j-1, k)+uz(i-1, j, k)+uz(i, j&
&       , k))
      v_x = fourth*(vx(i-1, j-1, k)+vx(i, j-1, k)+vx(i-1, j, k)+vx(i, j&
&       , k))
      v_y = fourth*(vy(i-1, j-1, k)+vy(i, j-1, k)+vy(i-1, j, k)+vy(i, j&
&       , k))
      v_z = fourth*(vz(i-1, j-1, k)+vz(i, j-1, k)+vz(i-1, j, k)+vz(i, j&
&       , k))
      w_x = fourth*(wx(i-1, j-1, k)+wx(i, j-1, k)+wx(i-1, j, k)+wx(i, j&
&       , k))
      w_y = fourth*(wy(i-1, j-1, k)+wy(i, j-1, k)+wy(i-1, j, k)+wy(i, j&
&       , k))
      w_z = fourth*(wz(i-1, j-1, k)+wz(i, j-1, k)+wz(i-1, j, k)+wz(i, j&
&       , k))
      q_x = fourth*(qx(i-1, j-1, k)+qx(i, j-1, k)+qx(i-1, j, k)+qx(i, j&
&       , k))
      q_y = fourth*(qy(i-1, j-1, k)+qy(i, j-1, k)+qy(i-1, j, k)+qy(i, j&
&       , k))
      q_z = fourth*(qz(i-1, j-1, k)+qz(i, j-1, k)+qz(i-1, j, k)+qz(i, j&
&       , k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center k to cell center k+1.
      ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j, k+&
&       1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1, 1)+x(i&
&       , j, k+1, 1)-x(i, j, k-1, 1))
      ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j, k+&
&       1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1, 2)+x(i&
&       , j, k+1, 2)-x(i, j, k-1, 2))
      ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j, k+&
&       1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1, 3)+x(i&
&       , j, k+1, 3)-x(i, j, k-1, 3))
! determine the length of this vector and create the
! unit normal.
      ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
      ssx = ss*ssx
      ssy = ss*ssy
      ssz = ss*ssz
! correct the gradients.
      corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j, k&
&       , ivx))*ss
      u_x = u_x - corr*ssx
      u_y = u_y - corr*ssy
      u_z = u_z - corr*ssz
      corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j, k&
&       , ivy))*ss
      v_x = v_x - corr*ssx
      v_y = v_y - corr*ssy
      v_z = v_z - corr*ssz
      corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j, k&
&       , ivz))*ss
      w_x = w_x - corr*ssx
      w_y = w_y - corr*ssy
      w_z = w_z - corr*ssz
      corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j, k+1)-aa(i, j, k))*&
&       ss
      q_x = q_x - corr*ssx
      q_y = q_y - corr*ssy
      q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
      fracdiv = twothird*(u_x+v_y+w_z)
      tauxx = mut*(two*u_x-fracdiv)
      tauyy = mut*(two*v_y-fracdiv)
      tauzz = mut*(two*w_z-fracdiv)
      tauxy = mut*(u_y+v_x)
      tauxz = mut*(u_z+w_x)
      tauyz = mut*(v_z+w_y)
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
      ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
      vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
      wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this k-face.
! update the residuals of cell k and k+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases k == 1
! and k == kl must be tested.
      frhoed = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
      fmzd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
      fmyd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
      fmxd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
      q_xd = -(sk(i, j, k, 1)*frhoed)
      q_yd = -(sk(i, j, k, 2)*frhoed)
      q_zd = -(sk(i, j, k, 3)*frhoed)
      tempd = sk(i, j, k, 3)*frhoed
      tauzzd = sk(i, j, k, 3)*fmzd + wbar*tempd
      tempd0 = sk(i, j, k, 2)*frhoed
      tauyzd = wbar*tempd0 + sk(i, j, k, 3)*fmyd + sk(i, j, k, 2)*fmzd +&
&       vbar*tempd
      tauyyd = sk(i, j, k, 2)*fmyd + vbar*tempd0
      tempd1 = sk(i, j, k, 1)*frhoed
      ubard = tauxy*tempd0 + tauxx*tempd1 + tauxz*tempd
      tauxzd = wbar*tempd1 + sk(i, j, k, 3)*fmxd + sk(i, j, k, 1)*fmzd +&
&       ubar*tempd
      vbard = tauyy*tempd0 + tauxy*tempd1 + tauyz*tempd
      wbard = tauyz*tempd0 + tauxz*tempd1 + tauzz*tempd
      tauxyd = vbar*tempd1 + sk(i, j, k, 2)*fmxd + sk(i, j, k, 1)*fmyd +&
&       ubar*tempd0
      tauxxd = sk(i, j, k, 1)*fmxd + ubar*tempd1
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wbard
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vbard
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*ubard
      heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
      q_zd = heatcoef*q_zd
      q_yd = heatcoef*q_yd
      q_xd = heatcoef*q_xd
      mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&       fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*tauxyd + &
&       (v_z+w_y)*tauyzd
      v_zd = mut*tauyzd
      w_yd = mut*tauyzd
      u_zd = mut*tauxzd
      w_xd = mut*tauxzd
      u_yd = mut*tauxyd
      v_xd = mut*tauxyd
      fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
      tempd2 = twothird*fracdivd
      w_zd = tempd2 + mut*two*tauzzd
      v_yd = tempd2 + mut*two*tauyyd
      u_xd = tempd2 + mut*two*tauxxd
      corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
      q_xd = q_xd + ssx*corrd
      q_yd = q_yd + ssy*corrd
      q_zd = q_zd + ssz*corrd
      aad(i, j, k+1) = aad(i, j, k+1) + ss*corrd
      aad(i, j, k) = aad(i, j, k) - ss*corrd
      corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
      w_xd = w_xd + ssx*corrd
      w_yd = w_yd + ssy*corrd
      w_zd = w_zd + ssz*corrd
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) - ss*corrd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
      corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
      v_xd = v_xd + ssx*corrd
      v_yd = v_yd + ssy*corrd
      v_zd = v_zd + ssz*corrd
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) - ss*corrd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
      corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
      u_xd = u_xd + ssx*corrd
      u_yd = u_yd + ssy*corrd
      u_zd = u_zd + ssz*corrd
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) - ss*corrd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
      tempd3 = fourth*q_zd
      qzd(i-1, j-1, k) = qzd(i-1, j-1, k) + tempd3
      qzd(i, j-1, k) = qzd(i, j-1, k) + tempd3
      qzd(i-1, j, k) = qzd(i-1, j, k) + tempd3
      qzd(i, j, k) = qzd(i, j, k) + tempd3
      tempd4 = fourth*q_yd
      qyd(i-1, j-1, k) = qyd(i-1, j-1, k) + tempd4
      qyd(i, j-1, k) = qyd(i, j-1, k) + tempd4
      qyd(i-1, j, k) = qyd(i-1, j, k) + tempd4
      qyd(i, j, k) = qyd(i, j, k) + tempd4
      tempd5 = fourth*q_xd
      qxd(i-1, j-1, k) = qxd(i-1, j-1, k) + tempd5
      qxd(i, j-1, k) = qxd(i, j-1, k) + tempd5
      qxd(i-1, j, k) = qxd(i-1, j, k) + tempd5
      qxd(i, j, k) = qxd(i, j, k) + tempd5
      tempd6 = fourth*w_zd
      wzd(i-1, j-1, k) = wzd(i-1, j-1, k) + tempd6
      wzd(i, j-1, k) = wzd(i, j-1, k) + tempd6
      wzd(i-1, j, k) = wzd(i-1, j, k) + tempd6
      wzd(i, j, k) = wzd(i, j, k) + tempd6
      tempd7 = fourth*w_yd
      wyd(i-1, j-1, k) = wyd(i-1, j-1, k) + tempd7
      wyd(i, j-1, k) = wyd(i, j-1, k) + tempd7
      wyd(i-1, j, k) = wyd(i-1, j, k) + tempd7
      wyd(i, j, k) = wyd(i, j, k) + tempd7
      tempd8 = fourth*w_xd
      wxd(i-1, j-1, k) = wxd(i-1, j-1, k) + tempd8
      wxd(i, j-1, k) = wxd(i, j-1, k) + tempd8
      wxd(i-1, j, k) = wxd(i-1, j, k) + tempd8
      wxd(i, j, k) = wxd(i, j, k) + tempd8
      tempd9 = fourth*v_zd
      vzd(i-1, j-1, k) = vzd(i-1, j-1, k) + tempd9
      vzd(i, j-1, k) = vzd(i, j-1, k) + tempd9
      vzd(i-1, j, k) = vzd(i-1, j, k) + tempd9
      vzd(i, j, k) = vzd(i, j, k) + tempd9
      tempd10 = fourth*v_yd
      vyd(i-1, j-1, k) = vyd(i-1, j-1, k) + tempd10
      vyd(i, j-1, k) = vyd(i, j-1, k) + tempd10
      vyd(i-1, j, k) = vyd(i-1, j, k) + tempd10
      vyd(i, j, k) = vyd(i, j, k) + tempd10
      tempd11 = fourth*v_xd
      vxd(i-1, j-1, k) = vxd(i-1, j-1, k) + tempd11
      vxd(i, j-1, k) = vxd(i, j-1, k) + tempd11
      vxd(i-1, j, k) = vxd(i-1, j, k) + tempd11
      vxd(i, j, k) = vxd(i, j, k) + tempd11
      tempd12 = fourth*u_zd
      uzd(i-1, j-1, k) = uzd(i-1, j-1, k) + tempd12
      uzd(i, j-1, k) = uzd(i, j-1, k) + tempd12
      uzd(i-1, j, k) = uzd(i-1, j, k) + tempd12
      uzd(i, j, k) = uzd(i, j, k) + tempd12
      tempd13 = fourth*u_yd
      uyd(i-1, j-1, k) = uyd(i-1, j-1, k) + tempd13
      uyd(i, j-1, k) = uyd(i, j-1, k) + tempd13
      uyd(i-1, j, k) = uyd(i-1, j, k) + tempd13
      uyd(i, j, k) = uyd(i, j, k) + tempd13
      tempd14 = fourth*u_xd
      uxd(i-1, j-1, k) = uxd(i-1, j-1, k) + tempd14
      uxd(i, j-1, k) = uxd(i, j-1, k) + tempd14
      uxd(i-1, j, k) = uxd(i-1, j, k) + tempd14
      uxd(i, j, k) = uxd(i, j, k) + tempd14
      muld = mutd + factlamheat*heatcoefd
      mued = mued + mutd + factturbheat*heatcoefd
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        revd(i, j, k) = revd(i, j, k) + por*mued
        revd(i, j, k+1) = revd(i, j, k+1) + por*mued
        mued = 0.0_8
      end if
      rlvd(i, j, k) = rlvd(i, j, k) + por*muld
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + por*muld
    end do
  end if
end subroutine viscousflux_fast_b

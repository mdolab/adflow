!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
! this module contains the source code related to the sa turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier. 
module samodule_fast_b
  use myPushPopLib
  use constants
  implicit none
  real(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
  real(kind=realtype), dimension(:, :, :), allocatable :: qq
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall

contains
  subroutine sa_block(resonly)
!
!      ******************************************************************
!      *                                                                *
!      * sa solves the transport equation for the spalart-allmaras      *
!      * turbulence model in a segregated manner using a diagonal       *
!      * dominant adi-scheme.                                           *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use inputtimespectral
    use iteration
    use inputphysics
    use paramturb
    implicit none
!
!      subroutine argument.
!
    logical, intent(in) :: resonly
!
!      local variables.
!
    integer(kind=inttype) :: nn, sps
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
! set the arrays for the boundary condition treatment.
    call bcturbtreatment()
! set model constants
    cv13 = rsacv1**3
    kar2inv = one/rsak**2
    cw36 = rsacw3**6
    cb3inv = one/rsacb3
! run the necessary code to setup and solve the sa transport
! equation for nutilde.
! production terms
    select case  (turbprod) 
    case (strain) 
      call prodsmag2()
    case (vorticity) 
      call prodwmag2()
    case (katolaunder) 
      call prodkatolaunder()
    end select
! alloc central jacobian memory
    allocate(qq(2:il, 2:jl, 2:kl))
! source terms
    call sasource()
! advection term
    nn = itu1 - 1
    call turbadvection(1_inttype, 1_inttype, nn, qq)
! unsteady term
    call unsteadyturbterm(1_inttype, 1_inttype, nn, qq)
! viscous terms
    call saviscous()
! perform the residual scaling
    call saresscale()
! we need to do an acutal solve. solve and update the eddy
! viscosity and the boundary conditions
    deallocate(qq)
  end subroutine sa_block
!  differentiation of sasource in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *rlv *scratch
!   with respect to varying inputs: *w *rlv *scratch
!   rw status of diff variables: *w:incr *rlv:incr *scratch:in-out
!   plus diff mem management of: w:in rlv:in scratch:in
  subroutine sasource_fast_b()
!
! ******************************************************************
! *                                                                *
! * source terms.                                                  *
! *                                                                *
! * determine the source term and its derivative w.r.t. nutilde    *
! * for all internal cells of the block.                           *
! *                                                                *
! ******************************************************************
    use blockpointers
    use constants
    use paramturb
    implicit none
! compute the source term jacobian. note that the part
! containing term1 is treated explicitly. the reason is that
! implicit treatment of this part leads to a decrease of the
! diagonal dominance of the jacobian and it thus decreases
! the stability. you may want to play around and try to
! take this term into account in the jacobian.
! note that -dsource/dnu is stored.
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: fv1d, fv2d, ft2d
    real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
    real(kind=realtype) :: ssd, sstd, nud, chid, chi2d, chi3d
    real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
    real(kind=realtype) :: rrd, ggd, gg6d, termfwd, fwsad, term1d, &
&   term2d
    real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
    real(kind=realtype), parameter :: xminn=1.e-10_realtype
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    integer :: branch
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
      ss = sqrt(scratch(i, j, k, iprod))
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
      nu = rlv(i, j, k)/w(i, j, k, irho)
      dist2inv = one/d2wall(i, j, k)**2
      chi = w(i, j, k, itu1)/nu
      chi2 = chi*chi
      chi3 = chi*chi2
      fv1 = chi3/(chi3+cv13)
      fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
      ft2 = rsact3*exp(-(rsact4*chi2))
! ft2 = zero
! correct the production term to account for the influence
! of the wall. make sure that this term remains positive
! (the function fv2 is negative between chi = 1 and 18.4,
! which can cause sst to go negative, which is undesirable).
      sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
      if (sst .lt. xminn) then
        sst = xminn
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
        sst = sst
      end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
      rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
      if (rr .gt. 10.0_realtype) then
        rr = 10.0_realtype
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
        rr = rr
      end if
      gg = rr + rsacw2*(rr**6-rr)
      gg6 = gg**6
      termfw = ((one+cw36)/(gg6+cw36))**sixth
      fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
      term1 = rsacb1*(one-ft2)*ss
      term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)
! compute some derivatives w.r.t. nutilde. these will occur
! in the left hand side, i.e. the matrix for the implicit
! treatment.
      tempd4 = w(i, j, k, itu1)*scratchd(i, j, k, idvt)
      temp1 = w(i, j, k, itu1)
      term1d = tempd4
      term2d = temp1*tempd4
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + (term1+term2*temp1)*&
&       scratchd(i, j, k, idvt) + term2*tempd4
      scratchd(i, j, k, idvt) = 0.0_8
      tempd5 = dist2inv*kar2inv*rsacb1*term2d
      ft2d = (1.0_8-fv2)*tempd5 - ss*rsacb1*term1d
      fv2d = (one-ft2)*tempd5
      fwsad = -(dist2inv*rsacw1*term2d)
      ssd = rsacb1*(one-ft2)*term1d
      termfwd = gg*fwsad
      temp0 = (one+cw36)/(cw36+gg6)
      if (temp0 .le. 0.0_8 .and. (sixth .eq. 0.0_8 .or. sixth .ne. int(&
&         sixth))) then
        gg6d = 0.0
      else
        gg6d = -(sixth*temp0**(sixth-1)*temp0*termfwd/(cw36+gg6))
      end if
      ggd = 6*gg**5*gg6d + termfw*fwsad
      rrd = (rsacw2*6*rr**5-rsacw2+1.0_8)*ggd
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) rrd = 0.0_8
      tempd3 = kar2inv*dist2inv*rrd/sst
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + tempd3
      sstd = -(w(i, j, k, itu1)*tempd3/sst)
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) sstd = 0.0_8
      tempd = kar2inv*dist2inv*sstd
      ssd = ssd + sstd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + fv2*tempd
      fv2d = fv2d + w(i, j, k, itu1)*tempd
      tempd0 = -(fv2d/(one+chi*fv1))
      tempd1 = -(chi*tempd0/(one+chi*fv1))
      fv1d = chi*tempd1
      tempd2 = fv1d/(cv13+chi3)
      chi3d = (1.0_8-chi3/(cv13+chi3))*tempd2
      chi2d = chi*chi3d - exp(-(rsact4*chi2))*rsact3*rsact4*ft2d
      chid = chi2*chi3d + 2*chi*chi2d + fv1*tempd1 + tempd0
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + chid/nu
      nud = -(w(i, j, k, itu1)*chid/nu**2)
      temp = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp**2
      if (.not.scratch(i, j, k, iprod) .eq. 0.0_8) scratchd(i, j, k, &
&       iprod) = scratchd(i, j, k, iprod) + ssd/(2.0*sqrt(scratch(i, j, &
&         k, iprod)))
    end do
  end subroutine sasource_fast_b
  subroutine sasource()
!
! ******************************************************************
! *                                                                *
! * source terms.                                                  *
! *                                                                *
! * determine the source term and its derivative w.r.t. nutilde    *
! * for all internal cells of the block.                           *
! *                                                                *
! ******************************************************************
    use blockpointers
    use constants
    use paramturb
    implicit none
! compute the source term jacobian. note that the part
! containing term1 is treated explicitly. the reason is that
! implicit treatment of this part leads to a decrease of the
! diagonal dominance of the jacobian and it thus decreases
! the stability. you may want to play around and try to
! take this term into account in the jacobian.
! note that -dsource/dnu is stored.
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
    real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
    real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
    real(kind=realtype), parameter :: xminn=1.e-10_realtype
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
      ss = sqrt(scratch(i, j, k, iprod))
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
      nu = rlv(i, j, k)/w(i, j, k, irho)
      dist2inv = one/d2wall(i, j, k)**2
      chi = w(i, j, k, itu1)/nu
      chi2 = chi*chi
      chi3 = chi*chi2
      fv1 = chi3/(chi3+cv13)
      fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
      ft2 = rsact3*exp(-(rsact4*chi2))
! ft2 = zero
! correct the production term to account for the influence
! of the wall. make sure that this term remains positive
! (the function fv2 is negative between chi = 1 and 18.4,
! which can cause sst to go negative, which is undesirable).
      sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
      if (sst .lt. xminn) then
        sst = xminn
      else
        sst = sst
      end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
      rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
      if (rr .gt. 10.0_realtype) then
        rr = 10.0_realtype
      else
        rr = rr
      end if
      gg = rr + rsacw2*(rr**6-rr)
      gg6 = gg**6
      termfw = ((one+cw36)/(gg6+cw36))**sixth
      fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
      term1 = rsacb1*(one-ft2)*ss
      term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)
      scratch(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, k&
&       , itu1)
! compute some derivatives w.r.t. nutilde. these will occur
! in the left hand side, i.e. the matrix for the implicit
! treatment.
      dfv1 = three*chi2*cv13/(chi3+cv13)**2
      dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
      dft2 = -(two*rsact4*chi*ft2/nu)
      drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
      dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
      dfw = cw36/(gg6+cw36)*termfw*dgg
    end do
  end subroutine sasource
!  differentiation of saviscous in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *rlv *scratch
!   with respect to varying inputs: *w *rlv *scratch
!   rw status of diff variables: *w:incr *rlv:incr *scratch:in-out
!   plus diff mem management of: w:in rlv:in scratch:in
  subroutine saviscous_fast_b()
!
! ******************************************************************
! *                                                                *
! * viscous term.                                                  *
! *                                                                *
! * determine the viscous contribution to the residual             *
! * for all internal cells of the block.                           *
! *                                                                *
! ******************************************************************
    use blockpointers
    use paramturb
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: nu
    real(kind=realtype) :: nud
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: cnudd, camd, capd
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: nutmd, nutpd, numd, nupd, cdmd, cdpd
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    real(kind=realtype) :: c1md, c1pd, c10d
    intrinsic mod
    intrinsic max
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp7
    real(kind=realtype) :: temp6
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp4
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
      nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
        c1m = cdm + cam
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
        c1p = cdp + cap
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i-1, j, k, itu1)*scratchd(i, j, k, idvt)
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i+1, j, k, itu1)*scratchd(i, j, k, idvt)
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd7 = ttp*cb3inv*cdpd
      nupd = tempd7
      nutpd = (one+rsacb2)*tempd7
      tempd8 = ttm*cb3inv*cdmd
      numd = tempd8
      nutmd = (one+rsacb2)*tempd8
      temp7 = w(i+1, j, k, irho)
      tempd9 = half*nupd/temp7
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + tempd9
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - rlv(i+1, j, k)*tempd9/&
&       temp7
      nud = half*numd + half*nupd
      temp6 = w(i-1, j, k, irho)
      tempd10 = half*numd/temp6
      rlvd(i-1, j, k) = rlvd(i-1, j, k) + tempd10
      wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - rlv(i-1, j, k)*tempd10&
&       /temp6
      temp5 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp5
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp5**2
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
    end do
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
      nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
        c1m = cdm + cam
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
        c1p = cdp + cap
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i, j-1, k, itu1)*scratchd(i, j, k, idvt)
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j+1, k, itu1)*scratchd(i, j, k, idvt)
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd3 = ttp*cb3inv*cdpd
      nupd = tempd3
      nutpd = (one+rsacb2)*tempd3
      tempd4 = ttm*cb3inv*cdmd
      numd = tempd4
      nutmd = (one+rsacb2)*tempd4
      temp4 = w(i, j+1, k, irho)
      tempd5 = half*nupd/temp4
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + tempd5
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - rlv(i, j+1, k)*tempd5/&
&       temp4
      nud = half*numd + half*nupd
      temp3 = w(i, j-1, k, irho)
      tempd6 = half*numd/temp3
      rlvd(i, j-1, k) = rlvd(i, j-1, k) + tempd6
      wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - rlv(i, j-1, k)*tempd6/&
&       temp3
      temp2 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp2
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp2**2
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
    end do
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
      nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
        c1m = cdm + cam
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 0
      else
        c1p = cdp + cap
myIntPtr = myIntPtr + 1
 myIntStack(myIntPtr) = 1
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i, j, k-1, itu1)*scratchd(i, j, k, idvt)
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j, k+1, itu1)*scratchd(i, j, k, idvt)
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
branch = myIntStack(myIntPtr)
 myIntPtr = myIntPtr - 1
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd = ttp*cb3inv*cdpd
      nupd = tempd
      nutpd = (one+rsacb2)*tempd
      tempd0 = ttm*cb3inv*cdmd
      numd = tempd0
      nutmd = (one+rsacb2)*tempd0
      temp1 = w(i, j, k+1, irho)
      tempd1 = half*nupd/temp1
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + tempd1
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - rlv(i, j, k+1)*tempd1/&
&       temp1
      nud = half*numd + half*nupd
      temp0 = w(i, j, k-1, irho)
      tempd2 = half*numd/temp0
      rlvd(i, j, k-1) = rlvd(i, j, k-1) + tempd2
      wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - rlv(i, j, k-1)*tempd2/&
&       temp0
      temp = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp**2
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
    end do
  end subroutine saviscous_fast_b
  subroutine saviscous()
!
! ******************************************************************
! *                                                                *
! * viscous term.                                                  *
! *                                                                *
! * determine the viscous contribution to the residual             *
! * for all internal cells of the block.                           *
! *                                                                *
! ******************************************************************
    use blockpointers
    use paramturb
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: nu
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    intrinsic mod
    intrinsic max
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in k-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
      nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j, k-1&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
    end do
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in j-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
      nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j-1, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
    end do
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in i-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
      nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i-1, j, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
    end do
  end subroutine saviscous
!  differentiation of saresscale in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:out
!   plus diff mem management of: dw:in scratch:in
  subroutine saresscale_fast_b()
!
! ******************************************************************
! *                                                                *
! * multiply the residual by the volume and store this in dw; this *
! * is done for monitoring reasons only. the multiplication with the
! * volume is present to be consistent with the flow residuals; also
! * the negative value is taken, again to be consistent with the   *
! * flow equations. also multiply by iblank so that no updates occur
! * in holes or the overset boundary.                              *
! *                                                                *
! ******************************************************************
    use blockpointers
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    scratchd = 0.0_8
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      x1 = real(iblank(i, j, k), realtype)
      if (x1 .lt. zero) then
        rblank = zero
      else
        rblank = x1
      end if
      scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) - vol(i, j, k)*&
&       rblank*dwd(i, j, k, itu1)
      dwd(i, j, k, itu1) = 0.0_8
    end do
  end subroutine saresscale_fast_b
  subroutine saresscale()
!
! ******************************************************************
! *                                                                *
! * multiply the residual by the volume and store this in dw; this *
! * is done for monitoring reasons only. the multiplication with the
! * volume is present to be consistent with the flow residuals; also
! * the negative value is taken, again to be consistent with the   *
! * flow equations. also multiply by iblank so that no updates occur
! * in holes or the overset boundary.                              *
! *                                                                *
! ******************************************************************
    use blockpointers
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      x1 = real(iblank(i, j, k), realtype)
      if (x1 .lt. zero) then
        rblank = zero
      else
        rblank = x1
      end if
      dw(i, j, k, itu1) = -(vol(i, j, k)*scratch(i, j, k, idvt)*rblank)
    end do
  end subroutine saresscale
  subroutine sasolve2()
!
! ******************************************************************
! *                                                                *
! * sasolve solves the turbulent transport equation for the        *
! * original spalart-allmaras model in a segregated manner using   *
! * a diagonal dominant adi-scheme.                                *
! *                                                                *
! ******************************************************************
    use bctypes
    use blockpointers
    use inputiteration
    use inputphysics
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype), dimension(2:max(kl, il, jl)) :: bb, cc, dd, ff
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    real(kind=realtype) :: uu, um, up, factor, f, tu1p, nu, rblank
    logical, dimension(2:jl, 2:kl), target :: flagi2, flagil
    logical, dimension(2:il, 2:kl), target :: flagj2, flagjl
    logical, dimension(2:il, 2:jl), target :: flagk2, flagkl
    logical, dimension(:, :), pointer :: flag
    intrinsic max
    intrinsic real
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
! initialize the wall function flags to .false.
    flagi2 = .false.
    flagil = .false.
    flagj2 = .false.
    flagjl = .false.
    flagk2 = .false.
    flagkl = .false.
! modify the rhs of the 1st internal cell, if wall functions
! are used; their value is determined by the table.
    if (wallfunctions) then
bocos:do nn=1,nviscbocos
! determine the block face on which the subface is located
! and set some variables. as flag points to the entire array
! flagi2, etc., its starting indices are the starting indices
! of its target and not 1.
        select case  (bcfaceid(nn)) 
        case (imin) 
          flag => flagi2
          ddw => dw(2, 1:, 1:, 1:)
          ddvt => scratch(2, 1:, 1:, idvt:)
          ww => w(2, 1:, 1:, 1:)
          rrlv => rlv(2, 1:, 1:)
          dd2wall => d2wall(2, :, :)
        case (imax) 
          flag => flagil
          ddw => dw(il, 1:, 1:, 1:)
          ddvt => scratch(il, 1:, 1:, idvt:)
          ww => w(il, 1:, 1:, 1:)
          rrlv => rlv(il, 1:, 1:)
          dd2wall => d2wall(il, :, :)
        case (jmin) 
          flag => flagj2
          ddw => dw(1:, 2, 1:, 1:)
          ddvt => scratch(1:, 2, 1:, idvt:)
          ww => w(1:, 2, 1:, 1:)
          rrlv => rlv(1:, 2, 1:)
          dd2wall => d2wall(:, 2, :)
        case (jmax) 
          flag => flagjl
          ddw => dw(1:, jl, 1:, 1:)
          ddvt => scratch(1:, jl, 1:, idvt:)
          ww => w(1:, jl, 1:, 1:)
          rrlv => rlv(1:, jl, 1:)
          dd2wall => d2wall(:, jl, :)
        case (kmin) 
          flag => flagk2
          ddw => dw(1:, 1:, 2, 1:)
          ddvt => scratch(1:, 1:, 2, idvt:)
          ww => w(1:, 1:, 2, 1:)
          rrlv => rlv(1:, 1:, 2)
          dd2wall => d2wall(:, :, 2)
        case (kmax) 
          flag => flagkl
          ddw => dw(1:, 1:, kl, :)
          ddvt => scratch(1:, 1:, kl, idvt:)
          ww => w(1:, 1:, kl, 1:)
          rrlv => rlv(1:, 1:, kl)
          dd2wall => d2wall(:, :, kl)
        end select
! loop over the owned faces of this subface. therefore the
! nodal range of bcdata must be used. the offset of +1 is
! present, because the starting index of the cell range is
! 1 larger than the starting index of the nodal range.
        do j=bcdata(nn)%jnbeg+1,bcdata(nn)%jnend
          do i=bcdata(nn)%inbeg+1,bcdata(nn)%inend
! set ddw to zero.
            ddw(i, j, itu1) = zero
! enforce nu tilde in the 1st internal cell from the
! wall function table. there is an offset of -1 in the
! wall distance. note that the offset compared to the
! current value must be stored, because dvt contains
! the update. also note that the curve fits contain the
! non-dimensional value.
            yp = ww(i, j, irho)*dd2wall(i-1, j-1)*viscsubface(nn)%utau(i&
&             , j)/rrlv(i, j)
            call curvetupyp(tu1p, yp, itu1, itu1)
            ddvt(i, j, 1) = tu1p*rrlv(i, j)/ww(i, j, irho) - ww(i, j, &
&             itu1)
! set the wall flag to .true.
            flag(i, j) = .true.
          end do
        end do
      end do bocos
    end if
! for implicit relaxation take the local time step into account,
! where dt is the inverse of the central jacobian times the cfl
! number. the following system is solved:
! (i/dt + cc + bb + dd)*dw = rhs, in which i/dt = cc/cfl. as in
! the rest of the algorithm only the modified central jacobian is
! used, stored it now.
! compute the factor multiplying the central jacobian, which
! is 1 + 1/cfl (implicit relaxation only).
    factor = one
    if (turbrelax .eq. turbrelaximplicit) factor = one + (one-alfaturb)/&
&       alfaturb
    do k=2,kl
      do j=2,jl
        do i=2,il
          qq(i, j, k) = factor*qq(i, j, k)
! set qq to 1 if the value is determined by the
! wall function table.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) qq(i, j, k) = &
&             one
        end do
      end do
    end do
! initialize the grid velocity to zero. this value will be used
! if the block is not moving.
    qs = zero
!
!      ******************************************************************
!      *                                                                *
!      * dd-adi step in j-direction. there is no particular reason to   *
!      * start in j-direction, it just happened to be so. as we solve   *
!      * in j-direction, the j-loop is the innermost loop.              *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do i=2,il
        do j=2,jl
! more or less the same code is executed here as above when
! the residual was built. however, now the off-diagonal
! terms for the dd-adi must be built and stored. this could
! have been done earlier, but then all the coefficients had
! to be stored. to save memory, they are recomputed.
! consequently, see the j-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! off-diagonal terms due to the diffusion terms
! in j-direction.
          nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
          nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          if (cdm + cam .lt. zero) then
            c1m = zero
          else
            c1m = cdm + cam
          end if
          if (cdp + cap .lt. zero) then
            c1p = zero
          else
            c1p = cdp + cap
          end if
          bb(j) = -c1m
          dd(j) = -c1p
! compute the grid velocity if present.
! it is taken as the average of j and j-1,
          if (addgridvelocities) qs = half*(sfacej(i, j, k)+sfacej(i, j-&
&             1, k))*voli
! off-diagonal terms due to the advection term in
! j-direction. first order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&           ivz) - qs
          um = zero
          up = zero
          if (uu .lt. zero) um = uu
          if (uu .gt. zero) up = uu
          bb(j) = bb(j) - up
          dd(j) = dd(j) + um
          x1 = real(iblank(i, j, k), realtype)
          if (x1 .lt. zero) then
            rblank = zero
          else
            rblank = x1
          end if
          cc(j) = qq(i, j, k)
          ff(j) = scratch(i, j, k, idvt)*rblank
          bb(j) = bb(j)*rblank
          dd(j) = dd(j)*rblank
! set the off diagonal terms to zero if the wall is flagged.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) then
            bb(j) = zero
            dd(j) = zero
          end if
        end do
! solve the tri-diagonal system in j-direction.
! first the backward sweep to eliminate the upper diagonal dd.
        do j=ny,2,-1
          f = dd(j)/cc(j+1)
          cc(j) = cc(j) - f*bb(j+1)
          ff(j) = ff(j) - f*ff(j+1)
        end do
! the matrix is now in lower block bi-diagonal form.
! perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        do j=3,jl
          ff(j) = ff(j) - bb(j)*ff(j-1)
          ff(j) = ff(j)/cc(j)
        end do
! determine the new rhs for the next direction.
        do j=2,jl
          scratch(i, j, k, idvt) = ff(j)*qq(i, j, k)
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dd-adi step in i-direction. as we solve in i-direction, the    *
!      * i-loop is the innermost loop.                                  *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! more or less the same code is executed here as above when
! the residual was built. however, now the off-diagonal
! terms for the dd-adi must be built and stored. this could
! have been done earlier, but then all the coefficients had
! to be stored. to save memory, they are recomputed.
! consequently, see the i-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! off-diagonal terms due to the diffusion terms
! in i-direction.
          nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
          nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          if (cdm + cam .lt. zero) then
            c1m = zero
          else
            c1m = cdm + cam
          end if
          if (cdp + cap .lt. zero) then
            c1p = zero
          else
            c1p = cdp + cap
          end if
          bb(i) = -c1m
          dd(i) = -c1p
! compute the grid velocity if present.
! it is taken as the average of i and i-1,
          if (addgridvelocities) qs = half*(sfacei(i, j, k)+sfacei(i-1, &
&             j, k))*voli
! off-diagonal terms due to the advection term in
! i-direction. first order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&           ivz) - qs
          um = zero
          up = zero
          if (uu .lt. zero) um = uu
          if (uu .gt. zero) up = uu
          bb(i) = bb(i) - up
          dd(i) = dd(i) + um
          x2 = real(iblank(i, j, k), realtype)
          if (x2 .lt. zero) then
            rblank = zero
          else
            rblank = x2
          end if
          cc(i) = qq(i, j, k)
          ff(i) = scratch(i, j, k, idvt)*rblank
          bb(i) = bb(i)*rblank
          dd(i) = dd(i)*rblank
! set the off diagonal terms to zero if the wall is flagged.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) then
            bb(i) = zero
            dd(i) = zero
          end if
        end do
! solve the tri-diagonal system in i-direction.
! first the backward sweep to eliminate the upper diagonal dd.
        do i=nx,2,-1
          f = dd(i)/cc(i+1)
          cc(i) = cc(i) - f*bb(i+1)
          ff(i) = ff(i) - f*ff(i+1)
        end do
! the matrix is now in lower block bi-diagonal form.
! perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        do i=3,il
          ff(i) = ff(i) - bb(i)*ff(i-1)
          ff(i) = ff(i)/cc(i)
        end do
! determine the new rhs for the next direction.
        do i=2,il
          scratch(i, j, k, idvt) = ff(i)*qq(i, j, k)
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dd-adi step in k-direction. as we solve in k-direction, the    *
!      * k-loop is the innermost loop.                                  *
!      *                                                                *
!      ******************************************************************
!
    do j=2,jl
      do i=2,il
        do k=2,kl
! more or less the same code is executed here as above when
! the residual was built. however, now the off-diagonal
! terms for the dd-adi must be built and stored. this could
! have been done earlier, but then all the coefficients had
! to be stored. to save memory, they are recomputed.
! consequently, see the k-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! off-diagonal terms due to the diffusion terms
! in k-direction.
          nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
          nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          if (cdm + cam .lt. zero) then
            c1m = zero
          else
            c1m = cdm + cam
          end if
          if (cdp + cap .lt. zero) then
            c1p = zero
          else
            c1p = cdp + cap
          end if
          bb(k) = -c1m
          dd(k) = -c1p
! compute the grid velocity if present.
! it is taken as the average of k and k-1,
          if (addgridvelocities) qs = half*(sfacek(i, j, k)+sfacek(i, j&
&             , k-1))*voli
! off-diagonal terms due to the advection term in
! k-direction. first order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&           ivz) - qs
          um = zero
          up = zero
          if (uu .lt. zero) um = uu
          if (uu .gt. zero) up = uu
          bb(k) = bb(k) - up
          dd(k) = dd(k) + um
          x3 = real(iblank(i, j, k), realtype)
          if (x3 .lt. zero) then
            rblank = zero
          else
            rblank = x3
          end if
          cc(k) = qq(i, j, k)
          ff(k) = scratch(i, j, k, idvt)*rblank
          bb(k) = bb(k)*rblank
          dd(k) = dd(k)*rblank
! set the off diagonal terms to zero if the wall is flagged.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) then
            bb(k) = zero
            dd(k) = zero
          end if
        end do
! solve the tri-diagonal system in k-direction.
! first the backward sweep to eliminate the upper diagonal dd.
        do k=nz,2,-1
          f = dd(k)/cc(k+1)
          cc(k) = cc(k) - f*bb(k+1)
          ff(k) = ff(k) - f*ff(k+1)
        end do
! the matrix is now in lower block bi-diagonal form.
! perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        do k=3,kl
          ff(k) = ff(k) - bb(k)*ff(k-1)
          ff(k) = ff(k)/cc(k)
        end do
! store the update in dvt.
        do k=2,kl
          scratch(i, j, k, idvt) = ff(k)
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * update the turbulent variables. for explicit relaxation the    *
!      * update must be relaxed; for implicit relaxation this has been  *
!      * done via the time step.                                        *
!      *                                                                *
!      ******************************************************************
!
    factor = one
    if (turbrelax .eq. turbrelaxexplicit) factor = alfaturb
    do k=2,kl
      do j=2,jl
        do i=2,il
          w(i, j, k, itu1) = w(i, j, k, itu1) + factor*scratch(i, j, k, &
&           idvt)
          if (w(i, j, k, itu1) .lt. zero) then
            w(i, j, k, itu1) = zero
          else
            w(i, j, k, itu1) = w(i, j, k, itu1)
          end if
        end do
      end do
    end do
  end subroutine sasolve2
end module samodule_fast_b

!
!     ******************************************************************
!     *                                                                *
!     * File:          verifydIdxFile.f90                              *
!     * Author:        C.A.(Sandy) Mader                               *
!     * Starting date: 06-05-2011                                      *
!     * Last modified: 06-05-2011                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine verifydIdxfile(level,costfunction,filename)
!
!     ******************************************************************
!     *                                                                *
!     * Compute all entries in dIdx (partial) using the automatically  *
!     * differentiated routines generated by Tapenade and print them   *
!     * to a file for comparison to the complex step results.          *
!     * This is only executed in debug mode.                           *
!     *                                                                *
!     ******************************************************************
!
      use adjointpetsc        !djdw
      use adjointVars         !nCellsGlobal
      use blockPointers
      use cgnsGrid            ! cgnsDoms
      use communication       ! procHalo(currentLevel)%nProcSend, myID
      use inputPhysics        ! equations
      use flowVarRefState     ! nw
      use inputDiscretization ! spaceDiscr, useCompactDiss
      use iteration           ! overset, currentLevel
      use inputTimeSpectral   ! nTimeIntervalsSpectral
      use section
      use monitor             ! monLoc, MonGlob, nMonSum
      use bcTypes             !imin,imax,jmin,jmax,kmin,kmax
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level,costfunction
      character(len = 64):: filename
!
!     Local variables.
!
      integer(kind=intType) ::  sps
      integer(kind=intType) ::  n,nn
      integer(kind=intType) :: i,j,k

  

      real(kind=realType), dimension(4) :: time
      real(kind=realType)               :: timeAdj, timeFD,timeAdjLocal

      ! > derivative output


  

      integer :: ierr,idxmgb

      character(len=2*maxStringLen) :: errorMessage
      character(len = 128)::outfile,testfile
 

!File Parameters
      integer :: unit = 8,ierror
   
      write(testfile,100) myid
100   format (i5)  
      testfile=adjustl(testfile)
      write(outfile,101) trim(filename),trim(testfile)
101   format(a,a,".out")
      unit = 8+myID
      
      open (UNIT=unit,File=outfile,status='replace',action='write',iostat=ierror)
      if(ierror /= 0)                        &
           call terminate("verifydIdxFile", &
           "Something wrong when &
           &calling open")

 
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
#ifndef USE_NO_PETSC
      !print *,'in verifydIdw'
      if( myID==0 ) write(*,*) "printing dIdx..."!,sps

      !assume that dJdx is already populated

      call cpu_time(time(1))


         
      !write solution to file....
      do sps = 1,nTimeIntervalsSpectral
         do nn = 1, nDom
            call setPointersAdj(nn,level,sps)
            do k = 1,ke!0,kb
               do j = 1,je!0,jb
                  do i = 1,ie!0,ib
                     do n = 1,3
                        idxmgb = globalNode(i,j,k)*3+n
                        print *,'index',sps,nn,k,j,i,n,idxmgb
                        if( (idxmgb-1)>=0) then
                           
                           call VecGetValues(dJdx, 1, idxmgb-1, &
                                value, PETScIerr)
                           
                           if( PETScIerr/=0 ) then
                              write(errorMessage,99) &
                                   "Error in VecGetValues for global Node", idxmgb
                              call terminate("verifydIdxFile",&
                                   errorMessage)
                           endif
                           if (abs(value).ne.0)then
                              print *,'values',value,idxmgb,nn,sps,globalNode(i,j,k),i,j,k

                           endif
                           if(costfunction==costFuncCl0)then
                              print *,'writing',value,sps,nn,k,j,i,n
                              write(unit,10) value,sps,nn,i,j,k,n,idxmgb,flowdoms(nn,level,sps)%cgnsblockid
10                            format(1x,'wcl0 ',f18.10,8I8)
                           elseif(costfunction==costFuncLiftCoef)then
                              write(unit,102) value,sps,nn,i,j,k,n,idxmgb
102                            format(1x,'wcl ',f18.10,7I8)
                           elseif(costfunction==costFuncMomZCoef)then
                              write(unit,103) value,sps,nn,i,j,k,n,idxmgb
103                            format(1x,'wcmz ',f18.10,7I8)
                           elseif(costfunction==costFuncCm0)then
                              write(unit,11) value,sps,nn,i,j,k,n,idxmgb
11                            format(1x,'wcmz0 ',f18.10,7I8)
                           elseif(costfunction==costFuncClAlpha)then
                              write(unit,12) value,sps,nn,i,j,k,n,idxmgb
12                            format(1x,'wdcldalpha ',f18.10,7I8)
                           elseif(costfunction==costFuncCmzAlpha)then
                              write(unit,13) value,sps,nn,i,j,k,n,idxmgb
13                            format(1x,'wdcmzdalpha ',f18.10,7I8)
                           elseif(costfunction==costFuncCmzq)then
                              write(unit,14) value,sps,nn,i,j,k,n,idxmgb
14                            format(1x,'wdcmzdq ',f18.10,7I8)
                           elseif(costfunction==costFuncClq)then
                              write(unit,15) value,sps,nn,i,j,k,n,idxmgb
15                            format(1x,'wdcldq ',f18.10,7I8)
                           else
                              print *,'not a valid cost function in this context'
                           endif
                        endif
                        
                        
                     enddo
                  enddo
               end do
            end do
         end do
      end do
      
      close(unit)
      
      call cpu_time(time(2))
      timeAdjLocal = time(2)-time(1)
      
      ! Determine the maximum time using MPI reduce
      ! with operation mpi_max.
      
      call mpi_reduce(timeAdjLocal, timeAdj, 1, sumb_real, &
           mpi_max, 0, SUMB_PETSC_COMM_WORLD, PETScIerr)
      
      if( myID==0 ) &
           write(*,20) "Printing ADjoint TS djdx vector time (s) = ", timeAdj
      
      
      ! Flush the output buffer and synchronize the processors.
      
      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
      !
      !     ******************************************************************
      !

      
      ! Deallocate memory for the temporary arrays.


  
      ! Output formats.

!  10  format(1x,a,1x,i3,1x,i3,1x,a,1x,i3,1x,i3,1x,i3)    
20 format(1x,a,8(1x,e13.6))       
!20 format(1x,(e18.6),2x,(e18.6),2x,(e18.6))
  30  format(1x,a,1x,i3,2x,e13.6,1x,5(i2,1x),3x,e13.6,1x,5(i2,1x))
  99  format(a,1x,i6)
#endif
 end subroutine verifydIdxfile
    

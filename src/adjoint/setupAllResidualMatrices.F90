!
!     ******************************************************************
!     *                                                                *
!     * File:          setupAllResidualMatrices.F90                    *
!     * Author:        C.A.(Sandy) Mader                               *
!     * Starting date: 06-04-2010                                      *
!     * Last modified: 06-04-2010                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine setupAllResidualMatrices
  !
  !     ******************************************************************
  !     *                                                                *
  !     * Combines all of the redidual setting routines into one....     *
  !     * Compute the transpose of the matrix dRdW of the discrete       *
  !     * ADjoint problem for                                            *
  !     * subsequent use by the solveADjointPETSc subroutine. The entries*
  !     * in dRdw are obtained using the automatically differentiated    *
  !     * routines generated by Tapenade.                                *
  !     *                                                                *
  !     * The ordering of the unknowns in the ADjoint matrix used here   *
  !     * is based on the global node numbering and is consistent with   *
  !     * the ordering used in the vector for the ADjoint problem        *
  !     * assembled in setupADjointRHS.                                  *
  !     *                                                                *
  !     ******************************************************************
  !
#ifndef USE_COMPLEX
  use ADjointPETSc
  use ADjointVars 
  use blockPointers   
  use communication    
  use inputDiscretization
  USE inputTimeSpectral 
  use iteration         
  use flowVarRefState   
  use inputADjoint 
  use section 
  use monitor      
  implicit none
  !
  !     Local variables.
  !
  integer(kind=intType) :: discr, nHalo,level
  integer(kind=intType) :: iCell, jCell, kCell
  integer(kind=intType) :: mm, nn, m, n,idxstate,idxres,idxnode
  integer(kind=intType) :: ii, jj, kk, i, j, k,liftIndex,l,ll

  logical :: fineGrid, correctForK, exchangeTurb,secondhalo
  logical :: useAD,useTranspose,usePC
  real(kind=realType), dimension(-2:2,-2:2,-2:2,nw,nTimeIntervalsSpectral) :: wAdj, wAdjB
  real(kind=realType), dimension(-3:2,-3:2,-3:2,3,nTimeIntervalsSpectral)  :: xAdj, xAdjB

  real(kind=realType), dimension(nw,nTimeIntervalsSpectral) :: dwAdj, dwAdjB

  REAL(KIND=REALTYPE) :: machadj, machcoefadj, uinfadj, pinfcorradj
  REAL(KIND=REALTYPE) :: machadjb, machcoefadjb,machgridadj, machgridadjb
  REAL(KIND=REALTYPE) :: prefadj, rhorefadj
  REAL(KIND=REALTYPE) :: pinfdimadj, rhoinfdimadj
  REAL(KIND=REALTYPE) :: rhoinfadj, pinfadj
  REAL(KIND=REALTYPE) :: murefadj, timerefadj
  REAL(KIND=REALTYPE) :: alphaadj, betaadj
  REAL(KIND=REALTYPE) :: alphaadjb, betaadjb
  REAL(KIND=REALTYPE), DIMENSION(3) :: rotcenteradj
  REAL(KIND=REALTYPE), DIMENSION(3) :: rotrateadj
  REAL(KIND=REALTYPE) :: rotcenteradjb(3), rotrateadjb(3)
  REAL(KIND=REALTYPE) :: pointrefadj(3), pointrefadjb(3), rotpointadj(3)&
       &  , rotpointadjb(3)
  REAL(KIND=REALTYPE) :: xblockcorneradj(2, 2, 2, 3,nTimeIntervalsSpectral), xblockcorneradjb(2&
       &  , 2, 2, 3,nTimeIntervalsSpectral)

  integer(kind=intType), dimension(0:nProc-1) :: offsetRecv

  real(kind=realType), dimension(2) :: time
  real(kind=realType)               :: timeAdjLocal, timeAdj

  ! dR/dw stencil

  real(kind=realType), dimension(nw,nw,nTimeIntervalsSpectral) :: Aad, Bad, BBad, &
       Cad, CCad, Dad, DDad, Ead, EEad, Fad, FFad, Gad, GGad

  ! idxmgb - global block row index
  ! idxngb - global block column index

  integer(kind=intType) :: idxmgb, idxngb,ierr, sps,sps2

  ! idxmgb - array of global row indices
  ! idxngb - array of global column indices

  integer(kind=intType), dimension(nw) :: idxmg, idxng
  integer(kind=intType) :: ind_node(3),cellstodo,iiCell,ind(3,56)
  character(len=2*maxStringLen) :: errorMessage

  !temporary storage for current dissipation coefficients. Used in error check
  real(kind=realType)::vis2ref,vis4ref

  !matrix norm check
  real(kind=realType)               ::val

  !correction to rotPoint
  real(kind=realType),dimension(3):: r,RpXCorrection,RpYCorrection,RpZCorrection
  real(kind=realType)::rotpointxcorrection,rotpointycorrection,rotpointzcorrection

  real(kind=realType) :: t(nSections),dt(nSections)
  real(kind=realType) :: displ(3)
  real(kind=realType) :: tOld,tNew

  real(kind=realType), dimension(3)   :: rotationPoint
  real(kind=realType), dimension(3,3) :: rotationMatrix

  !
  !     ******************************************************************
  !     *                                                                *
  !     * Begin execution.                                               *
  !     *                                                                *
  !     ******************************************************************
  !
#ifndef USE_NO_PETSC


  ! Set the grid level of the current MG cycle, the value of the
  ! discretization and the logical correctForK.

  level = 1_intType
  currentLevel = level
  !discr        = spaceDiscr
  fineGrid     = .true.

  ! Determine whether or not the total energy must be corrected
  ! for the presence of the turbulent kinetic energy and whether
  ! or not turbulence variables should be exchanged.

  if( kPresent ) then
     if((currentLevel <= groundLevel) .or. turbCoupled) then
        correctForK = .true.
     else
        correctForK = .false.
     endif
  else
     correctForK = .false.
  endif

  exchangeTurb = .false.

  ! Set the value of secondHalo, depending on the situation.
  ! In the full MG (currentLevel < groundLevel) the second halo is
  ! always set; otherwise only on the finest mesh in the current mg
  ! cycle.

  if(currentLevel <= groundLevel) then
     secondHalo = .true.
  else
     secondHalo = .false.
  endif

  !
  !     ******************************************************************
  !     *                                                                *
  !     * Exchange halo data to make sure it is up-to-date.              *
  !     * (originally called inside "rungeKuttaSmoother" subroutine).    *
  !     *                                                                *
  !     ******************************************************************
  !
  ! Exchange the pressure if the pressure must be exchanged early.
  ! Only the first halo's are needed, thus whalo1 is called.
  ! Only on the fine grid.

  if(exchangePressureEarly .and. currentLevel <= groundLevel) &
       call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
       .false., .false.)

  ! Apply all boundary conditions to all blocks on this level.

  call applyAllBC(secondHalo)

  ! Exchange the solution. Either whalo1 or whalo2
  ! must be called.

  if( secondHalo ) then
     call whalo2(currentLevel, 1_intType, nMGVar, .true., &
          .true., .true.)
  else
     call whalo1(currentLevel, 1_intType, nMGVar, .true., &
          .true., .true.)
  endif

  ! Reset the values of rkStage and currentLevel, such that
  ! they correspond to a new iteration.

  rkStage = 0
  currentLevel = groundLevel
  lumpedDiss=.False.
  !
  !     ******************************************************************
  !     *                                                                *
  !     * Compute the ADjoint matrix dR/dW using Tapenade's reverse mode *
  !     * of Automatic Differentiation.  NOTE: This is the reason I have *
  !     * been writing the word "ADjoint" with A and D capitalized. A    *
  !     * simple play with letter so that:                               *
  !     *                                                                *
  !     * ADjoint = Automatically Differentiated adjoint                 *
  !     *                                                                *
  !     ******************************************************************
  !
  ! Send some feedback to screen.


  if( myid ==0 ) &
       write(*,10) "Assembling All Residual Matrices..."
  
  call cpu_time(time(1))

  !zero the matrix for dRdW Insert call
  call MatZeroEntries(dRdwt,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)

  !zero the matrix for dRdx ADD call
  call MatZeroEntries(dRdx,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)

  !zero the matrix for dRda ADD call
  call MatZeroEntries(dRda,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)

  !needed for rotpoint correction
  do nn=1,nSections
     dt(nn) = sections(nn)%timePeriod &
          / real(nTimeIntervalsSpectral,realType)
  enddo
  
  timeUnsteady = zero

  domainLoopAD: do nn=1,nDom

     ! Loop over the number of time instances for this block.
     spectralLoop: do sps=1,nTimeIntervalsSpectral

        call setPointers(nn,level,sps)

        ! Loop over location of output (R) cell of residual

        do kCell = 2, kl
           do jCell = 2, jl
              do iCell = 2, il
                 !print *,'nn,i,j,k:',nn,icell,jcell,kcell
                 ! Copy the state w to the wAdj array in the stencil
                 call copyADjointStencil(wAdj, xAdj,xBlockCornerAdj,alphaAdj,&
                      betaAdj,MachAdj,machCoefAdj,machGridAdj,iCell, jCell, kCell,&
                      nn,level,sps,pointRefAdj,rotPointAdj,&
                      prefAdj,rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
                      rhoinfAdj, pinfAdj,rotRateAdj,rotCenterAdj,&
                      murefAdj, timerefAdj,pInfCorrAdj,liftIndex)

                 Aad(:,:,:)  = zero
                 Bad(:,:,:)  = zero
                 BBad(:,:,:) = zero
                 Cad(:,:,:)  = zero
                 CCad(:,:,:) = zero
                 Dad(:,:,:)  = zero
                 DDad(:,:,:) = zero
                 Ead(:,:,:)  = zero
                 EEad(:,:,:) = zero
                 Fad(:,:,:)  = zero
                 FFad(:,:,:) = zero
                 Gad(:,:,:)  = zero
                 GGad(:,:,:) = zero

                 mLoop: do m = 1, nw      ! Loop over output cell residuals (R)

                    ! Initialize the seed for the reverse mode
                    dwAdjb(:,:) = 0.
                    dwAdjb(m,sps) = 1.
                    dwAdj(:,:)  = 0.
                    wAdjb(:,:,:,:,:)  = 0.  !dR(m)/dw
                    xAdjb(:,:,:,:,:)  = 0.  !dR(m)/dx
                    xblockcorneradjb  = 0.
                    xadjb = 0.
                    alphaadjb = 0.
                    betaadjb = 0.
                    machadjb = 0.
                    machgridadjb = 0.
                    rotrateadjb(:)=0. 
                    rotpointadjb(:)=0.
                    pointrefadjb(:)=0.
                    rotcenteradjb(:)=0.

                    ! Call the reverse mode of residual computation.
                    !
                    !                          dR(iCell,jCell,kCell,l)
                    ! wAdjb(ii,jj,kk,n) = --------------------------------
                    !                     dW(iCell+ii,jCell+jj,kCell+kk,n)

                    ! Call reverse mode of residual computation


!                call COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, xblockcorneradj, &
!                     &  xblockcorneradjb, dwadj, dwadjb, alphaadj, alphaadjb, betaadj, &
!                     &  betaadjb, machadj, machadjb, machcoefadj, machgridadj, machgridadjb, &
!                     &  icell, jcell, kcell, nn, level, sps, correctfork, secondhalo, prefadj&
!                     &  , rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, rotrateadj&
!                     &  , rotrateadjb, rotcenteradj, rotcenteradjb, pointrefadj, rotpointadj&
!                     &  , rotpointadjb, murefadj, timerefadj, pinfcorradj, liftindex)

                    call COMPUTERADJOINTTS_B(wadj, wadjb, xadj, xadjb, xblockcorneradj&
                         &  , xblockcorneradjb, dwadj, dwadjb, alphaadj, alphaadjb, betaadj, &
                         &  betaadjb, machadj, machadjb, machcoefadj, machgridadj, machgridadjb, &
                         &  icell, jcell, kcell, nn, level, sps, correctfork, secondhalo, prefadj&
                         &  , rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, rotrateadj&
                         &  , rotrateadjb, rotcenteradj, rotcenteradjb, pointrefadj, rotpointadj&
                         &  , rotpointadjb, murefadj, timerefadj, pinfcorradj, liftindex)


               !COMPUTERADJOINT_B(wadj, wadjb, xadj, xadjb, xblockcorneradj, &
               !     &  xblockcorneradjb, dwadj, dwadjb, alphaadj, alphaadjb, betaadj, &
               !          &  betaadjb, machadj, machadjb, machcoefadj, machgridadj, machgridadjb, &
               !          &  icell, jcell, kcell, nn, level, sps, correctfork, secondhalo, prefadj&
               !          &  , rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, rotrateadj&
               !          &  , rotrateadjb, rotcenteradj, rotcenteradjb, pointrefadj, pointrefadjb&
               !          &  , rotpointadj, rotpointadjb, murefadj, timerefadj, pinfcorradj, &
               !          &  liftindex)
                  !   ! Store the block Jacobians (by rows).

                    Aad(m,:,:)  = wAdjB( 0, 0, 0,:,:)
                    Bad(m,:,:)  = wAdjB(-1, 0, 0,:,:)
                    BBad(m,:,:) = wAdjB(-2, 0, 0,:,:)
                    Cad(m,:,:)  = wAdjB( 1, 0, 0,:,:)
                    CCad(m,:,:) = wAdjB( 2, 0, 0,:,:)
                    Dad(m,:,:)  = wAdjB( 0,-1, 0,:,:)
                    DDad(m,:,:) = wAdjB( 0,-2, 0,:,:)
                    Ead(m,:,:)  = wAdjB( 0, 1, 0,:,:)
                    EEad(m,:,:) = wAdjB( 0, 2, 0,:,:)
                    Fad(m,:,:)  = wAdjB( 0, 0,-1,:,:)
                    FFad(m,:,:) = wAdjB( 0, 0,-2,:,:)
                    Gad(m,:,:)  = wAdjB( 0, 0, 1,:,:)
                    GGad(m,:,:) = wAdjB( 0, 0, 2,:,:)

                    idxres   = globalCell(iCell,jCell,kCell)*nw+ m - 1
                  !  call five_pt_node_stencil_all(icell,jcell,kcell,ind,cellstodo)
                    rotpointxcorrection = 0.0
                    rotpointycorrection = 0.0
                    rotpointzcorrection = 0.0

                    do sps2 = 1,nTimeIntervalsSpectral
!                         do iiCell=1,CellsToDo
!                            ii = ind(1,iiCell)
!                            jj = ind(2,iiCell)
!                            kk = ind(3,iiCell)
                       !for rotpoint correction
                       do ll=1,nSections
                          t(ll) = (sps2-1)*dt(ll)
                       enddo

                       ! Compute the displacements due to the rigid motion of the mesh.
                       
                       displ(:) = zero
                       
                       tNew = timeUnsteady + timeUnsteadyRestart
                       tOld = tNew - t(1)
                       
                       call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                       !rotation Point correction for rotPoint derivative
                       r = (/-1,0,0/)
                       RpXCorrection = matmul(rotationMatrix,r)
                       r = (/0,-1,0/)
                       RpYCorrection = matmul(rotationMatrix,r)
                       r = (/0,0,-1/)
                       RpZCorrection = matmul(rotationMatrix,r)
                       do kk = -3,2!1,kl-1
                          do jj = -3,2!1,jl-1
                             do ii= -3,2!1,il-1

                                i = iCell + ii
                                j = jCell + jj
                                k = kCell + kk
                                if (xAdjb(ii,jj,kk,1,sps2) .ne. 0.0 .or.&
                                    xAdjb(ii,jj,kk,2,sps2) .ne. 0.0 .or.& 
                                    xAdjb(ii,jj,kk,3,sps2) .ne. 0.0)then
                                    if(i>=0 .and. j>=0 .and. k>=0 .and. i<=ie .and. j<=je .and. k<=ke)then

                                      ind_node(1) = flowdoms(nn,level,sps2)%globalNode(i,j,k)*3
                                      ind_node(2) = ind_node(1) + 1
                                      ind_node(3) = ind_node(1) + 2

                                      if( (idxres)>=0 .and. ind_node(1)>=0) then ! replaced idxnode with ind(1)

                                         call MatSetValues(dRdx, 3, ind_node, 1, idxres,  &
                                              xAdjb(ii,jj,kk,:,sps2), ADD_VALUES, PETScIerr)
                                         ! NO error check here for speed purposes
                                         ! call ECHk(PETScIerr,__FILE__,__LINE__)
                                         
                                         rotpointxcorrection = rotpointxcorrection+ &
                                              DOT_PRODUCT(xAdjb(ii,jj,kk,:,sps2),((/1,0,0/)+ RpXCorrection))
                                         rotpointycorrection = rotpointycorrection+&
                                              DOT_PRODUCT(xAdjb(ii,jj,kk,:,sps2),((/0,1,0/)+ RpYCorrection))
                                         rotpointzcorrection = rotpointzcorrection+ &
                                              DOT_PRODUCT(xAdjb(ii,jj,kk,:,sps2),((/0,0,1/)+ RpZCorrection))
                                      endif
                                      

                                   endif
                                endif
                             enddo
                          enddo
                       enddo
                          
                       !set values for symmtery plane normal derivatives
                       do l = 1,3
                          if (xblockcorneradjb(1,1,1,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalNode(1,1,1)*3+l
                             call MatSetValues(drdx, 1, idxnode-1, 1, idxres,  &
                                  xblockcorneradjb(1,1,1,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(1,1,1,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(1,1,1,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(1,1,1,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                          if (xblockcorneradjb(2,1,1,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalNode(il,1,1)*3+l
                             call MatSetValues(drdx, 1, idxnode-1 , 1,idxres,   &
                                  xblockcorneradjb(2,1,1,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(2,1,1,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(2,1,1,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(2,1,1,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                          if (xblockcorneradjb(1,2,1,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalnode(1,jl,1)*3+l
                             call MatSetValues(drdx, 1, idxnode-1, 1, idxres, &
                                  xblockcorneradjb(1,2,1,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(1,2,1,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(1,2,1,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(1,2,1,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                          if (xblockcorneradjb(2,2,1,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalnode(il,jl,1)*3+l
                             call MatSetValues(drdx, 1, idxnode-1 , 1,idxres, &
                                  xblockcorneradjb(2,2,1,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(2,2,1,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(2,2,1,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(2,2,1,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                          if (xblockcorneradjb(1,1,2,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalnode(1,1,kl)*3+l
                             call MatSetValues(drdx, 1,idxnode-1, 1, idxres ,   &
                                  xblockcorneradjb(1,1,2,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(1,1,2,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(1,1,2,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(1,1,2,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                          if (xblockcorneradjb(1,2,2,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalnode(1,jl,kl)*3+l
                             call MatSetValues(drdx, 1, idxnode-1, 1, idxres,   &
                                  xblockcorneradjb(1,2,2,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(1,2,2,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(1,1,1,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(1,1,1,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                          if (xblockcorneradjb(2,1,2,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalnode(il,1,kl)*3+l
                             call MatSetValues(drdx, 1, idxnode-1, 1, idxres,   &
                                  xblockcorneradjb(2,1,2,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(2,1,2,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(2,1,2,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(2,1,2,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                          if (xblockcorneradjb(2,2,2,l,sps).ne.0.0)then
                             idxnode = flowDoms(nn,level,sps)%globalnode(il,jl,kl)*3+l
                             call MatSetValues(drdx, 1,idxnode-1, 1, idxres,   &
                                  xblockcorneradjb(2,2,2,l,sps), ADD_VALUES, PETScIerr)
                             call EChk(PETScIerr,__FILE__,__LINE__)
                             r = (/1,0,0/)
                             rotpointxcorrection = rotpointxcorrection+ xblockcorneradjb(2,2,2,l,sps)*(r(l)+ RpXCorrection(l))
                             r = (/0,1,0/)
                             rotpointycorrection = rotpointycorrection+ xblockcorneradjb(2,2,2,l,sps)*(r(l)+ RpYCorrection(l))
                             r = (/0,0,1/)
                             rotpointzcorrection = rotpointzcorrection+ xblockcorneradjb(2,2,2,l,sps)*(r(l)+ RpZCorrection(l))
                          endif
                       enddo
                    end do


                    ! Transfer the block Jacobians to the global [dR/da]
                    ! matrix by setting the corresponding block entries of
                    ! the PETSc matrix dRda.
                    !
                    ! Global matrix column idxmg function of node indices.
                    ! (note: index displaced by previous design variables)
                  
                   !Angle of Attack
                   
                    if (nDesignAoA >= 0) then
                       !print *,'alphadjb:',alphaadjb,myID,ndesignAoA,idxres
                       call MatSetValues(dRda, 1, idxres, 1, nDesignAoA, &
                            alphaadjb, INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    ! Side slip angle
                    if (nDesignSSA >= 0) then
                       !print *,'betadjb:',betaadjb,myID,ndesignSSA,idxres
                       call MatSetValues(dRda, 1, idxres,1, nDesignSSA, &
                            betaadjb, INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Mach Number
                    if (nDesignMach >= 0) then
                       !print *,'mach:',myID,1,ndesignmach
                       call MatSetValues(dRda, 1, idxres,1, nDesignMach, &
                            machAdjb, INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Mach NumberGrid
                    if (nDesignMachGrid >= 0) then
                       !print *,'machgrid',myID,ndesignmachgrid
                       call MatSetValues(dRda, 1, idxres,1, nDesignMachGrid, &
                            machGridAdjb, INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !X Rotation
                    if (nDesignRotX >= 0) then
                       !print *,'rotx:',myID,ndesignrotx
                       call MatSetValues(dRda, 1, idxres,1, nDesignRotX, &
                            rotrateadjb(1), INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Y Rotation
                    if (nDesignRotY >= 0) then
                       !print *,'roty:',myID,ndesignroty
                       call MatSetValues(dRda, 1, idxres,1, nDesignRotY, &
                            rotrateadjb(2), INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Z Rotation
                    if (nDesignRotZ >= 0) then
                       !print *,'rotz:',myID,ndesignrotz
                       call MatSetValues(dRda, 1, idxres,1, nDesignRotZ, &
                            rotrateadjb(3), INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !X Rotation Center
                    if (nDesignRotCenX >= 0) then
                       !print *,'rotcenx:',myID,ndesignrotcenx,rotcenteradjb(1),rotpointadjb(1),rotpointxcorrection!(1)
                       call MatSetValues(dRda, 1, idxres,1, nDesignRotCenX, &
                            rotcenteradjb(1)+rotpointadjb(1)+rotpointxcorrection, INSERT_VALUES,&
                            PETScIerr)
                       
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Y Rotation Center
                    if (nDesignRotCenY >= 0) then
                       !print *,'rotceny:',myID,ndesignrotceny
                       !call MatSetValues(dRda, 1, idxres,1, nDesignRotCenY, &
                       !     rotpointadjb(2)+rotpointcorrection(2), INSERT_VALUES,&
                       !     PETScIerr)
                       call MatSetValues(dRda, 1, idxres,1, nDesignRotCenY, &
                            rotcenteradjb(2)+rotpointadjb(2)+rotpointycorrection, INSERT_VALUES,&
                            PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Z Rotation Center
                    if (nDesignRotCenZ >= 0) then
                       !print *,'rotcenterz:',myID,ndesignrotcenz
                       !call MatSetValues(dRda, 1, idxres,1, nDesignRotCenZ, &
                       !     rotpointadjb(3)+rotpointcorrection(3), INSERT_VALUES,&
                       !     PETScIerr)
                       call MatSetValues(dRda, 1, idxres,1, nDesignRotCenZ, &
                            rotcenteradjb(3)+rotpointadjb(3)+rotpointzcorrection, INSERT_VALUES,&
                            PETScIerr)

                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !X Point Ref
                    if (nDesignPointRefX >= 0) then
!!$                       if (pointrefadjb(1) .ne.0) then
!!$                          print *,'pointrefx:',myID,ndesignPointRefx,pointrefadjb(1)
!!$                       end if
                       call MatSetValues(dRda, 1, idxres, 1,nDesignPointRefX, &
                            pointrefadjb(1), INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Y Point Ref
                    if (nDesignPointRefY >= 0) then
                       !print *,'pointrefy:',myID,ndesignPointRefy
                       call MatSetValues(dRda, 1, idxres,1, nDesignPointRefY, &
                            pointrefadjb(2), INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if

                    !Z Point Ref
                    if (nDesignPointRefZ >= 0) then
                       !print *,'pointrefz:',myID,ndesignPointRefZ
                       call MatSetValues(dRda, 1, idxres,1, nDesignPointRefZ, &
                            pointrefadjb(3), INSERT_VALUES, PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end if
                 enddo mLoop
                 if(PETScBlockMatrix) then

                    ! Global matrix block row mgb function of node indices.
                    !
                    ! MatSetValuesBlocked() uses 0-based row and column 
                    ! numbers but the global node numbering already accounts
                    ! for that since it starts at node 0.

                    idxmgb = globalCell(iCell,jCell,kCell)
                    do sps2 = 1,nTimeIntervalsSpectral
                       ! >>> center block A < W(i,j,k)
                       idxngb = flowDoms(nn,level,sps2)%globalCell(iCell,jCell,kCell)!idxmgb
                       !flip matrix indices to get transpose
                       call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                            transpose(Aad(:,:,sps2)), ADD_VALUES,PETScIerr)
                       call EChk(PETScIerr,__FILE__,__LINE__)
                    end do

                    ! >>> west block B < W(i-1,j,k)

                    if( (iCell-1) >= 0 ) then
                       idxngb = globalCell(iCell-1,jCell,kCell)
                       if (idxngb >=0 .and. idxngb.ne.-5) then
                          !print *,'indiciesi-1',idxmgb,idxngb
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(Bad(:,:,sps)), ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    endif

                    ! far west block BB < W(i-2,j,k)

                    if( (iCell-2) >= 0 ) then
                       idxngb = globalCell(iCell-2,jCell,kCell)!idxmgb
                       if (idxngb >=0 .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(BBad(:,:,sps)),ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> east block C < W(i+1,j,k)

                    if( (iCell+1) <= ib ) then
                       idxngb = globalCell(iCell+1,jCell,kCell)!idxmgb
                       if (idxngb<nCellsGlobal(1_intType)*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(Cad(:,:,sps)), ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> far east block CC < W(i+2,j,k)
                    if( (iCell+2) <= ib ) then
                       idxngb = globalCell(iCell+2,jCell,kCell)!idxmgb
                       if (idxngb<nCellsGlobal(1_intType)*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(CCad(:,:,sps)),ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> south block D < W(i,j-1,k)

                    if( (jCell-1) >= 0 ) then
                       idxngb = globalCell(iCell,jCell-1,kCell)!idxmgb
                       if (idxngb>=0 .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(Dad(:,:,sps)), ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    endif

                    ! >>> far south block DD < W(i,j-2,k)

                    if( (jCell-2) >= 0 ) then
                       idxngb = globalCell(iCell,jCell-2,kCell)!idxmgb
                       if (idxngb>=0 .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(DDad(:,:,sps)),ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> north block E < W(i,j+1,k)

                    if( (jCell+1) <= jb ) then
                       idxngb = globalCell(iCell,jCell+1,kCell)!idxmgb
                       if (idxngb<nCellsGlobal(1_intType)*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(Ead(:,:,sps)), ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> far north block EE < W(i,j+2,k)

                    if( (jCell+2) <= jb ) then
                       idxngb = globalCell(iCell,jCell+2,kCell)!idxmgb
                       if (idxngb<nCellsGlobal(1_intType)*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(EEad(:,:,sps)),ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> back block F < W(i,j,k-1)

                    if( (kCell-1) >= 0 ) then
                       idxngb = globalCell(iCell,jCell,kCell-1)!idxmgb
                       if (idxngb>=0 .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(Fad(:,:,sps)), ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    endif

                    ! >>> far back block FF < W(i,j,k-2)

                    if( (kCell-2) >= 0 ) then
                       idxngb = globalCell(iCell,jCell,kCell-2)!idxmgb
                       if (idxngb>=0 .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(FFad(:,:,sps)),ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> front block G < W(i,j,k+1)

                    if( (kCell+1) <= kb ) then
                       idxngb = globalCell(iCell,jCell,kCell+1)!idxmgb
                       if (idxngb<nCellsGlobal(1_intType)*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(Gad(:,:,sps)), ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if

                    ! >>> far front block GG < W(i,j,k+2)

                    if( (kCell+2) <= kb ) then
                       idxngb = globalCell(iCell,jCell,kCell+2)!idxmgb
                       if (idxngb<nCellsGlobal(1_intType)*nTimeIntervalsSpectral .and. idxngb.ne.-5) then
                          call MatSetValuesBlocked(dRdWt, 1, idxngb, 1, idxmgb, &
                               transpose(GGad(:,:,sps)),ADD_VALUES,PETScIerr)
                          call EChk(PETScIerr,__FILE__,__LINE__)
                       endif
                    end if
                 else ! PETScBlockMatrix
                    print *,'Non-Block Matrix Not Setup'
                    stop

                 endif ! PETScBlockMatrix
              end do

           enddo
        enddo
        
     enddo spectralLoop
     !===============================================================

  enddo domainLoopad

  if (nDesignDissError >= 0) then
     !print *,'nDesignDissError',nDesignDissError
     !==================================
     !Compute Dissipation error estimate
     !==================================
     
     !store dissipation coefficients
     vis2ref = vis2
     vis4ref = vis4
     
     !set dissipation coefficients to zero
     vis2 = 0.0
     vis4 = 0.0
     
     !evaluate new residual
     call whalo2(1_intType, 1_intType, nw, .True.,.True.,.True.)
     call computeResidualNK()

     
     !Store updated residual. This is an indication of how much error the dissipation scheme is causing
     
     do nn=1,nDom
        
        ! Loop over the number of time instances for this block.
        do sps=1,nTimeIntervalsSpectral
           
           call setPointers(nn,level,sps)
           
           ! Loop over location of output (R) cell of residual
           
           do kCell = 2, kl
              do jCell = 2, jl
                 do iCell = 2, il
                    do m = 1, nw 
                       idxres   = globalCell(iCell,jCell,kCell)*nw+ m - 1
                       
                       call MatSetValues(dRda, 1, idxres,1, nDesignDissError, &
                            dw(icell,jcell,kcell,m), INSERT_VALUES,&
                            PETScIerr)
                       
                       call EChk(PETScIerr,__FILE__,__LINE__)

                    end do
                 end do
              end do
           end do
        end do
     end do

     !Now restore the original residual

     !reset the original dissipation coefficients
     vis2 = vis2ref
     vis4 = vis4ref

     !reevaluate residual
     call whalo2(1_intType, 1_intType, nw, .True.,.True.,.True.)
     call computeResidualNK()
     
  end if

  !     ******************************************************************
  !     *                                                                *
  !     * Complete the PETSc matrix assembly process.                    *
  !     *                                                                *
  !     ******************************************************************

  call MatAssemblyBegin(dRdWT,MAT_FINAL_ASSEMBLY,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)
  call MatAssemblyBegin(dRdx,MAT_FINAL_ASSEMBLY,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)
  call MatAssemblyBegin(dRda,MAT_FINAL_ASSEMBLY,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)

  call MatAssemblyEnd  (dRdWT,MAT_FINAL_ASSEMBLY,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)
  call MatAssemblyEnd  (dRdx,MAT_FINAL_ASSEMBLY,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)
  call MatAssemblyEnd(dRda,MAT_FINAL_ASSEMBLY,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)

  ! Let PETSc know that the dRdW matrix retains the same nonzero 
  ! pattern, in case the matrix is assembled again, as for a new
  ! point in the design space.
  call MatSetOption(dRdWT,MAT_NEW_NONZERO_LOCATIONS,PETSC_FALSE,PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)
  call MatSetOption(dRdx,MAT_NEW_NONZERO_LOCATIONS,PETSC_TRUE,PETScIerr)    
  call EChk(PETScIerr,__FILE__,__LINE__)

  ! Get new time and compute the elapsed time.

  call cpu_time(time(2))
  timeAdjLocal = time(2)-time(1)

  ! Determine maximum time using MPI reduce
  ! with operation mpi_max.

  call mpi_reduce(timeAdjLocal, timeAdj, 1, sumb_real, &
       mpi_max, 0, SUMB_PETSC_COMM_WORLD, PETScIerr)
  call EChk(PETScIerr,__FILE__,__LINE__)
  if(myid ==0) &
       write(*,20) "Assembling All Residaul Matrices time (s) = ", timeAdj

  ! Output formats.
#endif

10 format(a)
20 format(a,1x,f8.2)
99 format(a,1x,i6)
 
  !=================================================================

contains

  !===============================================================

  subroutine blockIndices(indexBlock, indexArray)
    !
    !       ****************************************************************
    !       *                                                              *
    !       * blockIndices fill the array containing the block matrix      *
    !       * indices used when assembling the Jacobian matrix with the    *
    !       * PETSc function MatSetValues().                               *
    !       *                                                              *
    !       ****************************************************************
    !
    implicit none
    !
    !       Subroutine arguments.
    !
    integer(kind=intType), intent(in) :: indexBlock
    integer(kind=intType), dimension(nw), intent(out) :: indexArray
    !
    !       Local variables.
    !
    integer(kind=intType) :: idx
    !
    !       ****************************************************************
    !       *                                                              *
    !       * Begin execution.                                             *
    !       *                                                              *
    !       ****************************************************************
    !
    indexArray(1) = indexBlock * nw
    do idx = 2, nw
       indexArray(idx) = indexArray(idx-1) + 1
    enddo

  end subroutine blockIndices
#endif
end subroutine setupAllResidualMatrices

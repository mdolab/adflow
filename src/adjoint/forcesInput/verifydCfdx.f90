!
!     ******************************************************************
!     *                                                                *
!     * File:          verifydCfdx.f90                                 *
!     * Author:        Andre C. Marta, C.A.(Sandy) Mader               *
!     * Starting date: 01-15-2007                                      *
!     * Last modified: 05-08-2008                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine verifydCfdx(level)
!
!     ******************************************************************
!     *                                                                *
!     * Compute all entries in dIdx (partial) using the automatically  *
!     * differentiated routines generated by Tapenade and compare      *
!     * them to the finite-difference results using the modified       *
!     * force routine. This is only executed in debug mode.            *
!     *                                                                *
!     ******************************************************************
!
      use blockPointers
      use cgnsGrid            ! cgnsDoms
      use communication       ! procHalo(currentLevel)%nProcSend, myID
      use inputPhysics        ! equations
      use flowVarRefState     ! nw
      use inputDiscretization ! spaceDiscr, useCompactDiss
      use iteration           ! overset, currentLevel
      use inputTimeSpectral   ! nTimeIntervalsSpectral
      use section
      use monitor             ! monLoc, MonGlob, nMonSum
      use bcTypes             !imin,imax,jmin,jmax,kmin,kmax
      use adjointvars         !ndesignaoa,ndesignmach
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level
!
!     Local variables.
!
      integer(kind=intType) :: discr, nHalo, sps
      integer(kind=intType) :: inode, jnode, knode, mm, nn, m, n,ll
      integer(kind=intType) :: ii, jj, kk, i1, j1, k1, i2, j2, k2

      integer(kind=intType) ::  i2Beg,  i2End,  j2Beg,  j2End
      integer(kind=intType) :: iiBeg, iiEnd, jjBeg, jjEnd
      integer(kind=intType) :: i,j,k,l

      logical :: fineGrid,correctForK, exchangeTurb

      real(kind=realType) :: Cl,Cd,Cfx,Cfy,Cfz,Cmx,Cmy,Cmz
      real(kind=realType) :: ClAdj,CdAdj,CfxAdj,CfyAdj,CfzAdj,&
                             &CmxAdj,CmyAdj,CmzAdj  
      real(kind=realType) :: CLAdjP,CLAdjM,CDAdjP,CDAdjM,dCLdxFD,dCDdxFD,&
                             &dCmxdxFD,CmxAdjP,CmxAdjM
      real(kind=realType) :: ClAdjB,CdAdjB,CfxAdjB,CfyAdjB,CfzAdjB,&
                             &CmxAdjB,CmyAdjB,CmzAdjB 

      real(kind=realType) :: CLP,CLM,CDP,CDM,CmxP,CmxM,CmyP,CmyM,CmzP,CmzM,&
                             &CfxP,CfxM,CfyP,CfyM,CfzP,CfzM

      real(kind=realType), dimension(:,:,:,:), allocatable :: xAdj,xAdjB
      real(kind=realType), dimension(:,:,:,:), allocatable :: wAdj,wAdjB
      real(kind=realType), dimension(:,:,:), allocatable :: pAdj

      real(kind=realType), dimension(3) :: cFpAdj, cFvAdj
      real(kind=realType), dimension(3) :: cMpAdj, cMvAdj

      real(kind=realType), dimension(3) :: cFp, cFv
      real(kind=realType), dimension(3) :: cMp, cMv


      real(kind=realType) :: alphaAdj, betaAdj,MachAdj,machCoefAdj
      real(kind=realType) :: alphaAdjb, betaAdjb,MachAdjb,machCoefAdjb
      REAL(KIND=REALTYPE) :: prefAdj, rhorefAdj,pInfCorrAdj
      REAL(KIND=REALTYPE) :: pinfdimAdj, rhoinfdimAdj
      REAL(KIND=REALTYPE) :: rhoinfAdj, pinfAdj
      REAL(KIND=REALTYPE) :: murefAdj, timerefAdj


      real(kind=realType) :: factI, factJ, factK, tmp

      integer(kind=intType), dimension(0:nProc-1) :: offsetRecv

      real(kind=realType), dimension(4) :: time
      real(kind=realType)               :: timeAdj, timeFD

      ! > derivative output

      real(kind=realType), dimension(:,:,:,:,:), allocatable ::dCL, &
           dCD,dCmx
      real(kind=realType), dimension(:,:,:,:,:), allocatable :: dCLfd, &
           dCDfd,dCmxfd
      real(kind=realType), dimension(:,:,:,:,:), allocatable :: dCLer, &
           dCDer,dCmxer

      real(kind=realType), parameter :: deltax = 1.e-6_realType

      real(kind=realType) :: xAdjRef,xref,alpharef,machref,alpha,beta,machcoefref,rotratexref

      real(kind=realType), dimension(:,:,:), pointer :: norm
      real(kind=realType), dimension(:,:,:),allocatable:: normAdj
      real(kind=realType), dimension(3) :: refPoint
      real(kind=realType) :: yplusMax

      real(kind=realType),  dimension(:), allocatable :: monLoc1, monGlob1
      real(kind=realType),  dimension(:), allocatable :: monLoc2, monGlob2

      logical :: contributeToForce, viscousSubface,secondHalo,righthanded
      real(kind=realType), dimension(6) :: dCldextra,dcddextra,dCldextraFD,dcddextraFD,&
           dCldextraerror,dcddextraerror, dCldextralocal,dcddextralocal,dcmdextra,&
           dcmdextraFD,dcmdextralocal,dcmdextraerror

      REAL(KIND=REALTYPE) :: rotcenteradj(3), rotrateadj(3), rotrateadjb(3)

      real(kind=realType), dimension(nSections) :: t

      integer :: ierr,nmonsum1,nmonsum2,liftindex

!File Parameters
      integer :: unit = 8,ierror
      character(len = 10)::outfile
      
      outfile = "dcfdx.txt"
      
      open (UNIT=unit,File=outfile,status='replace',action='write',iostat=ierror)
      if(ierror /= 0)                        &
           call terminate("verifydCfdx", &
           "Something wrong when &
           &calling open")
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
      print *,'in verifydcfdx'
 !     if( myID==0 ) write(*,*) "Running verifydCfdx...",sps

      ! Set the grid level of the current MG cycle, the value of the
      ! discretization and the logical correctForK.

      currentLevel = level
      discr        = spaceDiscr
      correctForK  = .false.
      fineGrid     = .true.

      ! Determine whether or not the total energy must be corrected
      ! for the presence of the turbulent kinetic energy and whether
      ! or not turbulence variables should be exchanged.

      correctForK  = .false.
      exchangeTurb = .false.
      secondhalo = .true.

      ! Allocate memory for the temporary arrays.

      ie = maxval(flowDoms(:,currentLevel,1)%ie)
      je = maxval(flowDoms(:,currentLevel,1)%je)
      ke = maxval(flowDoms(:,currentLevel,1)%ke)

      allocate(dCL(nDom,0:ie,0:je,0:ke,3), dCLfd(nDom,0:ie,0:je,0:ke,3))
      allocate(dCD(nDom,0:ie,0:je,0:ke,3), dCDfd(nDom,0:ie,0:je,0:ke,3))
      allocate(dCmx(nDom,0:ie,0:je,0:ke,3), dCmxfd(nDom,0:ie,0:je,0:ke,3))
       
      allocate(dCLer(nDom,0:ie,0:je,0:ke,3))
      allocate(dCDer(nDom,0:ie,0:je,0:ke,3))
      allocate(dCmxer(nDom,0:ie,0:je,0:ke,3))

      
      nmonsum1 = 8
      nmonsum2 = 8

      allocate(monLoc1(nmonsum1), monGlob1(nmonsum1))
      allocate(monLoc2(nmonsum2), monGlob2(nmonsum2))

      ! Initialize the temporary arrays.

      dCL   = zero; dCLfd   = zero; dCLer   = zero;
      dCD   = zero; dCDfd   = zero; dCDer   = zero;
      dCmx  = zero; dCmxfd  = zero; dCmxer  = zero;
      dCldextra=zero
      dcddextra=zero

     ! Exchange the pressure if the pressure must be exchanged early.
      ! Only the first halo's are needed, thus whalo1 is called.
      ! Only on the fine grid.
      
      if(exchangePressureEarly .and. currentLevel <= groundLevel) &
           call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
           .false., .false.)
      
      ! Apply all boundary conditions to all blocks on this level.
      
      call applyAllBC(secondHalo)
      
      ! Exchange the solution. Either whalo1 or whalo2
      ! must be called.
      
      if( secondHalo ) then
         call whalo2(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      else
         call whalo1(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      endif

      call mpi_barrier(SUmb_comm_world, ierr)      


      print *,"halo's updated"
!
!     ******************************************************************
!     *                                                                *
!     * Compute the d(forces)/dx (partial) using the tapenade routines.*
!     *                                                                *
!     ******************************************************************
         
!*********************
      !from ForcesAndMoments.f90
       ! Determine the reference point for the moment computation in
       ! meters.
      print *,'setting refpoint'
       refPoint(1) = LRef*pointRef(1)
       refPoint(2) = LRef*pointRef(2)
       refPoint(3) = LRef*pointRef(3)

       ! Initialize the force and moment coefficients to 0 as well as
       ! yplusMax.

!!$       cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$       cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$       cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$       cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
       print *,'zeroing output'
       ClAdj = zero
       CDAdj = zero
       CmxAdj = zero 
       CmyAdj = zero
       CmzAdj = zero
       CfxAdj = zero
       CfyAdj = zero
       CfzAdj = zero

       yplusMax = zero

   !    print *,'Adjoint forces initialized'
!
!***********************************
       print *,' computing adjoint derivatives'
       
   spectralLoop1Adj: do sps=1,nTimeIntervalsSpectral
      
      print *,'zeroing force output'
      !zero the force components
      cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
      cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
      cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
      cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
      ! Loop over the number of local blocks.
      print *,'starting domain loop'
      domainLoop1AD: do nn=1,nDom

        ! Set some pointers to make the code more readable.
         !print *,'setting pointers'
        call setPointersAdj(nn,level,sps)
        !print *,'allocating memory'
        allocate(xAdj(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdj.")

        allocate(xAdjB(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdjB.")
        
        allocate(wAdj(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdj.")

        allocate(wAdjB(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdjB.")
        
        allocate(pAdj(0:ib,0:jb,0:kb), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for pAdj.")
        
        !print *,'finished allocating',nn,level,sps
        righthanded = flowDoms(nn,level,sps)%righthanded
        

        
!!$        nViscBocos = flowDoms(nn,groundLevel,sps)%nViscBocos
!!$        nInvBocos  = flowDoms(nn,groundLevel,sps)%nInvBocos
!!$        
!!$        BCFaceID => flowDoms(nn,groundLevel,  1)%BCFaceID
!!$        groupNum => flowDoms(nn,groundLevel,  1)%groupNum
!!$
!!$        d2Wall   => flowDoms(nn,groundLevel,sps)%d2Wall
!!$        muLam    => flowDoms(nn,groundLevel,sps)%muLam
           
!!$        ! Determine the number of time instances for this block and
!!$        ! store the block dimensions a bit easier.
!!$        
!!$        sectionID = flowDoms(nn,level,1)%sectionID
!!$        nTime     = sections(sectionID)%nTimeInstances
!!$
!!$        print *,'Pointers set',sectionID,nTime
!!$        stop
!!$        
!!$        il = flowDoms(nn,level,1)%il
!!$        jl = flowDoms(nn,level,1)%jl
!!$        kl = flowDoms(nn,level,1)%kl
!!$
!!$        
!!$        !Allocate the full grid stencil for the x
!!$        allocate(xAdj(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("verifydCfdx", &
!!$             "Memory allocation failure for xAdj.")
!!$
!!$        allocate(xAdjB(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("verifydCfdx", &
!!$             "Memory allocation failure for xAdjB.")  
!!$
!!$        !Copy the values of x to the Stencil
!!$        call copyADjointForcesStencil(xAdj,level,nn,sps)

        ! Copy the coordinates into xAdj and
        ! Compute the face normals on the subfaces
        call copyADjointForcesStencil(wAdj,xAdj,alphaAdj,betaAdj,&
             MachAdj,machCoefAdj,prefAdj,rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
             rhoinfAdj, pinfAdj,rotRateAdj,rotCenterAdj,murefAdj, timerefAdj,&
             pInfCorrAdj,nn,level,sps,liftIndex)

        machadjb=zero
        machcoefadjb=zero
        alphaadjb=zero
        betaadjb=zero
        rotrateadjb=zero
        bocoLoop: do mm=1,nBocos

           ! Determine the range of cell indices of the owned cells
           ! Notice these are not the node indices
           iiBeg = BCData(mm)%icBeg
           iiEnd = BCData(mm)%icEnd
           jjBeg = BCData(mm)%jcBeg
           jjEnd = BCData(mm)%jcEnd
           
           i2Beg= BCData(mm)%inBeg+1; i2End = BCData(mm)%inEnd
           j2Beg= BCData(mm)%jnBeg+1; j2End = BCData(mm)%jnEnd
!!$
!!$        !zero the inviscid and viscous force terms 
!!$
!!$        cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$        cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$        cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$        cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$
!!$        ! Count the number of wall boundary conditions
!!$
!!$        nBocos         = nViscBocos + nInvBocos
!!$        viscousSubface = .true. 
!!$
!!$        ! Loop over the number of boundary conditions for this block.
!!$
!!$
!!$        bocoLoop: do mm=1,nBocos
!!$           
!!$           !set some face dimensions
!!$           i2Beg = flowDoms(nn,level,1)%BCData(mm)%iBeg
!!$           j2Beg = flowDoms(nn,level,1)%BCData(mm)%jBeg
!!$           i2End = flowDoms(nn,level,1)%BCData(mm)%iEnd
!!$           j2End = flowDoms(nn,level,1)%BCData(mm)%jEnd
!!$           
!!$           
!!$           select case (flowDoms(nn,level,1)%BCFaceID(mm))
!!$           case (iMin, iMax)
!!$              if(i2End == jl) i2End = min(jl+1,je)
!!$              if(j2End == kl) j2End = min(kl+1,ke)
!!$              
!!$           case (jMin, jMax)
!!$              if(i2End == il) i2End = min(il+1,ie)
!!$              if(j2End == kl) j2End = min(kl+1,ke)
!!$
!!$           case (kMin, kMax)
!!$              if(i2End == il) i2End = min(il+1,ie)
!!$              if(j2End == jl) j2End = min(jl+1,je)
!!$           end select
!!$           
!!$           ! Determine the nodal range of the owned nodes. Due to block
!!$           ! splitting iBeg and jBeg may correspond to a halo.
!!$           iiBeg = max(i2Beg, 1_intType)
!!$           jjBeg = max(j2Beg, 1_intType)
!!$           iiEnd = i2End
!!$           jjEnd = j2End
!!$
!!$           iiBeg = max(i2Beg, 1_intType)
!!$           jjBeg = max(j2Beg, 1_intType)
!!$           iiEnd = min(i2End, flowDoms(nn,level,1)%BCData(mm)%iEnd)
!!$           jjEnd = min(j2End, flowDoms(nn,level,1)%BCData(mm)%jEnd)
!!$
!!$           
!!$           !Allocate the vector of cell normals in the full grid stencil
!!$           allocate(normAdj(iiBeg:iiEnd,jjBeg:jjEnd,3), stat=ierr)
!!$           if(ierr /= 0)                              &
!!$                call terminate("verifydCfdx", &
!!$                "Memory allocation failure for normAdj.")
           
           ! Initialize the seed for reverse mode. Cl is the first one
           ClAdjB = 1
           CDAdjB = 0
           CmxAdjB = 0
           CmyAdjB = 0
           CmzAdjB = 0
!!$        CfxAdjB = 0
!!$        CfyAdjB = 0
!!$        CfzAdjB = 0
           
           xAdjB(:,:,:,:) = zero ! > return dCf/dx
           
           
           !===============================================================
           !           
!           print *,'Initial Parameters Calculated,Computing Lift Partials...'
           
           !===============================================================
           ! Compute the force derivatives
                     
           call COMPUTEFORCESADJ_B(xadj, xadjb, wadj, wadjb, padj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, cfxadj, cfyadj, &
&  cfzadj, cmxadj, cmxadjb, cmyadj, cmyadjb, cmzadj, cmzadjb, yplusmax, &
&  refpoint, cladj, cladjb, cdadj, cdadjb, nn, level, sps, cfpadj, &
&  cmpadj, righthanded, secondhalo, alphaadj, alphaadjb, betaadj, &
&  betaadjb, machadj, machadjb, machcoefadj, machcoefadjb, prefadj, &
&  rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, murefadj, &
&  timerefadj, pinfcorradj, rotcenteradj, rotrateadj, rotrateadjb, &
&  liftindex)

           
           
           !loop over cells to store the jacobian
           do k = 0,ke
              do j = 0,je
                 do i = 0,ie
                    
                    ! Store the dervatives for comparison.
                   
                    dCL(nn,i,j,k,:)=dCL(nn,i,j,k,:)+& 
                         & xAdjB( i,j,k,:)


                 enddo
              enddo
           enddo

          
        end do bocoLoop
        dCldextralocal(ndesignmach) =dCldextralocal(ndesignmach)+ machadjb+machcoefadjb
        dCldextralocal(ndesignaoa) = dCldextralocal(ndesignaoa)+alphaadjb
        dCldextralocal(ndesignssa) = dCldextralocal(ndesignssa)+betaadjb
        dCldextralocal(ndesignrotx) = dCldextralocal(ndesignrotx)+rotrateadjb(1)
        dCldextralocal(ndesignroty) = dCldextralocal(ndesignroty)+rotrateadjb(2)
        dCldextralocal(ndesignrotz) = dCldextralocal(ndesignrotz)+rotrateadjb(3)
        !dCldextra(ndesignmach) = machadjb+machcoefadjb
        !!dCldextra(ndesignmach) = dCldextra(ndesignmach)+machadjb+machcoefadjb
        !print *,'ADcdldmach2', dCldextra(ndesignmach),machadjb,machcoefadjb
        !dCldextra(ndesignaoa) = dCldextra(ndesignaoa)+alphaadjb
        !dCldextra(ndesignssa) = dCldextra(ndesignssa)+betaadjb

       !===============================================================
        
        !print *,' deallocating'
        ! Deallocate the xAdj.
        deallocate(pAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.")
             
        ! Deallocate the xAdj.
        deallocate(wAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(wAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        ! Deallocate the xAdj.
        deallocate(xAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(xAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        !print *,'finishhed deallocating'
       
     enddo domainLoop1AD
      
      print *,'dcldextralocal',dcldextralocal(1),dcldextralocal(2),dcldextralocal(3)
      monLoc2(1) = dcldextralocal(1)
      monLoc2(2) = dcldextralocal(2)
      monLoc2(3) = dcldextralocal(3)
      monLoc2(4) = dcldextralocal(4)
      monLoc2(5) = dcldextralocal(5)
      monLoc2(6) = dcldextralocal(6)
      monLoc2(7) = 1!dcddextralocal(1)
      monLoc2(8) = 1!dcddextralocal(2)
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
!         write(*,*)'adj ',myID,monLoc2(1)
         !write(*,*)'nmonsum',nMonSum
         call mpi_allreduce(monLoc2, monGlob2, nMonSum2, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         dcldextra(1) = monGlob2(1)
         dcldextra(2) = monGlob2(2)
         dcldextra(3) = monGlob2(3)
         dcldextra(4) = monGlob2(4)
         dcldextra(5) = monGlob2(5) 
         dcldextra(6) = monGlob2(6)
         !dcddextra(1) = monGlob2(7)
         !dcddextra(2) = monGlob2(8)

      enddo spectralLoop1Adj

!****************************
!Drag loop
!*************************
       print *,'zeroing output'
       ClAdj = zero
       CDAdj = zero
       CmxAdj = zero 
       CmyAdj = zero
       CmzAdj = zero
       CfxAdj = zero
       CfyAdj = zero
       CfzAdj = zero

       yplusMax = zero

   !    print *,'Adjoint forces initialized'
!
!***********************************
       print *,' computing adjoint derivatives'
       
   spectralLoopAdj2: do sps=1,nTimeIntervalsSpectral
      
      print *,'zeroing force output'
      !zero the force components
      cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
      cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
      cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
      cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
      ! Loop over the number of local blocks.
      print *,'starting domain loop'
      domainLoopAD2: do nn=1,nDom

        ! Set some pointers to make the code more readable.
         !print *,'setting pointers'
        call setPointersAdj(nn,level,sps)
        !print *,'allocating memory'
        allocate(xAdj(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdj.")

        allocate(xAdjB(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdjB.")
        
        allocate(wAdj(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdj.")

        allocate(wAdjB(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdjB.")
        
        allocate(pAdj(0:ib,0:jb,0:kb), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for pAdj.")
        
        !print *,'finished allocating',nn,level,sps
        righthanded = flowDoms(nn,level,sps)%righthanded
        

        
!!$        nViscBocos = flowDoms(nn,groundLevel,sps)%nViscBocos
!!$        nInvBocos  = flowDoms(nn,groundLevel,sps)%nInvBocos
!!$        
!!$        BCFaceID => flowDoms(nn,groundLevel,  1)%BCFaceID
!!$        groupNum => flowDoms(nn,groundLevel,  1)%groupNum
!!$
!!$        d2Wall   => flowDoms(nn,groundLevel,sps)%d2Wall
!!$        muLam    => flowDoms(nn,groundLevel,sps)%muLam
           
!!$        ! Determine the number of time instances for this block and
!!$        ! store the block dimensions a bit easier.
!!$        
!!$        sectionID = flowDoms(nn,level,1)%sectionID
!!$        nTime     = sections(sectionID)%nTimeInstances
!!$
!!$        print *,'Pointers set',sectionID,nTime
!!$        stop
!!$        
!!$        il = flowDoms(nn,level,1)%il
!!$        jl = flowDoms(nn,level,1)%jl
!!$        kl = flowDoms(nn,level,1)%kl
!!$
!!$        
!!$        !Allocate the full grid stencil for the x
!!$        allocate(xAdj(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("verifydCfdx", &
!!$             "Memory allocation failure for xAdj.")
!!$
!!$        allocate(xAdjB(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("verifydCfdx", &
!!$             "Memory allocation failure for xAdjB.")  
!!$
!!$        !Copy the values of x to the Stencil
!!$        call copyADjointForcesStencil(xAdj,level,nn,sps)

        ! Copy the coordinates into xAdj and
        ! Compute the face normals on the subfaces
        call copyADjointForcesStencil(wAdj,xAdj,alphaAdj,betaAdj,&
             MachAdj,machCoefAdj,prefAdj,rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
             rhoinfAdj, pinfAdj,rotRateAdj,rotCenterAdj,murefAdj, timerefAdj,&
             pInfCorrAdj,nn,level,sps,liftIndex)

        machadjb=zero
        machcoefadjb=zero
        alphaadjb=zero
        betaadjb=zero
        rotrateadjb=zero
        bocoLoop2: do mm=1,nBocos

           ! Determine the range of cell indices of the owned cells
           ! Notice these are not the node indices
           iiBeg = BCData(mm)%icBeg
           iiEnd = BCData(mm)%icEnd
           jjBeg = BCData(mm)%jcBeg
           jjEnd = BCData(mm)%jcEnd
           
           i2Beg= BCData(mm)%inBeg+1; i2End = BCData(mm)%inEnd
           j2Beg= BCData(mm)%jnBeg+1; j2End = BCData(mm)%jnEnd

           ! Initialize the seed for reverse mode. Cd second
           ClAdjB = 0
           CDAdjB = 1
           CmxAdjB = 0
           CmyAdjB = 0
           CmzAdjB = 0
!!$        CfxAdjB = 0
!!$        CfyAdjB = 0
!!$        CfzAdjB = 0
       
           xAdjB(:,:,:,:) = zero ! > return dCf/dx
           
           !===============================================================
           !           
!           print *,'Calculating Drag Partials...'
           
           !===============================================================
           ! Compute the force derivatives
           
           call COMPUTEFORCESADJ_B(xadj, xadjb, wadj, wadjb, padj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, cfxadj, cfyadj, &
&  cfzadj, cmxadj, cmxadjb, cmyadj, cmyadjb, cmzadj, cmzadjb, yplusmax, &
&  refpoint, cladj, cladjb, cdadj, cdadjb, nn, level, sps, cfpadj, &
&  cmpadj, righthanded, secondhalo, alphaadj, alphaadjb, betaadj, &
&  betaadjb, machadj, machadjb, machcoefadj, machcoefadjb, prefadj, &
&  rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, murefadj, &
&  timerefadj, pinfcorradj, rotcenteradj, rotrateadj, rotrateadjb, &
&  liftindex)
           
           
           !loop over cells to store the jacobian
           do k = 0,ke
              do j = 0,je
                 do i = 0,ie
                    
                    ! Store the derivatives for comparison.
                    
                    dCD(nn,i,j,k,:)=dCD(nn,i,j,k,:)+& 
                         & xAdjB( i,j,k,:)

                 enddo
              enddo
           enddo
           

        enddo bocoLoop2
        dCddextralocal(ndesignmach) = dCddextralocal(ndesignmach)+machadjb+machcoefadjb
        dCddextralocal(ndesignaoa) = dCddextralocal(ndesignaoa)+alphaadjb
        dCddextralocal(ndesignssa) = dCddextralocal(ndesignssa)+betaadjb
        dCddextralocal(ndesignrotx) = dCddextralocal(ndesignrotx)+rotrateadjb(1)
        dCddextralocal(ndesignroty) = dCddextralocal(ndesignroty)+rotrateadjb(2)
        dCddextralocal(ndesignrotz) = dCddextralocal(ndesignrotz)+rotrateadjb(3)

       !===============================================================
        
        !print *,' deallocating'
        ! Deallocate the xAdj.
        deallocate(pAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.")
             
        ! Deallocate the xAdj.
        deallocate(wAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(wAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        ! Deallocate the xAdj.
        deallocate(xAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(xAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        !print *,'finishhed deallocating'
       
     enddo domainLoopAD2
      
      print *,'dcddextralocal',dcddextralocal(1),dcddextralocal(2),dcddextralocal(3)
      monLoc2(1) = dcddextralocal(1)
      monLoc2(2) = dcddextralocal(2)
      monLoc2(3) = dcddextralocal(3)
      monLoc2(4) = dcddextralocal(4)
      monLoc2(5) = dcddextralocal(5)
      monLoc2(6) = dcddextralocal(6)
      monLoc2(7) = 1!dcddextralocal(1)
      monLoc2(8) = 1!dcddextralocal(2)
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
!         write(*,*)'adj ',myID,monLoc2(1)
         !write(*,*)'nmonsum',nMonSum
         call mpi_allreduce(monLoc2, monGlob2, nMonSum2, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         dcddextra(1) = monGlob2(1)
         dcddextra(2) = monGlob2(2)
         dcddextra(3) = monGlob2(3)
         dcddextra(4) = monGlob2(4)
         dcddextra(5) = monGlob2(5) 
         dcddextra(6) = monGlob2(6)
         !dcddextra(1) = monGlob2(7)
         !dcddextra(2) = monGlob2(8)

      enddo spectralLoopAdj2


!*******************
!cmxloop
!*******************

       print *,'zeroing output'
       ClAdj = zero
       CDAdj = zero
       CmxAdj = zero 
       CmyAdj = zero
       CmzAdj = zero
       CfxAdj = zero
       CfyAdj = zero
       CfzAdj = zero

       yplusMax = zero

   !    print *,'Adjoint forces initialized'
!
!***********************************
       print *,' computing adjoint derivatives'
       
   spectralLoopAdj3: do sps=1,nTimeIntervalsSpectral
      
      print *,'zeroing force output'
      !zero the force components
      cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
      cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
      cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
      cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
      ! Loop over the number of local blocks.
      print *,'starting domain loop'
      domainLoopAD3: do nn=1,nDom

        ! Set some pointers to make the code more readable.
         !print *,'setting pointers'
        call setPointersAdj(nn,level,sps)
        !print *,'allocating memory'
        allocate(xAdj(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdj.")

        allocate(xAdjB(0:ie,0:je,0:ke,3), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for xAdjB.")
        
        allocate(wAdj(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdj.")

        allocate(wAdjB(0:ib,0:jb,0:kb,nw), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for wAdjB.")
        
        allocate(pAdj(0:ib,0:jb,0:kb), stat=ierr)
        if(ierr /= 0)                              &
             call terminate("Memory allocation failure for pAdj.")
        
        !print *,'finished allocating',nn,level,sps
        righthanded = flowDoms(nn,level,sps)%righthanded

        ! Copy the coordinates into xAdj and
        ! Compute the face normals on the subfaces
        call copyADjointForcesStencil(wAdj,xAdj,alphaAdj,betaAdj,&
             MachAdj,machCoefAdj,prefAdj,rhorefAdj, pinfdimAdj, rhoinfdimAdj,&
             rhoinfAdj, pinfAdj,rotRateAdj,rotCenterAdj,murefAdj, timerefAdj,&
             pInfCorrAdj,nn,level,sps,liftIndex)

        machadjb=zero
        machcoefadjb=zero
        alphaadjb=zero
        betaadjb=zero
        rotrateadjb=zero
        bocoLoop3: do mm=1,nBocos

           ! Determine the range of cell indices of the owned cells
           ! Notice these are not the node indices
           iiBeg = BCData(mm)%icBeg
           iiEnd = BCData(mm)%icEnd
           jjBeg = BCData(mm)%jcBeg
           jjEnd = BCData(mm)%jcEnd
           
           i2Beg= BCData(mm)%inBeg+1; i2End = BCData(mm)%inEnd
           j2Beg= BCData(mm)%jnBeg+1; j2End = BCData(mm)%jnEnd

           ! Initialize the seed for reverse mode. Cmx third
           ClAdjB = 0
           CDAdjB = 0
           CmxAdjB = 1
           CmyAdjB = 0
           CmzAdjB = 0
 !       CfxAdjB = 0
 !       CfyAdjB = 0
 !       CfzAdjB = 0
       
           xAdjB(:,:,:,:) = zero ! > return dCf/dx
           
           !===============================================================
           !           
!           print *,'Calculating MomX Partials...'
           
           !===============================================================
           ! Compute the force derivatives
           
           call COMPUTEFORCESADJ_B(xadj, xadjb, wadj, wadjb, padj, iibeg, &
&  iiend, jjbeg, jjend, i2beg, i2end, j2beg, j2end, mm, cfxadj, cfyadj, &
&  cfzadj, cmxadj, cmxadjb, cmyadj, cmyadjb, cmzadj, cmzadjb, yplusmax, &
&  refpoint, cladj, cladjb, cdadj, cdadjb, nn, level, sps, cfpadj, &
&  cmpadj, righthanded, secondhalo, alphaadj, alphaadjb, betaadj, &
&  betaadjb, machadj, machadjb, machcoefadj, machcoefadjb, prefadj, &
&  rhorefadj, pinfdimadj, rhoinfdimadj, rhoinfadj, pinfadj, murefadj, &
&  timerefadj, pinfcorradj, rotcenteradj, rotrateadj, rotrateadjb, &
&  liftindex)


           
           !loop over cells to store the jacobian
           do k = 0,ke
              do j = 0,je
                 do i = 0,ie
                    
                    ! Store the derivatives for comparison.
                   

                    dCMx(nn,i,j,k,:)=dCMx(nn,i,j,k,:)+& 
                         & xAdjB( i,j,k,:)
                    
                 enddo
              enddo
           enddo
!!$                     
!!$           deallocate(normAdj, stat=ierr)
!!$           if(ierr /= 0)                              &
!!$                call terminate("verifydCfdx", &
!!$                "Deallocation failure for normAdj.") 
           
        enddo bocoLoop3
        dCmdextralocal(ndesignmach) = dCmdextralocal(ndesignmach)+machadjb+machcoefadjb
        dCmdextralocal(ndesignaoa) = dCmdextralocal(ndesignaoa)+alphaadjb
        dCmdextralocal(ndesignssa) = dCmdextralocal(ndesignssa)+betaadjb
        dCmdextralocal(ndesignrotx) = dCmdextralocal(ndesignrotx)+rotrateadjb(1)
        dCmdextralocal(ndesignroty) = dCmdextralocal(ndesignroty)+rotrateadjb(2)
        dCmdextralocal(ndesignrotz) = dCmdextralocal(ndesignrotz)+rotrateadjb(3)
        
        !===============================================================
        
        !print *,' deallocating'
        ! Deallocate the xAdj.
        deallocate(pAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.")
             
        ! Deallocate the xAdj.
        deallocate(wAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(wAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        ! Deallocate the xAdj.
        deallocate(xAdj, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 

         deallocate(xAdjB, stat=ierr)
        if(ierr /= 0)                              &
             call terminate("verifydCfdx", &
             "Deallocation failure for xAdj.") 
        !print *,'finishhed deallocating'
       
     enddo domainLoopAD3
      
      print *,'dcldextralocal',dcmdextralocal(1),dcmdextralocal(2),dcmdextralocal(3)
      monLoc2(1) = dcmdextralocal(1)
      monLoc2(2) = dcmdextralocal(2)
      monLoc2(3) = dcmdextralocal(3)
      monLoc2(4) = dcmdextralocal(4)
      monLoc2(5) = dcmdextralocal(5)
      monLoc2(6) = dcmdextralocal(6)
      monLoc2(7) = 1!dcddextralocal(1)
      monLoc2(8) = 1!dcddextralocal(2)
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
!         write(*,*)'adj ',myID,monLoc2(1)
         !write(*,*)'nmonsum',nMonSum
         call mpi_allreduce(monLoc2, monGlob2, nMonSum2, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         dcmdextra(1) = monGlob2(1)
         dcmdextra(2) = monGlob2(2)
         dcmdextra(3) = monGlob2(3)
         dcmdextra(4) = monGlob2(4)
         dcmdextra(5) = monGlob2(5) 
         dcmdextra(6) = monGlob2(6)
         !dcmdextra(1) = monGlob2(7)
         !dcmdextra(2) = monGlob2(8)

      enddo spectralLoopAdj3


      
   print *,'AD loop finished'
      ! Get new time and compute the elapsed AD time.

      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) then
        call cpu_time(time(2))
        timeAdj = time(2)-time(1)
      endif
!
!     ******************************************************************
!     *                                                                *
!     * Compute d(Cf)/d(x) using central finite-differences.           *
!     *                                                                *
!     ******************************************************************
!
      ! Get the initial FD time.
      
      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) call cpu_time(time(3))

!version using original routines!
      ! Loop over the number of local blocks.
      
      sps=1
      print *,'starting FD loop',sps
      domainForcesLoopFDorig: do nn=1,nDom   
         print *,'fd in domain',nn
         !cycle
         call setPointers(nn,level,sps)

         !loop over all points

         do i = 0,ie
            print *,'i',i
            do j = 0,je
               do k = 0,ke
                  do l = 1,3
                     xref = x(i,j,k,l)

                     x(i,j,k,l) = xref+deltax

                     !*************************************************************
                     !Original force and metric calculation....
                     !     ******************************************************************
                     !     *                                                                *
                     !     * Update the force coefficients using the usual flow solver      *
                     !     * routine.                                                       *
                     !     *                                                                *
                     !     ******************************************************************
                     !
 
                     call metric(level)
                     call setPointers(nn,level,sps)
                     call computeForcesPressureAdj(w,p)
                     call applyAllBC(secondHalo)
                     call setPointers(nn,level,sps)
                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
                     
                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
                          + (cfp(2) + cfv(2))*liftDirection(2) &
                          + (cfp(3) + cfv(3))*liftDirection(3)
                     
                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
                          + (cfp(2) + cfv(2))*dragDirection(2) &
                          + (cfp(3) + cfv(3))*dragDirection(3)
                     
                     Cfx = cfp(1) + cfv(1)
                     Cfy = cfp(2) + cfv(2)
                     Cfz = cfp(3) + cfv(3)
                     
                     Cmx = cmp(1) + cmv(1)
                     Cmy = cmp(2) + cmv(2)
                     Cmz = cmp(3) + cmv(3)
                     
                     nmonsum = 8
                     
                     monLoc1(1) = Cl
                     monLoc1(2) = Cd
                     monLoc1(3) = cfx
                     monLoc1(4) = cfy
                     monLoc1(5) = cfz
                     monLoc1(6) = cmx
                     monLoc1(7) = cmy
                     monLoc1(8) = cmz
                     
!!$!                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax, sps)
!!$!                     
!!$!                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$!                          + (cfp(2) + cfv(2))*liftDirection(2) &
!!$!                          + (cfp(3) + cfv(3))*liftDirection(3)
!!$!                     
!!$!                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$!                          + (cfp(2) + cfv(2))*dragDirection(2) &
!!$!                          + (cfp(3) + cfv(3))*dragDirection(3)
!!$!                     
!!$!                     Cfx = cfp(1) + cfv(1)
!!$!                     Cfy = cfp(2) + cfv(2)
!!$!                     Cfz = cfp(3) + cfv(3)
!!$!                     
!!$!                     Cmx = cmp(1) + cmv(1)
!!$!                     Cmy = cmp(2) + cmv(2)
!!$!                     Cmz = cmp(3) + cmv(3)
!!$!                     
!!$!                     nmonsum = 8
!!$!                     
!!$!                     monLoc(1) = Cl
!!$!                     monLoc(2) = Cd
!!$!                     monLoc(3) = cfx
!!$!                     monLoc(4) = cfy
!!$!                     monLoc(5) = cfz
!!$!                     monLoc(6) = cmx
!!$!                     monLoc(7) = cmy
!!$!                     monLoc(8) = cmz
!!$!                     
                     
                     ! Determine the global sum of the summation monitoring
                     ! variables. The sum is made known to all processors.
                     
                     call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
                          mpi_sum, SUmb_comm_world, ierr)
                     
                     ! Transfer the cost function values to output arguments.
                     
                     CLp  = monGlob1(1)
                     CDp  = monGlob1(2)
                     Cfxp = monGlob1(3)
                     Cfyp = monGlob1(4)
                     Cfzp = monGlob1(5) 
                     CMxp = monGlob1(6)
                     CMyp = monGlob1(7)
                     CMzp = monGlob1(8)
                     
                     
                     !*********************
                     !Now calculate other perturbation
                     x(i,j,k,l) = xref-deltax
                     
                     !*************************************************************
                     !Original force and metric calculation....
                     !     ******************************************************************
                     !     *                                                                *
                     !     * Update the force coefficients using the usual flow solver      *
                     !     * routine.                                                       *
                     !     *                                                                *
                     !     ******************************************************************
                     !
  
                     call metric(level)
                     call setPointers(nn,level,sps)
                     call computeForcesPressureAdj(w,p)
                     call applyAllBC(secondHalo)
                     call setPointers(nn,level,sps)
                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
                     
                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
                          + (cfp(2) + cfv(2))*liftDirection(2) &
                          + (cfp(3) + cfv(3))*liftDirection(3)
                     
                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
                          + (cfp(2) + cfv(2))*dragDirection(2) &
                          + (cfp(3) + cfv(3))*dragDirection(3)
                     
                     Cfx = cfp(1) + cfv(1)
                     Cfy = cfp(2) + cfv(2)
                     Cfz = cfp(3) + cfv(3)
                     
                     Cmx = cmp(1) + cmv(1)
                     Cmy = cmp(2) + cmv(2)
                     Cmz = cmp(3) + cmv(3)
                     
                     nmonsum = 8
                     
                     monLoc2(1) = Cl
                     monLoc2(2) = Cd
                     monLoc2(3) = cfx
                     monLoc2(4) = cfy
                     monLoc2(5) = cfz
                     monLoc2(6) = cmx
                     monLoc2(7) = cmy
                     monLoc2(8) = cmz
                  
!!$!                     call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax, sps)
!!$!                     
!!$!                     Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$!                          + (cfp(2) + cfv(2))*liftDirection(2) &
!!$!                          + (cfp(3) + cfv(3))*liftDirection(3)
!!$!                     
!!$!                     Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$!                          + (cfp(2) + cfv(2))*dragDirection(2) &
!!$!                          + (cfp(3) + cfv(3))*dragDirection(3)
!!$!                     
!!$!                     Cfx = cfp(1) + cfv(1)
!!$!                     Cfy = cfp(2) + cfv(2)
!!$!                     Cfz = cfp(3) + cfv(3)
!!$!                     
!!$!                     Cmx = cmp(1) + cmv(1)
!!$!                     Cmy = cmp(2) + cmv(2)
!!$!                     Cmz = cmp(3) + cmv(3)
!!$!                     
!!$!                     nmonsum = 8
!!$!                     
!!$!                     monLoc(1) = Cl
!!$!                     monLoc(2) = Cd
!!$!                     monLoc(3) = cfx
!!$!                     monLoc(4) = cfy
!!$!                     monLoc(5) = cfz
!!$!                     monLoc(6) = cmx
!!$!                     monLoc(7) = cmy
!!$!                     monLoc(8) = cmz
                     
                     
                     ! Determine the global sum of the summation monitoring
                     ! variables. The sum is made known to all processors.
                     
                     call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
                          mpi_sum, SUmb_comm_world, ierr)
                     
                     ! Transfer the cost function values to output arguments.
                     
                     CLm  = monGlob2(1)
                     CDm  = monGlob2(2)
                     Cfxm = monGlob2(3)
                     Cfym = monGlob2(4)
                     Cfzm = monGlob2(5) 
                     CMxm = monGlob2(6)
                     CMym = monGlob2(7)
                     CMzm = monGlob2(8)
                     
                     
                     x(i,j,k,l) = xref
                  

                     dCLdxFD = (CLP-CLM)/(two*deltax)  
                    dCDdxFD = (CDP-CDM)/(two*deltax) 
                    dCmxdxFD = (CmxP-CmxM)/(two*deltax) 

                    dCLFD(nn,i,j,k,l)=dCLdxFD

                    dCDFD(nn,i,j,k,l)=dCDdxFD
                    
                    dCmxFD(nn,i,j,k,l)=dCmxdxFD
                    write (unit,*) dCLdxFD,i,j,k,l
                    
                    enddo
                 enddo
              enddo
           enddo
        enddo domainForcesLoopFDorig

      ! Loop over the number of local blocks.
      
        monloc1=0.0
        monloc2=0.0
      sps=1
      print *,'starting FD loop',sps
      domainMachLoopFDorig: do nn=1,nDom   
         
         call setPointers(nn,level,sps)

         !loop over all points
         
         machref = mach
         machcoefref=machcoef
         !print *,'mach before',mach,machcoef
         mach= machref+deltax
         machcoef = machcoefref+deltax
         !print *,'mach after',mach,machcoef
         !*************************************************************
         !Original force and metric calculation....
         !     ******************************************************************
         !     *                                                                *
         !     * Update the force coefficients using the usual flow solver      *
         !     * routine.                                                       *
         !     *                                                                *
         !     ******************************************************************
         !
 
         call metric(level)
         call setPointers(nn,level,sps)
         call computeForcesPressureAdj(w,p)
         call applyAllBC(secondHalo)
         call setPointers(nn,level,sps)
         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
         
         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
              + (cfp(2) + cfv(2))*liftDirection(2) &
              + (cfp(3) + cfv(3))*liftDirection(3)
         
         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
              + (cfp(2) + cfv(2))*dragDirection(2) &
              + (cfp(3) + cfv(3))*dragDirection(3)
         
         Cfx = cfp(1) + cfv(1)
         Cfy = cfp(2) + cfv(2)
         Cfz = cfp(3) + cfv(3)
         
         Cmx = cmp(1) + cmv(1)
         Cmy = cmp(2) + cmv(2)
         Cmz = cmp(3) + cmv(3)
         
         nmonsum = 8
         
         monLoc1(1) =monLoc1(1) + Cl
         monLoc1(2) =monLoc1(2)+ Cd
         monLoc1(3) =monLoc1(3)+ cfx
         monLoc1(4) =monLoc1(4) +cfy
         monLoc1(5) =monLoc1(5) +cfz
         monLoc1(6) =monLoc1(6) +cmx
         monLoc1(7) = monLoc1(7)+ cmy
         monLoc1(8) = monLoc1(8)+cmz
         
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
         
         call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         CLp  = monGlob1(1)
         CDp  = monGlob1(2)
         Cfxp = monGlob1(3)
         Cfyp = monGlob1(4)
         Cfzp = monGlob1(5) 
         CMxp = monGlob1(6)
         CMyp = monGlob1(7)
         CMzp = monGlob1(8)
         
         
         !*********************
         !Now calculate other perturbation
         mach = machref-deltax
         machcoef = machcoefref-deltax
         !*************************************************************
         !Original force and metric calculation....
         !     ******************************************************************
         !     *                                                                *
         !     * Update the force coefficients using the usual flow solver      *
         !     * routine.                                                       *
         !     *                                                                *
         !     ******************************************************************
         !
         
         call metric(level)
         call setPointers(nn,level,sps)
         call computeForcesPressureAdj(w,p)
         call applyAllBC(secondHalo)
         call setPointers(nn,level,sps)
         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
                     
         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
              + (cfp(2) + cfv(2))*liftDirection(2) &
              + (cfp(3) + cfv(3))*liftDirection(3)
         
         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
              + (cfp(2) + cfv(2))*dragDirection(2) &
              + (cfp(3) + cfv(3))*dragDirection(3)
         
         Cfx = cfp(1) + cfv(1)
         Cfy = cfp(2) + cfv(2)
         Cfz = cfp(3) + cfv(3)
         
         Cmx = cmp(1) + cmv(1)
         Cmy = cmp(2) + cmv(2)
         Cmz = cmp(3) + cmv(3)
         
         nmonsum = 8
         
         monLoc2(1) = monLoc2(1)+Cl
         monLoc2(2) = monLoc2(2)+Cd
         monLoc2(3) = monLoc2(3)+cfx
         monLoc2(4) = monLoc2(4)+cfy
         monLoc2(5) = monLoc2(5)+cfz
         monLoc2(6) = monLoc2(6)+cmx
         monLoc2(7) = monLoc2(7)+cmy
         monLoc2(8) = monLoc2(8)+cmz
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
         
         call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         CLm  = monGlob2(1)
         CDm  = monGlob2(2)
         Cfxm = monGlob2(3)
         Cfym = monGlob2(4)
         Cfzm = monGlob2(5) 
         CMxm = monGlob2(6)
         CMym = monGlob2(7)
         CMzm = monGlob2(8)
         
         
         mach = machref
         machcoef = machcoefref
         !print *,'clp',CLP,CLM,CLP-CLM
         dCLdextraFD(ndesignmach) = (CLP-CLM)/(two*deltax)  
         dCDdextraFD(ndesignmach) = (CDP-CDM)/(two*deltax) 
         dcmdextrafd(ndesignmach) = (cmxp-cmxm)/(two*deltax)
         !dCmxdxFD = (CmxP-CmxM)/(two*deltax) 
        
      enddo domainMachLoopFDorig
     

      !get reference conditions
      call getDirAngle(velDirFreestream,liftDirection,liftIndex,alpha,beta)
      monloc1=0.0
      monloc2=0.0
      
      sps=1
      print *,'starting FD loop',sps
      domainalphaLoopFDorig: do nn=1,nDom   
         
         call setPointers(nn,level,sps)

         !loop over all points
         alpharef = alpha
         
         alpha = alpharef+deltax
         
         !*************************************************************
         !Original force and metric calculation....
         !     ******************************************************************
         !     *                                                                *
         !     * Update the force coefficients using the usual flow solver      *
         !     * routine.                                                       *
         !     *                                                                *
         !     ******************************************************************
         !
         call adjustinflowangleadj(alpha,beta,veldirfreestream,liftdirection,dragdirection,liftindex)
         call metric(level)
         call setPointers(nn,level,sps)
         call computeForcesPressureAdj(w,p)
         call applyAllBC(secondHalo)
         call setPointers(nn,level,sps)
         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
         
         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
              + (cfp(2) + cfv(2))*liftDirection(2) &
              + (cfp(3) + cfv(3))*liftDirection(3)
         
         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
              + (cfp(2) + cfv(2))*dragDirection(2) &
              + (cfp(3) + cfv(3))*dragDirection(3)
         
         Cfx = cfp(1) + cfv(1)
         Cfy = cfp(2) + cfv(2)
         Cfz = cfp(3) + cfv(3)
         
         Cmx = cmp(1) + cmv(1)
         Cmy = cmp(2) + cmv(2)
         Cmz = cmp(3) + cmv(3)
         
         nmonsum = 8
         
         monLoc1(1) = monLoc1(1)+Cl
         monLoc1(2) = monLoc1(2)+Cd
         monLoc1(3) = monLoc1(3)+ cfx
         monLoc1(4) = monLoc1(4)+ cfy
         monLoc1(5) = monLoc1(5)+ cfz
         monLoc1(6) = monLoc1(6)+cmx
         monLoc1(7) = monLoc1(7)+cmy
         monLoc1(8) = monLoc1(8)+cmz
         
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
         
         call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         CLp  = monGlob1(1)
         CDp  = monGlob1(2)
         Cfxp = monGlob1(3)
         Cfyp = monGlob1(4)
         Cfzp = monGlob1(5) 
         CMxp = monGlob1(6)
         CMyp = monGlob1(7)
         CMzp = monGlob1(8)
                     
         
         !*********************
         !Now calculate other perturbation
         alpha = alpharef-deltax
                     
         !*************************************************************
         !Original force and metric calculation....
         !     ******************************************************************
         !     *                                                                *
         !     * Update the force coefficients using the usual flow solver      *
         !     * routine.                                                       *
         !     *                                                                *
         !     ******************************************************************
         !
         
         call adjustinflowangleadj(alpha,beta,veldirfreestream,liftdirection,dragdirection,liftindex)
         call metric(level)
         call setPointers(nn,level,sps)
         call computeForcesPressureAdj(w,p)
         call applyAllBC(secondHalo)
         call setPointers(nn,level,sps)
         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
         
         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
              + (cfp(2) + cfv(2))*liftDirection(2) &
              + (cfp(3) + cfv(3))*liftDirection(3)
         
         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
              + (cfp(2) + cfv(2))*dragDirection(2) &
              + (cfp(3) + cfv(3))*dragDirection(3)
         
         Cfx = cfp(1) + cfv(1)
         Cfy = cfp(2) + cfv(2)
         Cfz = cfp(3) + cfv(3)
         
         Cmx = cmp(1) + cmv(1)
         Cmy = cmp(2) + cmv(2)
         Cmz = cmp(3) + cmv(3)
         
         nmonsum = 8
         
         monLoc2(1) = monLoc2(1)+Cl
         monLoc2(2) = monLoc2(2)+Cd
         monLoc2(3) = monLoc2(3)+cfx
         monLoc2(4) = monLoc2(4)+ cfy
         monLoc2(5) = monLoc2(5)+cfz
         monLoc2(6) =monLoc2(6) +cmx
         monLoc2(7) =monLoc2(7) +cmy
         monLoc2(8) = monLoc2(8)+cmz
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
         
         call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         CLm  = monGlob2(1)
         CDm  = monGlob2(2)
         Cfxm = monGlob2(3)
         Cfym = monGlob2(4)
         Cfzm = monGlob2(5) 
         CMxm = monGlob2(6)
         CMym = monGlob2(7)
         CMzm = monGlob2(8)
         
         
         alpha = alpharef
                  
         call adjustinflowangleadj(alpha,beta,veldirfreestream,liftdirection,dragdirection,liftindex)

         dCLdextraFD(ndesignaoa) = (CLP-CLM)/(two*deltax)  
         dCDdextraFD(ndesignaoa) = (CDP-CDM)/(two*deltax) 
         dcmdextrafd(ndesignaoa) = (cmxp-cmxm)/(two*deltax)
         !dCmxdxFD = (CmxP-CmxM)/(two*deltax) 

      enddo domainalphaLoopFDorig


      ! Loop over the number of local blocks.
      
        monloc1=0.0
        monloc2=0.0
      sps=1
      print *,'starting FD loop',sps
      domainrotxLoopFDorig: do nn=1,nDom   
         
         call setPointers(nn,level,sps)

         !loop over all points
         
         rotratexref = rotrateadj(1)
              
         
         !print *,'mach before',mach,machcoef
         rotrateadj(1)= rotratexref+deltax
        
         cgnsDoms(nbkglobal)%rotRate(1) = RotRateAdj(1)/timeRef
         !print *,'mach after',mach,machcoef
         !*************************************************************
         !Original force and metric calculation....
         !     ******************************************************************
         !     *                                                                *
         !     * Update the force coefficients using the usual flow solver      *
         !     * routine.                                                       *
         !     *                                                                *
         !     ******************************************************************
         !
 
         call metric(level)
         do mm=1,nTimeIntervalsSpectral
            
            ! Compute the time, which corresponds to this spectral solution.
            ! For steady and unsteady mode this is simply the restart time;
            ! for the spectral mode the periodic time must be taken into
            ! account, which can be different for every section.
            
            t = timeUnsteadyRestart
            
            if(equationMode == timeSpectral) then
               do ll=1,nSections
                  t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                       /         real(nTimeIntervalsSpectral,realType)
               enddo
            endif
            
            call gridVelocitiesFineLevel(.false., t, mm)
            call gridVelocitiesCoarseLevels(mm)
            call normalVelocitiesAllLevels(mm)
            
            call slipVelocitiesFineLevel(.false., t, mm)
            call slipVelocitiesCoarseLevels(mm)
            
         enddo
         call setPointers(nn,level,sps)
         call computeForcesPressureAdj(w,p)
         call applyAllBC(secondHalo)
         call setPointers(nn,level,sps)
         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
         
         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
              + (cfp(2) + cfv(2))*liftDirection(2) &
              + (cfp(3) + cfv(3))*liftDirection(3)
         
         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
              + (cfp(2) + cfv(2))*dragDirection(2) &
              + (cfp(3) + cfv(3))*dragDirection(3)
         
         Cfx = cfp(1) + cfv(1)
         Cfy = cfp(2) + cfv(2)
         Cfz = cfp(3) + cfv(3)
         
         Cmx = cmp(1) + cmv(1)
         Cmy = cmp(2) + cmv(2)
         Cmz = cmp(3) + cmv(3)
         
         nmonsum = 8
         
         monLoc1(1) =monLoc1(1) + Cl
         monLoc1(2) =monLoc1(2)+ Cd
         monLoc1(3) =monLoc1(3)+ cfx
         monLoc1(4) =monLoc1(4) +cfy
         monLoc1(5) =monLoc1(5) +cfz
         monLoc1(6) =monLoc1(6) +cmx
         monLoc1(7) = monLoc1(7)+ cmy
         monLoc1(8) = monLoc1(8)+cmz
         
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
         
         call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         CLp  = monGlob1(1)
         CDp  = monGlob1(2)
         Cfxp = monGlob1(3)
         Cfyp = monGlob1(4)
         Cfzp = monGlob1(5) 
         CMxp = monGlob1(6)
         CMyp = monGlob1(7)
         CMzp = monGlob1(8)
         
         
         !*********************
         !Now calculate other perturbation
         rotrateadj(1)= rotratexref-deltax
        
         cgnsDoms(nbkglobal)%rotRate(1) = RotRateAdj(1)/timeRef
        
         !*************************************************************
         !Original force and metric calculation....
         !     ******************************************************************
         !     *                                                                *
         !     * Update the force coefficients using the usual flow solver      *
         !     * routine.                                                       *
         !     *                                                                *
         !     ******************************************************************
         !
         
         call metric(level)
         do mm=1,nTimeIntervalsSpectral
            
            ! Compute the time, which corresponds to this spectral solution.
            ! For steady and unsteady mode this is simply the restart time;
            ! for the spectral mode the periodic time must be taken into
            ! account, which can be different for every section.
            
            t = timeUnsteadyRestart
            
            if(equationMode == timeSpectral) then
               do ll=1,nSections
                  t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                       /         real(nTimeIntervalsSpectral,realType)
               enddo
            endif
            
            call gridVelocitiesFineLevel(.false., t, mm)
            call gridVelocitiesCoarseLevels(mm)
            call normalVelocitiesAllLevels(mm)
            
            call slipVelocitiesFineLevel(.false., t, mm)
            call slipVelocitiesCoarseLevels(mm)
            
         enddo
         call setPointers(nn,level,sps)
         call computeForcesPressureAdj(w,p)
         call applyAllBC(secondHalo)
         call setPointers(nn,level,sps)
         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
                     
         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
              + (cfp(2) + cfv(2))*liftDirection(2) &
              + (cfp(3) + cfv(3))*liftDirection(3)
         
         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
              + (cfp(2) + cfv(2))*dragDirection(2) &
              + (cfp(3) + cfv(3))*dragDirection(3)
         
         Cfx = cfp(1) + cfv(1)
         Cfy = cfp(2) + cfv(2)
         Cfz = cfp(3) + cfv(3)
         
         Cmx = cmp(1) + cmv(1)
         Cmy = cmp(2) + cmv(2)
         Cmz = cmp(3) + cmv(3)
         
         nmonsum = 8
         
         monLoc2(1) = monLoc2(1)+Cl
         monLoc2(2) = monLoc2(2)+Cd
         monLoc2(3) = monLoc2(3)+cfx
         monLoc2(4) = monLoc2(4)+cfy
         monLoc2(5) = monLoc2(5)+cfz
         monLoc2(6) = monLoc2(6)+cmx
         monLoc2(7) = monLoc2(7)+cmy
         monLoc2(8) = monLoc2(8)+cmz
         
         ! Determine the global sum of the summation monitoring
         ! variables. The sum is made known to all processors.
         
         call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
         
         ! Transfer the cost function values to output arguments.
         
         CLm  = monGlob2(1)
         CDm  = monGlob2(2)
         Cfxm = monGlob2(3)
         Cfym = monGlob2(4)
         Cfzm = monGlob2(5) 
         CMxm = monGlob2(6)
         CMym = monGlob2(7)
         CMzm = monGlob2(8)
         
         rotrateadj(1)= rotratexref
         
         cgnsDoms(nbkglobal)%rotRate(1) = RotRateAdj(1)/timeRef
         
         !print *,'clp',CLP,CLM,CLP-CLM
         dCLdextraFD(ndesignrotx) = (CLP-CLM)/(two*deltax)  
         dCDdextraFD(ndesignrotx) = (CDP-CDM)/(two*deltax) 
         dcmdextrafd(ndesignrotx) = (cmxp-cmxm)/(two*deltax)
         !dCmxdxFD = (CmxP-CmxM)/(two*deltax) 
        
      enddo domainrotxLoopFDorig

!!$      !from ForcesAndMoments.f90
!!$       ! Determine the reference point for the moment computation in
!!$       ! meters.
!!$
!!$       refPoint(1) = LRef*pointRef(1)
!!$       refPoint(2) = LRef*pointRef(2)
!!$       refPoint(3) = LRef*pointRef(3)
!!$
!!$       ! Initialize the force and moment coefficients to 0 as well as
!!$       ! yplusMax.
!!$
!!$!!!$       cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$!!!$       cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$!!!$       cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$!!!$       cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$!
!!$!***********************************
!!$
!!$      ! Loop over the number of local blocks.
!!$
!!$      domainForcesLoopFD: do nn=1,nDom   
!!$
!!$        ! Set some pointers to make the code more readable.
!!$
!!$        call setPointersAdj(nn,level,sps)
!!$
!!$        nViscBocos = flowDoms(nn,groundLevel,sps)%nViscBocos
!!$        nInvBocos  = flowDoms(nn,groundLevel,sps)%nInvBocos
!!$        BCFaceID => flowDoms(nn,groundLevel,  1)%BCFaceID
!!$        groupNum => flowDoms(nn,groundLevel,  1)%groupNum
!!$
!!$        d2Wall   => flowDoms(nn,groundLevel,sps)%d2Wall
!!$        muLam    => flowDoms(nn,groundLevel,sps)%muLam
!!$           
!!$!!!$        ! Determine the number of time instances for this block and
!!$!!!$        ! store the block dimensions a bit easier.
!!$!!!$        
!!$!!!$        sectionID = flowDoms(nn,level,1)%sectionID
!!$!!!$        nTime     = sections(sectionID)%nTimeInstances
!!$!!!$
!!$        
!!$        il = flowDoms(nn,level,1)%il
!!$        jl = flowDoms(nn,level,1)%jl
!!$        kl = flowDoms(nn,level,1)%kl
!!$
!!$        allocate(xAdj(ib:ie,jb:jE,kb:ke,3), stat=ierr)
!!$           if(ierr /= 0)                              &
!!$                call terminate("boundarySurfaceNormals", &
!!$                            "Memory allocation failure for xAdj.")
!!$
!!$        call copyADjointForcesStencil(xAdj,level,nn,sps)
!!$        
!!$     
!!$        nBocos         = nViscBocos + nInvBocos
!!$        viscousSubface = .true.
!!$        
!!$        !loop over cells to store the jacobian
!!$        do l = 1,3
!!$           do k = kb,ke
!!$              do j = jb,je
!!$                 do i = ib,ie
!!$                    !zero the forces
!!$                    cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$                    cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$                    cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$                    cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$                    
!!$                    
!!$                    ClAdjP = 0
!!$                    CDAdjP = 0
!!$                    CmxAdjP = 0
!!$                    CmyAdj = 0
!!$                    CmzAdj = 0
!!$                    CfxAdj = 0
!!$                    CfyAdj = 0
!!$                    CfzAdj = 0
!!$                    
!!$                    yplusMax = zero
!!$                    
!!$                    ! Store baseline x.
!!$                    
!!$                    xAdjRef = xAdj(i,j,k,l)
!!$                    
!!$                    ! Perturb x (forward) and compute dx.
!!$                    
!!$                    xAdj(i,j,k,l) = xAdjRef + deltax
!!$                    
!!$                    bocoLoop1: do mm=1,nBocos!flowDoms(nn,level,1)%nBocos
!!$                    
!!$                       
!!$                       i2Beg = flowDoms(nn,level,1)%BCData(mm)%iBeg
!!$                       j2Beg = flowDoms(nn,level,1)%BCData(mm)%jBeg
!!$                       i2End = flowDoms(nn,level,1)%BCData(mm)%iEnd
!!$                       j2End = flowDoms(nn,level,1)%BCData(mm)%jEnd
!!$                       
!!$
!!$                       select case (flowDoms(nn,level,1)%BCFaceID(mm))
!!$                       case (iMin, iMax)
!!$                          if(i2End == jl) i2End = min(jl+1,je)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (jMin, jMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (kMin, kMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == jl) j2End = min(jl+1,je)
!!$                       end select
!!$                       
!!$
!!$                       ! Determine the nodal range of the owned nodes. Due to block
!!$                       ! splitting iBeg and jBeg may correspond to a halo.
!!$!!!$                       iiBeg = max(i2Beg, 1_intType)
!!$!!!$                       jjBeg = max(j2Beg, 1_intType)
!!$!!!$                       iiEnd = i2End
!!$!!!$                       jjEnd = j2End   
!!$                       iiBeg = max(i2Beg, 1_intType)
!!$                       jjBeg = max(j2Beg, 1_intType)
!!$                       iiEnd = min(i2End, flowDoms(nn,level,1)%BCData(mm)%iEnd)
!!$                       jjEnd = min(j2End, flowDoms(nn,level,1)%BCData(mm)%jEnd)
!!$
!!$                 
!!$                       allocate(normAdj(iiBeg:iiEnd,jjBeg:jjEnd,3), stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Memory allocation failure for normAdj.")
!!$                       
!!$                       !======================================================
!!$                       ! Compute the forces.
!!$                       
!!$                       call computeForcesAdj(level,i2Beg,j2Beg,i2End,j2End,iiBeg,&
!!$                            & jjBeg,iiEnd,jjEnd,xAdj,mm,cFxAdj, cFyAdj, cFzAdj, cMxAdjP,&
!!$                            & cMyAdj,cMzAdj, yplusMax, refPoint, sps, CLAdjP, CDAdjP, nn,&
!!$                            & CfpAdj,cMpAdj,cFvAdj, cMvAdj)
!!$                       
!!$ 
!!$                       ! Release the memory of normAdj again.
!!$                       
!!$                       deallocate(normAdj, stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Deallocation failure for normAdj.") 
!!$                       
!!$                    enddo bocoLoop1
!!$
!!$                    !zero the forces
!!$                    cFpAdj(1) = zero; cFpAdj(2) = zero; cFpAdj(3) = zero
!!$                    cFvAdj(1) = zero; cFvAdj(2) = zero; cFvAdj(3) = zero
!!$                    cMpAdj(1) = zero; cMpAdj(2) = zero; cMpAdj(3) = zero
!!$                    cMvAdj(1) = zero; cMvAdj(2) = zero; cMvAdj(3) = zero
!!$
!!$                    ClAdjM = 0
!!$                    CDAdjM = 0
!!$                    CmxAdjM = 0
!!$                    CmyAdj = 0
!!$                    CmzAdj = 0
!!$                    CfxAdj = 0
!!$                    CfyAdj = 0
!!$                    CfzAdj = 0
!!$                    
!!$                    ! Perturb x (backward) and compute dx.
!!$                    
!!$                    xAdj(i,j,k,l) = xAdjRef - deltax
!!$                    
!!$                    bocoLoop2: do mm=1,nBocos!flowDoms(nn,level,1)%nBocos
!!$                       !       print *,'In bocoloop...',mm
!!$                       
!!$                       
!!$                       i2Beg = flowDoms(nn,level,1)%BCData(mm)%iBeg
!!$                       j2Beg = flowDoms(nn,level,1)%BCData(mm)%jBeg
!!$                       i2End = flowDoms(nn,level,1)%BCData(mm)%iEnd
!!$                       j2End = flowDoms(nn,level,1)%BCData(mm)%jEnd
!!$       
!!$                       select case (flowDoms(nn,level,1)%BCFaceID(mm))
!!$                       case (iMin, iMax)
!!$                          if(i2End == jl) i2End = min(jl+1,je)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (jMin, jMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == kl) j2End = min(kl+1,ke)
!!$                          
!!$                       case (kMin, kMax)
!!$                          if(i2End == il) i2End = min(il+1,ie)
!!$                          if(j2End == jl) j2End = min(jl+1,je)
!!$                       end select
!!$    
!!$                       ! Determine the nodal range of the owned nodes. Due to block
!!$                       ! splitting iBeg and jBeg may correspond to a halo.
!!$!!!$                       iiBeg = max(i2Beg, 1_intType)
!!$!!!$                       jjBeg = max(j2Beg, 1_intType)
!!$!!!$                       iiEnd = i2End
!!$!!!$                       jjEnd = j2End
!!$
!!$                       iiBeg = max(i2Beg, 1_intType)
!!$                       jjBeg = max(j2Beg, 1_intType)
!!$                       iiEnd = min(i2End, flowDoms(nn,level,1)%BCData(mm)%iEnd)
!!$                       jjEnd = min(j2End, flowDoms(nn,level,1)%BCData(mm)%jEnd)
!!$
!!$                       allocate(normAdj(iiBeg:iiEnd,jjBeg:jjEnd,3), stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Memory allocation failure for normAdj.")
!!$                       
!!$                       !======================================================
!!$                       ! Compute the forces.
!!$                       
!!$                       call computeForcesAdj(level,i2Beg,j2Beg,i2End,j2End,iiBeg,&
!!$                            & jjBeg,iiEnd,jjEnd,xAdj,mm,cFxAdj, cFyAdj, cFzAdj, cMxAdjM,&
!!$                            & cMyAdj,cMzAdj, yplusMax, refPoint, sps, CLAdjM, CDAdjM, nn,&
!!$                            & CfpAdj,cMpAdj,cFvAdj, cMvAdj)
!!$                       
!!$ 
!!$                       ! Release the memory of normAdj again.
!!$                       
!!$                       deallocate(normAdj, stat=ierr)
!!$                       if(ierr /= 0)                              &
!!$                            call terminate("boundarySurfaceNormals", &
!!$                            "Deallocation failure for normAdj.") 
!!$                       
!!$                    enddo bocoLoop2
!!$
!!$                    xAdj(i,j,k,l) = xAdjRef
!!$
!!$
!!$                    dCLdxFD = (CLAdjP-CLAdjM)/(two*deltax)  
!!$                    dCDdxFD = (CDAdjP-CDAdjM)/(two*deltax) 
!!$                    dCmxdxFD = (CmxAdjP-CmxAdjM)/(two*deltax) 
!!$
!!$                    dCLFD(nn,i,j,k,l)=dCLdxFD
!!$
!!$                    dCDFD(nn,i,j,k,l)=dCDdxFD
!!$                    
!!$                    dCmxFD(nn,i,j,k,l)=dCmxdxFD
!!$                    
!!$ 
!!$                 enddo
!!$              enddo
!!$           enddo
!!$        enddo
!!$        deallocate(xAdj, stat=ierr)
!!$        if(ierr /= 0)                              &
!!$             call terminate("boundarySurfaceNormals", &
!!$             "Deallocation failure for xAdj.") 
!!$     enddo domainForcesLoopFD

  
      ! Get new time and compute the elapsed FD time.

      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) then
        call cpu_time(time(4))
        timeFD = time(4)-time(3)
      endif
!
!     ******************************************************************
!     *                                                                *
!     * Output debug information.                                      *
!     *                                                                *
!     ******************************************************************
!
      ! Output debug information.

      domainDebugLoop: do nn=1,nDom

        ! Set the variables, which are related to the dimensions of the
        ! block. In this way the dimensions of the automatic arrays used
        ! in the flux routines are set a bit easier.
         print *,'setting pointers',nn,level,sps
         call setPointers(nn,level,sps)
!!$
!!$        il = flowDoms(nn,currentLevel,1)%il
!!$        jl = flowDoms(nn,currentLevel,1)%jl
!!$        kl = flowDoms(nn,currentLevel,1)%kl

        ! Loop over the location of the output node.

        do kNode=0,ke
          do jNode=0,je
            do iNode=0,ie

              ! Relative error

              do n=1,3

                 if ( dCL(nn,iNode,jNode,kNode,n) < 1e-10 ) then
                    dCLer(nn,iNode,jNode,kNode,n)  = zero
                 else
                    dCLer(nn,iNode,jNode,kNode,n)  =                   &
                         (  dCL(nn,iNode,jNode,kNode,n)      &
                         - dCLfd(nn,iNode,jNode,kNode,n) )  &
                         /  dCL(nn,iNode,jNode,kNode,n)
                 endif
                 
                 if ( dCD(nn,iNode,jNode,kNode,n) < 1e-10 ) then
                    dCDer(nn,iNode,jNode,kNode,n)  = zero
                 else
                    dCDer(nn,iNode,jNode,kNode,n)  =                   &
                         (  dCD(nn,iNode,jNode,kNode,n)      &
                         - dCDfd(nn,iNode,jNode,kNode,n) )  &
                         /  dCD(nn,iNode,jNode,kNode,n)
                 endif
                 
                 if ( dCmxer(nn,iNode,jNode,kNode,n) < 1e-10 ) then
                    dCmxer(nn,iNode,jNode,kNode,n)  = zero
                 else
                    dCmxer(nn,iNode,jNode,kNode,n)  =                   &
                         (  dCmx(nn,iNode,jNode,kNode,n)      &
                         - dCmxfd(nn,iNode,jNode,kNode,n) )  &
                         /  dCmx(nn,iNode,jNode,kNode,n)
                 endif
                 
              enddo
              
              ! Output if error

              !if(sum(dCLer(nn,iNode,jNode,kNode,:))/=0)then
              if(sum(dCL(nn,iNode,jNode,kNode,:))/=0)then
                 write(*,10) "Jacobian dCLer,dCL,dCLfd @ proc/block", &
                      myID, nn, "for node", iNode,jNode,kNode
                 do m=1,3
                    !if (dCLer(nn,iNode,jNode,kNode,m)/=0)          &
                    !     write(*,20) (dCLer(nn,iNode,jNode,kNode,m)), &
                    !     (dCL(nn,iNode,jNode,kNode,m)),   &
                    !     (dCLfd(nn,iNode,jNode,kNode,m))
                    if (dCL(nn,iNode,jNode,kNode,m)/=0)          &
                         write(*,20) (dCLer(nn,iNode,jNode,kNode,m)), &
                         (dCL(nn,iNode,jNode,kNode,m)),   &
                         (dCLfd(nn,iNode,jNode,kNode,m))
                 enddo
              endif
              if(sum(dCder(nn,iNode,jNode,kNode,:))/=0)then 
                 write(*,10) "Jacobian dCDer,dCD,dCDfd @ proc/block", &
                      myID, nn, "for node", iNode,jNode,kNode
                 do m=1,3
                    if (dCDer(nn,iNode,jNode,kNode,m)/=0)          &
                         write(*,20) (dCDer(nn,iNode,jNode,kNode,m)), &
                         (dCD(nn,iNode,jNode,kNode,m)),   &
                         (dCDfd(nn,iNode,jNode,kNode,m))
                 enddo
              end if
              if(sum(dCmxer(nn,iNode,jNode,kNode,:))/=0)then 
                 write(*,10) "Jacobian dCmxer,dCmx,dCmxfd @ proc/block", &
                      myID, nn, "for node", iNode,jNode,kNode
                 do m=1,3
                    if (dCmxer(nn,iNode,jNode,kNode,m)/=0)          &
                         write(*,20) (dCmxer(nn,iNode,jNode,kNode,m)), &
                         (dCmx(nn,iNode,jNode,kNode,m)),   &
                         (dCmxfd(nn,iNode,jNode,kNode,m))
                 enddo
              endif
           enddo
        enddo
     enddo
     
  enddo domainDebugLoop
  
  ! Flush the output buffer and synchronize the processors.
  
  call f77flush()
  call mpi_barrier(SUmb_comm_world, ierr)
  
  ! Output elapsed time for the adjoint and FD computations.
  
  if( myID==0 ) then
     print *, "====================================================="
     print *, " Time for reverse mode       =", timeAdj
     print *, " Time for finite differences =", timeFD
     print *, " Factor                      =", timeFD/timeAdj
     print *, "====================================================="
  endif
  !
!     ******************************************************************
!     *                                                                *
!     * Compute the errors in dCf/dx.                                   *
!     *                                                                *
!     ******************************************************************
!
      write(*,*)
      write(*,30) "dCLer : proc, min/loc, max/loc =", myID,          &
                 minval(dCLer(:,:,:,:,:)), minloc(dCLer(:,:,:,:,:)), &
                 maxval(dCLer(:,:,:,:,:)), maxloc(dCLer(:,:,:,:,:))
      write(*,30) "dCDer : proc, min/loc, max/loc =", myID,          &
                 minval(dCDer(:,:,:,:,:)), minloc(dCDer(:,:,:,:,:)), &
                 maxval(dCDer(:,:,:,:,:)), maxloc(dCDer(:,:,:,:,:))
      write(*,30) "dCmxer : proc, min/loc, max/loc =", myID,          &
                 minval(dCmxer(:,:,:,:,:)), minloc(dCmxer(:,:,:,:,:)), &
                 maxval(dCmxer(:,:,:,:,:)), maxloc(dCmxer(:,:,:,:,:))

      ! Flush the output buffer and synchronize the processors.

      dcldextraerror= dcldextra- dcldextraFD
      dcddextraerror= dcddextra- dcddextraFD
      dcmdextraerror= dcmdextra- dcmdextraFD
      
      do i=1,6
         print *,'dcldextra',i,dcldextraerror(i), dcldextra(i), dcldextraFD(i)
         print *,'dcddextra',i,dcddextraerror(i), dcddextra(i), dcddextraFD(i)
         print *,'dcmdextra',i,dcmdextraerror(i), dcmdextra(i), dcmdextraFD(i)
      end do

      
      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
!
!     ******************************************************************
!

      
      ! Deallocate memory for the temporary arrays.
      print *,'deallocating dcl'
      deallocate(dCl,  dCLfd,  dCLer)
      deallocate(dCD,  dCDfd,  dCDer)
      deallocate(dCmx, dCmxfd, dCmxer)
      print *,'finished deallocating dcl'
  
      ! Output formats.

  10  format(1x,a,1x,i3,1x,i3,1x,a,1x,i3,1x,i3,1x,i3)           
  20  format(1x,(e18.6),2x,(e18.6),2x,(e18.6))
  30  format(1x,a,1x,i3,2x,e13.6,1x,5(i2,1x),3x,e13.6,1x,5(i2,1x))

    end subroutine verifydCfdx

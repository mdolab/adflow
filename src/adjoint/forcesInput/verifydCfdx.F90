!
!     ******************************************************************
!     *                                                                *
!     * File:          verifydCfdx.f90                                 *
!     * Author:        Andre C. Marta, C.A.(Sandy) Mader               *
!     * Starting date: 01-15-2007                                      *
!     * Last modified: 02-15-2011                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine verifydCfdx(level,costFunction)
#ifndef USE_COMPLEX
!
!     ******************************************************************
!     *                                                                *
!     * Compute all entries in dIdx (partial) using the automatically  *
!     * differentiated routines generated by Tapenade and compare      *
!     * them to the finite-difference results using the modified       *
!     * force routine. This is only executed in debug mode.            *
!     *                                                                *
!     ******************************************************************
!
      use blockPointers
      use cgnsGrid            ! cgnsDoms
      use communication       ! procHalo(currentLevel)%nProcSend, myID
      use inputPhysics        ! equations
      use flowVarRefState     ! nw
      use inputDiscretization ! spaceDiscr, useCompactDiss
      use iteration           ! overset, currentLevel
      use inputTimeSpectral   ! nTimeIntervalsSpectral
      use section
      use monitor             ! monLoc, MonGlob, nMonSum
      use bcTypes             !imin,imax,jmin,jmax,kmin,kmax
      use adjointvars         !ndesignaoa,ndesignmach
      use ADjointPETSc
      use inputMotion
      use inputTSStabDeriv
      use costFunctions
      use inputMotion         !degreePol etc...
      use inputTSStabDeriv
      implicit none
!
!     Subroutine arguments.
!
      integer(kind=intType), intent(in) :: level,costFunction
!
!     Local variables.
!
      integer(kind=intType) ::sps
      integer(kind=intType) ::nn,mm,ii,npts,ncell,ll,nTS

      real(kind=realType), dimension(:,:,:),allocatable :: pts
      real(kind=realType), dimension(:,:,:),allocatable  :: ptsb

      ! Variables for computeforceandmomentadj_b
      real(kind=realtype) :: force(3), cforce(3)
      real(kind=realtype) :: forceb(3), cforceb(3)
      real(kind=realtype) :: lift, drag, cl, cd
      real(kind=realtype) :: liftb, dragb, clb, cdb
      real(kind=realtype) :: moment(3), cmoment(3)
      real(kind=realtype) :: momentb(3), cmomentb(3)
      
      real(kind=realType) :: alphaadj,alphaadjb,betaadj,betaadjb
      integer(kind=intType) :: liftindex
      real(kind=realType) :: machcoefadj,machcoefadjb
      real(kind=realType) :: pointrefadj(3),pointrefadjb(3)
      logical :: righthandedadj
      
      real(kind=realType), dimension(:,:,:,:),allocatable :: wblock,wblockb

      ! Working Variables
      integer(kind=intTYpe) :: ii_start,ii_end,iInc,n
      integer(kind=intTYpe) :: i,j,icell,jcell,kcell,idxmgb,&
           faceID,ibeg,iend,jbeg,jend

      integer(kind=intType) :: row_start,row_end,iLow,iHigh
      real(kind=realType)::val
      integer(kind=intType) ::k,l
!!$      integer(kind=intType) :: discr, nHalo, sps
!!$      integer(kind=intType) :: inode, jnode, knode, mm, nn, m, n,ll
!!$      integer(kind=intType) :: ii, jj, kk, i1, j1, k1, i2, j2, k2
!!$
!!$      integer(kind=intType) ::  i2Beg,  i2End,  j2Beg,  j2End
!!$      integer(kind=intType) :: iiBeg, iiEnd, jjBeg, jjEnd
!!$      integer(kind=intType) :: i,j,k,l
!!$
!!$      logical :: fineGrid,correctForK, exchangeTurb
!!$
      real(kind=realType) :: Cfx,Cfy,Cfz,Cmx,Cmy,Cmz
      real(kind=realType) :: ClAdj,CdAdj,CfxAdj,CfyAdj,CfzAdj,&
                             &CmxAdj,CmyAdj,CmzAdj  
      real(kind=realType) :: CLAdjP,CLAdjM,CDAdjP,CDAdjM,dCLdxFD,dCDdxFD,&
                             &dCmxdxFD,CmxAdjP,CmxAdjM
      real(kind=realType) :: ClAdjB,CdAdjB,CfxAdjB,CfyAdjB,CfzAdjB,&
                             &CmxAdjB,CmyAdjB,CmzAdjB 

      real(kind=realType) :: CLP,CLM,CDP,CDM,CmxP,CmxM,CmyP,CmyM,CmzP,CmzM,&
                             &CfxP,CfxM,CfyP,CfyM,CfzP,CfzM
!!$
!!$      real(kind=realType), dimension(:,:,:,:), allocatable :: xAdj,xAdjB
!!$      real(kind=realType), dimension(:,:,:,:), allocatable :: wAdj,wAdjB
!!$      real(kind=realType), dimension(:,:,:), allocatable :: pAdj
!!$
!!$      real(kind=realType), dimension(3) :: cFpAdj, cFvAdj
!!$      real(kind=realType), dimension(3) :: cMpAdj, cMvAdj
!!$
      real(kind=realType), dimension(3) :: cFp, cFv
      real(kind=realType), dimension(3) :: cMp, cMv
!!$
!!$
!!$      real(kind=realType) :: alphaAdj, betaAdj,MachAdj,machCoefAdj,machgridAdj
!!$      real(kind=realType) :: alphaAdjb, betaAdjb,MachAdjb,machCoefAdjb,machgridadjb
!!$      REAL(KIND=REALTYPE) :: prefAdj, rhorefAdj,pInfCorrAdj
!!$      REAL(KIND=REALTYPE) :: pinfdimAdj, rhoinfdimAdj
!!$      REAL(KIND=REALTYPE) :: rhoinfAdj, pinfAdj
!!$      REAL(KIND=REALTYPE) :: murefAdj, timerefAdj
!!$
!!$
!!$      real(kind=realType) :: factI, factJ, factK, tmp
!!$
!!$      integer(kind=intType), dimension(0:nProc-1) :: offsetRecv
!!$
      real(kind=realType), dimension(4) :: time
      real(kind=realType)               :: timeAdj, timeFD
!!$
!!$      ! > derivative output
!!$
!!$      real(kind=realType), dimension(:,:,:,:,:), allocatable ::dCL, &
!!$           dCD,dCmx
!!$      real(kind=realType), dimension(:,:,:,:,:), allocatable :: dCLfd, &
!!$           dCDfd,dCmxfd
!!$      real(kind=realType), dimension(:,:,:,:,:), allocatable :: dCLer, &
!!$           dCDer,dCmxer
!!$
      real(kind=realType), parameter :: deltax = 1.e-6_realType

      real(kind=realType) :: xAdjRef,xref,alpharef,betaref,machref,alpha,beta,machcoefref,rotratexref,pointref_ref

      real(kind=realType) ::valueold,valuenew

!!$
!!$      real(kind=realType), dimension(:,:,:), pointer :: norm
!!$      real(kind=realType), dimension(:,:,:),allocatable:: normAdj
!!$      real(kind=realType), dimension(3) :: refPoint
      real(kind=realType) :: yplusMax

      real(kind=realType),  dimension(:), allocatable :: monLoc1, monGlob1
      real(kind=realType),  dimension(:), allocatable :: monLoc2, monGlob2
!!$
!!$      logical :: contributeToForce, viscousSubface,secondHalo
      logical ::secondHalo
      real(kind=realType),  dimension(:,:), allocatable ::dIdaLoc,dIdaGlob,dIdaFD,dIdaError
  
!!$
!!$      REAL(KIND=REALTYPE) :: rotcenteradj(3), rotcenteradjb(3), rotrateadj(3), rotrateadjb(3)
!!$      REAL(KIND=REALTYPE) :: pointrefadj(3), pointrefadjb(3), rotpointadj(3)&
!!$           &  , rotpointadjb(3)
!!$
      real(kind=realType), dimension(nSections) :: t
 
      REAL(kind=realtype):: lengthrefadj, surfacerefadj
      REAL(kind=realtype) :: lengthrefadjb, surfacerefadjb
      !TS variables
      real(kind=realType) :: liftDirTmp(3),dragDirTmp(3)
      real(kind=realType) :: tNew, tOld
      real(kind=realType) :: alphaTS,alphaIncrement,&
           betaTS,betaIncrement
      !Rotation variables
      real(kind=realType), dimension(3)   :: rotationPoint
      real(kind=realType), dimension(3,3) :: rotationMatrix,&
           derivRotationMatrix
      
      !Function Definitions
      real(kind=realType) :: TSAlpha,TSBeta

      real(kind=realType) :: liftDir(3),dragDir(3)
      !real(kind=realType) :: velDirFreestreamAdj(3)

      integer :: ierr,nmonsum1,nmonsum2



!File Parameters
      integer :: unitdx,unitdw,ierror
      character(len = 64)::outfile,testfile
      write(testfile,100) myid!12
100   format (i5)
      testfile=adjustl(testfile)
      write(outfile,101) trim(testfile)!testfile
101   format("/scratch/mader/ADdCdxfile",a,".out")
      unitdx = 8+myID

      open (UNIT=unitdx,File=outfile,status='replace',action='write',iostat=ierror)
      if(ierror /= 0)                        &
           call terminate("verifydCfdx", &
           "Something wrong when &
           &calling open")

      write(testfile,102) myid!12
102   format (i5)
      testfile=adjustl(testfile)
      write(outfile,103) trim(testfile)!testfile
103   format("/scratch/mader/ADdCdwfile",a,".out")
      unitdw = 28+myID

      open (UNIT=unitdw,File=outfile,status='replace',action='write',iostat=ierror)
      if(ierror /= 0)                        &
           call terminate("verifydCfdx", &
           "Something wrong when &
           &calling open")
!
!     ******************************************************************
!     *                                                                *
!     * Begin execution.                                               *
!     *                                                                *
!     ******************************************************************
!
#ifndef USE_NO_PETSC
       if( myID==0 ) write(*,*) "Running verifydCfdx...",sps

      ! Set the grid level of the current MG cycle, the value of the
      ! discretization and the logical correctForK.

      currentLevel = level
 

      ! Determine whether or not the total energy must be corrected
      ! for the presence of the turbulent kinetic energy and whether
      ! or not turbulence variables should be exchanged.

 
      secondhalo = .true.



      
      nmonsum1 = 8
      nmonsum2 = 8

      allocate(monLoc1(nmonsum1), monGlob1(nmonsum1))
      allocate(monLoc2(nmonsum2), monGlob2(nmonsum2))
      allocate(dIdaLoc(nDesignExtra,nTimeIntervalsSpectral))
      allocate(dIdaGlob(nDesignExtra,nTimeIntervalsSpectral))
      allocate(dIdaFD(nDesignExtra,nTimeIntervalsSpectral))
      allocate(dIdaError(nDesignExtra,nTimeIntervalsSpectral))

     ! Exchange the pressure if the pressure must be exchanged early.
      ! Only the first halo's are needed, thus whalo1 is called.
      ! Only on the fine grid.
      
      if(exchangePressureEarly .and. currentLevel <= groundLevel) &
           call whalo1(currentLevel, 1_intType, 0_intType, .true.,&
           .false., .false.)
      
      ! Apply all boundary conditions to all blocks on this level.
      
      call applyAllBC(secondHalo)
      
      ! Exchange the solution. Either whalo1 or whalo2
      ! must be called.
      
      if( secondHalo ) then
         call whalo2(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      else
         call whalo1(currentLevel, 1_intType, nMGVar, .true., &
              .true., .true.)
      endif

      call mpi_barrier(SUmb_comm_world, ierr)      


      if( myID==0 )print *,"halo's updated"
!
!     ******************************************************************
!     *                                                                *
!     * Compute the d(forces)/dx (partial) using the tapenade routines.*
!     *                                                                *
!     ******************************************************************
      call getForceSize(npts,ncell,nTS)
      allocate(pts(3,npts,nTimeIntervalsSpectral),ptsb(3,npts,nTimeIntervalsSpectral))
      call getForcePoints(pts,npts,nTS)   

      ! Copy over values we need for the computeforcenadmoment call:
      MachCoefAdj = MachCoef
      pointRefAdj = pointRef
      lengthRefAdj = lengthRef
      SurfaceRefAdj = SurfaceRef
      
      call getDirAngleTS(velDirFreestream,LiftDirection,liftIndex,alphaAdj,betaAdj)
      pointRefAdj(1) = pointRef(1)
      pointRefAdj(2) = pointRef(2)
      pointRefAdj(3) = pointRef(3)

!***********************************
    

      dIdaLoc = 0.0
     
      
      if( myID==0 )print *,' computing adjoint derivatives'
      spectralLoopAdj: do sps=1,nTimeIntervalsSpectral

         ! entries into dJdw
         call VecZeroEntries(dJdw,ierr)
         call EChk(ierr,__FILE__,__LINE__)
         
         call VecZeroEntries(dJdx,ierr)
         call EChk(ierr,__FILE__,__LINE__)
         
         call VecGetOwnershipRange(dJdx,row_start,row_end,ierr)
         call EChk(ierr,__FILE__,__LINE__)
         ii = 0 
         domainLoopAD: do nn=1,nDom
            call setPointers(nn,1_intType,sps)
            bocos: do mm=1,nBocos
               !if( myID==0 )print*,'current index',sps,nn,mm
               if(BCType(mm) == EulerWall.or.BCType(mm) == NSWallAdiabatic .or.&
                    BCType(mm) == NSWallIsothermal) then
                  
                  jBeg = BCData(mm)%jnBeg ; jEnd = BCData(mm)%jnEnd
                  iBeg = BCData(mm)%inBeg ; iEnd = BCData(mm)%inEnd
                  
                  lengthrefadj = lengthRef
                  surfacerefAdj = SurfaceRef
                  ! Zero all the backward-mode seeds
                  forceb = 0.0
                  cforceb = 0.0
                  liftb = 0.0
                  dragb = 0.0
                  clb = 0.0
                  cdb = 0.0
                  momentb = 0.0
                  cmomentb = 0.0
                  alphaadjb = 0.0
                  betaadjb = 0.0
                  machcoefadjb = 0.0
                  pointrefadjb = 0.0
                  ptsb = 0.0
                  lengthrefadjb = 0.0
                  surfacerefAdjb = 0.0
                  
                  ! Seed the correct value based on the cost function
                  select case (costFunction)
                     
                  case (costFuncLift)
                     liftb = 1.0
                  case (costFuncDrag)
                     dragb = 1.0
                  case (costFuncLiftCoef,costFuncCL0,costFuncCLalpha)
                     clb = 1.0
                  case (costFuncDragCoef,costFuncCd0,costFuncCdAlpha)
                     cdb = 1.0
                  case (costFuncForceX)
                     forceb(1) = 1.0
                  case (costFuncForceY)
                     forceb(2) = 1.0
                  case (costFuncForceZ)
                     forceb(3) = 1.0
                  case (costFuncForceXCoef)
                     cforceb(1) = 1.0
                  case (costFuncForceYCoef)
                     cforceb(2) = 1.0
                  case (costFuncForceZCoef)
                     cforceb(3) = 1.0
                  case (costFuncMomX)
                     momentb(1) = 1.0
                  case (costFuncMomY)
                     momentb(2) = 1.0
                  case (costFuncMomZ)
                     momentb(3) = 1.0
                  case (costFuncMomXCoef)
                     cmomentb(1) = 1.0
                  case (costFuncMomYCoef)
                     cmomentb(2) = 1.0
                  case (costFuncMomZCoef,costFuncCMzAlpha,costFuncCmzalphadot,&
                       costFuncCmzq,costFuncCm0)
                     cmomentb(3) = 1.0
                  end select
                  
                  allocate(wblock(0:ib,0:jb,0:kb,nw),&
                       wblockb(0:ib,0:jb,0:kb,nw))
                  wblock(:,:,:,:) = w(:,:,:,:)
                  wblockb(:,:,:,:) = 0.0
                  righthandedadj = righthanded
                  
                  faceID = bcfaceid(mm)

                  call  COMPUTEFORCEANDMOMENTADJ_B(force, forceb, cforce, cforceb, &
   &  lift, liftb, drag, dragb, cl, clb, cd, cdb, moment, momentb, cmoment, &
   &  cmomentb, alphaadj, alphaadjb, betaadj, betaadjb, liftindex, &
   &  machcoefadj, machcoefadjb, pointrefadj, pointrefadjb, lengthrefadj, &
   &  lengthrefadjb,surfacerefadj, surfacerefadjb, pts(:,:,sps), ptsb(:,:,sps), npts&
   &  , wblock, wblockb, righthandedadj, faceid, ibeg, iend, jbeg, jend, &
   &  ii, sps)
                  !if( myID==0 )print *,'forces computed'
                  ! Set the w-values derivatives in dJdw
                  do kcell = 2,kl
                     do jcell = 2,jl
                        do icell = 2,il
                           idxmgb = globalCell(icell,jcell,kcell)
                           
                           call VecSetValuesBlocked(dJdw,1,idxmgb,&
                                wblockb(icell,jcell,kcell,:),&
                                ADD_VALUES,PETScIerr)
!!$                           call VecSetValuesBlocked(dJdw,1,idxmgb,&
!!$                                wblockb(icell,jcell,kcell,:)*dJdc(sps),&
!!$                                ADD_VALUES,PETScIerr)
                           call EChk(PETScIerr,__FILE__,__LINE__)
                        enddo
                     enddo
                  enddo
                  !if( myID==0 )print *,'state deriv set'
                  ! Set the pt derivative values in dIdpt
                  do j=jBeg,jEnd
                     do i=iBeg,iEnd
                        ! This takes care of the ii increments -- 
                        ! DO NOT NEED INCREMENT ON LINE BELOW
                        ii = ii + 1
                        call VecSetValues(dJdx,3,&
                             (/row_start+3*ii-3,row_start+3*ii-2,row_start+3*ii-1/),&
                             ptsb(:,ii,sps),ADD_VALUES,PETScIerr)
                        call EChk(PETScIerr,__FILE__,__LINE__)
                     end do
                  end do
                  !ii = ii + (iEnd-iBeg+1)*(jEnd-jBeg+1)
                  !if( myID==0 )print *,'coord deriv set'
                  ! We also have the derivative of the Objective wrt the
                  ! "AeroDVs" intrinsic aero design variables, alpha, beta etc
                  if (nDesignAoA >=0) then
                     print *,'aoa deriv',alphaAdjb,nn,sps, myID
                     dIdaloc(nDesignAoA+1,sps) = dIdaloc(nDesignAoA+1,sps) + alphaAdjb
                  end if
                  !if( myID==0 )print *,'aoa deriv set'
                  if (nDesignSSA >= 0) then
                     dIdaloc(nDesignSSA+1,sps) = dIdaloc(nDesignSSA+1,sps) + betaAdjb
                  end if
                  !if( myID==0 )print *,'ssa deriv set'
                  if (nDesignMach >= 0) then
                     dIdaloc(nDesignMach+1,sps) = dIdaloc(nDesignMach+1,sps) + machCoefAdjb!+machadjb
                  end if
                  !if( myID==0 )print *,'mach deriv set'
                  if (nDesignMachGrid >= 0) then
                     dIdaloc(nDesignMachGrid+1,sps) = dIdaloc(nDesignMachGrid+1,sps) + machCoefAdjb!+machgridadjb
                  end if
                  !if( myID==0 )print *,'machgrid deriv set'
                  if (nDesignPointRefX >=0) then
                     print *,'pointrefx', dIdaloc(nDesignPointRefX + 1,sps) , pointrefAdjb(1),sps, myID
                     dIdaloc(nDesignPointRefX + 1,sps) = dIdaloc(nDesignPointRefX + 1,sps) + pointrefAdjb(1)
                  end if
                  !if( myID==0 )print *,'refx deriv set'
                  if (nDesignPointRefY >=0) then
                     dIdaloc(nDesignPointRefY + 1,sps) = dIdaloc(nDesignPointRefY + 1,sps) + pointrefAdjb(2)
                  end if
                  !if( myID==0 )print *,'refy deriv set'
                  if (nDesignPointRefZ >=0) then
                     dIdaloc(nDesignPointRefZ + 1,sps) = dIdaloc(nDesignPointRefZ + 1,sps) + pointrefAdjb(3)
                  end if
                  !if( myID==0 )print *,'extra derivs set'
               end if
            end do bocos
            
            deallocate(wblock,wblockb,stat=ierr)
         end do domainLoopAD
         ! Assemble the petsc vectors
         call VecAssemblyBegin(dJdw,PETScIerr)
         call EChk(PETScIerr,__FILE__,__LINE__)
         call VecAssemblyEnd(dJdw,PETScIerr)
         call EChk(PETScIerr,__FILE__,__LINE__)
         
         call VecAssemblyBegin(dJdx,PETScIerr)
         call EChk(PETScIerr,__FILE__,__LINE__)
         call VecAssemblyEnd(dJdx,PETScIerr)
         call EChk(PETScIerr,__FILE__,__LINE__) 

         call VecGetOwnershipRange(djdw, iLow, iHigh, PETScIerr)
         call EChk(PETScIerr,__FILE__,__LINE__)
         do nn = 1,ndom
            call setPointers(nn,1_intType,sps)
            do k = 2,kl!0,kb
               do j = 2,jl!0,jb
                  do i = 2,il!0,ib
                     do l = 1,nw
                        idxmgb   = globalCell(i,j,k)*nw+l
                        
                        if( (idxmgb>=iLow).and.(idxmgb<=iHigh)) then
                           call VecGetValues(djdw, 1, idxmgb-1, &
                                val, PETScIerr)
                           call EChk(PETScIerr,__FILE__,__LINE__)
 
                           write(unitdw,11) val,sps,nn,i,j,k,l,idxmgb
11                         format(1x,'dcdw ',f18.10,7I8)
                        endif
                     enddo
                  enddo
               enddo
            enddo
         end do

         call VecGetOwnershipRange(djdx, iLow, iHigh, PETScIerr)
         call EChk(PETScIerr,__FILE__,__LINE__)
         do nn = 1,ndom
            call setPointers(nn,1_intType,sps)
            do k = 1,ke!0,kb
               do j = 1,je!0,jb
                  do i = 1,ie!0,ib
                     do l = 1,3
                        idxmgb   = globalnode(i,j,k)*3+l
                                                
                        if( (idxmgb>=iLow).and.(idxmgb<=iHigh)) then
                           call VecGetValues(djdx, 1, idxmgb-1, &
                                val, PETScIerr)
                           call EChk(PETScIerr,__FILE__,__LINE__)
 
                           write(unitdx,12) val,sps,nn,i,j,k,l,idxmgb
12                         format(1x,'dcdx ',f18.10,7I8)
                        endif
                     enddo
                  enddo
               enddo
            enddo
         end do

      end do spectralLoopAdj

      print *,'local',dIdaloc(nDesignAoA+1,:)
      do sps =1,nTimeintervalsSpectral
         call mpi_allreduce(dIdaLoc(:,sps), dIdaGlob(:,sps), nDesignExtra, sumb_real, &
              mpi_sum, SUmb_comm_world, ierr)
      enddo
      if(myid==0) print *,'global',dIdaglob(nDesignAoA+1,:)
     
      deallocate(pts,ptsb)
      deallocate(dIdaLoc)
      
     
      !
      ! Get new time and compute the elapsed AD time.

      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) then
        call cpu_time(time(2))
        timeAdj = time(2)-time(1)
      endif
!
!     ******************************************************************
!     *                                                                *
!     * Compute d(Cf)/d(x) using central finite-differences.           *
!     *                                                                *
!     ******************************************************************
!
      ! Get the initial FD time.
      
      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) call cpu_time(time(3))

!version using original routines!
!!$      ! Loop over the number of local blocks.
!!$      print *,'starting FD loop',nTimeIntervalsSpectral
!!$      do sps=1,nTimeIntervalsSpectral
!!$         
!!$         domainForcesLoopFDorig: do nn=1,nDom   
!!$            print *,'fd in domain',nn,sps
!!$            call setPointers(nn,level,sps)
!!$            
!!$            !loop over all points
!!$            
!!$            do i = 0,ie
!!$               print *,'i',i
!!$               do j = 0,je
!!$                  do k = 0,ke
!!$                     do l = 1,3
!!$                        xref = x(i,j,k,l)
!!$                        
!!$                        x(i,j,k,l) = xref+deltax
!!$                        
!!$                        !*************************************************************
!!$                        !Original force and metric calculation....
!!$                        !     ******************************************************************
!!$                        !     *                                                                *
!!$                        !     * Update the force coefficients using the usual flow solver      *
!!$                        !     * routine.                                                       *
!!$                        !     *                                                                *
!!$                        !     ******************************************************************
!!$                        !
!!$                        
!!$                        call metric(level)
!!$                        call setPointers(nn,level,sps)
!!$                        call computeForcesPressureAdj(w,p)
!!$                        call applyAllBC(secondHalo)
!!$                        call setPointers(nn,level,sps)
!!$                        call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
!!$                        
!!$                        Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$                             + (cfp(2) + cfv(2))*liftDirection(2) &
!!$                             + (cfp(3) + cfv(3))*liftDirection(3)
!!$                        
!!$                        Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$                             + (cfp(2) + cfv(2))*dragDirection(2) &
!!$                             + (cfp(3) + cfv(3))*dragDirection(3)
!!$                        
!!$                        Cfx = cfp(1) + cfv(1)
!!$                        Cfy = cfp(2) + cfv(2)
!!$                        Cfz = cfp(3) + cfv(3)
!!$                        
!!$                        Cmx = cmp(1) + cmv(1)
!!$                        Cmy = cmp(2) + cmv(2)
!!$                        Cmz = cmp(3) + cmv(3)
!!$                        
!!$                        nmonsum = 8
!!$                        
!!$                        monLoc1(1) = Cl
!!$                        monLoc1(2) = Cd
!!$                        monLoc1(3) = cfx
!!$                        monLoc1(4) = cfy
!!$                        monLoc1(5) = cfz
!!$                        monLoc1(6) = cmx
!!$                        monLoc1(7) = cmy
!!$                        monLoc1(8) = cmz
!!$                        
!!$                     
!!$                        ! Determine the global sum of the summation monitoring
!!$                        ! variables. The sum is made known to all processors.
!!$                        
!!$                        call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
!!$                             mpi_sum, SUmb_comm_world, ierr)
!!$                        
!!$                        ! Transfer the cost function values to output arguments.
!!$                        
!!$                        CLp  = monGlob1(1)
!!$                        CDp  = monGlob1(2)
!!$                        Cfxp = monGlob1(3)
!!$                        Cfyp = monGlob1(4)
!!$                        Cfzp = monGlob1(5) 
!!$                        CMxp = monGlob1(6)
!!$                        CMyp = monGlob1(7)
!!$                        CMzp = monGlob1(8)
!!$                        
!!$                        
!!$                        !*********************
!!$                        !Now calculate other perturbation
!!$                        x(i,j,k,l) = xref-deltax
!!$                        
!!$                        !*************************************************************
!!$                        !Original force and metric calculation....
!!$                        !     ******************************************************************
!!$                        !     *                                                                *
!!$                        !     * Update the force coefficients using the usual flow solver      *
!!$                        !     * routine.                                                       *
!!$                        !     *                                                                *
!!$                        !     ******************************************************************
!!$                        !
!!$                        
!!$                        call metric(level)
!!$                        call setPointers(nn,level,sps)
!!$                        call computeForcesPressureAdj(w,p)
!!$                        call applyAllBC(secondHalo)
!!$                        call setPointers(nn,level,sps)
!!$                        call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
!!$                        
!!$                        Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$                             + (cfp(2) + cfv(2))*liftDirection(2) &
!!$                             + (cfp(3) + cfv(3))*liftDirection(3)
!!$                        
!!$                        Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$                             + (cfp(2) + cfv(2))*dragDirection(2) &
!!$                             + (cfp(3) + cfv(3))*dragDirection(3)
!!$                        
!!$                        Cfx = cfp(1) + cfv(1)
!!$                        Cfy = cfp(2) + cfv(2)
!!$                        Cfz = cfp(3) + cfv(3)
!!$                        
!!$                        Cmx = cmp(1) + cmv(1)
!!$                        Cmy = cmp(2) + cmv(2)
!!$                        Cmz = cmp(3) + cmv(3)
!!$                        
!!$                        nmonsum = 8
!!$                        
!!$                        monLoc2(1) = Cl
!!$                        monLoc2(2) = Cd
!!$                        monLoc2(3) = cfx
!!$                        monLoc2(4) = cfy
!!$                        monLoc2(5) = cfz
!!$                        monLoc2(6) = cmx
!!$                        monLoc2(7) = cmy
!!$                        monLoc2(8) = cmz
!!$                        
!!$                        ! Determine the global sum of the summation monitoring
!!$                        ! variables. The sum is made known to all processors.
!!$                        
!!$                        call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
!!$                             mpi_sum, SUmb_comm_world, ierr)
!!$                        
!!$                        ! Transfer the cost function values to output arguments.
!!$                        
!!$                        CLm  = monGlob2(1)
!!$                        CDm  = monGlob2(2)
!!$                        Cfxm = monGlob2(3)
!!$                        Cfym = monGlob2(4)
!!$                        Cfzm = monGlob2(5) 
!!$                        CMxm = monGlob2(6)
!!$                        CMym = monGlob2(7)
!!$                        CMzm = monGlob2(8)
!!$                        
!!$                        
!!$                        x(i,j,k,l) = xref
!!$                        
!!$                        
!!$                        dCLdxFD = (CLP-CLM)/(two*deltax)  
!!$                        dCDdxFD = (CDP-CDM)/(two*deltax) 
!!$                        dCmxdxFD = (CmxP-CmxM)/(two*deltax) 
!!$                        
!!$                        dCLFD(nn,i,j,k,l)=dCLdxFD
!!$                        
!!$                        dCDFD(nn,i,j,k,l)=dCDdxFD
!!$                        
!!$                        dCmxFD(nn,i,j,k,l)=dCmxdxFD
!!$                        write (unit,*) dCLdxFD,i,j,k,l
!!$                        
!!$                     enddo
!!$                  enddo
!!$               enddo
!!$            enddo
!!$         enddo domainForcesLoopFDorig
!!$      enddo
!get reference conditions
      call getDirAngleTS(velDirFreestream,liftDirection,liftIndex,alpha,beta)
      alpharef = alpha
      betaref = beta
      !if( myID==0 )print *,'machalpha',alpha
      if (nDesignMach >= 0) then
         
      ! Loop over the number of local blocks.
      
      if( myID==0 )print *,'starting FD loop',nTimeIntervalsSpectral
      do sps = 1, nTimeIntervalsSpectral
         monloc1=0.0
         monloc2=0.0
         monGlob1 = 0.0
         monGlob2 = 0.0

         domainMachLoopFDorig: do nn=1,nDom   
            
            call setPointers(nn,level,sps)
            
            !loop over all points
            
            machref = mach
            machcoefref=machcoef
            !if( myID==0 )print *,'mach before',mach,machcoef
            mach= machref+deltax
            machcoef = machcoefref+deltax
            !if( myID==0 )print *,'mach after',mach,machcoef
            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !
            
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
            !if( myID==0 )print *,'routines complete'
            !compute the lift vector update
            call adjustInflowAngleForcesAdj(alpha,beta,velDirFreestream,&
                 liftDir,dragDir,liftIndex)
            !This computation is time dependent for TSStability so update for time instance
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha2',alphaTS,alphaIncrement
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = betaAdj+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!

            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
!            Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!                 + (cfp(2) + cfv(2))*liftDirection(2) &
!                 + (cfp(3) + cfv(3))*liftDirection(3)
!            
!            Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!                 + (cfp(2) + cfv(2))*dragDirection(2) &
!                 + (cfp(3) + cfv(3))*dragDirection(3)
            
            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)
            
            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            
            nmonsum = 8
            
            monLoc1(1) =monLoc1(1) + Cl
            monLoc1(2) =monLoc1(2)+ Cd
            monLoc1(3) =monLoc1(3)+ cfx
            monLoc1(4) =monLoc1(4) +cfy
            monLoc1(5) =monLoc1(5) +cfz
            monLoc1(6) =monLoc1(6) +cmx
            monLoc1(7) = monLoc1(7)+ cmy
            monLoc1(8) = monLoc1(8)+cmz
            
            
            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.
            
            call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)
            !if( myID==0 )print *,'alrreduce complete'
            ! Transfer the cost function values to output arguments.
            
            CLp  = monGlob1(1)
            CDp  = monGlob1(2)
            Cfxp = monGlob1(3)
            Cfyp = monGlob1(4)
            Cfzp = monGlob1(5) 
            CMxp = monGlob1(6)
            CMyp = monGlob1(7)
            CMzp = monGlob1(8)
            
            
            !*********************
            !Now calculate other perturbation
            mach = machref-deltax
            machcoef = machcoefref-deltax
            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !
            
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            !compute the lift vector update
            call adjustInflowAngleForcesAdj(alpha,beta,velDirFreestream,&
                 liftDir,dragDir,liftIndex)
            !This computation is time dependent for TSStability so update for time instance
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha2',alphaTS,alphaIncrement
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = betaAdj+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!

            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
            !Cl = (cfp(1) + cfv(1))*liftDirection(1) &
            !     + (cfp(2) + cfv(2))*liftDirection(2) &
            !     + (cfp(3) + cfv(3))*liftDirection(3)
            !
            !Cd = (cfp(1) + cfv(1))*dragDirection(1) &
            !     + (cfp(2) + cfv(2))*dragDirection(2) &
            !     + (cfp(3) + cfv(3))*dragDirection(3)
            
            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)
            
            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            
            nmonsum = 8
            
            monLoc2(1) = monLoc2(1)+Cl
            monLoc2(2) = monLoc2(2)+Cd
            monLoc2(3) = monLoc2(3)+cfx
            monLoc2(4) = monLoc2(4)+cfy
            monLoc2(5) = monLoc2(5)+cfz
            monLoc2(6) = monLoc2(6)+cmx
            monLoc2(7) = monLoc2(7)+cmy
            monLoc2(8) = monLoc2(8)+cmz
            
            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.
            
            call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)
            !if( myID==0 )print *,'allreduce complete 2'
            ! Transfer the cost function values to output arguments.
            
            CLm  = monGlob2(1)
            CDm  = monGlob2(2)
            Cfxm = monGlob2(3)
            Cfym = monGlob2(4)
            Cfzm = monGlob2(5) 
            CMxm = monGlob2(6)
            CMym = monGlob2(7)
            CMzm = monGlob2(8)
            
            
            mach = machref
            machcoef = machcoefref
            
        
         enddo domainMachLoopFDorig
         
         !if( myID==0 )print *,'setting derivatives'
         ! Store the correct value based on the cost function
         select case (costFunction)

         case (costFuncLiftCoef,costfunccl0)
            dIdaFD(nDesignMach+1,sps) = (CLP-CLM)/(two*deltax) 
         case (costFuncDragCoef)
            dIdaFD(nDesignMach+1,sps) = (CDP-CDM)/(two*deltax) 
         case (costFuncForceXCoef)
            dIdaFD(nDesignMach+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceYCoef)
            dIdaFD(nDesignMach+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceZCoef)
            dIdaFD(nDesignMach+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncMomXCoef)
            dIdaFD(nDesignMach+1,sps) = (cmxp-cmxm)/(two*deltax)
         case (costFuncMomYCoef)
            dIdaFD(nDesignMach+1,sps) = (cmyp-cmym)/(two*deltax)
         case (costFuncMomZCoef,costFuncCm0)
            dIdaFD(nDesignMach+1,sps) = (cmzp-cmzm)/(two*deltax)
         end select
      enddo
      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
      !if( myID==0 )print *,'mach derivatives complete'
      alpha = alpharef
   endif

   !if( myID==0 )print *,'alphaalpha',alpha

    if (nDesignAoA >= 0) then
      !get reference conditions
      !call getDirAngleTS(velDirFreestream,liftDirection,liftIndex,alpha,beta)
      
      
      print *,'starting alpha FD loop',nTimeIntervalsSpectral
      do sps = 1,nTimeIntervalsSpectral
         monloc1=0.0
         monloc2=0.0
         monGlob1 = 0.0
         monGlob2 = 0.0
         domainalphaLoopFDorig: do nn=1,nDom   
            !print *,'in domain loop',nn,level,sps
            call setPointers(nn,level,sps)

            !loop over all points
            alpharef = alpha

            alpha = alpharef+deltax
            if (myid==0)print *,'alpha',alpha
            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !
           
            do mm=1,nTimeIntervalsSpectral

               ! Compute the time, which corresponds to this spectral solution.
               ! For steady and unsteady mode this is simply the restart time;
               ! for the spectral mode the periodic time must be taken into
               ! account, which can be different for every section.

               t = timeUnsteadyRestart

               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                          /         real(nTimeIntervalsSpectral,realType)
                  enddo
               endif
               
              

               call gridVelocitiesFineLevel(.false., t, mm)
               call gridVelocitiesCoarseLevels(mm)
               call normalVelocitiesAllLevels(mm)

               call slipVelocitiesFineLevel(.false., t, mm)
               call slipVelocitiesCoarseLevels(mm)

            enddo
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
 !compute the lift vector update
            call adjustInflowAngleForcesAdj(alpha,beta,velDirFreestream,&
                 liftDir,dragDir,liftIndex)
            !This computation is time dependent for TSStability so update for time instance
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     !if(myID==0) print *,'time', t(ll) , (sps-1),sections(ll)%timePeriod,  nTimeIntervalsSpectral,1.0
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha1',alphaTS,alphaIncrement,t(1)
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = beta+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!
            !if( myID==0 )print *,'alphacl',cfp(1) , cfv(1),liftDir(1)
            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
!!$            Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$                 + (cfp(2) + cfv(2))*liftDirection(2) &
!!$                 + (cfp(3) + cfv(3))*liftDirection(3)
!!$            !(1.0/float(ndom))*liftDirection(1)
!!$
!!$            Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$                 + (cfp(2) + cfv(2))*dragDirection(2) &
!!$                 + (cfp(3) + cfv(3))*dragDirection(3)


            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)

            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            !(1.0/float(ndom))*liftDirection(3)!

            nmonsum = 8

            monLoc1(1) = monLoc1(1)+Cl
            monLoc1(2) = monLoc1(2)+Cd
            monLoc1(3) = monLoc1(3)+ cfx
            monLoc1(4) = monLoc1(4)+ cfy
            monLoc1(5) = monLoc1(5)+ cfz
            monLoc1(6) = monLoc1(6)+cmx
            monLoc1(7) = monLoc1(7)+cmy
            monLoc1(8) = monLoc1(8)+cmz


            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.

            call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)

            ! Transfer the cost function values to output arguments.

            CLp  = monGlob1(1)
            if (myid==0)print *,'Clp',clp
            CDp  = monGlob1(2)
            Cfxp = monGlob1(3)
            Cfyp = monGlob1(4)
            Cfzp = monGlob1(5) 
            CMxp = monGlob1(6)
            CMyp = monGlob1(7)
            CMzp = monGlob1(8)


            !*********************
            !Now calculate other perturbation
            alpha = alpharef-deltax
            if (myid==0)print *,'alpha2',alpha
            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !

            do mm=1,nTimeIntervalsSpectral

               ! Compute the time, which corresponds to this spectral solution.
               ! For steady and unsteady mode this is simply the restart time;
               ! for the spectral mode the periodic time must be taken into
               ! account, which can be different for every section.

               t = timeUnsteadyRestart

               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                          /         real(nTimeIntervalsSpectral,realType)
                  enddo
               endif

               call gridVelocitiesFineLevel(.false., t, mm)
               call gridVelocitiesCoarseLevels(mm)
               call normalVelocitiesAllLevels(mm)

               call slipVelocitiesFineLevel(.false., t, mm)
               call slipVelocitiesCoarseLevels(mm)

            enddo
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
            !compute the lift vector update
            call adjustInflowAngleForcesAdj(alpha,beta,velDirFreestream,&
                 liftDir,dragDir,liftIndex)
            !This computation is time dependent for TSStability so update for time instance
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha2',alphaTS,alphaIncrement
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = betaAdj+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!
            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
!!$            !if( myID==0 )print *,'routines complete 2',nn,level,sps
!!$            Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$                 + (cfp(2) + cfv(2))*liftDirection(2) &
!!$                 + (cfp(3) + cfv(3))*liftDirection(3)
!!$            !(1.0/float(ndom))*liftDirection(1)!
!!$
!!$            Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$                 + (cfp(2) + cfv(2))*dragDirection(2) &
!!$                 + (cfp(3) + cfv(3))*dragDirection(3)

            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)

            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            !(1.0/float(ndom))*liftDirection(3)!

            nmonsum = 8

            monLoc2(1) = monLoc2(1)+Cl
            monLoc2(2) = monLoc2(2)+Cd
            monLoc2(3) = monLoc2(3)+cfx
            monLoc2(4) = monLoc2(4)+ cfy
            monLoc2(5) = monLoc2(5)+cfz
            monLoc2(6) = monLoc2(6) +cmx
            monLoc2(7) = monLoc2(7) +cmy
            monLoc2(8) = monLoc2(8)+cmz

            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.

            call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)

            ! Transfer the cost function values to output arguments.

            CLm  = monGlob2(1)
            if (myid==0)print *,'clm',clm
            CDm  = monGlob2(2)
            Cfxm = monGlob2(3)
            Cfym = monGlob2(4)
            Cfzm = monGlob2(5) 
            CMxm = monGlob2(6)
            CMym = monGlob2(7)
            CMzm = monGlob2(8)


            alpha = alpharef

            call adjustinflowangleadjTS(alpha,beta,veldirfreestream,liftdirection,dragdirection,liftindex)
            !print *,'cl',clp,clm
            !valuenew = (CLP-CLM)/(two*deltax) 
            !print *,'testderiv',nn,sps,valuenew,valueold,valuenew-valueold
            !valueold = valuenew 
         enddo domainalphaLoopFDorig
         !if( myID==0 )print *,'setting derivative',nn,level,sps,costFunction,nDesignAoA+1,costfunccl0
         ! Store the correct value based on the cost function
         select case (costFunction)


         case (costFuncLiftCoef,costfunccl0)
            dIdaFD(nDesignAoA+1,sps) = (CLP-CLM)/(two*deltax) 
         case (costFuncDragCoef)
            dIdaFD(nDesignAoA+1,sps) = (CDP-CDM)/(two*deltax) 
         case (costFuncForceXCoef)
            dIdaFD(nDesignAoA+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceYCoef)
            dIdaFD(nDesignAoA+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceZCoef)
            dIdaFD(nDesignAoA+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncMomXCoef)
            dIdaFD(nDesignAoA+1,sps) = (cmxp-cmxm)/(two*deltax)
         case (costFuncMomYCoef)
            dIdaFD(nDesignAoA+1,sps) = (cmyp-cmym)/(two*deltax)
         case (costFuncMomZCoef,costFuncCm0)
            dIdaFD(nDesignAoA+1,sps) = (cmzp-cmzm)/(two*deltax)
         end select
      end do
  
      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
   end if

   if (nDesignssA >= 0) then
      !get reference conditions
      !call getDirAngleTS(velDirFreestream,liftDirection,liftIndex,alpha,beta)
      !print *,'dirangle',liftDirection,beta
      
      print *,'starting beta FD loop',sps
      do sps = 1,nTimeIntervalsSpectral
         monloc1=0.0
         monloc2=0.0
         monGlob1 = 0.0
         monGlob2 = 0.0
         domainbetaLoopFDorig: do nn=1,nDom   

            call setPointers(nn,level,sps)

            !loop over all points
            betaref = beta

            beta = betaref+deltax!*1000

            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !
            !print *,'betaplus', beta
            call adjustinflowangleadjTS(alpha,beta,veldirfreestream,liftdirection,dragdirection,liftindex)

            !call checkInputParam
            !print *,'adjflowangleplus',liftDirection
            do mm=1,nTimeIntervalsSpectral

               ! Compute the time, which corresponds to this spectral solution.
               ! For steady and unsteady mode this is simply the restart time;
               ! for the spectral mode the periodic time must be taken into
               ! account, which can be different for every section.

               t = timeUnsteadyRestart

               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                          /         real(nTimeIntervalsSpectral,realType)
                  enddo
               endif

               call gridVelocitiesFineLevel(.false., t, mm)
               call gridVelocitiesCoarseLevels(mm)
               call normalVelocitiesAllLevels(mm)

               call slipVelocitiesFineLevel(.false., t, mm)
               call slipVelocitiesCoarseLevels(mm)

            enddo
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha2',alphaTS,alphaIncrement
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = betaAdj+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!

            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
            !Cl = (cfp(1) + cfv(1))*liftDirection(1) &
            !     + (cfp(2) + cfv(2))*liftDirection(2) &
            !     + (cfp(3) + cfv(3))*liftDirection(3)
            !! (1.0/float(ndom))*liftDirection(1)!        
            !Cd = (cfp(1) + cfv(1))*dragDirection(1) &
            !     + (cfp(2) + cfv(2))*dragDirection(2) &
            !     + (cfp(3) + cfv(3))*dragDirection(3)
            !(1.0/float(ndom))*liftDirection(2)!

            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)

            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            !(1.0/float(ndom))*liftDirection(3)!      
            nmonsum = 8

            monLoc1(1) = monLoc1(1)+Cl
            monLoc1(2) = monLoc1(2)+Cd
            monLoc1(3) = monLoc1(3)+ cfx
            monLoc1(4) = monLoc1(4)+ cfy
            monLoc1(5) = monLoc1(5)+ cfz
            monLoc1(6) = monLoc1(6)+cmx
            monLoc1(7) = monLoc1(7)+cmy
            monLoc1(8) = monLoc1(8)+cmz


            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.

            call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)

            ! Transfer the cost function values to output arguments.

            CLp  = monGlob1(1)
            CDp  = monGlob1(2)
            Cfxp = monGlob1(3)
            Cfyp = monGlob1(4)
            Cfzp = monGlob1(5) 
            CMxp = monGlob1(6)
            CMyp = monGlob1(7)
            CMzp = monGlob1(8)


            !*********************
            !Now calculate other perturbation
            beta = betaref-deltax!*1000

            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !
            !print *,'betaminus',beta
            call adjustinflowangleadjTS(alpha,beta,veldirfreestream,liftdirection,dragdirection,liftindex)
            !call checkInputParam
            !print *,'adjflowangleminus',liftDirection
            do mm=1,nTimeIntervalsSpectral

               ! Compute the time, which corresponds to this spectral solution.
               ! For steady and unsteady mode this is simply the restart time;
               ! for the spectral mode the periodic time must be taken into
               ! account, which can be different for every section.

               t = timeUnsteadyRestart

               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                          /         real(nTimeIntervalsSpectral,realType)
                  enddo
               endif

               call gridVelocitiesFineLevel(.false., t, mm)
               call gridVelocitiesCoarseLevels(mm)
               call normalVelocitiesAllLevels(mm)

               call slipVelocitiesFineLevel(.false., t, mm)
               call slipVelocitiesCoarseLevels(mm)

            enddo
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha2',alphaTS,alphaIncrement
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = betaAdj+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!

            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
            !Cl = (cfp(1) + cfv(1))*liftDirection(1) &
            !     + (cfp(2) + cfv(2))*liftDirection(2) &
            !     + (cfp(3) + cfv(3))*liftDirection(3)
            !!(1.0/float(ndom))*liftDirection(1)!!
            !
            !Cd = (cfp(1) + cfv(1))*dragDirection(1) &
            !     + (cfp(2) + cfv(2))*dragDirection(2) &
            !     + (cfp(3) + cfv(3))*dragDirection(3)
            !(1.0/float(ndom))*liftDirection(2)!

            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)

            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            ! (1.0/float(ndom))*liftDirection(3)!

            nmonsum = 8

            monLoc2(1) = monLoc2(1)+Cl
            monLoc2(2) = monLoc2(2)+Cd
            monLoc2(3) = monLoc2(3)+cfx
            monLoc2(4) = monLoc2(4)+ cfy
            monLoc2(5) = monLoc2(5)+cfz
            monLoc2(6) =monLoc2(6) +cmx
            monLoc2(7) =monLoc2(7) +cmy
            monLoc2(8) = monLoc2(8)+cmz

            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.

            call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)

            ! Transfer the cost function values to output arguments.

            CLm  = monGlob2(1)
            CDm  = monGlob2(2)
            Cfxm = monGlob2(3)
            Cfym = monGlob2(4)
            Cfzm = monGlob2(5) 
            CMxm = monGlob2(6)
            CMym = monGlob2(7)
            CMzm = monGlob2(8)


            beta = betaref

            call adjustinflowangleadjTS(alpha,beta,veldirfreestream,liftdirection,dragdirection,liftindex)
            !call checkInputParam
          

         enddo domainbetaLoopFDorig
    
         
         ! Store the correct value based on the cost function
         select case (costFunction)

         case (costFuncLiftCoef,costFuncCl0)
            dIdaFD(nDesignSSA+1,sps) = (CLP-CLM)/(two*deltax) 
         case (costFuncDragCoef)
            dIdaFD(nDesignSSA+1,sps) = (CDP-CDM)/(two*deltax) 
         case (costFuncForceXCoef)
            dIdaFD(nDesignSSA+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceYCoef)
            dIdaFD(nDesignSSA+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceZCoef)
            dIdaFD(nDesignSSA+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncMomXCoef)
            dIdaFD(nDesignSSA+1,sps) = (cmxp-cmxm)/(two*deltax)
         case (costFuncMomYCoef)
            dIdaFD(nDesignSSA+1,sps) = (cmyp-cmym)/(two*deltax)
         case (costFuncMomZCoef,costFuncCm0)
            dIdaFD(nDesignSSA+1,sps) = (cmzp-cmzm)/(two*deltax)
         end select
      end do
      
      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
   end if
   alpha = alpharef
   beta = betaref
   if (nDesignPointRefX >= 0) then
     
     
      
      print *,'starting beta FD loop',sps
      do sps = 1,nTimeIntervalsSpectral
         monloc1=0.0
         monloc2=0.0
         monGlob1 = 0.0
         monGlob2 = 0.0
         domainpointrefxLoopFDorig: do nn=1,nDom   

            call setPointers(nn,level,sps)

            !loop over all points
            pointref_ref = pointref(1)

            pointref(1) = pointref_ref+deltax!*1000

            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !
           
            !call checkInputParam
            !print *,'adjflowangleplus',liftDirection
            do mm=1,nTimeIntervalsSpectral

               ! Compute the time, which corresponds to this spectral solution.
               ! For steady and unsteady mode this is simply the restart time;
               ! for the spectral mode the periodic time must be taken into
               ! account, which can be different for every section.

               t = timeUnsteadyRestart

               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                          /         real(nTimeIntervalsSpectral,realType)
                  enddo
               endif

               call gridVelocitiesFineLevel(.false., t, mm)
               call gridVelocitiesCoarseLevels(mm)
               call normalVelocitiesAllLevels(mm)

               call slipVelocitiesFineLevel(.false., t, mm)
               call slipVelocitiesCoarseLevels(mm)

            enddo
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha2',alphaTS,alphaIncrement
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = betaAdj+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!

            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
            !Cl = (cfp(1) + cfv(1))*liftDirection(1) &
            !     + (cfp(2) + cfv(2))*liftDirection(2) &
            !     + (cfp(3) + cfv(3))*liftDirection(3)
            !! (1.0/float(ndom))*liftDirection(1)!        
            !Cd = (cfp(1) + cfv(1))*dragDirection(1) &
            !     + (cfp(2) + cfv(2))*dragDirection(2) &
            !     + (cfp(3) + cfv(3))*dragDirection(3)
            !(1.0/float(ndom))*liftDirection(2)!

            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)

            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            !(1.0/float(ndom))*liftDirection(3)!      
            nmonsum = 8

            monLoc1(1) = monLoc1(1)+Cl
            monLoc1(2) = monLoc1(2)+Cd
            monLoc1(3) = monLoc1(3)+ cfx
            monLoc1(4) = monLoc1(4)+ cfy
            monLoc1(5) = monLoc1(5)+ cfz
            monLoc1(6) = monLoc1(6)+cmx
            monLoc1(7) = monLoc1(7)+cmy
            monLoc1(8) = monLoc1(8)+cmz


            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.

            call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)

            ! Transfer the cost function values to output arguments.

            CLp  = monGlob1(1)
            CDp  = monGlob1(2)
            Cfxp = monGlob1(3)
            Cfyp = monGlob1(4)
            Cfzp = monGlob1(5) 
            CMxp = monGlob1(6)
            CMyp = monGlob1(7)
            CMzp = monGlob1(8)


            !*********************
            !Now calculate other perturbation
            pointref(1) = pointref_ref-deltax!*1000

            !*************************************************************
            !Original force and metric calculation....
            !     ******************************************************************
            !     *                                                                *
            !     * Update the force coefficients using the usual flow solver      *
            !     * routine.                                                       *
            !     *                                                                *
            !     ******************************************************************
            !
            !print *,'adjflowangleminus',liftDirection
            do mm=1,nTimeIntervalsSpectral

               ! Compute the time, which corresponds to this spectral solution.
               ! For steady and unsteady mode this is simply the restart time;
               ! for the spectral mode the periodic time must be taken into
               ! account, which can be different for every section.

               t = timeUnsteadyRestart

               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
                          /         real(nTimeIntervalsSpectral,realType)
                  enddo
               endif

               call gridVelocitiesFineLevel(.false., t, mm)
               call gridVelocitiesCoarseLevels(mm)
               call normalVelocitiesAllLevels(mm)

               call slipVelocitiesFineLevel(.false., t, mm)
               call slipVelocitiesCoarseLevels(mm)

            enddo
            call metric(level)
            call setPointers(nn,level,sps)
            call computeForcesPressureAdj(w,p)
            call applyAllBC(secondHalo)
            call setPointers(nn,level,sps)
            call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
            if(TSStability)then
               
               !update the lift vector and drag vector to account for changing 
               !angles of attack
               
               ! compute the time of this interval
               t = timeUnsteadyRestart
               
               if(equationMode == timeSpectral) then
                  do ll=1,nSections
                     t(ll) = t(ll) + (sps-1)*sections(ll)%timePeriod &
                          /         nTimeIntervalsSpectral*1.0
                  enddo
               endif
               ! Determine the time values of the old and new time level.
               ! It is assumed that the rigid body rotation of the mesh is only
               ! used when only 1 section is present.
               tNew = timeUnsteady + timeUnsteadyRestart
               tOld = tNew - t(1)
               
               
               if(TSpMode.or. TSqMode .or.TSrMode) then
                  ! Compute the rotation matrix of the rigid body rotation as
                  ! well as the rotation point; the latter may vary in time due
                  ! to rigid body translation.
                  
                  call rotMatrixRigidBody(tNew, tOld, rotationMatrix, rotationPoint)
                  
                  liftDirTmp(1) = rotationMatrix(1,1)*liftDir(1) &
                  + rotationMatrix(1,2)*liftDir(2) &
                  + rotationMatrix(1,3)*liftDir(3)
                  liftDirTmp(2) = rotationMatrix(2,1)*liftDir(1) &
                       + rotationMatrix(2,2)*liftDir(2) &
                       + rotationMatrix(2,3)*liftDir(3)
                  liftDirTmp(3) = rotationMatrix(3,1)*liftDir(1) &
                       + rotationMatrix(3,2)*liftDir(2) &
                       + rotationMatrix(3,3)*liftDir(3)
                  dragDirTmp(1) = rotationMatrix(1,1)*dragDir(1) &
                       + rotationMatrix(1,2)*dragDir(2) &
                       + rotationMatrix(1,3)*dragDir(3)
                  dragDirTmp(2) = rotationMatrix(2,1)*dragDir(1) &
                       + rotationMatrix(2,2)*dragDir(2) &
                       + rotationMatrix(2,3)*dragDir(3)
                  dragDirTmp(3) = rotationMatrix(3,1)*dragDir(1) &
                       + rotationMatrix(3,2)*dragDir(2) &
                       + rotationMatrix(3,3)*dragDir(3)
                  
                  liftDir = liftDirTmp
                  dragDir = dragDirTmp
               elseif(tsAlphaMode)then
        
                  !Determine the alpha for this time instance
                  alphaIncrement = TSAlpha(degreePolAlpha,   coefPolAlpha,       &
                       degreeFourAlpha,  omegaFourAlpha,     &
                       cosCoefFourAlpha, sinCoefFourAlpha, t(1))
                  
                  alphaTS = alpha+alphaIncrement
                  !if(myID==0) print *,'alpha2',alphaTS,alphaIncrement
                  !Determine the grid velocity for this alpha
                  !if(myID==0) print *,'liftindex sub2',liftindex
                  call adjustInflowAngleForcesAdj(alphaTS,beta,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  !do I need to update the lift direction and drag direction as well? yes!!!
                  !if(myID==0) print *,'liftDir',liftDir 
               elseif(tsBetaMode)then
                  
                  !Determine the alpha for this time instance
                  betaIncrement = TSBeta(degreePolBeta,   coefPolBeta,       &
                       degreeFourBeta,  omegaFourBeta,     &
                       cosCoefFourBeta, sinCoefFourBeta, t(1))
        
                  betaTS = betaAdj+betaIncrement
                  !if(myID==0) print *,'liftindex sub3',liftindex
                  !Determine the grid velocity for this alpha
                  call adjustInflowAngleForcesAdj(alpha,betaTS,velDirFreestream,liftDir,dragDir,&
                       liftIndex)
                  
               end if
            end if
            !if( myID==0 )print *,'routines complete 2',nn,level,sps
            Cl = (cfp(1) + cfv(1))*liftDir(1) &
                 + (cfp(2) + cfv(2))*liftDir(2) &
                 + (cfp(3) + cfv(3))*liftDir(3)
            !(1.0/float(ndom))*liftDirection(1)!

            Cd = (cfp(1) + cfv(1))*dragDir(1) &
                 + (cfp(2) + cfv(2))*dragDir(2) &
                 + (cfp(3) + cfv(3))*dragDir(3)
            !Cl = (cfp(1) + cfv(1))*liftDirection(1) &
            !     + (cfp(2) + cfv(2))*liftDirection(2) &
            !     + (cfp(3) + cfv(3))*liftDirection(3)
            !!(1.0/float(ndom))*liftDirection(1)!!
            !
            !Cd = (cfp(1) + cfv(1))*dragDirection(1) &
            !     + (cfp(2) + cfv(2))*dragDirection(2) &
            !     + (cfp(3) + cfv(3))*dragDirection(3)
            !(1.0/float(ndom))*liftDirection(2)!

            Cfx = cfp(1) + cfv(1)
            Cfy = cfp(2) + cfv(2)
            Cfz = cfp(3) + cfv(3)

            Cmx = cmp(1) + cmv(1)
            Cmy = cmp(2) + cmv(2)
            Cmz = cmp(3) + cmv(3)
            ! (1.0/float(ndom))*liftDirection(3)!

            nmonsum = 8

            monLoc2(1) = monLoc2(1)+Cl
            monLoc2(2) = monLoc2(2)+Cd
            monLoc2(3) = monLoc2(3)+cfx
            monLoc2(4) = monLoc2(4)+ cfy
            monLoc2(5) = monLoc2(5)+cfz
            monLoc2(6) =monLoc2(6) +cmx
            monLoc2(7) =monLoc2(7) +cmy
            monLoc2(8) = monLoc2(8)+cmz

            ! Determine the global sum of the summation monitoring
            ! variables. The sum is made known to all processors.

            call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
                 mpi_sum, SUmb_comm_world, ierr)

            ! Transfer the cost function values to output arguments.

            CLm  = monGlob2(1)
            CDm  = monGlob2(2)
            Cfxm = monGlob2(3)
            Cfym = monGlob2(4)
            Cfzm = monGlob2(5) 
            CMxm = monGlob2(6)
            CMym = monGlob2(7)
            CMzm = monGlob2(8)


            pointref(1) = pointref_ref

            !print *,'cl',clp,clm
            !valuenew = (CLP-CLM)/(two*deltax) 
            !print *,'testderiv',nn,sps,valuenew,valueold,valuenew-valueold
            !valueold = valuenew         

         enddo domainpointrefxLoopFDorig
    
         
         ! Store the correct value based on the cost function
         select case (costFunction)

         case (costFuncLiftCoef,costFuncCl0)
            dIdaFD(nDesignPointRefX+1,sps) = (CLP-CLM)/(two*deltax) 
         case (costFuncDragCoef)
            dIdaFD(nDesignPointRefX+1,sps) = (CDP-CDM)/(two*deltax) 
         case (costFuncForceXCoef)
            dIdaFD(nDesignPointRefX+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceYCoef)
            dIdaFD(nDesignPointRefX+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncForceZCoef)
            dIdaFD(nDesignPointRefX+1,sps) = (cfxp-cfxm)/(two*deltax)
         case (costFuncMomXCoef)
            dIdaFD(nDesignPointRefX+1,sps) = (cmxp-cmxm)/(two*deltax)
         case (costFuncMomYCoef)
            dIdaFD(nDesignPointRefX+1,sps) = (cmyp-cmym)/(two*deltax)
         case (costFuncMomZCoef,costFuncCm0)
            dIdaFD(nDesignPointRefX+1,sps) = (cmzp-cmzm)/(two*deltax)
         end select
      end do
      
      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
   end if
!!$   if (nDesignrotx >= 0) then
!!$      ! Loop over the number of local blocks.
!!$      
!!$        monloc1=0.0
!!$        monloc2=0.0
!!$      sps=1
!!$      print *,'starting rotx FD loop',sps
!!$      domainrotxLoopFDorig: do nn=1,nDom   
!!$         
!!$         call setPointers(nn,level,sps)
!!$
!!$         !loop over all points
!!$         
!!$         rotratexref = rotrateadj(1)
!!$              
!!$         
!!$         !print *,'mach before',mach,machcoef
!!$         rotrateadj(1)= rotratexref+deltax
!!$        
!!$         cgnsDoms(nbkglobal)%rotRate(1) = RotRateAdj(1)/timeRef
!!$         !print *,'mach after',mach,machcoef
!!$         !*************************************************************
!!$         !Original force and metric calculation....
!!$         !     ******************************************************************
!!$         !     *                                                                *
!!$         !     * Update the force coefficients using the usual flow solver      *
!!$         !     * routine.                                                       *
!!$         !     *                                                                *
!!$         !     ******************************************************************
!!$         !
!!$ 
!!$         call metric(level)
!!$         do mm=1,nTimeIntervalsSpectral
!!$            
!!$            ! Compute the time, which corresponds to this spectral solution.
!!$            ! For steady and unsteady mode this is simply the restart time;
!!$            ! for the spectral mode the periodic time must be taken into
!!$            ! account, which can be different for every section.
!!$            
!!$            t = timeUnsteadyRestart
!!$            
!!$            if(equationMode == timeSpectral) then
!!$               do ll=1,nSections
!!$                  t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
!!$                       /         real(nTimeIntervalsSpectral,realType)
!!$               enddo
!!$            endif
!!$            
!!$            call gridVelocitiesFineLevel(.false., t, mm)
!!$            call gridVelocitiesCoarseLevels(mm)
!!$            call normalVelocitiesAllLevels(mm)
!!$            
!!$            call slipVelocitiesFineLevel(.false., t, mm)
!!$            call slipVelocitiesCoarseLevels(mm)
!!$            
!!$         enddo
!!$         call setPointers(nn,level,sps)
!!$         call computeForcesPressureAdj(w,p)
!!$         call applyAllBC(secondHalo)
!!$         call setPointers(nn,level,sps)
!!$         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
!!$         
!!$         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$              + (cfp(2) + cfv(2))*liftDirection(2) &
!!$              + (cfp(3) + cfv(3))*liftDirection(3)
!!$         
!!$         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$              + (cfp(2) + cfv(2))*dragDirection(2) &
!!$              + (cfp(3) + cfv(3))*dragDirection(3)
!!$         
!!$         Cfx = cfp(1) + cfv(1)
!!$         Cfy = cfp(2) + cfv(2)
!!$         Cfz = cfp(3) + cfv(3)
!!$         
!!$         Cmx = cmp(1) + cmv(1)
!!$         Cmy = cmp(2) + cmv(2)
!!$         Cmz = cmp(3) + cmv(3)
!!$         
!!$         nmonsum = 8
!!$         
!!$         monLoc1(1) =monLoc1(1) + Cl
!!$         monLoc1(2) =monLoc1(2)+ Cd
!!$         monLoc1(3) =monLoc1(3)+ cfx
!!$         monLoc1(4) =monLoc1(4) +cfy
!!$         monLoc1(5) =monLoc1(5) +cfz
!!$         monLoc1(6) =monLoc1(6) +cmx
!!$         monLoc1(7) = monLoc1(7)+ cmy
!!$         monLoc1(8) = monLoc1(8)+cmz
!!$         
!!$         
!!$         ! Determine the global sum of the summation monitoring
!!$         ! variables. The sum is made known to all processors.
!!$         
!!$         call mpi_allreduce(monLoc1, monGlob1, nMonSum, sumb_real, &
!!$              mpi_sum, SUmb_comm_world, ierr)
!!$         
!!$         ! Transfer the cost function values to output arguments.
!!$         
!!$         CLp  = monGlob1(1)
!!$         CDp  = monGlob1(2)
!!$         Cfxp = monGlob1(3)
!!$         Cfyp = monGlob1(4)
!!$         Cfzp = monGlob1(5) 
!!$         CMxp = monGlob1(6)
!!$         CMyp = monGlob1(7)
!!$         CMzp = monGlob1(8)
!!$         
!!$         
!!$         !*********************
!!$         !Now calculate other perturbation
!!$         rotrateadj(1)= rotratexref-deltax
!!$        
!!$         cgnsDoms(nbkglobal)%rotRate(1) = RotRateAdj(1)/timeRef
!!$        
!!$         !*************************************************************
!!$         !Original force and metric calculation....
!!$         !     ******************************************************************
!!$         !     *                                                                *
!!$         !     * Update the force coefficients using the usual flow solver      *
!!$         !     * routine.                                                       *
!!$         !     *                                                                *
!!$         !     ******************************************************************
!!$         !
!!$         
!!$         call metric(level)
!!$         do mm=1,nTimeIntervalsSpectral
!!$            
!!$            ! Compute the time, which corresponds to this spectral solution.
!!$            ! For steady and unsteady mode this is simply the restart time;
!!$            ! for the spectral mode the periodic time must be taken into
!!$            ! account, which can be different for every section.
!!$            
!!$            t = timeUnsteadyRestart
!!$            
!!$            if(equationMode == timeSpectral) then
!!$               do ll=1,nSections
!!$                  t(ll) = t(ll) + (mm-1)*sections(ll)%timePeriod &
!!$                       /         real(nTimeIntervalsSpectral,realType)
!!$               enddo
!!$            endif
!!$            
!!$            call gridVelocitiesFineLevel(.false., t, mm)
!!$            call gridVelocitiesCoarseLevels(mm)
!!$            call normalVelocitiesAllLevels(mm)
!!$            
!!$            call slipVelocitiesFineLevel(.false., t, mm)
!!$            call slipVelocitiesCoarseLevels(mm)
!!$            
!!$         enddo
!!$         call setPointers(nn,level,sps)
!!$         call computeForcesPressureAdj(w,p)
!!$         call applyAllBC(secondHalo)
!!$         call setPointers(nn,level,sps)
!!$         call forcesAndMoments(cFp, cFv, cMp, cMv, yplusMax)
!!$                     
!!$         Cl = (cfp(1) + cfv(1))*liftDirection(1) &
!!$              + (cfp(2) + cfv(2))*liftDirection(2) &
!!$              + (cfp(3) + cfv(3))*liftDirection(3)
!!$         
!!$         Cd = (cfp(1) + cfv(1))*dragDirection(1) &
!!$              + (cfp(2) + cfv(2))*dragDirection(2) &
!!$              + (cfp(3) + cfv(3))*dragDirection(3)
!!$         
!!$         Cfx = cfp(1) + cfv(1)
!!$         Cfy = cfp(2) + cfv(2)
!!$         Cfz = cfp(3) + cfv(3)
!!$         
!!$         Cmx = cmp(1) + cmv(1)
!!$         Cmy = cmp(2) + cmv(2)
!!$         Cmz = cmp(3) + cmv(3)
!!$         
!!$         nmonsum = 8
!!$         
!!$         monLoc2(1) = monLoc2(1)+Cl
!!$         monLoc2(2) = monLoc2(2)+Cd
!!$         monLoc2(3) = monLoc2(3)+cfx
!!$         monLoc2(4) = monLoc2(4)+cfy
!!$         monLoc2(5) = monLoc2(5)+cfz
!!$         monLoc2(6) = monLoc2(6)+cmx
!!$         monLoc2(7) = monLoc2(7)+cmy
!!$         monLoc2(8) = monLoc2(8)+cmz
!!$         
!!$         ! Determine the global sum of the summation monitoring
!!$         ! variables. The sum is made known to all processors.
!!$         
!!$         call mpi_allreduce(monLoc2, monGlob2, nMonSum, sumb_real, &
!!$              mpi_sum, SUmb_comm_world, ierr)
!!$         
!!$         ! Transfer the cost function values to output arguments.
!!$         
!!$         CLm  = monGlob2(1)
!!$         CDm  = monGlob2(2)
!!$         Cfxm = monGlob2(3)
!!$         Cfym = monGlob2(4)
!!$         Cfzm = monGlob2(5) 
!!$         CMxm = monGlob2(6)
!!$         CMym = monGlob2(7)
!!$         CMzm = monGlob2(8)
!!$         
!!$         rotrateadj(1)= rotratexref
!!$         
!!$         cgnsDoms(nbkglobal)%rotRate(1) = RotRateAdj(1)/timeRef
!!$         
!!$         !print *,'clp',CLP,CLM,CLP-CLM
!!$         dCLdextraFD(ndesignrotx) = (CLP-CLM)/(two*deltax)  
!!$         dCDdextraFD(ndesignrotx) = (CDP-CDM)/(two*deltax) 
!!$         dcmdextrafd(ndesignrotx) = (cmzp-cmzm)/(two*deltax)
!!$         !dCmxdxFD = (CmxP-CmxM)/(two*deltax) 
!!$        
!!$      enddo domainrotxLoopFDorig
!!$  endif

      ! Get new time and compute the elapsed FD time.

      call mpi_barrier(SUmb_comm_world, ierr)
      if(myID == 0) then
        call cpu_time(time(4))
        timeFD = time(4)-time(3)
      endif
!
!     ******************************************************************
!     *                                                                *
!     * Output debug information.                                      *
!     *                                                                *
!     ******************************************************************
!
 
  ! Flush the output buffer and synchronize the processors.
  
  call f77flush()
  call mpi_barrier(SUmb_comm_world, ierr)
  
  ! Output elapsed time for the adjoint and FD computations.
  
  if( myID==0 ) then
     print *, "====================================================="
     print *, " Time for reverse mode       =", timeAdj
     print *, " Time for finite differences =", timeFD
     print *, " Factor                      =", timeFD/timeAdj
     print *, "====================================================="
  endif

!
!     ******************************************************************
!     *                                                                *
!     * Compute the errors in dCf/dx.                                   *
!     *                                                                *
!     ******************************************************************
!


      ! Flush the output buffer and synchronize the processors.
  if( myID==0 ) then
      dIdaError = dIdaGlob-dIdaFD
     
      do sps = 1,nTimeIntervalsSpectral
         do i=1,nDesignExtra
            print *,'i',i,sps
            print *,'dcdextra',i,dIdaError(i,sps), dIdaGlob(i,sps),dIdaFD(i,sps)
         end do
      enddo
   end if

      
      call f77flush()
      call mpi_barrier(SUmb_comm_world, ierr)
!
!     ******************************************************************
!
      
      deallocate(monLoc1, monGlob1)
      deallocate(monLoc2, monGlob2)
      deallocate(dIdaFD)
      deallocate(dIdaError)
      deallocate(dIdaGlob)

      close(unitdw)
      close(unitdx)
      ! Output formats.

  10  format(1x,a,1x,i3,1x,i3,1x,a,1x,i3,1x,i3,1x,i3)           
  20  format(1x,(e18.6),2x,(e18.6),2x,(e18.6))
  30  format(1x,a,1x,i3,2x,e13.6,1x,5(i2,1x),3x,e13.6,1x,5(i2,1x))
#endif
#endif
    end subroutine verifydCfdx

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of boundarynormals in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *si *sj *sk *(*bcdata.norm)
!   with respect to varying inputs: *si *sj *sk
!   plus diff mem management of: si:in sj:in sk:in bcdata:in *bcdata.norm:in
subroutine boundarynormals_b()
! **************************************************************
! *                                                            *
! * the unit normals on the boundary faces. these always point *
! * out of the domain, so a multiplication by -1 is needed for *
! * the imin, jmin and kmin boundaries.                        *
! *                                                            *
! **************************************************************
!
  use blockpointers
  use cgnsgrid
  use communication
  use inputtimespectral
  implicit none
! local variables.
  integer(kind=inttype) :: i, j, ii
  integer(kind=inttype) :: mm
  real(kind=realtype) :: fact, mult
  real(kind=realtype) :: factd
  real(kind=realtype) :: xxp, yyp, zzp
  real(kind=realtype) :: xxpd, yypd, zzpd
  intrinsic mod
  intrinsic sqrt
  integer :: branch
  real(kind=realtype) :: tempd
  zzpd = 0.0_8
  yypd = 0.0_8
  xxpd = 0.0_8
  do mm=1,nbocos
    call pushinteger4(i)
    call pushreal8(fact)
    call pushreal8(mult)
    call pushreal8(zzp)
    call pushreal8(yyp)
    call pushreal8(xxp)
    call pushinteger4(mm)
! loop over the boundary faces of the subface.
    do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&       bcdata(mm)%icbeg+1)-1
      i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm)%&
&       icbeg
      j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
      select case  (bcfaceid(mm)) 
      case (imin) 
        mult = -one
        xxp = si(1, i, j, 1)
        yyp = si(1, i, j, 2)
        zzp = si(1, i, j, 3)
      case (imax) 
        mult = one
        xxp = si(il, i, j, 1)
        yyp = si(il, i, j, 2)
        zzp = si(il, i, j, 3)
      case (jmin) 
        mult = -one
        xxp = sj(i, 1, j, 1)
        yyp = sj(i, 1, j, 2)
        zzp = sj(i, 1, j, 3)
      case (jmax) 
        mult = one
        xxp = sj(i, jl, j, 1)
        yyp = sj(i, jl, j, 2)
        zzp = sj(i, jl, j, 3)
      case (kmin) 
        mult = -one
        xxp = sk(i, j, 1, 1)
        yyp = sk(i, j, 1, 2)
        zzp = sk(i, j, 1, 3)
      case (kmax) 
        mult = one
        xxp = sk(i, j, kl, 1)
        yyp = sk(i, j, kl, 2)
        zzp = sk(i, j, kl, 3)
      end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
      fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
      if (fact .gt. zero) fact = mult/fact
! compute the unit normal.
      bcdata(mm)%norm(i, j, 1) = fact*xxp
      bcdata(mm)%norm(i, j, 2) = fact*yyp
      bcdata(mm)%norm(i, j, 3) = fact*zzp
    end do
    call popinteger4(mm)
    call lookreal8(xxp)
    call lookreal8(yyp)
    call lookreal8(zzp)
    call lookreal8(mult)
    do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&       bcdata(mm)%icbeg+1)-1
      i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm)%&
&       icbeg
      j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
      select case  (bcfaceid(mm)) 
      case (imin) 
        mult = -one
        xxp = si(1, i, j, 1)
        yyp = si(1, i, j, 2)
        zzp = si(1, i, j, 3)
        call pushcontrol3b(1)
      case (imax) 
        mult = one
        xxp = si(il, i, j, 1)
        yyp = si(il, i, j, 2)
        zzp = si(il, i, j, 3)
        call pushcontrol3b(2)
      case (jmin) 
        mult = -one
        xxp = sj(i, 1, j, 1)
        yyp = sj(i, 1, j, 2)
        zzp = sj(i, 1, j, 3)
        call pushcontrol3b(3)
      case (jmax) 
        mult = one
        xxp = sj(i, jl, j, 1)
        yyp = sj(i, jl, j, 2)
        zzp = sj(i, jl, j, 3)
        call pushcontrol3b(4)
      case (kmin) 
        mult = -one
        xxp = sk(i, j, 1, 1)
        yyp = sk(i, j, 1, 2)
        zzp = sk(i, j, 1, 3)
        call pushcontrol3b(5)
      case (kmax) 
        mult = one
        xxp = sk(i, j, kl, 1)
        yyp = sk(i, j, kl, 2)
        zzp = sk(i, j, kl, 3)
        call pushcontrol3b(6)
      case default
        call pushcontrol3b(0)
      end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
      fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
      if (fact .gt. zero) then
        call pushreal8(fact)
        fact = mult/fact
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      factd = zzp*bcdatad(mm)%norm(i, j, 3)
      zzpd = zzpd + fact*bcdatad(mm)%norm(i, j, 3)
      bcdatad(mm)%norm(i, j, 3) = 0.0_8
      factd = factd + yyp*bcdatad(mm)%norm(i, j, 2)
      yypd = yypd + fact*bcdatad(mm)%norm(i, j, 2)
      bcdatad(mm)%norm(i, j, 2) = 0.0_8
      factd = factd + xxp*bcdatad(mm)%norm(i, j, 1)
      xxpd = xxpd + fact*bcdatad(mm)%norm(i, j, 1)
      bcdatad(mm)%norm(i, j, 1) = 0.0_8
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        call popreal8(fact)
        factd = -(mult*factd/fact**2)
      end if
      if (xxp**2 + yyp**2 + zzp**2 .eq. 0.0_8) then
        tempd = 0.0
      else
        tempd = factd/(2.0*sqrt(xxp**2+yyp**2+zzp**2))
      end if
      xxpd = xxpd + 2*xxp*tempd
      yypd = yypd + 2*yyp*tempd
      zzpd = zzpd + 2*zzp*tempd
      call popcontrol3b(branch)
      if (branch .lt. 3) then
        if (branch .ne. 0) then
          if (branch .eq. 1) then
            sid(1, i, j, 3) = sid(1, i, j, 3) + zzpd
            sid(1, i, j, 2) = sid(1, i, j, 2) + yypd
            sid(1, i, j, 1) = sid(1, i, j, 1) + xxpd
            zzpd = 0.0_8
            yypd = 0.0_8
            xxpd = 0.0_8
          else
            sid(il, i, j, 3) = sid(il, i, j, 3) + zzpd
            sid(il, i, j, 2) = sid(il, i, j, 2) + yypd
            sid(il, i, j, 1) = sid(il, i, j, 1) + xxpd
            zzpd = 0.0_8
            yypd = 0.0_8
            xxpd = 0.0_8
          end if
        end if
      else if (branch .lt. 5) then
        if (branch .eq. 3) then
          sjd(i, 1, j, 3) = sjd(i, 1, j, 3) + zzpd
          sjd(i, 1, j, 2) = sjd(i, 1, j, 2) + yypd
          sjd(i, 1, j, 1) = sjd(i, 1, j, 1) + xxpd
          zzpd = 0.0_8
          yypd = 0.0_8
          xxpd = 0.0_8
        else
          sjd(i, jl, j, 3) = sjd(i, jl, j, 3) + zzpd
          sjd(i, jl, j, 2) = sjd(i, jl, j, 2) + yypd
          sjd(i, jl, j, 1) = sjd(i, jl, j, 1) + xxpd
          zzpd = 0.0_8
          yypd = 0.0_8
          xxpd = 0.0_8
        end if
      else if (branch .eq. 5) then
        skd(i, j, 1, 3) = skd(i, j, 1, 3) + zzpd
        skd(i, j, 1, 2) = skd(i, j, 1, 2) + yypd
        skd(i, j, 1, 1) = skd(i, j, 1, 1) + xxpd
        zzpd = 0.0_8
        yypd = 0.0_8
        xxpd = 0.0_8
      else
        skd(i, j, kl, 3) = skd(i, j, kl, 3) + zzpd
        skd(i, j, kl, 2) = skd(i, j, kl, 2) + yypd
        skd(i, j, kl, 1) = skd(i, j, kl, 1) + xxpd
        zzpd = 0.0_8
        yypd = 0.0_8
        xxpd = 0.0_8
      end if
    end do
    call popreal8(xxp)
    call popreal8(yyp)
    call popreal8(zzp)
    call popreal8(mult)
    call popreal8(fact)
    call popinteger4(i)
  end do
end subroutine boundarynormals_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!      ******************************************************************
!      *                                                                *
!      * file:          bcroutines.f90                                   *
!      * author:        gaetan k. w. kenway                             *
!      * starting date: 01-23-2015                                      *
!      * last modified: 01-23-2015                                      *
!      *                                                                *
!      ******************************************************************
!
!      ******************************************************************
!      *                                                                *
!      * this module contains data structures *and* routines used       *
!      * for applying *all* boundary conditions for navier stokes part  *
!      * of the code. the reason for using a module to contain the      *
!      * routines is that due to the use of pointers, it eliminates the *
!      * need for using interfaces. all former bc*.f90 routines are now *
!      * included in this module.                                       *
!      *                                                                *
!      ******************************************************************
!
module bcroutines_b
  use constants
  implicit none
  save 
  real(kind=realtype), dimension(:, :, :), allocatable :: ww0, ww1, ww2&
& , ww3
  real(kind=realtype), dimension(:, :, :), allocatable :: ww0d, ww1d, &
& ww2d, ww3d
  real(kind=realtype), dimension(:, :), allocatable :: pp0, pp1, pp2, &
& pp3
  real(kind=realtype), dimension(:, :), allocatable :: pp0d, pp1d, pp2d&
& , pp3d
  real(kind=realtype), dimension(:, :), allocatable :: rlv0, rlv1, rlv2&
& , rlv3
  real(kind=realtype), dimension(:, :), allocatable :: rlv0d, rlv1d, &
& rlv2d, rlv3d
  real(kind=realtype), dimension(:, :), allocatable :: rev0, rev1, rev2&
& , rev3
  real(kind=realtype), dimension(:, :), allocatable :: rev0d, rev1d, &
& rev2d, rev3d
  real(kind=realtype), dimension(:, :), allocatable :: gamma0, gamma1, &
& gamma2, gamma3
  real(kind=realtype), dimension(:, :, :), allocatable :: ssi, xx
  real(kind=realtype), dimension(:, :, :), allocatable :: ssid, xxd
  integer(kind=inttype) :: istart, iend, isize
  integer(kind=inttype) :: jstart, jend, jsize

contains
!  differentiation of applyallbc_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: gammainf winf pinfcorr rgas
!                *rev *p *w *rlv *x *si *sj *sk *xx *rev0 *rev1
!                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
!                *rlv3 *ssi *ww0 *ww1 *ww2 *ww3
!   with respect to varying inputs: gammainf winf pinfcorr rgas
!                *rev *p *w *rlv *x *si *sj *sk *(*bcdata.norm)
!                *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2 *pp3
!                *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2 *ww3
!   plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
!                sj:in sk:in bcdata:in *bcdata.norm:in xx:in rev0:in
!                rev1:in rev2:in rev3:in pp0:in pp1:in pp2:in pp3:in
!                rlv0:in rlv1:in rlv2:in rlv3:in ssi:in ww0:in
!                ww1:in ww2:in ww3:in
  subroutine applyallbc_block_b(secondhalo)
! apply bc's for a single block
    use blockpointers
    use flowvarrefstate
    use inputdiscretization
    use inputtimespectral
    use iteration
    use bctypes
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
! local variables.
    logical :: correctfork
    integer(kind=inttype) :: nn
    integer :: ii1
!
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .le. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
    call pushreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call pushreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma&
&                 , 3))
    call pushreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call pushreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call pushreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call pushreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si&
&                 , 4))
    call pushreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj&
&                 , 4))
    call pushreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk&
&                 , 4))
    call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call pushreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
! apply all the boundary conditions. the order is important!  only
! some of them have been ad'ed
! ------------------------------------
!  symmetry boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers(nn, .false.)
        call bcsymm(nn, secondhalo)
        call resetbcpointers(nn, .false.)
      end if
    end do
    call pushinteger4(jstart)
    call pushinteger4(isize)
    call pushinteger4(jsize)
    call pushinteger4(istart)
    call pushreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call pushreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call pushreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma&
&                 , 3))
    call pushreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call pushreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call pushreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call pushreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si&
&                 , 4))
    call pushreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj&
&                 , 4))
    call pushreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk&
&                 , 4))
    call pushreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call pushreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
! ------------------------------------
!  adibatic wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers(nn, .false.)
        call bcnswalladiabatic(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
    call pushinteger4(jstart)
    call pushinteger4(isize)
    call pushinteger4(jsize)
    call pushinteger4(istart)
    call pushreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call pushreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call pushreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma&
&                 , 3))
    call pushreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call pushreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call pushreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call pushreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si&
&                 , 4))
    call pushreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj&
&                 , 4))
    call pushreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk&
&                 , 4))
    call pushreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call pushreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
! ------------------------------------
!  isotermal wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers(nn, .false.)
        call bcnswallisothermal(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
    call pushinteger4(jstart)
    call pushinteger4(isize)
    call pushinteger4(jsize)
    call pushinteger4(istart)
    call pushreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call pushreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call pushreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma&
&                 , 3))
    call pushreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call pushreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call pushreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call pushreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si&
&                 , 4))
    call pushreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj&
&                 , 4))
    call pushreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk&
&                 , 4))
    call pushreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call pushreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call pushreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers(nn, .false.)
        call bcfarfield(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
    call pushreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call pushinteger4(jstart)
    call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call pushinteger4(isize)
    call pushinteger4(jsize)
    call pushinteger4(istart)
    call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call pushreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    do ii1=1,size(bcdatad)
      bcdatad(ii1)%norm = 0.0_8
    end do
    do nn=1,nbocos
      if (bctype(nn) .eq. eulerwall) then
        call setbcpointers(nn, .true.)
        call resetbcpointers_b(nn, .true.)
        call bceulerwall_b(nn, secondhalo, correctfork)
        call setbcpointers_b(nn, .true.)
      end if
    end do
    call popreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call popinteger4(istart)
    call popinteger4(jsize)
    call popinteger4(isize)
    call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call popinteger4(jstart)
    call popreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call popreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call popreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call popreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call popreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk, &
&                4))
    call popreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj, &
&                4))
    call popreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si, &
&                4))
    call popreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call popreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call popreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call popreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma, &
&                3))
    call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call popreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call lookreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call lookreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers(nn, .false.)
        call resetbcpointers_b(nn, .false.)
        call bcfarfield_b(nn, secondhalo, correctfork)
        call setbcpointers_b(nn, .false.)
      end if
    end do
    call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call popreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call popinteger4(istart)
    call popinteger4(jsize)
    call popinteger4(isize)
    call popinteger4(jstart)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call popreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call popreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call popreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk, &
&                4))
    call popreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj, &
&                4))
    call popreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si, &
&                4))
    call popreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call popreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call popreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call popreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma, &
&                3))
    call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call popreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call lookreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call lookreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers(nn, .false.)
        call resetbcpointers_b(nn, .false.)
        call bcnswallisothermal_b(nn, secondhalo, correctfork)
        call setbcpointers_b(nn, .false.)
      end if
    end do
    call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call popreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call popinteger4(istart)
    call popinteger4(jsize)
    call popinteger4(isize)
    call popinteger4(jstart)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call popreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call popreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call popreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk, &
&                4))
    call popreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj, &
&                4))
    call popreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si, &
&                4))
    call popreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call popreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call popreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call popreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma, &
&                3))
    call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call popreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call lookreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers(nn, .false.)
        call resetbcpointers_b(nn, .false.)
        call bcnswalladiabatic_b(nn, secondhalo, correctfork)
        call setbcpointers_b(nn, .false.)
      end if
    end do
    call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call popreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call popinteger4(istart)
    call popinteger4(jsize)
    call popinteger4(isize)
    call popinteger4(jstart)
    call popreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call popreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk, &
&                4))
    call popreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj, &
&                4))
    call popreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si, &
&                4))
    call popreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4))
    call popreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call popreal8array(w, size(w, 1)*size(w, 2)*size(w, 3)*size(w, 4))
    call popreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma, &
&                3))
    call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call popreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers(nn, .false.)
        call resetbcpointers_b(nn, .false.)
        call bcsymm_b(nn, secondhalo)
        call setbcpointers_b(nn, .false.)
      end if
    end do
  end subroutine applyallbc_block_b
  subroutine applyallbc_block(secondhalo)
! apply bc's for a single block
    use blockpointers
    use flowvarrefstate
    use inputdiscretization
    use inputtimespectral
    use iteration
    use bctypes
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
! local variables.
    logical :: correctfork
    integer(kind=inttype) :: nn
!
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .le. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
! apply all the boundary conditions. the order is important!  only
! some of them have been ad'ed
! ------------------------------------
!  symmetry boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers(nn, .false.)
        call bcsymm(nn, secondhalo)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  adibatic wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers(nn, .false.)
        call bcnswalladiabatic(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  isotermal wall boundary condition 
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers(nn, .false.)
        call bcnswallisothermal(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  farfield boundary condition 
! ------------------------------------
    if (precond .eq. turkel .or. precond .eq. choimerkle) call &
&     returnfail('applyallbc', &
&      'farfield turkel and coid/merkle preconditioners not implemented'&
&            )
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers(nn, .false.)
        call bcfarfield(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  euler wall boundary condition 
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. eulerwall) then
        call setbcpointers(nn, .true.)
        call bceulerwall(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .true.)
      end if
    end do
  end subroutine applyallbc_block
!  differentiation of bcsymm in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*bcdata.norm) *rev0 *rev1
!                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
!                *rlv3 *ww0 *ww1 *ww2 *ww3
!   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
!                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
!                *rlv3 *ww0 *ww1 *ww2 *ww3
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
!                rev1:in rev2:in rev3:in pp0:in pp1:in pp2:in pp3:in
!                rlv0:in rlv1:in rlv2:in rlv3:in ww0:in ww1:in
!                ww2:in ww3:in
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm_b(nn, secondhalo)
!
! ******************************************************************
! *                                                                *
! * bcsymm applies the symmetry boundary conditions to a block.    *
! * it is assumed that the pointers in blockpointers are already   *
! * set to the correct block on the correct grid level.            *
! *                                                                *
! * in case also the second halo must be set the loop over the     *
! * boundary subfaces is executed twice. this is the only correct  *
! * way in case the block contains only 1 cell between two         *
! * symmetry planes, i.e. a 2d problem.                            *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
    if (secondhalo) then
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(vn)
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
&         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
&         , 3))
! determine the flow variables in the halo cell.
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
        if (viscous) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (eddymodel) then
          rev3d(i, j) = rev3d(i, j) + rev0d(i, j)
          rev0d(i, j) = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rlv3d(i, j) = rlv3d(i, j) + rlv0d(i, j)
          rlv0d(i, j) = 0.0_8
        end if
        pp3d(i, j) = pp3d(i, j) + pp0d(i, j)
        pp0d(i, j) = 0.0_8
        do l=nt1mg,nt2mg
          ww3d(i, j, l) = ww3d(i, j, l) + ww0d(i, j, l)
          ww0d(i, j, l) = 0.0_8
        end do
        ww3d(i, j, irhoe) = ww3d(i, j, irhoe) + ww0d(i, j, irhoe)
        ww0d(i, j, irhoe) = 0.0_8
        ww3d(i, j, ivz) = ww3d(i, j, ivz) + ww0d(i, j, ivz)
        vnd = -(bcdata(nn)%norm(i, j, 3)*ww0d(i, j, ivz))
        bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww0d(&
&         i, j, ivz)
        ww0d(i, j, ivz) = 0.0_8
        ww3d(i, j, ivy) = ww3d(i, j, ivy) + ww0d(i, j, ivy)
        vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww0d(i, j, ivy)
        bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww0d(&
&         i, j, ivy)
        ww0d(i, j, ivy) = 0.0_8
        ww3d(i, j, ivx) = ww3d(i, j, ivx) + ww0d(i, j, ivx)
        vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww0d(i, j, ivx)
        bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww0d(&
&         i, j, ivx)
        ww0d(i, j, ivx) = 0.0_8
        ww3d(i, j, irho) = ww3d(i, j, irho) + ww0d(i, j, irho)
        ww0d(i, j, irho) = 0.0_8
        tempd0 = two*vnd
        ww3d(i, j, ivx) = ww3d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*&
&         tempd0
        bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww3(i, j&
&         , ivx)*tempd0
        ww3d(i, j, ivy) = ww3d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*&
&         tempd0
        bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww3(i, j&
&         , ivy)*tempd0
        ww3d(i, j, ivz) = ww3d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*&
&         tempd0
        bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww3(i, j&
&         , ivz)*tempd0
      end do
      call popreal8(vn)
      call popinteger4(j)
      call popinteger4(i)
    end if
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
        rlv1d(i, j) = 0.0_8
      end if
      pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
      pp1d(i, j) = 0.0_8
      do l=nt1mg,nt2mg
        ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
        ww1d(i, j, l) = 0.0_8
      end do
      ww2d(i, j, irhoe) = ww2d(i, j, irhoe) + ww1d(i, j, irhoe)
      ww1d(i, j, irhoe) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + ww1d(i, j, ivz)
      vnd = -(bcdata(nn)%norm(i, j, 3)*ww1d(i, j, ivz))
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww1d(i&
&       , j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + ww1d(i, j, ivy)
      vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww1d(i, j, ivy)
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww1d(i&
&       , j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + ww1d(i, j, ivx)
      vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww1d(i, j, ivx)
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww1d(i&
&       , j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
      ww1d(i, j, irho) = 0.0_8
      tempd = two*vnd
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*tempd
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww2(i, j, &
&       ivx)*tempd
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*tempd
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww2(i, j, &
&       ivy)*tempd
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*tempd
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww2(i, j, &
&       ivz)*tempd
    end do
  end subroutine bcsymm_b
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm(nn, secondhalo)
!
! ******************************************************************
! *                                                                *
! * bcsymm applies the symmetry boundary conditions to a block.    *
! * it is assumed that the pointers in blockpointers are already   *
! * set to the correct block on the correct grid level.            *
! *                                                                *
! * in case also the second halo must be set the loop over the     *
! * boundary subfaces is executed twice. this is the only correct  *
! * way in case the block contains only 1 cell between two         *
! * symmetry planes, i.e. a 2d problem.                            *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! loop over the generic subface to set the state in the
! 1-st level halos 
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! simply copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(i, j, l) = ww2(i, j, l)
      end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma1(i, j) = gamma2(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
    if (secondhalo) then
! if we need the second halo, do everything again, but using ww0,
! ww3 etc instead of ww2 and ww1. 
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
&         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
&         , 3))
! determine the flow variables in the halo cell.
        ww0(i, j, irho) = ww3(i, j, irho)
        ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
        ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
        ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
        ww0(i, j, irhoe) = ww3(i, j, irhoe)
        do l=nt1mg,nt2mg
          ww0(i, j, l) = ww3(i, j, l)
        end do
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
        gamma0(i, j) = gamma3(i, j)
        pp0(i, j) = pp3(i, j)
        if (viscous) rlv0(i, j) = rlv3(i, j)
        if (eddymodel) rev0(i, j) = rev3(i, j)
      end do
    end if
  end subroutine bcsymm
!  differentiation of bcnswalladiabatic in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   plus diff mem management of: bcdata:in rev0:in rev1:in rev2:in
!                pp0:in pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in
!                ww1:in ww2:in
  subroutine bcnswalladiabatic_b(nn, secondhalo, correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * bcnswalladiabatic applies the viscous adiabatic wall           *
!      * boundary condition the pointers already defined.               *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    real(kind=realtype) :: rhokd
    intrinsic mod
    integer :: branch
! apply the bcwall in case the turbulent transport equations are
! solved together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.  no need
! to extrapolate the secondary halo's, because this is done in
! extrapolate2ndhalo. this is only necesssary when correcting for
! k. *this is not currently included in ad. it will be required
! for the 2-equation turbulence models. 
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    rhokd = 0.0_8
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
      rlv1d(i, j) = 0.0_8
      pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
      rhokd = rhokd - four*third*pp1d(i, j)
      pp1d(i, j) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
      ww1d(i, j, irho) = 0.0_8
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
        ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
        rhokd = 0.0_8
      end if
    end do
  end subroutine bcnswalladiabatic_b
  subroutine bcnswalladiabatic(nn, secondhalo, correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * bcnswalladiabatic applies the viscous adiabatic wall           *
!      * boundary condition the pointers already defined.               *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    intrinsic mod
! apply the bcwall in case the turbulent transport equations are
! solved together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.  no need
! to extrapolate the secondary halo's, because this is done in
! extrapolate2ndhalo. this is only necesssary when correcting for
! k. *this is not currently included in ad. it will be required
! for the 2-equation turbulence models. 
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswalladiabatic
!  differentiation of bcnswallisothermal in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: rgas *rev0 *rev1 *rev2 *pp0
!                *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: rgas *rev0 *rev1 *rev2 *pp0
!                *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   plus diff mem management of: bcdata:in rev0:in rev1:in rev2:in
!                pp0:in pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in
!                ww1:in ww2:in
  subroutine bcnswallisothermal_b(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bcnswalladiabatic applies the viscous isothermal wall          *
! * boundary condition to a block. it is assumed that the          *
! * bcpointers are already set                                     *
! *                                                                *
! ******************************************************************
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok, t2, t1
    real(kind=realtype) :: rhokd, t2d, t1d
    intrinsic mod
    intrinsic max
    intrinsic min
    integer :: branch
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! in case the turbulent transport equations are solved
! together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.
! no need to extrapolate the secondary halo's, because this
! is done in extrapolate2ndhalo.
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call pushreal8(rhok)
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1(i, j) = pp2(i, j) - four*third*rhok
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    rhokd = 0.0_8
    call popreal8(rhok)
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        rhok = ww2(i, j, irho)*ww2(i, j, itu1)
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        call pushcontrol1b(0)
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
        call pushcontrol1b(1)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        call pushcontrol1b(0)
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
        call pushcontrol1b(1)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1(i, j) = pp2(i, j) - four*third*rhok
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
      rlv1d(i, j) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      tempd0 = ww1d(i, j, irho)/(rgas*t1)
      tempd1 = -(pp1(i, j)*tempd0/(rgas*t1))
      pp1d(i, j) = pp1d(i, j) + tempd0
      rgasd = rgasd + t1*tempd1
      t1d = rgas*tempd1
      ww1d(i, j, irho) = 0.0_8
      pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
      rhokd = rhokd - four*third*pp1d(i, j)
      pp1d(i, j) = 0.0_8
      call popcontrol1b(branch)
      if (branch .ne. 0) t1d = 0.0_8
      call popcontrol1b(branch)
      if (branch .ne. 0) t1d = 0.0_8
      t2d = -t1d
      temp = rgas*ww2(i, j, irho)
      tempd = -(pp2(i, j)*t2d/temp**2)
      pp2d(i, j) = pp2d(i, j) + t2d/temp
      rgasd = rgasd + ww2(i, j, irho)*tempd
      ww2d(i, j, irho) = ww2d(i, j, irho) + rgas*tempd
      call popcontrol1b(branch)
      if (branch .ne. 0) then
        ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
        ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
        rhokd = 0.0_8
      end if
    end do
  end subroutine bcnswallisothermal_b
  subroutine bcnswallisothermal(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bcnswalladiabatic applies the viscous isothermal wall          *
! * boundary condition to a block. it is assumed that the          *
! * bcpointers are already set                                     *
! *                                                                *
! ******************************************************************
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok, t2, t1
    intrinsic mod
    intrinsic max
    intrinsic min
! in case the turbulent transport equations are solved
! together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.
! no need to extrapolate the secondary halo's, because this
! is done in extrapolate2ndhalo.
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      pp1(i, j) = pp2(i, j) - four*third*rhok
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswallisothermal
!  differentiation of bceulerwall in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*bcdata.norm) *rev0 *rev1
!                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0
!                *ww1 *ww2
!   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
!                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0
!                *ww1 *ww2
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
!                rev1:in rev2:in pp0:in pp1:in pp2:in pp3:in rlv0:in
!                rlv1:in rlv2:in ww0:in ww1:in ww2:in
  subroutine bceulerwall_b(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bceulerwall applies the inviscid wall boundary condition to    *
! * a block. it is assumed that the bcpointers are                 *
! * already set to the correct block on the correct grid level.    *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: vnd
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: gradd
    intrinsic mod
    real(kind=realtype) :: dim
    integer :: branch
    real(kind=realtype) :: tempd
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = wallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
! **************************************************************
! *                                                            *
! * determine the boundary condition treatment and compute the *
! * undivided pressure gradient accordingly. this gradient is  *
! * temporarily stored in the halo pressure.                   *
! *                                                            *
! **************************************************************
!
    select case  (walltreatment) 
    case (constantpressure) 
      call pushcontrol1b(1)
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation. 
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
      call pushcontrol1b(0)
    case default
      call pushcontrol1b(1)
    end select
    call pushinteger4(j)
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = dim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! just copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(j, k, l) = ww2(j, k, l)
      end do
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    gradd = 0.0_8
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
! the laminar and eddy viscosity, if present.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev2d(j, k) = rev2d(j, k) + rev1d(j, k)
        rev1d(j, k) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv2d(j, k) = rlv2d(j, k) + rlv1d(j, k)
        rlv1d(j, k) = 0.0_8
      end if
      do l=nt2mg,nt1mg,-1
        ww2d(j, k, l) = ww2d(j, k, l) + ww1d(j, k, l)
        ww1d(j, k, l) = 0.0_8
      end do
      ww2d(j, k, ivz) = ww2d(j, k, ivz) + ww1d(j, k, ivz)
      vnd = bcdata(nn)%norm(j, k, 3)*ww1d(j, k, ivz)
      bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) + vn*ww1d(j&
&       , k, ivz)
      ww1d(j, k, ivz) = 0.0_8
      ww2d(j, k, ivy) = ww2d(j, k, ivy) + ww1d(j, k, ivy)
      vnd = vnd + bcdata(nn)%norm(j, k, 2)*ww1d(j, k, ivy)
      bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) + vn*ww1d(j&
&       , k, ivy)
      ww1d(j, k, ivy) = 0.0_8
      ww2d(j, k, ivx) = ww2d(j, k, ivx) + ww1d(j, k, ivx)
      vnd = vnd + bcdata(nn)%norm(j, k, 1)*ww1d(j, k, ivx)
      bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) + vn*ww1d(j&
&       , k, ivx)
      ww1d(j, k, ivx) = 0.0_8
      ww2d(j, k, irho) = ww2d(j, k, irho) + ww1d(j, k, irho)
      ww1d(j, k, irho) = 0.0_8
      tempd = two*vnd
      ww2d(j, k, ivx) = ww2d(j, k, ivx) - bcdata(nn)%norm(j, k, 1)*tempd
      bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) - ww2(j, k, &
&       ivx)*tempd
      ww2d(j, k, ivy) = ww2d(j, k, ivy) - bcdata(nn)%norm(j, k, 2)*tempd
      bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) - ww2(j, k, &
&       ivy)*tempd
      ww2d(j, k, ivz) = ww2d(j, k, ivz) - bcdata(nn)%norm(j, k, 3)*tempd
      bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) - ww2(j, k, &
&       ivz)*tempd
      call dim_b(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k), pp1d(j&
&          , k))
      pp1d(j, k) = 0.0_8
    end do
    call popinteger4(j)
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        pp3d(j, k) = pp3d(j, k) + gradd(j, k)
        pp2d(j, k) = pp2d(j, k) - gradd(j, k)
        gradd(j, k) = 0.0_8
      end do
    end if
  end subroutine bceulerwall_b
  subroutine bceulerwall(nn, secondhalo, correctfork)
!
! ******************************************************************
! *                                                                *
! * bceulerwall applies the inviscid wall boundary condition to    *
! * a block. it is assumed that the bcpointers are                 *
! * already set to the correct block on the correct grid level.    *
! *                                                                *
! ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    intrinsic mod
    real(kind=realtype) :: dim
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = wallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
! **************************************************************
! *                                                            *
! * determine the boundary condition treatment and compute the *
! * undivided pressure gradient accordingly. this gradient is  *
! * temporarily stored in the halo pressure.                   *
! *                                                            *
! **************************************************************
!
    select case  (walltreatment) 
    case (constantpressure) 
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation. 
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = dim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! just copy the turbulent variables.
      do l=nt1mg,nt2mg
        ww1(j, k, l) = ww2(j, k, l)
      end do
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bceulerwall
!  differentiation of bcfarfield in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: gammainf winf pinfcorr *(*bcdata.norm)
!                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
!                *ww0 *ww1 *ww2
!   with respect to varying inputs: gammainf winf pinfcorr *(*bcdata.norm)
!                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
!                *ww0 *ww1 *ww2
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
!                rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in rlv1:in
!                rlv2:in ww0:in ww1:in ww2:in
  subroutine bcfarfield_b(nn, secondhalo, correctfork)
!      ******************************************************************
!      *                                                                *
!      * bcfarfield applies the farfield boundary condition to a block. *
!      * it is assumed that the bcpointers are already set              *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: gm1d, ovgm1d, ac1d, ac2d
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: r0d, u0d, v0d, w0d, qn0d, c0d, s0d
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: red, ued, ved, wed, qned, ced
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    real(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
    intrinsic sqrt
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    c0 = sqrt(gammainf*pinfcorr*r0)
    s0 = winf(irho)**gammainf/pinfcorr
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
        end do
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        do l=nt1mg,nt2mg
          ww1(i, j, l) = winf(l)
        end do
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    v0d = 0.0_8
    gm1d = 0.0_8
    s0d = 0.0_8
    c0d = 0.0_8
    w0d = 0.0_8
    u0d = 0.0_8
    ovgm1d = 0.0_8
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
        call pushcontrol1b(0)
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
        call pushcontrol1b(1)
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
        call pushcontrol1b(0)
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
        call pushcontrol1b(1)
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
        end do
        call pushcontrol1b(0)
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        do l=nt1mg,nt2mg
          ww1(i, j, l) = winf(l)
        end do
        call pushcontrol1b(1)
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
        rlv1d(i, j) = 0.0_8
      end if
      ww1d(i, j, irho) = ww1d(i, j, irho) + cc*pp1d(i, j)
      wfd = ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      vfd = ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ufd = ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      temp1 = sf*cc
      if (temp1 .le. 0.0_8 .and. (ovgm1 .eq. 0.0_8 .or. ovgm1 .ne. int(&
&         ovgm1))) then
        tempd10 = 0.0
      else
        tempd10 = ovgm1*temp1**(ovgm1-1)*ww1d(i, j, irho)
      end if
      ccd = sf*tempd10 + ww1(i, j, irho)*pp1d(i, j)
      pp1d(i, j) = 0.0_8
      sfd = cc*tempd10
      if (.not.temp1 .le. 0.0_8) ovgm1d = ovgm1d + temp1**ovgm1*log(&
&         temp1)*ww1d(i, j, irho)
      ww1d(i, j, irho) = 0.0_8
      cfd = 2*cf*ccd/gamma2(i, j)
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        do l=nt1mg,nt2mg
          ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
          ww1d(i, j, l) = 0.0_8
        end do
        tempd6 = bcdata(nn)%norm(i, j, 1)*ufd
        tempd5 = bcdata(nn)%norm(i, j, 2)*vfd
        tempd3 = sfd/pp2(i, j)
        temp0 = gamma2(i, j)
        if (.not.(ww2(i, j, irho) .le. 0.0_8 .and. (temp0 .eq. 0.0_8 &
&           .or. temp0 .ne. int(temp0)))) ww2d(i, j, irho) = ww2d(i, j, &
&           irho) + temp0*ww2(i, j, irho)**(temp0-1)*tempd3
        pp2d(i, j) = pp2d(i, j) - ww2(i, j, irho)**temp0*tempd3/pp2(i, j&
&         )
        tempd4 = bcdata(nn)%norm(i, j, 3)*wfd
        wed = wfd
        qnfd = tempd5 + tempd6 + tempd4
        qned = -tempd5 - tempd6 - tempd4
        bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qne&
&         )*wfd
        ved = vfd
        bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qne&
&         )*vfd
        ued = ufd
        bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qne&
&         )*ufd
        qn0d = 0.0_8
      else
        do l=nt1mg,nt2mg
          winfd(l) = winfd(l) + ww1d(i, j, l)
          ww1d(i, j, l) = 0.0_8
        end do
        tempd9 = bcdata(nn)%norm(i, j, 1)*ufd
        tempd8 = bcdata(nn)%norm(i, j, 2)*vfd
        s0d = s0d + sfd
        tempd7 = bcdata(nn)%norm(i, j, 3)*wfd
        w0d = w0d + wfd
        qnfd = tempd8 + tempd9 + tempd7
        qn0d = -tempd8 - tempd9 - tempd7
        bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qn0&
&         )*wfd
        v0d = v0d + vfd
        bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qn0&
&         )*vfd
        u0d = u0d + ufd
        bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qn0&
&         )*ufd
        qned = 0.0_8
        ued = 0.0_8
        ved = 0.0_8
        wed = 0.0_8
      end if
      tempd2 = fourth*cfd
      ac1d = half*qnfd + gm1*tempd2
      ac2d = half*qnfd - gm1*tempd2
      gm1d = gm1d + (ac1-ac2)*tempd2
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        qned = qned + ac2d
        ovgm1d = ovgm1d - two*ce*ac2d
        ced = -(two*ovgm1*ac2d)
      else
        qn0d = qn0d + ac2d
        ovgm1d = ovgm1d - two*c0*ac2d
        c0d = c0d - two*ovgm1*ac2d
        ced = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        qned = qned + ac1d
        ovgm1d = ovgm1d + two*ce*ac1d
        ced = ced + two*ovgm1*ac1d
      else
        qn0d = qn0d + ac1d
        ovgm1d = ovgm1d + two*c0*ac1d
        c0d = c0d + two*ovgm1*ac1d
      end if
      if (gamma2(i, j)*(pp2(i, j)*re) .eq. 0.0_8) then
        tempd1 = 0.0
      else
        tempd1 = gamma2(i, j)*ced/(2.0*sqrt(gamma2(i, j)*(pp2(i, j)*re))&
&         )
      end if
      pp2d(i, j) = pp2d(i, j) + re*tempd1
      red = pp2(i, j)*tempd1
      ued = ued + bcdata(nn)%norm(i, j, 1)*qned
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ue*qned
      ved = ved + bcdata(nn)%norm(i, j, 2)*qned
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ve*qned
      wed = wed + bcdata(nn)%norm(i, j, 3)*qned
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + we*qned
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + wed
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + ved
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + ued
      ww2d(i, j, irho) = ww2d(i, j, irho) - one*red/ww2(i, j, irho)**2
      u0d = u0d + bcdata(nn)%norm(i, j, 1)*qn0d
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + u0*qn0d
      v0d = v0d + bcdata(nn)%norm(i, j, 2)*qn0d
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + v0*qn0d
      w0d = w0d + bcdata(nn)%norm(i, j, 3)*qn0d
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + w0*qn0d
    end do
    gm1d = gm1d - one*ovgm1d/gm1**2
    if (gammainf*pinfcorr*r0 .eq. 0.0_8) then
      tempd0 = 0.0
    else
      tempd0 = c0d/(2.0*sqrt(gammainf*pinfcorr*r0))
    end if
    tempd = s0d/pinfcorr
    temp = winf(irho)**gammainf
    if (.not.(winf(irho) .le. 0.0_8 .and. (gammainf .eq. 0.0_8 .or. &
&       gammainf .ne. int(gammainf)))) winfd(irho) = winfd(irho) + &
&       gammainf*winf(irho)**(gammainf-1)*tempd
    if (winf(irho) .le. 0.0_8) then
      gammainfd = gammainfd + r0*pinfcorr*tempd0 + gm1d
    else
      gammainfd = gammainfd + r0*pinfcorr*tempd0 + gm1d + temp*log(winf(&
&       irho))*tempd
    end if
    pinfcorrd = pinfcorrd + r0*gammainf*tempd0 - temp*tempd/pinfcorr
    r0d = gammainf*pinfcorr*tempd0
    winfd(ivz) = winfd(ivz) + w0d
    winfd(ivy) = winfd(ivy) + v0d
    winfd(ivx) = winfd(ivx) + u0d
    winfd(irho) = winfd(irho) - one*r0d/winf(irho)**2
  end subroutine bcfarfield_b
  subroutine bcfarfield(nn, secondhalo, correctfork)
!      ******************************************************************
!      *                                                                *
!      * bcfarfield applies the farfield boundary condition to a block. *
!      * it is assumed that the bcpointers are already set              *
!      *                                                                *
!      ******************************************************************
!
    use blockpointers
    use bctypes
    use constants
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    intrinsic sqrt
    intrinsic mod
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    c0 = sqrt(gammainf*pinfcorr*r0)
    s0 = winf(irho)**gammainf/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
        do l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
        end do
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        do l=nt1mg,nt2mg
          ww1(i, j, l) = winf(l)
        end do
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcfarfield
!  differentiation of extrapolate2ndhalo in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
!                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
  subroutine extrapolate2ndhalo_b(correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * extrapolate2ndhalo determines the states of the second layer   *
!      * halo cells for the given subface of the block. it is assumed   *
!      * that the appropriate bcpointers are already set
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use constants
    use flowvarrefstate
    use iteration
    use inputphysics
    implicit none
    logical, intent(in) :: correctfork
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
    integer :: branch
    call pushreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! extrapolate the turbulent variables. use constant
! extrapolation.
      do l=nt1mg,nt2mg
        ww0(i, j, l) = ww1(i, j, l)
      end do
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
    call computeetot_b(ww0, ww0d, pp0, pp0d, correctfork)
    call popreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev1d(i, j) + rev0d(i, j)
        rev0d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv1d(i, j) = rlv1d(i, j) + rlv0d(i, j)
        rlv0d(i, j) = 0.0_8
      end if
      do l=nt1mg,nt2mg
        ww1d(i, j, l) = ww1d(i, j, l) + ww0d(i, j, l)
        ww0d(i, j, l) = 0.0_8
      end do
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pp1d(i, j) = pp1d(i, j) + two*pp0d(i, j)
        pp2d(i, j) = pp2d(i, j) - pp0d(i, j)
        pp0d(i, j) = 0.0_8
      else
        pp1d(i, j) = pp1d(i, j) + factor*pp0d(i, j)
        pp0d(i, j) = 0.0_8
      end if
      ww1d(i, j, ivz) = ww1d(i, j, ivz) + two*ww0d(i, j, ivz)
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww0d(i, j, ivz)
      ww0d(i, j, ivz) = 0.0_8
      ww1d(i, j, ivy) = ww1d(i, j, ivy) + two*ww0d(i, j, ivy)
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww0d(i, j, ivy)
      ww0d(i, j, ivy) = 0.0_8
      ww1d(i, j, ivx) = ww1d(i, j, ivx) + two*ww0d(i, j, ivx)
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww0d(i, j, ivx)
      ww0d(i, j, ivx) = 0.0_8
      call popcontrol1b(branch)
      if (branch .ne. 0) then
        ww1d(i, j, irho) = ww1d(i, j, irho) + factor*ww0d(i, j, irho)
        ww0d(i, j, irho) = 0.0_8
      end if
      ww1d(i, j, irho) = ww1d(i, j, irho) + two*ww0d(i, j, irho)
      ww2d(i, j, irho) = ww2d(i, j, irho) - ww0d(i, j, irho)
      ww0d(i, j, irho) = 0.0_8
    end do
  end subroutine extrapolate2ndhalo_b
!  differentiation of computeetot in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: ww pp
!   with respect to varying inputs: ww pp
  subroutine computeetot_b(ww, wwd, pp, ppd, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use flowvarrefstate
    use inputphysics
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :) :: ppd
    real(kind=realtype), dimension(:, :, :) :: ww
    real(kind=realtype), dimension(:, :, :) :: wwd
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd0
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          tmpd = wwd(i, j, irhoe)
          wwd(i, j, irhoe) = 0.0_8
          tempd = half*ww(i, j, irho)*tmpd
          ppd(i, j) = ppd(i, j) + ovgm1*tmpd
          wwd(i, j, irho) = wwd(i, j, irho) + half*(ww(i, j, ivx)**2+ww(&
&           i, j, ivy)**2+ww(i, j, ivz)**2)*tmpd
          wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd
          wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd
          wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd
        else
          tmpd0 = wwd(i, j, irhoe)
          wwd(i, j, irhoe) = 0.0_8
          tempd0 = half*ww(i, j, irho)*tmpd0
          ppd(i, j) = ppd(i, j) + ovgm1*tmpd0
          wwd(i, j, irho) = wwd(i, j, irho) + (half*(ww(i, j, ivx)**2+ww&
&           (i, j, ivy)**2+ww(i, j, ivz)**2)-factk*ww(i, j, itu1))*tmpd0
          wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd0
          wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd0
          wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd0
          wwd(i, j, itu1) = wwd(i, j, itu1) - factk*ww(i, j, irho)*tmpd0
        end if
      end do
    end select
  end subroutine computeetot_b
  subroutine extrapolate2ndhalo(correctfork)
!
!      ******************************************************************
!      *                                                                *
!      * extrapolate2ndhalo determines the states of the second layer   *
!      * halo cells for the given subface of the block. it is assumed   *
!      * that the appropriate bcpointers are already set
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use constants
    use flowvarrefstate
    use iteration
    use inputphysics
    implicit none
    logical, intent(in) :: correctfork
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! extrapolate the turbulent variables. use constant
! extrapolation.
      do l=nt1mg,nt2mg
        ww0(i, j, l) = ww1(i, j, l)
      end do
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
! compute the energy for this halo range.
    call computeetot(ww0, pp0, correctfork)
  end subroutine extrapolate2ndhalo
  subroutine computeetot(ww, pp, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use flowvarrefstate
    use inputphysics
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :, :) :: ww
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
! loop over the given array and compute the energy, possibly
! correcting for k
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
        else
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
&           j, irho)*ww(i, j, itu1)
        end if
      end do
    case (cptempcurvefits) 
      call returnfail('bcroutines', &
&                  'cptempcurvefits not implemented yet.')
    end select
  end subroutine computeetot
!  differentiation of setbcpointers in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev *p *w *rlv *x *si *sj
!                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
!                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
!                *ww3
!   with respect to varying inputs: *rev *p *w *rlv *x *si *sj
!                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
!                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
!                *ww3
!   plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
!                sj:in sk:in bcdata:in xx:in rev0:in rev1:in rev2:in
!                rev3:in pp0:in pp1:in pp2:in pp3:in rlv0:in rlv1:in
!                rlv2:in rlv3:in ssi:in ww0:in ww1:in ww2:in ww3:in
  subroutine setbcpointers_b(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * setbcpointers sets the pointers needed for the boundary        *
!      * condition treatment on a general face, such that the boundary  *
!      * routines are only implemented once instead of 6 times.         *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    use inputphysics
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    integer :: branch
! determine the sizes of each face and point to just the range we
! need on each face. 
! set the size of the subface
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
      call pushcontrol3b(1)
    case (imax) 
      call pushcontrol3b(2)
    case (jmin) 
      call pushcontrol3b(3)
    case (jmax) 
      call pushcontrol3b(4)
    case (kmin) 
      call pushcontrol3b(5)
    case (kmax) 
      call pushcontrol3b(6)
    case default
      call pushcontrol3b(0)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        sid(1, 1:je, 1:ke, :) = sid(1, 1:je, 1:ke, :) + ssid(1:je, 1:ke&
&         , :)
        ssid(1:je, 1:ke, :) = 0.0_8
        xd(1, 0:je, 0:ke, :) = xd(1, 0:je, 0:ke, :) + xxd(1:je+1, 1:ke+1&
&         , :)
        xxd(1:je+1, 1:ke+1, :) = 0.0_8
      case (imax) 
        sid(il, 1:je, 1:ke, :) = sid(il, 1:je, 1:ke, :) + ssid(1:je, 1:&
&         ke, :)
        ssid(1:je, 1:ke, :) = 0.0_8
        xd(il, 0:je, 0:ke, :) = xd(il, 0:je, 0:ke, :) + xxd(1:je+1, 1:ke&
&         +1, :)
        xxd(1:je+1, 1:ke+1, :) = 0.0_8
      case (jmin) 
        sjd(1:ie, 1, 1:ke, :) = sjd(1:ie, 1, 1:ke, :) + ssid(1:ie, 1:ke&
&         , :)
        ssid(1:ie, 1:ke, :) = 0.0_8
        xd(0:ie, 1, 0:ke, :) = xd(0:ie, 1, 0:ke, :) + xxd(1:ie+1, 1:ke+1&
&         , :)
        xxd(1:ie+1, 1:ke+1, :) = 0.0_8
      case (jmax) 
        sjd(1:ie, jl, 1:ke, :) = sjd(1:ie, jl, 1:ke, :) + ssid(1:ie, 1:&
&         ke, :)
        ssid(1:ie, 1:ke, :) = 0.0_8
        xd(0:ie, jl, 0:ke, :) = xd(0:ie, jl, 0:ke, :) + xxd(1:ie+1, 1:ke&
&         +1, :)
        xxd(1:ie+1, 1:ke+1, :) = 0.0_8
      case (kmin) 
        skd(1:ie, 1:je, 1, :) = skd(1:ie, 1:je, 1, :) + ssid(1:ie, 1:je&
&         , :)
        ssid(1:ie, 1:je, :) = 0.0_8
        xd(0:ie, 0:je, 1, :) = xd(0:ie, 0:je, 1, :) + xxd(1:ie+1, 1:je+1&
&         , :)
        xxd(1:ie+1, 1:je+1, :) = 0.0_8
      case (kmax) 
        skd(1:ie, 1:je, kl, :) = skd(1:ie, 1:je, kl, :) + ssid(1:ie, 1:&
&         je, :)
        ssid(1:ie, 1:je, :) = 0.0_8
        xd(0:ie, 0:je, kl, :) = xd(0:ie, 0:je, kl, :) + xxd(1:ie+1, 1:je&
&         +1, :)
        xxd(1:ie+1, 1:je+1, :) = 0.0_8
      end select
    end if
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .ne. 0) then
        if (branch .eq. 1) then
          revd(0, 1:je, 1:ke) = revd(0, 1:je, 1:ke) + rev0d(1:je, 1:ke)
          rev0d(1:je, 1:ke) = 0.0_8
          revd(1, 1:je, 1:ke) = revd(1, 1:je, 1:ke) + rev1d(1:je, 1:ke)
          rev1d(1:je, 1:ke) = 0.0_8
          revd(2, 1:je, 1:ke) = revd(2, 1:je, 1:ke) + rev2d(1:je, 1:ke)
          rev2d(1:je, 1:ke) = 0.0_8
          revd(3, 1:je, 1:ke) = revd(3, 1:je, 1:ke) + rev3d(1:je, 1:ke)
          rev3d(1:je, 1:ke) = 0.0_8
          rlvd(0, 1:je, 1:ke) = rlvd(0, 1:je, 1:ke) + rlv0d(1:je, 1:ke)
          rlv0d(1:je, 1:ke) = 0.0_8
          rlvd(1, 1:je, 1:ke) = rlvd(1, 1:je, 1:ke) + rlv1d(1:je, 1:ke)
          rlv1d(1:je, 1:ke) = 0.0_8
          rlvd(2, 1:je, 1:ke) = rlvd(2, 1:je, 1:ke) + rlv2d(1:je, 1:ke)
          rlv2d(1:je, 1:ke) = 0.0_8
          rlvd(3, 1:je, 1:ke) = rlvd(3, 1:je, 1:ke) + rlv3d(1:je, 1:ke)
          rlv3d(1:je, 1:ke) = 0.0_8
          pd(0, 1:je, 1:ke) = pd(0, 1:je, 1:ke) + pp0d(1:je, 1:ke)
          pp0d(1:je, 1:ke) = 0.0_8
          pd(1, 1:je, 1:ke) = pd(1, 1:je, 1:ke) + pp1d(1:je, 1:ke)
          pp1d(1:je, 1:ke) = 0.0_8
          pd(2, 1:je, 1:ke) = pd(2, 1:je, 1:ke) + pp2d(1:je, 1:ke)
          pp2d(1:je, 1:ke) = 0.0_8
          pd(3, 1:je, 1:ke) = pd(3, 1:je, 1:ke) + pp3d(1:je, 1:ke)
          pp3d(1:je, 1:ke) = 0.0_8
          wd(0, 1:je, 1:ke, :) = wd(0, 1:je, 1:ke, :) + ww0d(1:je, 1:ke&
&           , :)
          ww0d(1:je, 1:ke, :) = 0.0_8
          wd(1, 1:je, 1:ke, :) = wd(1, 1:je, 1:ke, :) + ww1d(1:je, 1:ke&
&           , :)
          ww1d(1:je, 1:ke, :) = 0.0_8
          wd(2, 1:je, 1:ke, :) = wd(2, 1:je, 1:ke, :) + ww2d(1:je, 1:ke&
&           , :)
          ww2d(1:je, 1:ke, :) = 0.0_8
          wd(3, 1:je, 1:ke, :) = wd(3, 1:je, 1:ke, :) + ww3d(1:je, 1:ke&
&           , :)
          ww3d(1:je, 1:ke, :) = 0.0_8
        else
          revd(ib, 1:je, 1:ke) = revd(ib, 1:je, 1:ke) + rev0d(1:je, 1:ke&
&           )
          rev0d(1:je, 1:ke) = 0.0_8
          revd(ie, 1:je, 1:ke) = revd(ie, 1:je, 1:ke) + rev1d(1:je, 1:ke&
&           )
          rev1d(1:je, 1:ke) = 0.0_8
          revd(il, 1:je, 1:ke) = revd(il, 1:je, 1:ke) + rev2d(1:je, 1:ke&
&           )
          rev2d(1:je, 1:ke) = 0.0_8
          revd(nx, 1:je, 1:ke) = revd(nx, 1:je, 1:ke) + rev3d(1:je, 1:ke&
&           )
          rev3d(1:je, 1:ke) = 0.0_8
          rlvd(ib, 1:je, 1:ke) = rlvd(ib, 1:je, 1:ke) + rlv0d(1:je, 1:ke&
&           )
          rlv0d(1:je, 1:ke) = 0.0_8
          rlvd(ie, 1:je, 1:ke) = rlvd(ie, 1:je, 1:ke) + rlv1d(1:je, 1:ke&
&           )
          rlv1d(1:je, 1:ke) = 0.0_8
          rlvd(il, 1:je, 1:ke) = rlvd(il, 1:je, 1:ke) + rlv2d(1:je, 1:ke&
&           )
          rlv2d(1:je, 1:ke) = 0.0_8
          rlvd(nx, 1:je, 1:ke) = rlvd(nx, 1:je, 1:ke) + rlv3d(1:je, 1:ke&
&           )
          rlv3d(1:je, 1:ke) = 0.0_8
          pd(ib, 1:je, 1:ke) = pd(ib, 1:je, 1:ke) + pp0d(1:je, 1:ke)
          pp0d(1:je, 1:ke) = 0.0_8
          pd(ie, 1:je, 1:ke) = pd(ie, 1:je, 1:ke) + pp1d(1:je, 1:ke)
          pp1d(1:je, 1:ke) = 0.0_8
          pd(il, 1:je, 1:ke) = pd(il, 1:je, 1:ke) + pp2d(1:je, 1:ke)
          pp2d(1:je, 1:ke) = 0.0_8
          pd(nx, 1:je, 1:ke) = pd(nx, 1:je, 1:ke) + pp3d(1:je, 1:ke)
          pp3d(1:je, 1:ke) = 0.0_8
          wd(ib, 1:je, 1:ke, :) = wd(ib, 1:je, 1:ke, :) + ww0d(1:je, 1:&
&           ke, :)
          ww0d(1:je, 1:ke, :) = 0.0_8
          wd(ie, 1:je, 1:ke, :) = wd(ie, 1:je, 1:ke, :) + ww1d(1:je, 1:&
&           ke, :)
          ww1d(1:je, 1:ke, :) = 0.0_8
          wd(il, 1:je, 1:ke, :) = wd(il, 1:je, 1:ke, :) + ww2d(1:je, 1:&
&           ke, :)
          ww2d(1:je, 1:ke, :) = 0.0_8
          wd(nx, 1:je, 1:ke, :) = wd(nx, 1:je, 1:ke, :) + ww3d(1:je, 1:&
&           ke, :)
          ww3d(1:je, 1:ke, :) = 0.0_8
        end if
      end if
    else if (branch .lt. 5) then
      if (branch .eq. 3) then
        revd(1:ie, 0, 1:ke) = revd(1:ie, 0, 1:ke) + rev0d(1:ie, 1:ke)
        rev0d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, 1, 1:ke) = revd(1:ie, 1, 1:ke) + rev1d(1:ie, 1:ke)
        rev1d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, 2, 1:ke) = revd(1:ie, 2, 1:ke) + rev2d(1:ie, 1:ke)
        rev2d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, 3, 1:ke) = revd(1:ie, 3, 1:ke) + rev3d(1:ie, 1:ke)
        rev3d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 0, 1:ke) = rlvd(1:ie, 0, 1:ke) + rlv0d(1:ie, 1:ke)
        rlv0d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 1, 1:ke) = rlvd(1:ie, 1, 1:ke) + rlv1d(1:ie, 1:ke)
        rlv1d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 2, 1:ke) = rlvd(1:ie, 2, 1:ke) + rlv2d(1:ie, 1:ke)
        rlv2d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 3, 1:ke) = rlvd(1:ie, 3, 1:ke) + rlv3d(1:ie, 1:ke)
        rlv3d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 0, 1:ke) = pd(1:ie, 0, 1:ke) + pp0d(1:ie, 1:ke)
        pp0d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 1, 1:ke) = pd(1:ie, 1, 1:ke) + pp1d(1:ie, 1:ke)
        pp1d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 2, 1:ke) = pd(1:ie, 2, 1:ke) + pp2d(1:ie, 1:ke)
        pp2d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 3, 1:ke) = pd(1:ie, 3, 1:ke) + pp3d(1:ie, 1:ke)
        pp3d(1:ie, 1:ke) = 0.0_8
        wd(1:ie, 0, 1:ke, :) = wd(1:ie, 0, 1:ke, :) + ww0d(1:ie, 1:ke, :&
&         )
        ww0d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, 1, 1:ke, :) = wd(1:ie, 1, 1:ke, :) + ww1d(1:ie, 1:ke, :&
&         )
        ww1d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, 2, 1:ke, :) = wd(1:ie, 2, 1:ke, :) + ww2d(1:ie, 1:ke, :&
&         )
        ww2d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, 3, 1:ke, :) = wd(1:ie, 3, 1:ke, :) + ww3d(1:ie, 1:ke, :&
&         )
        ww3d(1:ie, 1:ke, :) = 0.0_8
      else
        revd(1:ie, jb, 1:ke) = revd(1:ie, jb, 1:ke) + rev0d(1:ie, 1:ke)
        rev0d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, je, 1:ke) = revd(1:ie, je, 1:ke) + rev1d(1:ie, 1:ke)
        rev1d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, jl, 1:ke) = revd(1:ie, jl, 1:ke) + rev2d(1:ie, 1:ke)
        rev2d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, ny, 1:ke) = revd(1:ie, ny, 1:ke) + rev3d(1:ie, 1:ke)
        rev3d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, jb, 1:ke) = rlvd(1:ie, jb, 1:ke) + rlv0d(1:ie, 1:ke)
        rlv0d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, je, 1:ke) = rlvd(1:ie, je, 1:ke) + rlv1d(1:ie, 1:ke)
        rlv1d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, jl, 1:ke) = rlvd(1:ie, jl, 1:ke) + rlv2d(1:ie, 1:ke)
        rlv2d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, ny, 1:ke) = rlvd(1:ie, ny, 1:ke) + rlv3d(1:ie, 1:ke)
        rlv3d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, jb, 1:ke) = pd(1:ie, jb, 1:ke) + pp0d(1:ie, 1:ke)
        pp0d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, je, 1:ke) = pd(1:ie, je, 1:ke) + pp1d(1:ie, 1:ke)
        pp1d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, jl, 1:ke) = pd(1:ie, jl, 1:ke) + pp2d(1:ie, 1:ke)
        pp2d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, ny, 1:ke) = pd(1:ie, ny, 1:ke) + pp3d(1:ie, 1:ke)
        pp3d(1:ie, 1:ke) = 0.0_8
        wd(1:ie, jb, 1:ke, :) = wd(1:ie, jb, 1:ke, :) + ww0d(1:ie, 1:ke&
&         , :)
        ww0d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, je, 1:ke, :) = wd(1:ie, je, 1:ke, :) + ww1d(1:ie, 1:ke&
&         , :)
        ww1d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, jl, 1:ke, :) = wd(1:ie, jl, 1:ke, :) + ww2d(1:ie, 1:ke&
&         , :)
        ww2d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, ny, 1:ke, :) = wd(1:ie, ny, 1:ke, :) + ww3d(1:ie, 1:ke&
&         , :)
        ww3d(1:ie, 1:ke, :) = 0.0_8
      end if
    else if (branch .eq. 5) then
      revd(1:ie, 1:je, 0) = revd(1:ie, 1:je, 0) + rev0d(1:ie, 1:je)
      rev0d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, 1) = revd(1:ie, 1:je, 1) + rev1d(1:ie, 1:je)
      rev1d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, 2) = revd(1:ie, 1:je, 2) + rev2d(1:ie, 1:je)
      rev2d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, 3) = revd(1:ie, 1:je, 3) + rev3d(1:ie, 1:je)
      rev3d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 0) = rlvd(1:ie, 1:je, 0) + rlv0d(1:ie, 1:je)
      rlv0d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 1) = rlvd(1:ie, 1:je, 1) + rlv1d(1:ie, 1:je)
      rlv1d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 2) = rlvd(1:ie, 1:je, 2) + rlv2d(1:ie, 1:je)
      rlv2d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 3) = rlvd(1:ie, 1:je, 3) + rlv3d(1:ie, 1:je)
      rlv3d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 0) = pd(1:ie, 1:je, 0) + pp0d(1:ie, 1:je)
      pp0d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 1) = pd(1:ie, 1:je, 1) + pp1d(1:ie, 1:je)
      pp1d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 2) = pd(1:ie, 1:je, 2) + pp2d(1:ie, 1:je)
      pp2d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 3) = pd(1:ie, 1:je, 3) + pp3d(1:ie, 1:je)
      pp3d(1:ie, 1:je) = 0.0_8
      wd(1:ie, 1:je, 0, :) = wd(1:ie, 1:je, 0, :) + ww0d(1:ie, 1:je, :)
      ww0d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, 1, :) = wd(1:ie, 1:je, 1, :) + ww1d(1:ie, 1:je, :)
      ww1d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, 2, :) = wd(1:ie, 1:je, 2, :) + ww2d(1:ie, 1:je, :)
      ww2d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, 3, :) = wd(1:ie, 1:je, 3, :) + ww3d(1:ie, 1:je, :)
      ww3d(1:ie, 1:je, :) = 0.0_8
    else
      revd(1:ie, 1:je, kb) = revd(1:ie, 1:je, kb) + rev0d(1:ie, 1:je)
      rev0d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, ke) = revd(1:ie, 1:je, ke) + rev1d(1:ie, 1:je)
      rev1d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, kl) = revd(1:ie, 1:je, kl) + rev2d(1:ie, 1:je)
      rev2d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, nz) = revd(1:ie, 1:je, nz) + rev3d(1:ie, 1:je)
      rev3d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, kb) = rlvd(1:ie, 1:je, kb) + rlv0d(1:ie, 1:je)
      rlv0d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, ke) = rlvd(1:ie, 1:je, ke) + rlv1d(1:ie, 1:je)
      rlv1d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, kl) = rlvd(1:ie, 1:je, kl) + rlv2d(1:ie, 1:je)
      rlv2d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, nz) = rlvd(1:ie, 1:je, nz) + rlv3d(1:ie, 1:je)
      rlv3d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, kb) = pd(1:ie, 1:je, kb) + pp0d(1:ie, 1:je)
      pp0d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, ke) = pd(1:ie, 1:je, ke) + pp1d(1:ie, 1:je)
      pp1d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, kl) = pd(1:ie, 1:je, kl) + pp2d(1:ie, 1:je)
      pp2d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, nz) = pd(1:ie, 1:je, nz) + pp3d(1:ie, 1:je)
      pp3d(1:ie, 1:je) = 0.0_8
      wd(1:ie, 1:je, kb, :) = wd(1:ie, 1:je, kb, :) + ww0d(1:ie, 1:je, :&
&       )
      ww0d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, ke, :) = wd(1:ie, 1:je, ke, :) + ww1d(1:ie, 1:je, :&
&       )
      ww1d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, kl, :) = wd(1:ie, 1:je, kl, :) + ww2d(1:ie, 1:je, :&
&       )
      ww2d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, nz, :) = wd(1:ie, 1:je, nz, :) + ww3d(1:ie, 1:je, :&
&       )
      ww3d(1:ie, 1:je, :) = 0.0_8
    end if
  end subroutine setbcpointers_b
  subroutine setbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * setbcpointers sets the pointers needed for the boundary        *
!      * condition treatment on a general face, such that the boundary  *
!      * routines are only implemented once instead of 6 times.         *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    use inputphysics
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      ww3(1:je, 1:ke, :) = w(3, 1:je, 1:ke, :)
      ww2(1:je, 1:ke, :) = w(2, 1:je, 1:ke, :)
      ww1(1:je, 1:ke, :) = w(1, 1:je, 1:ke, :)
      ww0(1:je, 1:ke, :) = w(0, 1:je, 1:ke, :)
      pp3(1:je, 1:ke) = p(3, 1:je, 1:ke)
      pp2(1:je, 1:ke) = p(2, 1:je, 1:ke)
      pp1(1:je, 1:ke) = p(1, 1:je, 1:ke)
      pp0(1:je, 1:ke) = p(0, 1:je, 1:ke)
      rlv3(1:je, 1:ke) = rlv(3, 1:je, 1:ke)
      rlv2(1:je, 1:ke) = rlv(2, 1:je, 1:ke)
      rlv1(1:je, 1:ke) = rlv(1, 1:je, 1:ke)
      rlv0(1:je, 1:ke) = rlv(0, 1:je, 1:ke)
      rev3(1:je, 1:ke) = rev(3, 1:je, 1:ke)
      rev2(1:je, 1:ke) = rev(2, 1:je, 1:ke)
      rev1(1:je, 1:ke) = rev(1, 1:je, 1:ke)
      rev0(1:je, 1:ke) = rev(0, 1:je, 1:ke)
      gamma3(1:je, 1:ke) = gamma(3, 1:je, 1:ke)
      gamma2(1:je, 1:ke) = gamma(2, 1:je, 1:ke)
      gamma1(1:je, 1:ke) = gamma(1, 1:je, 1:ke)
      gamma0(1:je, 1:ke) = gamma(0, 1:je, 1:ke)
    case (imax) 
!===============================================================
      ww3(1:je, 1:ke, :) = w(nx, 1:je, 1:ke, :)
      ww2(1:je, 1:ke, :) = w(il, 1:je, 1:ke, :)
      ww1(1:je, 1:ke, :) = w(ie, 1:je, 1:ke, :)
      ww0(1:je, 1:ke, :) = w(ib, 1:je, 1:ke, :)
      pp3(1:je, 1:ke) = p(nx, 1:je, 1:ke)
      pp2(1:je, 1:ke) = p(il, 1:je, 1:ke)
      pp1(1:je, 1:ke) = p(ie, 1:je, 1:ke)
      pp0(1:je, 1:ke) = p(ib, 1:je, 1:ke)
      rlv3(1:je, 1:ke) = rlv(nx, 1:je, 1:ke)
      rlv2(1:je, 1:ke) = rlv(il, 1:je, 1:ke)
      rlv1(1:je, 1:ke) = rlv(ie, 1:je, 1:ke)
      rlv0(1:je, 1:ke) = rlv(ib, 1:je, 1:ke)
      rev3(1:je, 1:ke) = rev(nx, 1:je, 1:ke)
      rev2(1:je, 1:ke) = rev(il, 1:je, 1:ke)
      rev1(1:je, 1:ke) = rev(ie, 1:je, 1:ke)
      rev0(1:je, 1:ke) = rev(ib, 1:je, 1:ke)
      gamma3(1:je, 1:ke) = gamma(nx, 1:je, 1:ke)
      gamma2(1:je, 1:ke) = gamma(il, 1:je, 1:ke)
      gamma1(1:je, 1:ke) = gamma(ie, 1:je, 1:ke)
      gamma0(1:je, 1:ke) = gamma(ib, 1:je, 1:ke)
    case (jmin) 
!===============================================================
      ww3(1:ie, 1:ke, :) = w(1:ie, 3, 1:ke, :)
      ww2(1:ie, 1:ke, :) = w(1:ie, 2, 1:ke, :)
      ww1(1:ie, 1:ke, :) = w(1:ie, 1, 1:ke, :)
      ww0(1:ie, 1:ke, :) = w(1:ie, 0, 1:ke, :)
      pp3(1:ie, 1:ke) = p(1:ie, 3, 1:ke)
      pp2(1:ie, 1:ke) = p(1:ie, 2, 1:ke)
      pp1(1:ie, 1:ke) = p(1:ie, 1, 1:ke)
      pp0(1:ie, 1:ke) = p(1:ie, 0, 1:ke)
      rlv3(1:ie, 1:ke) = rlv(1:ie, 3, 1:ke)
      rlv2(1:ie, 1:ke) = rlv(1:ie, 2, 1:ke)
      rlv1(1:ie, 1:ke) = rlv(1:ie, 1, 1:ke)
      rlv0(1:ie, 1:ke) = rlv(1:ie, 0, 1:ke)
      rev3(1:ie, 1:ke) = rev(1:ie, 3, 1:ke)
      rev2(1:ie, 1:ke) = rev(1:ie, 2, 1:ke)
      rev1(1:ie, 1:ke) = rev(1:ie, 1, 1:ke)
      rev0(1:ie, 1:ke) = rev(1:ie, 0, 1:ke)
      gamma3(1:ie, 1:ke) = gamma(1:ie, 3, 1:ke)
      gamma2(1:ie, 1:ke) = gamma(1:ie, 2, 1:ke)
      gamma1(1:ie, 1:ke) = gamma(1:ie, 1, 1:ke)
      gamma0(1:ie, 1:ke) = gamma(1:ie, 0, 1:ke)
    case (jmax) 
!===============================================================
      ww3(1:ie, 1:ke, :) = w(1:ie, ny, 1:ke, :)
      ww2(1:ie, 1:ke, :) = w(1:ie, jl, 1:ke, :)
      ww1(1:ie, 1:ke, :) = w(1:ie, je, 1:ke, :)
      ww0(1:ie, 1:ke, :) = w(1:ie, jb, 1:ke, :)
      pp3(1:ie, 1:ke) = p(1:ie, ny, 1:ke)
      pp2(1:ie, 1:ke) = p(1:ie, jl, 1:ke)
      pp1(1:ie, 1:ke) = p(1:ie, je, 1:ke)
      pp0(1:ie, 1:ke) = p(1:ie, jb, 1:ke)
      rlv3(1:ie, 1:ke) = rlv(1:ie, ny, 1:ke)
      rlv2(1:ie, 1:ke) = rlv(1:ie, jl, 1:ke)
      rlv1(1:ie, 1:ke) = rlv(1:ie, je, 1:ke)
      rlv0(1:ie, 1:ke) = rlv(1:ie, jb, 1:ke)
      rev3(1:ie, 1:ke) = rev(1:ie, ny, 1:ke)
      rev2(1:ie, 1:ke) = rev(1:ie, jl, 1:ke)
      rev1(1:ie, 1:ke) = rev(1:ie, je, 1:ke)
      rev0(1:ie, 1:ke) = rev(1:ie, jb, 1:ke)
      gamma3(1:ie, 1:ke) = gamma(1:ie, ny, 1:ke)
      gamma2(1:ie, 1:ke) = gamma(1:ie, jl, 1:ke)
      gamma1(1:ie, 1:ke) = gamma(1:ie, je, 1:ke)
      gamma0(1:ie, 1:ke) = gamma(1:ie, jb, 1:ke)
    case (kmin) 
!===============================================================
      ww3(1:ie, 1:je, :) = w(1:ie, 1:je, 3, :)
      ww2(1:ie, 1:je, :) = w(1:ie, 1:je, 2, :)
      ww1(1:ie, 1:je, :) = w(1:ie, 1:je, 1, :)
      ww0(1:ie, 1:je, :) = w(1:ie, 1:je, 0, :)
      pp3(1:ie, 1:je) = p(1:ie, 1:je, 3)
      pp2(1:ie, 1:je) = p(1:ie, 1:je, 2)
      pp1(1:ie, 1:je) = p(1:ie, 1:je, 1)
      pp0(1:ie, 1:je) = p(1:ie, 1:je, 0)
      rlv3(1:ie, 1:je) = rlv(1:ie, 1:je, 3)
      rlv2(1:ie, 1:je) = rlv(1:ie, 1:je, 2)
      rlv1(1:ie, 1:je) = rlv(1:ie, 1:je, 1)
      rlv0(1:ie, 1:je) = rlv(1:ie, 1:je, 0)
      rev3(1:ie, 1:je) = rev(1:ie, 1:je, 3)
      rev2(1:ie, 1:je) = rev(1:ie, 1:je, 2)
      rev1(1:ie, 1:je) = rev(1:ie, 1:je, 1)
      rev0(1:ie, 1:je) = rev(1:ie, 1:je, 0)
      gamma3(1:ie, 1:je) = gamma(1:ie, 1:je, 3)
      gamma2(1:ie, 1:je) = gamma(1:ie, 1:je, 2)
      gamma1(1:ie, 1:je) = gamma(1:ie, 1:je, 1)
      gamma0(1:ie, 1:je) = gamma(1:ie, 1:je, 0)
    case (kmax) 
!===============================================================
      ww3(1:ie, 1:je, :) = w(1:ie, 1:je, nz, :)
      ww2(1:ie, 1:je, :) = w(1:ie, 1:je, kl, :)
      ww1(1:ie, 1:je, :) = w(1:ie, 1:je, ke, :)
      ww0(1:ie, 1:je, :) = w(1:ie, 1:je, kb, :)
      pp3(1:ie, 1:je) = p(1:ie, 1:je, nz)
      pp2(1:ie, 1:je) = p(1:ie, 1:je, kl)
      pp1(1:ie, 1:je) = p(1:ie, 1:je, ke)
      pp0(1:ie, 1:je) = p(1:ie, 1:je, kb)
      rlv3(1:ie, 1:je) = rlv(1:ie, 1:je, nz)
      rlv2(1:ie, 1:je) = rlv(1:ie, 1:je, kl)
      rlv1(1:ie, 1:je) = rlv(1:ie, 1:je, ke)
      rlv0(1:ie, 1:je) = rlv(1:ie, 1:je, kb)
      rev3(1:ie, 1:je) = rev(1:ie, 1:je, nz)
      rev2(1:ie, 1:je) = rev(1:ie, 1:je, kl)
      rev1(1:ie, 1:je) = rev(1:ie, 1:je, ke)
      rev0(1:ie, 1:je) = rev(1:ie, 1:je, kb)
      gamma3(1:ie, 1:je) = gamma(1:ie, 1:je, nz)
      gamma2(1:ie, 1:je) = gamma(1:ie, 1:je, kl)
      gamma1(1:ie, 1:je) = gamma(1:ie, 1:je, ke)
      gamma0(1:ie, 1:je) = gamma(1:ie, 1:je, kb)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xx(1:je+1, 1:ke+1, :) = x(1, 0:je, 0:ke, :)
        ssi(1:je, 1:ke, :) = si(1, 1:je, 1:ke, :)
      case (imax) 
        xx(1:je+1, 1:ke+1, :) = x(il, 0:je, 0:ke, :)
        ssi(1:je, 1:ke, :) = si(il, 1:je, 1:ke, :)
      case (jmin) 
        xx(1:ie+1, 1:ke+1, :) = x(0:ie, 1, 0:ke, :)
        ssi(1:ie, 1:ke, :) = sj(1:ie, 1, 1:ke, :)
      case (jmax) 
        xx(1:ie+1, 1:ke+1, :) = x(0:ie, jl, 0:ke, :)
        ssi(1:ie, 1:ke, :) = sj(1:ie, jl, 1:ke, :)
      case (kmin) 
        xx(1:ie+1, 1:je+1, :) = x(0:ie, 0:je, 1, :)
        ssi(1:ie, 1:je, :) = sk(1:ie, 1:je, 1, :)
      case (kmax) 
        xx(1:ie+1, 1:je+1, :) = x(0:ie, 0:je, kl, :)
        ssi(1:ie, 1:je, :) = sk(1:ie, 1:je, kl, :)
      end select
    end if
  end subroutine setbcpointers
!  differentiation of resetbcpointers in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev *p *w *rlv *x *si *sj
!                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
!                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
!                *ww3
!   with respect to varying inputs: *rev *p *w *rlv *x *si *sj
!                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
!                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
!                *ww3
!   plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
!                sj:in sk:in xx:in rev0:in rev1:in rev2:in rev3:in
!                pp0:in pp1:in pp2:in pp3:in rlv0:in rlv1:in rlv2:in
!                rlv3:in ssi:in ww0:in ww1:in ww2:in ww3:in
  subroutine resetbcpointers_b(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * resetbcpointers nullifyies the boundary pointers. for reverse  *
!      * mode ad it copies the values back in to the respective arrays  *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    integer :: branch
    select case  (bcfaceid(nn)) 
    case (imin) 
      call pushcontrol3b(1)
    case (imax) 
      call pushcontrol3b(2)
    case (jmin) 
      call pushcontrol3b(3)
    case (jmax) 
      call pushcontrol3b(4)
    case (kmin) 
      call pushcontrol3b(5)
    case (kmax) 
      call pushcontrol3b(6)
    case default
      call pushcontrol3b(0)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        ssid(1:je, 1:ke, :) = ssid(1:je, 1:ke, :) + sid(1, 1:je, 1:ke, :&
&         )
        sid(1, 1:je, 1:ke, :) = 0.0_8
        xxd(1:je+1, 1:ke+1, :) = xxd(1:je+1, 1:ke+1, :) + xd(1, 0:je, 0:&
&         ke, :)
        xd(1, 0:je, 0:ke, :) = 0.0_8
      case (imax) 
        ssid(1:je, 1:ke, :) = ssid(1:je, 1:ke, :) + sid(il, 1:je, 1:ke, &
&         :)
        sid(il, 1:je, 1:ke, :) = 0.0_8
        xxd(1:je+1, 1:ke+1, :) = xxd(1:je+1, 1:ke+1, :) + xd(il, 0:je, 0&
&         :ke, :)
        xd(il, 0:je, 0:ke, :) = 0.0_8
      case (jmin) 
        ssid(1:ie, 1:ke, :) = ssid(1:ie, 1:ke, :) + sjd(1:ie, 1, 1:ke, :&
&         )
        sjd(1:ie, 1, 1:ke, :) = 0.0_8
        xxd(1:ie+1, 1:ke+1, :) = xxd(1:ie+1, 1:ke+1, :) + xd(0:ie, 1, 0:&
&         ke, :)
        xd(0:ie, 1, 0:ke, :) = 0.0_8
      case (jmax) 
        ssid(1:ie, 1:ke, :) = ssid(1:ie, 1:ke, :) + sjd(1:ie, jl, 1:ke, &
&         :)
        sjd(1:ie, jl, 1:ke, :) = 0.0_8
        xxd(1:ie+1, 1:ke+1, :) = xxd(1:ie+1, 1:ke+1, :) + xd(0:ie, jl, 0&
&         :ke, :)
        xd(0:ie, jl, 0:ke, :) = 0.0_8
      case (kmin) 
        ssid(1:ie, 1:je, :) = ssid(1:ie, 1:je, :) + skd(1:ie, 1:je, 1, :&
&         )
        skd(1:ie, 1:je, 1, :) = 0.0_8
        xxd(1:ie+1, 1:je+1, :) = xxd(1:ie+1, 1:je+1, :) + xd(0:ie, 0:je&
&         , 1, :)
        xd(0:ie, 0:je, 1, :) = 0.0_8
      case (kmax) 
        ssid(1:ie, 1:je, :) = ssid(1:ie, 1:je, :) + skd(1:ie, 1:je, kl, &
&         :)
        skd(1:ie, 1:je, kl, :) = 0.0_8
        xxd(1:ie+1, 1:je+1, :) = xxd(1:ie+1, 1:je+1, :) + xd(0:ie, 0:je&
&         , kl, :)
        xd(0:ie, 0:je, kl, :) = 0.0_8
      end select
    end if
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .ne. 0) then
        if (branch .eq. 1) then
          rev0d(1:je, 1:ke) = rev0d(1:je, 1:ke) + revd(0, 1:je, 1:ke)
          revd(0, 1:je, 1:ke) = 0.0_8
          rev1d(1:je, 1:ke) = rev1d(1:je, 1:ke) + revd(1, 1:je, 1:ke)
          revd(1, 1:je, 1:ke) = 0.0_8
          rev2d(1:je, 1:ke) = rev2d(1:je, 1:ke) + revd(2, 1:je, 1:ke)
          revd(2, 1:je, 1:ke) = 0.0_8
          rev3d(1:je, 1:ke) = rev3d(1:je, 1:ke) + revd(3, 1:je, 1:ke)
          revd(3, 1:je, 1:ke) = 0.0_8
          rlv0d(1:je, 1:ke) = rlv0d(1:je, 1:ke) + rlvd(0, 1:je, 1:ke)
          rlvd(0, 1:je, 1:ke) = 0.0_8
          rlv1d(1:je, 1:ke) = rlv1d(1:je, 1:ke) + rlvd(1, 1:je, 1:ke)
          rlvd(1, 1:je, 1:ke) = 0.0_8
          rlv2d(1:je, 1:ke) = rlv2d(1:je, 1:ke) + rlvd(2, 1:je, 1:ke)
          rlvd(2, 1:je, 1:ke) = 0.0_8
          rlv3d(1:je, 1:ke) = rlv3d(1:je, 1:ke) + rlvd(3, 1:je, 1:ke)
          rlvd(3, 1:je, 1:ke) = 0.0_8
          pp0d(1:je, 1:ke) = pp0d(1:je, 1:ke) + pd(0, 1:je, 1:ke)
          pd(0, 1:je, 1:ke) = 0.0_8
          pp1d(1:je, 1:ke) = pp1d(1:je, 1:ke) + pd(1, 1:je, 1:ke)
          pd(1, 1:je, 1:ke) = 0.0_8
          pp2d(1:je, 1:ke) = pp2d(1:je, 1:ke) + pd(2, 1:je, 1:ke)
          pd(2, 1:je, 1:ke) = 0.0_8
          pp3d(1:je, 1:ke) = pp3d(1:je, 1:ke) + pd(3, 1:je, 1:ke)
          pd(3, 1:je, 1:ke) = 0.0_8
          ww0d(1:je, 1:ke, :) = ww0d(1:je, 1:ke, :) + wd(0, 1:je, 1:ke, &
&           :)
          wd(0, 1:je, 1:ke, :) = 0.0_8
          ww1d(1:je, 1:ke, :) = ww1d(1:je, 1:ke, :) + wd(1, 1:je, 1:ke, &
&           :)
          wd(1, 1:je, 1:ke, :) = 0.0_8
          ww2d(1:je, 1:ke, :) = ww2d(1:je, 1:ke, :) + wd(2, 1:je, 1:ke, &
&           :)
          wd(2, 1:je, 1:ke, :) = 0.0_8
          ww3d(1:je, 1:ke, :) = ww3d(1:je, 1:ke, :) + wd(3, 1:je, 1:ke, &
&           :)
          wd(3, 1:je, 1:ke, :) = 0.0_8
        else
          rev0d(1:je, 1:ke) = rev0d(1:je, 1:ke) + revd(ib, 1:je, 1:ke)
          revd(ib, 1:je, 1:ke) = 0.0_8
          rev1d(1:je, 1:ke) = rev1d(1:je, 1:ke) + revd(ie, 1:je, 1:ke)
          revd(ie, 1:je, 1:ke) = 0.0_8
          rev2d(1:je, 1:ke) = rev2d(1:je, 1:ke) + revd(il, 1:je, 1:ke)
          revd(il, 1:je, 1:ke) = 0.0_8
          rev3d(1:je, 1:ke) = rev3d(1:je, 1:ke) + revd(nx, 1:je, 1:ke)
          revd(nx, 1:je, 1:ke) = 0.0_8
          rlv0d(1:je, 1:ke) = rlv0d(1:je, 1:ke) + rlvd(ib, 1:je, 1:ke)
          rlvd(ib, 1:je, 1:ke) = 0.0_8
          rlv1d(1:je, 1:ke) = rlv1d(1:je, 1:ke) + rlvd(ie, 1:je, 1:ke)
          rlvd(ie, 1:je, 1:ke) = 0.0_8
          rlv2d(1:je, 1:ke) = rlv2d(1:je, 1:ke) + rlvd(il, 1:je, 1:ke)
          rlvd(il, 1:je, 1:ke) = 0.0_8
          rlv3d(1:je, 1:ke) = rlv3d(1:je, 1:ke) + rlvd(nx, 1:je, 1:ke)
          rlvd(nx, 1:je, 1:ke) = 0.0_8
          pp0d(1:je, 1:ke) = pp0d(1:je, 1:ke) + pd(ib, 1:je, 1:ke)
          pd(ib, 1:je, 1:ke) = 0.0_8
          pp1d(1:je, 1:ke) = pp1d(1:je, 1:ke) + pd(ie, 1:je, 1:ke)
          pd(ie, 1:je, 1:ke) = 0.0_8
          pp2d(1:je, 1:ke) = pp2d(1:je, 1:ke) + pd(il, 1:je, 1:ke)
          pd(il, 1:je, 1:ke) = 0.0_8
          pp3d(1:je, 1:ke) = pp3d(1:je, 1:ke) + pd(nx, 1:je, 1:ke)
          pd(nx, 1:je, 1:ke) = 0.0_8
          ww0d(1:je, 1:ke, :) = ww0d(1:je, 1:ke, :) + wd(ib, 1:je, 1:ke&
&           , :)
          wd(ib, 1:je, 1:ke, :) = 0.0_8
          ww1d(1:je, 1:ke, :) = ww1d(1:je, 1:ke, :) + wd(ie, 1:je, 1:ke&
&           , :)
          wd(ie, 1:je, 1:ke, :) = 0.0_8
          ww2d(1:je, 1:ke, :) = ww2d(1:je, 1:ke, :) + wd(il, 1:je, 1:ke&
&           , :)
          wd(il, 1:je, 1:ke, :) = 0.0_8
          ww3d(1:je, 1:ke, :) = ww3d(1:je, 1:ke, :) + wd(nx, 1:je, 1:ke&
&           , :)
          wd(nx, 1:je, 1:ke, :) = 0.0_8
        end if
      end if
    else if (branch .lt. 5) then
      if (branch .eq. 3) then
        rev0d(1:ie, 1:ke) = rev0d(1:ie, 1:ke) + revd(1:ie, 0, 1:ke)
        revd(1:ie, 0, 1:ke) = 0.0_8
        rev1d(1:ie, 1:ke) = rev1d(1:ie, 1:ke) + revd(1:ie, 1, 1:ke)
        revd(1:ie, 1, 1:ke) = 0.0_8
        rev2d(1:ie, 1:ke) = rev2d(1:ie, 1:ke) + revd(1:ie, 2, 1:ke)
        revd(1:ie, 2, 1:ke) = 0.0_8
        rev3d(1:ie, 1:ke) = rev3d(1:ie, 1:ke) + revd(1:ie, 3, 1:ke)
        revd(1:ie, 3, 1:ke) = 0.0_8
        rlv0d(1:ie, 1:ke) = rlv0d(1:ie, 1:ke) + rlvd(1:ie, 0, 1:ke)
        rlvd(1:ie, 0, 1:ke) = 0.0_8
        rlv1d(1:ie, 1:ke) = rlv1d(1:ie, 1:ke) + rlvd(1:ie, 1, 1:ke)
        rlvd(1:ie, 1, 1:ke) = 0.0_8
        rlv2d(1:ie, 1:ke) = rlv2d(1:ie, 1:ke) + rlvd(1:ie, 2, 1:ke)
        rlvd(1:ie, 2, 1:ke) = 0.0_8
        rlv3d(1:ie, 1:ke) = rlv3d(1:ie, 1:ke) + rlvd(1:ie, 3, 1:ke)
        rlvd(1:ie, 3, 1:ke) = 0.0_8
        pp0d(1:ie, 1:ke) = pp0d(1:ie, 1:ke) + pd(1:ie, 0, 1:ke)
        pd(1:ie, 0, 1:ke) = 0.0_8
        pp1d(1:ie, 1:ke) = pp1d(1:ie, 1:ke) + pd(1:ie, 1, 1:ke)
        pd(1:ie, 1, 1:ke) = 0.0_8
        pp2d(1:ie, 1:ke) = pp2d(1:ie, 1:ke) + pd(1:ie, 2, 1:ke)
        pd(1:ie, 2, 1:ke) = 0.0_8
        pp3d(1:ie, 1:ke) = pp3d(1:ie, 1:ke) + pd(1:ie, 3, 1:ke)
        pd(1:ie, 3, 1:ke) = 0.0_8
        ww0d(1:ie, 1:ke, :) = ww0d(1:ie, 1:ke, :) + wd(1:ie, 0, 1:ke, :)
        wd(1:ie, 0, 1:ke, :) = 0.0_8
        ww1d(1:ie, 1:ke, :) = ww1d(1:ie, 1:ke, :) + wd(1:ie, 1, 1:ke, :)
        wd(1:ie, 1, 1:ke, :) = 0.0_8
        ww2d(1:ie, 1:ke, :) = ww2d(1:ie, 1:ke, :) + wd(1:ie, 2, 1:ke, :)
        wd(1:ie, 2, 1:ke, :) = 0.0_8
        ww3d(1:ie, 1:ke, :) = ww3d(1:ie, 1:ke, :) + wd(1:ie, 3, 1:ke, :)
        wd(1:ie, 3, 1:ke, :) = 0.0_8
      else
        rev0d(1:ie, 1:ke) = rev0d(1:ie, 1:ke) + revd(1:ie, jb, 1:ke)
        revd(1:ie, jb, 1:ke) = 0.0_8
        rev1d(1:ie, 1:ke) = rev1d(1:ie, 1:ke) + revd(1:ie, je, 1:ke)
        revd(1:ie, je, 1:ke) = 0.0_8
        rev2d(1:ie, 1:ke) = rev2d(1:ie, 1:ke) + revd(1:ie, jl, 1:ke)
        revd(1:ie, jl, 1:ke) = 0.0_8
        rev3d(1:ie, 1:ke) = rev3d(1:ie, 1:ke) + revd(1:ie, ny, 1:ke)
        revd(1:ie, ny, 1:ke) = 0.0_8
        rlv0d(1:ie, 1:ke) = rlv0d(1:ie, 1:ke) + rlvd(1:ie, jb, 1:ke)
        rlvd(1:ie, jb, 1:ke) = 0.0_8
        rlv1d(1:ie, 1:ke) = rlv1d(1:ie, 1:ke) + rlvd(1:ie, je, 1:ke)
        rlvd(1:ie, je, 1:ke) = 0.0_8
        rlv2d(1:ie, 1:ke) = rlv2d(1:ie, 1:ke) + rlvd(1:ie, jl, 1:ke)
        rlvd(1:ie, jl, 1:ke) = 0.0_8
        rlv3d(1:ie, 1:ke) = rlv3d(1:ie, 1:ke) + rlvd(1:ie, ny, 1:ke)
        rlvd(1:ie, ny, 1:ke) = 0.0_8
        pp0d(1:ie, 1:ke) = pp0d(1:ie, 1:ke) + pd(1:ie, jb, 1:ke)
        pd(1:ie, jb, 1:ke) = 0.0_8
        pp1d(1:ie, 1:ke) = pp1d(1:ie, 1:ke) + pd(1:ie, je, 1:ke)
        pd(1:ie, je, 1:ke) = 0.0_8
        pp2d(1:ie, 1:ke) = pp2d(1:ie, 1:ke) + pd(1:ie, jl, 1:ke)
        pd(1:ie, jl, 1:ke) = 0.0_8
        pp3d(1:ie, 1:ke) = pp3d(1:ie, 1:ke) + pd(1:ie, ny, 1:ke)
        pd(1:ie, ny, 1:ke) = 0.0_8
        ww0d(1:ie, 1:ke, :) = ww0d(1:ie, 1:ke, :) + wd(1:ie, jb, 1:ke, :&
&         )
        wd(1:ie, jb, 1:ke, :) = 0.0_8
        ww1d(1:ie, 1:ke, :) = ww1d(1:ie, 1:ke, :) + wd(1:ie, je, 1:ke, :&
&         )
        wd(1:ie, je, 1:ke, :) = 0.0_8
        ww2d(1:ie, 1:ke, :) = ww2d(1:ie, 1:ke, :) + wd(1:ie, jl, 1:ke, :&
&         )
        wd(1:ie, jl, 1:ke, :) = 0.0_8
        ww3d(1:ie, 1:ke, :) = ww3d(1:ie, 1:ke, :) + wd(1:ie, ny, 1:ke, :&
&         )
        wd(1:ie, ny, 1:ke, :) = 0.0_8
      end if
    else if (branch .eq. 5) then
      rev0d(1:ie, 1:je) = rev0d(1:ie, 1:je) + revd(1:ie, 1:je, 0)
      revd(1:ie, 1:je, 0) = 0.0_8
      rev1d(1:ie, 1:je) = rev1d(1:ie, 1:je) + revd(1:ie, 1:je, 1)
      revd(1:ie, 1:je, 1) = 0.0_8
      rev2d(1:ie, 1:je) = rev2d(1:ie, 1:je) + revd(1:ie, 1:je, 2)
      revd(1:ie, 1:je, 2) = 0.0_8
      rev3d(1:ie, 1:je) = rev3d(1:ie, 1:je) + revd(1:ie, 1:je, 3)
      revd(1:ie, 1:je, 3) = 0.0_8
      rlv0d(1:ie, 1:je) = rlv0d(1:ie, 1:je) + rlvd(1:ie, 1:je, 0)
      rlvd(1:ie, 1:je, 0) = 0.0_8
      rlv1d(1:ie, 1:je) = rlv1d(1:ie, 1:je) + rlvd(1:ie, 1:je, 1)
      rlvd(1:ie, 1:je, 1) = 0.0_8
      rlv2d(1:ie, 1:je) = rlv2d(1:ie, 1:je) + rlvd(1:ie, 1:je, 2)
      rlvd(1:ie, 1:je, 2) = 0.0_8
      rlv3d(1:ie, 1:je) = rlv3d(1:ie, 1:je) + rlvd(1:ie, 1:je, 3)
      rlvd(1:ie, 1:je, 3) = 0.0_8
      pp0d(1:ie, 1:je) = pp0d(1:ie, 1:je) + pd(1:ie, 1:je, 0)
      pd(1:ie, 1:je, 0) = 0.0_8
      pp1d(1:ie, 1:je) = pp1d(1:ie, 1:je) + pd(1:ie, 1:je, 1)
      pd(1:ie, 1:je, 1) = 0.0_8
      pp2d(1:ie, 1:je) = pp2d(1:ie, 1:je) + pd(1:ie, 1:je, 2)
      pd(1:ie, 1:je, 2) = 0.0_8
      pp3d(1:ie, 1:je) = pp3d(1:ie, 1:je) + pd(1:ie, 1:je, 3)
      pd(1:ie, 1:je, 3) = 0.0_8
      ww0d(1:ie, 1:je, :) = ww0d(1:ie, 1:je, :) + wd(1:ie, 1:je, 0, :)
      wd(1:ie, 1:je, 0, :) = 0.0_8
      ww1d(1:ie, 1:je, :) = ww1d(1:ie, 1:je, :) + wd(1:ie, 1:je, 1, :)
      wd(1:ie, 1:je, 1, :) = 0.0_8
      ww2d(1:ie, 1:je, :) = ww2d(1:ie, 1:je, :) + wd(1:ie, 1:je, 2, :)
      wd(1:ie, 1:je, 2, :) = 0.0_8
      ww3d(1:ie, 1:je, :) = ww3d(1:ie, 1:je, :) + wd(1:ie, 1:je, 3, :)
      wd(1:ie, 1:je, 3, :) = 0.0_8
    else
      rev0d(1:ie, 1:je) = rev0d(1:ie, 1:je) + revd(1:ie, 1:je, kb)
      revd(1:ie, 1:je, kb) = 0.0_8
      rev1d(1:ie, 1:je) = rev1d(1:ie, 1:je) + revd(1:ie, 1:je, ke)
      revd(1:ie, 1:je, ke) = 0.0_8
      rev2d(1:ie, 1:je) = rev2d(1:ie, 1:je) + revd(1:ie, 1:je, kl)
      revd(1:ie, 1:je, kl) = 0.0_8
      rev3d(1:ie, 1:je) = rev3d(1:ie, 1:je) + revd(1:ie, 1:je, nz)
      revd(1:ie, 1:je, nz) = 0.0_8
      rlv0d(1:ie, 1:je) = rlv0d(1:ie, 1:je) + rlvd(1:ie, 1:je, kb)
      rlvd(1:ie, 1:je, kb) = 0.0_8
      rlv1d(1:ie, 1:je) = rlv1d(1:ie, 1:je) + rlvd(1:ie, 1:je, ke)
      rlvd(1:ie, 1:je, ke) = 0.0_8
      rlv2d(1:ie, 1:je) = rlv2d(1:ie, 1:je) + rlvd(1:ie, 1:je, kl)
      rlvd(1:ie, 1:je, kl) = 0.0_8
      rlv3d(1:ie, 1:je) = rlv3d(1:ie, 1:je) + rlvd(1:ie, 1:je, nz)
      rlvd(1:ie, 1:je, nz) = 0.0_8
      pp0d(1:ie, 1:je) = pp0d(1:ie, 1:je) + pd(1:ie, 1:je, kb)
      pd(1:ie, 1:je, kb) = 0.0_8
      pp1d(1:ie, 1:je) = pp1d(1:ie, 1:je) + pd(1:ie, 1:je, ke)
      pd(1:ie, 1:je, ke) = 0.0_8
      pp2d(1:ie, 1:je) = pp2d(1:ie, 1:je) + pd(1:ie, 1:je, kl)
      pd(1:ie, 1:je, kl) = 0.0_8
      pp3d(1:ie, 1:je) = pp3d(1:ie, 1:je) + pd(1:ie, 1:je, nz)
      pd(1:ie, 1:je, nz) = 0.0_8
      ww0d(1:ie, 1:je, :) = ww0d(1:ie, 1:je, :) + wd(1:ie, 1:je, kb, :)
      wd(1:ie, 1:je, kb, :) = 0.0_8
      ww1d(1:ie, 1:je, :) = ww1d(1:ie, 1:je, :) + wd(1:ie, 1:je, ke, :)
      wd(1:ie, 1:je, ke, :) = 0.0_8
      ww2d(1:ie, 1:je, :) = ww2d(1:ie, 1:je, :) + wd(1:ie, 1:je, kl, :)
      wd(1:ie, 1:je, kl, :) = 0.0_8
      ww3d(1:ie, 1:je, :) = ww3d(1:ie, 1:je, :) + wd(1:ie, 1:je, nz, :)
      wd(1:ie, 1:je, nz, :) = 0.0_8
    end if
  end subroutine resetbcpointers_b
  subroutine resetbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * resetbcpointers nullifyies the boundary pointers. for reverse  *
!      * mode ad it copies the values back in to the respective arrays  *
!      *                                                                *
!      ******************************************************************
!
    use bctypes
    use blockpointers
    use flowvarrefstate
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      w(3, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(2, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(1, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(0, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(3, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(2, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(1, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(0, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(3, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(2, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(1, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(0, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(3, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(2, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(1, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(0, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(3, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(2, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(1, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(0, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (imax) 
!===============================================================
      w(nx, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(il, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(ie, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(ib, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(nx, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(il, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(ie, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(ib, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(nx, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(il, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(ie, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(ib, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(nx, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(il, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(ie, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(ib, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(nx, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(il, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(ie, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(ib, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (jmin) 
!===============================================================
      w(1:ie, 3, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, 2, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, 1, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, 0, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, 3, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, 2, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, 1, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, 0, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, 3, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, 2, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, 1, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, 0, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, 3, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, 2, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, 1, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, 0, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, 3, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, 2, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, 1, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, 0, 1:ke) = gamma0(1:ie, 1:ke)
    case (jmax) 
!===============================================================
      w(1:ie, ny, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, jl, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, je, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, jb, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, ny, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, jl, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, je, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, jb, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, ny, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, jl, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, je, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, jb, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, ny, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, jl, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, je, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, jb, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, ny, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, jl, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, je, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, jb, 1:ke) = gamma0(1:ie, 1:ke)
    case (kmin) 
!===============================================================
      w(1:ie, 1:je, 3, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, 2, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, 1, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, 0, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, 3) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, 2) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, 1) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, 0) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, 3) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, 2) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, 1) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, 0) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, 3) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, 2) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, 1) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, 0) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, 3) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, 2) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, 1) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, 0) = gamma0(1:ie, 1:je)
    case (kmax) 
!===============================================================
      w(1:ie, 1:je, nz, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, kl, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, ke, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, kb, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, nz) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, kl) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, ke) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, kb) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, nz) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, kl) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, ke) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, kb) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, nz) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, kl) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, ke) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, kb) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, nz) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, kl) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, ke) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, kb) = gamma0(1:ie, 1:je)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        x(1, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(1, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (imax) 
        x(il, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(il, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (jmin) 
        x(0:ie, 1, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, 1, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (jmax) 
        x(0:ie, jl, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, jl, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (kmin) 
        x(0:ie, 0:je, 1, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, 1, :) = ssi(1:ie, 1:je, :)
      case (kmax) 
        x(0:ie, 0:je, kl, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, kl, :) = ssi(1:ie, 1:je, :)
      end select
    end if
  end subroutine resetbcpointers
end module bcroutines_b

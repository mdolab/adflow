!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
! this module contains routines used for applying *all* boundary
! conditions for navier stokes part of the code. boundary conditions
! pointers from the bcpointers modules are used. the utilty routines
! setbcpointers (and resetbcpointers) are employed.
module bcroutines_b
  implicit none
  save 

contains
  subroutine applyallbc_block(secondhalo)
! apply bc's for a single block
    use constants
    use blockpointers, only : nbocos, bctype, nviscbocos, w, dw, x, &
&   vol, il, jl, kl, sectionid, wold, volold, bcdata, si, sj, sk, sfacei&
&   , sfacej, sfacek, rlv, gamma, p, rev, bmtj1, bmtj2, scratch, bmtk2, &
&   bmtk1, fw, aa, d2wall, bmti1, bmti2, s
    use utils_b, only : setbcpointers, resetbcpointers, getcorrectfork
    use bcpointers_b
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo
! local variables.
    logical :: correctfork
    integer(kind=inttype) :: nn
!
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    correctfork = getcorrectfork()
! apply all the boundary conditions. the order is important!  only
! some of them have been ad'ed
! ------------------------------------
!  symmetry boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symm) then
        call setbcpointers(nn, .false.)
        call bcsymm1sthalo(nn)
        call resetbcpointers(nn, .false.)
      end if
    end do
    if (secondhalo) then
      do nn=1,nbocos
        if (bctype(nn) .eq. symm) then
          call setbcpointers(nn, .false.)
          call bcsymm2ndhalo(nn)
          call resetbcpointers(nn, .false.)
        end if
      end do
    end if
! ------------------------------------
!  symmetry polar boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. symmpolar) then
        call setbcpointers(nn, .true.)
        call bcsymmpolar1sthalo(nn)
        call resetbcpointers(nn, .true.)
      end if
    end do
    if (secondhalo) then
      do nn=1,nbocos
        if (bctype(nn) .eq. symmpolar) then
          call setbcpointers(nn, .true.)
          call bcsymmpolar2ndhalo(nn)
          call resetbcpointers(nn, .true.)
        end if
      end do
    end if
! ------------------------------------
!  adibatic wall boundary condition
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswalladiabatic) then
        call setbcpointers(nn, .false.)
        call bcnswalladiabatic(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  isotermal wall boundary condition
! ------------------------------------
    do nn=1,nviscbocos
      if (bctype(nn) .eq. nswallisothermal) then
        call setbcpointers(nn, .false.)
        call bcnswallisothermal(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  farfield boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. farfield) then
        call setbcpointers(nn, .false.)
        call bcfarfield(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  subsonic outflow boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. subsonicoutflow .or. bctype(nn) .eq. &
&         massbleedoutflow) then
        call setbcpointers(nn, .false.)
        call bcsubsonicoutflow(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  subsonic inflow boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. subsonicinflow) then
        call setbcpointers(nn, .false.)
        call bcsubsonicinflow(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  extrapolation boundary condition
! ------------------------------------
! extrapolation boundary conditions; this also includes
! the supersonic outflow boundary conditions. the difference
! between the two is that the extrap boundary conditions
! correspond to singular lines and supersonic outflow
! boundaries to physical boundaries. the treatment however
! is identical.
    do nn=1,nbocos
      if (bctype(nn) .eq. extrap .or. bctype(nn) .eq. supersonicoutflow&
&     ) then
        call setbcpointers(nn, .false.)
        call bcextrap(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
! ------------------------------------
!  euler wall boundary condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. eulerwall) then
        call setbcpointers(nn, .true.)
        call bceulerwall(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .true.)
      end if
    end do
! ------------------------------------
!  supersonic inflow condition
! ------------------------------------
    do nn=1,nbocos
      if (bctype(nn) .eq. supersonicinflow) then
        call setbcpointers(nn, .false.)
        call bcsupersonicinflow(nn, secondhalo, correctfork)
        call resetbcpointers(nn, .false.)
      end if
    end do
  end subroutine applyallbc_block
!  differentiation of bcsymm1sthalo in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*bcdata.norm) *rev1 *rev2
!                *pp1 *pp2 *rlv1 *rlv2 *ww1 *ww2
!   with respect to varying inputs: *(*bcdata.norm) *rev1 *rev2
!                *pp1 *pp2 *rlv1 *rlv2 *ww1 *ww2
!   rw status of diff variables: *(*bcdata.norm):incr *rev1:in-out
!                *rev2:incr *pp1:in-out *pp2:incr *rlv1:in-out
!                *rlv2:incr *ww1:in-out *ww2:incr
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev1:in
!                rev2:in pp1:in pp2:in rlv1:in rlv2:in ww1:in ww2:in
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm1sthalo_b(nn)
!  bcsymm1sthalo applies the symmetry boundary conditions to a
!  block.  * it is assumed that the pointers in blockpointers are
!  already set to the correct block on the correct grid level.
!
!  in case also the second halo must be set, a second loop is
!  execulted calling bcsymm2ndhalo. this is the only correct way
!  in case the block contains only 1 cell between two symmetry
!  planes, i.e. a 2d problem.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_b, only : gamma1, gamma2, ww1, ww1d, ww2, ww2d, pp1, &
&   pp1d, pp2, pp2d, rlv1, rlv1d, rlv2, rlv2d, istart, jstart, isize, &
&   jsize, rev1, rev1d, rev2, rev2d
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: tempd
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
        rlv1d(i, j) = 0.0_8
      end if
      pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
      pp1d(i, j) = 0.0_8
      ww2d(i, j, irhoe) = ww2d(i, j, irhoe) + ww1d(i, j, irhoe)
      ww1d(i, j, irhoe) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + ww1d(i, j, ivz)
      vnd = -(bcdata(nn)%norm(i, j, 3)*ww1d(i, j, ivz))
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww1d(i&
&       , j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + ww1d(i, j, ivy)
      vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww1d(i, j, ivy)
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww1d(i&
&       , j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + ww1d(i, j, ivx)
      vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww1d(i, j, ivx)
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww1d(i&
&       , j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
      ww1d(i, j, irho) = 0.0_8
      tempd = two*vnd
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*tempd
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww2(i, j, &
&       ivx)*tempd
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*tempd
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww2(i, j, &
&       ivy)*tempd
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*tempd
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww2(i, j, &
&       ivz)*tempd
    end do
  end subroutine bcsymm1sthalo_b
! ===================================================================
!   actual implementation of each of the boundary condition routines
! ===================================================================
  subroutine bcsymm1sthalo(nn)
!  bcsymm1sthalo applies the symmetry boundary conditions to a
!  block.  * it is assumed that the pointers in blockpointers are
!  already set to the correct block on the correct grid level.
!
!  in case also the second halo must be set, a second loop is
!  execulted calling bcsymm2ndhalo. this is the only correct way
!  in case the block contains only 1 cell between two symmetry
!  planes, i.e. a 2d problem.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_b, only : gamma1, gamma2, ww1, ww2, pp1, pp2, rlv1, &
&   rlv2, istart, jstart, isize, jsize, rev1, rev2
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine twice the normal velocity component,
! which must be substracted from the donor velocity
! to obtain the halo velocity.
      vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma1(i, j) = gamma2(i, j)
      pp1(i, j) = pp2(i, j)
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
  end subroutine bcsymm1sthalo
!  differentiation of bcsymm2ndhalo in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*bcdata.norm) *rev0 *rev3
!                *pp0 *pp3 *rlv0 *rlv3 *ww0 *ww3
!   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev3
!                *pp0 *pp3 *rlv0 *rlv3 *ww0 *ww3
!   rw status of diff variables: *(*bcdata.norm):incr *rev0:in-out
!                *rev3:incr *pp0:in-out *pp3:incr *rlv0:in-out
!                *rlv3:incr *ww0:in-out *ww3:incr
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
!                rev3:in pp0:in pp3:in rlv0:in rlv3:in ww0:in ww3:in
  subroutine bcsymm2ndhalo_b(nn)
!  bcsymm2ndhalo applies the symmetry boundary conditions to a
!  block for the 2nd halo. this routine is separate as it makes
!  ad slightly easier.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_b, only : gamma0, gamma3, ww0, ww0d, ww3, ww3d, pp0, &
&   pp0d, pp3, pp3d, rlv0, rlv0d, rlv3, rlv3d, rev0, rev0d, rev3, rev3d,&
&   istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    real(kind=realtype) :: vnd
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: tempd
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev3d(i, j) = rev3d(i, j) + rev0d(i, j)
        rev0d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv3d(i, j) = rlv3d(i, j) + rlv0d(i, j)
        rlv0d(i, j) = 0.0_8
      end if
      pp3d(i, j) = pp3d(i, j) + pp0d(i, j)
      pp0d(i, j) = 0.0_8
      ww3d(i, j, irhoe) = ww3d(i, j, irhoe) + ww0d(i, j, irhoe)
      ww0d(i, j, irhoe) = 0.0_8
      ww3d(i, j, ivz) = ww3d(i, j, ivz) + ww0d(i, j, ivz)
      vnd = -(bcdata(nn)%norm(i, j, 3)*ww0d(i, j, ivz))
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww0d(i&
&       , j, ivz)
      ww0d(i, j, ivz) = 0.0_8
      ww3d(i, j, ivy) = ww3d(i, j, ivy) + ww0d(i, j, ivy)
      vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww0d(i, j, ivy)
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww0d(i&
&       , j, ivy)
      ww0d(i, j, ivy) = 0.0_8
      ww3d(i, j, ivx) = ww3d(i, j, ivx) + ww0d(i, j, ivx)
      vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww0d(i, j, ivx)
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww0d(i&
&       , j, ivx)
      ww0d(i, j, ivx) = 0.0_8
      ww3d(i, j, irho) = ww3d(i, j, irho) + ww0d(i, j, irho)
      ww0d(i, j, irho) = 0.0_8
      tempd = two*vnd
      ww3d(i, j, ivx) = ww3d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*tempd
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww3(i, j, &
&       ivx)*tempd
      ww3d(i, j, ivy) = ww3d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*tempd
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww3(i, j, &
&       ivy)*tempd
      ww3d(i, j, ivz) = ww3d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*tempd
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww3(i, j, &
&       ivz)*tempd
    end do
  end subroutine bcsymm2ndhalo_b
  subroutine bcsymm2ndhalo(nn)
!  bcsymm2ndhalo applies the symmetry boundary conditions to a
!  block for the 2nd halo. this routine is separate as it makes
!  ad slightly easier.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : viscous, eddymodel
    use bcpointers_b, only : gamma0, gamma3, ww0, ww3, pp0, pp3, rlv0, &
&   rlv3, rev0, rev3, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: vn, nnx, nny, nnz
    intrinsic mod
! if we need the second halo, do everything again, but using ww0,
! ww3 etc instead of ww2 and ww1.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)*&
&       bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
&       )
! determine the flow variables in the halo cell.
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
      ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
      ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
! set the pressure and gamma and possibly the
! laminar and eddy viscosity in the halo.
      gamma0(i, j) = gamma3(i, j)
      pp0(i, j) = pp3(i, j)
      if (viscous) rlv0(i, j) = rlv3(i, j)
      if (eddymodel) rev0(i, j) = rev3(i, j)
    end do
  end subroutine bcsymm2ndhalo
  subroutine bcsymmpolar1sthalo(nn)
! bcsymmpolar applies the polar symmetry boundary conditions to a
! singular line of a block. it is assumed that the pointers in
! blockpointers are already set to the correct block on the
! correct grid level.  the polar symmetry condition is a special
! case of a degenerate line, as this line is the axi-symmetric
! centerline. this routine does just the 1st level halo.
    use constants
    use bcpointers_b, only : ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, rev2,&
&   xx, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii, mm
    real(kind=realtype) :: nnx, nny, nnz, tmp, vtx, vty, vtz
    intrinsic mod
    intrinsic sqrt
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine the unit vector along the degenerated face.
! however it is not known which is the singular
! direction and therefore determine the direction along
! the diagonal (i,j) -- (i-1,j-1), which is correct for
! both singular i and j-direction. note that due to the
! usage of the pointer xx there is an offset of +1
! in the indices and therefore (i+1,j+1) - (i,j) must
! be used to determine this vector.
      nnx = xx(i+1, j+1, 1) - xx(i, j, 1)
      nny = xx(i+1, j+1, 2) - xx(i, j, 2)
      nnz = xx(i+1, j+1, 3) - xx(i, j, 3)
! determine the unit vector in this direction.
      tmp = one/sqrt(nnx*nnx+nny*nny+nnz*nnz)
      nnx = nnx*tmp
      nny = nny*tmp
      nnz = nnz*tmp
! determine twice the tangential velocity vector of the
! internal cell.
      tmp = two*(ww2(i, j, ivx)*nnx+ww2(i, j, ivy)*nny+ww2(i, j, ivz)*&
&       nnz)
      vtx = tmp*nnx
      vty = tmp*nny
      vtz = tmp*nnz
! determine the flow variables in the halo cell. the
! velocity is constructed such that the average of the
! internal and the halo cell is along the centerline.
! note that the magnitude of the velocity does not
! change and thus the energy is identical.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = vtx - ww2(i, j, ivx)
      ww1(i, j, ivy) = vty - ww2(i, j, ivy)
      ww1(i, j, ivz) = vtz - ww2(i, j, ivz)
      ww1(i, j, irhoe) = ww2(i, j, irhoe)
! set the pressure and possibly the laminar and
! eddy viscosity in the halo.
      pp1(i, j) = pp2(i, j)
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
  end subroutine bcsymmpolar1sthalo
  subroutine bcsymmpolar2ndhalo(nn)
! bcsymmpolar applies the polar symmetry boundary conditions to a
! singular line of a block. it is assumed that the pointers in
! blockpointers are already set to the correct block on the
! correct grid level.  the polar symmetry condition is a special
! case of a degenerate line, as this line is the axi-symmetric
! centerline. this routine does just the 2nd level halo.
    use constants
    use bcpointers_b, only : ww0, ww3, pp0, pp3, rlv0, rlv3, rev0, rev3,&
&   xx, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii, mm
    real(kind=realtype) :: nnx, nny, nnz, tmp, vtx, vty, vtz
    intrinsic mod
    intrinsic sqrt
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! determine the unit vector along the degenerated face.
! however it is not known which is the singular
! direction and therefore determine the direction along
! the diagonal (i,j) -- (i-1,j-1), which is correct for
! both singular i and j-direction. note that due to the
! usage of the pointer xx there is an offset of +1
! in the indices and therefore (i+1,j+1) - (i,j) must
! be used to determine this vector.
      nnx = xx(i+1, j+1, 1) - xx(i, j, 1)
      nny = xx(i+1, j+1, 2) - xx(i, j, 2)
      nnz = xx(i+1, j+1, 3) - xx(i, j, 3)
! determine the unit vector in this direction.
      tmp = one/sqrt(nnx*nnx+nny*nny+nnz*nnz)
      nnx = nnx*tmp
      nny = nny*tmp
      nnz = nnz*tmp
! determine twice the tangential velocity vector of the
! internal cell.
      tmp = two*(ww3(i, j, ivx)*nnx+ww3(i, j, ivy)*nny+ww3(i, j, ivz)*&
&       nnz)
      vtx = tmp*nnx
      vty = tmp*nny
      vtz = tmp*nnz
! determine the flow variables in the halo cell. the
! velocity is constructed such that the average of the
! internal and the halo cell is along the centerline.
! note that the magnitude of the velocity does not
! change and thus the energy is identical.
      ww0(i, j, irho) = ww3(i, j, irho)
      ww0(i, j, ivx) = vtx - ww3(i, j, ivx)
      ww0(i, j, ivy) = vty - ww3(i, j, ivy)
      ww0(i, j, ivz) = vtz - ww3(i, j, ivz)
      ww0(i, j, irhoe) = ww3(i, j, irhoe)
! set the pressure and possibly the laminar and
! eddy viscosity in the halo.
      pp0(i, j) = pp3(i, j)
      if (viscous) rlv0(i, j) = rlv3(i, j)
      if (eddymodel) rev0(i, j) = rev3(i, j)
    end do
  end subroutine bcsymmpolar2ndhalo
!  differentiation of bcnswalladiabatic in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
!                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   rw status of diff variables: *rev0:in-out *rev1:in-out *rev2:incr
!                *pp0:in-out *pp1:in-out *pp2:incr *rlv0:in-out
!                *rlv1:in-out *rlv2:incr *ww0:in-out *ww1:in-out
!                *ww2:incr
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in
  subroutine bcnswalladiabatic_b(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous adiabatic wall boundary
! condition the pointers already defined.
    use constants
    use blockpointers, only : bcdata, bcdatad
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_b, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, rlv0, &
&   rlv0d, rlv1, rlv1d, rlv2, rlv2d, pp0, pp0d, pp1, pp1d, pp2, pp2d, &
&   pp3, pp3d, rev0, rev0d, rev1, rev1d, rev2, rev2d, istart, jstart, &
&   isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    use iteration, only : currentlevel, groundlevel
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    real(kind=realtype) :: rhokd
    integer(kind=inttype) :: walltreatment
    intrinsic mod
    integer :: branch
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) pp1(i, j) = pp2(i, j)
      end select
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    rhokd = 0.0_8
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      if (eddymodel) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
        pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
        rhokd = rhokd - four*third*pp1d(i, j)
        pp1d(i, j) = 0.0_8
      case default
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) then
          pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
          pp1d(i, j) = 0.0_8
        end if
        pp2d(i, j) = pp2d(i, j) + 2*pp1d(i, j)
        pp1d(i, j) = 0.0_8
      end select
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
      rlv1d(i, j) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
      ww1d(i, j, irho) = 0.0_8
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
        ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
        rhokd = 0.0_8
      end if
    end do
  end subroutine bcnswalladiabatic_b
  subroutine bcnswalladiabatic(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous adiabatic wall boundary
! condition the pointers already defined.
    use constants
    use blockpointers, only : bcdata
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_b, only : ww0, ww1, ww2, rlv0, rlv1, rlv2, pp0, pp1, &
&   pp2, pp3, rev0, rev1, rev2, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel
    use iteration, only : currentlevel, groundlevel
    implicit none
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
    integer(kind=inttype) :: i, j, ii
    real(kind=realtype) :: rhok
    integer(kind=inttype) :: walltreatment
    intrinsic mod
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = ww2(i, j, irho)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) pp1(i, j) = pp2(i, j)
      end select
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswalladiabatic
!  differentiation of bcnswallisothermal in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: rgas *rev0 *rev1 *rev2 *pp0
!                *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   with respect to varying inputs: rgas *rev0 *rev1 *rev2 *pp0
!                *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
!   rw status of diff variables: rgas:incr *rev0:in-out *rev1:in-out
!                *rev2:incr *pp0:in-out *pp1:in-out *pp2:incr *rlv0:in-out
!                *rlv1:in-out *rlv2:incr *ww0:in-out *ww1:in-out
!                *ww2:incr
!   plus diff mem management of: rev0:in rev1:in rev2:in pp0:in
!                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
!                ww2:in
  subroutine bcnswallisothermal_b(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous isothermal wall boundary
! condition to a block. it is assumed that the bcpointers are
! already set
    use constants
    use blockpointers, only : bcdata, bcdatad
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_b, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, rlv0, &
&   rlv0d, rlv1, rlv1d, rlv2, rlv2d, pp0, pp0d, pp1, pp1d, pp2, pp2d, &
&   pp3, pp3d, rev0, rev0d, rev1, rev1d, rev2, rev2d, istart, jstart, &
&   isize, jsize
    use flowvarrefstate, only : viscous, eddymodel, rgas, rgasd
    use iteration, only : currentlevel, groundlevel
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: rhok, t2, t1
    real(kind=realtype) :: rhokd, t2d, t1d
    intrinsic mod
    intrinsic max
    intrinsic min
    integer :: branch
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call pushreal8(rhok)
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! pressure extrapolation
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
! linear extrapolation.
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) pp1(i, j) = pp2(i, j)
      end select
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    rhokd = 0.0_8
    call popreal8(rhok)
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) then
        rhok = ww2(i, j, irho)*ww2(i, j, itu1)
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        call pushcontrol1b(0)
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
        call pushcontrol1b(1)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        call pushcontrol1b(0)
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
        call pushcontrol1b(1)
      end if
! pressure extrapolation
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1(i, j) = pp2(i, j) - four*third*rhok
        call pushcontrol2b(0)
      case default
! linear extrapolation.
        call pushinteger4(i)
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) then
          pp1(i, j) = pp2(i, j)
          call pushcontrol2b(1)
        else
          call pushcontrol2b(2)
        end if
      end select
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
      rlv1d(i, j) = 0.0_8
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      tempd0 = ww1d(i, j, irho)/(rgas*t1)
      tempd1 = -(pp1(i, j)*tempd0/(rgas*t1))
      pp1d(i, j) = pp1d(i, j) + tempd0
      rgasd = rgasd + t1*tempd1
      t1d = rgas*tempd1
      ww1d(i, j, irho) = 0.0_8
      call popcontrol2b(branch)
      if (branch .eq. 0) then
        pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
        rhokd = rhokd - four*third*pp1d(i, j)
        pp1d(i, j) = 0.0_8
      else
        if (branch .eq. 1) then
          pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
          pp1d(i, j) = 0.0_8
        end if
        pp2d(i, j) = pp2d(i, j) + 2*pp1d(i, j)
        pp1d(i, j) = 0.0_8
        j = ii/isize + jstart
        call popinteger4(i)
      end if
      call popcontrol1b(branch)
      if (branch .ne. 0) t1d = 0.0_8
      call popcontrol1b(branch)
      if (branch .ne. 0) t1d = 0.0_8
      t2d = -t1d
      temp = rgas*ww2(i, j, irho)
      tempd = -(pp2(i, j)*t2d/temp**2)
      pp2d(i, j) = pp2d(i, j) + t2d/temp
      rgasd = rgasd + ww2(i, j, irho)*tempd
      ww2d(i, j, irho) = ww2d(i, j, irho) + rgas*tempd
      call popcontrol1b(branch)
      if (branch .ne. 0) then
        ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
        ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
        rhokd = 0.0_8
      end if
    end do
  end subroutine bcnswallisothermal_b
  subroutine bcnswallisothermal(nn, secondhalo, correctfork)
! bcnswalladiabatic applies the viscous isothermal wall boundary
! condition to a block. it is assumed that the bcpointers are
! already set
    use constants
    use blockpointers, only : bcdata
    use inputdiscretization, only : viscwallbctreatment
    use bcpointers_b, only : ww0, ww1, ww2, rlv0, rlv1, rlv2, pp0, pp1, &
&   pp2, pp3, rev0, rev1, rev2, istart, jstart, isize, jsize
    use flowvarrefstate, only : viscous, eddymodel, rgas
    use iteration, only : currentlevel, groundlevel
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: rhok, t2, t1
    intrinsic mod
    intrinsic max
    intrinsic min
! initialize rhok to zero. this will be overwritten if a
! correction for k must be applied.
    rhok = zero
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! set the value of rhok if a correcton must be applied.
! it probably does not matter too much, because k is very
! small near the wall.
      if (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
      t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
      t1 = two*bcdata(nn)%tns_wall(i, j) - t2
      if (half*bcdata(nn)%tns_wall(i, j) .lt. t1) then
        t1 = t1
      else
        t1 = half*bcdata(nn)%tns_wall(i, j)
      end if
      if (two*bcdata(nn)%tns_wall(i, j) .gt. t1) then
        t1 = t1
      else
        t1 = two*bcdata(nn)%tns_wall(i, j)
      end if
! pressure extrapolation
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
      walltreatment = viscwallbctreatment
      if (currentlevel .gt. groundlevel) walltreatment = &
&         constantpressure
      select case  (walltreatment) 
      case (constantpressure) 
! constant pressure. set the gradient to zero.
        pp1(i, j) = pp2(i, j) - four*third*rhok
      case default
! linear extrapolation.
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        pp1(i, j) = 2*pp2(i, j) - pp3(i, j)
! adjust value if pressure is negative
        if (pp1(i, j) .le. zero) pp1(i, j) = pp2(i, j)
      end select
! determine the variables in the halo. as the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. take the slip
! velocity into account.
      ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
      ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
      ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
      ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
! set the viscosities. there is no need to test for a
! viscous problem of course. the eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
      rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = -rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcnswallisothermal
  subroutine bcsubsonicoutflow(nn, secondhalo, correctfork)
!  bcsubsonicoutflow applies the subsonic outflow boundary
!  condition, static pressure prescribed, to a block. it is
!  assumed that the pointers in blockpointers are already set to
!  the correct block on the correct grid level.  exactly the same
!  boundary condition is also applied for an outflow mass
!  bleed. therefore the test is for both a subsonic outflow and an
!  bleed outflow.
    use constants
    use blockpointers, only : bcdata
    use bcpointers_b, only : gamma2, rev2, rlv2, pp2, ww2, rlv1, rev1, &
&   pp1, ww1, isize, jsize, istart, jstart
    use flowvarrefstate, only : eddymodel, viscous
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype) :: ovg, ovgm1, nnx, nny, nnz
    real(kind=realtype) :: pexit, pint, r, a2, a, ac, ss
    real(kind=realtype) :: ue, ve, we, qne, qnh
    intrinsic mod
    intrinsic sqrt
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! store a couple of variables, such as the static
! pressure and grid unit outward normal, a bit easier.
      pexit = bcdata(nn)%ps(i, j)
      nnx = bcdata(nn)%norm(i, j, 1)
      nny = bcdata(nn)%norm(i, j, 2)
      nnz = bcdata(nn)%norm(i, j, 3)
! abbreviate 1/gamma and 1/(gamma -1) a bit easier.
      ovg = one/gamma2(i, j)
      ovgm1 = one/(gamma2(i, j)-one)
! store the internal pressure and correct for the
! possible presence of a k-equation.
      pint = pp2(i, j)
      if (correctfork) pint = pint - twothird*ww2(i, j, irho)*ww2(i, j, &
&         itu1)
! compute the velocity components, the normal velocity
! and the speed of sound for the internal cell.
      r = one/ww2(i, j, irho)
      a2 = gamma2(i, j)*pint*r
      a = sqrt(a2)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*nnx + ve*nny + we*nnz
! compute the entropy and the acoustic variable.
! these riemann invariants, as well as the tangential
! velocity components, are extrapolated.
      ss = pint*r**gamma2(i, j)
      ac = qne + two*a*ovgm1
! compute the state in the halo.
      ww1(i, j, irho) = (pexit/ss)**ovg
      pp1(i, j) = pexit
      a = sqrt(gamma2(i, j)*pexit/ww1(i, j, irho))
      qnh = ac - two*a*ovgm1
      ww1(i, j, ivx) = ue + (qnh-qne)*nnx
      ww1(i, j, ivy) = ve + (qnh-qne)*nny
      ww1(i, j, ivz) = we + (qnh-qne)*nnz
! correct the pressure if a k-equation is present.
      if (correctfork) pp1(i, j) = pp1(i, j) + twothird*ww1(i, j, irho)*&
&         ww1(i, j, itu1)
! set the viscosities in the halo to the viscosities
! in the donor cell.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcsubsonicoutflow
  subroutine bcsubsonicinflow(nn, secondhalo, correctfork)
!  bcsubsonicinflow applies the subsonic outflow boundary
!  condition, total pressure, total density and flow direction
!  prescribed, to a block. it is assumed that the pointers in
!  blockpointers are already set to the correct block on the
!  correct grid level.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : viscous, eddymodel, rgas
    use inputdiscretization, only : hscalinginlet
    use bcpointers_b, only : gamma2, ww2, pp2, rlv1, rlv2, rev1, rev2, &
&   ww1, pp1, isize, jsize, istart, jstart
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: gm1, ovgm1
    real(kind=realtype) :: ptot, ttot, htot, a2tot, r, alpha, beta
    real(kind=realtype) :: aa2, bb, cc, dd, q, q2, a2, m2, scalefact
    real(kind=realtype) :: ssx, ssy, ssz, nnx, nny, nnz
    real(kind=realtype) :: rho, velx, vely, velz
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic min
    real(kind=realtype) :: max1
! determine the boundary treatment to be used.
    select case  (bcdata(nn)%subsonicinlettreatment) 
    case (totalconditions) 
! the total conditions have been prescribed.
! loop over the generic subface to set the state in the
! halo cells.
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store a couple of variables, such as the total
! pressure, total temperature, total enthalpy, flow
! direction and grid unit outward normal, a bit easier.
        ptot = bcdata(nn)%ptinlet(i, j)
        ttot = bcdata(nn)%ttinlet(i, j)
        htot = bcdata(nn)%htinlet(i, j)
        ssx = bcdata(nn)%flowxdirinlet(i, j)
        ssy = bcdata(nn)%flowydirinlet(i, j)
        ssz = bcdata(nn)%flowzdirinlet(i, j)
        nnx = bcdata(nn)%norm(i, j, 1)
        nny = bcdata(nn)%norm(i, j, 2)
        nnz = bcdata(nn)%norm(i, j, 3)
! some abbreviations in which gamma occurs.
        gm1 = gamma2(i, j) - one
        ovgm1 = one/gm1
! determine the acoustic riemann variable that must be
! extrapolated from the domain.
        r = one/ww2(i, j, irho)
        a2 = gamma2(i, j)*pp2(i, j)*r
        beta = ww2(i, j, ivx)*nnx + ww2(i, j, ivy)*nny + ww2(i, j, ivz)*&
&         nnz + two*ovgm1*sqrt(a2)
! correct the value of the riemann invariant if total
! enthalpy scaling must be applied. this scaling may
! be needed for stability if large gradients of the
! total temperature are prescribed.
        scalefact = one
        if (hscalinginlet) scalefact = sqrt(htot/(r*(ww2(i, j, irhoe)+&
&           pp2(i, j))))
        beta = beta*scalefact
! compute the value of a2 + 0.5*gm1*q2, which is the
! total speed of sound for constant cp. however, the
! expression below is also valid for variable cp,
! although a linearization around the value of the
! internal cell is performed.
        q2 = ww2(i, j, ivx)**2 + ww2(i, j, ivy)**2 + ww2(i, j, ivz)**2
        a2tot = gm1*(htot-r*(ww2(i, j, irhoe)+pp2(i, j))+half*q2) + a2
! compute the dot product between the normal and the
! velocity direction. this value should be negative.
        alpha = nnx*ssx + nny*ssy + nnz*ssz
! compute the coefficients in the quadratic equation
! for the magnitude of the velocity.
        aa2 = half*gm1*alpha*alpha + one
        bb = -(gm1*alpha*beta)
        cc = half*gm1*beta*beta - two*ovgm1*a2tot
! solve the equation for the magnitude of the
! velocity. as this value must be positive and both aa2
! and bb are positive (alpha is negative and beta is
! positive up till mach = 5.0 or so, which is not
! really subsonic anymore), it is clear which of the
! two possible solutions must be taken. some clipping
! is present, but this is normally not active.
        dd = bb*bb - four*aa2*cc
        if (zero .lt. dd) then
          max1 = dd
        else
          max1 = zero
        end if
        dd = sqrt(max1)
        q = (-bb+dd)/(two*aa2)
        if (zero .lt. q) then
          q = q
        else
          q = zero
        end if
        q2 = q*q
! compute the speed of sound squared from the total
! speed of sound equation (== total enthalpy equation
! for constant cp).
        a2 = a2tot - half*gm1*q2
! compute the mach number squared and cut it between
! 0.0 and 1.0. adapt the velocity and speed of sound
! squared accordingly.
        m2 = q2/a2
        if (one .gt. m2) then
          m2 = m2
        else
          m2 = one
        end if
        q2 = m2*a2
        q = sqrt(q2)
        a2 = a2tot - half*gm1*q2
! compute the velocities in the halo cell and use rho,
! rhoe and p as temporary buffers to store the total
! temperature, total pressure and static temperature.
        ww1(i, j, ivx) = q*ssx
        ww1(i, j, ivy) = q*ssy
        ww1(i, j, ivz) = q*ssz
        ww1(i, j, irho) = ttot
        pp1(i, j) = ptot
        ww1(i, j, irhoe) = a2/(gamma2(i, j)*rgas)
! set the viscosities in the halo to the viscosities
! in the donor cell.
        if (viscous) rlv1(i, j) = rlv2(i, j)
        if (eddymodel) rev1(i, j) = rev2(i, j)
      end do
! compute the pressure and density for these halo's.
      call prhosubsonicinlet(ww1, pp1, correctfork)
    case (massflow) 
!===========================================================
! density and velocity vector prescribed.
! loop over the generic subface to set the state in the
! halo cells.
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store a couple of variables, such as the density,
! velocity and grid unit outward normal, a bit easier.
        rho = bcdata(nn)%rho(i, j)
        velx = bcdata(nn)%velx(i, j)
        vely = bcdata(nn)%vely(i, j)
        velz = bcdata(nn)%velz(i, j)
        nnx = bcdata(nn)%norm(i, j, 1)
        nny = bcdata(nn)%norm(i, j, 2)
        nnz = bcdata(nn)%norm(i, j, 3)
! some abbreviations in which gamma occurs.
        gm1 = gamma2(i, j) - one
        ovgm1 = one/gm1
! determine the acoustic riemann variable that must be
! extrapolated from the domain.
        r = one/ww2(i, j, irho)
        a2 = gamma2(i, j)*pp2(i, j)*r
        beta = ww2(i, j, ivx)*nnx + ww2(i, j, ivy)*nny + ww2(i, j, ivz)*&
&         nnz + two*ovgm1*sqrt(a2)
! compute the speed of sound squared in the halo.
        a2 = half*gm1*(beta-velx*nnx-vely*nny-velz*nnz)
        if (zero .lt. a2) then
          a2 = a2
        else
          a2 = zero
        end if
        a2 = a2*a2
! compute the pressure in the halo, assuming a
! constant value of gamma.
        pp1(i, j) = rho*a2/gamma2(i, j)
! simply copy the density and velocities.
        ww1(i, j, irho) = rho
        ww1(i, j, ivx) = velx
        ww1(i, j, ivy) = vely
        ww1(i, j, ivz) = velz
! set the viscosities in the halo to the viscosities
! in the donor cell.
        if (viscous) rlv1(i, j) = rlv2(i, j)
        if (eddymodel) rev1(i, j) = rev2(i, j)
      end do
    end select
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcsubsonicinflow
!  differentiation of bceulerwall in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*bcdata.norm) *rev0 *rev1
!                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ss
!                *ssi *ssj *ssk *ww0 *ww1 *ww2
!   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
!                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ss
!                *ssi *ssj *ssk *ww0 *ww1 *ww2
!   rw status of diff variables: *(*bcdata.norm):incr *rev0:in-out
!                *rev1:in-out *rev2:incr *pp0:in-out *pp1:in-out
!                *pp2:incr *pp3:incr *rlv0:in-out *rlv1:in-out
!                *rlv2:incr *ss:incr *ssi:incr *ssj:incr *ssk:incr
!                *ww0:in-out *ww1:in-out *ww2:incr
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
!                rev1:in rev2:in pp0:in pp1:in pp2:in pp3:in rlv0:in
!                rlv1:in rlv2:in ss:in ssi:in ssj:in ssk:in ww0:in
!                ww1:in ww2:in
  subroutine bceulerwall_b(nn, secondhalo, correctfork)
!  bceulerwall applies the inviscid wall boundary condition to a
!  block. it is assumed that the bcpointers are already set to the
!  correct block on the correct grid level.
    use constants
    use blockpointers, only : bcdata, bcdatad, addgridvelocities
    use flowvarrefstate, only : viscous, eddymodel, rgas, rgasd
    use inputdiscretization, only : eulerwallbctreatment
    use iteration, only : currentlevel, groundlevel
    use utils_b, only : mydim, mydim_b
    use bcpointers_b, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, pp3, pp3d, rlv0, rlv0d, rlv1, rlv1d, rlv2, &
&   rlv2d, rev0, rev0d, rev1, rev1d, rev2, rev2d, ss, ssd, ssi, ssid, &
&   ssj, ssjd, ssk, sskd, istart, isize, jstart, jsize, iend, jend
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: sixad, siyad, sizad, sjxad, sjyad, sjzad
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: skxad, skyad, skzad
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: rxjd, ryjd, rzjd, rxkd, rykd, rzkd
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: dpjd, dpkd, rid, rjd, rkd, qjd, qkd, vnd
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype) :: uuxd, uuyd, uuzd
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: gradd
    intrinsic mod
    intrinsic max
    intrinsic min
    integer :: branch
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    integer(kind=inttype) :: max2
    integer(kind=inttype) :: max1
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = eulerwallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
!  determine the boundary condition treatment and compute the 
!  undivided pressure gradient accordingly. this gradient is  
!  temporarily stored in the halo pressure.                   
!
    select case  (walltreatment) 
    case (constantpressure) 
      call pushcontrol2b(2)
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
      call pushcontrol2b(1)
    case (normalmomentum) 
! pressure gradient is computed using the normal momentum
! equation. first set a couple of additional variables for
! the normals, depending on the block face. note that the
! construction 1: should not be used in these pointers,
! because element 0 is needed. consequently there will be
! an offset of 1 for these normals. this is commented in
! the code. for moving faces also the grid velocity of
! the 1st cell center from the wall is needed.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
! store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        if (jstart .lt. km1) then
          km1 = km1
        else
          km1 = jstart
        end if
        kp1 = k + 1
        if (jend .gt. kp1) then
          kp1 = kp1
        else
          kp1 = jend
        end if
        if (1_inttype .lt. kp1 - km1) then
          max1 = kp1 - km1
        else
          max1 = 1_inttype
        end if
! compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
! the indices j+1 and j-1. make sure that they
! do not exceed the range of the arrays.
        jm1 = j - 1
        if (istart .lt. jm1) then
          jm1 = jm1
        else
          jm1 = istart
        end if
        jp1 = j + 1
        if (iend .gt. jp1) then
          jp1 = jp1
        else
          jp1 = iend
        end if
        if (1_inttype .lt. jp1 - jm1) then
          max2 = jp1 - jm1
        else
          max2 = 1_inttype
        end if
! compute the scaling factor for the central
! difference in the j-direction.
        a1 = one/max2
! compute (twice) the average normal in the generic i,
! j and k-direction. note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). however due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
        sixa = two*ssi(j, k, 1)
        siya = two*ssi(j, k, 2)
        siza = two*ssi(j, k, 3)
        sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
        sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
        sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
        skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
        skya = ssk(j, k, 2) + ssk(j, k+1, 2)
        skza = ssk(j, k, 3) + ssk(j, k+1, 3)
! compute the difference of the normal vector and
! pressure in j and k-direction. as the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
        rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
        ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
        rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
        dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
        rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
        ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
        rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
        dpk = b1*(pp2(j, kp1)-pp2(j, km1))
! compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
        ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
&         siya + bcdata(nn)%norm(j, k, 3)*siza
        rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
&         sjya + bcdata(nn)%norm(j, k, 3)*sjza
        rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
&         skya + bcdata(nn)%norm(j, k, 3)*skza
! store the velocity components in uux, uuy and uuz and
! subtract the mesh velocity if the face is moving.
        uux = ww2(j, k, ivx)
        uuy = ww2(j, k, ivy)
        uuz = ww2(j, k, ivz)
        if (addgridvelocities) then
          uux = uux - ss(j, k, 1)
          uuy = uuy - ss(j, k, 2)
          uuz = uuz - ss(j, k, 3)
        end if
! compute the velocity components in j and
! k-direction.
        qj = uux*sjxa + uuy*sjya + uuz*sjza
        qk = uux*skxa + uuy*skya + uuz*skza
! compute the pressure gradient, which is stored
! in pp1. i'm not entirely sure whether this
! formulation is correct for moving meshes. it could
! be that an additional term is needed there.
        grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
&         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
      end do
      call pushcontrol2b(0)
    case default
      call pushcontrol2b(2)
    end select
    call pushinteger4(j)
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = mydim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    gradd = 0.0_8
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
! the laminar and eddy viscosity, if present.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev2d(j, k) = rev2d(j, k) + rev1d(j, k)
        rev1d(j, k) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv2d(j, k) = rlv2d(j, k) + rlv1d(j, k)
        rlv1d(j, k) = 0.0_8
      end if
      ww2d(j, k, ivz) = ww2d(j, k, ivz) + ww1d(j, k, ivz)
      vnd = bcdata(nn)%norm(j, k, 3)*ww1d(j, k, ivz)
      bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) + vn*ww1d(j&
&       , k, ivz)
      ww1d(j, k, ivz) = 0.0_8
      ww2d(j, k, ivy) = ww2d(j, k, ivy) + ww1d(j, k, ivy)
      vnd = vnd + bcdata(nn)%norm(j, k, 2)*ww1d(j, k, ivy)
      bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) + vn*ww1d(j&
&       , k, ivy)
      ww1d(j, k, ivy) = 0.0_8
      ww2d(j, k, ivx) = ww2d(j, k, ivx) + ww1d(j, k, ivx)
      vnd = vnd + bcdata(nn)%norm(j, k, 1)*ww1d(j, k, ivx)
      bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) + vn*ww1d(j&
&       , k, ivx)
      ww1d(j, k, ivx) = 0.0_8
      ww2d(j, k, irho) = ww2d(j, k, irho) + ww1d(j, k, irho)
      ww1d(j, k, irho) = 0.0_8
      tempd3 = two*vnd
      ww2d(j, k, ivx) = ww2d(j, k, ivx) - bcdata(nn)%norm(j, k, 1)*&
&       tempd3
      bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) - ww2(j, k, &
&       ivx)*tempd3
      ww2d(j, k, ivy) = ww2d(j, k, ivy) - bcdata(nn)%norm(j, k, 2)*&
&       tempd3
      bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) - ww2(j, k, &
&       ivy)*tempd3
      ww2d(j, k, ivz) = ww2d(j, k, ivz) - bcdata(nn)%norm(j, k, 3)*&
&       tempd3
      bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) - ww2(j, k, &
&       ivz)*tempd3
      call mydim_b(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k), pp1d(&
&            j, k))
      pp1d(j, k) = 0.0_8
    end do
    call popinteger4(j)
    call popcontrol2b(branch)
    if (branch .eq. 0) then
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
! store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        if (jstart .lt. km1) then
          km1 = km1
        else
          km1 = jstart
        end if
        kp1 = k + 1
        if (jend .gt. kp1) then
          kp1 = kp1
        else
          kp1 = jend
        end if
        if (1_inttype .lt. kp1 - km1) then
          max1 = kp1 - km1
        else
          max1 = 1_inttype
        end if
! compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
! the indices j+1 and j-1. make sure that they
! do not exceed the range of the arrays.
        jm1 = j - 1
        if (istart .lt. jm1) then
          jm1 = jm1
        else
          jm1 = istart
        end if
        jp1 = j + 1
        if (iend .gt. jp1) then
          jp1 = jp1
        else
          jp1 = iend
        end if
        if (1_inttype .lt. jp1 - jm1) then
          max2 = jp1 - jm1
        else
          max2 = 1_inttype
        end if
! compute the scaling factor for the central
! difference in the j-direction.
        a1 = one/max2
! compute (twice) the average normal in the generic i,
! j and k-direction. note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). however due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
        sixa = two*ssi(j, k, 1)
        siya = two*ssi(j, k, 2)
        siza = two*ssi(j, k, 3)
        sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
        sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
        sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
        skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
        skya = ssk(j, k, 2) + ssk(j, k+1, 2)
        skza = ssk(j, k, 3) + ssk(j, k+1, 3)
! compute the difference of the normal vector and
! pressure in j and k-direction. as the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
        rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
        ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
        rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
        dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
        rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
        ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
        rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
        dpk = b1*(pp2(j, kp1)-pp2(j, km1))
! compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
        ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
&         siya + bcdata(nn)%norm(j, k, 3)*siza
        rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
&         sjya + bcdata(nn)%norm(j, k, 3)*sjza
        rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
&         skya + bcdata(nn)%norm(j, k, 3)*skza
! store the velocity components in uux, uuy and uuz and
! subtract the mesh velocity if the face is moving.
        uux = ww2(j, k, ivx)
        uuy = ww2(j, k, ivy)
        uuz = ww2(j, k, ivz)
        if (addgridvelocities) then
          uux = uux - ss(j, k, 1)
          uuy = uuy - ss(j, k, 2)
          uuz = uuz - ss(j, k, 3)
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
! compute the velocity components in j and
! k-direction.
        qj = uux*sjxa + uuy*sjya + uuz*sjza
        qk = uux*skxa + uuy*skya + uuz*skza
! compute the pressure gradient, which is stored
! in pp1. i'm not entirely sure whether this
! formulation is correct for moving meshes. it could
! be that an additional term is needed there.
        tempd = gradd(j, k)/ri
        tempd0 = ww2(j, k, irho)*tempd
        temp0 = uux*rxj + uuy*ryj + uuz*rzj
        tempd1 = qj*tempd0
        temp1 = uux*rxk + uuy*ryk + uuz*rzk
        tempd2 = qk*tempd0
        temp = qj*temp0 + qk*temp1
        qjd = temp0*tempd0
        rxjd = uux*tempd1
        ryjd = uuy*tempd1
        rzjd = uuz*tempd1
        qkd = temp1*tempd0
        uuxd = skxa*qkd + sjxa*qjd + rxk*tempd2 + rxj*tempd1
        uuyd = skya*qkd + sjya*qjd + ryk*tempd2 + ryj*tempd1
        uuzd = skza*qkd + sjza*qjd + rzk*tempd2 + rzj*tempd1
        rxkd = uux*tempd2
        rykd = uuy*tempd2
        rzkd = uuz*tempd2
        ww2d(j, k, irho) = ww2d(j, k, irho) + temp*tempd
        rjd = -(dpj*tempd)
        dpjd = -(rj*tempd)
        rkd = -(dpk*tempd)
        dpkd = -(rk*tempd)
        rid = -((temp*ww2(j, k, irho)-rj*dpj-rk*dpk)*tempd/ri)
        gradd(j, k) = 0.0_8
        skxad = uux*qkd
        skyad = uuy*qkd
        skzad = uuz*qkd
        sjxad = uux*qjd
        sjyad = uuy*qjd
        sjzad = uuz*qjd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          ssd(j, k, 3) = ssd(j, k, 3) - uuzd
          ssd(j, k, 2) = ssd(j, k, 2) - uuyd
          ssd(j, k, 1) = ssd(j, k, 1) - uuxd
        end if
        ww2d(j, k, ivz) = ww2d(j, k, ivz) + uuzd
        ww2d(j, k, ivy) = ww2d(j, k, ivy) + uuyd
        ww2d(j, k, ivx) = ww2d(j, k, ivx) + uuxd
        bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) + skxa*rkd
        skxad = skxad + bcdata(nn)%norm(j, k, 1)*rkd
        bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) + skya*rkd
        skyad = skyad + bcdata(nn)%norm(j, k, 2)*rkd
        bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) + skza*rkd
        skzad = skzad + bcdata(nn)%norm(j, k, 3)*rkd
        bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) + sjxa*rjd
        sjxad = sjxad + bcdata(nn)%norm(j, k, 1)*rjd
        bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) + sjya*rjd
        sjyad = sjyad + bcdata(nn)%norm(j, k, 2)*rjd
        bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) + sjza*rjd
        sjzad = sjzad + bcdata(nn)%norm(j, k, 3)*rjd
        bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) + sixa*rid
        sixad = bcdata(nn)%norm(j, k, 1)*rid
        bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) + siya*rid
        siyad = bcdata(nn)%norm(j, k, 2)*rid
        bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) + siza*rid
        sizad = bcdata(nn)%norm(j, k, 3)*rid
        pp2d(j, kp1) = pp2d(j, kp1) + b1*dpkd
        pp2d(j, km1) = pp2d(j, km1) - b1*dpkd
        bcdatad(nn)%norm(j, kp1, 3) = bcdatad(nn)%norm(j, kp1, 3) + b1*&
&         rzkd
        bcdatad(nn)%norm(j, km1, 3) = bcdatad(nn)%norm(j, km1, 3) - b1*&
&         rzkd
        bcdatad(nn)%norm(j, kp1, 2) = bcdatad(nn)%norm(j, kp1, 2) + b1*&
&         rykd
        bcdatad(nn)%norm(j, km1, 2) = bcdatad(nn)%norm(j, km1, 2) - b1*&
&         rykd
        bcdatad(nn)%norm(j, kp1, 1) = bcdatad(nn)%norm(j, kp1, 1) + b1*&
&         rxkd
        bcdatad(nn)%norm(j, km1, 1) = bcdatad(nn)%norm(j, km1, 1) - b1*&
&         rxkd
        pp2d(jp1, k) = pp2d(jp1, k) + a1*dpjd
        pp2d(jm1, k) = pp2d(jm1, k) - a1*dpjd
        bcdatad(nn)%norm(jp1, k, 3) = bcdatad(nn)%norm(jp1, k, 3) + a1*&
&         rzjd
        bcdatad(nn)%norm(jm1, k, 3) = bcdatad(nn)%norm(jm1, k, 3) - a1*&
&         rzjd
        bcdatad(nn)%norm(jp1, k, 2) = bcdatad(nn)%norm(jp1, k, 2) + a1*&
&         ryjd
        bcdatad(nn)%norm(jm1, k, 2) = bcdatad(nn)%norm(jm1, k, 2) - a1*&
&         ryjd
        bcdatad(nn)%norm(jp1, k, 1) = bcdatad(nn)%norm(jp1, k, 1) + a1*&
&         rxjd
        bcdatad(nn)%norm(jm1, k, 1) = bcdatad(nn)%norm(jm1, k, 1) - a1*&
&         rxjd
        sskd(j, k, 3) = sskd(j, k, 3) + skzad
        sskd(j, k+1, 3) = sskd(j, k+1, 3) + skzad
        sskd(j, k, 2) = sskd(j, k, 2) + skyad
        sskd(j, k+1, 2) = sskd(j, k+1, 2) + skyad
        sskd(j, k, 1) = sskd(j, k, 1) + skxad
        sskd(j, k+1, 1) = sskd(j, k+1, 1) + skxad
        ssjd(j, k, 3) = ssjd(j, k, 3) + sjzad
        ssjd(j+1, k, 3) = ssjd(j+1, k, 3) + sjzad
        ssjd(j, k, 2) = ssjd(j, k, 2) + sjyad
        ssjd(j+1, k, 2) = ssjd(j+1, k, 2) + sjyad
        ssjd(j, k, 1) = ssjd(j, k, 1) + sjxad
        ssjd(j+1, k, 1) = ssjd(j+1, k, 1) + sjxad
        ssid(j, k, 3) = ssid(j, k, 3) + two*sizad
        ssid(j, k, 2) = ssid(j, k, 2) + two*siyad
        ssid(j, k, 1) = ssid(j, k, 1) + two*sixad
      end do
    else if (branch .eq. 1) then
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        pp3d(j, k) = pp3d(j, k) + gradd(j, k)
        pp2d(j, k) = pp2d(j, k) - gradd(j, k)
        gradd(j, k) = 0.0_8
      end do
    end if
  end subroutine bceulerwall_b
  subroutine bceulerwall(nn, secondhalo, correctfork)
!  bceulerwall applies the inviscid wall boundary condition to a
!  block. it is assumed that the bcpointers are already set to the
!  correct block on the correct grid level.
    use constants
    use blockpointers, only : bcdata, addgridvelocities
    use flowvarrefstate, only : viscous, eddymodel, rgas
    use inputdiscretization, only : eulerwallbctreatment
    use iteration, only : currentlevel, groundlevel
    use utils_b, only : mydim
    use bcpointers_b, only : ww0, ww1, ww2, pp0, pp1, pp2, pp3, rlv0, &
&   rlv1, rlv2, rev0, rev1, rev2, ss, ssi, ssj, ssk, istart, isize, &
&   jstart, jsize, iend, jend
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: j, k, l, ii
    integer(kind=inttype) :: jm1, jp1, km1, kp1
    integer(kind=inttype) :: walltreatment
    real(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    real(kind=realtype) :: skxa, skya, skza, a1, b1
    real(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    real(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    real(kind=realtype) :: uux, uuy, uuz
    real(kind=realtype), dimension(istart:iend, jstart:jend) :: grad
    intrinsic mod
    intrinsic max
    intrinsic min
    integer(kind=inttype) :: max2
    integer(kind=inttype) :: max1
! make sure that on the coarser grids the constant pressure
! boundary condition is used.
    walltreatment = eulerwallbctreatment
    if (currentlevel .gt. groundlevel) walltreatment = constantpressure
!  determine the boundary condition treatment and compute the 
!  undivided pressure gradient accordingly. this gradient is  
!  temporarily stored in the halo pressure.                   
!
    select case  (walltreatment) 
    case (constantpressure) 
! constant pressure. set the gradient to zero.
      grad = zero
    case (linextrapolpressure) 
! linear extrapolation.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
        grad(j, k) = pp3(j, k) - pp2(j, k)
      end do
    case (normalmomentum) 
! pressure gradient is computed using the normal momentum
! equation. first set a couple of additional variables for
! the normals, depending on the block face. note that the
! construction 1: should not be used in these pointers,
! because element 0 is needed. consequently there will be
! an offset of 1 for these normals. this is commented in
! the code. for moving faces also the grid velocity of
! the 1st cell center from the wall is needed.
      do ii=0,isize*jsize-1
        j = mod(ii, isize) + istart
        k = ii/isize + jstart
! store the indices k+1, k-1 a bit easier and make
! sure that they do not exceed the range of the arrays.
        km1 = k - 1
        if (jstart .lt. km1) then
          km1 = km1
        else
          km1 = jstart
        end if
        kp1 = k + 1
        if (jend .gt. kp1) then
          kp1 = kp1
        else
          kp1 = jend
        end if
        if (1_inttype .lt. kp1 - km1) then
          max1 = kp1 - km1
        else
          max1 = 1_inttype
        end if
! compute the scaling factor for the central difference
! in the k-direction.
        b1 = one/max1
! the indices j+1 and j-1. make sure that they
! do not exceed the range of the arrays.
        jm1 = j - 1
        if (istart .lt. jm1) then
          jm1 = jm1
        else
          jm1 = istart
        end if
        jp1 = j + 1
        if (iend .gt. jp1) then
          jp1 = jp1
        else
          jp1 = iend
        end if
        if (1_inttype .lt. jp1 - jm1) then
          max2 = jp1 - jm1
        else
          max2 = 1_inttype
        end if
! compute the scaling factor for the central
! difference in the j-direction.
        a1 = one/max2
! compute (twice) the average normal in the generic i,
! j and k-direction. note that in j and k-direction
! the average in the original indices should be taken
! using j-1 and j (and k-1 and k). however due to the
! usage of pointers ssj and ssk there is an offset in
! the indices of 1 and therefore now the correct
! average is obtained with the indices j and j+1
! (k and k+1).
        sixa = two*ssi(j, k, 1)
        siya = two*ssi(j, k, 2)
        siza = two*ssi(j, k, 3)
        sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
        sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
        sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
        skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
        skya = ssk(j, k, 2) + ssk(j, k+1, 2)
        skza = ssk(j, k, 3) + ssk(j, k+1, 3)
! compute the difference of the normal vector and
! pressure in j and k-direction. as the indices are
! restricted to the 1st halo-layer, the computation
! of the internal halo values is not consistent;
! however this is not really a problem, because these
! values are overwritten in the communication pattern.
        rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
        ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
        rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
        dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
        rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
        ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
        rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
        dpk = b1*(pp2(j, kp1)-pp2(j, km1))
! compute the dot product between the unit vector
! and the normal vectors in i, j and k-direction.
        ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
&         siya + bcdata(nn)%norm(j, k, 3)*siza
        rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
&         sjya + bcdata(nn)%norm(j, k, 3)*sjza
        rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
&         skya + bcdata(nn)%norm(j, k, 3)*skza
! store the velocity components in uux, uuy and uuz and
! subtract the mesh velocity if the face is moving.
        uux = ww2(j, k, ivx)
        uuy = ww2(j, k, ivy)
        uuz = ww2(j, k, ivz)
        if (addgridvelocities) then
          uux = uux - ss(j, k, 1)
          uuy = uuy - ss(j, k, 2)
          uuz = uuz - ss(j, k, 3)
        end if
! compute the velocity components in j and
! k-direction.
        qj = uux*sjxa + uuy*sjya + uuz*sjza
        qk = uux*skxa + uuy*skya + uuz*skza
! compute the pressure gradient, which is stored
! in pp1. i'm not entirely sure whether this
! formulation is correct for moving meshes. it could
! be that an additional term is needed there.
        grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
&         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
      end do
    end select
! determine the state in the halo cell. again loop over
! the cell range for this subface.
    do ii=0,isize*jsize-1
      j = mod(ii, isize) + istart
      k = ii/isize + jstart
! compute the pressure density and velocity in the
! halo cell. note that rface is the grid velocity
! component in the direction of norm, i.e. outward
! pointing.
      pp1(j, k) = mydim(pp2(j, k), grad(j, k))
      vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
&       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
&       bcdata(nn)%norm(j, k, 3))
      ww1(j, k, irho) = ww2(j, k, irho)
      ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
      ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
      ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
! the laminar and eddy viscosity, if present.
      if (viscous) rlv1(j, k) = rlv2(j, k)
      if (eddymodel) rev1(j, k) = rev2(j, k)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bceulerwall
!  differentiation of bcfarfield in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*bcdata.norm) winf pinfcorr
!                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
!                *ww0 *ww1 *ww2
!   with respect to varying inputs: *(*bcdata.norm) winf pinfcorr
!                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
!                *ww0 *ww1 *ww2
!   rw status of diff variables: *(*bcdata.norm):incr winf:incr
!                pinfcorr:incr *rev0:in-out *rev1:in-out *rev2:incr
!                *pp0:in-out *pp1:in-out *pp2:incr *rlv0:in-out
!                *rlv1:in-out *rlv2:incr *ww0:in-out *ww1:in-out
!                *ww2:incr
!   plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
!                rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in rlv1:in
!                rlv2:in ww0:in ww1:in ww2:in
  subroutine bcfarfield_b(nn, secondhalo, correctfork)
! bcfarfield applies the farfield boundary condition to a block.
! it is assumed that the bcpointers are already set *
    use constants
    use blockpointers, only : bcdata, bcdatad
    use flowvarrefstate, only : eddymodel, viscous, gammainf, winf, &
&   winfd, pinfcorr, pinfcorrd
    use bcpointers_b, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, rlv0, rlv0d, rlv1, rlv1d, rlv2, rlv2d, rev0, &
&   rev0d, rev1, rev1d, rev2, rev2d, gamma2, istart, jstart, isize, &
&   jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: ac1d, ac2d
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: r0d, u0d, v0d, w0d, qn0d, c0d, s0d
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: red, ued, ved, wed, qned, ced
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    real(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
    intrinsic sqrt
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    c0 = sqrt(gammainf*pinfcorr*r0)
    s0 = winf(irho)**gammainf/pinfcorr
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo_b(correctfork)
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call computeetot_b(ww1, ww1d, pp1, pp1d, correctfork)
    v0d = 0.0_8
    s0d = 0.0_8
    c0d = 0.0_8
    w0d = 0.0_8
    u0d = 0.0_8
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
        call pushcontrol1b(0)
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
        call pushcontrol1b(1)
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
        call pushcontrol1b(0)
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
        call pushcontrol1b(1)
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
        call pushcontrol1b(0)
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
        call pushcontrol1b(1)
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
        rev1d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
        rlv1d(i, j) = 0.0_8
      end if
      ww1d(i, j, irho) = ww1d(i, j, irho) + cc*pp1d(i, j)
      wfd = ww1d(i, j, ivz)
      ww1d(i, j, ivz) = 0.0_8
      vfd = ww1d(i, j, ivy)
      ww1d(i, j, ivy) = 0.0_8
      ufd = ww1d(i, j, ivx)
      ww1d(i, j, ivx) = 0.0_8
      if (sf*cc .le. 0.0_8 .and. (ovgm1 .eq. 0.0_8 .or. ovgm1 .ne. int(&
&         ovgm1))) then
        tempd9 = 0.0
      else
        tempd9 = ovgm1*(sf*cc)**(ovgm1-1)*ww1d(i, j, irho)
      end if
      ccd = sf*tempd9 + ww1(i, j, irho)*pp1d(i, j)
      pp1d(i, j) = 0.0_8
      sfd = cc*tempd9
      ww1d(i, j, irho) = 0.0_8
      cfd = 2*cf*ccd/gamma2(i, j)
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tempd5 = bcdata(nn)%norm(i, j, 1)*ufd
        tempd4 = bcdata(nn)%norm(i, j, 2)*vfd
        tempd2 = sfd/pp2(i, j)
        temp = gamma2(i, j)
        if (.not.(ww2(i, j, irho) .le. 0.0_8 .and. (temp .eq. 0.0_8 .or.&
&           temp .ne. int(temp)))) ww2d(i, j, irho) = ww2d(i, j, irho) +&
&           temp*ww2(i, j, irho)**(temp-1)*tempd2
        pp2d(i, j) = pp2d(i, j) - ww2(i, j, irho)**temp*tempd2/pp2(i, j)
        tempd3 = bcdata(nn)%norm(i, j, 3)*wfd
        wed = wfd
        qnfd = tempd4 + tempd5 + tempd3
        qned = -tempd4 - tempd5 - tempd3
        bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qne&
&         )*wfd
        ved = vfd
        bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qne&
&         )*vfd
        ued = ufd
        bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qne&
&         )*ufd
        qn0d = 0.0_8
      else
        tempd8 = bcdata(nn)%norm(i, j, 1)*ufd
        tempd7 = bcdata(nn)%norm(i, j, 2)*vfd
        s0d = s0d + sfd
        tempd6 = bcdata(nn)%norm(i, j, 3)*wfd
        w0d = w0d + wfd
        qnfd = tempd7 + tempd8 + tempd6
        qn0d = -tempd7 - tempd8 - tempd6
        bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qn0&
&         )*wfd
        v0d = v0d + vfd
        bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qn0&
&         )*vfd
        u0d = u0d + ufd
        bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qn0&
&         )*ufd
        qned = 0.0_8
        ued = 0.0_8
        ved = 0.0_8
        wed = 0.0_8
      end if
      tempd1 = fourth*gm1*cfd
      ac1d = half*qnfd + tempd1
      ac2d = half*qnfd - tempd1
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        qned = qned + ac2d
        ced = -(two*ovgm1*ac2d)
      else
        qn0d = qn0d + ac2d
        c0d = c0d - two*ovgm1*ac2d
        ced = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        qned = qned + ac1d
        ced = ced + two*ovgm1*ac1d
      else
        qn0d = qn0d + ac1d
        c0d = c0d + two*ovgm1*ac1d
      end if
      if (gamma2(i, j)*(pp2(i, j)*re) .eq. 0.0_8) then
        tempd0 = 0.0
      else
        tempd0 = gamma2(i, j)*ced/(2.0*sqrt(gamma2(i, j)*(pp2(i, j)*re))&
&         )
      end if
      pp2d(i, j) = pp2d(i, j) + re*tempd0
      red = pp2(i, j)*tempd0
      ued = ued + bcdata(nn)%norm(i, j, 1)*qned
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ue*qned
      ved = ved + bcdata(nn)%norm(i, j, 2)*qned
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ve*qned
      wed = wed + bcdata(nn)%norm(i, j, 3)*qned
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + we*qned
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + wed
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + ved
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + ued
      ww2d(i, j, irho) = ww2d(i, j, irho) - one*red/ww2(i, j, irho)**2
      u0d = u0d + bcdata(nn)%norm(i, j, 1)*qn0d
      bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + u0*qn0d
      v0d = v0d + bcdata(nn)%norm(i, j, 2)*qn0d
      bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + v0*qn0d
      w0d = w0d + bcdata(nn)%norm(i, j, 3)*qn0d
      bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + w0*qn0d
    end do
    if (gammainf*(pinfcorr*r0) .eq. 0.0_8) then
      tempd = 0.0
    else
      tempd = gammainf*c0d/(2.0*sqrt(gammainf*(pinfcorr*r0)))
    end if
    if (.not.(winf(irho) .le. 0.0_8 .and. (gammainf .eq. 0.0_8 .or. &
&       gammainf .ne. int(gammainf)))) winfd(irho) = winfd(irho) + &
&       gammainf*winf(irho)**(gammainf-1)*s0d/pinfcorr
    pinfcorrd = pinfcorrd + r0*tempd - winf(irho)**gammainf*s0d/pinfcorr&
&     **2
    r0d = pinfcorr*tempd
    winfd(ivz) = winfd(ivz) + w0d
    winfd(ivy) = winfd(ivy) + v0d
    winfd(ivx) = winfd(ivx) + u0d
    winfd(irho) = winfd(irho) - one*r0d/winf(irho)**2
  end subroutine bcfarfield_b
  subroutine bcfarfield(nn, secondhalo, correctfork)
! bcfarfield applies the farfield boundary condition to a block.
! it is assumed that the bcpointers are already set *
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : eddymodel, viscous, gammainf, winf, &
&   pinfcorr
    use bcpointers_b, only : ww0, ww1, ww2, pp0, pp1, pp2, rlv0, rlv1, &
&   rlv2, rev0, rev1, rev2, gamma2, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
! local variables.
    integer(kind=inttype) :: nn, i, j, k, l, ii
    real(kind=realtype) :: nnx, nny, nnz
    real(kind=realtype) :: gm1, ovgm1, ac1, ac2
    real(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    real(kind=realtype) :: re, ue, ve, we, qne, ce
    real(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    intrinsic sqrt
    intrinsic mod
! some constants needed to compute the riemann invariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
! compute the three velocity components, the speed of sound and
! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    c0 = sqrt(gammainf*pinfcorr*r0)
    s0 = winf(irho)**gammainf/pinfcorr
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! compute the normal velocity of the free stream and
! substract the normal velocity of the mesh.
      qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
&       w0*bcdata(nn)%norm(i, j, 3)
      vn0 = qn0 - bcdata(nn)%rface(i, j)
! compute the three velocity components, the normal
! velocity and the speed of sound of the current state
! in the internal cell.
      re = one/ww2(i, j, irho)
      ue = ww2(i, j, ivx)
      ve = ww2(i, j, ivy)
      we = ww2(i, j, ivz)
      qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
&       we*bcdata(nn)%norm(i, j, 3)
      ce = sqrt(gamma2(i, j)*pp2(i, j)*re)
! compute the new values of the riemann invariants in
! the halo cell. either the value in the internal cell
! is taken (positive sign of the corresponding
! eigenvalue) or the free stream value is taken
! (otherwise).
      if (vn0 .gt. -c0) then
! outflow or subsonic inflow.
        ac1 = qne + two*ovgm1*ce
      else
! supersonic inflow.
        ac1 = qn0 + two*ovgm1*c0
      end if
      if (vn0 .gt. c0) then
! supersonic outflow.
        ac2 = qne - two*ovgm1*ce
      else
! inflow or subsonic outflow.
        ac2 = qn0 - two*ovgm1*c0
      end if
      qnf = half*(ac1+ac2)
      cf = fourth*(ac1-ac2)*gm1
      if (vn0 .gt. zero) then
! outflow.
        uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
        vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
        wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
        sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
      else
! inflow
        uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
        vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
        wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
        sf = s0
      end if
! compute the density, velocity and pressure in the
! halo cell.
      cc = cf*cf/gamma2(i, j)
      qq = uf*uf + vf*vf + wf*wf
      ww1(i, j, irho) = (sf*cc)**ovgm1
      ww1(i, j, ivx) = uf
      ww1(i, j, ivy) = vf
      ww1(i, j, ivz) = wf
      pp1(i, j) = ww1(i, j, irho)*cc
! simply set the laminar and eddy viscosity to
! the value in the donor cell. their values do
! not matter too much in the far field.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcfarfield
  subroutine bcsupersonicinflow(nn, secondhalo, correctfork)
! bcsupersonicinflow applies the supersonic inflow boundary
! conditions, entire state vector is prescribed, to a block. it is
! assumed that the pointers in blockpointers are already set to
! the correct block on the correct grid level.
    use constants
    use blockpointers, only : bcdata
    use flowvarrefstate, only : eddymodel, viscous
    use bcpointers_b, only : ww0, ww1, pp0, pp1, rlv0, rlv1, rlv2, rev0,&
&   rev1, rev2, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local variables.
    integer(kind=inttype) :: i, j, l, kk, mm, ii
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, kbeg, kend
    intrinsic mod
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
      ww1(i, j, irho) = bcdata(nn)%rho(i, j)
      ww1(i, j, ivx) = bcdata(nn)%velx(i, j)
      ww1(i, j, ivy) = bcdata(nn)%vely(i, j)
      ww1(i, j, ivz) = bcdata(nn)%velz(i, j)
      pp1(i, j) = bcdata(nn)%ps(i, j)
! set the laminar and eddy viscosity in the halo
! if needed.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
    call computeetot(ww1, pp1, correctfork)
    if (secondhalo) then
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        ww0(i, j, irho) = bcdata(nn)%rho(i, j)
        ww0(i, j, ivx) = bcdata(nn)%velx(i, j)
        ww0(i, j, ivy) = bcdata(nn)%vely(i, j)
        ww0(i, j, ivz) = bcdata(nn)%velz(i, j)
        pp0(i, j) = bcdata(nn)%ps(i, j)
! set the laminar and eddy viscosity in the halo
! if needed.
        if (viscous) rlv0(i, j) = rlv1(i, j)
        if (eddymodel) rev0(i, j) = rev1(i, j)
      end do
      call computeetot(ww0, pp0, correctfork)
    end if
  end subroutine bcsupersonicinflow
  subroutine bcextrap(nn, secondhalo, correctfork)
!
!  ccextrap applies the extrapolation boundary condition to a     
!  block. it is assumed that the pointers in blockpointers are    
!  already set to the correct block on the correct grid level.    
!  extrapolation boundaries are applied to both singular lines or 
!  points of a block face and to supersonic outlets. they are     
!  marked differently because of postprocessing reasons, but      
!  their numerical treatment is identical.                        
!
    use constants
    use blockpointers, only : bctype
    use flowvarrefstate, only : viscous, eddymodel
    use inputdiscretization, only : outflowtreatment
!use inputphysics
    use bcpointers_b, only : ww1, ww2, ww3, pp1, pp2, pp3, rlv1, rlv2, &
&   rev1, rev2, istart, jstart, isize, jsize
    implicit none
! subroutine arguments.
    logical, intent(in) :: secondhalo, correctfork
    integer(kind=inttype), intent(in) :: nn
! local parameter.
    real(kind=realtype), parameter :: factor=0.5
! local variables.
    integer(kind=inttype) :: i, j, l, ii
    real(kind=realtype) :: fw2, fw3
    intrinsic mod
    intrinsic max
! set the extrapolation weights, depending on the situation.
    if (bctype(nn) .eq. supersonicoutflow) then
! a physical outflow face. set the weights depending
! on the input parameter.
      select case  (outflowtreatment) 
      case (constantextrapol) 
        fw2 = one
        fw3 = zero
      case (linextrapol) 
        fw2 = two
        fw3 = -one
      end select
    else
! singular block boundary. use linear extrapolation.
      fw2 = two
      fw3 = -one
    end if
! loop over the generic subface to set the state in the
! 1-st level halos
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, velocities and pressure.
! make sure that a certain threshold is kept for the
! density and pressure.
      ww1(i, j, irho) = fw2*ww2(i, j, irho) + fw3*ww3(i, j, irho)
      if (factor*ww2(i, j, irho) .lt. ww1(i, j, irho)) then
        ww1(i, j, irho) = ww1(i, j, irho)
      else
        ww1(i, j, irho) = factor*ww2(i, j, irho)
      end if
      ww1(i, j, ivx) = fw2*ww2(i, j, ivx) + fw3*ww3(i, j, ivx)
      ww1(i, j, ivy) = fw2*ww2(i, j, ivy) + fw3*ww3(i, j, ivy)
      ww1(i, j, ivz) = fw2*ww2(i, j, ivz) + fw3*ww3(i, j, ivz)
      pp1(i, j) = fw2*pp2(i, j) + fw3*pp3(i, j)
      if (factor*pp2(i, j) .lt. pp1(i, j)) then
        pp1(i, j) = pp1(i, j)
      else
        pp1(i, j) = factor*pp2(i, j)
      end if
! the laminar and eddy viscosity, if present. these
! values are simply taken constant. their values do
! not really matter.
      if (viscous) rlv1(i, j) = rlv2(i, j)
      if (eddymodel) rev1(i, j) = rev2(i, j)
    end do
! compute the energy for these halo's.
    call computeetot(ww1, pp1, correctfork)
! extrapolate the state vectors in case a second halo
! is needed.
    if (secondhalo) call extrapolate2ndhalo(correctfork)
  end subroutine bcextrap
  subroutine prhosubsonicinlet(ww, pp, correctfork)
!  prhosubsonicinlet computes the pressure and density for the
!  given range of the block to which the pointers in blockpointers
!  currently point.
    use constants
    use cpcurvefits
    use flowvarrefstate, only : rgas, tref
    use inputphysics, only : cpmodel, gammaconstant
    use bcpointers_b, only : isize, jsize, istart, jstart
    implicit none
! local parameter.
    real(kind=realtype), parameter :: twothird=two*third
! subroutine arguments.
    real(kind=realtype), dimension(:, :, :) :: ww
    real(kind=realtype), dimension(:, :) :: pp
    logical, intent(in) :: correctfork
! local variables.
    integer(kind=inttype) :: i, j, ii, mm, nns, nnt, iii
    real(kind=realtype) :: govgm1, tt, ts, pt, ratio
    real(kind=realtype) :: intts, inttt, val
    intrinsic mod
! determine the cp model used in the computation.
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma. compute the coefficient
! gamma/(gamma-1), which occurs in the isentropic expression
! for the total pressure.
      govgm1 = gammaconstant/(gammaconstant-one)
! loop over the pointer range
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
! store the total temperature, total pressure and
! static temperature a bit easier.
        tt = ww(i, j, irho)
        pt = pp(i, j)
        ts = ww(i, j, irhoe)
! compute the static pressure from the total pressure
! and the temperature ratio. compute the density using
! the gas law.
        ratio = (ts/tt)**govgm1
        pp(i, j) = pt*ratio
        ww(i, j, irho) = pp(i, j)/(rgas*ts)
      end do
    end select
! add 2*rho*k/3 to the pressure if a k-equation is present.
    if (correctfork) then
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        pp(i, j) = pp(i, j) + twothird*ww(i, j, irho)*ww(i, j, itu1)
      end do
    end if

  contains
    subroutine cportintegrant(t, nn, int)
      implicit none
! subroutine arguments.
      integer(kind=inttype), intent(out) :: nn
      real(kind=realtype), intent(in) :: t
      real(kind=realtype), intent(out) :: int
! local variables.
      integer(kind=inttype) :: mm, ii, start
      real(kind=realtype) :: t2
      intrinsic log
! determine the situation we are having here for the temperature.
      if (t .le. cptrange(0)) then
! temperature is less than the smallest temperature of the
! curve fits. use extrapolation using constant cp.
! set nn to 0 to indicate this.
        nn = 0
        int = (cv0+one)*log(t)
      else if (t .ge. cptrange(cpnparts)) then
! temperature is larger than the largest temperature of the
! curve fits. use extrapolation using constant cp.
! set nn to cpnparts+1 to indicate this.
        nn = cpnparts + 1
        int = (cvn+one)*log(t)
      else
! temperature is within the curve fit range. determine
! the correct interval.
        ii = cpnparts
        start = 1
interval:do 
! next guess for the interval.
          nn = start + ii/2
! determine the situation we are having here.
          if (t .gt. cptrange(nn)) then
! temperature is larger than the upper boundary of
! the current interval. update the lower boundary.
            start = nn + 1
            ii = ii - 1
          else if (t .ge. cptrange(nn-1)) then
! nn contains the correct curve fit interval.
! compute the value of the integrant.
            int = zero
            do ii=1,cptempfit(nn)%nterm
              mm = cptempfit(nn)%exponents(ii)
              if (mm .eq. 0_inttype) then
                int = int + cptempfit(nn)%constants(ii)*log(t)
              else
                t2 = t**mm
                int = int + cptempfit(nn)%constants(ii)*t2/mm
              end if
            end do
            goto 100
          end if
! this is the correct range. exit the do-loop.
! modify ii for the next branch to search.
          ii = ii/2
        end do interval
      end if
 100  continue
    end subroutine cportintegrant
  end subroutine prhosubsonicinlet
!  differentiation of extrapolate2ndhalo in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
!                *rlv0 *rlv1 *ww0 *ww1 *ww2
!   plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
!                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
  subroutine extrapolate2ndhalo_b(correctfork)
! extrapolate2ndhalo determines the states of the second layer
! halo cells for the given subface of the block. it is assumed
! that the appropriate bcpointers are already set
    use constants
    use bcpointers_b, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, pp0, pp0d,&
&   pp1, pp1d, pp2, pp2d, rlv0, rlv0d, rlv1, rlv1d, rlv2, rlv2d, rev0, &
&   rev0d, rev1, rev1d, rev2, rev2d, isize, jsize, istart, jstart
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! input variables
    logical, intent(in) :: correctfork
! working variables
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
    integer :: branch
    call pushreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
    call computeetot_b(ww0, ww0d, pp0, pp0d, correctfork)
    call popreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (eddymodel) then
        rev1d(i, j) = rev1d(i, j) + rev0d(i, j)
        rev0d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rlv1d(i, j) = rlv1d(i, j) + rlv0d(i, j)
        rlv0d(i, j) = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pp1d(i, j) = pp1d(i, j) + two*pp0d(i, j)
        pp2d(i, j) = pp2d(i, j) - pp0d(i, j)
        pp0d(i, j) = 0.0_8
      else
        pp1d(i, j) = pp1d(i, j) + factor*pp0d(i, j)
        pp0d(i, j) = 0.0_8
      end if
      ww1d(i, j, ivz) = ww1d(i, j, ivz) + two*ww0d(i, j, ivz)
      ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww0d(i, j, ivz)
      ww0d(i, j, ivz) = 0.0_8
      ww1d(i, j, ivy) = ww1d(i, j, ivy) + two*ww0d(i, j, ivy)
      ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww0d(i, j, ivy)
      ww0d(i, j, ivy) = 0.0_8
      ww1d(i, j, ivx) = ww1d(i, j, ivx) + two*ww0d(i, j, ivx)
      ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww0d(i, j, ivx)
      ww0d(i, j, ivx) = 0.0_8
      call popcontrol1b(branch)
      if (branch .ne. 0) then
        ww1d(i, j, irho) = ww1d(i, j, irho) + factor*ww0d(i, j, irho)
        ww0d(i, j, irho) = 0.0_8
      end if
      ww1d(i, j, irho) = ww1d(i, j, irho) + two*ww0d(i, j, irho)
      ww2d(i, j, irho) = ww2d(i, j, irho) - ww0d(i, j, irho)
      ww0d(i, j, irho) = 0.0_8
    end do
  end subroutine extrapolate2ndhalo_b
!  differentiation of computeetot in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: ww pp
!   with respect to varying inputs: ww pp
  subroutine computeetot_b(ww, wwd, pp, ppd, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use inputphysics, only : gammaconstant, cpmodel
    use utils_b, only : terminate
    use bcpointers_b, only : isize, jsize, istart, jstart
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :) :: ppd
    real(kind=realtype), dimension(:, :, :) :: ww
    real(kind=realtype), dimension(:, :, :) :: wwd
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd0
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          tmpd = wwd(i, j, irhoe)
          wwd(i, j, irhoe) = 0.0_8
          tempd = half*ww(i, j, irho)*tmpd
          ppd(i, j) = ppd(i, j) + ovgm1*tmpd
          wwd(i, j, irho) = wwd(i, j, irho) + half*(ww(i, j, ivx)**2+ww(&
&           i, j, ivy)**2+ww(i, j, ivz)**2)*tmpd
          wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd
          wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd
          wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd
        else
          tmpd0 = wwd(i, j, irhoe)
          wwd(i, j, irhoe) = 0.0_8
          tempd0 = half*ww(i, j, irho)*tmpd0
          ppd(i, j) = ppd(i, j) + ovgm1*tmpd0
          wwd(i, j, irho) = wwd(i, j, irho) + (half*(ww(i, j, ivx)**2+ww&
&           (i, j, ivy)**2+ww(i, j, ivz)**2)-factk*ww(i, j, itu1))*tmpd0
          wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd0
          wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd0
          wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd0
          wwd(i, j, itu1) = wwd(i, j, itu1) - factk*ww(i, j, irho)*tmpd0
        end if
      end do
    end select
  end subroutine computeetot_b
  subroutine extrapolate2ndhalo(correctfork)
! extrapolate2ndhalo determines the states of the second layer
! halo cells for the given subface of the block. it is assumed
! that the appropriate bcpointers are already set
    use constants
    use bcpointers_b, only : ww0, ww1, ww2, pp0, pp1, pp2, rlv0, rlv1, &
&   rlv2, rev0, rev1, rev2, isize, jsize, istart, jstart
    use flowvarrefstate, only : viscous, eddymodel
    implicit none
! input variables
    logical, intent(in) :: correctfork
! working variables
    real(kind=realtype), parameter :: factor=0.5_realtype
    integer(kind=inttype) :: i, j, l, ii
    intrinsic mod
    intrinsic max
! loop over the generic subface to set the state in the
! halo cells.
    do ii=0,isize*jsize-1
      i = mod(ii, isize) + istart
      j = ii/isize + jstart
! extrapolate the density, momentum and pressure.
! make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      if (factor*ww1(i, j, irho) .lt. ww0(i, j, irho)) then
        ww0(i, j, irho) = ww0(i, j, irho)
      else
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      end if
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      if (factor*pp1(i, j) .lt. two*pp1(i, j) - pp2(i, j)) then
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      else
        pp0(i, j) = factor*pp1(i, j)
      end if
! the laminar and eddy viscosity, if present. these values
! are simply taken constant. their values do not matter.
      if (viscous) rlv0(i, j) = rlv1(i, j)
      if (eddymodel) rev0(i, j) = rev1(i, j)
    end do
! compute the energy for this halo range.
    call computeetot(ww0, pp0, correctfork)
  end subroutine extrapolate2ndhalo
  subroutine computeetot(ww, pp, correctfork)
! simplified total energy computation for boundary conditions.
! only implements the constant cpmodel
    use constants
    use inputphysics, only : gammaconstant, cpmodel
    use utils_b, only : terminate
    use bcpointers_b, only : isize, jsize, istart, jstart
    implicit none
    real(kind=realtype), dimension(:, :) :: pp
    real(kind=realtype), dimension(:, :, :) :: ww
    logical :: correctfork
    integer(kind=inttype) :: ii, i, j
    real(kind=realtype) :: ovgm1, factk
    intrinsic mod
    select case  (cpmodel) 
    case (cpconstant) 
! constant cp and thus constant gamma.
! abbreviate 1/(gamma -1) a bit easier.
      ovgm1 = one/(gammaconstant-one)
      factk = ovgm1*(five*third-gammaconstant)
! loop over the given array and compute the energy, possibly
! correcting for k
      do ii=0,isize*jsize-1
        i = mod(ii, isize) + istart
        j = ii/isize + jstart
        if (.not.correctfork) then
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
        else
          ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
&           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
&           j, irho)*ww(i, j, itu1)
        end if
      end do
    case (cptempcurvefits) 
      call terminate('bcroutines', &
&              'cptempcurvefits not implemented yet.')
    end select
  end subroutine computeetot
end module bcroutines_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of allnodalgradients in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *aa *wx *wy *wz *w *qx *qy
!                *qz *ux *vol *uy *uz *si *sj *sk *vx *vy *vz
!   with respect to varying inputs: *aa *w *vol *si *sj *sk
!   plus diff mem management of: aa:in wx:in wy:in wz:in w:in qx:in
!                qy:in qz:in ux:in vol:in uy:in uz:in si:in sj:in
!                sk:in vx:in vy:in vz:in
subroutine allnodalgradients_b()
!
!        ****************************************************************
!        *                                                              *
!        * nodalgradients computes the nodal velocity gradients and     *
!        * minus the gradient of the speed of sound squared. the minus  *
!        * sign is present, because this is the definition of the heat  *
!        * flux. these gradients are computed for all nodes.            * 
!        *                                                              *
!        ****************************************************************
!
  use blockpointers
  implicit none
!        local variables.
  integer(kind=inttype) :: i, j, k
  integer(kind=inttype) :: k1, kk
  integer(kind=inttype) :: istart, iend, isize, ii
  integer(kind=inttype) :: jstart, jend, jsize
  integer(kind=inttype) :: kstart, kend, ksize
  real(kind=realtype) :: oneoverv, ubar, vbar, wbar, a2
  real(kind=realtype) :: oneovervd, ubard, vbard, wbard, a2d
  real(kind=realtype) :: sx, sx1, sy, sy1, sz, sz1
  real(kind=realtype) :: sxd, syd, szd
  intrinsic mod
  integer :: branch
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: temp
!
!        ****************************************************************
!        *                                                              *
!        * begin execution                                              *
!        *                                                              *
!        ****************************************************************
!
! zero all nodeal gradients:
  ux = zero
  uy = zero
  uz = zero
  vx = zero
  vy = zero
  vz = zero
  wx = zero
  wy = zero
  wz = zero
  qx = zero
  qy = zero
  qz = zero
! first part. contribution in the k-direction.
! the contribution is scattered to both the left and right node
! in k-direction.
  do ii=0,il*jl*ke-1
    i = mod(ii, il) + 1
    j = mod(ii/il, jl) + 1
    k = ii/(il*jl) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = sk(i, j, k-1, 1) + sk(i+1, j, k-1, 1) + sk(i, j+1, k-1, 1) + sk&
&     (i+1, j+1, k-1, 1) + sk(i, j, k, 1) + sk(i+1, j, k, 1) + sk(i, j+1&
&     , k, 1) + sk(i+1, j+1, k, 1)
    sy = sk(i, j, k-1, 2) + sk(i+1, j, k-1, 2) + sk(i, j+1, k-1, 2) + sk&
&     (i+1, j+1, k-1, 2) + sk(i, j, k, 2) + sk(i+1, j, k, 2) + sk(i, j+1&
&     , k, 2) + sk(i+1, j+1, k, 2)
    sz = sk(i, j, k-1, 3) + sk(i+1, j, k-1, 3) + sk(i, j+1, k-1, 3) + sk&
&     (i+1, j+1, k-1, 3) + sk(i, j, k, 3) + sk(i+1, j, k, 3) + sk(i, j+1&
&     , k, 3) + sk(i+1, j+1, k, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
    ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j+1, k, ivx)+w&
&     (i+1, j+1, k, ivx))
    vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j+1, k, ivy)+w&
&     (i+1, j+1, k, ivy))
    wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j+1, k, ivz)+w&
&     (i+1, j+1, k, ivz))
    a2 = fourth*(aa(i, j, k)+aa(i+1, j, k)+aa(i, j+1, k)+aa(i+1, j+1, k)&
&     )
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (k .gt. 1) then
      ux(i, j, k-1) = ux(i, j, k-1) + ubar*sx
      uy(i, j, k-1) = uy(i, j, k-1) + ubar*sy
      uz(i, j, k-1) = uz(i, j, k-1) + ubar*sz
      vx(i, j, k-1) = vx(i, j, k-1) + vbar*sx
      vy(i, j, k-1) = vy(i, j, k-1) + vbar*sy
      vz(i, j, k-1) = vz(i, j, k-1) + vbar*sz
      wx(i, j, k-1) = wx(i, j, k-1) + wbar*sx
      wy(i, j, k-1) = wy(i, j, k-1) + wbar*sy
      wz(i, j, k-1) = wz(i, j, k-1) + wbar*sz
      qx(i, j, k-1) = qx(i, j, k-1) - a2*sx
      qy(i, j, k-1) = qy(i, j, k-1) - a2*sy
      qz(i, j, k-1) = qz(i, j, k-1) - a2*sz
    end if
    if (k .lt. ke) then
      ux(i, j, k) = ux(i, j, k) - ubar*sx
      uy(i, j, k) = uy(i, j, k) - ubar*sy
      uz(i, j, k) = uz(i, j, k) - ubar*sz
      vx(i, j, k) = vx(i, j, k) - vbar*sx
      vy(i, j, k) = vy(i, j, k) - vbar*sy
      vz(i, j, k) = vz(i, j, k) - vbar*sz
      wx(i, j, k) = wx(i, j, k) - wbar*sx
      wy(i, j, k) = wy(i, j, k) - wbar*sy
      wz(i, j, k) = wz(i, j, k) - wbar*sz
      qx(i, j, k) = qx(i, j, k) + a2*sx
      qy(i, j, k) = qy(i, j, k) + a2*sy
      qz(i, j, k) = qz(i, j, k) + a2*sz
    end if
  end do
  call pushinteger4(i)
  call pushinteger4(j)
  call pushinteger4(k)
  call pushreal8(wbar)
  call pushreal8(vbar)
  call pushreal8(ubar)
  call pushreal8(a2)
  call pushreal8(sx)
  call pushreal8(sy)
  call pushreal8(sz)
! second part. contribution in the j-direction.
! the contribution is scattered to both the left and right node
! in j-direction.
  do ii=0,il*je*kl-1
    i = mod(ii, il) + 1
    j = mod(ii/il, je) + 1
    k = ii/(il*je) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = sj(i, j-1, k, 1) + sj(i+1, j-1, k, 1) + sj(i, j-1, k+1, 1) + sj&
&     (i+1, j-1, k+1, 1) + sj(i, j, k, 1) + sj(i+1, j, k, 1) + sj(i, j, &
&     k+1, 1) + sj(i+1, j, k+1, 1)
    sy = sj(i, j-1, k, 2) + sj(i+1, j-1, k, 2) + sj(i, j-1, k+1, 2) + sj&
&     (i+1, j-1, k+1, 2) + sj(i, j, k, 2) + sj(i+1, j, k, 2) + sj(i, j, &
&     k+1, 2) + sj(i+1, j, k+1, 2)
    sz = sj(i, j-1, k, 3) + sj(i+1, j-1, k, 3) + sj(i, j-1, k+1, 3) + sj&
&     (i+1, j-1, k+1, 3) + sj(i, j, k, 3) + sj(i+1, j, k, 3) + sj(i, j, &
&     k+1, 3) + sj(i+1, j, k+1, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
    ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j, k+1, ivx)+w&
&     (i+1, j, k+1, ivx))
    vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j, k+1, ivy)+w&
&     (i+1, j, k+1, ivy))
    wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j, k+1, ivz)+w&
&     (i+1, j, k+1, ivz))
    a2 = fourth*(aa(i, j, k)+aa(i+1, j, k)+aa(i, j, k+1)+aa(i+1, j, k+1)&
&     )
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (j .gt. 1) then
      ux(i, j-1, k) = ux(i, j-1, k) + ubar*sx
      uy(i, j-1, k) = uy(i, j-1, k) + ubar*sy
      uz(i, j-1, k) = uz(i, j-1, k) + ubar*sz
      vx(i, j-1, k) = vx(i, j-1, k) + vbar*sx
      vy(i, j-1, k) = vy(i, j-1, k) + vbar*sy
      vz(i, j-1, k) = vz(i, j-1, k) + vbar*sz
      wx(i, j-1, k) = wx(i, j-1, k) + wbar*sx
      wy(i, j-1, k) = wy(i, j-1, k) + wbar*sy
      wz(i, j-1, k) = wz(i, j-1, k) + wbar*sz
      qx(i, j-1, k) = qx(i, j-1, k) - a2*sx
      qy(i, j-1, k) = qy(i, j-1, k) - a2*sy
      qz(i, j-1, k) = qz(i, j-1, k) - a2*sz
    end if
    if (j .lt. je) then
      ux(i, j, k) = ux(i, j, k) - ubar*sx
      uy(i, j, k) = uy(i, j, k) - ubar*sy
      uz(i, j, k) = uz(i, j, k) - ubar*sz
      vx(i, j, k) = vx(i, j, k) - vbar*sx
      vy(i, j, k) = vy(i, j, k) - vbar*sy
      vz(i, j, k) = vz(i, j, k) - vbar*sz
      wx(i, j, k) = wx(i, j, k) - wbar*sx
      wy(i, j, k) = wy(i, j, k) - wbar*sy
      wz(i, j, k) = wz(i, j, k) - wbar*sz
      qx(i, j, k) = qx(i, j, k) + a2*sx
      qy(i, j, k) = qy(i, j, k) + a2*sy
      qz(i, j, k) = qz(i, j, k) + a2*sz
    end if
  end do
  call pushinteger4(i)
  call pushinteger4(j)
  call pushinteger4(k)
  call pushreal8(wbar)
  call pushreal8(vbar)
  call pushreal8(ubar)
  call pushreal8(a2)
  call pushreal8(sx)
  call pushreal8(sy)
  call pushreal8(sz)
! third part. contribution in the i-direction.
! the contribution is scattered to both the left and right node
! in i-direction.
  do ii=0,ie*jl*kl-1
    i = mod(ii, ie) + 1
    j = mod(ii/ie, jl) + 1
    k = ii/(ie*jl) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = si(i-1, j, k, 1) + si(i-1, j+1, k, 1) + si(i-1, j, k+1, 1) + si&
&     (i-1, j+1, k+1, 1) + si(i, j, k, 1) + si(i, j+1, k, 1) + si(i, j, &
&     k+1, 1) + si(i, j+1, k+1, 1)
    sy = si(i-1, j, k, 2) + si(i-1, j+1, k, 2) + si(i-1, j, k+1, 2) + si&
&     (i-1, j+1, k+1, 2) + si(i, j, k, 2) + si(i, j+1, k, 2) + si(i, j, &
&     k+1, 2) + si(i, j+1, k+1, 2)
    sz = si(i-1, j, k, 3) + si(i-1, j+1, k, 3) + si(i-1, j, k+1, 3) + si&
&     (i-1, j+1, k+1, 3) + si(i, j, k, 3) + si(i, j+1, k, 3) + si(i, j, &
&     k+1, 3) + si(i, j+1, k+1, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
    ubar = fourth*(w(i, j, k, ivx)+w(i, j+1, k, ivx)+w(i, j, k+1, ivx)+w&
&     (i, j+1, k+1, ivx))
    vbar = fourth*(w(i, j, k, ivy)+w(i, j+1, k, ivy)+w(i, j, k+1, ivy)+w&
&     (i, j+1, k+1, ivy))
    wbar = fourth*(w(i, j, k, ivz)+w(i, j+1, k, ivz)+w(i, j, k+1, ivz)+w&
&     (i, j+1, k+1, ivz))
    a2 = fourth*(aa(i, j, k)+aa(i, j+1, k)+aa(i, j, k+1)+aa(i, j+1, k+1)&
&     )
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (i .gt. 1) then
      ux(i-1, j, k) = ux(i-1, j, k) + ubar*sx
      uy(i-1, j, k) = uy(i-1, j, k) + ubar*sy
      uz(i-1, j, k) = uz(i-1, j, k) + ubar*sz
      vx(i-1, j, k) = vx(i-1, j, k) + vbar*sx
      vy(i-1, j, k) = vy(i-1, j, k) + vbar*sy
      vz(i-1, j, k) = vz(i-1, j, k) + vbar*sz
      wx(i-1, j, k) = wx(i-1, j, k) + wbar*sx
      wy(i-1, j, k) = wy(i-1, j, k) + wbar*sy
      wz(i-1, j, k) = wz(i-1, j, k) + wbar*sz
      qx(i-1, j, k) = qx(i-1, j, k) - a2*sx
      qy(i-1, j, k) = qy(i-1, j, k) - a2*sy
      qz(i-1, j, k) = qz(i-1, j, k) - a2*sz
    end if
    if (i .lt. ie) then
      ux(i, j, k) = ux(i, j, k) - ubar*sx
      uy(i, j, k) = uy(i, j, k) - ubar*sy
      uz(i, j, k) = uz(i, j, k) - ubar*sz
      vx(i, j, k) = vx(i, j, k) - vbar*sx
      vy(i, j, k) = vy(i, j, k) - vbar*sy
      vz(i, j, k) = vz(i, j, k) - vbar*sz
      wx(i, j, k) = wx(i, j, k) - wbar*sx
      wy(i, j, k) = wy(i, j, k) - wbar*sy
      wz(i, j, k) = wz(i, j, k) - wbar*sz
      qx(i, j, k) = qx(i, j, k) + a2*sx
      qy(i, j, k) = qy(i, j, k) + a2*sy
      qz(i, j, k) = qz(i, j, k) + a2*sz
    end if
  end do
  call pushinteger4(i)
  call pushinteger4(j)
  call pushinteger4(k)
  do ii=0,il*jl*kl-1
    i = mod(ii, il) + 1
    j = mod(ii/il, jl) + 1
    k = ii/(il*jl) + 1
! compute the inverse of 8 times the volume for this node.
    oneoverv = one/(vol(i, j, k)+vol(i, j, k+1)+vol(i+1, j, k)+vol(i+1, &
&     j, k+1)+vol(i, j+1, k)+vol(i, j+1, k+1)+vol(i+1, j+1, k)+vol(i+1, &
&     j+1, k+1))
! compute the correct velocity gradients and "unit" heat
! fluxes. the velocity gradients are stored in ux, etc.
    oneovervd = qz(i, j, k)*qzd(i, j, k)
    qzd(i, j, k) = oneoverv*qzd(i, j, k)
    oneovervd = oneovervd + qy(i, j, k)*qyd(i, j, k)
    qyd(i, j, k) = oneoverv*qyd(i, j, k)
    oneovervd = oneovervd + qx(i, j, k)*qxd(i, j, k)
    qxd(i, j, k) = oneoverv*qxd(i, j, k)
    oneovervd = oneovervd + wz(i, j, k)*wzd(i, j, k)
    wzd(i, j, k) = oneoverv*wzd(i, j, k)
    oneovervd = oneovervd + wy(i, j, k)*wyd(i, j, k)
    wyd(i, j, k) = oneoverv*wyd(i, j, k)
    oneovervd = oneovervd + wx(i, j, k)*wxd(i, j, k)
    wxd(i, j, k) = oneoverv*wxd(i, j, k)
    oneovervd = oneovervd + vz(i, j, k)*vzd(i, j, k)
    vzd(i, j, k) = oneoverv*vzd(i, j, k)
    oneovervd = oneovervd + vy(i, j, k)*vyd(i, j, k)
    vyd(i, j, k) = oneoverv*vyd(i, j, k)
    oneovervd = oneovervd + vx(i, j, k)*vxd(i, j, k)
    vxd(i, j, k) = oneoverv*vxd(i, j, k)
    oneovervd = oneovervd + uz(i, j, k)*uzd(i, j, k)
    uzd(i, j, k) = oneoverv*uzd(i, j, k)
    oneovervd = oneovervd + uy(i, j, k)*uyd(i, j, k)
    uyd(i, j, k) = oneoverv*uyd(i, j, k)
    oneovervd = oneovervd + ux(i, j, k)*uxd(i, j, k)
    uxd(i, j, k) = oneoverv*uxd(i, j, k)
    temp = vol(i, j, k) + vol(i, j, k+1) + vol(i+1, j, k) + vol(i+1, j, &
&     k+1) + vol(i, j+1, k) + vol(i, j+1, k+1) + vol(i+1, j+1, k) + vol(&
&     i+1, j+1, k+1)
    tempd11 = -(one*oneovervd/temp**2)
    vold(i, j, k) = vold(i, j, k) + tempd11
    vold(i, j, k+1) = vold(i, j, k+1) + tempd11
    vold(i+1, j, k) = vold(i+1, j, k) + tempd11
    vold(i+1, j, k+1) = vold(i+1, j, k+1) + tempd11
    vold(i, j+1, k) = vold(i, j+1, k) + tempd11
    vold(i, j+1, k+1) = vold(i, j+1, k+1) + tempd11
    vold(i+1, j+1, k) = vold(i+1, j+1, k) + tempd11
    vold(i+1, j+1, k+1) = vold(i+1, j+1, k+1) + tempd11
  end do
  call popinteger4(k)
  call popinteger4(j)
  call popinteger4(i)
  do ii=0,ie*jl*kl-1
    i = mod(ii, ie) + 1
    j = mod(ii/ie, jl) + 1
    k = ii/(ie*jl) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = si(i-1, j, k, 1) + si(i-1, j+1, k, 1) + si(i-1, j, k+1, 1) + si&
&     (i-1, j+1, k+1, 1) + si(i, j, k, 1) + si(i, j+1, k, 1) + si(i, j, &
&     k+1, 1) + si(i, j+1, k+1, 1)
    sy = si(i-1, j, k, 2) + si(i-1, j+1, k, 2) + si(i-1, j, k+1, 2) + si&
&     (i-1, j+1, k+1, 2) + si(i, j, k, 2) + si(i, j+1, k, 2) + si(i, j, &
&     k+1, 2) + si(i, j+1, k+1, 2)
    sz = si(i-1, j, k, 3) + si(i-1, j+1, k, 3) + si(i-1, j, k+1, 3) + si&
&     (i-1, j+1, k+1, 3) + si(i, j, k, 3) + si(i, j+1, k, 3) + si(i, j, &
&     k+1, 3) + si(i, j+1, k+1, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
    ubar = fourth*(w(i, j, k, ivx)+w(i, j+1, k, ivx)+w(i, j, k+1, ivx)+w&
&     (i, j+1, k+1, ivx))
    vbar = fourth*(w(i, j, k, ivy)+w(i, j+1, k, ivy)+w(i, j, k+1, ivy)+w&
&     (i, j+1, k+1, ivy))
    wbar = fourth*(w(i, j, k, ivz)+w(i, j+1, k, ivz)+w(i, j, k+1, ivz)+w&
&     (i, j+1, k+1, ivz))
    a2 = fourth*(aa(i, j, k)+aa(i, j+1, k)+aa(i, j, k+1)+aa(i, j+1, k+1)&
&     )
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (i .gt. 1) then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    if (i .lt. ie) then
      a2d = sy*qyd(i, j, k) + sx*qxd(i, j, k) + sz*qzd(i, j, k)
      szd = a2*qzd(i, j, k) - ubar*uzd(i, j, k) - vbar*vzd(i, j, k) - &
&       wbar*wzd(i, j, k)
      syd = a2*qyd(i, j, k) - ubar*uyd(i, j, k) - vbar*vyd(i, j, k) - &
&       wbar*wyd(i, j, k)
      sxd = a2*qxd(i, j, k) - ubar*uxd(i, j, k) - vbar*vxd(i, j, k) - &
&       wbar*wxd(i, j, k)
      wbard = -(sy*wyd(i, j, k)) - sx*wxd(i, j, k) - sz*wzd(i, j, k)
      vbard = -(sy*vyd(i, j, k)) - sx*vxd(i, j, k) - sz*vzd(i, j, k)
      ubard = -(sy*uyd(i, j, k)) - sx*uxd(i, j, k) - sz*uzd(i, j, k)
    else
      wbard = 0.0_8
      vbard = 0.0_8
      ubard = 0.0_8
      a2d = 0.0_8
      sxd = 0.0_8
      syd = 0.0_8
      szd = 0.0_8
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      a2d = a2d - sy*qyd(i-1, j, k) - sx*qxd(i-1, j, k) - sz*qzd(i-1, j&
&       , k)
      szd = szd + wbar*wzd(i-1, j, k) + ubar*uzd(i-1, j, k) + vbar*vzd(i&
&       -1, j, k) - a2*qzd(i-1, j, k)
      syd = syd + wbar*wyd(i-1, j, k) + ubar*uyd(i-1, j, k) + vbar*vyd(i&
&       -1, j, k) - a2*qyd(i-1, j, k)
      sxd = sxd + wbar*wxd(i-1, j, k) + ubar*uxd(i-1, j, k) + vbar*vxd(i&
&       -1, j, k) - a2*qxd(i-1, j, k)
      wbard = wbard + sy*wyd(i-1, j, k) + sx*wxd(i-1, j, k) + sz*wzd(i-1&
&       , j, k)
      vbard = vbard + sy*vyd(i-1, j, k) + sx*vxd(i-1, j, k) + sz*vzd(i-1&
&       , j, k)
      ubard = ubard + sy*uyd(i-1, j, k) + sx*uxd(i-1, j, k) + sz*uzd(i-1&
&       , j, k)
    end if
    tempd7 = fourth*a2d
    aad(i, j, k) = aad(i, j, k) + tempd7
    aad(i, j+1, k) = aad(i, j+1, k) + tempd7
    aad(i, j, k+1) = aad(i, j, k+1) + tempd7
    aad(i, j+1, k+1) = aad(i, j+1, k+1) + tempd7
    tempd8 = fourth*wbard
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + tempd8
    wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + tempd8
    wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + tempd8
    wd(i, j+1, k+1, ivz) = wd(i, j+1, k+1, ivz) + tempd8
    tempd9 = fourth*vbard
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + tempd9
    wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + tempd9
    wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + tempd9
    wd(i, j+1, k+1, ivy) = wd(i, j+1, k+1, ivy) + tempd9
    tempd10 = fourth*ubard
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + tempd10
    wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + tempd10
    wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + tempd10
    wd(i, j+1, k+1, ivx) = wd(i, j+1, k+1, ivx) + tempd10
    sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + szd
    sid(i-1, j+1, k, 3) = sid(i-1, j+1, k, 3) + szd
    sid(i-1, j, k+1, 3) = sid(i-1, j, k+1, 3) + szd
    sid(i-1, j+1, k+1, 3) = sid(i-1, j+1, k+1, 3) + szd
    sid(i, j, k, 3) = sid(i, j, k, 3) + szd
    sid(i, j+1, k, 3) = sid(i, j+1, k, 3) + szd
    sid(i, j, k+1, 3) = sid(i, j, k+1, 3) + szd
    sid(i, j+1, k+1, 3) = sid(i, j+1, k+1, 3) + szd
    sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + syd
    sid(i-1, j+1, k, 2) = sid(i-1, j+1, k, 2) + syd
    sid(i-1, j, k+1, 2) = sid(i-1, j, k+1, 2) + syd
    sid(i-1, j+1, k+1, 2) = sid(i-1, j+1, k+1, 2) + syd
    sid(i, j, k, 2) = sid(i, j, k, 2) + syd
    sid(i, j+1, k, 2) = sid(i, j+1, k, 2) + syd
    sid(i, j, k+1, 2) = sid(i, j, k+1, 2) + syd
    sid(i, j+1, k+1, 2) = sid(i, j+1, k+1, 2) + syd
    sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + sxd
    sid(i-1, j+1, k, 1) = sid(i-1, j+1, k, 1) + sxd
    sid(i-1, j, k+1, 1) = sid(i-1, j, k+1, 1) + sxd
    sid(i-1, j+1, k+1, 1) = sid(i-1, j+1, k+1, 1) + sxd
    sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
    sid(i, j+1, k, 1) = sid(i, j+1, k, 1) + sxd
    sid(i, j, k+1, 1) = sid(i, j, k+1, 1) + sxd
    sid(i, j+1, k+1, 1) = sid(i, j+1, k+1, 1) + sxd
  end do
  call popreal8(sz)
  call popreal8(sy)
  call popreal8(sx)
  call popreal8(a2)
  call popreal8(ubar)
  call popreal8(vbar)
  call popreal8(wbar)
  call popinteger4(k)
  call popinteger4(j)
  call popinteger4(i)
  do ii=0,il*je*kl-1
    i = mod(ii, il) + 1
    j = mod(ii/il, je) + 1
    k = ii/(il*je) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = sj(i, j-1, k, 1) + sj(i+1, j-1, k, 1) + sj(i, j-1, k+1, 1) + sj&
&     (i+1, j-1, k+1, 1) + sj(i, j, k, 1) + sj(i+1, j, k, 1) + sj(i, j, &
&     k+1, 1) + sj(i+1, j, k+1, 1)
    sy = sj(i, j-1, k, 2) + sj(i+1, j-1, k, 2) + sj(i, j-1, k+1, 2) + sj&
&     (i+1, j-1, k+1, 2) + sj(i, j, k, 2) + sj(i+1, j, k, 2) + sj(i, j, &
&     k+1, 2) + sj(i+1, j, k+1, 2)
    sz = sj(i, j-1, k, 3) + sj(i+1, j-1, k, 3) + sj(i, j-1, k+1, 3) + sj&
&     (i+1, j-1, k+1, 3) + sj(i, j, k, 3) + sj(i+1, j, k, 3) + sj(i, j, &
&     k+1, 3) + sj(i+1, j, k+1, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
    ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j, k+1, ivx)+w&
&     (i+1, j, k+1, ivx))
    vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j, k+1, ivy)+w&
&     (i+1, j, k+1, ivy))
    wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j, k+1, ivz)+w&
&     (i+1, j, k+1, ivz))
    a2 = fourth*(aa(i, j, k)+aa(i+1, j, k)+aa(i, j, k+1)+aa(i+1, j, k+1)&
&     )
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (j .gt. 1) then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    if (j .lt. je) then
      a2d = sy*qyd(i, j, k) + sx*qxd(i, j, k) + sz*qzd(i, j, k)
      szd = a2*qzd(i, j, k) - ubar*uzd(i, j, k) - vbar*vzd(i, j, k) - &
&       wbar*wzd(i, j, k)
      syd = a2*qyd(i, j, k) - ubar*uyd(i, j, k) - vbar*vyd(i, j, k) - &
&       wbar*wyd(i, j, k)
      sxd = a2*qxd(i, j, k) - ubar*uxd(i, j, k) - vbar*vxd(i, j, k) - &
&       wbar*wxd(i, j, k)
      wbard = -(sy*wyd(i, j, k)) - sx*wxd(i, j, k) - sz*wzd(i, j, k)
      vbard = -(sy*vyd(i, j, k)) - sx*vxd(i, j, k) - sz*vzd(i, j, k)
      ubard = -(sy*uyd(i, j, k)) - sx*uxd(i, j, k) - sz*uzd(i, j, k)
    else
      wbard = 0.0_8
      vbard = 0.0_8
      ubard = 0.0_8
      a2d = 0.0_8
      sxd = 0.0_8
      syd = 0.0_8
      szd = 0.0_8
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      a2d = a2d - sy*qyd(i, j-1, k) - sx*qxd(i, j-1, k) - sz*qzd(i, j-1&
&       , k)
      szd = szd + wbar*wzd(i, j-1, k) + ubar*uzd(i, j-1, k) + vbar*vzd(i&
&       , j-1, k) - a2*qzd(i, j-1, k)
      syd = syd + wbar*wyd(i, j-1, k) + ubar*uyd(i, j-1, k) + vbar*vyd(i&
&       , j-1, k) - a2*qyd(i, j-1, k)
      sxd = sxd + wbar*wxd(i, j-1, k) + ubar*uxd(i, j-1, k) + vbar*vxd(i&
&       , j-1, k) - a2*qxd(i, j-1, k)
      wbard = wbard + sy*wyd(i, j-1, k) + sx*wxd(i, j-1, k) + sz*wzd(i, &
&       j-1, k)
      vbard = vbard + sy*vyd(i, j-1, k) + sx*vxd(i, j-1, k) + sz*vzd(i, &
&       j-1, k)
      ubard = ubard + sy*uyd(i, j-1, k) + sx*uxd(i, j-1, k) + sz*uzd(i, &
&       j-1, k)
    end if
    tempd3 = fourth*a2d
    aad(i, j, k) = aad(i, j, k) + tempd3
    aad(i+1, j, k) = aad(i+1, j, k) + tempd3
    aad(i, j, k+1) = aad(i, j, k+1) + tempd3
    aad(i+1, j, k+1) = aad(i+1, j, k+1) + tempd3
    tempd4 = fourth*wbard
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + tempd4
    wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + tempd4
    wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + tempd4
    wd(i+1, j, k+1, ivz) = wd(i+1, j, k+1, ivz) + tempd4
    tempd5 = fourth*vbard
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + tempd5
    wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + tempd5
    wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + tempd5
    wd(i+1, j, k+1, ivy) = wd(i+1, j, k+1, ivy) + tempd5
    tempd6 = fourth*ubard
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + tempd6
    wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + tempd6
    wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + tempd6
    wd(i+1, j, k+1, ivx) = wd(i+1, j, k+1, ivx) + tempd6
    sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + szd
    sjd(i+1, j-1, k, 3) = sjd(i+1, j-1, k, 3) + szd
    sjd(i, j-1, k+1, 3) = sjd(i, j-1, k+1, 3) + szd
    sjd(i+1, j-1, k+1, 3) = sjd(i+1, j-1, k+1, 3) + szd
    sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
    sjd(i+1, j, k, 3) = sjd(i+1, j, k, 3) + szd
    sjd(i, j, k+1, 3) = sjd(i, j, k+1, 3) + szd
    sjd(i+1, j, k+1, 3) = sjd(i+1, j, k+1, 3) + szd
    sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + syd
    sjd(i+1, j-1, k, 2) = sjd(i+1, j-1, k, 2) + syd
    sjd(i, j-1, k+1, 2) = sjd(i, j-1, k+1, 2) + syd
    sjd(i+1, j-1, k+1, 2) = sjd(i+1, j-1, k+1, 2) + syd
    sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
    sjd(i+1, j, k, 2) = sjd(i+1, j, k, 2) + syd
    sjd(i, j, k+1, 2) = sjd(i, j, k+1, 2) + syd
    sjd(i+1, j, k+1, 2) = sjd(i+1, j, k+1, 2) + syd
    sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + sxd
    sjd(i+1, j-1, k, 1) = sjd(i+1, j-1, k, 1) + sxd
    sjd(i, j-1, k+1, 1) = sjd(i, j-1, k+1, 1) + sxd
    sjd(i+1, j-1, k+1, 1) = sjd(i+1, j-1, k+1, 1) + sxd
    sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
    sjd(i+1, j, k, 1) = sjd(i+1, j, k, 1) + sxd
    sjd(i, j, k+1, 1) = sjd(i, j, k+1, 1) + sxd
    sjd(i+1, j, k+1, 1) = sjd(i+1, j, k+1, 1) + sxd
  end do
  call popreal8(sz)
  call popreal8(sy)
  call popreal8(sx)
  call popreal8(a2)
  call popreal8(ubar)
  call popreal8(vbar)
  call popreal8(wbar)
  call popinteger4(k)
  call popinteger4(j)
  call popinteger4(i)
  do ii=0,il*jl*ke-1
    i = mod(ii, il) + 1
    j = mod(ii/il, jl) + 1
    k = ii/(il*jl) + 1
! compute 8 times the average normal for this part of
! the control volume. the factor 8 is taken care of later
! on when the division by the volume takes place.
    sx = sk(i, j, k-1, 1) + sk(i+1, j, k-1, 1) + sk(i, j+1, k-1, 1) + sk&
&     (i+1, j+1, k-1, 1) + sk(i, j, k, 1) + sk(i+1, j, k, 1) + sk(i, j+1&
&     , k, 1) + sk(i+1, j+1, k, 1)
    sy = sk(i, j, k-1, 2) + sk(i+1, j, k-1, 2) + sk(i, j+1, k-1, 2) + sk&
&     (i+1, j+1, k-1, 2) + sk(i, j, k, 2) + sk(i+1, j, k, 2) + sk(i, j+1&
&     , k, 2) + sk(i+1, j+1, k, 2)
    sz = sk(i, j, k-1, 3) + sk(i+1, j, k-1, 3) + sk(i, j+1, k-1, 3) + sk&
&     (i+1, j+1, k-1, 3) + sk(i, j, k, 3) + sk(i+1, j, k, 3) + sk(i, j+1&
&     , k, 3) + sk(i+1, j+1, k, 3)
! compute the average velocities and speed of sound squared
! for this integration point. node that these variables are
! stored in w(ivx), w(ivy), w(ivz) and p.
    ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j+1, k, ivx)+w&
&     (i+1, j+1, k, ivx))
    vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j+1, k, ivy)+w&
&     (i+1, j+1, k, ivy))
    wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j+1, k, ivz)+w&
&     (i+1, j+1, k, ivz))
    a2 = fourth*(aa(i, j, k)+aa(i+1, j, k)+aa(i, j+1, k)+aa(i+1, j+1, k)&
&     )
! add the contributions to the surface integral to the node
! j-1 and substract it from the node j. for the heat flux it
! is reversed, because the negative of the gradient of the
! speed of sound must be computed.
    if (k .gt. 1) then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    if (k .lt. ke) then
      a2d = sy*qyd(i, j, k) + sx*qxd(i, j, k) + sz*qzd(i, j, k)
      szd = a2*qzd(i, j, k) - ubar*uzd(i, j, k) - vbar*vzd(i, j, k) - &
&       wbar*wzd(i, j, k)
      syd = a2*qyd(i, j, k) - ubar*uyd(i, j, k) - vbar*vyd(i, j, k) - &
&       wbar*wyd(i, j, k)
      sxd = a2*qxd(i, j, k) - ubar*uxd(i, j, k) - vbar*vxd(i, j, k) - &
&       wbar*wxd(i, j, k)
      wbard = -(sy*wyd(i, j, k)) - sx*wxd(i, j, k) - sz*wzd(i, j, k)
      vbard = -(sy*vyd(i, j, k)) - sx*vxd(i, j, k) - sz*vzd(i, j, k)
      ubard = -(sy*uyd(i, j, k)) - sx*uxd(i, j, k) - sz*uzd(i, j, k)
    else
      wbard = 0.0_8
      vbard = 0.0_8
      ubard = 0.0_8
      a2d = 0.0_8
      sxd = 0.0_8
      syd = 0.0_8
      szd = 0.0_8
    end if
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      a2d = a2d - sy*qyd(i, j, k-1) - sx*qxd(i, j, k-1) - sz*qzd(i, j, k&
&       -1)
      szd = szd + wbar*wzd(i, j, k-1) + ubar*uzd(i, j, k-1) + vbar*vzd(i&
&       , j, k-1) - a2*qzd(i, j, k-1)
      syd = syd + wbar*wyd(i, j, k-1) + ubar*uyd(i, j, k-1) + vbar*vyd(i&
&       , j, k-1) - a2*qyd(i, j, k-1)
      sxd = sxd + wbar*wxd(i, j, k-1) + ubar*uxd(i, j, k-1) + vbar*vxd(i&
&       , j, k-1) - a2*qxd(i, j, k-1)
      wbard = wbard + sy*wyd(i, j, k-1) + sx*wxd(i, j, k-1) + sz*wzd(i, &
&       j, k-1)
      vbard = vbard + sy*vyd(i, j, k-1) + sx*vxd(i, j, k-1) + sz*vzd(i, &
&       j, k-1)
      ubard = ubard + sy*uyd(i, j, k-1) + sx*uxd(i, j, k-1) + sz*uzd(i, &
&       j, k-1)
    end if
    tempd = fourth*a2d
    aad(i, j, k) = aad(i, j, k) + tempd
    aad(i+1, j, k) = aad(i+1, j, k) + tempd
    aad(i, j+1, k) = aad(i, j+1, k) + tempd
    aad(i+1, j+1, k) = aad(i+1, j+1, k) + tempd
    tempd0 = fourth*wbard
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + tempd0
    wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + tempd0
    wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + tempd0
    wd(i+1, j+1, k, ivz) = wd(i+1, j+1, k, ivz) + tempd0
    tempd1 = fourth*vbard
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + tempd1
    wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + tempd1
    wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + tempd1
    wd(i+1, j+1, k, ivy) = wd(i+1, j+1, k, ivy) + tempd1
    tempd2 = fourth*ubard
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + tempd2
    wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + tempd2
    wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + tempd2
    wd(i+1, j+1, k, ivx) = wd(i+1, j+1, k, ivx) + tempd2
    skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + szd
    skd(i+1, j, k-1, 3) = skd(i+1, j, k-1, 3) + szd
    skd(i, j+1, k-1, 3) = skd(i, j+1, k-1, 3) + szd
    skd(i+1, j+1, k-1, 3) = skd(i+1, j+1, k-1, 3) + szd
    skd(i, j, k, 3) = skd(i, j, k, 3) + szd
    skd(i+1, j, k, 3) = skd(i+1, j, k, 3) + szd
    skd(i, j+1, k, 3) = skd(i, j+1, k, 3) + szd
    skd(i+1, j+1, k, 3) = skd(i+1, j+1, k, 3) + szd
    skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + syd
    skd(i+1, j, k-1, 2) = skd(i+1, j, k-1, 2) + syd
    skd(i, j+1, k-1, 2) = skd(i, j+1, k-1, 2) + syd
    skd(i+1, j+1, k-1, 2) = skd(i+1, j+1, k-1, 2) + syd
    skd(i, j, k, 2) = skd(i, j, k, 2) + syd
    skd(i+1, j, k, 2) = skd(i+1, j, k, 2) + syd
    skd(i, j+1, k, 2) = skd(i, j+1, k, 2) + syd
    skd(i+1, j+1, k, 2) = skd(i+1, j+1, k, 2) + syd
    skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + sxd
    skd(i+1, j, k-1, 1) = skd(i+1, j, k-1, 1) + sxd
    skd(i, j+1, k-1, 1) = skd(i, j+1, k-1, 1) + sxd
    skd(i+1, j+1, k-1, 1) = skd(i+1, j+1, k-1, 1) + sxd
    skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
    skd(i+1, j, k, 1) = skd(i+1, j, k, 1) + sxd
    skd(i, j+1, k, 1) = skd(i, j+1, k, 1) + sxd
    skd(i+1, j+1, k, 1) = skd(i+1, j+1, k, 1) + sxd
  end do
end subroutine allnodalgradients_b

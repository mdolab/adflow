!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of computegamma in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: gamma
!   with respect to varying inputs: t
!
!      ******************************************************************
!      *                                                                *
!      * file:          computegamma.f90                                *
!      * author:        edwin van der weide                             *
!      * starting date: 09-16-2003                                      *
!      * last modified: 03-23-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine computegamma_b(t, td, gamma, gammad, mm)
!
!      ******************************************************************
!      *                                                                *
!      * computegamma computes the corresponding values of gamma for    *
!      * the given dimensional temperatures.                            *
!      *                                                                *
!      ******************************************************************
!
  use constants
  use cpcurvefits
  use inputphysics
  implicit none
  integer(kind=inttype), intent(in) :: mm
!
!      subroutine arguments.
!
  real(kind=realtype), dimension(mm), intent(in) :: t
  real(kind=realtype), dimension(mm) :: td
  real(kind=realtype), dimension(mm) :: gamma
  real(kind=realtype), dimension(mm) :: gammad
!
!      local variables.
!
  integer(kind=inttype) :: i, ii, nn, start
  real(kind=realtype) :: cp, t2
  real(kind=realtype) :: cpd, t2d
  integer :: ad_count
  integer :: i0
  integer :: branch
  integer :: ad_to
  real(kind=realtype) :: tempd
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! determine the cp model used in the computation.
  select case  (cpmodel) 
  case (cpconstant) 

  case (cptempcurvefits) 
!        ================================================================
! cp as function of the temperature is given via curve fits.
    do i=1,mm
! determine the case we are having here.
      if (t(i) .le. cptrange(0)) then
        call pushcontrol2b(2)
      else if (t(i) .ge. cptrange(cpnparts)) then
        call pushcontrol2b(1)
      else
! temperature is in the curve fit range.
! first find the valid range.
        ii = cpnparts
        start = 1
        ad_count = 1
! next guess for the interval.
 100    call pushinteger4(nn)
        nn = start + ii/2
! determine the situation we are having here.
        if (t(i) .gt. cptrange(nn)) then
          call pushcontrol1b(0)
! temperature is larger than the upper boundary of
! the current interval. update the lower boundary.
          start = nn + 1
          ii = ii - 1
        else if (t(i) .ge. cptrange(nn-1)) then
          goto 110
        else
          call pushcontrol1b(1)
        end if
! this is the correct range. exit the do-loop.
! modify ii for the next branch to search.
        ii = ii/2
        ad_count = ad_count + 1
        goto 100
 110    call pushinteger4(ad_count)
! nn contains the correct curve fit interval.
! compute the value of cp.
        call pushreal8(cp)
        cp = zero
        do ii=1,cptempfit(nn)%nterm
          t2 = t(i)**cptempfit(nn)%exponents(ii)
          cp = cp + cptempfit(nn)%constants(ii)*t2
        end do
        call pushinteger4(ii - 1)
        call pushcontrol2b(0)
      end if
    end do
    td = 0.0_8
    do i=mm,1,-1
      call popcontrol2b(branch)
      if (branch .eq. 0) then
        tempd = gammad(i)/(cp-one)
        cpd = (1.0_8-cp/(cp-one))*tempd
        gammad(i) = 0.0_8
        call popinteger4(ad_to)
        do ii=ad_to,1,-1
          t2d = cptempfit(nn)%constants(ii)*cpd
          if (.not.(t(i) .le. 0.0_8 .and. (cptempfit(nn)%exponents(ii) &
&             .eq. 0.0_8 .or. cptempfit(nn)%exponents(ii) .ne. int(&
&             cptempfit(nn)%exponents(ii))))) td(i) = td(i) + cptempfit(&
&             nn)%exponents(ii)*t(i)**(cptempfit(nn)%exponents(ii)-1)*&
&             t2d
        end do
        call popreal8(cp)
        call popinteger4(ad_count)
        do i0=1,ad_count
          if (i0 .ne. 1) call popcontrol1b(branch)
          call popinteger4(nn)
        end do
      else if (branch .eq. 1) then
        gammad(i) = 0.0_8
      else
        gammad(i) = 0.0_8
      end if
    end do
    goto 120
  end select
  td = 0.0_8
 120 continue
end subroutine computegamma_b

!        generated by tapenade     (inria, ecuador team)
!  tapenade 3.16 (develop) - 13 sep 2023 12:36
!
module sst_b
! this module contains the source code related to the sst turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier.
  use constants
  implicit none
  real(kind=realtype), dimension(:, :, :, :, :), allocatable :: qq
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall

contains
!  differentiation of sstsource in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *rev *w *scratch
!   with respect to varying inputs: *rev *w *scratch
!   rw status of diff variables: *rev:incr *w:incr *scratch:in-out
!   plus diff mem management of: rev:in w:in scratch:in
  subroutine sstsource_b()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rsstgamd, rsstbetad
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: rhoid, ssd, spkd, sdkd
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic mod
    intrinsic min
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: temp0
    integer :: branch
    integer :: ii
! set model constants
    rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/sqrt(&
&     rsstbetas)
    rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/sqrt(&
&     rsstbetas)
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstgam = t1*rsstgam1 + t2*rsstgam2
      rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
      rhoi = one/w(i, j, k, irho)
      ss = scratch(i, j, k, iprod)
      spk = rev(i, j, k)*ss*rhoi
      sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
      if (spk .gt. pklim*sdk) then
        spk = pklim*sdk
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        spk = spk
      end if
      scratch(i, j, k, idvt) = spk - sdk
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.
      tmpd = scratchd(i, j, k, idvt+1)
      scratchd(i, j, k, idvt+1) = 0.0_8
      temp0 = w(i, j, k, itu2)
      rsstgamd = ss*tmpd
      ssd = rsstgam*tmpd
      tempd = two*rsstsigw2*tmpd
      rsstbetad = -(temp0**2*tmpd)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - 2*temp0*rsstbeta*tmpd
      t2d = scratch(i, j, k, icd)*tempd
      scratchd(i, j, k, icd) = scratchd(i, j, k, icd) + t2*tempd
      spkd = scratchd(i, j, k, idvt)
      sdkd = -scratchd(i, j, k, idvt)
      scratchd(i, j, k, idvt) = 0.0_8
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        sdkd = sdkd + pklim*spkd
        spkd = 0.0_8
      end if
      t2d = t2d + rsstbeta2*rsstbetad + rsstgam2*rsstgamd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + w(i, j, k, itu2)*rsstbetas&
&       *sdkd
      wd(i, j, k, itu2) = wd(i, j, k, itu2) + w(i, j, k, itu1)*rsstbetas&
&       *sdkd
      revd(i, j, k) = revd(i, j, k) + ss*rhoi*spkd
      tempd = rev(i, j, k)*spkd
      ssd = ssd + rhoi*tempd
      rhoid = ss*tempd
      scratchd(i, j, k, iprod) = scratchd(i, j, k, iprod) + ssd
      temp = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp**2
      t1d = rsstbeta1*rsstbetad + rsstgam1*rsstgamd - t2d
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
    end do
  end subroutine sstsource_b

  subroutine sstsource()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic mod
    intrinsic min
    integer :: ii
! set model constants
    rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/sqrt(&
&     rsstbetas)
    rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/sqrt(&
&     rsstbetas)
!$ad ii-loop
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstgam = t1*rsstgam1 + t2*rsstgam2
      rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
      rhoi = one/w(i, j, k, irho)
      ss = scratch(i, j, k, iprod)
      spk = rev(i, j, k)*ss*rhoi
      sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
      if (spk .gt. pklim*sdk) then
        spk = pklim*sdk
      else
        spk = spk
      end if
      scratch(i, j, k, idvt) = spk - sdk
      scratch(i, j, k, idvt+1) = rsstgam*ss + two*t2*rsstsigw2*scratch(i&
&       , j, k, icd) - rsstbeta*w(i, j, k, itu2)**2
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.
    end do
  end subroutine sstsource

!  differentiation of sstviscous in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   with respect to varying inputs: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   rw status of diff variables: *rev:incr *w:incr *rlv:incr *scratch:in-out
!                *vol:incr *si:incr *sj:incr *sk:incr
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                vol:in si:in sj:in sk:in
  subroutine sstviscous_b()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigkp1d, rsstsigkd, rsstsigkm1d
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: rsstsigwp1d, rsstsigwd, rsstsigwm1d
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
    intrinsic mod
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd
    integer :: branch
    if (associated(scratch)) then
      call pushreal8array(scratch, size(scratch, 1)*size(scratch, 2)*&
&                   size(scratch, 3)*size(scratch, 4))
      call pushcontrol1b(1)
    else
      call pushcontrol1b(0)
    end if
!$fwd-of ii-loop 
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
      t1 = scratch(i, j, k+1, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k-1, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j, k-1&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j, &
&       k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, itu2)
    end do
    if (associated(scratch)) then
      call pushreal8array(scratch, size(scratch, 1)*size(scratch, 2)*&
&                   size(scratch, 3)*size(scratch, 4))
      call pushcontrol1b(1)
    else
      call pushcontrol1b(0)
    end if
!$fwd-of ii-loop 
!
!       viscous terms in j-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
      t1 = scratch(i, j+1, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j-1, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j-1, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j-1&
&       , k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, itu2)
    end do
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
      t1 = scratch(i+1, j, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i-1, j, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
      mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      call pushreal8(muem)
      muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
      call pushreal8(muep)
      muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      c20d = -(w(i, j, k, itu2)*scratchd(i, j, k, idvt+1))
      c2md = w(i-1, j, k, itu2)*scratchd(i, j, k, idvt+1) + c20d
      wd(i-1, j, k, itu2) = wd(i-1, j, k, itu2) + c2m*scratchd(i, j, k, &
&       idvt+1)
      c2pd = w(i+1, j, k, itu2)*scratchd(i, j, k, idvt+1) + c20d
      wd(i+1, j, k, itu2) = wd(i+1, j, k, itu2) + c2p*scratchd(i, j, k, &
&       idvt+1)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - c20*scratchd(i, j, k, idvt&
&       +1)
      c1md = w(i-1, j, k, itu1)*scratchd(i, j, k, idvt) + c10d
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i+1, j, k, itu1)*scratchd(i, j, k, idvt) + c10d
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      tempd = ttp*rhoi*c2pd
      ttpd = rhoi*(mulp+muep)*c2pd
      rhoid = ttp*(mulp+muep)*c2pd + ttm*(mulm+muem)*c2md
      mulpd = tempd
      muepd = tempd
      tempd = ttm*rhoi*c2md
      ttmd = rhoi*(mulm+muem)*c2md
      mulmd = tempd
      muemd = tempd
      call popreal8(muep)
      tempd = half*muepd
      rsstsigwp1d = rev(i+1, j, k)*tempd
      revd(i+1, j, k) = revd(i+1, j, k) + rsstsigwp1*tempd
      rsstsigwd = rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigw*tempd
      call popreal8(muem)
      tempd = half*muemd
      rsstsigwm1d = rev(i-1, j, k)*tempd
      revd(i-1, j, k) = revd(i-1, j, k) + rsstsigwm1*tempd
      rsstsigwd = rsstsigwd + rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigw*tempd
      tempd = ttp*rhoi*c1pd
      ttpd = ttpd + rhoi*(mulp+muep)*c1pd
      rhoid = rhoid + ttp*(mulp+muep)*c1pd + ttm*(mulm+muem)*c1md
      mulpd = mulpd + tempd
      muepd = tempd
      tempd = ttm*rhoi*c1md
      ttmd = ttmd + rhoi*(mulm+muem)*c1md
      mulmd = mulmd + tempd
      muemd = tempd
      tempd = half*muepd
      rsstsigkp1d = rev(i+1, j, k)*tempd
      revd(i+1, j, k) = revd(i+1, j, k) + rsstsigkp1*tempd
      rsstsigkd = rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigk*tempd
      tempd = half*muemd
      rsstsigkm1d = rev(i-1, j, k)*tempd
      revd(i-1, j, k) = revd(i-1, j, k) + rsstsigkm1*tempd
      rsstsigkd = rsstsigkd + rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigk*tempd
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd + half*mulmd
      rlvd(i-1, j, k) = rlvd(i-1, j, k) + half*mulmd
      temp = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp**2
      t2d = rsstsigw2*rsstsigwm1d + rsstsigk2*rsstsigkm1d
      t1d = rsstsigw1*rsstsigwm1d + rsstsigk1*rsstsigkm1d - t2d
      scratchd(i-1, j, k, if1sst) = scratchd(i-1, j, k, if1sst) + t1d
      t2d = rsstsigw2*rsstsigwd + rsstsigk2*rsstsigkd
      t1d = rsstsigw1*rsstsigwd + rsstsigk1*rsstsigkd - t2d
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
      t2d = rsstsigw2*rsstsigwp1d + rsstsigk2*rsstsigkp1d
      t1d = rsstsigw1*rsstsigwp1d + rsstsigk1*rsstsigkp1d - t2d
      scratchd(i+1, j, k, if1sst) = scratchd(i+1, j, k, if1sst) + t1d
      xpd = xa*ttpd
      xad = xp*ttpd + xm*ttmd
      ypd = ya*ttpd
      yad = yp*ttpd + ym*ttmd
      zpd = za*ttpd
      zad = zp*ttpd + zm*ttmd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd = half*zad
      sid(i, j, k, 3) = sid(i, j, k, 3) + voli*tempd
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*tempd
      volid = (si(i, j, k, 3)+si(i-1, j, k, 3))*tempd
      tempd = half*yad
      sid(i, j, k, 2) = sid(i, j, k, 2) + voli*tempd
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*tempd
      volid = volid + (si(i, j, k, 2)+si(i-1, j, k, 2))*tempd
      tempd = half*xad
      sid(i, j, k, 1) = sid(i, j, k, 1) + voli*tempd
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*tempd
      volid = volid + (si(i, j, k, 1)+si(i-1, j, k, 1))*tempd
      sid(i, j, k, 3) = sid(i, j, k, 3) + volpi*zpd
      volpid = si(i, j, k, 3)*zpd + si(i, j, k, 2)*ypd + si(i, j, k, 1)*&
&       xpd
      sid(i, j, k, 2) = sid(i, j, k, 2) + volpi*ypd
      sid(i, j, k, 1) = sid(i, j, k, 1) + volpi*xpd
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + volmi*zmd
      volmid = si(i-1, j, k, 3)*zmd + si(i-1, j, k, 2)*ymd + si(i-1, j, &
&       k, 1)*xmd
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + volmi*ymd
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + volmi*xmd
      temp = vol(i, j, k) + vol(i+1, j, k)
      tempd = -(two*volpid/temp**2)
      vold(i, j, k) = vold(i, j, k) + tempd
      vold(i+1, j, k) = vold(i+1, j, k) + tempd
      temp = vol(i, j, k) + vol(i-1, j, k)
      tempd = -(two*volmid/temp**2)
      vold(i-1, j, k) = vold(i-1, j, k) + tempd
      vold(i, j, k) = vold(i, j, k) + tempd - one*volid/vol(i, j, k)**2
    end do
    call popcontrol1b(branch)
    if (branch .eq. 1) call popreal8array(scratch, size(scratch, 1)*size&
&                                   (scratch, 2)*size(scratch, 3)*size(&
&                                   scratch, 4))
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
      t1 = scratch(i, j+1, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j-1, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      call pushreal8(muem)
      muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
      call pushreal8(muep)
      muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      c20d = -(w(i, j, k, itu2)*scratchd(i, j, k, idvt+1))
      c2md = w(i, j-1, k, itu2)*scratchd(i, j, k, idvt+1) + c20d
      wd(i, j-1, k, itu2) = wd(i, j-1, k, itu2) + c2m*scratchd(i, j, k, &
&       idvt+1)
      c2pd = w(i, j+1, k, itu2)*scratchd(i, j, k, idvt+1) + c20d
      wd(i, j+1, k, itu2) = wd(i, j+1, k, itu2) + c2p*scratchd(i, j, k, &
&       idvt+1)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - c20*scratchd(i, j, k, idvt&
&       +1)
      c1md = w(i, j-1, k, itu1)*scratchd(i, j, k, idvt) + c10d
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j+1, k, itu1)*scratchd(i, j, k, idvt) + c10d
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      tempd = ttp*rhoi*c2pd
      ttpd = rhoi*(mulp+muep)*c2pd
      rhoid = ttp*(mulp+muep)*c2pd + ttm*(mulm+muem)*c2md
      mulpd = tempd
      muepd = tempd
      tempd = ttm*rhoi*c2md
      ttmd = rhoi*(mulm+muem)*c2md
      mulmd = tempd
      muemd = tempd
      call popreal8(muep)
      tempd = half*muepd
      rsstsigwp1d = rev(i, j+1, k)*tempd
      revd(i, j+1, k) = revd(i, j+1, k) + rsstsigwp1*tempd
      rsstsigwd = rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigw*tempd
      call popreal8(muem)
      tempd = half*muemd
      rsstsigwm1d = rev(i, j-1, k)*tempd
      revd(i, j-1, k) = revd(i, j-1, k) + rsstsigwm1*tempd
      rsstsigwd = rsstsigwd + rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigw*tempd
      tempd = ttp*rhoi*c1pd
      ttpd = ttpd + rhoi*(mulp+muep)*c1pd
      rhoid = rhoid + ttp*(mulp+muep)*c1pd + ttm*(mulm+muem)*c1md
      mulpd = mulpd + tempd
      muepd = tempd
      tempd = ttm*rhoi*c1md
      ttmd = ttmd + rhoi*(mulm+muem)*c1md
      mulmd = mulmd + tempd
      muemd = tempd
      tempd = half*muepd
      rsstsigkp1d = rev(i, j+1, k)*tempd
      revd(i, j+1, k) = revd(i, j+1, k) + rsstsigkp1*tempd
      rsstsigkd = rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigk*tempd
      tempd = half*muemd
      rsstsigkm1d = rev(i, j-1, k)*tempd
      revd(i, j-1, k) = revd(i, j-1, k) + rsstsigkm1*tempd
      rsstsigkd = rsstsigkd + rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigk*tempd
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd + half*mulmd
      rlvd(i, j-1, k) = rlvd(i, j-1, k) + half*mulmd
      temp = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp**2
      t2d = rsstsigw2*rsstsigwm1d + rsstsigk2*rsstsigkm1d
      t1d = rsstsigw1*rsstsigwm1d + rsstsigk1*rsstsigkm1d - t2d
      scratchd(i, j-1, k, if1sst) = scratchd(i, j-1, k, if1sst) + t1d
      t2d = rsstsigw2*rsstsigwd + rsstsigk2*rsstsigkd
      t1d = rsstsigw1*rsstsigwd + rsstsigk1*rsstsigkd - t2d
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
      t2d = rsstsigw2*rsstsigwp1d + rsstsigk2*rsstsigkp1d
      t1d = rsstsigw1*rsstsigwp1d + rsstsigk1*rsstsigkp1d - t2d
      scratchd(i, j+1, k, if1sst) = scratchd(i, j+1, k, if1sst) + t1d
      xpd = xa*ttpd
      xad = xp*ttpd + xm*ttmd
      ypd = ya*ttpd
      yad = yp*ttpd + ym*ttmd
      zpd = za*ttpd
      zad = zp*ttpd + zm*ttmd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd = half*zad
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*tempd
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*tempd
      volid = (sj(i, j, k, 3)+sj(i, j-1, k, 3))*tempd
      tempd = half*yad
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*tempd
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*tempd
      volid = volid + (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempd
      tempd = half*xad
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*tempd
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*tempd
      volid = volid + (sj(i, j, k, 1)+sj(i, j-1, k, 1))*tempd
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + volpi*zpd
      volpid = sj(i, j, k, 3)*zpd + sj(i, j, k, 2)*ypd + sj(i, j, k, 1)*&
&       xpd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + volpi*ypd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + volpi*xpd
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + volmi*zmd
      volmid = sj(i, j-1, k, 3)*zmd + sj(i, j-1, k, 2)*ymd + sj(i, j-1, &
&       k, 1)*xmd
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + volmi*ymd
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + volmi*xmd
      temp = vol(i, j, k) + vol(i, j+1, k)
      tempd = -(two*volpid/temp**2)
      vold(i, j, k) = vold(i, j, k) + tempd
      vold(i, j+1, k) = vold(i, j+1, k) + tempd
      temp = vol(i, j, k) + vol(i, j-1, k)
      tempd = -(two*volmid/temp**2)
      vold(i, j-1, k) = vold(i, j-1, k) + tempd
      vold(i, j, k) = vold(i, j, k) + tempd - one*volid/vol(i, j, k)**2
    end do
    call popcontrol1b(branch)
    if (branch .eq. 1) call popreal8array(scratch, size(scratch, 1)*size&
&                                   (scratch, 2)*size(scratch, 3)*size(&
&                                   scratch, 4))
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
      t1 = scratch(i, j, k+1, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k-1, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      call pushreal8(muem)
      muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
      call pushreal8(muep)
      muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      c20d = -(w(i, j, k, itu2)*scratchd(i, j, k, idvt+1))
      c2md = w(i, j, k-1, itu2)*scratchd(i, j, k, idvt+1) + c20d
      wd(i, j, k-1, itu2) = wd(i, j, k-1, itu2) + c2m*scratchd(i, j, k, &
&       idvt+1)
      c2pd = w(i, j, k+1, itu2)*scratchd(i, j, k, idvt+1) + c20d
      wd(i, j, k+1, itu2) = wd(i, j, k+1, itu2) + c2p*scratchd(i, j, k, &
&       idvt+1)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - c20*scratchd(i, j, k, idvt&
&       +1)
      c1md = w(i, j, k-1, itu1)*scratchd(i, j, k, idvt) + c10d
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j, k+1, itu1)*scratchd(i, j, k, idvt) + c10d
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      tempd = ttp*rhoi*c2pd
      ttpd = rhoi*(mulp+muep)*c2pd
      rhoid = ttp*(mulp+muep)*c2pd + ttm*(mulm+muem)*c2md
      mulpd = tempd
      muepd = tempd
      tempd = ttm*rhoi*c2md
      ttmd = rhoi*(mulm+muem)*c2md
      mulmd = tempd
      muemd = tempd
      call popreal8(muep)
      tempd = half*muepd
      rsstsigwp1d = rev(i, j, k+1)*tempd
      revd(i, j, k+1) = revd(i, j, k+1) + rsstsigwp1*tempd
      rsstsigwd = rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigw*tempd
      call popreal8(muem)
      tempd = half*muemd
      rsstsigwm1d = rev(i, j, k-1)*tempd
      revd(i, j, k-1) = revd(i, j, k-1) + rsstsigwm1*tempd
      rsstsigwd = rsstsigwd + rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigw*tempd
      tempd = ttp*rhoi*c1pd
      ttpd = ttpd + rhoi*(mulp+muep)*c1pd
      rhoid = rhoid + ttp*(mulp+muep)*c1pd + ttm*(mulm+muem)*c1md
      mulpd = mulpd + tempd
      muepd = tempd
      tempd = ttm*rhoi*c1md
      ttmd = ttmd + rhoi*(mulm+muem)*c1md
      mulmd = mulmd + tempd
      muemd = tempd
      tempd = half*muepd
      rsstsigkp1d = rev(i, j, k+1)*tempd
      revd(i, j, k+1) = revd(i, j, k+1) + rsstsigkp1*tempd
      rsstsigkd = rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigk*tempd
      tempd = half*muemd
      rsstsigkm1d = rev(i, j, k-1)*tempd
      revd(i, j, k-1) = revd(i, j, k-1) + rsstsigkm1*tempd
      rsstsigkd = rsstsigkd + rev(i, j, k)*tempd
      revd(i, j, k) = revd(i, j, k) + rsstsigk*tempd
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd + half*mulmd
      rlvd(i, j, k-1) = rlvd(i, j, k-1) + half*mulmd
      temp = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp**2
      t2d = rsstsigw2*rsstsigwm1d + rsstsigk2*rsstsigkm1d
      t1d = rsstsigw1*rsstsigwm1d + rsstsigk1*rsstsigkm1d - t2d
      scratchd(i, j, k-1, if1sst) = scratchd(i, j, k-1, if1sst) + t1d
      t2d = rsstsigw2*rsstsigwd + rsstsigk2*rsstsigkd
      t1d = rsstsigw1*rsstsigwd + rsstsigk1*rsstsigkd - t2d
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
      t2d = rsstsigw2*rsstsigwp1d + rsstsigk2*rsstsigkp1d
      t1d = rsstsigw1*rsstsigwp1d + rsstsigk1*rsstsigkp1d - t2d
      scratchd(i, j, k+1, if1sst) = scratchd(i, j, k+1, if1sst) + t1d
      xpd = xa*ttpd
      xad = xp*ttpd + xm*ttmd
      ypd = ya*ttpd
      yad = yp*ttpd + ym*ttmd
      zpd = za*ttpd
      zad = zp*ttpd + zm*ttmd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd = half*zad
      skd(i, j, k, 3) = skd(i, j, k, 3) + voli*tempd
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*tempd
      volid = (sk(i, j, k, 3)+sk(i, j, k-1, 3))*tempd
      tempd = half*yad
      skd(i, j, k, 2) = skd(i, j, k, 2) + voli*tempd
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*tempd
      volid = volid + (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempd
      tempd = half*xad
      skd(i, j, k, 1) = skd(i, j, k, 1) + voli*tempd
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*tempd
      volid = volid + (sk(i, j, k, 1)+sk(i, j, k-1, 1))*tempd
      skd(i, j, k, 3) = skd(i, j, k, 3) + volpi*zpd
      volpid = sk(i, j, k, 3)*zpd + sk(i, j, k, 2)*ypd + sk(i, j, k, 1)*&
&       xpd
      skd(i, j, k, 2) = skd(i, j, k, 2) + volpi*ypd
      skd(i, j, k, 1) = skd(i, j, k, 1) + volpi*xpd
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + volmi*zmd
      volmid = sk(i, j, k-1, 3)*zmd + sk(i, j, k-1, 2)*ymd + sk(i, j, k-&
&       1, 1)*xmd
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + volmi*ymd
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + volmi*xmd
      temp = vol(i, j, k) + vol(i, j, k+1)
      tempd = -(two*volpid/temp**2)
      vold(i, j, k) = vold(i, j, k) + tempd
      vold(i, j, k+1) = vold(i, j, k+1) + tempd
      temp = vol(i, j, k) + vol(i, j, k-1)
      tempd = -(two*volmid/temp**2)
      vold(i, j, k-1) = vold(i, j, k-1) + tempd
      vold(i, j, k) = vold(i, j, k) + tempd - one*volid/vol(i, j, k)**2
    end do
  end subroutine sstviscous_b

  subroutine sstviscous()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
    intrinsic mod
!$ad ii-loop
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
      t1 = scratch(i, j, k+1, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k-1, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j, k-1&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j, &
&       k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, itu2)
    end do
!$ad ii-loop
!
!       viscous terms in j-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
      t1 = scratch(i, j+1, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j-1, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j-1, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j-1&
&       , k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, itu2)
    end do
!$ad ii-loop
!
!       viscous terms in i-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
      t1 = scratch(i+1, j, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i-1, j, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
      mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i-1, j, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i-1, j&
&       , k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i+1, j, k, itu2)
    end do
  end subroutine sstviscous

!  differentiation of sstresscale in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *dw *scratch
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:incr
!   plus diff mem management of: dw:in scratch:in
  subroutine sstresscale_b()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rblank = real(iblank(i, j, k), realtype)
      scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) - volref(i, &
&       j, k)*rblank*dwd(i, j, k, itu2)
      dwd(i, j, k, itu2) = 0.0_8
      scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) - volref(i, j, k&
&       )*rblank*dwd(i, j, k, itu1)
      dwd(i, j, k, itu1) = 0.0_8
    end do
  end subroutine sstresscale_b

  subroutine sstresscale()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
!$ad ii-loop
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rblank = real(iblank(i, j, k), realtype)
      dw(i, j, k, itu1) = -(volref(i, j, k)*scratch(i, j, k, idvt)*&
&       rblank)
      dw(i, j, k, itu2) = -(volref(i, j, k)*scratch(i, j, k, idvt+1)*&
&       rblank)
    end do
  end subroutine sstresscale

!  differentiation of f1sst in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *w *rlv *scratch
!   with respect to varying inputs: *w *rlv *scratch *d2wall
!   rw status of diff variables: *w:incr *rlv:incr *scratch:in-out
!                *d2wall:out
!   plus diff mem management of: w:in rlv:in scratch:in d2wall:in
  subroutine f1sst_b()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    integer(kind=inttype) :: isize, ibeg, iend
    integer(kind=inttype) :: jsize, jbeg, jend
    integer(kind=inttype) :: ksize, kbeg, kend
    real(kind=realtype) :: t1, t2, arg1, myeps
    real(kind=realtype) :: t1d, t2d, arg1d
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    real(kind=realtype) :: max1
    real(kind=realtype) :: max1d
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmpd0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmpd1
    integer :: branch
    real(realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd
    real(kind=realtype) :: temp4
    real(kind=realtype) :: temp5
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd2
    integer :: ad_from
    integer :: ad_to
    integer :: ad_from0
    integer :: ad_to0
    integer :: ad_from1
    integer :: ad_to1
    integer :: ad_from2
    integer :: ad_to2
    integer :: ad_from3
    integer :: ad_to3
    integer :: ad_from4
    integer :: ad_to4
    integer :: ad_from5
    integer :: ad_to5
    integer :: ad_from6
    integer :: ad_to6
    integer :: ad_from7
    integer :: ad_to7
    integer :: ad_from8
    integer :: ad_to8
    integer :: ad_from9
    integer :: ad_to9
    integer :: ad_from10
    integer :: ad_to10
    ibeg = 1
    jbeg = 1
    kbeg = 1
    iend = ie
    jend = je
    kend = ke
    do nn=1,nbocos
      select case  (bcfaceid(nn)) 
      case (imin) 
        call pushcontrol3b(5)
        ibeg = 2
      case (imax) 
        call pushcontrol3b(4)
        iend = il
      case (jmin) 
        call pushcontrol3b(3)
        jbeg = 2
      case (jmax) 
        call pushcontrol3b(2)
        jend = jl
      case (kmin) 
        call pushcontrol3b(1)
        kbeg = 2
      case (kmax) 
        call pushcontrol3b(0)
        kend = kl
      case default
        call pushcontrol3b(6)
      end select
    end do
! compute the blending function f1 for all owned cells.
    isize = iend - ibeg + 1
    jsize = jend - jbeg + 1
    ksize = kend - kbeg + 1
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        ad_from0 = kcbeg(nn)
        do k=ad_from0,kcend(nn)
          ad_from = jcbeg(nn)
          j = jcend(nn) + 1
          call pushinteger4(j - 1)
          call pushinteger4(ad_from)
        end do
        call pushinteger4(k - 1)
        call pushinteger4(ad_from0)
        call pushcontrol3b(5)
      case (imax) 
        ad_from2 = kcbeg(nn)
!              ==========================================================
        do k=ad_from2,kcend(nn)
          ad_from1 = jcbeg(nn)
          j = jcend(nn) + 1
          call pushinteger4(j - 1)
          call pushinteger4(ad_from1)
        end do
        call pushinteger4(k - 1)
        call pushinteger4(ad_from2)
        call pushcontrol3b(4)
      case (jmin) 
        ad_from4 = kcbeg(nn)
!              ==========================================================
        do k=ad_from4,kcend(nn)
          ad_from3 = icbeg(nn)
          i = icend(nn) + 1
          call pushinteger4(i - 1)
          call pushinteger4(ad_from3)
        end do
        call pushinteger4(k - 1)
        call pushinteger4(ad_from4)
        call pushcontrol3b(3)
      case (jmax) 
        ad_from6 = kcbeg(nn)
!              ==========================================================
        do k=ad_from6,kcend(nn)
          ad_from5 = icbeg(nn)
          i = icend(nn) + 1
          call pushinteger4(i - 1)
          call pushinteger4(ad_from5)
        end do
        call pushinteger4(k - 1)
        call pushinteger4(ad_from6)
        call pushcontrol3b(2)
      case (kmin) 
        ad_from8 = jcbeg(nn)
!              ==========================================================
        do j=ad_from8,jcend(nn)
          ad_from7 = icbeg(nn)
          i = icend(nn) + 1
          call pushinteger4(i - 1)
          call pushinteger4(ad_from7)
        end do
        call pushinteger4(j - 1)
        call pushinteger4(ad_from8)
        call pushcontrol3b(1)
      case (kmax) 
        ad_from10 = jcbeg(nn)
!              ==========================================================
        do j=ad_from10,jcend(nn)
          ad_from9 = icbeg(nn)
          i = icend(nn) + 1
          call pushinteger4(i - 1)
          call pushinteger4(ad_from9)
        end do
        call pushinteger4(j - 1)
        call pushinteger4(ad_from10)
        call pushcontrol3b(0)
      case default
        call pushcontrol3b(6)
      end select
    end do bocos
    do nn=nbocos,1,-1
      call popcontrol3b(branch)
      if (branch .lt. 3) then
        if (branch .eq. 0) then
          call popinteger4(ad_from10)
          call popinteger4(ad_to10)
          do j=ad_to10,ad_from10,-1
            call popinteger4(ad_from9)
            call popinteger4(ad_to9)
            do i=ad_to9,ad_from9,-1
              tmpd1 = scratchd(i, j, ke, if1sst)
              scratchd(i, j, ke, if1sst) = 0.0_8
              scratchd(i, j, kl, if1sst) = scratchd(i, j, kl, if1sst) + &
&               tmpd1
            end do
          end do
        else if (branch .eq. 1) then
          call popinteger4(ad_from8)
          call popinteger4(ad_to8)
          do j=ad_to8,ad_from8,-1
            call popinteger4(ad_from7)
            call popinteger4(ad_to7)
            do i=ad_to7,ad_from7,-1
              scratchd(i, j, 2, if1sst) = scratchd(i, j, 2, if1sst) + &
&               scratchd(i, j, 1, if1sst)
              scratchd(i, j, 1, if1sst) = 0.0_8
            end do
          end do
        else
          call popinteger4(ad_from6)
          call popinteger4(ad_to6)
          do k=ad_to6,ad_from6,-1
            call popinteger4(ad_from5)
            call popinteger4(ad_to5)
            do i=ad_to5,ad_from5,-1
              tmpd0 = scratchd(i, je, k, if1sst)
              scratchd(i, je, k, if1sst) = 0.0_8
              scratchd(i, jl, k, if1sst) = scratchd(i, jl, k, if1sst) + &
&               tmpd0
            end do
          end do
        end if
      else if (branch .lt. 5) then
        if (branch .eq. 3) then
          call popinteger4(ad_from4)
          call popinteger4(ad_to4)
          do k=ad_to4,ad_from4,-1
            call popinteger4(ad_from3)
            call popinteger4(ad_to3)
            do i=ad_to3,ad_from3,-1
              scratchd(i, 2, k, if1sst) = scratchd(i, 2, k, if1sst) + &
&               scratchd(i, 1, k, if1sst)
              scratchd(i, 1, k, if1sst) = 0.0_8
            end do
          end do
        else
          call popinteger4(ad_from2)
          call popinteger4(ad_to2)
          do k=ad_to2,ad_from2,-1
            call popinteger4(ad_from1)
            call popinteger4(ad_to1)
            do j=ad_to1,ad_from1,-1
              tmpd = scratchd(ie, j, k, if1sst)
              scratchd(ie, j, k, if1sst) = 0.0_8
              scratchd(il, j, k, if1sst) = scratchd(il, j, k, if1sst) + &
&               tmpd
            end do
          end do
        end if
      else if (branch .eq. 5) then
        call popinteger4(ad_from0)
        call popinteger4(ad_to0)
        do k=ad_to0,ad_from0,-1
          call popinteger4(ad_from)
          call popinteger4(ad_to)
          do j=ad_to,ad_from,-1
            scratchd(2, j, k, if1sst) = scratchd(2, j, k, if1sst) + &
&             scratchd(1, j, k, if1sst)
            scratchd(1, j, k, if1sst) = 0.0_8
          end do
        end do
      end if
    end do
    if (associated(d2walld)) d2walld = 0.0_8
!$bwd-of ii-loop 
    do ii=0,isize*jsize*ksize-1
      i = mod(ii, isize) + ibeg
      j = mod(ii/isize, jsize) + jbeg
      k = ii/(isize*jsize) + kbeg
      t1 = sqrt(w(i, j, k, itu1))/(0.09_realtype*w(i, j, k, itu2)*d2wall&
&       (i, j, k))
      t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, itu2&
&       )*d2wall(i, j, k)**2)
      if (t1 .lt. t2) then
        t1 = t2
        call pushcontrol1b(0)
      else
        t1 = t1
        call pushcontrol1b(1)
      end if
      if (eps .lt. scratch(i, j, k, icd)) then
        max1 = scratch(i, j, k, icd)
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        max1 = eps
      end if
      t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
      if (t1 .gt. t2) then
        arg1 = t2
        call pushcontrol1b(0)
      else
        arg1 = t1
        call pushcontrol1b(1)
      end if
      arg1d = 4*arg1**3*(1.0-tanh(arg1**4)**2)*scratchd(i, j, k, if1sst)
      scratchd(i, j, k, if1sst) = 0.0_8
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        t2d = arg1d
        t1d = 0.0_8
      else
        t1d = arg1d
        t2d = 0.0_8
      end if
      temp5 = d2wall(i, j, k)*d2wall(i, j, k)
      tempd1 = two*t2d/(max1*temp5)
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + tempd1
      tempd2 = -(w(i, j, k, itu1)*tempd1/(max1*temp5))
      max1d = temp5*tempd2
      d2walld(i, j, k) = d2walld(i, j, k) + 2*d2wall(i, j, k)*max1*&
&       tempd2
      call popcontrol1b(branch)
      if (branch .eq. 0) scratchd(i, j, k, icd) = scratchd(i, j, k, icd)&
&         + max1d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        t2d = t1d
        t1d = 0.0_8
      else
        t2d = 0.0_8
      end if
      temp3 = d2wall(i, j, k)*d2wall(i, j, k)
      temp2 = w(i, j, k, itu2)
      temp1 = w(i, j, k, irho)
      temp0 = temp1*temp2
      temp4 = temp0*temp3
      tempd0 = 500.0_realtype*t2d/temp4
      rlvd(i, j, k) = rlvd(i, j, k) + tempd0
      tempd1 = -(rlv(i, j, k)*tempd0/temp4)
      wd(i, j, k, irho) = wd(i, j, k, irho) + temp2*temp3*tempd1
      wd(i, j, k, itu2) = wd(i, j, k, itu2) + temp1*temp3*tempd1
      d2walld(i, j, k) = d2walld(i, j, k) + 2*d2wall(i, j, k)*temp0*&
&       tempd1
      temp = 0.09_realtype*d2wall(i, j, k)
      temp0 = w(i, j, k, itu2)
      temp1 = temp0*temp
      temp2 = w(i, j, k, itu1)
      temp3 = sqrt(temp2)
      if (.not.temp2 .eq. 0.0_8) wd(i, j, k, itu1) = wd(i, j, k, itu1) +&
&         t1d/(2.0*temp3*temp1)
      tempd = -(temp3*t1d/temp1**2)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) + temp*tempd
      d2walld(i, j, k) = d2walld(i, j, k) + 0.09_realtype*temp0*tempd
    end do
    do nn=nbocos,1,-1
      call popcontrol3b(branch)
    end do
  end subroutine f1sst_b

  subroutine f1sst()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    integer(kind=inttype) :: isize, ibeg, iend
    integer(kind=inttype) :: jsize, jbeg, jend
    integer(kind=inttype) :: ksize, kbeg, kend
    real(kind=realtype) :: t1, t2, arg1, myeps
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    real(kind=realtype) :: max1
    myeps = 1e-10_realtype/two/rsstsigw2
    ibeg = 1
    jbeg = 1
    kbeg = 1
    iend = ie
    jend = je
    kend = ke
    do nn=1,nbocos
      select case  (bcfaceid(nn)) 
      case (imin) 
        ibeg = 2
      case (imax) 
        iend = il
      case (jmin) 
        jbeg = 2
      case (jmax) 
        jend = jl
      case (kmin) 
        kbeg = 2
      case (kmax) 
        kend = kl
      end select
    end do
! compute the blending function f1 for all owned cells.
    isize = iend - ibeg + 1
    jsize = jend - jbeg + 1
    ksize = kend - kbeg + 1
!$ad ii-loop
    do ii=0,isize*jsize*ksize-1
      i = mod(ii, isize) + ibeg
      j = mod(ii/isize, jsize) + jbeg
      k = ii/(isize*jsize) + kbeg
      t1 = sqrt(w(i, j, k, itu1))/(0.09_realtype*w(i, j, k, itu2)*d2wall&
&       (i, j, k))
      t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, itu2&
&       )*d2wall(i, j, k)**2)
      if (t1 .lt. t2) then
        t1 = t2
      else
        t1 = t1
      end if
      if (eps .lt. scratch(i, j, k, icd)) then
        max1 = scratch(i, j, k, icd)
      else
        max1 = eps
      end if
      t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
      if (t1 .gt. t2) then
        arg1 = t2
      else
        arg1 = t1
      end if
      scratch(i, j, k, if1sst) = tanh(arg1**4)
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst

end module sst_b


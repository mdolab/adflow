!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of invisciddissfluxmatrixapprox in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *p *w *si *sj *sk *fw
!   with respect to varying inputs: pinfcorr *p *w *si *sj *sk
!   plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          invisciddissfluxmatrixapprox.f90                *
!      * author:        gaetan k.w. kenway                              *
!      * starting date: 12-02-2014                                      *
!      * last modified: 12-02-2014                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine invisciddissfluxmatrixapprox_b()
!
!      ******************************************************************
!      *                                                                *
!      * invisciddissfluxmatrix computes the matrix artificial          *
!      * dissipation term. instead of the spectral radius, as used in   *
!      * the scalar dissipation scheme, the absolute value of the flux  *
!      * jacobian is used. this leads to a less diffusive and           *
!      * consequently more accurate scheme. it is assumed that the      *
!      * pointers in blockpointers already point to the correct block.  *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use cgnsgrid
  use constants
  use flowvarrefstate
  use inputdiscretization
  use inputphysics
  use iteration
  implicit none
!
!      local parameters.
!
  real(kind=realtype), parameter :: dpmax=0.25_realtype
  real(kind=realtype), parameter :: epsacoustic=0.25_realtype
  real(kind=realtype), parameter :: epsshear=0.025_realtype
  real(kind=realtype), parameter :: omega=0.5_realtype
  real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ind
  real(kind=realtype) :: plim, sface
  real(kind=realtype) :: plimd, sfaced
  real(kind=realtype) :: sfil, fis2, fis4
  real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
  real(kind=realtype) :: ppor, rrad, dis2
  real(kind=realtype) :: rradd, dis2d
  real(kind=realtype) :: dp1, dp2, ddw, tmp, fs
  real(kind=realtype) :: dp1d, dp2d, ddwd, tmpd, fsd
  real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
  real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd, sxd, syd, &
& szd
  real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
  real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
  real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
  real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
  real(kind=realtype) :: kavg, lam1, lam2, lam3, area
  real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d, aread
  real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
  real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, abv7d
  logical :: correctfork, getcorrectfork
  intrinsic abs
  intrinsic max
  intrinsic min
  intrinsic sqrt
  integer :: branch
  real(kind=realtype) :: temp3
  real(kind=realtype) :: temp2
  real(kind=realtype) :: tempd13
  real(kind=realtype) :: temp1
  real(kind=realtype) :: tempd12
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: x6d
  real(kind=realtype) :: max2d
  real(kind=realtype) :: min3
  real(kind=realtype) :: min2
  real(kind=realtype) :: min1
  real(kind=realtype) :: x6
  real(kind=realtype) :: x5
  real(kind=realtype) :: min1d
  real(kind=realtype) :: x4
  real(kind=realtype) :: x3
  real(kind=realtype) :: x2
  real(kind=realtype) :: x2d
  real(kind=realtype) :: x1
  real(kind=realtype) :: x5d
  real(kind=realtype) :: y3d
  real(kind=realtype) :: temp10
  real(kind=realtype) :: max1d
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: abs12
  real(kind=realtype) :: x1d
  real(kind=realtype) :: abs11
  real(kind=realtype) :: abs10
  real(kind=realtype) :: min3d
  real(kind=realtype) :: x4d
  real(kind=realtype) :: y2d
  real(kind=realtype) :: abs9
  real(kind=realtype) :: abs8
  real(kind=realtype) :: abs7
  real(kind=realtype) :: abs6
  real(kind=realtype) :: abs5
  real(kind=realtype) :: abs4
  real(kind=realtype) :: abs3
  real(kind=realtype) :: abs2
  real(kind=realtype) :: abs1
  real(kind=realtype) :: abs0
  real(kind=realtype) :: max3d
  real(kind=realtype) :: temp
  real(kind=realtype) :: max3
  real(kind=realtype) :: max2
  real(kind=realtype) :: max1
  real(kind=realtype) :: temp9
  real(kind=realtype) :: min2d
  real(kind=realtype) :: temp8
  real(kind=realtype) :: temp7
  real(kind=realtype) :: y3
  real(kind=realtype) :: temp6
  real(kind=realtype) :: y2
  real(kind=realtype) :: x3d
  real(kind=realtype) :: temp5
  real(kind=realtype) :: y1
  real(kind=realtype) :: y1d
  real(kind=realtype) :: temp4
  if (rfil .ge. 0.) then
    abs0 = rfil
  else
    abs0 = -rfil
  end if
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
  if (abs0 .lt. thresholdreal) then
    pinfcorrd = 0.0_8
  else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
    plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
! set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the i-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do j=2,jl
        if (shocksensor(2, j, k) - shocksensor(1, j, k) .ge. 0.) then
          call pushreal8(abs1)
          abs1 = shocksensor(2, j, k) - shocksensor(1, j, k)
          call pushcontrol1b(1)
        else
          call pushreal8(abs1)
          abs1 = -(shocksensor(2, j, k)-shocksensor(1, j, k))
          call pushcontrol1b(0)
        end if
        if (shocksensor(1, j, k) - shocksensor(0, j, k) .ge. 0.) then
          call pushreal8(abs7)
          abs7 = shocksensor(1, j, k) - shocksensor(0, j, k)
          call pushcontrol1b(0)
        else
          call pushreal8(abs7)
          abs7 = -(shocksensor(1, j, k)-shocksensor(0, j, k))
          call pushcontrol1b(1)
        end if
        x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+shocksensor(&
&         0, j, k))/(omega*(shocksensor(2, j, k)+two*shocksensor(1, j, k&
&         )+shocksensor(0, j, k))+oneminomega*(abs1+abs7)+plim)
        if (x1 .ge. 0.) then
          dp1 = x1
          call pushcontrol1b(0)
        else
          dp1 = -x1
          call pushcontrol1b(1)
        end if
! loop in i-direction.
        do i=1,il
          if (shocksensor(i+2, j, k) - shocksensor(i+1, j, k) .ge. 0.) &
&         then
            call pushreal8(abs2)
            abs2 = shocksensor(i+2, j, k) - shocksensor(i+1, j, k)
            call pushcontrol1b(1)
          else
            call pushreal8(abs2)
            abs2 = -(shocksensor(i+2, j, k)-shocksensor(i+1, j, k))
            call pushcontrol1b(0)
          end if
          if (shocksensor(i+1, j, k) - shocksensor(i, j, k) .ge. 0.) &
&         then
            call pushreal8(abs8)
            abs8 = shocksensor(i+1, j, k) - shocksensor(i, j, k)
            call pushcontrol1b(0)
          else
            call pushreal8(abs8)
            abs8 = -(shocksensor(i+1, j, k)-shocksensor(i, j, k))
            call pushcontrol1b(1)
          end if
          x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&           shocksensor(i, j, k))/(omega*(shocksensor(i+2, j, k)+two*&
&           shocksensor(i+1, j, k)+shocksensor(i, j, k))+oneminomega*(&
&           abs2+abs8)+plim)
          if (x2 .ge. 0.) then
            dp2 = x2
            call pushcontrol1b(0)
          else
            dp2 = -x2
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (pori(i, j, k) .eq. normalflux) ppor = one
          if (dp1 .lt. dp2) then
            y1 = dp2
            call pushcontrol1b(0)
          else
            y1 = dp1
            call pushcontrol1b(1)
          end if
          if (dpmax .gt. y1) then
            min1 = y1
            call pushcontrol1b(0)
          else
            min1 = dpmax
            call pushcontrol1b(1)
          end if
          call pushreal8(dis2)
          dis2 = fis2*ppor*min1 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          call pushreal8(dr)
          dr = dis2*ddw
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          call pushreal8(dru)
          dru = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          call pushreal8(drv)
          drv = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          call pushreal8(drw)
          drw = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          call pushreal8(dre)
          dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drk = dis2*ddw
            kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
            call pushcontrol1b(1)
          else
            drk = zero
            kavg = zero
            call pushcontrol1b(0)
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
          call pushreal8(a2avg)
          a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          call pushreal8(sx)
          sx = si(i, j, k, 1)
          call pushreal8(sy)
          sy = si(i, j, k, 2)
          call pushreal8(sz)
          sz = si(i, j, k, 3)
          call pushreal8(area)
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            call pushreal8(max1)
            max1 = area
            call pushcontrol1b(0)
          else
            call pushreal8(max1)
            max1 = 1.e-25_realtype
            call pushcontrol1b(1)
          end if
          tmp = one/max1
          call pushreal8(sx)
          sx = sx*tmp
          call pushreal8(sy)
          sy = sy*tmp
          call pushreal8(sz)
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call pushreal8(havg)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          call pushreal8(aavg)
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sface = sfacei(i, j, k)*tmp
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1 = unavg - sface + aavg
            call pushcontrol1b(0)
          else
            lam1 = -(unavg-sface+aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2 = unavg - sface - aavg
            call pushcontrol1b(0)
          else
            lam2 = -(unavg-sface-aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface .ge. 0.) then
            call pushreal8(lam3)
            lam3 = unavg - sface
            call pushcontrol1b(0)
          else
            call pushreal8(lam3)
            lam3 = -(unavg-sface)
            call pushcontrol1b(1)
          end if
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3 = epsshear*rrad
            call pushcontrol1b(0)
          else
            lam3 = lam3
            call pushcontrol1b(1)
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          call pushreal8(lam1)
          lam1 = lam1*area
          call pushreal8(lam2)
          lam2 = lam2*area
          call pushreal8(lam3)
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          call pushreal8(abv2)
          abv2 = half*(lam1-lam2)
          call pushreal8(abv3)
          abv3 = abv1 - lam3
          call pushreal8(abv4)
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
          dp1 = dp2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the j-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do i=2,il
        if (shocksensor(i, 2, k) - shocksensor(i, 1, k) .ge. 0.) then
          call pushreal8(abs3)
          abs3 = shocksensor(i, 2, k) - shocksensor(i, 1, k)
          call pushcontrol1b(1)
        else
          call pushreal8(abs3)
          abs3 = -(shocksensor(i, 2, k)-shocksensor(i, 1, k))
          call pushcontrol1b(0)
        end if
        if (shocksensor(i, 1, k) - shocksensor(i, 0, k) .ge. 0.) then
          call pushreal8(abs9)
          abs9 = shocksensor(i, 1, k) - shocksensor(i, 0, k)
          call pushcontrol1b(0)
        else
          call pushreal8(abs9)
          abs9 = -(shocksensor(i, 1, k)-shocksensor(i, 0, k))
          call pushcontrol1b(1)
        end if
        x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+shocksensor(&
&         i, 0, k))/(omega*(shocksensor(i, 2, k)+two*shocksensor(i, 1, k&
&         )+shocksensor(i, 0, k))+oneminomega*(abs3+abs9)+plim)
        if (x3 .ge. 0.) then
          dp1 = x3
          call pushcontrol1b(0)
        else
          dp1 = -x3
          call pushcontrol1b(1)
        end if
! loop in j-direction.
        do j=1,jl
          if (shocksensor(i, j+2, k) - shocksensor(i, j+1, k) .ge. 0.) &
&         then
            call pushreal8(abs4)
            abs4 = shocksensor(i, j+2, k) - shocksensor(i, j+1, k)
            call pushcontrol1b(1)
          else
            call pushreal8(abs4)
            abs4 = -(shocksensor(i, j+2, k)-shocksensor(i, j+1, k))
            call pushcontrol1b(0)
          end if
          if (shocksensor(i, j+1, k) - shocksensor(i, j, k) .ge. 0.) &
&         then
            call pushreal8(abs10)
            abs10 = shocksensor(i, j+1, k) - shocksensor(i, j, k)
            call pushcontrol1b(0)
          else
            call pushreal8(abs10)
            abs10 = -(shocksensor(i, j+1, k)-shocksensor(i, j, k))
            call pushcontrol1b(1)
          end if
          x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&           shocksensor(i, j, k))/(omega*(shocksensor(i, j+2, k)+two*&
&           shocksensor(i, j+1, k)+shocksensor(i, j, k))+oneminomega*(&
&           abs4+abs10)+plim)
          if (x4 .ge. 0.) then
            dp2 = x4
            call pushcontrol1b(0)
          else
            dp2 = -x4
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (porj(i, j, k) .eq. normalflux) ppor = one
          if (dp1 .lt. dp2) then
            y2 = dp2
            call pushcontrol1b(0)
          else
            y2 = dp1
            call pushcontrol1b(1)
          end if
          if (dpmax .gt. y2) then
            min2 = y2
            call pushcontrol1b(0)
          else
            min2 = dpmax
            call pushcontrol1b(1)
          end if
          call pushreal8(dis2)
          dis2 = fis2*ppor*min2 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          call pushreal8(dr)
          dr = dis2*ddw
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          call pushreal8(dru)
          dru = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          call pushreal8(drv)
          drv = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          call pushreal8(drw)
          drw = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          call pushreal8(dre)
          dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drk = dis2*ddw
            kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
            call pushcontrol1b(1)
          else
            drk = zero
            kavg = zero
            call pushcontrol1b(0)
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
          call pushreal8(a2avg)
          a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          call pushreal8(sx)
          sx = sj(i, j, k, 1)
          call pushreal8(sy)
          sy = sj(i, j, k, 2)
          call pushreal8(sz)
          sz = sj(i, j, k, 3)
          call pushreal8(area)
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            call pushreal8(max2)
            max2 = area
            call pushcontrol1b(0)
          else
            call pushreal8(max2)
            max2 = 1.e-25_realtype
            call pushcontrol1b(1)
          end if
          tmp = one/max2
          call pushreal8(sx)
          sx = sx*tmp
          call pushreal8(sy)
          sy = sy*tmp
          call pushreal8(sz)
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call pushreal8(havg)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          call pushreal8(aavg)
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sface = sfacej(i, j, k)*tmp
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1 = unavg - sface + aavg
            call pushcontrol1b(0)
          else
            lam1 = -(unavg-sface+aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2 = unavg - sface - aavg
            call pushcontrol1b(0)
          else
            lam2 = -(unavg-sface-aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface .ge. 0.) then
            call pushreal8(lam3)
            lam3 = unavg - sface
            call pushcontrol1b(0)
          else
            call pushreal8(lam3)
            lam3 = -(unavg-sface)
            call pushcontrol1b(1)
          end if
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3 = epsshear*rrad
            call pushcontrol1b(0)
          else
            lam3 = lam3
            call pushcontrol1b(1)
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          call pushreal8(lam1)
          lam1 = lam1*area
          call pushreal8(lam2)
          lam2 = lam2*area
          call pushreal8(lam3)
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          call pushreal8(abv2)
          abv2 = half*(lam1-lam2)
          call pushreal8(abv3)
          abv3 = abv1 - lam3
          call pushreal8(abv4)
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
          dp1 = dp2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the k-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do j=2,jl
      do i=2,il
        if (shocksensor(i, j, 2) - shocksensor(i, j, 1) .ge. 0.) then
          call pushreal8(abs5)
          abs5 = shocksensor(i, j, 2) - shocksensor(i, j, 1)
          call pushcontrol1b(1)
        else
          call pushreal8(abs5)
          abs5 = -(shocksensor(i, j, 2)-shocksensor(i, j, 1))
          call pushcontrol1b(0)
        end if
        if (shocksensor(i, j, 1) - shocksensor(i, j, 0) .ge. 0.) then
          call pushreal8(abs11)
          abs11 = shocksensor(i, j, 1) - shocksensor(i, j, 0)
          call pushcontrol1b(0)
        else
          call pushreal8(abs11)
          abs11 = -(shocksensor(i, j, 1)-shocksensor(i, j, 0))
          call pushcontrol1b(1)
        end if
        x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+shocksensor(&
&         i, j, 0))/(omega*(shocksensor(i, j, 2)+two*shocksensor(i, j, 1&
&         )+shocksensor(i, j, 0))+oneminomega*(abs5+abs11)+plim)
        if (x5 .ge. 0.) then
          dp1 = x5
          call pushcontrol1b(0)
        else
          dp1 = -x5
          call pushcontrol1b(1)
        end if
! loop in k-direction.
        do k=1,kl
          if (shocksensor(i, j, k+2) - shocksensor(i, j, k+1) .ge. 0.) &
&         then
            call pushreal8(abs6)
            abs6 = shocksensor(i, j, k+2) - shocksensor(i, j, k+1)
            call pushcontrol1b(1)
          else
            call pushreal8(abs6)
            abs6 = -(shocksensor(i, j, k+2)-shocksensor(i, j, k+1))
            call pushcontrol1b(0)
          end if
          if (shocksensor(i, j, k+1) - shocksensor(i, j, k) .ge. 0.) &
&         then
            call pushreal8(abs12)
            abs12 = shocksensor(i, j, k+1) - shocksensor(i, j, k)
            call pushcontrol1b(0)
          else
            call pushreal8(abs12)
            abs12 = -(shocksensor(i, j, k+1)-shocksensor(i, j, k))
            call pushcontrol1b(1)
          end if
          x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&           shocksensor(i, j, k))/(omega*(shocksensor(i, j, k+2)+two*&
&           shocksensor(i, j, k+1)+shocksensor(i, j, k))+oneminomega*(&
&           abs6+abs12)+plim)
          if (x6 .ge. 0.) then
            dp2 = x6
            call pushcontrol1b(0)
          else
            dp2 = -x6
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (pork(i, j, k) .eq. normalflux) ppor = one
          if (dp1 .lt. dp2) then
            y3 = dp2
            call pushcontrol1b(0)
          else
            y3 = dp1
            call pushcontrol1b(1)
          end if
          if (dpmax .gt. y3) then
            min3 = y3
            call pushcontrol1b(0)
          else
            min3 = dpmax
            call pushcontrol1b(1)
          end if
          call pushreal8(dis2)
          dis2 = fis2*ppor*min3 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          call pushreal8(dr)
          dr = dis2*ddw
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          call pushreal8(dru)
          dru = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          call pushreal8(drv)
          drv = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          call pushreal8(drw)
          drw = dis2*ddw
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          call pushreal8(dre)
          dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drk = dis2*ddw
            kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
            call pushcontrol1b(1)
          else
            drk = zero
            kavg = zero
            call pushcontrol1b(0)
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
          call pushreal8(a2avg)
          a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          call pushreal8(sx)
          sx = sk(i, j, k, 1)
          call pushreal8(sy)
          sy = sk(i, j, k, 2)
          call pushreal8(sz)
          sz = sk(i, j, k, 3)
          call pushreal8(area)
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            call pushreal8(max3)
            max3 = area
            call pushcontrol1b(0)
          else
            call pushreal8(max3)
            max3 = 1.e-25_realtype
            call pushcontrol1b(1)
          end if
          tmp = one/max3
          call pushreal8(sx)
          sx = sx*tmp
          call pushreal8(sy)
          sy = sy*tmp
          call pushreal8(sz)
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call pushreal8(havg)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          call pushreal8(aavg)
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sface = sfacek(i, j, k)*tmp
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1 = unavg - sface + aavg
            call pushcontrol1b(0)
          else
            lam1 = -(unavg-sface+aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2 = unavg - sface - aavg
            call pushcontrol1b(0)
          else
            lam2 = -(unavg-sface-aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface .ge. 0.) then
            call pushreal8(lam3)
            lam3 = unavg - sface
            call pushcontrol1b(0)
          else
            call pushreal8(lam3)
            lam3 = -(unavg-sface)
            call pushcontrol1b(1)
          end if
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3 = epsshear*rrad
            call pushcontrol1b(0)
          else
            lam3 = lam3
            call pushcontrol1b(1)
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          call pushreal8(lam1)
          lam1 = lam1*area
          call pushreal8(lam2)
          lam2 = lam2*area
          call pushreal8(lam3)
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          call pushreal8(abv2)
          abv2 = half*(lam1-lam2)
          call pushreal8(abv3)
          abv3 = abv1 - lam3
          call pushreal8(abv4)
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
          dp1 = dp2
        end do
      end do
    end do
    plimd = 0.0_8
    sfaced = 0.0_8
    do j=jl,2,-1
      do i=il,2,-1
        dp1d = 0.0_8
        do k=kl,1,-1
          dp2d = dp1d
          fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
          wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
          vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
          uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
          unavg = uavg*sx + vavg*sy + wavg*sz
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          ovaavg = one/aavg
          ova2avg = one/a2avg
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
          lam3d = dre*fsd
          dred = lam3*fsd
          havgd = abv6*fsd
          abv6d = havg*fsd
          unavgd = abv7*fsd
          abv7d = unavg*fsd
          fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
          lam3d = lam3d + drw*fsd
          drwd = lam3*fsd
          wavgd = abv6*fsd
          abv6d = abv6d + wavg*fsd
          szd = abv7*fsd
          abv7d = abv7d + sz*fsd
          fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
          lam3d = lam3d + drv*fsd
          drvd = lam3*fsd
          vavgd = abv6*fsd
          abv6d = abv6d + vavg*fsd
          syd = abv7*fsd
          abv7d = abv7d + sy*fsd
          fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
          lam3d = lam3d + dru*fsd
          drud = lam3*fsd
          uavgd = abv6*fsd
          abv6d = abv6d + uavg*fsd
          sxd = abv7*fsd
          abv7d = abv7d + sx*fsd
          fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
          abv6d = abv6d + fsd
          abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
          abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
          ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
          abv3d = ova2avg*abv4*abv6d + abv5*abv7d
          lam3d = lam3d + dr*fsd - abv3d
          abv5d = ovaavg*abv2*abv6d + abv3*abv7d
          ova2avgd = abv3*abv4*abv6d
          sxd = sxd + dru*abv5d
          syd = syd + drv*abv5d
          szd = szd + drw*abv5d
          unavgd = unavgd - dr*abv5d
          gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
          gm1 = gammaavg - one
          gm53 = gammaavg - five*third
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call popreal8(abv4)
          tempd13 = gm1*abv4d
          drd = alphaavg*tempd13 - unavg*abv5d + lam3*fsd
          drud = drud + sx*abv5d - uavg*tempd13
          drvd = drvd + sy*abv5d - vavg*tempd13
          drwd = drwd + sz*abv5d - wavg*tempd13
          alphaavgd = dr*tempd13
          uavgd = uavgd - dru*tempd13
          vavgd = vavgd - drv*tempd13
          dred = dred + tempd13
          wavgd = wavgd - drw*tempd13
          drkd = -(gm53*abv4d)
          call popreal8(abv3)
          abv1d = abv3d
          call popreal8(abv2)
          lam1d = half*abv1d + half*abv2d
          lam2d = half*abv1d - half*abv2d
          call popreal8(lam3)
          call popreal8(lam2)
          call popreal8(lam1)
          aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
          lam3d = area*lam3d
          lam2d = area*lam2d
          lam1d = area*lam1d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = epsshear*lam3d
            lam3d = 0.0_8
          else
            rradd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam2d
            lam2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam1d
            lam1d = 0.0_8
          end if
          lam3d = lam3d + rradd
          aavgd = rradd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam3)
            unavgd = unavgd + lam3d
            sfaced = sfaced - lam3d
          else
            call popreal8(lam3)
            sfaced = sfaced + lam3d
            unavgd = unavgd - lam3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam2d
            sfaced = sfaced - lam2d
            aavgd = aavgd - lam2d
          else
            sfaced = sfaced + lam2d
            unavgd = unavgd - lam2d
            aavgd = aavgd + lam2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam1d
            sfaced = sfaced - lam1d
            aavgd = aavgd + lam1d
          else
            sfaced = sfaced + lam1d
            unavgd = unavgd - lam1d
            aavgd = aavgd - lam1d
          end if
          tmp = one/max3
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            tmpd = 0.0_8
          else
            tmpd = sfacek(i, j, k)*sfaced
            sfaced = 0.0_8
          end if
          alphaavgd = alphaavgd + havgd
          tempd12 = half*alphaavgd
          ovgm1 = one/gm1
          aavgd = aavgd - one*ovaavgd/aavg**2
          if (a2avg .eq. 0.0_8) then
            a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
          else
            a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&             ova2avgd/a2avg**2
          end if
          uavgd = uavgd + 2*uavg*tempd12 + sx*unavgd
          sxd = sxd + uavg*unavgd
          vavgd = vavgd + 2*vavg*tempd12 + sy*unavgd
          syd = syd + vavg*unavgd
          wavgd = wavgd + 2*wavg*tempd12 + sz*unavgd
          szd = szd + wavg*unavgd
          call popreal8(aavg)
          call popreal8(havg)
          kavgd = -(ovgm1*gm53*havgd)
          call popreal8(sz)
          call popreal8(sy)
          call popreal8(sx)
          tmpd = tmpd + sy*syd + sx*sxd + sz*szd
          szd = tmp*szd
          syd = tmp*syd
          sxd = tmp*sxd
          max3d = -(one*tmpd/max3**2)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max3)
            aread = aread + max3d
          else
            call popreal8(max3)
          end if
          call popreal8(area)
          if (sx**2 + sy**2 + sz**2 .eq. 0.0_8) then
            tempd9 = 0.0
          else
            tempd9 = aread/(2.0*sqrt(sx**2+sy**2+sz**2))
          end if
          sxd = sxd + 2*sx*tempd9
          syd = syd + 2*sy*tempd9
          szd = szd + 2*sz*tempd9
          call popreal8(sz)
          skd(i, j, k, 3) = skd(i, j, k, 3) + szd
          call popreal8(sy)
          skd(i, j, k, 2) = skd(i, j, k, 2) + syd
          call popreal8(sx)
          skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
          call popreal8(a2avg)
          temp10 = w(i, j, k, irho)
          temp9 = w(i, j, k+1, irho)
          tempd10 = gamma(i, j, k+1)*half*a2avgd/temp9
          tempd11 = gamma(i, j, k)*half*a2avgd/temp10
          pd(i, j, k+1) = pd(i, j, k+1) + tempd10
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - p(i, j, k+1)*&
&           tempd10/temp9
          pd(i, j, k) = pd(i, j, k) + tempd11
          wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd11/&
&           temp10
          wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wavgd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
          wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vavgd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
          wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*uavgd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dis2d = 0.0_8
          else
            wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*kavgd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
            dis2d = ddw*drkd
            ddwd = dis2*drkd
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, &
&             itu1)*ddwd
            wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + w(i, j, k+1, &
&             irho)*ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&             ddwd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&             ddwd
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          end if
          call popreal8(dre)
          dis2d = dis2d + ddw*dred
          ddwd = dis2*dred
          call popreal8(ddw)
          wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          call popreal8(drw)
          dis2d = dis2d + ddw*drwd
          ddwd = dis2*drwd
          call popreal8(ddw)
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
&           ddwd
          wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
          call popreal8(drv)
          dis2d = dis2d + ddw*drvd
          ddwd = dis2*drvd
          call popreal8(ddw)
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
&           ddwd
          wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
          call popreal8(dru)
          dis2d = dis2d + ddw*drud
          ddwd = dis2*drud
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
&           ddwd
          wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          call popreal8(dr)
          dis2d = dis2d + ddw*drd
          ddwd = dis2*drd
          call popreal8(ddw)
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          call popreal8(dis2)
          min3d = fis2*ppor*dis2d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            y3d = min3d
          else
            y3d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dp2d = dp2d + y3d
            dp1d = 0.0_8
          else
            dp1d = y3d
          end if
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x6d = dp2d
          else
            x6d = -dp2d
          end if
          temp8 = omega*(shocksensor(i, j, k+2)+two*shocksensor(i, j, k+&
&           1)+shocksensor(i, j, k)) + oneminomega*(abs6+abs12) + plim
          plimd = plimd - (shocksensor(i, j, k+2)-two*shocksensor(i, j, &
&           k+1)+shocksensor(i, j, k))*x6d/temp8**2
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs12)
          else
            call popreal8(abs12)
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs6)
          else
            call popreal8(abs6)
          end if
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x5d = dp1d
        else
          x5d = -dp1d
        end if
        temp7 = omega*(shocksensor(i, j, 2)+two*shocksensor(i, j, 1)+&
&         shocksensor(i, j, 0)) + oneminomega*(abs5+abs11) + plim
        plimd = plimd - (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&         shocksensor(i, j, 0))*x5d/temp7**2
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs11)
        else
          call popreal8(abs11)
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs5)
        else
          call popreal8(abs5)
        end if
      end do
    end do
    do k=kl,2,-1
      do i=il,2,-1
        dp1d = 0.0_8
        do j=jl,1,-1
          dp2d = dp1d
          fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
          wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
          vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
          uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
          unavg = uavg*sx + vavg*sy + wavg*sz
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          ovaavg = one/aavg
          ova2avg = one/a2avg
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
          lam3d = dre*fsd
          dred = lam3*fsd
          havgd = abv6*fsd
          abv6d = havg*fsd
          unavgd = abv7*fsd
          abv7d = unavg*fsd
          fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
          lam3d = lam3d + drw*fsd
          drwd = lam3*fsd
          wavgd = abv6*fsd
          abv6d = abv6d + wavg*fsd
          szd = abv7*fsd
          abv7d = abv7d + sz*fsd
          fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
          lam3d = lam3d + drv*fsd
          drvd = lam3*fsd
          vavgd = abv6*fsd
          abv6d = abv6d + vavg*fsd
          syd = abv7*fsd
          abv7d = abv7d + sy*fsd
          fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
          lam3d = lam3d + dru*fsd
          drud = lam3*fsd
          uavgd = abv6*fsd
          abv6d = abv6d + uavg*fsd
          sxd = abv7*fsd
          abv7d = abv7d + sx*fsd
          fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
          abv6d = abv6d + fsd
          abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
          abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
          ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
          abv3d = ova2avg*abv4*abv6d + abv5*abv7d
          lam3d = lam3d + dr*fsd - abv3d
          abv5d = ovaavg*abv2*abv6d + abv3*abv7d
          ova2avgd = abv3*abv4*abv6d
          sxd = sxd + dru*abv5d
          syd = syd + drv*abv5d
          szd = szd + drw*abv5d
          unavgd = unavgd - dr*abv5d
          gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          gm53 = gammaavg - five*third
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call popreal8(abv4)
          tempd8 = gm1*abv4d
          drd = alphaavg*tempd8 - unavg*abv5d + lam3*fsd
          drud = drud + sx*abv5d - uavg*tempd8
          drvd = drvd + sy*abv5d - vavg*tempd8
          drwd = drwd + sz*abv5d - wavg*tempd8
          alphaavgd = dr*tempd8
          uavgd = uavgd - dru*tempd8
          vavgd = vavgd - drv*tempd8
          dred = dred + tempd8
          wavgd = wavgd - drw*tempd8
          drkd = -(gm53*abv4d)
          call popreal8(abv3)
          abv1d = abv3d
          call popreal8(abv2)
          lam1d = half*abv1d + half*abv2d
          lam2d = half*abv1d - half*abv2d
          call popreal8(lam3)
          call popreal8(lam2)
          call popreal8(lam1)
          aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
          lam3d = area*lam3d
          lam2d = area*lam2d
          lam1d = area*lam1d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = epsshear*lam3d
            lam3d = 0.0_8
          else
            rradd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam2d
            lam2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam1d
            lam1d = 0.0_8
          end if
          lam3d = lam3d + rradd
          aavgd = rradd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam3)
            unavgd = unavgd + lam3d
            sfaced = sfaced - lam3d
          else
            call popreal8(lam3)
            sfaced = sfaced + lam3d
            unavgd = unavgd - lam3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam2d
            sfaced = sfaced - lam2d
            aavgd = aavgd - lam2d
          else
            sfaced = sfaced + lam2d
            unavgd = unavgd - lam2d
            aavgd = aavgd + lam2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam1d
            sfaced = sfaced - lam1d
            aavgd = aavgd + lam1d
          else
            sfaced = sfaced + lam1d
            unavgd = unavgd - lam1d
            aavgd = aavgd - lam1d
          end if
          tmp = one/max2
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            tmpd = 0.0_8
          else
            tmpd = sfacej(i, j, k)*sfaced
            sfaced = 0.0_8
          end if
          alphaavgd = alphaavgd + havgd
          tempd7 = half*alphaavgd
          ovgm1 = one/gm1
          aavgd = aavgd - one*ovaavgd/aavg**2
          if (a2avg .eq. 0.0_8) then
            a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
          else
            a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&             ova2avgd/a2avg**2
          end if
          uavgd = uavgd + 2*uavg*tempd7 + sx*unavgd
          sxd = sxd + uavg*unavgd
          vavgd = vavgd + 2*vavg*tempd7 + sy*unavgd
          syd = syd + vavg*unavgd
          wavgd = wavgd + 2*wavg*tempd7 + sz*unavgd
          szd = szd + wavg*unavgd
          call popreal8(aavg)
          call popreal8(havg)
          kavgd = -(ovgm1*gm53*havgd)
          call popreal8(sz)
          call popreal8(sy)
          call popreal8(sx)
          tmpd = tmpd + sy*syd + sx*sxd + sz*szd
          szd = tmp*szd
          syd = tmp*syd
          sxd = tmp*sxd
          max2d = -(one*tmpd/max2**2)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max2)
            aread = aread + max2d
          else
            call popreal8(max2)
          end if
          call popreal8(area)
          if (sx**2 + sy**2 + sz**2 .eq. 0.0_8) then
            tempd4 = 0.0
          else
            tempd4 = aread/(2.0*sqrt(sx**2+sy**2+sz**2))
          end if
          sxd = sxd + 2*sx*tempd4
          syd = syd + 2*sy*tempd4
          szd = szd + 2*sz*tempd4
          call popreal8(sz)
          sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
          call popreal8(sy)
          sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
          call popreal8(sx)
          sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
          call popreal8(a2avg)
          temp6 = w(i, j, k, irho)
          temp5 = w(i, j+1, k, irho)
          tempd5 = gamma(i, j+1, k)*half*a2avgd/temp5
          tempd6 = gamma(i, j, k)*half*a2avgd/temp6
          pd(i, j+1, k) = pd(i, j+1, k) + tempd5
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - p(i, j+1, k)*&
&           tempd5/temp5
          pd(i, j, k) = pd(i, j, k) + tempd6
          wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd6/&
&           temp6
          wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wavgd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
          wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vavgd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
          wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*uavgd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dis2d = 0.0_8
          else
            wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
            wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*kavgd
            dis2d = ddw*drkd
            ddwd = dis2*drkd
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, &
&             itu1)*ddwd
            wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + w(i, j+1, k, &
&             irho)*ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&             ddwd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&             ddwd
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          end if
          call popreal8(dre)
          dis2d = dis2d + ddw*dred
          ddwd = dis2*dred
          call popreal8(ddw)
          wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          call popreal8(drw)
          dis2d = dis2d + ddw*drwd
          ddwd = dis2*drwd
          call popreal8(ddw)
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
&           ddwd
          wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
          call popreal8(drv)
          dis2d = dis2d + ddw*drvd
          ddwd = dis2*drvd
          call popreal8(ddw)
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
&           ddwd
          wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
          call popreal8(dru)
          dis2d = dis2d + ddw*drud
          ddwd = dis2*drud
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
&           ddwd
          wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          call popreal8(dr)
          dis2d = dis2d + ddw*drd
          ddwd = dis2*drd
          call popreal8(ddw)
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          call popreal8(dis2)
          min2d = fis2*ppor*dis2d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            y2d = min2d
          else
            y2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dp2d = dp2d + y2d
            dp1d = 0.0_8
          else
            dp1d = y2d
          end if
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x4d = dp2d
          else
            x4d = -dp2d
          end if
          temp4 = omega*(shocksensor(i, j+2, k)+two*shocksensor(i, j+1, &
&           k)+shocksensor(i, j, k)) + oneminomega*(abs4+abs10) + plim
          plimd = plimd - (shocksensor(i, j+2, k)-two*shocksensor(i, j+1&
&           , k)+shocksensor(i, j, k))*x4d/temp4**2
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs10)
          else
            call popreal8(abs10)
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs4)
          else
            call popreal8(abs4)
          end if
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x3d = dp1d
        else
          x3d = -dp1d
        end if
        temp3 = omega*(shocksensor(i, 2, k)+two*shocksensor(i, 1, k)+&
&         shocksensor(i, 0, k)) + oneminomega*(abs3+abs9) + plim
        plimd = plimd - (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&         shocksensor(i, 0, k))*x3d/temp3**2
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs9)
        else
          call popreal8(abs9)
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs3)
        else
          call popreal8(abs3)
        end if
      end do
    end do
    do k=kl,2,-1
      do j=jl,2,-1
        dp1d = 0.0_8
        do i=il,1,-1
          dp2d = dp1d
          fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
          wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
          vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
          uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
          unavg = uavg*sx + vavg*sy + wavg*sz
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          ovaavg = one/aavg
          ova2avg = one/a2avg
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
          lam3d = dre*fsd
          dred = lam3*fsd
          havgd = abv6*fsd
          abv6d = havg*fsd
          unavgd = abv7*fsd
          abv7d = unavg*fsd
          fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
          lam3d = lam3d + drw*fsd
          drwd = lam3*fsd
          wavgd = abv6*fsd
          abv6d = abv6d + wavg*fsd
          szd = abv7*fsd
          abv7d = abv7d + sz*fsd
          fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
          lam3d = lam3d + drv*fsd
          drvd = lam3*fsd
          vavgd = abv6*fsd
          abv6d = abv6d + vavg*fsd
          syd = abv7*fsd
          abv7d = abv7d + sy*fsd
          fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
          lam3d = lam3d + dru*fsd
          drud = lam3*fsd
          uavgd = abv6*fsd
          abv6d = abv6d + uavg*fsd
          sxd = abv7*fsd
          abv7d = abv7d + sx*fsd
          fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
          abv6d = abv6d + fsd
          abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
          abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
          ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
          abv3d = ova2avg*abv4*abv6d + abv5*abv7d
          lam3d = lam3d + dr*fsd - abv3d
          abv5d = ovaavg*abv2*abv6d + abv3*abv7d
          ova2avgd = abv3*abv4*abv6d
          sxd = sxd + dru*abv5d
          syd = syd + drv*abv5d
          szd = szd + drw*abv5d
          unavgd = unavgd - dr*abv5d
          gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          gm53 = gammaavg - five*third
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call popreal8(abv4)
          tempd3 = gm1*abv4d
          drd = alphaavg*tempd3 - unavg*abv5d + lam3*fsd
          drud = drud + sx*abv5d - uavg*tempd3
          drvd = drvd + sy*abv5d - vavg*tempd3
          drwd = drwd + sz*abv5d - wavg*tempd3
          alphaavgd = dr*tempd3
          uavgd = uavgd - dru*tempd3
          vavgd = vavgd - drv*tempd3
          dred = dred + tempd3
          wavgd = wavgd - drw*tempd3
          drkd = -(gm53*abv4d)
          call popreal8(abv3)
          abv1d = abv3d
          call popreal8(abv2)
          lam1d = half*abv1d + half*abv2d
          lam2d = half*abv1d - half*abv2d
          call popreal8(lam3)
          call popreal8(lam2)
          call popreal8(lam1)
          aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
          lam3d = area*lam3d
          lam2d = area*lam2d
          lam1d = area*lam1d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = epsshear*lam3d
            lam3d = 0.0_8
          else
            rradd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam2d
            lam2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam1d
            lam1d = 0.0_8
          end if
          lam3d = lam3d + rradd
          aavgd = rradd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam3)
            unavgd = unavgd + lam3d
            sfaced = sfaced - lam3d
          else
            call popreal8(lam3)
            sfaced = sfaced + lam3d
            unavgd = unavgd - lam3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam2d
            sfaced = sfaced - lam2d
            aavgd = aavgd - lam2d
          else
            sfaced = sfaced + lam2d
            unavgd = unavgd - lam2d
            aavgd = aavgd + lam2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam1d
            sfaced = sfaced - lam1d
            aavgd = aavgd + lam1d
          else
            sfaced = sfaced + lam1d
            unavgd = unavgd - lam1d
            aavgd = aavgd - lam1d
          end if
          tmp = one/max1
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            tmpd = 0.0_8
          else
            tmpd = sfacei(i, j, k)*sfaced
            sfaced = 0.0_8
          end if
          alphaavgd = alphaavgd + havgd
          tempd2 = half*alphaavgd
          ovgm1 = one/gm1
          aavgd = aavgd - one*ovaavgd/aavg**2
          if (a2avg .eq. 0.0_8) then
            a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
          else
            a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&             ova2avgd/a2avg**2
          end if
          uavgd = uavgd + 2*uavg*tempd2 + sx*unavgd
          sxd = sxd + uavg*unavgd
          vavgd = vavgd + 2*vavg*tempd2 + sy*unavgd
          syd = syd + vavg*unavgd
          wavgd = wavgd + 2*wavg*tempd2 + sz*unavgd
          szd = szd + wavg*unavgd
          call popreal8(aavg)
          call popreal8(havg)
          kavgd = -(ovgm1*gm53*havgd)
          call popreal8(sz)
          call popreal8(sy)
          call popreal8(sx)
          tmpd = tmpd + sy*syd + sx*sxd + sz*szd
          szd = tmp*szd
          syd = tmp*syd
          sxd = tmp*sxd
          max1d = -(one*tmpd/max1**2)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max1)
            aread = aread + max1d
          else
            call popreal8(max1)
          end if
          call popreal8(area)
          if (sx**2 + sy**2 + sz**2 .eq. 0.0_8) then
            tempd = 0.0
          else
            tempd = aread/(2.0*sqrt(sx**2+sy**2+sz**2))
          end if
          sxd = sxd + 2*sx*tempd
          syd = syd + 2*sy*tempd
          szd = szd + 2*sz*tempd
          call popreal8(sz)
          sid(i, j, k, 3) = sid(i, j, k, 3) + szd
          call popreal8(sy)
          sid(i, j, k, 2) = sid(i, j, k, 2) + syd
          call popreal8(sx)
          sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
          call popreal8(a2avg)
          temp2 = w(i, j, k, irho)
          temp1 = w(i+1, j, k, irho)
          tempd0 = gamma(i+1, j, k)*half*a2avgd/temp1
          tempd1 = gamma(i, j, k)*half*a2avgd/temp2
          pd(i+1, j, k) = pd(i+1, j, k) + tempd0
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - p(i+1, j, k)*&
&           tempd0/temp1
          pd(i, j, k) = pd(i, j, k) + tempd1
          wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd1/&
&           temp2
          wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wavgd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
          wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vavgd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
          wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*uavgd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dis2d = 0.0_8
          else
            wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
            wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*kavgd
            dis2d = ddw*drkd
            ddwd = dis2*drkd
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, &
&             itu1)*ddwd
            wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + w(i+1, j, k, &
&             irho)*ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&             ddwd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&             ddwd
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          end if
          call popreal8(dre)
          dis2d = dis2d + ddw*dred
          ddwd = dis2*dred
          call popreal8(ddw)
          wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          call popreal8(drw)
          dis2d = dis2d + ddw*drwd
          ddwd = dis2*drwd
          call popreal8(ddw)
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
&           ddwd
          wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
          call popreal8(drv)
          dis2d = dis2d + ddw*drvd
          ddwd = dis2*drvd
          call popreal8(ddw)
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
&           ddwd
          wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
          call popreal8(dru)
          dis2d = dis2d + ddw*drud
          ddwd = dis2*drud
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
&           ddwd
          wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          call popreal8(dr)
          dis2d = dis2d + ddw*drd
          ddwd = dis2*drd
          call popreal8(ddw)
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          call popreal8(dis2)
          min1d = fis2*ppor*dis2d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            y1d = min1d
          else
            y1d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dp2d = dp2d + y1d
            dp1d = 0.0_8
          else
            dp1d = y1d
          end if
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x2d = dp2d
          else
            x2d = -dp2d
          end if
          temp0 = omega*(shocksensor(i+2, j, k)+two*shocksensor(i+1, j, &
&           k)+shocksensor(i, j, k)) + oneminomega*(abs2+abs8) + plim
          plimd = plimd - (shocksensor(i+2, j, k)-two*shocksensor(i+1, j&
&           , k)+shocksensor(i, j, k))*x2d/temp0**2
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs8)
          else
            call popreal8(abs8)
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs2)
          else
            call popreal8(abs2)
          end if
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x1d = dp1d
        else
          x1d = -dp1d
        end if
        temp = omega*(shocksensor(2, j, k)+two*shocksensor(1, j, k)+&
&         shocksensor(0, j, k)) + oneminomega*(abs1+abs7) + plim
        plimd = plimd - (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&         shocksensor(0, j, k))*x1d/temp**2
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs7)
        else
          call popreal8(abs7)
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs1)
        else
          call popreal8(abs1)
        end if
      end do
    end do
    pinfcorrd = 0.001_realtype*plimd
  end if
end subroutine invisciddissfluxmatrixapprox_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
! this module contains the source code related to the sa turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier. 
module sa_b
  use constants
  implicit none
  real(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
  real(kind=realtype), dimension(:, :, :), allocatable :: qq
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall

contains
!  differentiation of sa_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw *w *rlv *vol *si *sj *sk
!                (global)timeref
!   with respect to varying inputs: *dw *w *rlv *vol *d2wall *si
!                *sj *sk (global)timeref
!   plus diff mem management of: bvtj1:in bvtj2:in dw:in w:in rlv:in
!                scratch:in bvtk1:in bvtk2:in vol:in d2wall:in
!                si:in sj:in sk:in bvti1:in bvti2:in bcdata:in
  subroutine sa_block_b(resonly)
!
!       sa solves the transport equation for the spalart-allmaras
!       turbulence model in a segregated manner using a diagonal
!       dominant adi-scheme. note that the scratch and boundary
!       matrix values are not strictly, but tapande would like to
!       see them becuase it must save them.
!
    use constants
    use blockpointers, only : ndom, il, jl, kl, scratch, scratchd, &
&   bmtj1, bmtj2, bmti1, bmti2, bmtk1, bmtk2
    use inputtimespectral, only : ntimeintervalsspectral
    use iteration, only : currentlevel
    use inputphysics, only : turbprod
    use paramturb
    use turbutils_b
    use turbbcroutines_b
    implicit none
!
!      subroutine argument.
!
    logical, intent(in) :: resonly
!
!      local variables.
!
    integer(kind=inttype) :: nn, sps
! set the arrays for the boundary condition treatment.
! alloc central jacobian memory
    allocate(qq(2:il, 2:jl, 2:kl))
! source terms
    call sasource()
! advection term
    nn = itu1 - 1
    call turbadvection(1_inttype, 1_inttype, nn, qq)
! unsteady term
    call unsteadyturbterm(1_inttype, 1_inttype, nn, qq)
! viscous terms
    call saviscous()
! perform the residual scaling
! we need to do an acutal solve. solve and update the eddy
! viscosity and the boundary conditions
    call saresscale_b()
    call saviscous_b()
    call unsteadyturbterm_b(1_inttype, 1_inttype, nn, qq)
    call turbadvection_b(1_inttype, 1_inttype, nn, qq)
    call sasource_b()
  deallocate(qq)
end subroutine sa_block_b
  subroutine sa_block(resonly)
!
!       sa solves the transport equation for the spalart-allmaras
!       turbulence model in a segregated manner using a diagonal
!       dominant adi-scheme. note that the scratch and boundary
!       matrix values are not strictly, but tapande would like to
!       see them becuase it must save them.
!
    use constants
    use blockpointers, only : ndom, il, jl, kl, scratch, bmtj1, bmtj2,&
&   bmti1, bmti2, bmtk1, bmtk2
    use inputtimespectral, only : ntimeintervalsspectral
    use iteration, only : currentlevel
    use inputphysics, only : turbprod
    use paramturb
    use turbutils_b
    use turbbcroutines_b
    implicit none
!
!      subroutine argument.
!
    logical, intent(in) :: resonly
!
!      local variables.
!
    integer(kind=inttype) :: nn, sps
! set the arrays for the boundary condition treatment.
    call bcturbtreatment()
! alloc central jacobian memory
    allocate(qq(2:il, 2:jl, 2:kl))
! source terms
    call sasource()
! advection term
    nn = itu1 - 1
    call turbadvection(1_inttype, 1_inttype, nn, qq)
! unsteady term
    call unsteadyturbterm(1_inttype, 1_inttype, nn, qq)
! viscous terms
    call saviscous()
! perform the residual scaling
    call saresscale()
! we need to do an acutal solve. solve and update the eddy
! viscosity and the boundary conditions
    deallocate(qq)
  end subroutine sa_block
!  differentiation of sasource in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *rlv *scratch *vol *si *sj
!                *sk timeref
!   with respect to varying inputs: *w *rlv *vol *d2wall *si *sj
!                *sk timeref
!   plus diff mem management of: w:in rlv:in scratch:in vol:in
!                d2wall:in si:in sj:in sk:in
  subroutine sasource_b()
!
!  source terms.                                                  
!  determine the source term and its derivative w.r.t. nutilde    
!  for all internal cells of the block.                           
    use blockpointers
    use constants
    use paramturb
    use section
    use inputphysics
    use flowvarrefstate
    implicit none
! local parameters
    real(kind=realtype), parameter :: f23=two*third
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: fv1d, fv2d, ft2d
    real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
    real(kind=realtype) :: ssd, sstd, nud, dist2invd, chid, chi2d, chi3d
    real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
    real(kind=realtype) :: rrd, ggd, gg6d, termfwd, fwsad, term1d, &
&   term2d
    real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
    real(kind=realtype) :: uux, uuy, uuz, vvx, vvy, vvz, wwx, wwy, wwz
    real(kind=realtype) :: uuxd, uuyd, uuzd, vvxd, vvyd, vvzd, wwxd, &
&   wwyd, wwzd
    real(kind=realtype) :: div2, fact, sxx, syy, szz, sxy, sxz, syz
    real(kind=realtype) :: div2d, factd, sxxd, syyd, szzd, sxyd, sxzd, &
&   syzd
    real(kind=realtype) :: vortx, vorty, vortz
    real(kind=realtype) :: vortxd, vortyd, vortzd
    real(kind=realtype) :: omegax, omegay, omegaz
    real(kind=realtype) :: omegaxd, omegayd, omegazd
    real(kind=realtype) :: strainmag2, strainprod, vortprod
    real(kind=realtype) :: strainmag2d, strainprodd, vortprodd
    real(kind=realtype), parameter :: xminn=1.e-10_realtype
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic min
    intrinsic max
    integer :: branch
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: min1
    real(kind=realtype) :: min1d
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    real(kind=realtype) :: y1
    real(kind=realtype) :: y1d
! set model constants
    cv13 = rsacv1**3
    kar2inv = one/rsak**2
    cw36 = rsacw3**6
! determine the non-dimensional wheel speed of this block.
    omegax = timeref*sections(sectionid)%rotrate(1)
    omegay = timeref*sections(sectionid)%rotrate(2)
    omegaz = timeref*sections(sectionid)%rotrate(3)
! create switches to production term depending on the variable that
! should be used
    if (turbprod .eq. katolaunder) then
      stop
    else
      d2walld = 0.0_8
      omegaxd = 0.0_8
      omegayd = 0.0_8
      omegazd = 0.0_8
      strainmag2d = 0.0_8
      ssd = 0.0_8
      do ii=0,nx*ny*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 2
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! the gradient is scaled by the factor 2*vol.
        uux = w(i+1, j, k, ivx)*si(i, j, k, 1) - w(i-1, j, k, ivx)*si(i-&
&         1, j, k, 1) + w(i, j+1, k, ivx)*sj(i, j, k, 1) - w(i, j-1, k, &
&         ivx)*sj(i, j-1, k, 1) + w(i, j, k+1, ivx)*sk(i, j, k, 1) - w(i&
&         , j, k-1, ivx)*sk(i, j, k-1, 1)
        uuy = w(i+1, j, k, ivx)*si(i, j, k, 2) - w(i-1, j, k, ivx)*si(i-&
&         1, j, k, 2) + w(i, j+1, k, ivx)*sj(i, j, k, 2) - w(i, j-1, k, &
&         ivx)*sj(i, j-1, k, 2) + w(i, j, k+1, ivx)*sk(i, j, k, 2) - w(i&
&         , j, k-1, ivx)*sk(i, j, k-1, 2)
        uuz = w(i+1, j, k, ivx)*si(i, j, k, 3) - w(i-1, j, k, ivx)*si(i-&
&         1, j, k, 3) + w(i, j+1, k, ivx)*sj(i, j, k, 3) - w(i, j-1, k, &
&         ivx)*sj(i, j-1, k, 3) + w(i, j, k+1, ivx)*sk(i, j, k, 3) - w(i&
&         , j, k-1, ivx)*sk(i, j, k-1, 3)
! idem for the gradient of v.
        vvx = w(i+1, j, k, ivy)*si(i, j, k, 1) - w(i-1, j, k, ivy)*si(i-&
&         1, j, k, 1) + w(i, j+1, k, ivy)*sj(i, j, k, 1) - w(i, j-1, k, &
&         ivy)*sj(i, j-1, k, 1) + w(i, j, k+1, ivy)*sk(i, j, k, 1) - w(i&
&         , j, k-1, ivy)*sk(i, j, k-1, 1)
        vvy = w(i+1, j, k, ivy)*si(i, j, k, 2) - w(i-1, j, k, ivy)*si(i-&
&         1, j, k, 2) + w(i, j+1, k, ivy)*sj(i, j, k, 2) - w(i, j-1, k, &
&         ivy)*sj(i, j-1, k, 2) + w(i, j, k+1, ivy)*sk(i, j, k, 2) - w(i&
&         , j, k-1, ivy)*sk(i, j, k-1, 2)
        vvz = w(i+1, j, k, ivy)*si(i, j, k, 3) - w(i-1, j, k, ivy)*si(i-&
&         1, j, k, 3) + w(i, j+1, k, ivy)*sj(i, j, k, 3) - w(i, j-1, k, &
&         ivy)*sj(i, j-1, k, 3) + w(i, j, k+1, ivy)*sk(i, j, k, 3) - w(i&
&         , j, k-1, ivy)*sk(i, j, k-1, 3)
! and for the gradient of w.
        wwx = w(i+1, j, k, ivz)*si(i, j, k, 1) - w(i-1, j, k, ivz)*si(i-&
&         1, j, k, 1) + w(i, j+1, k, ivz)*sj(i, j, k, 1) - w(i, j-1, k, &
&         ivz)*sj(i, j-1, k, 1) + w(i, j, k+1, ivz)*sk(i, j, k, 1) - w(i&
&         , j, k-1, ivz)*sk(i, j, k-1, 1)
        wwy = w(i+1, j, k, ivz)*si(i, j, k, 2) - w(i-1, j, k, ivz)*si(i-&
&         1, j, k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 2) - w(i, j-1, k, &
&         ivz)*sj(i, j-1, k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 2) - w(i&
&         , j, k-1, ivz)*sk(i, j, k-1, 2)
        wwz = w(i+1, j, k, ivz)*si(i, j, k, 3) - w(i-1, j, k, ivz)*si(i-&
&         1, j, k, 3) + w(i, j+1, k, ivz)*sj(i, j, k, 3) - w(i, j-1, k, &
&         ivz)*sj(i, j-1, k, 3) + w(i, j, k+1, ivz)*sk(i, j, k, 3) - w(i&
&         , j, k-1, ivz)*sk(i, j, k-1, 3)
! compute the components of the stress tensor.
! the combination of the current scaling of the velocity
! gradients (2*vol) and the definition of the stress tensor,
! leads to the factor 1/(4*vol).
        fact = fourth/vol(i, j, k)
        if (turbprod .eq. strain) then
          sxx = two*fact*uux
          syy = two*fact*vvy
          szz = two*fact*wwz
          sxy = fact*(uuy+vvx)
          sxz = fact*(uuz+wwx)
          syz = fact*(vvz+wwy)
! compute 2/3 * divergence of velocity squared
          div2 = f23*(sxx+syy+szz)**2
! compute strain production term
          strainmag2 = two*(sxy**2+sxz**2+syz**2) + sxx**2 + syy**2 + &
&           szz**2
          strainprod = two*strainmag2 - div2
          ss = sqrt(strainprod)
          call pushcontrol2b(0)
        else if (turbprod .eq. vorticity) then
! compute the three components of the vorticity vector.
! substract the part coming from the rotating frame.
          vortx = two*fact*(wwy-vvz) - two*omegax
          vorty = two*fact*(uuz-wwx) - two*omegay
          vortz = two*fact*(vvx-uuy) - two*omegaz
! compute the vorticity production term
          vortprod = vortx**2 + vorty**2 + vortz**2
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
! we do this to avoid if statements.
          ss = sqrt(vortprod)
          call pushcontrol2b(1)
        else
          call pushcontrol2b(2)
        end if
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
        nu = rlv(i, j, k)/w(i, j, k, irho)
        dist2inv = one/d2wall(i, j, k)**2
        chi = w(i, j, k, itu1)/nu
        chi2 = chi*chi
        chi3 = chi*chi2
        fv1 = chi3/(chi3+cv13)
        fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
        if (useft2sa) then
          ft2 = rsact3*exp(-(rsact4*chi2))
          call pushcontrol1b(0)
        else
          ft2 = zero
          call pushcontrol1b(1)
        end if
! correct the production term to account for the influence
! of the wall.
        sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
! add rotation term (userotationsa defined in inputparams.f90)
        if (userotationsa) then
          y1 = sqrt(two*strainmag2)
          if (zero .gt. y1) then
            min1 = y1
            call pushcontrol1b(0)
          else
            min1 = zero
            call pushcontrol1b(1)
          end if
          sst = sst + rsacrot*min1
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
        if (sst .lt. xminn) then
          sst = xminn
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          sst = sst
        end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
        rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
        if (rr .gt. 10.0_realtype) then
          rr = 10.0_realtype
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          rr = rr
        end if
        gg = rr + rsacw2*(rr**6-rr)
        gg6 = gg**6
        termfw = ((one+cw36)/(gg6+cw36))**sixth
        fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
        term1 = rsacb1*(one-ft2)*ss
        term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
&         )
        tempd9 = w(i, j, k, itu1)*scratchd(i, j, k, idvt)
        temp2 = w(i, j, k, itu1)
        term1d = tempd9
        term2d = temp2*tempd9
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + (term1+term2*temp2)*&
&         scratchd(i, j, k, idvt) + term2*tempd9
        scratchd(i, j, k, idvt) = 0.0_8
        tempd10 = dist2inv*kar2inv*rsacb1*term2d
        dist2invd = (kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)*&
&         term2d
        ft2d = (1.0_8-fv2)*tempd10 - ss*rsacb1*term1d
        fv2d = (one-ft2)*tempd10
        fwsad = -(dist2inv*rsacw1*term2d)
        ssd = ssd + rsacb1*(one-ft2)*term1d
        termfwd = gg*fwsad
        temp1 = (one+cw36)/(cw36+gg6)
        if (temp1 .le. 0.0_8 .and. (sixth .eq. 0.0_8 .or. sixth .ne. int&
&           (sixth))) then
          gg6d = 0.0
        else
          gg6d = -(sixth*temp1**(sixth-1)*temp1*termfwd/(cw36+gg6))
        end if
        ggd = 6*gg**5*gg6d + termfw*fwsad
        rrd = (rsacw2*6*rr**5-rsacw2+1.0_8)*ggd
        call popcontrol1b(branch)
        if (branch .eq. 0) rrd = 0.0_8
        tempd8 = w(i, j, k, itu1)*kar2inv*rrd/sst
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*dist2inv*rrd/sst
        dist2invd = dist2invd + tempd8
        sstd = -(dist2inv*tempd8/sst)
        call popcontrol1b(branch)
        if (branch .eq. 0) sstd = 0.0_8
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          min1d = rsacrot*sstd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            y1d = min1d
          else
            y1d = 0.0_8
          end if
          if (.not.two*strainmag2 .eq. 0.0_8) strainmag2d = strainmag2d &
&             + two*y1d/(2.0*sqrt(two*strainmag2))
        end if
        tempd7 = kar2inv*w(i, j, k, itu1)*sstd
        ssd = ssd + sstd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*fv2*dist2inv*&
&         sstd
        fv2d = fv2d + dist2inv*tempd7
        dist2invd = dist2invd + fv2*tempd7
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          chi2d = -(exp(-(rsact4*chi2))*rsact3*rsact4*ft2d)
        else
          chi2d = 0.0_8
        end if
        tempd4 = -(fv2d/(one+chi*fv1))
        tempd5 = -(chi*tempd4/(one+chi*fv1))
        fv1d = chi*tempd5
        tempd6 = fv1d/(cv13+chi3)
        chi3d = (1.0_8-chi3/(cv13+chi3))*tempd6
        chi2d = chi2d + chi*chi3d
        chid = chi2*chi3d + 2*chi*chi2d + fv1*tempd5 + tempd4
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + chid/nu
        nud = -(w(i, j, k, itu1)*chid/nu**2)
        temp0 = d2wall(i, j, k)
        d2walld(i, j, k) = d2walld(i, j, k) - one*2*dist2invd/temp0**3
        temp = w(i, j, k, irho)
        rlvd(i, j, k) = rlvd(i, j, k) + nud/temp
        wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp**2
        call popcontrol2b(branch)
        if (branch .eq. 0) then
          if (strainprod .eq. 0.0_8) then
            strainprodd = 0.0
          else
            strainprodd = ssd/(2.0*sqrt(strainprod))
          end if
          strainmag2d = strainmag2d + two*strainprodd
          div2d = -strainprodd
          tempd = two*strainmag2d
          sxyd = 2*sxy*tempd
          sxzd = 2*sxz*tempd
          syzd = 2*syz*tempd
          tempd0 = f23*2*(sxx+syy+szz)*div2d
          sxxd = tempd0 + 2*sxx*strainmag2d
          syyd = tempd0 + 2*syy*strainmag2d
          szzd = tempd0 + 2*szz*strainmag2d
          factd = (uuz+wwx)*sxzd + two*wwz*szzd + two*uux*sxxd + two*vvy&
&           *syyd + (uuy+vvx)*sxyd + (vvz+wwy)*syzd
          vvzd = fact*syzd
          wwyd = fact*syzd
          uuzd = fact*sxzd
          wwxd = fact*sxzd
          uuyd = fact*sxyd
          vvxd = fact*sxyd
          wwzd = two*fact*szzd
          vvyd = two*fact*syyd
          uuxd = two*fact*sxxd
          strainmag2d = 0.0_8
          ssd = 0.0_8
        else
          if (branch .eq. 1) then
            if (vortprod .eq. 0.0_8) then
              vortprodd = 0.0
            else
              vortprodd = ssd/(2.0*sqrt(vortprod))
            end if
            vortxd = 2*vortx*vortprodd
            vortyd = 2*vorty*vortprodd
            vortzd = 2*vortz*vortprodd
            tempd1 = two*vortzd
            vvxd = fact*tempd1
            uuyd = -(fact*tempd1)
            omegazd = omegazd - two*vortzd
            tempd2 = two*vortyd
            uuzd = fact*tempd2
            wwxd = -(fact*tempd2)
            omegayd = omegayd - two*vortyd
            tempd3 = two*vortxd
            factd = (uuz-wwx)*tempd2 + (wwy-vvz)*tempd3 + (vvx-uuy)*&
&             tempd1
            wwyd = fact*tempd3
            vvzd = -(fact*tempd3)
            omegaxd = omegaxd - two*vortxd
            ssd = 0.0_8
          else
            wwxd = 0.0_8
            wwyd = 0.0_8
            vvxd = 0.0_8
            vvzd = 0.0_8
            factd = 0.0_8
            uuyd = 0.0_8
            uuzd = 0.0_8
          end if
          wwzd = 0.0_8
          vvyd = 0.0_8
          uuxd = 0.0_8
        end if
        vold(i, j, k) = vold(i, j, k) - fourth*factd/vol(i, j, k)**2
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + si(i, j, k, 3)*wwzd
        sid(i, j, k, 3) = sid(i, j, k, 3) + w(i+1, j, k, ivz)*wwzd
        wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - si(i-1, j, k, 3)*wwzd
        sid(i-1, j, k, 3) = sid(i-1, j, k, 3) - w(i-1, j, k, ivz)*wwzd
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + sj(i, j, k, 3)*wwzd
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + w(i, j+1, k, ivz)*wwzd
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + sk(i, j, k, 3)*wwzd
        skd(i, j, k, 3) = skd(i, j, k, 3) + w(i, j, k+1, ivz)*wwzd
        wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - sj(i, j-1, k, 3)*wwzd
        sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) - w(i, j-1, k, ivz)*wwzd
        wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - sk(i, j, k-1, 3)*wwzd
        skd(i, j, k-1, 3) = skd(i, j, k-1, 3) - w(i, j, k-1, ivz)*wwzd
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + si(i, j, k, 2)*wwyd
        sid(i, j, k, 2) = sid(i, j, k, 2) + w(i+1, j, k, ivz)*wwyd
        wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - si(i-1, j, k, 2)*wwyd
        sid(i-1, j, k, 2) = sid(i-1, j, k, 2) - w(i-1, j, k, ivz)*wwyd
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + sj(i, j, k, 2)*wwyd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + w(i, j+1, k, ivz)*wwyd
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + sk(i, j, k, 2)*wwyd
        skd(i, j, k, 2) = skd(i, j, k, 2) + w(i, j, k+1, ivz)*wwyd
        wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - sj(i, j-1, k, 2)*wwyd
        sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) - w(i, j-1, k, ivz)*wwyd
        wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - sk(i, j, k-1, 2)*wwyd
        skd(i, j, k-1, 2) = skd(i, j, k-1, 2) - w(i, j, k-1, ivz)*wwyd
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + si(i, j, k, 1)*wwxd
        sid(i, j, k, 1) = sid(i, j, k, 1) + w(i+1, j, k, ivz)*wwxd
        wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - si(i-1, j, k, 1)*wwxd
        sid(i-1, j, k, 1) = sid(i-1, j, k, 1) - w(i-1, j, k, ivz)*wwxd
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + sj(i, j, k, 1)*wwxd
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + w(i, j+1, k, ivz)*wwxd
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + sk(i, j, k, 1)*wwxd
        skd(i, j, k, 1) = skd(i, j, k, 1) + w(i, j, k+1, ivz)*wwxd
        wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - sj(i, j-1, k, 1)*wwxd
        sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) - w(i, j-1, k, ivz)*wwxd
        wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - sk(i, j, k-1, 1)*wwxd
        skd(i, j, k-1, 1) = skd(i, j, k-1, 1) - w(i, j, k-1, ivz)*wwxd
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + si(i, j, k, 3)*vvzd
        sid(i, j, k, 3) = sid(i, j, k, 3) + w(i+1, j, k, ivy)*vvzd
        wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - si(i-1, j, k, 3)*vvzd
        sid(i-1, j, k, 3) = sid(i-1, j, k, 3) - w(i-1, j, k, ivy)*vvzd
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + sj(i, j, k, 3)*vvzd
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + w(i, j+1, k, ivy)*vvzd
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + sk(i, j, k, 3)*vvzd
        skd(i, j, k, 3) = skd(i, j, k, 3) + w(i, j, k+1, ivy)*vvzd
        wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - sj(i, j-1, k, 3)*vvzd
        sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) - w(i, j-1, k, ivy)*vvzd
        wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - sk(i, j, k-1, 3)*vvzd
        skd(i, j, k-1, 3) = skd(i, j, k-1, 3) - w(i, j, k-1, ivy)*vvzd
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + si(i, j, k, 2)*vvyd
        sid(i, j, k, 2) = sid(i, j, k, 2) + w(i+1, j, k, ivy)*vvyd
        wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - si(i-1, j, k, 2)*vvyd
        sid(i-1, j, k, 2) = sid(i-1, j, k, 2) - w(i-1, j, k, ivy)*vvyd
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + sj(i, j, k, 2)*vvyd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + w(i, j+1, k, ivy)*vvyd
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + sk(i, j, k, 2)*vvyd
        skd(i, j, k, 2) = skd(i, j, k, 2) + w(i, j, k+1, ivy)*vvyd
        wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - sj(i, j-1, k, 2)*vvyd
        sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) - w(i, j-1, k, ivy)*vvyd
        wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - sk(i, j, k-1, 2)*vvyd
        skd(i, j, k-1, 2) = skd(i, j, k-1, 2) - w(i, j, k-1, ivy)*vvyd
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + si(i, j, k, 1)*vvxd
        sid(i, j, k, 1) = sid(i, j, k, 1) + w(i+1, j, k, ivy)*vvxd
        wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - si(i-1, j, k, 1)*vvxd
        sid(i-1, j, k, 1) = sid(i-1, j, k, 1) - w(i-1, j, k, ivy)*vvxd
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + sj(i, j, k, 1)*vvxd
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + w(i, j+1, k, ivy)*vvxd
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + sk(i, j, k, 1)*vvxd
        skd(i, j, k, 1) = skd(i, j, k, 1) + w(i, j, k+1, ivy)*vvxd
        wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - sj(i, j-1, k, 1)*vvxd
        sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) - w(i, j-1, k, ivy)*vvxd
        wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - sk(i, j, k-1, 1)*vvxd
        skd(i, j, k-1, 1) = skd(i, j, k-1, 1) - w(i, j, k-1, ivy)*vvxd
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + si(i, j, k, 3)*uuzd
        sid(i, j, k, 3) = sid(i, j, k, 3) + w(i+1, j, k, ivx)*uuzd
        wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - si(i-1, j, k, 3)*uuzd
        sid(i-1, j, k, 3) = sid(i-1, j, k, 3) - w(i-1, j, k, ivx)*uuzd
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + sj(i, j, k, 3)*uuzd
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + w(i, j+1, k, ivx)*uuzd
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + sk(i, j, k, 3)*uuzd
        skd(i, j, k, 3) = skd(i, j, k, 3) + w(i, j, k+1, ivx)*uuzd
        wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - sj(i, j-1, k, 3)*uuzd
        sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) - w(i, j-1, k, ivx)*uuzd
        wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - sk(i, j, k-1, 3)*uuzd
        skd(i, j, k-1, 3) = skd(i, j, k-1, 3) - w(i, j, k-1, ivx)*uuzd
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + si(i, j, k, 2)*uuyd
        sid(i, j, k, 2) = sid(i, j, k, 2) + w(i+1, j, k, ivx)*uuyd
        wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - si(i-1, j, k, 2)*uuyd
        sid(i-1, j, k, 2) = sid(i-1, j, k, 2) - w(i-1, j, k, ivx)*uuyd
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + sj(i, j, k, 2)*uuyd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + w(i, j+1, k, ivx)*uuyd
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + sk(i, j, k, 2)*uuyd
        skd(i, j, k, 2) = skd(i, j, k, 2) + w(i, j, k+1, ivx)*uuyd
        wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - sj(i, j-1, k, 2)*uuyd
        sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) - w(i, j-1, k, ivx)*uuyd
        wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - sk(i, j, k-1, 2)*uuyd
        skd(i, j, k-1, 2) = skd(i, j, k-1, 2) - w(i, j, k-1, ivx)*uuyd
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + si(i, j, k, 1)*uuxd
        sid(i, j, k, 1) = sid(i, j, k, 1) + w(i+1, j, k, ivx)*uuxd
        wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - si(i-1, j, k, 1)*uuxd
        sid(i-1, j, k, 1) = sid(i-1, j, k, 1) - w(i-1, j, k, ivx)*uuxd
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + sj(i, j, k, 1)*uuxd
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + w(i, j+1, k, ivx)*uuxd
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + sk(i, j, k, 1)*uuxd
        skd(i, j, k, 1) = skd(i, j, k, 1) + w(i, j, k+1, ivx)*uuxd
        wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - sj(i, j-1, k, 1)*uuxd
        sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) - w(i, j-1, k, ivx)*uuxd
        wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - sk(i, j, k-1, 1)*uuxd
        skd(i, j, k-1, 1) = skd(i, j, k-1, 1) - w(i, j, k-1, ivx)*uuxd
      end do
      timerefd = timerefd + sections(sectionid)%rotrate(2)*omegayd + &
&       sections(sectionid)%rotrate(1)*omegaxd + sections(sectionid)%&
&       rotrate(3)*omegazd
    end if
  end subroutine sasource_b
  subroutine sasource()
!
!  source terms.                                                  
!  determine the source term and its derivative w.r.t. nutilde    
!  for all internal cells of the block.                           
    use blockpointers
    use constants
    use paramturb
    use section
    use inputphysics
    use flowvarrefstate
    implicit none
! local parameters
    real(kind=realtype), parameter :: f23=two*third
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
    real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
    real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
    real(kind=realtype) :: uux, uuy, uuz, vvx, vvy, vvz, wwx, wwy, wwz
    real(kind=realtype) :: div2, fact, sxx, syy, szz, sxy, sxz, syz
    real(kind=realtype) :: vortx, vorty, vortz
    real(kind=realtype) :: omegax, omegay, omegaz
    real(kind=realtype) :: strainmag2, strainprod, vortprod
    real(kind=realtype), parameter :: xminn=1.e-10_realtype
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic min
    intrinsic max
    real(kind=realtype) :: min1
    real(kind=realtype) :: y1
! set model constants
    cv13 = rsacv1**3
    kar2inv = one/rsak**2
    cw36 = rsacw3**6
    cb3inv = one/rsacb3
! determine the non-dimensional wheel speed of this block.
    omegax = timeref*sections(sectionid)%rotrate(1)
    omegay = timeref*sections(sectionid)%rotrate(2)
    omegaz = timeref*sections(sectionid)%rotrate(3)
! create switches to production term depending on the variable that
! should be used
    if (turbprod .eq. katolaunder) then
      print*, 'katolaunder production term not supported for sa'
      stop
    else
      do ii=0,nx*ny*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 2
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! the gradient is scaled by the factor 2*vol.
        uux = w(i+1, j, k, ivx)*si(i, j, k, 1) - w(i-1, j, k, ivx)*si(i-&
&         1, j, k, 1) + w(i, j+1, k, ivx)*sj(i, j, k, 1) - w(i, j-1, k, &
&         ivx)*sj(i, j-1, k, 1) + w(i, j, k+1, ivx)*sk(i, j, k, 1) - w(i&
&         , j, k-1, ivx)*sk(i, j, k-1, 1)
        uuy = w(i+1, j, k, ivx)*si(i, j, k, 2) - w(i-1, j, k, ivx)*si(i-&
&         1, j, k, 2) + w(i, j+1, k, ivx)*sj(i, j, k, 2) - w(i, j-1, k, &
&         ivx)*sj(i, j-1, k, 2) + w(i, j, k+1, ivx)*sk(i, j, k, 2) - w(i&
&         , j, k-1, ivx)*sk(i, j, k-1, 2)
        uuz = w(i+1, j, k, ivx)*si(i, j, k, 3) - w(i-1, j, k, ivx)*si(i-&
&         1, j, k, 3) + w(i, j+1, k, ivx)*sj(i, j, k, 3) - w(i, j-1, k, &
&         ivx)*sj(i, j-1, k, 3) + w(i, j, k+1, ivx)*sk(i, j, k, 3) - w(i&
&         , j, k-1, ivx)*sk(i, j, k-1, 3)
! idem for the gradient of v.
        vvx = w(i+1, j, k, ivy)*si(i, j, k, 1) - w(i-1, j, k, ivy)*si(i-&
&         1, j, k, 1) + w(i, j+1, k, ivy)*sj(i, j, k, 1) - w(i, j-1, k, &
&         ivy)*sj(i, j-1, k, 1) + w(i, j, k+1, ivy)*sk(i, j, k, 1) - w(i&
&         , j, k-1, ivy)*sk(i, j, k-1, 1)
        vvy = w(i+1, j, k, ivy)*si(i, j, k, 2) - w(i-1, j, k, ivy)*si(i-&
&         1, j, k, 2) + w(i, j+1, k, ivy)*sj(i, j, k, 2) - w(i, j-1, k, &
&         ivy)*sj(i, j-1, k, 2) + w(i, j, k+1, ivy)*sk(i, j, k, 2) - w(i&
&         , j, k-1, ivy)*sk(i, j, k-1, 2)
        vvz = w(i+1, j, k, ivy)*si(i, j, k, 3) - w(i-1, j, k, ivy)*si(i-&
&         1, j, k, 3) + w(i, j+1, k, ivy)*sj(i, j, k, 3) - w(i, j-1, k, &
&         ivy)*sj(i, j-1, k, 3) + w(i, j, k+1, ivy)*sk(i, j, k, 3) - w(i&
&         , j, k-1, ivy)*sk(i, j, k-1, 3)
! and for the gradient of w.
        wwx = w(i+1, j, k, ivz)*si(i, j, k, 1) - w(i-1, j, k, ivz)*si(i-&
&         1, j, k, 1) + w(i, j+1, k, ivz)*sj(i, j, k, 1) - w(i, j-1, k, &
&         ivz)*sj(i, j-1, k, 1) + w(i, j, k+1, ivz)*sk(i, j, k, 1) - w(i&
&         , j, k-1, ivz)*sk(i, j, k-1, 1)
        wwy = w(i+1, j, k, ivz)*si(i, j, k, 2) - w(i-1, j, k, ivz)*si(i-&
&         1, j, k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 2) - w(i, j-1, k, &
&         ivz)*sj(i, j-1, k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 2) - w(i&
&         , j, k-1, ivz)*sk(i, j, k-1, 2)
        wwz = w(i+1, j, k, ivz)*si(i, j, k, 3) - w(i-1, j, k, ivz)*si(i-&
&         1, j, k, 3) + w(i, j+1, k, ivz)*sj(i, j, k, 3) - w(i, j-1, k, &
&         ivz)*sj(i, j-1, k, 3) + w(i, j, k+1, ivz)*sk(i, j, k, 3) - w(i&
&         , j, k-1, ivz)*sk(i, j, k-1, 3)
! compute the components of the stress tensor.
! the combination of the current scaling of the velocity
! gradients (2*vol) and the definition of the stress tensor,
! leads to the factor 1/(4*vol).
        fact = fourth/vol(i, j, k)
        if (turbprod .eq. strain) then
          sxx = two*fact*uux
          syy = two*fact*vvy
          szz = two*fact*wwz
          sxy = fact*(uuy+vvx)
          sxz = fact*(uuz+wwx)
          syz = fact*(vvz+wwy)
! compute 2/3 * divergence of velocity squared
          div2 = f23*(sxx+syy+szz)**2
! compute strain production term
          strainmag2 = two*(sxy**2+sxz**2+syz**2) + sxx**2 + syy**2 + &
&           szz**2
          strainprod = two*strainmag2 - div2
          ss = sqrt(strainprod)
        else if (turbprod .eq. vorticity) then
! compute the three components of the vorticity vector.
! substract the part coming from the rotating frame.
          vortx = two*fact*(wwy-vvz) - two*omegax
          vorty = two*fact*(uuz-wwx) - two*omegay
          vortz = two*fact*(vvx-uuy) - two*omegaz
! compute the vorticity production term
          vortprod = vortx**2 + vorty**2 + vortz**2
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
! we do this to avoid if statements.
          ss = sqrt(vortprod)
        end if
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
        nu = rlv(i, j, k)/w(i, j, k, irho)
        dist2inv = one/d2wall(i, j, k)**2
        chi = w(i, j, k, itu1)/nu
        chi2 = chi*chi
        chi3 = chi*chi2
        fv1 = chi3/(chi3+cv13)
        fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
        if (useft2sa) then
          ft2 = rsact3*exp(-(rsact4*chi2))
        else
          ft2 = zero
        end if
! correct the production term to account for the influence
! of the wall.
        sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
! add rotation term (userotationsa defined in inputparams.f90)
        if (userotationsa) then
          y1 = sqrt(two*strainmag2)
          if (zero .gt. y1) then
            min1 = y1
          else
            min1 = zero
          end if
          sst = sst + rsacrot*min1
        end if
        if (sst .lt. xminn) then
          sst = xminn
        else
          sst = sst
        end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
        rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
        if (rr .gt. 10.0_realtype) then
          rr = 10.0_realtype
        else
          rr = rr
        end if
        gg = rr + rsacw2*(rr**6-rr)
        gg6 = gg**6
        termfw = ((one+cw36)/(gg6+cw36))**sixth
        fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
        term1 = rsacb1*(one-ft2)*ss
        term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
&         )
        scratch(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, &
&         k, itu1)
      end do
    end if
  end subroutine sasource
!  differentiation of saviscous in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *rlv *scratch *vol *si *sj
!                *sk
!   with respect to varying inputs: *w *rlv *scratch *vol *si *sj
!                *sk
!   plus diff mem management of: w:in rlv:in scratch:in vol:in
!                si:in sj:in sk:in
  subroutine saviscous_b()
!
!  viscous term.                                                  
!  determine the viscous contribution to the residual             
!  for all internal cells of the block.                           
    use blockpointers
    use paramturb
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: nu
    real(kind=realtype) :: nud
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: volid, volmid, volpid, xmd, ymd, zmd, xpd, &
&   ypd, zpd
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: xad, yad, zad, ttmd, ttpd, cnudd, camd, capd
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: nutmd, nutpd, numd, nupd, cdmd, cdpd
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    real(kind=realtype) :: c1md, c1pd, c10d
    intrinsic mod
    intrinsic max
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: temp13
    real(kind=realtype) :: temp12
    real(kind=realtype) :: temp11
    real(kind=realtype) :: temp10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd25
    real(kind=realtype) :: tempd24
    real(kind=realtype) :: tempd23
    real(kind=realtype) :: tempd22
    real(kind=realtype) :: tempd21
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp9
    real(kind=realtype) :: temp8
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: temp7
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: temp6
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: temp5
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: temp4
    real(kind=realtype) :: tempd15
! set model constants
    cb3inv = one/rsacb3
    call pushinteger4(i)
    call pushreal8(c10)
    call pushinteger4(j)
    call pushinteger4(k)
    call pushreal8(xa)
    call pushreal8(xm)
    call pushreal8(xp)
    call pushreal8(volpi)
    call pushreal8(num)
    call pushreal8(cnud)
    call pushreal8(ya)
    call pushreal8(nup)
    call pushreal8(volmi)
    call pushreal8(nutm)
    call pushreal8(nutp)
    call pushreal8(ym)
    call pushreal8(voli)
    call pushreal8(yp)
    call pushreal8(c1m)
    call pushreal8(c1p)
    call pushreal8(za)
    call pushreal8(ttm)
    call pushreal8(ttp)
    call pushreal8(zm)
    call pushreal8(zp)
    call pushinteger4(i)
    call pushreal8(c10)
    call pushinteger4(j)
    call pushinteger4(k)
    call pushreal8(xa)
    call pushreal8(xm)
    call pushreal8(xp)
    call pushreal8(volpi)
    call pushreal8(num)
    call pushreal8(cnud)
    call pushreal8(ya)
    call pushreal8(nup)
    call pushreal8(volmi)
    call pushreal8(nutm)
    call pushreal8(nutp)
    call pushreal8(ym)
    call pushreal8(voli)
    call pushreal8(yp)
    call pushreal8(c1m)
    call pushreal8(c1p)
    call pushreal8(za)
    call pushreal8(ttm)
    call pushreal8(ttp)
    call pushreal8(zm)
    call pushreal8(zp)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
      nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
        call pushcontrol1b(0)
      else
        c1m = cdm + cam
        call pushcontrol1b(1)
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
        call pushcontrol1b(0)
      else
        c1p = cdp + cap
        call pushcontrol1b(1)
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i-1, j, k, itu1)*scratchd(i, j, k, idvt)
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i+1, j, k, itu1)*scratchd(i, j, k, idvt)
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd17 = cb3inv*cdpd
      nupd = ttp*tempd17
      nutpd = ttp*(one+rsacb2)*tempd17
      ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd17
      tempd18 = cb3inv*cdmd
      numd = ttm*tempd18
      nutmd = ttm*(one+rsacb2)*tempd18
      ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd18
      temp13 = w(i+1, j, k, irho)
      tempd19 = half*nupd/temp13
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + tempd19
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - rlv(i+1, j, k)*tempd19&
&       /temp13
      nud = half*numd + half*nupd
      temp12 = w(i-1, j, k, irho)
      tempd20 = half*numd/temp12
      rlvd(i-1, j, k) = rlvd(i-1, j, k) + tempd20
      wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - rlv(i-1, j, k)*tempd20&
&       /temp12
      temp11 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp11
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp11**2
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd21 = half*zad
      sid(i, j, k, 3) = sid(i, j, k, 3) + voli*tempd21
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*tempd21
      tempd22 = half*yad
      sid(i, j, k, 2) = sid(i, j, k, 2) + voli*tempd22
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*tempd22
      tempd23 = half*xad
      volid = (si(i, j, k, 2)+si(i-1, j, k, 2))*tempd22 + (si(i, j, k, 1&
&       )+si(i-1, j, k, 1))*tempd23 + (si(i, j, k, 3)+si(i-1, j, k, 3))*&
&       tempd21
      sid(i, j, k, 1) = sid(i, j, k, 1) + voli*tempd23
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*tempd23
      sid(i, j, k, 3) = sid(i, j, k, 3) + volpi*zpd
      volpid = si(i, j, k, 2)*ypd + si(i, j, k, 1)*xpd + si(i, j, k, 3)*&
&       zpd
      sid(i, j, k, 2) = sid(i, j, k, 2) + volpi*ypd
      sid(i, j, k, 1) = sid(i, j, k, 1) + volpi*xpd
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + volmi*zmd
      volmid = si(i-1, j, k, 2)*ymd + si(i-1, j, k, 1)*xmd + si(i-1, j, &
&       k, 3)*zmd
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + volmi*ymd
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + volmi*xmd
      temp10 = vol(i, j, k) + vol(i+1, j, k)
      tempd24 = -(two*volpid/temp10**2)
      vold(i, j, k) = vold(i, j, k) + tempd24
      vold(i+1, j, k) = vold(i+1, j, k) + tempd24
      temp9 = vol(i, j, k) + vol(i-1, j, k)
      tempd25 = -(two*volmid/temp9**2)
      vold(i, j, k) = vold(i, j, k) + tempd25
      vold(i-1, j, k) = vold(i-1, j, k) + tempd25
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
    call popreal8(zp)
    call popreal8(zm)
    call popreal8(ttp)
    call popreal8(ttm)
    call popreal8(za)
    call popreal8(c1p)
    call popreal8(c1m)
    call popreal8(yp)
    call popreal8(voli)
    call popreal8(ym)
    call popreal8(nutp)
    call popreal8(nutm)
    call popreal8(volmi)
    call popreal8(nup)
    call popreal8(ya)
    call popreal8(cnud)
    call popreal8(num)
    call popreal8(volpi)
    call popreal8(xp)
    call popreal8(xm)
    call popreal8(xa)
    call popinteger4(k)
    call popinteger4(j)
    call popreal8(c10)
    call popinteger4(i)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
      nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
        call pushcontrol1b(0)
      else
        c1m = cdm + cam
        call pushcontrol1b(1)
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
        call pushcontrol1b(0)
      else
        c1p = cdp + cap
        call pushcontrol1b(1)
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i, j-1, k, itu1)*scratchd(i, j, k, idvt)
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j+1, k, itu1)*scratchd(i, j, k, idvt)
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd8 = cb3inv*cdpd
      nupd = ttp*tempd8
      nutpd = ttp*(one+rsacb2)*tempd8
      ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd8
      tempd9 = cb3inv*cdmd
      numd = ttm*tempd9
      nutmd = ttm*(one+rsacb2)*tempd9
      ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd9
      temp8 = w(i, j+1, k, irho)
      tempd10 = half*nupd/temp8
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + tempd10
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - rlv(i, j+1, k)*tempd10&
&       /temp8
      nud = half*numd + half*nupd
      temp7 = w(i, j-1, k, irho)
      tempd11 = half*numd/temp7
      rlvd(i, j-1, k) = rlvd(i, j-1, k) + tempd11
      wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - rlv(i, j-1, k)*tempd11&
&       /temp7
      temp6 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp6
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp6**2
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd12 = half*zad
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*tempd12
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*tempd12
      tempd13 = half*yad
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*tempd13
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*tempd13
      tempd14 = half*xad
      volid = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempd13 + (sj(i, j, k, 1&
&       )+sj(i, j-1, k, 1))*tempd14 + (sj(i, j, k, 3)+sj(i, j-1, k, 3))*&
&       tempd12
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*tempd14
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*tempd14
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + volpi*zpd
      volpid = sj(i, j, k, 2)*ypd + sj(i, j, k, 1)*xpd + sj(i, j, k, 3)*&
&       zpd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + volpi*ypd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + volpi*xpd
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + volmi*zmd
      volmid = sj(i, j-1, k, 2)*ymd + sj(i, j-1, k, 1)*xmd + sj(i, j-1, &
&       k, 3)*zmd
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + volmi*ymd
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + volmi*xmd
      temp5 = vol(i, j, k) + vol(i, j+1, k)
      tempd15 = -(two*volpid/temp5**2)
      vold(i, j, k) = vold(i, j, k) + tempd15
      vold(i, j+1, k) = vold(i, j+1, k) + tempd15
      temp4 = vol(i, j, k) + vol(i, j-1, k)
      tempd16 = -(two*volmid/temp4**2)
      vold(i, j, k) = vold(i, j, k) + tempd16
      vold(i, j-1, k) = vold(i, j-1, k) + tempd16
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
    call popreal8(zp)
    call popreal8(zm)
    call popreal8(ttp)
    call popreal8(ttm)
    call popreal8(za)
    call popreal8(c1p)
    call popreal8(c1m)
    call popreal8(yp)
    call popreal8(voli)
    call popreal8(ym)
    call popreal8(nutp)
    call popreal8(nutm)
    call popreal8(volmi)
    call popreal8(nup)
    call popreal8(ya)
    call popreal8(cnud)
    call popreal8(num)
    call popreal8(volpi)
    call popreal8(xp)
    call popreal8(xm)
    call popreal8(xa)
    call popinteger4(k)
    call popinteger4(j)
    call popreal8(c10)
    call popinteger4(i)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
      nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
        call pushcontrol1b(0)
      else
        c1m = cdm + cam
        call pushcontrol1b(1)
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
        call pushcontrol1b(0)
      else
        c1p = cdp + cap
        call pushcontrol1b(1)
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i, j, k-1, itu1)*scratchd(i, j, k, idvt)
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j, k+1, itu1)*scratchd(i, j, k, idvt)
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd = cb3inv*cdpd
      nupd = ttp*tempd
      nutpd = ttp*(one+rsacb2)*tempd
      ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd
      tempd0 = cb3inv*cdmd
      numd = ttm*tempd0
      nutmd = ttm*(one+rsacb2)*tempd0
      ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd0
      temp3 = w(i, j, k+1, irho)
      tempd1 = half*nupd/temp3
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + tempd1
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - rlv(i, j, k+1)*tempd1/&
&       temp3
      nud = half*numd + half*nupd
      temp2 = w(i, j, k-1, irho)
      tempd2 = half*numd/temp2
      rlvd(i, j, k-1) = rlvd(i, j, k-1) + tempd2
      wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - rlv(i, j, k-1)*tempd2/&
&       temp2
      temp1 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp1
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp1**2
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd3 = half*zad
      skd(i, j, k, 3) = skd(i, j, k, 3) + voli*tempd3
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*tempd3
      tempd4 = half*yad
      skd(i, j, k, 2) = skd(i, j, k, 2) + voli*tempd4
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*tempd4
      tempd5 = half*xad
      volid = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempd4 + (sk(i, j, k, 1)&
&       +sk(i, j, k-1, 1))*tempd5 + (sk(i, j, k, 3)+sk(i, j, k-1, 3))*&
&       tempd3
      skd(i, j, k, 1) = skd(i, j, k, 1) + voli*tempd5
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*tempd5
      skd(i, j, k, 3) = skd(i, j, k, 3) + volpi*zpd
      volpid = sk(i, j, k, 2)*ypd + sk(i, j, k, 1)*xpd + sk(i, j, k, 3)*&
&       zpd
      skd(i, j, k, 2) = skd(i, j, k, 2) + volpi*ypd
      skd(i, j, k, 1) = skd(i, j, k, 1) + volpi*xpd
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + volmi*zmd
      volmid = sk(i, j, k-1, 2)*ymd + sk(i, j, k-1, 1)*xmd + sk(i, j, k-&
&       1, 3)*zmd
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + volmi*ymd
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + volmi*xmd
      temp0 = vol(i, j, k) + vol(i, j, k+1)
      tempd6 = -(two*volpid/temp0**2)
      vold(i, j, k) = vold(i, j, k) + tempd6
      vold(i, j, k+1) = vold(i, j, k+1) + tempd6
      temp = vol(i, j, k) + vol(i, j, k-1)
      tempd7 = -(two*volmid/temp**2)
      vold(i, j, k) = vold(i, j, k) + tempd7
      vold(i, j, k-1) = vold(i, j, k-1) + tempd7
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
  end subroutine saviscous_b
  subroutine saviscous()
!
!  viscous term.                                                  
!  determine the viscous contribution to the residual             
!  for all internal cells of the block.                           
    use blockpointers
    use paramturb
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: nu
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    intrinsic mod
    intrinsic max
! set model constants
    cv13 = rsacv1**3
    kar2inv = one/rsak**2
    cw36 = rsacw3**6
    cb3inv = one/rsacb3
!
!       viscous terms in k-direction.                                  
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
      nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j, k-1&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
    end do
!
!       viscous terms in j-direction.                                  
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
      nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j-1, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
    end do
!
!       viscous terms in i-direction.                                  
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
      nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i-1, j, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
    end do
  end subroutine saviscous
!  differentiation of saresscale in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw *vol
!   with respect to varying inputs: *dw *scratch *vol
!   plus diff mem management of: dw:in scratch:in vol:in
  subroutine saresscale_b()
!
!  multiply the residual by the volume and store this in dw; this 
! * is done for monitoring reasons only. the multiplication with the
! * volume is present to be consistent with the flow residuals; also
!  the negative value is taken, again to be consistent with the   
! * flow equations. also multiply by iblank so that no updates occur
!  in holes or the overset boundary.                              
    use blockpointers
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    scratchd = 0.0_8
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      x1 = real(iblank(i, j, k), realtype)
      if (x1 .lt. zero) then
        rblank = zero
      else
        rblank = x1
      end if
      vold(i, j, k) = vold(i, j, k) - rblank*scratch(i, j, k, idvt)*dwd(&
&       i, j, k, itu1)
      scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) - rblank*vol(i, &
&       j, k)*dwd(i, j, k, itu1)
      dwd(i, j, k, itu1) = 0.0_8
    end do
  end subroutine saresscale_b
  subroutine saresscale()
!
!  multiply the residual by the volume and store this in dw; this 
! * is done for monitoring reasons only. the multiplication with the
! * volume is present to be consistent with the flow residuals; also
!  the negative value is taken, again to be consistent with the   
! * flow equations. also multiply by iblank so that no updates occur
!  in holes or the overset boundary.                              
    use blockpointers
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      x1 = real(iblank(i, j, k), realtype)
      if (x1 .lt. zero) then
        rblank = zero
      else
        rblank = x1
      end if
      dw(i, j, k, itu1) = -(vol(i, j, k)*scratch(i, j, k, idvt)*rblank)
    end do
  end subroutine saresscale
end module sa_b

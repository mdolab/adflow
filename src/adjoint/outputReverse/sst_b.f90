!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module sst_b
! this module contains the source code related to the sst turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier.
  use constants
  implicit none
  real(kind=realtype), dimension(:, :, :, :, :), allocatable :: qq

contains
!  differentiation of sstsource in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *scratch
!   with respect to varying inputs: *w *scratch
!   rw status of diff variables: *w:incr *scratch:in-out
!   plus diff mem management of: w:in scratch:in
  subroutine sstsource_b()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use paramturb
    implicit none
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rsstgamd, rsstbetad
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: rhoid, ssd, spkd, sdkd
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic mod
    intrinsic min
    real(kind=realtype) :: tmp
    integer :: branch
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tmpd
    integer :: ii
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
! set model constants
    rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/sqrt(&
&     rsstbetas)
    rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/sqrt(&
&     rsstbetas)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstgam = t1*rsstgam1 + t2*rsstgam2
      rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
      rhoi = one/w(i, j, k, irho)
      ss = scratch(i, j, k, iprod)
      spk = rev(i, j, k)*ss*rhoi
      sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
      if (spk .gt. pklim*sdk) then
        spk = pklim*sdk
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        spk = spk
      end if
      scratch(i, j, k, idvt+0) = spk - sdk
      tmpd = scratchd(i, j, k, idvt+1)
      scratchd(i, j, k, idvt+1) = 0.0_8
      tempd0 = two*rsstsigw2*tmpd
      temp0 = w(i, j, k, itu2)
      rsstgamd = ss*tmpd
      ssd = rsstgam*tmpd
      t2d = scratch(i, j, k, icd)*tempd0
      scratchd(i, j, k, icd) = scratchd(i, j, k, icd) + t2*tempd0
      rsstbetad = -(temp0**2*tmpd)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - rsstbeta*2*temp0*tmpd
      spkd = scratchd(i, j, k, idvt+0)
      sdkd = -scratchd(i, j, k, idvt+0)
      scratchd(i, j, k, idvt+0) = 0.0_8
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        sdkd = sdkd + pklim*spkd
        spkd = 0.0_8
      end if
      t2d = t2d + rsstgam2*rsstgamd + rsstbeta2*rsstbetad
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + rsstbetas*w(i, j, k, itu2)&
&       *sdkd
      wd(i, j, k, itu2) = wd(i, j, k, itu2) + rsstbetas*w(i, j, k, itu1)&
&       *sdkd
      tempd = rev(i, j, k)*spkd
      ssd = ssd + rhoi*tempd
      rhoid = ss*tempd
      scratchd(i, j, k, iprod) = scratchd(i, j, k, iprod) + ssd
      temp = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp**2
      t1d = rsstgam1*rsstgamd - t2d + rsstbeta1*rsstbetad
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
    end do
  end subroutine sstsource_b
  subroutine sstsource()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use inputphysics
    use paramturb
    implicit none
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    intrinsic sqrt
    intrinsic mod
    intrinsic min
    integer :: ii
! set model constants
    rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/sqrt(&
&     rsstbetas)
    rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/sqrt(&
&     rsstbetas)
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstgam = t1*rsstgam1 + t2*rsstgam2
      rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
      rhoi = one/w(i, j, k, irho)
      ss = scratch(i, j, k, iprod)
      spk = rev(i, j, k)*ss*rhoi
      sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
      if (spk .gt. pklim*sdk) then
        spk = pklim*sdk
      else
        spk = spk
      end if
      scratch(i, j, k, idvt+0) = spk - sdk
      scratch(i, j, k, idvt+1) = rsstgam*ss + two*t2*rsstsigw2*scratch(i&
&       , j, k, icd) - rsstbeta*w(i, j, k, itu2)**2
    end do
  end subroutine sstsource
!  differentiation of sstviscous in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *rlv *scratch *vol *si *sj
!                *sk
!   with respect to varying inputs: *w *rlv *scratch *vol *si *sj
!                *sk
!   rw status of diff variables: *w:incr *rlv:incr *scratch:in-out
!                *vol:incr *si:incr *sj:incr *sk:incr
!   plus diff mem management of: w:in rlv:in scratch:in vol:in
!                si:in sj:in sk:in
  subroutine sstviscous_b()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigkp1d, rsstsigkd, rsstsigkm1d
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: rsstsigwp1d, rsstsigwd, rsstsigwm1d
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
    intrinsic mod
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd25
    real(kind=realtype) :: tempd24
    real(kind=realtype) :: tempd23
    real(kind=realtype) :: tempd22
    real(kind=realtype) :: tempd21
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: temp7
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: temp6
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp4
    real(kind=realtype) :: tempd15
    call pushreal8array(scratch, size(scratch, 1)*size(scratch, 2)*size(&
&                 scratch, 3)*size(scratch, 4))
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
      t1 = scratch(i, j, k+1, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k-1, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i, j, &
&       k-1, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j, &
&       k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, itu2)
    end do
    call pushinteger4(i)
    call pushreal8(c10)
    call pushinteger4(j)
    call pushreal8(c1m)
    call pushreal8(c1p)
    call pushreal8(muem)
    call pushreal8(muep)
    call pushreal8array(scratch, size(scratch, 1)*size(scratch, 2)*size(&
&                 scratch, 3)*size(scratch, 4))
!
!       viscous terms in j-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
      t1 = scratch(i, j+1, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j-1, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i, j-1&
&       , k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j-1&
&       , k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, itu2)
    end do
    call pushinteger4(i)
    call pushreal8(c10)
    call pushinteger4(j)
    call pushreal8(c1m)
    call pushreal8(c1p)
    call pushreal8(muem)
    call pushreal8(muep)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
      t1 = scratch(i+1, j, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i-1, j, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
      mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      call pushreal8(muem)
      muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
      call pushreal8(muep)
      muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      c2md = w(i-1, j, k, itu2)*scratchd(i, j, k, idvt+1)
      wd(i-1, j, k, itu2) = wd(i-1, j, k, itu2) + c2m*scratchd(i, j, k, &
&       idvt+1)
      c2pd = w(i+1, j, k, itu2)*scratchd(i, j, k, idvt+1)
      wd(i+1, j, k, itu2) = wd(i+1, j, k, itu2) + c2p*scratchd(i, j, k, &
&       idvt+1)
      c20d = -(w(i, j, k, itu2)*scratchd(i, j, k, idvt+1))
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - c20*scratchd(i, j, k, idvt&
&       +1)
      c1md = w(i-1, j, k, itu1)*scratchd(i, j, k, idvt+0)
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt+0)
      c1pd = w(i+1, j, k, itu1)*scratchd(i, j, k, idvt+0)
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt+0)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt+0))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       +0)
      c2md = c2md + c20d
      c2pd = c2pd + c20d
      tempd17 = ttp*rhoi*c2pd
      muepd = tempd17
      ttpd = (mulp+muep)*rhoi*c2pd
      rhoid = (mulm+muem)*ttm*c2md + (mulp+muep)*ttp*c2pd
      tempd19 = ttm*rhoi*c2md
      muemd = tempd19
      ttmd = (mulm+muem)*rhoi*c2md
      call popreal8(muep)
      rsstsigwp1d = half*rev(i+1, j, k)*muepd
      rsstsigwd = half*rev(i, j, k)*muemd + half*rev(i, j, k)*muepd
      call popreal8(muem)
      rsstsigwm1d = half*rev(i-1, j, k)*muemd
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      tempd18 = ttp*rhoi*c1pd
      mulpd = tempd18 + tempd17
      muepd = tempd18
      ttpd = ttpd + (mulp+muep)*rhoi*c1pd
      rhoid = rhoid + (mulm+muem)*ttm*c1md + (mulp+muep)*ttp*c1pd
      tempd20 = ttm*rhoi*c1md
      mulmd = tempd20 + tempd19
      muemd = tempd20
      ttmd = ttmd + (mulm+muem)*rhoi*c1md
      rsstsigkp1d = half*rev(i+1, j, k)*muepd
      rsstsigkd = half*rev(i, j, k)*muemd + half*rev(i, j, k)*muepd
      rsstsigkm1d = half*rev(i-1, j, k)*muemd
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd
      rlvd(i-1, j, k) = rlvd(i-1, j, k) + half*mulmd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulmd
      temp7 = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp7**2
      t2d = rsstsigk2*rsstsigkm1d + rsstsigw2*rsstsigwm1d
      t1d = rsstsigk1*rsstsigkm1d - t2d + rsstsigw1*rsstsigwm1d
      scratchd(i-1, j, k, if1sst) = scratchd(i-1, j, k, if1sst) + t1d
      t2d = rsstsigk2*rsstsigkd + rsstsigw2*rsstsigwd
      t1d = rsstsigk1*rsstsigkd - t2d + rsstsigw1*rsstsigwd
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
      t2d = rsstsigk2*rsstsigkp1d + rsstsigw2*rsstsigwp1d
      t1d = rsstsigk1*rsstsigkp1d - t2d + rsstsigw1*rsstsigwp1d
      scratchd(i+1, j, k, if1sst) = scratchd(i+1, j, k, if1sst) + t1d
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd21 = half*zad
      sid(i, j, k, 3) = sid(i, j, k, 3) + voli*tempd21
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*tempd21
      tempd22 = half*yad
      sid(i, j, k, 2) = sid(i, j, k, 2) + voli*tempd22
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*tempd22
      tempd23 = half*xad
      volid = (si(i, j, k, 2)+si(i-1, j, k, 2))*tempd22 + (si(i, j, k, 1&
&       )+si(i-1, j, k, 1))*tempd23 + (si(i, j, k, 3)+si(i-1, j, k, 3))*&
&       tempd21
      sid(i, j, k, 1) = sid(i, j, k, 1) + voli*tempd23
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*tempd23
      sid(i, j, k, 3) = sid(i, j, k, 3) + volpi*zpd
      volpid = si(i, j, k, 2)*ypd + si(i, j, k, 1)*xpd + si(i, j, k, 3)*&
&       zpd
      sid(i, j, k, 2) = sid(i, j, k, 2) + volpi*ypd
      sid(i, j, k, 1) = sid(i, j, k, 1) + volpi*xpd
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + volmi*zmd
      volmid = si(i-1, j, k, 2)*ymd + si(i-1, j, k, 1)*xmd + si(i-1, j, &
&       k, 3)*zmd
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + volmi*ymd
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + volmi*xmd
      temp6 = vol(i, j, k) + vol(i+1, j, k)
      tempd24 = -(two*volpid/temp6**2)
      vold(i, j, k) = vold(i, j, k) + tempd24
      vold(i+1, j, k) = vold(i+1, j, k) + tempd24
      temp5 = vol(i, j, k) + vol(i-1, j, k)
      tempd25 = -(two*volmid/temp5**2)
      vold(i, j, k) = vold(i, j, k) + tempd25
      vold(i-1, j, k) = vold(i-1, j, k) + tempd25
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
    call popreal8(muep)
    call popreal8(muem)
    call popreal8(c1p)
    call popreal8(c1m)
    call popinteger4(j)
    call popreal8(c10)
    call popinteger4(i)
    call popreal8array(scratch, size(scratch, 1)*size(scratch, 2)*size(&
&                scratch, 3)*size(scratch, 4))
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
      t1 = scratch(i, j+1, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j-1, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      call pushreal8(muem)
      muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
      call pushreal8(muep)
      muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      c2md = w(i, j-1, k, itu2)*scratchd(i, j, k, idvt+1)
      wd(i, j-1, k, itu2) = wd(i, j-1, k, itu2) + c2m*scratchd(i, j, k, &
&       idvt+1)
      c2pd = w(i, j+1, k, itu2)*scratchd(i, j, k, idvt+1)
      wd(i, j+1, k, itu2) = wd(i, j+1, k, itu2) + c2p*scratchd(i, j, k, &
&       idvt+1)
      c20d = -(w(i, j, k, itu2)*scratchd(i, j, k, idvt+1))
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - c20*scratchd(i, j, k, idvt&
&       +1)
      c1md = w(i, j-1, k, itu1)*scratchd(i, j, k, idvt+0)
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt+0)
      c1pd = w(i, j+1, k, itu1)*scratchd(i, j, k, idvt+0)
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt+0)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt+0))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       +0)
      c2md = c2md + c20d
      c2pd = c2pd + c20d
      tempd8 = ttp*rhoi*c2pd
      muepd = tempd8
      ttpd = (mulp+muep)*rhoi*c2pd
      rhoid = (mulm+muem)*ttm*c2md + (mulp+muep)*ttp*c2pd
      tempd10 = ttm*rhoi*c2md
      muemd = tempd10
      ttmd = (mulm+muem)*rhoi*c2md
      call popreal8(muep)
      rsstsigwp1d = half*rev(i, j+1, k)*muepd
      rsstsigwd = half*rev(i, j, k)*muemd + half*rev(i, j, k)*muepd
      call popreal8(muem)
      rsstsigwm1d = half*rev(i, j-1, k)*muemd
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      tempd9 = ttp*rhoi*c1pd
      mulpd = tempd9 + tempd8
      muepd = tempd9
      ttpd = ttpd + (mulp+muep)*rhoi*c1pd
      rhoid = rhoid + (mulm+muem)*ttm*c1md + (mulp+muep)*ttp*c1pd
      tempd11 = ttm*rhoi*c1md
      mulmd = tempd11 + tempd10
      muemd = tempd11
      ttmd = ttmd + (mulm+muem)*rhoi*c1md
      rsstsigkp1d = half*rev(i, j+1, k)*muepd
      rsstsigkd = half*rev(i, j, k)*muemd + half*rev(i, j, k)*muepd
      rsstsigkm1d = half*rev(i, j-1, k)*muemd
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd
      rlvd(i, j-1, k) = rlvd(i, j-1, k) + half*mulmd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulmd
      temp4 = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp4**2
      t2d = rsstsigk2*rsstsigkm1d + rsstsigw2*rsstsigwm1d
      t1d = rsstsigk1*rsstsigkm1d - t2d + rsstsigw1*rsstsigwm1d
      scratchd(i, j-1, k, if1sst) = scratchd(i, j-1, k, if1sst) + t1d
      t2d = rsstsigk2*rsstsigkd + rsstsigw2*rsstsigwd
      t1d = rsstsigk1*rsstsigkd - t2d + rsstsigw1*rsstsigwd
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
      t2d = rsstsigk2*rsstsigkp1d + rsstsigw2*rsstsigwp1d
      t1d = rsstsigk1*rsstsigkp1d - t2d + rsstsigw1*rsstsigwp1d
      scratchd(i, j+1, k, if1sst) = scratchd(i, j+1, k, if1sst) + t1d
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd12 = half*zad
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*tempd12
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*tempd12
      tempd13 = half*yad
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*tempd13
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*tempd13
      tempd14 = half*xad
      volid = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempd13 + (sj(i, j, k, 1&
&       )+sj(i, j-1, k, 1))*tempd14 + (sj(i, j, k, 3)+sj(i, j-1, k, 3))*&
&       tempd12
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*tempd14
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*tempd14
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + volpi*zpd
      volpid = sj(i, j, k, 2)*ypd + sj(i, j, k, 1)*xpd + sj(i, j, k, 3)*&
&       zpd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + volpi*ypd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + volpi*xpd
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + volmi*zmd
      volmid = sj(i, j-1, k, 2)*ymd + sj(i, j-1, k, 1)*xmd + sj(i, j-1, &
&       k, 3)*zmd
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + volmi*ymd
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + volmi*xmd
      temp3 = vol(i, j, k) + vol(i, j+1, k)
      tempd15 = -(two*volpid/temp3**2)
      vold(i, j, k) = vold(i, j, k) + tempd15
      vold(i, j+1, k) = vold(i, j+1, k) + tempd15
      temp2 = vol(i, j, k) + vol(i, j-1, k)
      tempd16 = -(two*volmid/temp2**2)
      vold(i, j, k) = vold(i, j, k) + tempd16
      vold(i, j-1, k) = vold(i, j-1, k) + tempd16
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
    call popreal8(muep)
    call popreal8(muem)
    call popreal8(c1p)
    call popreal8(c1m)
    call popinteger4(j)
    call popreal8(c10)
    call popinteger4(i)
    call popreal8array(scratch, size(scratch, 1)*size(scratch, 2)*size(&
&                scratch, 3)*size(scratch, 4))
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
      t1 = scratch(i, j, k+1, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k-1, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      call pushreal8(muem)
      muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
      call pushreal8(muep)
      muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      c2md = w(i, j, k-1, itu2)*scratchd(i, j, k, idvt+1)
      wd(i, j, k-1, itu2) = wd(i, j, k-1, itu2) + c2m*scratchd(i, j, k, &
&       idvt+1)
      c2pd = w(i, j, k+1, itu2)*scratchd(i, j, k, idvt+1)
      wd(i, j, k+1, itu2) = wd(i, j, k+1, itu2) + c2p*scratchd(i, j, k, &
&       idvt+1)
      c20d = -(w(i, j, k, itu2)*scratchd(i, j, k, idvt+1))
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - c20*scratchd(i, j, k, idvt&
&       +1)
      c1md = w(i, j, k-1, itu1)*scratchd(i, j, k, idvt+0)
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + c1m*scratchd(i, j, k, &
&       idvt+0)
      c1pd = w(i, j, k+1, itu1)*scratchd(i, j, k, idvt+0)
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + c1p*scratchd(i, j, k, &
&       idvt+0)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt+0))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       +0)
      c2md = c2md + c20d
      c2pd = c2pd + c20d
      tempd = ttp*rhoi*c2pd
      muepd = tempd
      ttpd = (mulp+muep)*rhoi*c2pd
      rhoid = (mulm+muem)*ttm*c2md + (mulp+muep)*ttp*c2pd
      tempd1 = ttm*rhoi*c2md
      muemd = tempd1
      ttmd = (mulm+muem)*rhoi*c2md
      call popreal8(muep)
      rsstsigwp1d = half*rev(i, j, k+1)*muepd
      rsstsigwd = half*rev(i, j, k)*muemd + half*rev(i, j, k)*muepd
      call popreal8(muem)
      rsstsigwm1d = half*rev(i, j, k-1)*muemd
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      tempd0 = ttp*rhoi*c1pd
      mulpd = tempd0 + tempd
      muepd = tempd0
      ttpd = ttpd + (mulp+muep)*rhoi*c1pd
      rhoid = rhoid + (mulm+muem)*ttm*c1md + (mulp+muep)*ttp*c1pd
      tempd2 = ttm*rhoi*c1md
      mulmd = tempd2 + tempd1
      muemd = tempd2
      ttmd = ttmd + (mulm+muem)*rhoi*c1md
      rsstsigkp1d = half*rev(i, j, k+1)*muepd
      rsstsigkd = half*rev(i, j, k)*muemd + half*rev(i, j, k)*muepd
      rsstsigkm1d = half*rev(i, j, k-1)*muemd
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd
      rlvd(i, j, k-1) = rlvd(i, j, k-1) + half*mulmd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulmd
      temp1 = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp1**2
      t2d = rsstsigk2*rsstsigkm1d + rsstsigw2*rsstsigwm1d
      t1d = rsstsigk1*rsstsigkm1d - t2d + rsstsigw1*rsstsigwm1d
      scratchd(i, j, k-1, if1sst) = scratchd(i, j, k-1, if1sst) + t1d
      t2d = rsstsigk2*rsstsigkd + rsstsigw2*rsstsigwd
      t1d = rsstsigk1*rsstsigkd - t2d + rsstsigw1*rsstsigwd
      scratchd(i, j, k, if1sst) = scratchd(i, j, k, if1sst) + t1d
      t2d = rsstsigk2*rsstsigkp1d + rsstsigw2*rsstsigwp1d
      t1d = rsstsigk1*rsstsigkp1d - t2d + rsstsigw1*rsstsigwp1d
      scratchd(i, j, k+1, if1sst) = scratchd(i, j, k+1, if1sst) + t1d
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd3 = half*zad
      skd(i, j, k, 3) = skd(i, j, k, 3) + voli*tempd3
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*tempd3
      tempd4 = half*yad
      skd(i, j, k, 2) = skd(i, j, k, 2) + voli*tempd4
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*tempd4
      tempd5 = half*xad
      volid = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempd4 + (sk(i, j, k, 1)&
&       +sk(i, j, k-1, 1))*tempd5 + (sk(i, j, k, 3)+sk(i, j, k-1, 3))*&
&       tempd3
      skd(i, j, k, 1) = skd(i, j, k, 1) + voli*tempd5
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*tempd5
      skd(i, j, k, 3) = skd(i, j, k, 3) + volpi*zpd
      volpid = sk(i, j, k, 2)*ypd + sk(i, j, k, 1)*xpd + sk(i, j, k, 3)*&
&       zpd
      skd(i, j, k, 2) = skd(i, j, k, 2) + volpi*ypd
      skd(i, j, k, 1) = skd(i, j, k, 1) + volpi*xpd
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + volmi*zmd
      volmid = sk(i, j, k-1, 2)*ymd + sk(i, j, k-1, 1)*xmd + sk(i, j, k-&
&       1, 3)*zmd
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + volmi*ymd
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + volmi*xmd
      temp0 = vol(i, j, k) + vol(i, j, k+1)
      tempd6 = -(two*volpid/temp0**2)
      vold(i, j, k) = vold(i, j, k) + tempd6
      vold(i, j, k+1) = vold(i, j, k+1) + tempd6
      temp = vol(i, j, k) + vol(i, j, k-1)
      tempd7 = -(two*volmid/temp**2)
      vold(i, j, k) = vold(i, j, k) + tempd7
      vold(i, j, k-1) = vold(i, j, k-1) + tempd7
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
  end subroutine sstviscous_b
  subroutine sstviscous()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
    intrinsic mod
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
      t1 = scratch(i, j, k+1, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k-1, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i, j, &
&       k-1, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j, &
&       k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, itu2)
    end do
!
!       viscous terms in j-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
      t1 = scratch(i, j+1, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j-1, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i, j-1&
&       , k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i, j-1&
&       , k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, itu2)
    end do
!
!       viscous terms in i-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
      t1 = scratch(i+1, j, k, if1sst)
      t2 = one - t1
      rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i, j, k, if1sst)
      t2 = one - t1
      rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
      t1 = scratch(i-1, j, k, if1sst)
      t2 = one - t1
      rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
      rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
      mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
      muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
      muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
      c1m = ttm*(mulm+muem)*rhoi
      c1p = ttp*(mulp+muep)*rhoi
      c10 = c1m + c1p
! and the omega term.
      muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
      muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
      c2m = ttm*(mulm+muem)*rhoi
      c2p = ttp*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, idvt+0) = scratch(i, j, k, idvt+0) + c1m*w(i-1, j&
&       , k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
      scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i-1, j&
&       , k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i+1, j, k, itu2)
    end do
  end subroutine sstviscous
!  differentiation of sstresscale in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:out
!   plus diff mem management of: dw:in scratch:in
  subroutine sstresscale_b()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
    scratchd = 0.0_8
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rblank = real(iblank(i, j, k), realtype)
      scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) - volref(i, &
&       j, k)*rblank*dwd(i, j, k, itu2)
      dwd(i, j, k, itu2) = 0.0_8
      scratchd(i, j, k, idvt+0) = scratchd(i, j, k, idvt+0) - volref(i, &
&       j, k)*rblank*dwd(i, j, k, itu1)
      dwd(i, j, k, itu1) = 0.0_8
    end do
  end subroutine sstresscale_b
  subroutine sstresscale()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rblank = real(iblank(i, j, k), realtype)
      dw(i, j, k, itu1) = -(volref(i, j, k)*scratch(i, j, k, idvt+0)*&
&       rblank)
      dw(i, j, k, itu2) = -(volref(i, j, k)*scratch(i, j, k, idvt+1)*&
&       rblank)
    end do
  end subroutine sstresscale
!  differentiation of f1sst in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *scratch *d2wall
!   with respect to varying inputs: *w *scratch *d2wall
!   rw status of diff variables: *w:incr *scratch:in-out *d2wall:incr
!   plus diff mem management of: w:in scratch:in d2wall:in
  subroutine f1sst_b()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    real(kind=realtype) :: t1, t2, arg1, myeps
    real(kind=realtype) :: t1d, t2d, arg1d
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    integer :: branch
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: max1d
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
    real(kind=realtype) :: temp
    real(kind=realtype) :: max1
    real(kind=realtype) :: temp8
    real(kind=realtype) :: temp7
    real(kind=realtype) :: temp6
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp4
    call pushinteger4(i)
    call pushinteger4(j)
    do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        call pushinteger4(k)
        do k=kcbeg(nn),kcend(nn)
          call pushinteger4(j)
        end do
        do k=kcend(nn),kcbeg(nn),-1
          do j=jcend(nn),jcbeg(nn),-1
            scratchd(2, j, k, if1sst) = scratchd(2, j, k, if1sst) + &
&             scratchd(1, j, k, if1sst)
            scratchd(1, j, k, if1sst) = 0.0_8
          end do
          call popinteger4(j)
        end do
        call popinteger4(k)
      case (imax) 
        call pushinteger4(k)
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          call pushinteger4(j)
        end do
        do k=kcend(nn),kcbeg(nn),-1
          do j=jcend(nn),jcbeg(nn),-1
            tmpd = scratchd(ie, j, k, if1sst)
            scratchd(ie, j, k, if1sst) = 0.0_8
            scratchd(il, j, k, if1sst) = scratchd(il, j, k, if1sst) + &
&             tmpd
          end do
          call popinteger4(j)
        end do
        call popinteger4(k)
      case (jmin) 
        call pushinteger4(k)
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          call pushinteger4(i)
        end do
        do k=kcend(nn),kcbeg(nn),-1
          do i=icend(nn),icbeg(nn),-1
            scratchd(i, 2, k, if1sst) = scratchd(i, 2, k, if1sst) + &
&             scratchd(i, 1, k, if1sst)
            scratchd(i, 1, k, if1sst) = 0.0_8
          end do
          call popinteger4(i)
        end do
        call popinteger4(k)
      case (jmax) 
        call pushinteger4(k)
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          call pushinteger4(i)
        end do
        do k=kcend(nn),kcbeg(nn),-1
          do i=icend(nn),icbeg(nn),-1
            tmpd0 = scratchd(i, je, k, if1sst)
            scratchd(i, je, k, if1sst) = 0.0_8
            scratchd(i, jl, k, if1sst) = scratchd(i, jl, k, if1sst) + &
&             tmpd0
          end do
          call popinteger4(i)
        end do
        call popinteger4(k)
      case (kmin) 
        call pushinteger4(j)
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          call pushinteger4(i)
        end do
        do j=jcend(nn),jcbeg(nn),-1
          do i=icend(nn),icbeg(nn),-1
            scratchd(i, j, 2, if1sst) = scratchd(i, j, 2, if1sst) + &
&             scratchd(i, j, 1, if1sst)
            scratchd(i, j, 1, if1sst) = 0.0_8
          end do
          call popinteger4(i)
        end do
        call popinteger4(j)
      case (kmax) 
        call pushinteger4(j)
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          call pushinteger4(i)
        end do
        do j=jcend(nn),jcbeg(nn),-1
          do i=icend(nn),icbeg(nn),-1
            tmpd1 = scratchd(i, j, ke, if1sst)
            scratchd(i, j, ke, if1sst) = 0.0_8
            scratchd(i, j, kl, if1sst) = scratchd(i, j, kl, if1sst) + &
&             tmpd1
          end do
          call popinteger4(i)
        end do
        call popinteger4(j)
      end select
    end do
    call popinteger4(j)
    call popinteger4(i)
    do ii=0,ie*je*ke-1
      i = mod(ii, ie) + 1
      j = mod(ii/ie, je) + 1
      k = ii/(ie*je) + 1
      t1 = sqrt(w(i, j, k, itu1))/(0.09_realtype*w(i, j, k, itu2)*d2wall&
&       (i, j, k))
      t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, itu2&
&       )*d2wall(i, j, k)**2)
      if (t1 .lt. t2) then
        t1 = t2
        call pushcontrol1b(0)
      else
        t1 = t1
        call pushcontrol1b(1)
      end if
      if (eps .lt. scratch(i, j, k, icd)) then
        max1 = scratch(i, j, k, icd)
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        max1 = eps
      end if
      t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
      if (t1 .gt. t2) then
        arg1 = t2
        call pushcontrol1b(0)
      else
        arg1 = t1
        call pushcontrol1b(1)
      end if
      arg1d = (1.0-tanh(arg1**4)**2)*4*arg1**3*scratchd(i, j, k, if1sst)
      scratchd(i, j, k, if1sst) = 0.0_8
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        t2d = arg1d
        t1d = 0.0_8
      else
        t1d = arg1d
        t2d = 0.0_8
      end if
      temp8 = d2wall(i, j, k)**2
      tempd1 = two*t2d/(max1*temp8)
      tempd2 = -(w(i, j, k, itu1)*tempd1/(max1*temp8))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + tempd1
      max1d = temp8*tempd2
      d2walld(i, j, k) = d2walld(i, j, k) + max1*2*d2wall(i, j, k)*&
&       tempd2
      call popcontrol1b(branch)
      if (branch .eq. 0) scratchd(i, j, k, icd) = scratchd(i, j, k, icd)&
&         + max1d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        t2d = t1d
        t1d = 0.0_8
      else
        t2d = 0.0_8
      end if
      temp7 = d2wall(i, j, k)**2
      temp6 = w(i, j, k, itu2)
      temp5 = w(i, j, k, irho)
      temp4 = temp5*temp6
      tempd = -(rlv(i, j, k)*500.0_realtype*t2d/(temp4**2*temp7**2))
      wd(i, j, k, irho) = wd(i, j, k, irho) + temp7*temp6*tempd
      wd(i, j, k, itu2) = wd(i, j, k, itu2) + temp7*temp5*tempd
      d2walld(i, j, k) = d2walld(i, j, k) + temp4*2*d2wall(i, j, k)*&
&       tempd
      temp3 = 0.09_realtype*d2wall(i, j, k)
      temp2 = w(i, j, k, itu2)
      temp = temp2*temp3
      temp1 = w(i, j, k, itu1)
      temp0 = sqrt(temp1)
      tempd0 = -(temp0*t1d/temp**2)
      if (.not.temp1 .eq. 0.0_8) wd(i, j, k, itu1) = wd(i, j, k, itu1) +&
&         t1d/(temp*2.0*temp0)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) + temp3*tempd0
      d2walld(i, j, k) = d2walld(i, j, k) + temp2*0.09_realtype*tempd0
    end do
  end subroutine f1sst_b
  subroutine f1sst()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    real(kind=realtype) :: t1, t2, arg1, myeps
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic tanh
    real(kind=realtype) :: max1
    myeps = 1e-10_realtype/two/rsstsigw2
! compute the blending function f1 for all owned cells.
    do ii=0,ie*je*ke-1
      i = mod(ii, ie) + 1
      j = mod(ii/ie, je) + 1
      k = ii/(ie*je) + 1
      t1 = sqrt(w(i, j, k, itu1))/(0.09_realtype*w(i, j, k, itu2)*d2wall&
&       (i, j, k))
      t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, itu2&
&       )*d2wall(i, j, k)**2)
      if (t1 .lt. t2) then
        t1 = t2
      else
        t1 = t1
      end if
      if (eps .lt. scratch(i, j, k, icd)) then
        max1 = scratch(i, j, k, icd)
      else
        max1 = eps
      end if
      t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
      if (t1 .gt. t2) then
        arg1 = t2
      else
        arg1 = t1
      end if
      scratch(i, j, k, if1sst) = tanh(arg1**4)
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst
end module sst_b

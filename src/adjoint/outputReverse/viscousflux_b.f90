!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of viscousflux in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev *w *rlv *x *si *sj *sk
!                *fw *(*viscsubface.tau)
!   with respect to varying inputs: *rev *aa *wx *wy *wz *w *rlv
!                *x *qx *qy *qz *ux *uy *uz *si *sj *sk *vx *vy
!                *vz *fw
!   plus diff mem management of: rev:in aa:in wx:in wy:in wz:in
!                w:in rlv:in x:in qx:in qy:in qz:in ux:in uy:in
!                uz:in si:in sj:in sk:in vx:in vy:in vz:in fw:in
!                viscsubface:in *viscsubface.tau:in
subroutine viscousflux_b()
!
!       viscousflux computes the viscous fluxes using a central        
!       difference scheme for a block.                                 
!       it is assumed that the pointers in block pointer already point 
!       to the correct block.                                          
!
  use constants
  use blockpointers
  use flowvarrefstate
  use inputphysics
  use iteration
  implicit none
! possibly correct the wall shear stress.
! wall function is not aded
!
!      local parameter.
!
  real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ii
  real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
  real(kind=realtype) :: muld, mued, mutd, heatcoefd
  real(kind=realtype) :: gm1, factlamheat, factturbheat
  real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
  real(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, w_yd&
& , w_zd
  real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
  real(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
  real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
  real(kind=realtype) :: corrd, ssxd, ssyd, sszd, ssd, fracdivd
  real(kind=realtype) :: tauxx, tauyy, tauzz
  real(kind=realtype) :: tauxxd, tauyyd, tauzzd
  real(kind=realtype) :: tauxy, tauxz, tauyz
  real(kind=realtype) :: tauxyd, tauxzd, tauyzd
  real(kind=realtype) :: fmx, fmy, fmz, frhoe
  real(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
  logical :: correctfork, storewalltensor
  intrinsic abs
  intrinsic mod
  intrinsic sqrt
  integer :: branch
  real(kind=realtype) :: tempd14
  real(kind=realtype) :: temp3
  real(kind=realtype) :: tempd13
  real(kind=realtype) :: temp2
  real(kind=realtype) :: tempd12
  real(kind=realtype) :: temp1
  real(kind=realtype) :: tempd49
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: tempd48
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: tempd47
  real(kind=realtype) :: tempd46
  real(kind=realtype) :: tempd45
  real(kind=realtype) :: tempd44
  real(kind=realtype) :: tempd43
  real(kind=realtype) :: tempd42
  real(kind=realtype) :: tempd41
  real(kind=realtype) :: tempd40
  real(kind=realtype) :: tempd39
  real(kind=realtype) :: tempd38
  real(kind=realtype) :: tempd37
  real(kind=realtype) :: tempd36
  real(kind=realtype) :: tempd35
  real(kind=realtype) :: tempd34
  real(kind=realtype) :: tempd33
  real(kind=realtype) :: tempd32
  real(kind=realtype) :: tempd31
  real(kind=realtype) :: tempd30
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: tempd29
  real(kind=realtype) :: tempd28
  real(kind=realtype) :: tempd27
  real(kind=realtype) :: tempd26
  real(kind=realtype) :: tempd25
  real(kind=realtype) :: tempd24
  real(kind=realtype) :: tempd23
  real(kind=realtype) :: tempd22
  real(kind=realtype) :: tempd21
  real(kind=realtype) :: tempd58
  real(kind=realtype) :: tempd20
  real(kind=realtype) :: tempd57
  real(kind=realtype) :: tempd56
  real(kind=realtype) :: tempd55
  real(kind=realtype) :: tempd54
  real(kind=realtype) :: tempd53
  real(kind=realtype) :: tempd52
  real(kind=realtype) :: tempd51
  real(kind=realtype) :: tempd50
  real(kind=realtype) :: abs0
  real(kind=realtype) :: temp
  real(kind=realtype) :: tempd19
  real(kind=realtype) :: tempd18
  real(kind=realtype) :: tempd17
  real(kind=realtype) :: tempd16
  real(kind=realtype) :: tempd15
  real(kind=realtype) :: temp4
! set rfilv to rfil to indicate that this is the viscous part.
! if rfilv == 0 the viscous residuals need not to be computed
! and a return can be made.
  rfilv = rfil
  if (rfilv .ge. 0.) then
    abs0 = rfilv
  else
    abs0 = -rfilv
  end if
  if (abs0 .lt. thresholdreal) then
    aad = 0.0_8
    wxd = 0.0_8
    wyd = 0.0_8
    wzd = 0.0_8
    qxd = 0.0_8
    qyd = 0.0_8
    qzd = 0.0_8
    uxd = 0.0_8
    uyd = 0.0_8
    uzd = 0.0_8
    vxd = 0.0_8
    vyd = 0.0_8
    vzd = 0.0_8
  else
! determine whether or not the wall stress tensor and wall heat
! flux must be stored for viscous walls.
    storewalltensor = .false.
    if (wallfunctions) then
      storewalltensor = .true.
    else if (rkstage .eq. 0 .and. currentlevel .eq. groundlevel) then
      storewalltensor = .true.
    end if
    call pushreal8(ssx)
    call pushreal8(ssy)
    call pushreal8(ssz)
    call pushreal8(u_x)
    call pushreal8(u_y)
    call pushreal8(u_z)
    call pushinteger4(i)
    call pushinteger4(j)
    call pushinteger4(k)
    call pushreal8(w_x)
    call pushreal8(w_y)
    call pushreal8(w_z)
    call pushreal8(corr)
    call pushreal8(q_x)
    call pushreal8(q_y)
    call pushreal8(q_z)
    call pushreal8(v_x)
    call pushreal8(v_y)
    call pushreal8(v_z)
    call pushreal8(heatcoef)
    call pushreal8(ss)
    call pushreal8(fracdiv)
    call pushreal8(por)
    call pushreal8(mut)
    call pushreal8(ssx)
    call pushreal8(ssy)
    call pushreal8(ssz)
    call pushreal8(u_x)
    call pushreal8(u_y)
    call pushreal8(u_z)
    call pushinteger4(i)
    call pushinteger4(j)
    call pushinteger4(k)
    call pushreal8(w_x)
    call pushreal8(w_y)
    call pushreal8(w_z)
    call pushreal8(corr)
    call pushreal8(q_x)
    call pushreal8(q_y)
    call pushreal8(q_z)
    call pushreal8(v_x)
    call pushreal8(v_y)
    call pushreal8(v_z)
    call pushreal8(heatcoef)
    call pushreal8(ss)
    call pushreal8(fracdiv)
    call pushreal8(por)
    call pushreal8(mut)
    aad = 0.0_8
    wxd = 0.0_8
    wyd = 0.0_8
    wzd = 0.0_8
    qxd = 0.0_8
    qyd = 0.0_8
    qzd = 0.0_8
    uxd = 0.0_8
    uyd = 0.0_8
    uzd = 0.0_8
    vxd = 0.0_8
    vyd = 0.0_8
    vzd = 0.0_8
    mued = 0.0_8
    mue = zero
    aad = 0.0_8
    wxd = 0.0_8
    wyd = 0.0_8
    wzd = 0.0_8
    qxd = 0.0_8
    qyd = 0.0_8
    qzd = 0.0_8
    uxd = 0.0_8
    uyd = 0.0_8
    uzd = 0.0_8
    vxd = 0.0_8
    vyd = 0.0_8
    vzd = 0.0_8
    mued = 0.0_8
    do ii=0,il*ny*nz-1
      i = mod(ii, il) + 1
      j = mod(ii/il, ny) + 2
      k = ii/(il*ny) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
      por = half*rfilv
      if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
      mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
      if (eddymodel) then
        mue = por*(rev(i, j, k)+rev(i+1, j, k))
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      mut = mul + mue
      gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
      factlamheat = one/(prandtl*gm1)
      factturbheat = one/(prandtlturb*gm1)
      heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
      u_x = fourth*(ux(i, j-1, k-1)+ux(i, j, k-1)+ux(i, j-1, k)+ux(i, j&
&       , k))
      u_y = fourth*(uy(i, j-1, k-1)+uy(i, j, k-1)+uy(i, j-1, k)+uy(i, j&
&       , k))
      u_z = fourth*(uz(i, j-1, k-1)+uz(i, j, k-1)+uz(i, j-1, k)+uz(i, j&
&       , k))
      v_x = fourth*(vx(i, j-1, k-1)+vx(i, j, k-1)+vx(i, j-1, k)+vx(i, j&
&       , k))
      v_y = fourth*(vy(i, j-1, k-1)+vy(i, j, k-1)+vy(i, j-1, k)+vy(i, j&
&       , k))
      v_z = fourth*(vz(i, j-1, k-1)+vz(i, j, k-1)+vz(i, j-1, k)+vz(i, j&
&       , k))
      w_x = fourth*(wx(i, j-1, k-1)+wx(i, j, k-1)+wx(i, j-1, k)+wx(i, j&
&       , k))
      w_y = fourth*(wy(i, j-1, k-1)+wy(i, j, k-1)+wy(i, j-1, k)+wy(i, j&
&       , k))
      w_z = fourth*(wz(i, j-1, k-1)+wz(i, j, k-1)+wz(i, j-1, k)+wz(i, j&
&       , k))
      q_x = fourth*(qx(i, j-1, k-1)+qx(i, j, k-1)+qx(i, j-1, k)+qx(i, j&
&       , k))
      q_y = fourth*(qy(i, j-1, k-1)+qy(i, j, k-1)+qy(i, j-1, k)+qy(i, j&
&       , k))
      q_z = fourth*(qz(i, j-1, k-1)+qz(i, j, k-1)+qz(i, j-1, k)+qz(i, j&
&       , k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center i to cell center i+1.
      ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j-1, &
&       k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1, 1)+x(i+&
&       1, j, k, 1)-x(i-1, j, k, 1))
      ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j-1, &
&       k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1, 2)+x(i+&
&       1, j, k, 2)-x(i-1, j, k, 2))
      ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j-1, &
&       k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1, 3)+x(i+&
&       1, j, k, 3)-x(i-1, j, k, 3))
! determine the length of this vector and create the
! unit normal.
      ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
      call pushreal8(ssx)
      ssx = ss*ssx
      call pushreal8(ssy)
      ssy = ss*ssy
      call pushreal8(ssz)
      ssz = ss*ssz
! correct the gradients.
      corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j, k&
&       , ivx))*ss
      call pushreal8(u_x)
      u_x = u_x - corr*ssx
      call pushreal8(u_y)
      u_y = u_y - corr*ssy
      call pushreal8(u_z)
      u_z = u_z - corr*ssz
      call pushreal8(corr)
      corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j, k&
&       , ivy))*ss
      call pushreal8(v_x)
      v_x = v_x - corr*ssx
      call pushreal8(v_y)
      v_y = v_y - corr*ssy
      call pushreal8(v_z)
      v_z = v_z - corr*ssz
      call pushreal8(corr)
      corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j, k&
&       , ivz))*ss
      call pushreal8(w_x)
      w_x = w_x - corr*ssx
      call pushreal8(w_y)
      w_y = w_y - corr*ssy
      call pushreal8(w_z)
      w_z = w_z - corr*ssz
      call pushreal8(corr)
      corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i+1, j, k)-aa(i, j, k))*&
&       ss
      call pushreal8(q_x)
      q_x = q_x - corr*ssx
      call pushreal8(q_y)
      q_y = q_y - corr*ssy
      call pushreal8(q_z)
      q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
      fracdiv = twothird*(u_x+v_y+w_z)
      tauxx = mut*(two*u_x-fracdiv)
      tauyy = mut*(two*v_y-fracdiv)
      tauzz = mut*(two*w_z-fracdiv)
      tauxy = mut*(u_y+v_x)
      tauxz = mut*(u_z+w_x)
      tauyz = mut*(v_z+w_y)
      call pushreal8(q_x)
      q_x = heatcoef*q_x
      call pushreal8(q_y)
      q_y = heatcoef*q_y
      call pushreal8(q_z)
      q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
      ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
      vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
      wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
! update the residuals of cell i and i+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases i == 1
! and i == il must be tested.
      if (i .eq. 1 .and. storewalltensor .and. visciminpointer(j, k) &
&         .gt. 0) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! and the i == il case.
      if (i .eq. il .and. storewalltensor .and. viscimaxpointer(j, k) &
&         .gt. 0) then
        tauyzd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 6)
        viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 6) = 0.0_8
        tauxzd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 5)
        viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 5) = 0.0_8
        tauxyd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 4)
        viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 4) = 0.0_8
        tauzzd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 3)
        viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 3) = 0.0_8
        tauyyd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 2)
        viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 2) = 0.0_8
        tauxxd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 1)
        viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 1) = 0.0_8
      else
        tauzzd = 0.0_8
        tauxxd = 0.0_8
        tauxyd = 0.0_8
        tauxzd = 0.0_8
        tauyyd = 0.0_8
        tauyzd = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tauyzd = tauyzd + viscsubfaced(visciminpointer(j, k))%tau(j, k, &
&         6)
        viscsubfaced(visciminpointer(j, k))%tau(j, k, 6) = 0.0_8
        tauxzd = tauxzd + viscsubfaced(visciminpointer(j, k))%tau(j, k, &
&         5)
        viscsubfaced(visciminpointer(j, k))%tau(j, k, 5) = 0.0_8
        tauxyd = tauxyd + viscsubfaced(visciminpointer(j, k))%tau(j, k, &
&         4)
        viscsubfaced(visciminpointer(j, k))%tau(j, k, 4) = 0.0_8
        tauzzd = tauzzd + viscsubfaced(visciminpointer(j, k))%tau(j, k, &
&         3)
        viscsubfaced(visciminpointer(j, k))%tau(j, k, 3) = 0.0_8
        tauyyd = tauyyd + viscsubfaced(visciminpointer(j, k))%tau(j, k, &
&         2)
        viscsubfaced(visciminpointer(j, k))%tau(j, k, 2) = 0.0_8
        tauxxd = tauxxd + viscsubfaced(visciminpointer(j, k))%tau(j, k, &
&         1)
        viscsubfaced(visciminpointer(j, k))%tau(j, k, 1) = 0.0_8
      end if
      frhoed = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
      fmzd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
      fmyd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
      fmxd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
      tempd39 = si(i, j, k, 1)*frhoed
      tempd40 = si(i, j, k, 2)*frhoed
      tempd41 = si(i, j, k, 3)*frhoed
      ubard = tauxz*tempd41 + tauxy*tempd40 + tauxx*tempd39
      tauxxd = tauxxd + si(i, j, k, 1)*fmxd + ubar*tempd39
      vbard = tauyz*tempd41 + tauyy*tempd40 + tauxy*tempd39
      tauxyd = tauxyd + si(i, j, k, 1)*fmyd + si(i, j, k, 2)*fmxd + ubar&
&       *tempd40 + vbar*tempd39
      wbard = tauzz*tempd41 + tauyz*tempd40 + tauxz*tempd39
      tauxzd = tauxzd + si(i, j, k, 1)*fmzd + si(i, j, k, 3)*fmxd + ubar&
&       *tempd41 + wbar*tempd39
      sid(i, j, k, 1) = sid(i, j, k, 1) + (ubar*tauxx-q_x+vbar*tauxy+&
&       wbar*tauxz)*frhoed
      tauyyd = tauyyd + si(i, j, k, 2)*fmyd + vbar*tempd40
      tauyzd = tauyzd + si(i, j, k, 2)*fmzd + si(i, j, k, 3)*fmyd + vbar&
&       *tempd41 + wbar*tempd40
      sid(i, j, k, 2) = sid(i, j, k, 2) + (ubar*tauxy-q_y+vbar*tauyy+&
&       wbar*tauyz)*frhoed
      tauzzd = tauzzd + si(i, j, k, 3)*fmzd + wbar*tempd41
      sid(i, j, k, 3) = sid(i, j, k, 3) + (ubar*tauxz-q_z+vbar*tauyz+&
&       wbar*tauzz)*frhoed
      q_xd = -(si(i, j, k, 1)*frhoed)
      q_yd = -(si(i, j, k, 2)*frhoed)
      q_zd = -(si(i, j, k, 3)*frhoed)
      sid(i, j, k, 1) = sid(i, j, k, 1) + tauxz*fmzd
      sid(i, j, k, 2) = sid(i, j, k, 2) + tauyz*fmzd
      sid(i, j, k, 3) = sid(i, j, k, 3) + tauzz*fmzd
      sid(i, j, k, 1) = sid(i, j, k, 1) + tauxy*fmyd
      sid(i, j, k, 2) = sid(i, j, k, 2) + tauyy*fmyd
      sid(i, j, k, 3) = sid(i, j, k, 3) + tauyz*fmyd
      sid(i, j, k, 1) = sid(i, j, k, 1) + tauxx*fmxd
      sid(i, j, k, 2) = sid(i, j, k, 2) + tauxy*fmxd
      sid(i, j, k, 3) = sid(i, j, k, 3) + tauxz*fmxd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wbard
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vbard
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*ubard
      call popreal8(q_z)
      call popreal8(q_y)
      call popreal8(q_x)
      heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
      q_zd = heatcoef*q_zd
      q_yd = heatcoef*q_yd
      q_xd = heatcoef*q_xd
      mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&       fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*tauxyd + &
&       (v_z+w_y)*tauyzd
      v_zd = mut*tauyzd
      w_yd = mut*tauyzd
      u_zd = mut*tauxzd
      w_xd = mut*tauxzd
      u_yd = mut*tauxyd
      v_xd = mut*tauxyd
      fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
      tempd42 = twothird*fracdivd
      w_zd = tempd42 + mut*two*tauzzd
      v_yd = tempd42 + mut*two*tauyyd
      u_xd = tempd42 + mut*two*tauxxd
      call popreal8(q_z)
      corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
      sszd = q_z*corrd - corr*q_zd
      call popreal8(q_y)
      ssyd = q_y*corrd - corr*q_yd
      call popreal8(q_x)
      ssxd = q_x*corrd - corr*q_xd
      call popreal8(corr)
      q_xd = q_xd + ssx*corrd
      q_yd = q_yd + ssy*corrd
      q_zd = q_zd + ssz*corrd
      aad(i+1, j, k) = aad(i+1, j, k) + ss*corrd
      aad(i, j, k) = aad(i, j, k) - ss*corrd
      ssd = (aa(i+1, j, k)-aa(i, j, k))*corrd
      call popreal8(w_z)
      corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
      sszd = sszd + w_z*corrd - corr*w_zd
      call popreal8(w_y)
      ssyd = ssyd + w_y*corrd - corr*w_yd
      call popreal8(w_x)
      ssxd = ssxd + w_x*corrd - corr*w_xd
      call popreal8(corr)
      w_xd = w_xd + ssx*corrd
      w_yd = w_yd + ssy*corrd
      w_zd = w_zd + ssz*corrd
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) - ss*corrd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
      ssd = ssd - (w(i+1, j, k, ivz)-w(i, j, k, ivz))*corrd
      call popreal8(v_z)
      corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
      sszd = sszd + v_z*corrd - corr*v_zd
      call popreal8(v_y)
      ssyd = ssyd + v_y*corrd - corr*v_yd
      call popreal8(v_x)
      ssxd = ssxd + v_x*corrd - corr*v_xd
      call popreal8(corr)
      v_xd = v_xd + ssx*corrd
      v_yd = v_yd + ssy*corrd
      v_zd = v_zd + ssz*corrd
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) - ss*corrd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
      ssd = ssd - (w(i+1, j, k, ivy)-w(i, j, k, ivy))*corrd
      call popreal8(u_z)
      corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
      sszd = sszd + u_z*corrd - corr*u_zd
      call popreal8(u_y)
      ssyd = ssyd + u_y*corrd - corr*u_yd
      call popreal8(u_x)
      ssxd = ssxd + u_x*corrd - corr*u_xd
      u_xd = u_xd + ssx*corrd
      u_yd = u_yd + ssy*corrd
      u_zd = u_zd + ssz*corrd
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) - ss*corrd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
      call popreal8(ssz)
      call popreal8(ssy)
      call popreal8(ssx)
      ssd = ssd + ssz*sszd + ssx*ssxd + ssy*ssyd - (w(i+1, j, k, ivx)-w(&
&       i, j, k, ivx))*corrd
      temp3 = ssx**2 + ssy**2 + ssz**2
      temp4 = sqrt(temp3)
      if (temp3 .eq. 0.0_8) then
        tempd43 = 0.0
      else
        tempd43 = -(one*ssd/(temp4**3*2.0))
      end if
      sszd = 2*ssz*tempd43 + ss*sszd
      ssyd = 2*ssy*tempd43 + ss*ssyd
      ssxd = 2*ssx*tempd43 + ss*ssxd
      tempd44 = eighth*sszd
      xd(i+1, j-1, k-1, 3) = xd(i+1, j-1, k-1, 3) + tempd44
      xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd44
      xd(i+1, j-1, k, 3) = xd(i+1, j-1, k, 3) + tempd44
      xd(i-1, j-1, k, 3) = xd(i-1, j-1, k, 3) - tempd44
      xd(i+1, j, k-1, 3) = xd(i+1, j, k-1, 3) + tempd44
      xd(i-1, j, k-1, 3) = xd(i-1, j, k-1, 3) - tempd44
      xd(i+1, j, k, 3) = xd(i+1, j, k, 3) + tempd44
      xd(i-1, j, k, 3) = xd(i-1, j, k, 3) - tempd44
      tempd45 = eighth*ssyd
      xd(i+1, j-1, k-1, 2) = xd(i+1, j-1, k-1, 2) + tempd45
      xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd45
      xd(i+1, j-1, k, 2) = xd(i+1, j-1, k, 2) + tempd45
      xd(i-1, j-1, k, 2) = xd(i-1, j-1, k, 2) - tempd45
      xd(i+1, j, k-1, 2) = xd(i+1, j, k-1, 2) + tempd45
      xd(i-1, j, k-1, 2) = xd(i-1, j, k-1, 2) - tempd45
      xd(i+1, j, k, 2) = xd(i+1, j, k, 2) + tempd45
      xd(i-1, j, k, 2) = xd(i-1, j, k, 2) - tempd45
      tempd46 = eighth*ssxd
      xd(i+1, j-1, k-1, 1) = xd(i+1, j-1, k-1, 1) + tempd46
      xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd46
      xd(i+1, j-1, k, 1) = xd(i+1, j-1, k, 1) + tempd46
      xd(i-1, j-1, k, 1) = xd(i-1, j-1, k, 1) - tempd46
      xd(i+1, j, k-1, 1) = xd(i+1, j, k-1, 1) + tempd46
      xd(i-1, j, k-1, 1) = xd(i-1, j, k-1, 1) - tempd46
      xd(i+1, j, k, 1) = xd(i+1, j, k, 1) + tempd46
      xd(i-1, j, k, 1) = xd(i-1, j, k, 1) - tempd46
      tempd47 = fourth*q_zd
      qzd(i, j-1, k-1) = qzd(i, j-1, k-1) + tempd47
      qzd(i, j, k-1) = qzd(i, j, k-1) + tempd47
      qzd(i, j-1, k) = qzd(i, j-1, k) + tempd47
      qzd(i, j, k) = qzd(i, j, k) + tempd47
      tempd48 = fourth*q_yd
      qyd(i, j-1, k-1) = qyd(i, j-1, k-1) + tempd48
      qyd(i, j, k-1) = qyd(i, j, k-1) + tempd48
      qyd(i, j-1, k) = qyd(i, j-1, k) + tempd48
      qyd(i, j, k) = qyd(i, j, k) + tempd48
      tempd49 = fourth*q_xd
      qxd(i, j-1, k-1) = qxd(i, j-1, k-1) + tempd49
      qxd(i, j, k-1) = qxd(i, j, k-1) + tempd49
      qxd(i, j-1, k) = qxd(i, j-1, k) + tempd49
      qxd(i, j, k) = qxd(i, j, k) + tempd49
      tempd50 = fourth*w_zd
      wzd(i, j-1, k-1) = wzd(i, j-1, k-1) + tempd50
      wzd(i, j, k-1) = wzd(i, j, k-1) + tempd50
      wzd(i, j-1, k) = wzd(i, j-1, k) + tempd50
      wzd(i, j, k) = wzd(i, j, k) + tempd50
      tempd51 = fourth*w_yd
      wyd(i, j-1, k-1) = wyd(i, j-1, k-1) + tempd51
      wyd(i, j, k-1) = wyd(i, j, k-1) + tempd51
      wyd(i, j-1, k) = wyd(i, j-1, k) + tempd51
      wyd(i, j, k) = wyd(i, j, k) + tempd51
      tempd52 = fourth*w_xd
      wxd(i, j-1, k-1) = wxd(i, j-1, k-1) + tempd52
      wxd(i, j, k-1) = wxd(i, j, k-1) + tempd52
      wxd(i, j-1, k) = wxd(i, j-1, k) + tempd52
      wxd(i, j, k) = wxd(i, j, k) + tempd52
      tempd53 = fourth*v_zd
      vzd(i, j-1, k-1) = vzd(i, j-1, k-1) + tempd53
      vzd(i, j, k-1) = vzd(i, j, k-1) + tempd53
      vzd(i, j-1, k) = vzd(i, j-1, k) + tempd53
      vzd(i, j, k) = vzd(i, j, k) + tempd53
      tempd54 = fourth*v_yd
      vyd(i, j-1, k-1) = vyd(i, j-1, k-1) + tempd54
      vyd(i, j, k-1) = vyd(i, j, k-1) + tempd54
      vyd(i, j-1, k) = vyd(i, j-1, k) + tempd54
      vyd(i, j, k) = vyd(i, j, k) + tempd54
      tempd55 = fourth*v_xd
      vxd(i, j-1, k-1) = vxd(i, j-1, k-1) + tempd55
      vxd(i, j, k-1) = vxd(i, j, k-1) + tempd55
      vxd(i, j-1, k) = vxd(i, j-1, k) + tempd55
      vxd(i, j, k) = vxd(i, j, k) + tempd55
      tempd56 = fourth*u_zd
      uzd(i, j-1, k-1) = uzd(i, j-1, k-1) + tempd56
      uzd(i, j, k-1) = uzd(i, j, k-1) + tempd56
      uzd(i, j-1, k) = uzd(i, j-1, k) + tempd56
      uzd(i, j, k) = uzd(i, j, k) + tempd56
      tempd57 = fourth*u_yd
      uyd(i, j-1, k-1) = uyd(i, j-1, k-1) + tempd57
      uyd(i, j, k-1) = uyd(i, j, k-1) + tempd57
      uyd(i, j-1, k) = uyd(i, j-1, k) + tempd57
      uyd(i, j, k) = uyd(i, j, k) + tempd57
      tempd58 = fourth*u_xd
      uxd(i, j-1, k-1) = uxd(i, j-1, k-1) + tempd58
      uxd(i, j, k-1) = uxd(i, j, k-1) + tempd58
      uxd(i, j-1, k) = uxd(i, j-1, k) + tempd58
      uxd(i, j, k) = uxd(i, j, k) + tempd58
      muld = mutd + factlamheat*heatcoefd
      mued = mued + mutd + factturbheat*heatcoefd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        revd(i, j, k) = revd(i, j, k) + por*mued
        revd(i+1, j, k) = revd(i+1, j, k) + por*mued
        mued = 0.0_8
      end if
      rlvd(i, j, k) = rlvd(i, j, k) + por*muld
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + por*muld
    end do
    call popreal8(mut)
    call popreal8(por)
    call popreal8(fracdiv)
    call popreal8(ss)
    call popreal8(heatcoef)
    call popreal8(v_z)
    call popreal8(v_y)
    call popreal8(v_x)
    call popreal8(q_z)
    call popreal8(q_y)
    call popreal8(q_x)
    call popreal8(corr)
    call popreal8(w_z)
    call popreal8(w_y)
    call popreal8(w_x)
    call popinteger4(k)
    call popinteger4(j)
    call popinteger4(i)
    call popreal8(u_z)
    call popreal8(u_y)
    call popreal8(u_x)
    call popreal8(ssz)
    call popreal8(ssy)
    call popreal8(ssx)
    mued = 0.0_8
    mue = zero
    mued = 0.0_8
    do ii=0,nx*jl*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, jl) + 1
      k = ii/(nx*jl) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
      por = half*rfilv
      if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
      mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
      if (eddymodel) then
        mue = por*(rev(i, j, k)+rev(i, j+1, k))
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      mut = mul + mue
      gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
      factlamheat = one/(prandtl*gm1)
      factturbheat = one/(prandtlturb*gm1)
      heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
      u_x = fourth*(ux(i-1, j, k-1)+ux(i, j, k-1)+ux(i-1, j, k)+ux(i, j&
&       , k))
      u_y = fourth*(uy(i-1, j, k-1)+uy(i, j, k-1)+uy(i-1, j, k)+uy(i, j&
&       , k))
      u_z = fourth*(uz(i-1, j, k-1)+uz(i, j, k-1)+uz(i-1, j, k)+uz(i, j&
&       , k))
      v_x = fourth*(vx(i-1, j, k-1)+vx(i, j, k-1)+vx(i-1, j, k)+vx(i, j&
&       , k))
      v_y = fourth*(vy(i-1, j, k-1)+vy(i, j, k-1)+vy(i-1, j, k)+vy(i, j&
&       , k))
      v_z = fourth*(vz(i-1, j, k-1)+vz(i, j, k-1)+vz(i-1, j, k)+vz(i, j&
&       , k))
      w_x = fourth*(wx(i-1, j, k-1)+wx(i, j, k-1)+wx(i-1, j, k)+wx(i, j&
&       , k))
      w_y = fourth*(wy(i-1, j, k-1)+wy(i, j, k-1)+wy(i-1, j, k)+wy(i, j&
&       , k))
      w_z = fourth*(wz(i-1, j, k-1)+wz(i, j, k-1)+wz(i-1, j, k)+wz(i, j&
&       , k))
      q_x = fourth*(qx(i-1, j, k-1)+qx(i, j, k-1)+qx(i-1, j, k)+qx(i, j&
&       , k))
      q_y = fourth*(qy(i-1, j, k-1)+qy(i, j, k-1)+qy(i-1, j, k)+qy(i, j&
&       , k))
      q_z = fourth*(qz(i-1, j, k-1)+qz(i, j, k-1)+qz(i-1, j, k)+qz(i, j&
&       , k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center j to cell center j+1.
      ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j+1, &
&       k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1, 1)+x(i&
&       , j+1, k, 1)-x(i, j-1, k, 1))
      ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j+1, &
&       k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1, 2)+x(i&
&       , j+1, k, 2)-x(i, j-1, k, 2))
      ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j+1, &
&       k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1, 3)+x(i&
&       , j+1, k, 3)-x(i, j-1, k, 3))
! determine the length of this vector and create the
! unit normal.
      ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
      call pushreal8(ssx)
      ssx = ss*ssx
      call pushreal8(ssy)
      ssy = ss*ssy
      call pushreal8(ssz)
      ssz = ss*ssz
! correct the gradients.
      corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j, k&
&       , ivx))*ss
      call pushreal8(u_x)
      u_x = u_x - corr*ssx
      call pushreal8(u_y)
      u_y = u_y - corr*ssy
      call pushreal8(u_z)
      u_z = u_z - corr*ssz
      call pushreal8(corr)
      corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j, k&
&       , ivy))*ss
      call pushreal8(v_x)
      v_x = v_x - corr*ssx
      call pushreal8(v_y)
      v_y = v_y - corr*ssy
      call pushreal8(v_z)
      v_z = v_z - corr*ssz
      call pushreal8(corr)
      corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j, k&
&       , ivz))*ss
      call pushreal8(w_x)
      w_x = w_x - corr*ssx
      call pushreal8(w_y)
      w_y = w_y - corr*ssy
      call pushreal8(w_z)
      w_z = w_z - corr*ssz
      call pushreal8(corr)
      corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j+1, k)-aa(i, j, k))*&
&       ss
      call pushreal8(q_x)
      q_x = q_x - corr*ssx
      call pushreal8(q_y)
      q_y = q_y - corr*ssy
      call pushreal8(q_z)
      q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
      fracdiv = twothird*(u_x+v_y+w_z)
      tauxx = mut*(two*u_x-fracdiv)
      tauyy = mut*(two*v_y-fracdiv)
      tauzz = mut*(two*w_z-fracdiv)
      tauxy = mut*(u_y+v_x)
      tauxz = mut*(u_z+w_x)
      tauyz = mut*(v_z+w_y)
      call pushreal8(q_x)
      q_x = heatcoef*q_x
      call pushreal8(q_y)
      q_y = heatcoef*q_y
      call pushreal8(q_z)
      q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
      ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
      vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
      wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
! update the residuals of cell j and j+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases j == 1
! and j == jl must be tested.
      if (j .eq. 1 .and. storewalltensor .and. viscjminpointer(i, k) &
&         .gt. 0) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! and the j == jl case.
      if (j .eq. jl .and. storewalltensor .and. viscjmaxpointer(i, k) &
&         .gt. 0) then
        tauyzd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 6)
        viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 6) = 0.0_8
        tauxzd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 5)
        viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 5) = 0.0_8
        tauxyd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 4)
        viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 4) = 0.0_8
        tauzzd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 3)
        viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 3) = 0.0_8
        tauyyd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 2)
        viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 2) = 0.0_8
        tauxxd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 1)
        viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 1) = 0.0_8
      else
        tauzzd = 0.0_8
        tauxxd = 0.0_8
        tauxyd = 0.0_8
        tauxzd = 0.0_8
        tauyyd = 0.0_8
        tauyzd = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tauyzd = tauyzd + viscsubfaced(viscjminpointer(i, k))%tau(i, k, &
&         6)
        viscsubfaced(viscjminpointer(i, k))%tau(i, k, 6) = 0.0_8
        tauxzd = tauxzd + viscsubfaced(viscjminpointer(i, k))%tau(i, k, &
&         5)
        viscsubfaced(viscjminpointer(i, k))%tau(i, k, 5) = 0.0_8
        tauxyd = tauxyd + viscsubfaced(viscjminpointer(i, k))%tau(i, k, &
&         4)
        viscsubfaced(viscjminpointer(i, k))%tau(i, k, 4) = 0.0_8
        tauzzd = tauzzd + viscsubfaced(viscjminpointer(i, k))%tau(i, k, &
&         3)
        viscsubfaced(viscjminpointer(i, k))%tau(i, k, 3) = 0.0_8
        tauyyd = tauyyd + viscsubfaced(viscjminpointer(i, k))%tau(i, k, &
&         2)
        viscsubfaced(viscjminpointer(i, k))%tau(i, k, 2) = 0.0_8
        tauxxd = tauxxd + viscsubfaced(viscjminpointer(i, k))%tau(i, k, &
&         1)
        viscsubfaced(viscjminpointer(i, k))%tau(i, k, 1) = 0.0_8
      end if
      frhoed = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
      fmzd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
      fmyd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
      fmxd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
      tempd19 = sj(i, j, k, 1)*frhoed
      tempd20 = sj(i, j, k, 2)*frhoed
      tempd21 = sj(i, j, k, 3)*frhoed
      ubard = tauxz*tempd21 + tauxy*tempd20 + tauxx*tempd19
      tauxxd = tauxxd + sj(i, j, k, 1)*fmxd + ubar*tempd19
      vbard = tauyz*tempd21 + tauyy*tempd20 + tauxy*tempd19
      tauxyd = tauxyd + sj(i, j, k, 1)*fmyd + sj(i, j, k, 2)*fmxd + ubar&
&       *tempd20 + vbar*tempd19
      wbard = tauzz*tempd21 + tauyz*tempd20 + tauxz*tempd19
      tauxzd = tauxzd + sj(i, j, k, 1)*fmzd + sj(i, j, k, 3)*fmxd + ubar&
&       *tempd21 + wbar*tempd19
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + (ubar*tauxx-q_x+vbar*tauxy+&
&       wbar*tauxz)*frhoed
      tauyyd = tauyyd + sj(i, j, k, 2)*fmyd + vbar*tempd20
      tauyzd = tauyzd + sj(i, j, k, 2)*fmzd + sj(i, j, k, 3)*fmyd + vbar&
&       *tempd21 + wbar*tempd20
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + (ubar*tauxy-q_y+vbar*tauyy+&
&       wbar*tauyz)*frhoed
      tauzzd = tauzzd + sj(i, j, k, 3)*fmzd + wbar*tempd21
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + (ubar*tauxz-q_z+vbar*tauyz+&
&       wbar*tauzz)*frhoed
      q_xd = -(sj(i, j, k, 1)*frhoed)
      q_yd = -(sj(i, j, k, 2)*frhoed)
      q_zd = -(sj(i, j, k, 3)*frhoed)
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + tauxz*fmzd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + tauyz*fmzd
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + tauzz*fmzd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + tauxy*fmyd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + tauyy*fmyd
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + tauyz*fmyd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + tauxx*fmxd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + tauxy*fmxd
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + tauxz*fmxd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wbard
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vbard
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*ubard
      call popreal8(q_z)
      call popreal8(q_y)
      call popreal8(q_x)
      heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
      q_zd = heatcoef*q_zd
      q_yd = heatcoef*q_yd
      q_xd = heatcoef*q_xd
      mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&       fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*tauxyd + &
&       (v_z+w_y)*tauyzd
      v_zd = mut*tauyzd
      w_yd = mut*tauyzd
      u_zd = mut*tauxzd
      w_xd = mut*tauxzd
      u_yd = mut*tauxyd
      v_xd = mut*tauxyd
      fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
      tempd22 = twothird*fracdivd
      w_zd = tempd22 + mut*two*tauzzd
      v_yd = tempd22 + mut*two*tauyyd
      u_xd = tempd22 + mut*two*tauxxd
      call popreal8(q_z)
      corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
      sszd = q_z*corrd - corr*q_zd
      call popreal8(q_y)
      ssyd = q_y*corrd - corr*q_yd
      call popreal8(q_x)
      ssxd = q_x*corrd - corr*q_xd
      call popreal8(corr)
      q_xd = q_xd + ssx*corrd
      q_yd = q_yd + ssy*corrd
      q_zd = q_zd + ssz*corrd
      aad(i, j+1, k) = aad(i, j+1, k) + ss*corrd
      aad(i, j, k) = aad(i, j, k) - ss*corrd
      ssd = (aa(i, j+1, k)-aa(i, j, k))*corrd
      call popreal8(w_z)
      corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
      sszd = sszd + w_z*corrd - corr*w_zd
      call popreal8(w_y)
      ssyd = ssyd + w_y*corrd - corr*w_yd
      call popreal8(w_x)
      ssxd = ssxd + w_x*corrd - corr*w_xd
      call popreal8(corr)
      w_xd = w_xd + ssx*corrd
      w_yd = w_yd + ssy*corrd
      w_zd = w_zd + ssz*corrd
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) - ss*corrd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
      ssd = ssd - (w(i, j+1, k, ivz)-w(i, j, k, ivz))*corrd
      call popreal8(v_z)
      corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
      sszd = sszd + v_z*corrd - corr*v_zd
      call popreal8(v_y)
      ssyd = ssyd + v_y*corrd - corr*v_yd
      call popreal8(v_x)
      ssxd = ssxd + v_x*corrd - corr*v_xd
      call popreal8(corr)
      v_xd = v_xd + ssx*corrd
      v_yd = v_yd + ssy*corrd
      v_zd = v_zd + ssz*corrd
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) - ss*corrd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
      ssd = ssd - (w(i, j+1, k, ivy)-w(i, j, k, ivy))*corrd
      call popreal8(u_z)
      corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
      sszd = sszd + u_z*corrd - corr*u_zd
      call popreal8(u_y)
      ssyd = ssyd + u_y*corrd - corr*u_yd
      call popreal8(u_x)
      ssxd = ssxd + u_x*corrd - corr*u_xd
      u_xd = u_xd + ssx*corrd
      u_yd = u_yd + ssy*corrd
      u_zd = u_zd + ssz*corrd
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) - ss*corrd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
      call popreal8(ssz)
      call popreal8(ssy)
      call popreal8(ssx)
      ssd = ssd + ssz*sszd + ssx*ssxd + ssy*ssyd - (w(i, j+1, k, ivx)-w(&
&       i, j, k, ivx))*corrd
      temp1 = ssx**2 + ssy**2 + ssz**2
      temp2 = sqrt(temp1)
      if (temp1 .eq. 0.0_8) then
        tempd23 = 0.0
      else
        tempd23 = -(one*ssd/(temp2**3*2.0))
      end if
      sszd = 2*ssz*tempd23 + ss*sszd
      ssyd = 2*ssy*tempd23 + ss*ssyd
      ssxd = 2*ssx*tempd23 + ss*ssxd
      tempd24 = eighth*sszd
      xd(i-1, j+1, k-1, 3) = xd(i-1, j+1, k-1, 3) + tempd24
      xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd24
      xd(i-1, j+1, k, 3) = xd(i-1, j+1, k, 3) + tempd24
      xd(i-1, j-1, k, 3) = xd(i-1, j-1, k, 3) - tempd24
      xd(i, j+1, k-1, 3) = xd(i, j+1, k-1, 3) + tempd24
      xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) - tempd24
      xd(i, j+1, k, 3) = xd(i, j+1, k, 3) + tempd24
      xd(i, j-1, k, 3) = xd(i, j-1, k, 3) - tempd24
      tempd25 = eighth*ssyd
      xd(i-1, j+1, k-1, 2) = xd(i-1, j+1, k-1, 2) + tempd25
      xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd25
      xd(i-1, j+1, k, 2) = xd(i-1, j+1, k, 2) + tempd25
      xd(i-1, j-1, k, 2) = xd(i-1, j-1, k, 2) - tempd25
      xd(i, j+1, k-1, 2) = xd(i, j+1, k-1, 2) + tempd25
      xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) - tempd25
      xd(i, j+1, k, 2) = xd(i, j+1, k, 2) + tempd25
      xd(i, j-1, k, 2) = xd(i, j-1, k, 2) - tempd25
      tempd26 = eighth*ssxd
      xd(i-1, j+1, k-1, 1) = xd(i-1, j+1, k-1, 1) + tempd26
      xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd26
      xd(i-1, j+1, k, 1) = xd(i-1, j+1, k, 1) + tempd26
      xd(i-1, j-1, k, 1) = xd(i-1, j-1, k, 1) - tempd26
      xd(i, j+1, k-1, 1) = xd(i, j+1, k-1, 1) + tempd26
      xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) - tempd26
      xd(i, j+1, k, 1) = xd(i, j+1, k, 1) + tempd26
      xd(i, j-1, k, 1) = xd(i, j-1, k, 1) - tempd26
      tempd27 = fourth*q_zd
      qzd(i-1, j, k-1) = qzd(i-1, j, k-1) + tempd27
      qzd(i, j, k-1) = qzd(i, j, k-1) + tempd27
      qzd(i-1, j, k) = qzd(i-1, j, k) + tempd27
      qzd(i, j, k) = qzd(i, j, k) + tempd27
      tempd28 = fourth*q_yd
      qyd(i-1, j, k-1) = qyd(i-1, j, k-1) + tempd28
      qyd(i, j, k-1) = qyd(i, j, k-1) + tempd28
      qyd(i-1, j, k) = qyd(i-1, j, k) + tempd28
      qyd(i, j, k) = qyd(i, j, k) + tempd28
      tempd29 = fourth*q_xd
      qxd(i-1, j, k-1) = qxd(i-1, j, k-1) + tempd29
      qxd(i, j, k-1) = qxd(i, j, k-1) + tempd29
      qxd(i-1, j, k) = qxd(i-1, j, k) + tempd29
      qxd(i, j, k) = qxd(i, j, k) + tempd29
      tempd30 = fourth*w_zd
      wzd(i-1, j, k-1) = wzd(i-1, j, k-1) + tempd30
      wzd(i, j, k-1) = wzd(i, j, k-1) + tempd30
      wzd(i-1, j, k) = wzd(i-1, j, k) + tempd30
      wzd(i, j, k) = wzd(i, j, k) + tempd30
      tempd31 = fourth*w_yd
      wyd(i-1, j, k-1) = wyd(i-1, j, k-1) + tempd31
      wyd(i, j, k-1) = wyd(i, j, k-1) + tempd31
      wyd(i-1, j, k) = wyd(i-1, j, k) + tempd31
      wyd(i, j, k) = wyd(i, j, k) + tempd31
      tempd32 = fourth*w_xd
      wxd(i-1, j, k-1) = wxd(i-1, j, k-1) + tempd32
      wxd(i, j, k-1) = wxd(i, j, k-1) + tempd32
      wxd(i-1, j, k) = wxd(i-1, j, k) + tempd32
      wxd(i, j, k) = wxd(i, j, k) + tempd32
      tempd33 = fourth*v_zd
      vzd(i-1, j, k-1) = vzd(i-1, j, k-1) + tempd33
      vzd(i, j, k-1) = vzd(i, j, k-1) + tempd33
      vzd(i-1, j, k) = vzd(i-1, j, k) + tempd33
      vzd(i, j, k) = vzd(i, j, k) + tempd33
      tempd34 = fourth*v_yd
      vyd(i-1, j, k-1) = vyd(i-1, j, k-1) + tempd34
      vyd(i, j, k-1) = vyd(i, j, k-1) + tempd34
      vyd(i-1, j, k) = vyd(i-1, j, k) + tempd34
      vyd(i, j, k) = vyd(i, j, k) + tempd34
      tempd35 = fourth*v_xd
      vxd(i-1, j, k-1) = vxd(i-1, j, k-1) + tempd35
      vxd(i, j, k-1) = vxd(i, j, k-1) + tempd35
      vxd(i-1, j, k) = vxd(i-1, j, k) + tempd35
      vxd(i, j, k) = vxd(i, j, k) + tempd35
      tempd36 = fourth*u_zd
      uzd(i-1, j, k-1) = uzd(i-1, j, k-1) + tempd36
      uzd(i, j, k-1) = uzd(i, j, k-1) + tempd36
      uzd(i-1, j, k) = uzd(i-1, j, k) + tempd36
      uzd(i, j, k) = uzd(i, j, k) + tempd36
      tempd37 = fourth*u_yd
      uyd(i-1, j, k-1) = uyd(i-1, j, k-1) + tempd37
      uyd(i, j, k-1) = uyd(i, j, k-1) + tempd37
      uyd(i-1, j, k) = uyd(i-1, j, k) + tempd37
      uyd(i, j, k) = uyd(i, j, k) + tempd37
      tempd38 = fourth*u_xd
      uxd(i-1, j, k-1) = uxd(i-1, j, k-1) + tempd38
      uxd(i, j, k-1) = uxd(i, j, k-1) + tempd38
      uxd(i-1, j, k) = uxd(i-1, j, k) + tempd38
      uxd(i, j, k) = uxd(i, j, k) + tempd38
      muld = mutd + factlamheat*heatcoefd
      mued = mued + mutd + factturbheat*heatcoefd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        revd(i, j, k) = revd(i, j, k) + por*mued
        revd(i, j+1, k) = revd(i, j+1, k) + por*mued
        mued = 0.0_8
      end if
      rlvd(i, j, k) = rlvd(i, j, k) + por*muld
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + por*muld
    end do
    call popreal8(mut)
    call popreal8(por)
    call popreal8(fracdiv)
    call popreal8(ss)
    call popreal8(heatcoef)
    call popreal8(v_z)
    call popreal8(v_y)
    call popreal8(v_x)
    call popreal8(q_z)
    call popreal8(q_y)
    call popreal8(q_x)
    call popreal8(corr)
    call popreal8(w_z)
    call popreal8(w_y)
    call popreal8(w_x)
    call popinteger4(k)
    call popinteger4(j)
    call popinteger4(i)
    call popreal8(u_z)
    call popreal8(u_y)
    call popreal8(u_x)
    call popreal8(ssz)
    call popreal8(ssy)
    call popreal8(ssx)
    mued = 0.0_8
!
!         viscous fluxes in the k-direction.                           
!
    mue = zero
    mued = 0.0_8
    do ii=0,nx*ny*kl-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 1
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
      por = half*rfilv
      if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
      mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
      if (eddymodel) then
        mue = por*(rev(i, j, k)+rev(i, j, k+1))
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      mut = mul + mue
      gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
      factlamheat = one/(prandtl*gm1)
      factturbheat = one/(prandtlturb*gm1)
      heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
      u_x = fourth*(ux(i-1, j-1, k)+ux(i, j-1, k)+ux(i-1, j, k)+ux(i, j&
&       , k))
      u_y = fourth*(uy(i-1, j-1, k)+uy(i, j-1, k)+uy(i-1, j, k)+uy(i, j&
&       , k))
      u_z = fourth*(uz(i-1, j-1, k)+uz(i, j-1, k)+uz(i-1, j, k)+uz(i, j&
&       , k))
      v_x = fourth*(vx(i-1, j-1, k)+vx(i, j-1, k)+vx(i-1, j, k)+vx(i, j&
&       , k))
      v_y = fourth*(vy(i-1, j-1, k)+vy(i, j-1, k)+vy(i-1, j, k)+vy(i, j&
&       , k))
      v_z = fourth*(vz(i-1, j-1, k)+vz(i, j-1, k)+vz(i-1, j, k)+vz(i, j&
&       , k))
      w_x = fourth*(wx(i-1, j-1, k)+wx(i, j-1, k)+wx(i-1, j, k)+wx(i, j&
&       , k))
      w_y = fourth*(wy(i-1, j-1, k)+wy(i, j-1, k)+wy(i-1, j, k)+wy(i, j&
&       , k))
      w_z = fourth*(wz(i-1, j-1, k)+wz(i, j-1, k)+wz(i-1, j, k)+wz(i, j&
&       , k))
      q_x = fourth*(qx(i-1, j-1, k)+qx(i, j-1, k)+qx(i-1, j, k)+qx(i, j&
&       , k))
      q_y = fourth*(qy(i-1, j-1, k)+qy(i, j-1, k)+qy(i-1, j, k)+qy(i, j&
&       , k))
      q_z = fourth*(qz(i-1, j-1, k)+qz(i, j-1, k)+qz(i-1, j, k)+qz(i, j&
&       , k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center k to cell center k+1.
      ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j, k+&
&       1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1, 1)+x(i&
&       , j, k+1, 1)-x(i, j, k-1, 1))
      ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j, k+&
&       1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1, 2)+x(i&
&       , j, k+1, 2)-x(i, j, k-1, 2))
      ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j, k+&
&       1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1, 3)+x(i&
&       , j, k+1, 3)-x(i, j, k-1, 3))
! determine the length of this vector and create the
! unit normal.
      ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
      call pushreal8(ssx)
      ssx = ss*ssx
      call pushreal8(ssy)
      ssy = ss*ssy
      call pushreal8(ssz)
      ssz = ss*ssz
! correct the gradients.
      corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j, k&
&       , ivx))*ss
      call pushreal8(u_x)
      u_x = u_x - corr*ssx
      call pushreal8(u_y)
      u_y = u_y - corr*ssy
      call pushreal8(u_z)
      u_z = u_z - corr*ssz
      call pushreal8(corr)
      corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j, k&
&       , ivy))*ss
      call pushreal8(v_x)
      v_x = v_x - corr*ssx
      call pushreal8(v_y)
      v_y = v_y - corr*ssy
      call pushreal8(v_z)
      v_z = v_z - corr*ssz
      call pushreal8(corr)
      corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j, k&
&       , ivz))*ss
      call pushreal8(w_x)
      w_x = w_x - corr*ssx
      call pushreal8(w_y)
      w_y = w_y - corr*ssy
      call pushreal8(w_z)
      w_z = w_z - corr*ssz
      call pushreal8(corr)
      corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j, k+1)-aa(i, j, k))*&
&       ss
      call pushreal8(q_x)
      q_x = q_x - corr*ssx
      call pushreal8(q_y)
      q_y = q_y - corr*ssy
      call pushreal8(q_z)
      q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
      fracdiv = twothird*(u_x+v_y+w_z)
      tauxx = mut*(two*u_x-fracdiv)
      tauyy = mut*(two*v_y-fracdiv)
      tauzz = mut*(two*w_z-fracdiv)
      tauxy = mut*(u_y+v_x)
      tauxz = mut*(u_z+w_x)
      tauyz = mut*(v_z+w_y)
      call pushreal8(q_x)
      q_x = heatcoef*q_x
      call pushreal8(q_y)
      q_y = heatcoef*q_y
      call pushreal8(q_z)
      q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
      ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
      vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
      wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this k-face.
! update the residuals of cell k and k+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases k == 1
! and k == kl must be tested.
      if (k .eq. 1 .and. storewalltensor .and. visckminpointer(i, j) &
&         .gt. 0) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! and the k == kl case.
      if (k .eq. kl .and. storewalltensor .and. visckmaxpointer(i, j) &
&         .gt. 0) then
        tauyzd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 6)
        viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 6) = 0.0_8
        tauxzd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 5)
        viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 5) = 0.0_8
        tauxyd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 4)
        viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 4) = 0.0_8
        tauzzd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 3)
        viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 3) = 0.0_8
        tauyyd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 2)
        viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 2) = 0.0_8
        tauxxd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 1)
        viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 1) = 0.0_8
      else
        tauzzd = 0.0_8
        tauxxd = 0.0_8
        tauxyd = 0.0_8
        tauxzd = 0.0_8
        tauyyd = 0.0_8
        tauyzd = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tauyzd = tauyzd + viscsubfaced(visckminpointer(i, j))%tau(i, j, &
&         6)
        viscsubfaced(visckminpointer(i, j))%tau(i, j, 6) = 0.0_8
        tauxzd = tauxzd + viscsubfaced(visckminpointer(i, j))%tau(i, j, &
&         5)
        viscsubfaced(visckminpointer(i, j))%tau(i, j, 5) = 0.0_8
        tauxyd = tauxyd + viscsubfaced(visckminpointer(i, j))%tau(i, j, &
&         4)
        viscsubfaced(visckminpointer(i, j))%tau(i, j, 4) = 0.0_8
        tauzzd = tauzzd + viscsubfaced(visckminpointer(i, j))%tau(i, j, &
&         3)
        viscsubfaced(visckminpointer(i, j))%tau(i, j, 3) = 0.0_8
        tauyyd = tauyyd + viscsubfaced(visckminpointer(i, j))%tau(i, j, &
&         2)
        viscsubfaced(visckminpointer(i, j))%tau(i, j, 2) = 0.0_8
        tauxxd = tauxxd + viscsubfaced(visckminpointer(i, j))%tau(i, j, &
&         1)
        viscsubfaced(visckminpointer(i, j))%tau(i, j, 1) = 0.0_8
      end if
      frhoed = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
      fmzd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
      fmyd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
      fmxd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
      q_xd = -(sk(i, j, k, 1)*frhoed)
      skd(i, j, k, 1) = skd(i, j, k, 1) - q_x*frhoed
      q_yd = -(sk(i, j, k, 2)*frhoed)
      skd(i, j, k, 2) = skd(i, j, k, 2) - q_y*frhoed
      q_zd = -(sk(i, j, k, 3)*frhoed)
      skd(i, j, k, 3) = skd(i, j, k, 3) - q_z*frhoed
      tempd = sk(i, j, k, 3)*frhoed
      tauzzd = tauzzd + sk(i, j, k, 3)*fmzd + wbar*tempd
      skd(i, j, k, 3) = skd(i, j, k, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
&       tauzz)*frhoed
      tempd0 = sk(i, j, k, 2)*frhoed
      tauyzd = tauyzd + wbar*tempd0 + sk(i, j, k, 3)*fmyd + sk(i, j, k, &
&       2)*fmzd + vbar*tempd
      tauyyd = tauyyd + sk(i, j, k, 2)*fmyd + vbar*tempd0
      skd(i, j, k, 2) = skd(i, j, k, 2) + (ubar*tauxy+vbar*tauyy+wbar*&
&       tauyz)*frhoed
      tempd1 = sk(i, j, k, 1)*frhoed
      ubard = tauxy*tempd0 + tauxx*tempd1 + tauxz*tempd
      tauxzd = tauxzd + wbar*tempd1 + sk(i, j, k, 3)*fmxd + sk(i, j, k, &
&       1)*fmzd + ubar*tempd
      vbard = tauyy*tempd0 + tauxy*tempd1 + tauyz*tempd
      wbard = tauyz*tempd0 + tauxz*tempd1 + tauzz*tempd
      tauxyd = tauxyd + vbar*tempd1 + sk(i, j, k, 2)*fmxd + sk(i, j, k, &
&       1)*fmyd + ubar*tempd0
      tauxxd = tauxxd + sk(i, j, k, 1)*fmxd + ubar*tempd1
      skd(i, j, k, 1) = skd(i, j, k, 1) + (ubar*tauxx+vbar*tauxy+wbar*&
&       tauxz)*frhoed
      skd(i, j, k, 1) = skd(i, j, k, 1) + tauxz*fmzd
      skd(i, j, k, 2) = skd(i, j, k, 2) + tauyz*fmzd
      skd(i, j, k, 3) = skd(i, j, k, 3) + tauzz*fmzd
      skd(i, j, k, 1) = skd(i, j, k, 1) + tauxy*fmyd
      skd(i, j, k, 2) = skd(i, j, k, 2) + tauyy*fmyd
      skd(i, j, k, 3) = skd(i, j, k, 3) + tauyz*fmyd
      skd(i, j, k, 1) = skd(i, j, k, 1) + tauxx*fmxd
      skd(i, j, k, 2) = skd(i, j, k, 2) + tauxy*fmxd
      skd(i, j, k, 3) = skd(i, j, k, 3) + tauxz*fmxd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wbard
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vbard
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*ubard
      call popreal8(q_z)
      call popreal8(q_y)
      call popreal8(q_x)
      heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
      q_zd = heatcoef*q_zd
      q_yd = heatcoef*q_yd
      q_xd = heatcoef*q_xd
      mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&       fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*tauxyd + &
&       (v_z+w_y)*tauyzd
      v_zd = mut*tauyzd
      w_yd = mut*tauyzd
      u_zd = mut*tauxzd
      w_xd = mut*tauxzd
      u_yd = mut*tauxyd
      v_xd = mut*tauxyd
      fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
      tempd2 = twothird*fracdivd
      w_zd = tempd2 + mut*two*tauzzd
      v_yd = tempd2 + mut*two*tauyyd
      u_xd = tempd2 + mut*two*tauxxd
      call popreal8(q_z)
      corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
      sszd = q_z*corrd - corr*q_zd
      call popreal8(q_y)
      ssyd = q_y*corrd - corr*q_yd
      call popreal8(q_x)
      ssxd = q_x*corrd - corr*q_xd
      call popreal8(corr)
      q_xd = q_xd + ssx*corrd
      q_yd = q_yd + ssy*corrd
      q_zd = q_zd + ssz*corrd
      aad(i, j, k+1) = aad(i, j, k+1) + ss*corrd
      aad(i, j, k) = aad(i, j, k) - ss*corrd
      ssd = (aa(i, j, k+1)-aa(i, j, k))*corrd
      call popreal8(w_z)
      corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
      sszd = sszd + w_z*corrd - corr*w_zd
      call popreal8(w_y)
      ssyd = ssyd + w_y*corrd - corr*w_yd
      call popreal8(w_x)
      ssxd = ssxd + w_x*corrd - corr*w_xd
      call popreal8(corr)
      w_xd = w_xd + ssx*corrd
      w_yd = w_yd + ssy*corrd
      w_zd = w_zd + ssz*corrd
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) - ss*corrd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
      ssd = ssd - (w(i, j, k+1, ivz)-w(i, j, k, ivz))*corrd
      call popreal8(v_z)
      corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
      sszd = sszd + v_z*corrd - corr*v_zd
      call popreal8(v_y)
      ssyd = ssyd + v_y*corrd - corr*v_yd
      call popreal8(v_x)
      ssxd = ssxd + v_x*corrd - corr*v_xd
      call popreal8(corr)
      v_xd = v_xd + ssx*corrd
      v_yd = v_yd + ssy*corrd
      v_zd = v_zd + ssz*corrd
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) - ss*corrd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
      ssd = ssd - (w(i, j, k+1, ivy)-w(i, j, k, ivy))*corrd
      call popreal8(u_z)
      corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
      sszd = sszd + u_z*corrd - corr*u_zd
      call popreal8(u_y)
      ssyd = ssyd + u_y*corrd - corr*u_yd
      call popreal8(u_x)
      ssxd = ssxd + u_x*corrd - corr*u_xd
      u_xd = u_xd + ssx*corrd
      u_yd = u_yd + ssy*corrd
      u_zd = u_zd + ssz*corrd
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) - ss*corrd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
      call popreal8(ssz)
      call popreal8(ssy)
      call popreal8(ssx)
      ssd = ssd + ssz*sszd + ssx*ssxd + ssy*ssyd - (w(i, j, k+1, ivx)-w(&
&       i, j, k, ivx))*corrd
      temp = ssx**2 + ssy**2 + ssz**2
      temp0 = sqrt(temp)
      if (temp .eq. 0.0_8) then
        tempd3 = 0.0
      else
        tempd3 = -(one*ssd/(temp0**3*2.0))
      end if
      sszd = 2*ssz*tempd3 + ss*sszd
      ssyd = 2*ssy*tempd3 + ss*ssyd
      ssxd = 2*ssx*tempd3 + ss*ssxd
      tempd4 = eighth*sszd
      xd(i-1, j-1, k+1, 3) = xd(i-1, j-1, k+1, 3) + tempd4
      xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd4
      xd(i-1, j, k+1, 3) = xd(i-1, j, k+1, 3) + tempd4
      xd(i-1, j, k-1, 3) = xd(i-1, j, k-1, 3) - tempd4
      xd(i, j-1, k+1, 3) = xd(i, j-1, k+1, 3) + tempd4
      xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) - tempd4
      xd(i, j, k+1, 3) = xd(i, j, k+1, 3) + tempd4
      xd(i, j, k-1, 3) = xd(i, j, k-1, 3) - tempd4
      tempd5 = eighth*ssyd
      xd(i-1, j-1, k+1, 2) = xd(i-1, j-1, k+1, 2) + tempd5
      xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd5
      xd(i-1, j, k+1, 2) = xd(i-1, j, k+1, 2) + tempd5
      xd(i-1, j, k-1, 2) = xd(i-1, j, k-1, 2) - tempd5
      xd(i, j-1, k+1, 2) = xd(i, j-1, k+1, 2) + tempd5
      xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) - tempd5
      xd(i, j, k+1, 2) = xd(i, j, k+1, 2) + tempd5
      xd(i, j, k-1, 2) = xd(i, j, k-1, 2) - tempd5
      tempd6 = eighth*ssxd
      xd(i-1, j-1, k+1, 1) = xd(i-1, j-1, k+1, 1) + tempd6
      xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd6
      xd(i-1, j, k+1, 1) = xd(i-1, j, k+1, 1) + tempd6
      xd(i-1, j, k-1, 1) = xd(i-1, j, k-1, 1) - tempd6
      xd(i, j-1, k+1, 1) = xd(i, j-1, k+1, 1) + tempd6
      xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) - tempd6
      xd(i, j, k+1, 1) = xd(i, j, k+1, 1) + tempd6
      xd(i, j, k-1, 1) = xd(i, j, k-1, 1) - tempd6
      tempd7 = fourth*q_zd
      qzd(i-1, j-1, k) = qzd(i-1, j-1, k) + tempd7
      qzd(i, j-1, k) = qzd(i, j-1, k) + tempd7
      qzd(i-1, j, k) = qzd(i-1, j, k) + tempd7
      qzd(i, j, k) = qzd(i, j, k) + tempd7
      tempd8 = fourth*q_yd
      qyd(i-1, j-1, k) = qyd(i-1, j-1, k) + tempd8
      qyd(i, j-1, k) = qyd(i, j-1, k) + tempd8
      qyd(i-1, j, k) = qyd(i-1, j, k) + tempd8
      qyd(i, j, k) = qyd(i, j, k) + tempd8
      tempd9 = fourth*q_xd
      qxd(i-1, j-1, k) = qxd(i-1, j-1, k) + tempd9
      qxd(i, j-1, k) = qxd(i, j-1, k) + tempd9
      qxd(i-1, j, k) = qxd(i-1, j, k) + tempd9
      qxd(i, j, k) = qxd(i, j, k) + tempd9
      tempd10 = fourth*w_zd
      wzd(i-1, j-1, k) = wzd(i-1, j-1, k) + tempd10
      wzd(i, j-1, k) = wzd(i, j-1, k) + tempd10
      wzd(i-1, j, k) = wzd(i-1, j, k) + tempd10
      wzd(i, j, k) = wzd(i, j, k) + tempd10
      tempd11 = fourth*w_yd
      wyd(i-1, j-1, k) = wyd(i-1, j-1, k) + tempd11
      wyd(i, j-1, k) = wyd(i, j-1, k) + tempd11
      wyd(i-1, j, k) = wyd(i-1, j, k) + tempd11
      wyd(i, j, k) = wyd(i, j, k) + tempd11
      tempd12 = fourth*w_xd
      wxd(i-1, j-1, k) = wxd(i-1, j-1, k) + tempd12
      wxd(i, j-1, k) = wxd(i, j-1, k) + tempd12
      wxd(i-1, j, k) = wxd(i-1, j, k) + tempd12
      wxd(i, j, k) = wxd(i, j, k) + tempd12
      tempd13 = fourth*v_zd
      vzd(i-1, j-1, k) = vzd(i-1, j-1, k) + tempd13
      vzd(i, j-1, k) = vzd(i, j-1, k) + tempd13
      vzd(i-1, j, k) = vzd(i-1, j, k) + tempd13
      vzd(i, j, k) = vzd(i, j, k) + tempd13
      tempd14 = fourth*v_yd
      vyd(i-1, j-1, k) = vyd(i-1, j-1, k) + tempd14
      vyd(i, j-1, k) = vyd(i, j-1, k) + tempd14
      vyd(i-1, j, k) = vyd(i-1, j, k) + tempd14
      vyd(i, j, k) = vyd(i, j, k) + tempd14
      tempd15 = fourth*v_xd
      vxd(i-1, j-1, k) = vxd(i-1, j-1, k) + tempd15
      vxd(i, j-1, k) = vxd(i, j-1, k) + tempd15
      vxd(i-1, j, k) = vxd(i-1, j, k) + tempd15
      vxd(i, j, k) = vxd(i, j, k) + tempd15
      tempd16 = fourth*u_zd
      uzd(i-1, j-1, k) = uzd(i-1, j-1, k) + tempd16
      uzd(i, j-1, k) = uzd(i, j-1, k) + tempd16
      uzd(i-1, j, k) = uzd(i-1, j, k) + tempd16
      uzd(i, j, k) = uzd(i, j, k) + tempd16
      tempd17 = fourth*u_yd
      uyd(i-1, j-1, k) = uyd(i-1, j-1, k) + tempd17
      uyd(i, j-1, k) = uyd(i, j-1, k) + tempd17
      uyd(i-1, j, k) = uyd(i-1, j, k) + tempd17
      uyd(i, j, k) = uyd(i, j, k) + tempd17
      tempd18 = fourth*u_xd
      uxd(i-1, j-1, k) = uxd(i-1, j-1, k) + tempd18
      uxd(i, j-1, k) = uxd(i, j-1, k) + tempd18
      uxd(i-1, j, k) = uxd(i-1, j, k) + tempd18
      uxd(i, j, k) = uxd(i, j, k) + tempd18
      muld = mutd + factlamheat*heatcoefd
      mued = mued + mutd + factturbheat*heatcoefd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        revd(i, j, k) = revd(i, j, k) + por*mued
        revd(i, j, k+1) = revd(i, j, k+1) + por*mued
        mued = 0.0_8
      end if
      rlvd(i, j, k) = rlvd(i, j, k) + por*muld
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + por*muld
    end do
  end if
end subroutine viscousflux_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module zipperintegrations_b
  implicit none

contains
!  differentiation of flowintegrationzipper in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: alpha beta pointref timeref
!                tref rgas pref rhoref funcvalues vars localvalues
!   with respect to varying inputs: alpha beta pointref timeref
!                tref rgas pref rhoref funcvalues vars localvalues
!   rw status of diff variables: alpha:incr beta:incr pointref:incr
!                timeref:incr tref:incr rgas:incr pref:incr rhoref:incr
!                funcvalues:incr vars:incr localvalues:in-out
  subroutine flowintegrationzipper_b(isinflow, conn, fams, vars, varsd, &
&   localvalues, localvaluesd, famlist, sps, withgathered, funcvalues, &
&   funcvaluesd, ptvalid)
! integrate over the trianges for the inflow/outflow conditions. 
    use constants
    use blockpointers, only : bctype
    use sorting, only : faminlist
    use flowvarrefstate, only : pref, prefd, pinf, pinfd, rhoref, &
&   rhorefd, pref, prefd, timeref, timerefd, lref, tref, trefd, rgas, &
&   rgasd, uref, urefd, uinf, uinfd
    use inputphysics, only : pointref, pointrefd, flowtype, &
&   veldirfreestream, veldirfreestreamd, alpha, alphad, beta, betad, &
&   liftindex
    use flowutils_b, only : computeptot, computeptot_b, computettot, &
&   computettot_b, getdirvector, getdirvector_b
    use surfacefamilies, only : familyexchange, bcfamexchange
    use utils_b, only : mynorm2, mynorm2_b, cross_prod, cross_prod_b
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    integer(kind=inttype), dimension(:, :), intent(in) :: conn
    integer(kind=inttype), dimension(:), intent(in) :: fams
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), dimension(:, :) :: varsd
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvaluesd
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: withgathered
    real(kind=realtype), dimension(:), optional, intent(in) :: &
&   funcvalues
    real(kind=realtype), dimension(:), optional :: funcvaluesd
    logical(kind=inttype), dimension(:), optional, intent(in) :: ptvalid
! working variables
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, fx, fy, fz, &
&   cellarea, u, v, w, vnmfreestreamref
    real(kind=realtype) :: sfd, vmagd, vnmd, vxmd, vymd, vzmd, fxd, fyd&
&   , fzd, cellaread, ud, vd, wd, vnmfreestreamrefd
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   ss, x1, x2, x3, norm, vcoordref, vfreestreamref, sfacefreestreamref&
&   , normfreestreamref
    real(kind=realtype), dimension(3) :: fpd, mpd, fmomd, mmomd, &
&   refpointd, ssd, x1d, x2d, x3d, normd, vcoordrefd, vfreestreamrefd, &
&   sfacefreestreamrefd, normfreestreamrefd
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, mnm, &
&   massflowratelocal
    real(kind=realtype) :: pmd, ptotd, ttotd, rhomd, gammamd, mnmd, &
&   massflowratelocald
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn
    real(kind=realtype) :: massflowrated, mass_ptotd, mass_ttotd, &
&   mass_psd, mass_mnd
    real(kind=realtype) :: mredim, pk, sigma_mn, sigma_ptot
    real(kind=realtype) :: mredimd, pkd, sigma_mnd, sigma_ptotd
    real(kind=realtype) :: internalflowfact, inflowfact, xc, yc, zc, mx&
&   , my, mz
    real(kind=realtype) :: xcd, ycd, zcd, mxd, myd, mzd
    real(kind=realtype) :: edota, edotv, edotp
    real(kind=realtype) :: edotad, edotvd, edotpd
    logical :: triisvalid
    intrinsic sqrt
    intrinsic size
    intrinsic present
    intrinsic abs
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1d
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype), dimension(3) :: arg2d
    logical :: res
    real(kind=realtype) :: arg20
    real(kind=realtype) :: arg10
    real(kind=realtype) :: arg21
    real(kind=realtype) :: arg11
    integer :: branch
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: abs1d
    real(kind=realtype) :: abs0d
    real(kind=realtype) :: arg1d1
    real(kind=realtype) :: arg1d0
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: arg2d1
    real(kind=realtype) :: arg2d0
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: tempd15
    real(kind=realtype) :: temp4
    mredim = sqrt(pref*rhoref)
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
    if (withgathered) then
      sigma_ptotd = localvaluesd(isigmaptot)
      sigma_mnd = localvaluesd(isigmamn)
      edotpd = 0.0_8
      mass_ptotd = 0.0_8
      edotvd = 0.0_8
      mmomd = 0.0_8
      mass_psd = 0.0_8
      mass_mnd = 0.0_8
      mass_ttotd = 0.0_8
      fpd = 0.0_8
      pkd = 0.0_8
      fmomd = 0.0_8
      edotad = 0.0_8
      massflowrated = 0.0_8
      mpd = 0.0_8
    else
      mmomd = 0.0_8
      mmomd = localvaluesd(iflowmm:iflowmm+2)
      mpd = 0.0_8
      mpd = localvaluesd(iflowmp:iflowmp+2)
      fmomd = 0.0_8
      fmomd = localvaluesd(iflowfm:iflowfm+2)
      fpd = 0.0_8
      fpd = localvaluesd(ifp:ifp+2)
      edotad = localvaluesd(iedota) + localvaluesd(iedot)
      edotvd = localvaluesd(iedotv) + localvaluesd(iedot)
      edotpd = localvaluesd(iedotp) + localvaluesd(iedot)
      pkd = localvaluesd(ipk)
      mass_mnd = localvaluesd(imassmn)
      mass_psd = localvaluesd(imassps)
      mass_ttotd = localvaluesd(imassttot)
      mass_ptotd = localvaluesd(imassptot)
      massflowrated = localvaluesd(imassflow)
      sigma_mnd = 0.0_8
      sigma_ptotd = 0.0_8
    end if
    mredimd = 0.0_8
    vfreestreamrefd = 0.0_8
    vcoordrefd = 0.0_8
    normd = 0.0_8
    ptotd = 0.0_8
    refpointd = 0.0_8
    normfreestreamrefd = 0.0_8
    ttotd = 0.0_8
    do i=1,size(conn, 2)
      res = faminlist(fams(i), famlist)
      if (res) then
! if the ptvalid list is given, check if we should integrate
! this triangle.
        triisvalid = .true.
        if (present(ptvalid)) then
! check if each of the three nodes are valid
          if (((ptvalid(conn(1, i)) .eqv. .false.) .or. (ptvalid(conn(2&
&             , i)) .eqv. .false.)) .or. (ptvalid(conn(3, i)) .eqv. &
&             .false.)) triisvalid = .false.
        end if
        if (triisvalid) then
! compute the averaged values for this triangle
          vxm = zero
          vym = zero
          vzm = zero
          rhom = zero
          pm = zero
          gammam = zero
          sf = zero
          do j=1,3
            rhom = rhom + vars(conn(j, i), irho)
            vxm = vxm + vars(conn(j, i), ivx)
            vym = vym + vars(conn(j, i), ivy)
            vzm = vzm + vars(conn(j, i), ivz)
            pm = pm + vars(conn(j, i), irhoe)
            gammam = gammam + vars(conn(j, i), izippflowgamma)
            sf = sf + vars(conn(j, i), izippflowsface)
          end do
! divide by 3 due to the summation above:
          rhom = third*rhom
          vxm = third*vxm
          vym = third*vym
          vzm = third*vzm
          pm = third*pm
          gammam = third*gammam
          sf = third*sf
! get the nodes of triangle.
          x1 = vars(conn(1, i), izippflowx:izippflowz)
          x2 = vars(conn(2, i), izippflowx:izippflowz)
          x3 = vars(conn(3, i), izippflowx:izippflowz)
          arg1(:) = x2 - x1
          arg2(:) = x3 - x1
          call cross_prod(arg1(:), arg2(:), norm)
          ss = half*norm
          call computeptot(rhom, vxm, vym, vzm, pm, ptot)
          call computettot(rhom, vxm, vym, vzm, pm, ttot)
          vnm = vxm*ss(1) + vym*ss(2) + vzm*ss(3) - sf
          vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
! a = sqrt(gamma*p/rho); sqrt(v**2/a**2)
          mnm = vmag/sqrt(gammam*pm/rhom)
          cellarea = sqrt(ss(1)**2 + ss(2)**2 + ss(3)**2)
          massflowratelocal = rhom*vnm*mredim
          if (withgathered) then
            if (massflowratelocal .ge. 0.) then
              abs0 = massflowratelocal
              call pushcontrol1b(0)
            else
              abs0 = -massflowratelocal
              call pushcontrol1b(1)
            end if
            call pushreal8(ptot)
            ptot = ptot*pref
            if (massflowratelocal .ge. 0.) then
              abs1 = massflowratelocal
              call pushcontrol1b(0)
            else
              abs1 = -massflowratelocal
              call pushcontrol1b(1)
            end if
            tempd4 = abs1*2*(ptot-funcvalues(costfuncmavgptot))*&
&             sigma_ptotd
            abs1d = (ptot-funcvalues(costfuncmavgptot))**2*sigma_ptotd
            ptotd = ptotd + tempd4
            funcvaluesd(costfuncmavgptot) = funcvaluesd(costfuncmavgptot&
&             ) - tempd4
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              massflowratelocald = abs1d
            else
              massflowratelocald = -abs1d
            end if
            call popreal8(ptot)
            prefd = prefd + ptot*ptotd
            ptotd = pref*ptotd
            tempd3 = abs0*2*(mnm-funcvalues(costfuncmavgmn))*sigma_mnd
            abs0d = (mnm-funcvalues(costfuncmavgmn))**2*sigma_mnd
            mnmd = tempd3
            funcvaluesd(costfuncmavgmn) = funcvaluesd(costfuncmavgmn) - &
&             tempd3
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              massflowratelocald = massflowratelocald + abs0d
            else
              massflowratelocald = massflowratelocald - abs0d
            end if
            vnmd = 0.0_8
            vxmd = 0.0_8
            vymd = 0.0_8
            sfd = 0.0_8
            rhomd = 0.0_8
            cellaread = 0.0_8
            ssd = 0.0_8
            pmd = 0.0_8
            vzmd = 0.0_8
            vmagd = 0.0_8
          else
! computes the normalized vector maped into the freestream direction, so we multiply by the magnitude after
            vcoordref(1) = vxm
            vcoordref(2) = vym
            vcoordref(3) = vzm
            arg20 = -beta
            arg10 = -alpha
            call getdirvector(vcoordref, arg10, arg20, vfreestreamref, &
&                       liftindex)
            call pushreal8array(vfreestreamref, 3)
            vfreestreamref = vfreestreamref*vmag
!project the face normal into the freestream velocity and scale by the face
            arg21 = -beta
            arg11 = -alpha
            call getdirvector(ss, arg11, arg21, normfreestreamref, &
&                       liftindex)
! note that normfreestreamref is of magnitude 1 now
            sfacefreestreamref = normfreestreamref*sf
! compute the pertubations of the flow from the free-stream velocity
            u = vfreestreamref(1) - sfacefreestreamref(1) - uinf
            v = vfreestreamref(2) - sfacefreestreamref(2)
            w = vfreestreamref(3) - sfacefreestreamref(3)
            vnmfreestreamref = (u+uinf)*normfreestreamref(1) + v*&
&             normfreestreamref(2) + w*normfreestreamref(3)
            call pushreal8(vnmfreestreamref)
            vnmfreestreamref = vnmfreestreamref*cellarea
            call pushreal8(pm)
            pm = pm*pref
! compute the average cell center. 
            xc = zero
            yc = zero
            zc = zero
            do j=1,3
              xc = xc + vars(conn(1, i), izippflowx)
              yc = yc + vars(conn(2, i), izippflowy)
              zc = zc + vars(conn(3, i), izippflowz)
            end do
! finish average for cell center
            xc = third*xc
            yc = third*yc
            zc = third*zc
            xc = xc - refpoint(1)
            yc = yc - refpoint(2)
            zc = zc - refpoint(3)
            call pushreal8(pm)
            pm = -(pm-pinf*pref)
! update the pressure force and moment coefficients.
! momentum forces
! get unit normal vector. 
            call pushreal8array(ss, 3)
            ss = ss/cellarea
            call pushreal8(massflowratelocal)
            massflowratelocal = massflowratelocal/timeref*&
&             internalflowfact*inflowfact
            fx = massflowratelocal*ss(1)*vxm/timeref
            fy = massflowratelocal*ss(2)*vym/timeref
            fz = massflowratelocal*ss(3)*vzm/timeref
            temp2 = ss(1)/timeref
            temp3 = ss(2)/timeref
            mzd = mmomd(3)
            myd = mmomd(2)
            mxd = mmomd(1)
            xcd = fy*mzd - fz*myd
            fyd = xc*mzd - fmomd(2) - zc*mxd
            ycd = fz*mxd - fx*mzd
            fxd = zc*myd - fmomd(1) - yc*mzd
            zcd = fx*myd - fy*mxd
            fzd = yc*mxd - fmomd(3) - xc*myd
            ssd = 0.0_8
            tempd17 = massflowratelocal*vzm*fzd/timeref
            temp4 = ss(3)/timeref
            ssd(3) = ssd(3) + tempd17
            massflowratelocald = temp3*vym*fyd + temp2*vxm*fxd + temp4*&
&             vzm*fzd
            vzmd = temp4*massflowratelocal*fzd
            tempd18 = massflowratelocal*vym*fyd/timeref
            ssd(2) = ssd(2) + tempd18
            vymd = temp3*massflowratelocal*fyd
            tempd20 = massflowratelocal*vxm*fxd/timeref
            ssd(1) = ssd(1) + tempd20
            vxmd = temp2*massflowratelocal*fxd
            call popreal8(massflowratelocal)
            tempd19 = internalflowfact*inflowfact*massflowratelocald/&
&             timeref
            timerefd = timerefd - temp3*tempd18 - massflowratelocal*&
&             tempd19/timeref - temp2*tempd20 - temp4*tempd17
            massflowratelocald = tempd19
            call popreal8array(ss, 3)
            cellaread = sum(-(ss*ssd/cellarea))/cellarea
            ssd = ssd/cellarea
            mzd = mpd(3)
            myd = mpd(2)
            mxd = mpd(1)
            fx = pm*ss(1)
            fy = pm*ss(2)
            fyd = fpd(2) - zc*mxd + xc*mzd
            fxd = zc*myd + fpd(1) - yc*mzd
            fz = pm*ss(3)
            xcd = xcd + fy*mzd - fz*myd
            ycd = ycd + fz*mxd - fx*mzd
            zcd = zcd + fx*myd - fy*mxd
            fzd = yc*mxd + fpd(3) - xc*myd
            pmd = ss(2)*fyd + ss(1)*fxd + ss(3)*fzd
            ssd(3) = ssd(3) + pm*fzd
            ssd(2) = ssd(2) + pm*fyd
            ssd(1) = ssd(1) + pm*fxd
            call popreal8(pm)
            prefd = prefd + pinf*pmd
            pmd = -pmd
            refpointd(3) = refpointd(3) - zcd
            refpointd(2) = refpointd(2) - ycd
            refpointd(1) = refpointd(1) - xcd
            zcd = third*zcd
            ycd = third*ycd
            xcd = third*xcd
            do j=3,1,-1
              varsd(conn(3, i), izippflowz) = varsd(conn(3, i), &
&               izippflowz) + zcd
              varsd(conn(2, i), izippflowy) = varsd(conn(2, i), &
&               izippflowy) + ycd
              varsd(conn(1, i), izippflowx) = varsd(conn(1, i), &
&               izippflowx) + xcd
            end do
            tempd16 = uref*internalflowfact*pkd
            tempd9 = vnm*pref*tempd16
            temp1 = vmag**2 - uinf**2
            tempd15 = half*uref*internalflowfact*edotad
            tempd14 = u**2*pref*tempd15
            mnmd = massflowratelocal*mass_mnd
            massflowratelocald = massflowratelocald + pm*mass_psd + pref&
&             *ptot*mass_ptotd + massflowrated + tref*ttot*mass_ttotd + &
&             mnm*mass_mnd
            pmd = pmd + massflowratelocal*mass_psd
            ttotd = ttotd + tref*massflowratelocal*mass_ttotd
            trefd = trefd + ttot*massflowratelocal*mass_ttotd
            ptotd = ptotd + pref*massflowratelocal*mass_ptotd
            call popreal8(pm)
            tempd10 = uref*internalflowfact*edotpd
            tempd8 = (vnm-uinf*(normfreestreamref(1)*cellarea))*tempd10
            tempd11 = (pm-pinf)*pref*tempd10
            tempd12 = half*uref*internalflowfact*edotvd
            tempd13 = rhom*vnmfreestreamref*pref*tempd12
            tempd5 = (v**2+w**2)*tempd12
            rhomd = vnmfreestreamref*tempd14 + half*temp1*tempd9 + pref*&
&             vnmfreestreamref*tempd5
            vnmfreestreamrefd = rhom*tempd14 + pref*rhom*tempd5
            tempd7 = rhom*vnmfreestreamref*tempd15
            sfacefreestreamrefd = 0.0_8
            arg1d1 = 0.0_8
            arg2d1 = 0.0_8
            arg1d0 = 0.0_8
            arg2d0 = 0.0_8
            tempd6 = (pm-pinf+half*(rhom*temp1))*tempd16
            prefd = prefd + pm*pmd + rhom*vnmfreestreamref*tempd5 + vnm*&
&             tempd6 + u**2*tempd7 + (pm-pinf)*tempd8 + ptot*&
&             massflowratelocal*mass_ptotd
            pmd = pref*tempd8 + tempd9 + pref*pmd
            vnmd = pref*tempd6 + tempd11
            call popreal8(vnmfreestreamref)
            cellaread = cellaread + vnmfreestreamref*vnmfreestreamrefd -&
&             uinf*normfreestreamref(1)*tempd11
            vnmfreestreamrefd = cellarea*vnmfreestreamrefd
            normfreestreamrefd(1) = normfreestreamrefd(1) + (uinf+u)*&
&             vnmfreestreamrefd - uinf*cellarea*tempd11
            vd = normfreestreamref(2)*vnmfreestreamrefd + 2*v*tempd13
            wd = normfreestreamref(3)*vnmfreestreamrefd + 2*w*tempd13
            ud = normfreestreamref(1)*vnmfreestreamrefd + pref*2*u*&
&             tempd7
            normfreestreamrefd(2) = normfreestreamrefd(2) + v*&
&             vnmfreestreamrefd
            normfreestreamrefd(3) = normfreestreamrefd(3) + w*&
&             vnmfreestreamrefd
            vfreestreamrefd(3) = vfreestreamrefd(3) + wd
            sfacefreestreamrefd(3) = sfacefreestreamrefd(3) - wd
            vfreestreamrefd(2) = vfreestreamrefd(2) + vd
            sfacefreestreamrefd(2) = sfacefreestreamrefd(2) - vd
            vfreestreamrefd(1) = vfreestreamrefd(1) + ud
            sfacefreestreamrefd(1) = sfacefreestreamrefd(1) - ud
            normfreestreamrefd = normfreestreamrefd + sf*&
&             sfacefreestreamrefd
            sfd = sum(normfreestreamref*sfacefreestreamrefd)
            call getdirvector_b(ss, ssd, arg11, arg1d1, arg21, arg2d1, &
&                         normfreestreamref, normfreestreamrefd, &
&                         liftindex)
            call popreal8array(vfreestreamref, 3)
            vmagd = rhom*half*2*vmag*tempd9 + sum(vfreestreamref*&
&             vfreestreamrefd)
            vfreestreamrefd = vmag*vfreestreamrefd
            call getdirvector_b(vcoordref, vcoordrefd, arg10, arg1d0, &
&                         arg20, arg2d0, vfreestreamref, vfreestreamrefd&
&                         , liftindex)
            alphad = alphad - arg1d0 - arg1d1
            betad = betad - arg2d0 - arg2d1
            vzmd = vzmd + vcoordrefd(3)
            vcoordrefd(3) = 0.0_8
            vymd = vymd + vcoordrefd(2)
            vcoordrefd(2) = 0.0_8
            vxmd = vxmd + vcoordrefd(1)
            vcoordrefd(1) = 0.0_8
          end if
          temp = gammam*pm/rhom
          temp0 = sqrt(temp)
          if (temp .eq. 0.0_8) then
            tempd0 = 0.0
          else
            tempd0 = -(vmag*mnmd/(2.0*temp0**3*rhom))
          end if
          rhomd = rhomd + mredim*vnm*massflowratelocald - temp*tempd0
          vnmd = vnmd + mredim*rhom*massflowratelocald
          mredimd = mredimd + rhom*vnm*massflowratelocald
          if (ss(1)**2 + ss(2)**2 + ss(3)**2 .eq. 0.0_8) then
            tempd1 = 0.0
          else
            tempd1 = cellaread/(2.0*sqrt(ss(1)**2+ss(2)**2+ss(3)**2))
          end if
          ssd(1) = ssd(1) + 2*ss(1)*tempd1
          ssd(2) = ssd(2) + 2*ss(2)*tempd1
          ssd(3) = ssd(3) + 2*ss(3)*tempd1
          vmagd = vmagd + mnmd/temp0
          gammamd = pm*tempd0
          pmd = pmd + gammam*tempd0
          if (vxm**2 + vym**2 + vzm**2 .eq. 0.0_8) then
            tempd2 = 0.0
          else
            tempd2 = vmagd/(2.0*sqrt(vxm**2+vym**2+vzm**2))
          end if
          vxmd = vxmd + ss(1)*vnmd + 2*vxm*tempd2
          vymd = vymd + ss(2)*vnmd + 2*vym*tempd2
          vzmd = vzmd + ss(3)*vnmd + 2*vzm*tempd2
          sfd = sfd - vnmd - vmagd
          ssd(1) = ssd(1) + vxm*vnmd
          ssd(2) = ssd(2) + vym*vnmd
          ssd(3) = ssd(3) + vzm*vnmd
          call computettot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, &
&                      vzmd, pm, pmd, ttot, ttotd)
          call computeptot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, &
&                      vzmd, pm, pmd, ptot, ptotd)
          normd = normd + half*ssd
          call cross_prod_b(arg1(:), arg1d(:), arg2(:), arg2d(:), norm, &
&                     normd)
          x1d = 0.0_8
          x3d = 0.0_8
          x3d = arg2d(:)
          x1d = -arg1d(:) - arg2d(:)
          x2d = 0.0_8
          x2d = arg1d(:)
          varsd(conn(3, i), izippflowx:izippflowz) = varsd(conn(3, i), &
&           izippflowx:izippflowz) + x3d
          varsd(conn(2, i), izippflowx:izippflowz) = varsd(conn(2, i), &
&           izippflowx:izippflowz) + x2d
          varsd(conn(1, i), izippflowx:izippflowz) = varsd(conn(1, i), &
&           izippflowx:izippflowz) + x1d
          sfd = third*sfd
          gammamd = third*gammamd
          pmd = third*pmd
          vzmd = third*vzmd
          vymd = third*vymd
          vxmd = third*vxmd
          rhomd = third*rhomd
          do j=3,1,-1
            varsd(conn(j, i), izippflowsface) = varsd(conn(j, i), &
&             izippflowsface) + sfd
            varsd(conn(j, i), izippflowgamma) = varsd(conn(j, i), &
&             izippflowgamma) + gammamd
            varsd(conn(j, i), irhoe) = varsd(conn(j, i), irhoe) + pmd
            varsd(conn(j, i), ivz) = varsd(conn(j, i), ivz) + vzmd
            varsd(conn(j, i), ivy) = varsd(conn(j, i), ivy) + vymd
            varsd(conn(j, i), ivx) = varsd(conn(j, i), ivx) + vxmd
            varsd(conn(j, i), irho) = varsd(conn(j, i), irho) + rhomd
          end do
        end if
      end if
    end do
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
    if (pref*rhoref .eq. 0.0_8) then
      tempd = 0.0
    else
      tempd = mredimd/(2.0*sqrt(pref*rhoref))
    end if
    prefd = prefd + rhoref*tempd
    rhorefd = rhorefd + pref*tempd
  end subroutine flowintegrationzipper_b
  subroutine flowintegrationzipper(isinflow, conn, fams, vars, &
&   localvalues, famlist, sps, withgathered, funcvalues, ptvalid)
! integrate over the trianges for the inflow/outflow conditions. 
    use constants
    use blockpointers, only : bctype
    use sorting, only : faminlist
    use flowvarrefstate, only : pref, pinf, rhoref, pref, timeref, &
&   lref, tref, rgas, uref, uinf
    use inputphysics, only : pointref, flowtype, veldirfreestream, &
&   alpha, beta, liftindex
    use flowutils_b, only : computeptot, computettot, getdirvector
    use surfacefamilies, only : familyexchange, bcfamexchange
    use utils_b, only : mynorm2, cross_prod
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    integer(kind=inttype), dimension(:, :), intent(in) :: conn
    integer(kind=inttype), dimension(:), intent(in) :: fams
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
    logical, intent(in) :: withgathered
    real(kind=realtype), dimension(:), optional, intent(in) :: &
&   funcvalues
    logical(kind=inttype), dimension(:), optional, intent(in) :: ptvalid
! working variables
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, fx, fy, fz, &
&   cellarea, u, v, w, vnmfreestreamref
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   ss, x1, x2, x3, norm, vcoordref, vfreestreamref, sfacefreestreamref&
&   , normfreestreamref
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, mnm, &
&   massflowratelocal
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn
    real(kind=realtype) :: mredim, pk, sigma_mn, sigma_ptot
    real(kind=realtype) :: internalflowfact, inflowfact, xc, yc, zc, mx&
&   , my, mz
    real(kind=realtype) :: edota, edotv, edotp
    logical :: triisvalid
    intrinsic sqrt
    intrinsic size
    intrinsic present
    intrinsic abs
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    mredim = sqrt(pref*rhoref)
    fp = zero
    mp = zero
    fmom = zero
    mmom = zero
    massflowrate = zero
    mass_ptot = zero
    mass_ttot = zero
    mass_ps = zero
    edota = zero
    edotv = zero
    edotp = zero
    sigma_mn = zero
    sigma_ptot = zero
    pk = zero
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
    do i=1,size(conn, 2)
      if (faminlist(fams(i), famlist)) then
! if the ptvalid list is given, check if we should integrate
! this triangle.
        triisvalid = .true.
        if (present(ptvalid)) then
! check if each of the three nodes are valid
          if (((ptvalid(conn(1, i)) .eqv. .false.) .or. (ptvalid(conn(2&
&             , i)) .eqv. .false.)) .or. (ptvalid(conn(3, i)) .eqv. &
&             .false.)) triisvalid = .false.
        end if
        if (triisvalid) then
! compute the averaged values for this triangle
          vxm = zero
          vym = zero
          vzm = zero
          rhom = zero
          pm = zero
          mnm = zero
          gammam = zero
          sf = zero
          do j=1,3
            rhom = rhom + vars(conn(j, i), irho)
            vxm = vxm + vars(conn(j, i), ivx)
            vym = vym + vars(conn(j, i), ivy)
            vzm = vzm + vars(conn(j, i), ivz)
            pm = pm + vars(conn(j, i), irhoe)
            gammam = gammam + vars(conn(j, i), izippflowgamma)
            sf = sf + vars(conn(j, i), izippflowsface)
          end do
! divide by 3 due to the summation above:
          rhom = third*rhom
          vxm = third*vxm
          vym = third*vym
          vzm = third*vzm
          pm = third*pm
          gammam = third*gammam
          sf = third*sf
! get the nodes of triangle.
          x1 = vars(conn(1, i), izippflowx:izippflowz)
          x2 = vars(conn(2, i), izippflowx:izippflowz)
          x3 = vars(conn(3, i), izippflowx:izippflowz)
          arg1(:) = x2 - x1
          arg2(:) = x3 - x1
          call cross_prod(arg1(:), arg2(:), norm)
          ss = half*norm
          call computeptot(rhom, vxm, vym, vzm, pm, ptot)
          call computettot(rhom, vxm, vym, vzm, pm, ttot)
          vnm = vxm*ss(1) + vym*ss(2) + vzm*ss(3) - sf
          vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
! a = sqrt(gamma*p/rho); sqrt(v**2/a**2)
          mnm = vmag/sqrt(gammam*pm/rhom)
          cellarea = sqrt(ss(1)**2 + ss(2)**2 + ss(3)**2)
          massflowratelocal = rhom*vnm*mredim
          if (withgathered) then
            if (massflowratelocal .ge. 0.) then
              abs0 = massflowratelocal
            else
              abs0 = -massflowratelocal
            end if
            sigma_mn = sigma_mn + abs0*(mnm-funcvalues(costfuncmavgmn))&
&             **2
            ptot = ptot*pref
            if (massflowratelocal .ge. 0.) then
              abs1 = massflowratelocal
            else
              abs1 = -massflowratelocal
            end if
            sigma_ptot = sigma_ptot + abs1*(ptot-funcvalues(&
&             costfuncmavgptot))**2
          else
            massflowrate = massflowrate + massflowratelocal
            pk = pk + (pm-pinf+half*rhom*(vmag**2-uinf**2))*vnm*pref*&
&             uref*internalflowfact
! computes the normalized vector maped into the freestream direction, so we multiply by the magnitude after
            vcoordref(1) = vxm
            vcoordref(2) = vym
            vcoordref(3) = vzm
            call getdirvector(vcoordref, -alpha, -beta, vfreestreamref, &
&                       liftindex)
            vfreestreamref = vfreestreamref*vmag
!project the face normal into the freestream velocity and scale by the face
            call getdirvector(ss, -alpha, -beta, normfreestreamref, &
&                       liftindex)
! note that normfreestreamref is of magnitude 1 now
            sfacefreestreamref = normfreestreamref*sf
! compute the pertubations of the flow from the free-stream velocity
            u = vfreestreamref(1) - sfacefreestreamref(1) - uinf
            v = vfreestreamref(2) - sfacefreestreamref(2)
            w = vfreestreamref(3) - sfacefreestreamref(3)
            vnmfreestreamref = (u+uinf)*normfreestreamref(1) + v*&
&             normfreestreamref(2) + w*normfreestreamref(3)
            vnmfreestreamref = vnmfreestreamref*cellarea
            edota = edota + half*rhom*u**2*vnmfreestreamref*pref*uref*&
&             internalflowfact
            edotv = edotv + half*rhom*(v**2+w**2)*vnmfreestreamref*pref*&
&             uref*internalflowfact
            edotp = edotp + (pm-pinf)*(vnm-uinf*normfreestreamref(1)*&
&             cellarea)*pref*uref*internalflowfact
            pm = pm*pref
            mass_ptot = mass_ptot + ptot*massflowratelocal*pref
            mass_ttot = mass_ttot + ttot*massflowratelocal*tref
            mass_ps = mass_ps + pm*massflowratelocal
            mass_mn = mass_mn + mnm*massflowratelocal
! compute the average cell center. 
            xc = zero
            yc = zero
            zc = zero
            do j=1,3
              xc = xc + vars(conn(1, i), izippflowx)
              yc = yc + vars(conn(2, i), izippflowy)
              zc = zc + vars(conn(3, i), izippflowz)
            end do
! finish average for cell center
            xc = third*xc
            yc = third*yc
            zc = third*zc
            xc = xc - refpoint(1)
            yc = yc - refpoint(2)
            zc = zc - refpoint(3)
            pm = -(pm-pinf*pref)
            fx = pm*ss(1)
            fy = pm*ss(2)
            fz = pm*ss(3)
! update the pressure force and moment coefficients.
            fp(1) = fp(1) + fx
            fp(2) = fp(2) + fy
            fp(3) = fp(3) + fz
            mx = yc*fz - zc*fy
            my = zc*fx - xc*fz
            mz = xc*fy - yc*fx
            mp(1) = mp(1) + mx
            mp(2) = mp(2) + my
            mp(3) = mp(3) + mz
! momentum forces
! get unit normal vector. 
            ss = ss/cellarea
            massflowratelocal = massflowratelocal/timeref*&
&             internalflowfact*inflowfact
            fx = massflowratelocal*ss(1)*vxm/timeref
            fy = massflowratelocal*ss(2)*vym/timeref
            fz = massflowratelocal*ss(3)*vzm/timeref
            fmom(1) = fmom(1) - fx
            fmom(2) = fmom(2) - fy
            fmom(3) = fmom(3) - fz
            mx = yc*fz - zc*fy
            my = zc*fx - xc*fz
            mz = xc*fy - yc*fx
            mmom(1) = mmom(1) + mx
            mmom(2) = mmom(2) + my
            mmom(3) = mmom(3) + mz
          end if
        end if
      end if
    end do
    if (withgathered) then
      localvalues(isigmamn) = localvalues(isigmamn) + sigma_mn
      localvalues(isigmaptot) = localvalues(isigmaptot) + sigma_ptot
    else
! increment the local values array with what we computed here
      localvalues(imassflow) = localvalues(imassflow) + massflowrate
      localvalues(imassptot) = localvalues(imassptot) + mass_ptot
      localvalues(imassttot) = localvalues(imassttot) + mass_ttot
      localvalues(imassps) = localvalues(imassps) + mass_ps
      localvalues(imassmn) = localvalues(imassmn) + mass_mn
      localvalues(ipk) = localvalues(ipk) + pk
      localvalues(iedota) = localvalues(iedota) + edota
      localvalues(iedotv) = localvalues(iedotv) + edotv
      localvalues(iedotp) = localvalues(iedotp) + edotp
      localvalues(iedot) = localvalues(iedot) + edota + edotv + edotp
      localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
      localvalues(iflowfm:iflowfm+2) = localvalues(iflowfm:iflowfm+2) + &
&       fmom
      localvalues(iflowmp:iflowmp+2) = localvalues(iflowmp:iflowmp+2) + &
&       mp
      localvalues(iflowmm:iflowmm+2) = localvalues(iflowmm:iflowmm+2) + &
&       mmom
    end if
  end subroutine flowintegrationzipper
!  differentiation of wallintegrationzipper in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: pointref vars localvalues
!   with respect to varying inputs: pointref vars localvalues
!   rw status of diff variables: pointref:incr vars:incr localvalues:in-out
  subroutine wallintegrationzipper_b(conn, fams, vars, varsd, &
&   localvalues, localvaluesd, famlist, sps)
    use constants
    use sorting, only : faminlist
    use flowvarrefstate, only : lref
    use inputphysics, only : pointref, pointrefd
    use utils_b, only : mynorm2, mynorm2_b, cross_prod, cross_prod_b
    implicit none
! input/output
    integer(kind=inttype), dimension(:, :), intent(in) :: conn
    integer(kind=inttype), dimension(:), intent(in) :: fams
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), dimension(:, :) :: varsd
    real(kind=realtype), intent(inout) :: localvalues(nlocalvalues)
    real(kind=realtype) :: localvaluesd(nlocalvalues)
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
! working
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype), dimension(3) :: fpd, fvd, mpd, mvd
    integer(kind=inttype) :: i, j
    real(kind=realtype), dimension(3) :: ss, norm, refpoint
    real(kind=realtype), dimension(3) :: ssd, normd, refpointd
    real(kind=realtype), dimension(3) :: p1, p2, p3, v1, v2, v3, x1, x2&
&   , x3
    real(kind=realtype), dimension(3) :: p1d, p2d, p3d, v1d, v2d, v3d, &
&   x1d, x2d, x3d
    real(kind=realtype) :: fact, triarea, fx, fy, fz, mx, my, mz, xc, yc&
&   , zc
    real(kind=realtype) :: triaread, fxd, fyd, fzd, mxd, myd, mzd, xcd, &
&   ycd, zcd
    intrinsic size
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1d
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype), dimension(3) :: arg2d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    logical :: res
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    mvd = 0.0_8
    mvd = localvaluesd(imv:imv+2)
    mpd = 0.0_8
    mpd = localvaluesd(imp:imp+2)
    fvd = 0.0_8
    fvd = localvaluesd(ifv:ifv+2)
    fpd = 0.0_8
    fpd = localvaluesd(ifp:ifp+2)
    normd = 0.0_8
    refpointd = 0.0_8
    do i=1,size(conn, 2)
      res = faminlist(fams(i), famlist)
      if (res) then
! get the nodes of triangle. 
        x1 = vars(conn(1, i), izippwallx:izippwallz)
        x2 = vars(conn(2, i), izippwallx:izippwallz)
        x3 = vars(conn(3, i), izippwallx:izippwallz)
        arg1(:) = x2 - x1
        arg2(:) = x3 - x1
        call cross_prod(arg1(:), arg2(:), norm)
        ss = half*norm
! the third here is to account for the summation of p1, p2
! and p3
        result1 = mynorm2(ss)
        triarea = result1*third
! compute the average cell center. 
        xc = third*(x1(1)+x2(1)+x3(1))
        yc = third*(x1(2)+x2(2)+x3(2))
        zc = third*(x1(3)+x2(3)+x3(3))
        xc = xc - refpoint(1)
        yc = yc - refpoint(2)
        zc = zc - refpoint(3)
! update the pressure force and moment coefficients.
        p1 = vars(conn(1, i), izippwalltpx:izippwalltpz)
        p2 = vars(conn(2, i), izippwalltpx:izippwalltpz)
        p3 = vars(conn(3, i), izippwalltpx:izippwalltpz)
! update the viscous force and moment coefficients
        v1 = vars(conn(1, i), izippwalltvx:izippwalltvz)
        v2 = vars(conn(2, i), izippwalltvx:izippwalltvz)
        v3 = vars(conn(3, i), izippwalltvx:izippwalltvz)
        fx = (v1(1)+v2(1)+v3(1))*triarea
        fy = (v1(2)+v2(2)+v3(2))*triarea
        fz = (v1(3)+v2(3)+v3(3))*triarea
! note: momentum forces have opposite sign to pressure forces
        mzd = mvd(3)
        myd = mvd(2)
        mxd = mvd(1)
        xcd = fy*mzd - fz*myd
        fyd = fvd(2) - zc*mxd + xc*mzd
        ycd = fz*mxd - fx*mzd
        fxd = zc*myd + fvd(1) - yc*mzd
        zcd = fx*myd - fy*mxd
        fzd = yc*mxd + fvd(3) - xc*myd
        v1d = 0.0_8
        v2d = 0.0_8
        v3d = 0.0_8
        tempd = triarea*fzd
        v1d(3) = v1d(3) + tempd
        v2d(3) = v2d(3) + tempd
        v3d(3) = v3d(3) + tempd
        triaread = (v1(2)+v2(2)+v3(2))*fyd + (v1(1)+v2(1)+v3(1))*fxd + (&
&         v1(3)+v2(3)+v3(3))*fzd
        tempd0 = triarea*fyd
        v1d(2) = v1d(2) + tempd0
        v2d(2) = v2d(2) + tempd0
        v3d(2) = v3d(2) + tempd0
        tempd1 = triarea*fxd
        v1d(1) = v1d(1) + tempd1
        v2d(1) = v2d(1) + tempd1
        v3d(1) = v3d(1) + tempd1
        varsd(conn(3, i), izippwalltvx:izippwalltvz) = varsd(conn(3, i)&
&         , izippwalltvx:izippwalltvz) + v3d
        varsd(conn(2, i), izippwalltvx:izippwalltvz) = varsd(conn(2, i)&
&         , izippwalltvx:izippwalltvz) + v2d
        varsd(conn(1, i), izippwalltvx:izippwalltvz) = varsd(conn(1, i)&
&         , izippwalltvx:izippwalltvz) + v1d
        mzd = mpd(3)
        myd = mpd(2)
        mxd = mpd(1)
        fx = (p1(1)+p2(1)+p3(1))*triarea
        fy = (p1(2)+p2(2)+p3(2))*triarea
        fyd = fpd(2) - zc*mxd + xc*mzd
        fxd = zc*myd + fpd(1) - yc*mzd
        fz = (p1(3)+p2(3)+p3(3))*triarea
        xcd = xcd + fy*mzd - fz*myd
        ycd = ycd + fz*mxd - fx*mzd
        zcd = zcd + fx*myd - fy*mxd
        fzd = yc*mxd + fpd(3) - xc*myd
        p1d = 0.0_8
        p2d = 0.0_8
        p3d = 0.0_8
        tempd2 = triarea*fzd
        p1d(3) = p1d(3) + tempd2
        p2d(3) = p2d(3) + tempd2
        p3d(3) = p3d(3) + tempd2
        triaread = triaread + (p1(2)+p2(2)+p3(2))*fyd + (p1(1)+p2(1)+p3(&
&         1))*fxd + (p1(3)+p2(3)+p3(3))*fzd
        tempd3 = triarea*fyd
        p1d(2) = p1d(2) + tempd3
        p2d(2) = p2d(2) + tempd3
        p3d(2) = p3d(2) + tempd3
        tempd4 = triarea*fxd
        p1d(1) = p1d(1) + tempd4
        p2d(1) = p2d(1) + tempd4
        p3d(1) = p3d(1) + tempd4
        varsd(conn(3, i), izippwalltpx:izippwalltpz) = varsd(conn(3, i)&
&         , izippwalltpx:izippwalltpz) + p3d
        varsd(conn(2, i), izippwalltpx:izippwalltpz) = varsd(conn(2, i)&
&         , izippwalltpx:izippwalltpz) + p2d
        varsd(conn(1, i), izippwalltpx:izippwalltpz) = varsd(conn(1, i)&
&         , izippwalltpx:izippwalltpz) + p1d
        refpointd(3) = refpointd(3) - zcd
        refpointd(2) = refpointd(2) - ycd
        refpointd(1) = refpointd(1) - xcd
        x1d = 0.0_8
        x2d = 0.0_8
        x3d = 0.0_8
        tempd5 = third*zcd
        x1d(3) = x1d(3) + tempd5
        x2d(3) = x2d(3) + tempd5
        x3d(3) = x3d(3) + tempd5
        tempd6 = third*ycd
        x1d(2) = x1d(2) + tempd6
        x2d(2) = x2d(2) + tempd6
        x3d(2) = x3d(2) + tempd6
        tempd7 = third*xcd
        x1d(1) = x1d(1) + tempd7
        x2d(1) = x2d(1) + tempd7
        x3d(1) = x3d(1) + tempd7
        result1d = third*triaread
        call mynorm2_b(ss, ssd, result1d)
        normd = normd + half*ssd
        call cross_prod_b(arg1(:), arg1d(:), arg2(:), arg2d(:), norm, &
&                   normd)
        x3d = x3d + arg2d
        x1d = x1d - arg1d - arg2d
        x2d = x2d + arg1d
        varsd(conn(3, i), izippwallx:izippwallz) = varsd(conn(3, i), &
&         izippwallx:izippwallz) + x3d
        varsd(conn(2, i), izippwallx:izippwallz) = varsd(conn(2, i), &
&         izippwallx:izippwallz) + x2d
        varsd(conn(1, i), izippwallx:izippwallz) = varsd(conn(1, i), &
&         izippwallx:izippwallz) + x1d
      end if
    end do
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine wallintegrationzipper_b
  subroutine wallintegrationzipper(conn, fams, vars, localvalues, &
&   famlist, sps)
    use constants
    use sorting, only : faminlist
    use flowvarrefstate, only : lref
    use inputphysics, only : pointref
    use utils_b, only : mynorm2, cross_prod
    implicit none
! input/output
    integer(kind=inttype), dimension(:, :), intent(in) :: conn
    integer(kind=inttype), dimension(:), intent(in) :: fams
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), intent(inout) :: localvalues(nlocalvalues)
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
! working
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    integer(kind=inttype) :: i, j
    real(kind=realtype), dimension(3) :: ss, norm, refpoint
    real(kind=realtype), dimension(3) :: p1, p2, p3, v1, v2, v3, x1, x2&
&   , x3
    real(kind=realtype) :: fact, triarea, fx, fy, fz, mx, my, mz, xc, yc&
&   , zc
    intrinsic size
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype) :: result1
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    fp = zero
    fv = zero
    mp = zero
    mv = zero
    do i=1,size(conn, 2)
      if (faminlist(fams(i), famlist)) then
! get the nodes of triangle. 
        x1 = vars(conn(1, i), izippwallx:izippwallz)
        x2 = vars(conn(2, i), izippwallx:izippwallz)
        x3 = vars(conn(3, i), izippwallx:izippwallz)
        arg1(:) = x2 - x1
        arg2(:) = x3 - x1
        call cross_prod(arg1(:), arg2(:), norm)
        ss = half*norm
! the third here is to account for the summation of p1, p2
! and p3
        result1 = mynorm2(ss)
        triarea = result1*third
! compute the average cell center. 
        xc = third*(x1(1)+x2(1)+x3(1))
        yc = third*(x1(2)+x2(2)+x3(2))
        zc = third*(x1(3)+x2(3)+x3(3))
        xc = xc - refpoint(1)
        yc = yc - refpoint(2)
        zc = zc - refpoint(3)
! update the pressure force and moment coefficients.
        p1 = vars(conn(1, i), izippwalltpx:izippwalltpz)
        p2 = vars(conn(2, i), izippwalltpx:izippwalltpz)
        p3 = vars(conn(3, i), izippwalltpx:izippwalltpz)
        fx = (p1(1)+p2(1)+p3(1))*triarea
        fy = (p1(2)+p2(2)+p3(2))*triarea
        fz = (p1(3)+p2(3)+p3(3))*triarea
        fp(1) = fp(1) + fx
        fp(2) = fp(2) + fy
        fp(3) = fp(3) + fz
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mp(1) = mp(1) + mx
        mp(2) = mp(2) + my
        mp(3) = mp(3) + mz
! update the viscous force and moment coefficients
        v1 = vars(conn(1, i), izippwalltvx:izippwalltvz)
        v2 = vars(conn(2, i), izippwalltvx:izippwalltvz)
        v3 = vars(conn(3, i), izippwalltvx:izippwalltvz)
        fx = (v1(1)+v2(1)+v3(1))*triarea
        fy = (v1(2)+v2(2)+v3(2))*triarea
        fz = (v1(3)+v2(3)+v3(3))*triarea
! note: momentum forces have opposite sign to pressure forces
        fv(1) = fv(1) + fx
        fv(2) = fv(2) + fy
        fv(3) = fv(3) + fz
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mv(1) = mv(1) + mx
        mv(2) = mv(2) + my
        mv(3) = mv(3) + mz
      end if
    end do
! increment into the local vector
    localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
    localvalues(ifv:ifv+2) = localvalues(ifv:ifv+2) + fv
    localvalues(imp:imp+2) = localvalues(imp:imp+2) + mp
    localvalues(imv:imv+2) = localvalues(imv:imv+2) + mv
  end subroutine wallintegrationzipper
end module zipperintegrations_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
! this module contains the source code related to the sa turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier. 
module samodule_b
  use constants
  implicit none
  real(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
  real(kind=realtype), dimension(:, :, :), allocatable :: qq
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall

contains
!  differentiation of sa_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw *w *rlv *vol *si *sj *sk
!                (global)timeref
!   with respect to varying inputs: *dw *w *rlv *vol *d2wall *si
!                sj 
!   plus diff mem management of: bvtj1:in bvtj2:in dw:in w:in rlv:in
!                scratch:in bvtk1:in bvtk2:in vol:in d2wall:in
!                si:in sj:in sk:in bvti1:in bvti2:in bcdata:in
  subroutine sa_block_b(resonly)
!
!       sa solves the transport equation for the spalart-allmaras      
!       turbulence model in a segregated manner using a diagonal       
!       dominant adi-scheme.                                           
!
    use blockpointers
    use inputtimespectral
    use iteration
    use inputphysics
    use paramturb
    implicit none
!
!      subroutine argument.
!
    logical, intent(in) :: resonly
!
!      local variables.
!
    integer(kind=inttype) :: nn, sps
    integer :: branch
!
!       begin execution                                                
! set the arrays for the boundary condition treatment.
    call pushreal8array(bmtj2, size(bmtj2, 1)*size(bmtj2, 2)*size(bmtj2&
&                 , 3)*size(bmtj2, 4))
    call pushreal8array(bmtj1, size(bmtj1, 1)*size(bmtj1, 2)*size(bmtj1&
&                 , 3)*size(bmtj1, 4))
    call pushreal8array(bmti2, size(bmti2, 1)*size(bmti2, 2)*size(bmti2&
&                 , 3)*size(bmti2, 4))
    call pushreal8array(bmti1, size(bmti1, 1)*size(bmti1, 2)*size(bmti1&
&                 , 3)*size(bmti1, 4))
    call pushreal8array(bmtk2, size(bmtk2, 1)*size(bmtk2, 2)*size(bmtk2&
&                 , 3)*size(bmtk2, 4))
    call pushreal8array(bmtk1, size(bmtk1, 1)*size(bmtk1, 2)*size(bmtk1&
&                 , 3)*size(bmtk1, 4))
    call bcturbtreatment()
! set model constants
    cv13 = rsacv1**3
    kar2inv = one/rsak**2
    cw36 = rsacw3**6
    cb3inv = one/rsacb3
! run the necessary code to setup and solve the sa transport
! equation for nutilde.
! production terms
    select case  (turbprod) 
    case (strain) 
      call prodsmag2()
      call pushcontrol2b(1)
    case (vorticity) 
      call prodwmag2()
      call pushcontrol2b(2)
    case (katolaunder) 
      call prodkatolaunder()
      call pushcontrol2b(3)
    case default
      call pushcontrol2b(0)
    end select
! alloc central jacobian memory
    allocate(qq(2:il, 2:jl, 2:kl))
! source terms
    call pushreal8array(scratch, size(scratch, 1)*size(scratch, 2)*size(&
&                 scratch, 3)*size(scratch, 4))
    call sasource()
! advection term
    nn = itu1 - 1
    call turbadvection(1_inttype, 1_inttype, nn, qq)
! unsteady term
    call unsteadyturbterm(1_inttype, 1_inttype, nn, qq)
! viscous terms
    call saviscous()
! perform the residual scaling
! we need to do an acutal solve. solve and update the eddy
! viscosity and the boundary conditions
    call saresscale_b()
    call saviscous_b()
    call unsteadyturbterm_b(1_inttype, 1_inttype, nn, qq)
    call turbadvection_b(1_inttype, 1_inttype, nn, qq)
    call popreal8array(scratch, size(scratch, 1)*size(scratch, 2)*size(&
&                scratch, 3)*size(scratch, 4))
    call sasource_b()
    call popcontrol2b(branch)
    if (branch .lt. 2) then
      if (branch .ne. 0) call prodsmag2_b()
    else if (branch .eq. 2) then
      call prodwmag2_b()
    else
      call prodkatolaunder_b()
    end if
    call popreal8array(bmtk1, size(bmtk1, 1)*size(bmtk1, 2)*size(bmtk1, &
&                3)*size(bmtk1, 4))
    call popreal8array(bmtk2, size(bmtk2, 1)*size(bmtk2, 2)*size(bmtk2, &
&                3)*size(bmtk2, 4))
    call popreal8array(bmti1, size(bmti1, 1)*size(bmti1, 2)*size(bmti1, &
&                3)*size(bmti1, 4))
    call popreal8array(bmti2, size(bmti2, 1)*size(bmti2, 2)*size(bmti2, &
&                3)*size(bmti2, 4))
    call popreal8array(bmtj1, size(bmtj1, 1)*size(bmtj1, 2)*size(bmtj1, &
&                3)*size(bmtj1, 4))
    call popreal8array(bmtj2, size(bmtj2, 1)*size(bmtj2, 2)*size(bmtj2, &
&                3)*size(bmtj2, 4))
  deallocate(qq)
end subroutine sa_block_b
  subroutine sa_block(resonly)
!
!       sa solves the transport equation for the spalart-allmaras      
!       turbulence model in a segregated manner using a diagonal       
!       dominant adi-scheme.                                           
!
    use blockpointers
    use inputtimespectral
    use iteration
    use inputphysics
    use paramturb
    implicit none
!
!      subroutine argument.
!
    logical, intent(in) :: resonly
!
!      local variables.
!
    integer(kind=inttype) :: nn, sps
!
!       begin execution                                                
! set the arrays for the boundary condition treatment.
    call bcturbtreatment()
! set model constants
    cv13 = rsacv1**3
    kar2inv = one/rsak**2
    cw36 = rsacw3**6
    cb3inv = one/rsacb3
! run the necessary code to setup and solve the sa transport
! equation for nutilde.
! production terms
    select case  (turbprod) 
    case (strain) 
      call prodsmag2()
    case (vorticity) 
      call prodwmag2()
    case (katolaunder) 
      call prodkatolaunder()
    end select
! alloc central jacobian memory
    allocate(qq(2:il, 2:jl, 2:kl))
! source terms
    call sasource()
! advection term
    nn = itu1 - 1
    call turbadvection(1_inttype, 1_inttype, nn, qq)
! unsteady term
    call unsteadyturbterm(1_inttype, 1_inttype, nn, qq)
! viscous terms
    call saviscous()
! perform the residual scaling
    call saresscale()
! we need to do an acutal solve. solve and update the eddy
! viscosity and the boundary conditions
    deallocate(qq)
  end subroutine sa_block
!  differentiation of sasource in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *rlv *scratch
!   with respect to varying inputs: *w *rlv *scratch *d2wall
!   plus diff mem management of: w:in rlv:in scratch:in d2wall:in
  subroutine sasource_b()
!
!  source terms.                                                  
!  determine the source term and its derivative w.r.t. nutilde    
!  for all internal cells of the block.                           
    use blockpointers
    use constants
    use paramturb
    implicit none
! compute the source term jacobian. note that the part
! containing term1 is treated explicitly. the reason is that
! implicit treatment of this part leads to a decrease of the
! diagonal dominance of the jacobian and it thus decreases
! the stability. you may want to play around and try to
! take this term into account in the jacobian.
! note that -dsource/dnu is stored.
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: fv1d, fv2d, ft2d
    real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
    real(kind=realtype) :: ssd, sstd, nud, dist2invd, chid, chi2d, chi3d
    real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
    real(kind=realtype) :: rrd, ggd, gg6d, termfwd, fwsad, term1d, &
&   term2d
    real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
    real(kind=realtype), parameter :: xminn=1.e-10_realtype
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    integer :: branch
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    d2walld = 0.0_8
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
      ss = sqrt(scratch(i, j, k, iprod))
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
      nu = rlv(i, j, k)/w(i, j, k, irho)
      dist2inv = one/d2wall(i, j, k)**2
      chi = w(i, j, k, itu1)/nu
      chi2 = chi*chi
      chi3 = chi*chi2
      fv1 = chi3/(chi3+cv13)
      fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
      ft2 = rsact3*exp(-(rsact4*chi2))
! ft2 = zero
! correct the production term to account for the influence
! of the wall. make sure that this term remains positive
! (the function fv2 is negative between chi = 1 and 18.4,
! which can cause sst to go negative, which is undesirable).
      sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
      if (sst .lt. xminn) then
        sst = xminn
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        sst = sst
      end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
      rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
      if (rr .gt. 10.0_realtype) then
        rr = 10.0_realtype
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        rr = rr
      end if
      gg = rr + rsacw2*(rr**6-rr)
      gg6 = gg**6
      termfw = ((one+cw36)/(gg6+cw36))**sixth
      fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
      term1 = rsacb1*(one-ft2)*ss
      term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)
! compute some derivatives w.r.t. nutilde. these will occur
! in the left hand side, i.e. the matrix for the implicit
! treatment.
      tempd4 = w(i, j, k, itu1)*scratchd(i, j, k, idvt)
      temp2 = w(i, j, k, itu1)
      term1d = tempd4
      term2d = temp2*tempd4
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + (term1+term2*temp2)*&
&       scratchd(i, j, k, idvt) + term2*tempd4
      scratchd(i, j, k, idvt) = 0.0_8
      tempd5 = dist2inv*kar2inv*rsacb1*term2d
      dist2invd = (kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)*&
&       term2d
      ft2d = (1.0_8-fv2)*tempd5 - ss*rsacb1*term1d
      fv2d = (one-ft2)*tempd5
      fwsad = -(dist2inv*rsacw1*term2d)
      ssd = rsacb1*(one-ft2)*term1d
      termfwd = gg*fwsad
      temp1 = (one+cw36)/(cw36+gg6)
      if (temp1 .le. 0.0_8 .and. (sixth .eq. 0.0_8 .or. sixth .ne. int(&
&         sixth))) then
        gg6d = 0.0
      else
        gg6d = -(sixth*temp1**(sixth-1)*temp1*termfwd/(cw36+gg6))
      end if
      ggd = 6*gg**5*gg6d + termfw*fwsad
      rrd = (rsacw2*6*rr**5-rsacw2+1.0_8)*ggd
      call popcontrol1b(branch)
      if (branch .eq. 0) rrd = 0.0_8
      tempd3 = w(i, j, k, itu1)*kar2inv*rrd/sst
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*dist2inv*rrd/sst
      dist2invd = dist2invd + tempd3
      sstd = -(dist2inv*tempd3/sst)
      call popcontrol1b(branch)
      if (branch .eq. 0) sstd = 0.0_8
      tempd = kar2inv*w(i, j, k, itu1)*sstd
      ssd = ssd + sstd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*fv2*dist2inv*sstd
      fv2d = fv2d + dist2inv*tempd
      dist2invd = dist2invd + fv2*tempd
      tempd0 = -(fv2d/(one+chi*fv1))
      tempd1 = -(chi*tempd0/(one+chi*fv1))
      fv1d = chi*tempd1
      tempd2 = fv1d/(cv13+chi3)
      chi3d = (1.0_8-chi3/(cv13+chi3))*tempd2
      chi2d = chi*chi3d - exp(-(rsact4*chi2))*rsact3*rsact4*ft2d
      chid = chi2*chi3d + 2*chi*chi2d + fv1*tempd1 + tempd0
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + chid/nu
      nud = -(w(i, j, k, itu1)*chid/nu**2)
      temp0 = d2wall(i, j, k)
      d2walld(i, j, k) = d2walld(i, j, k) - one*2*dist2invd/temp0**3
      temp = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp**2
      if (.not.scratch(i, j, k, iprod) .eq. 0.0_8) scratchd(i, j, k, &
&       iprod) = scratchd(i, j, k, iprod) + ssd/(2.0*sqrt(scratch(i, j, &
&         k, iprod)))
    end do
  end subroutine sasource_b
  subroutine sasource()
!
!  source terms.                                                  
!  determine the source term and its derivative w.r.t. nutilde    
!  for all internal cells of the block.                           
    use blockpointers
    use constants
    use paramturb
    implicit none
! compute the source term jacobian. note that the part
! containing term1 is treated explicitly. the reason is that
! implicit treatment of this part leads to a decrease of the
! diagonal dominance of the jacobian and it thus decreases
! the stability. you may want to play around and try to
! take this term into account in the jacobian.
! note that -dsource/dnu is stored.
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
    real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
    real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
    real(kind=realtype), parameter :: xminn=1.e-10_realtype
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
      ss = sqrt(scratch(i, j, k, iprod))
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
      nu = rlv(i, j, k)/w(i, j, k, irho)
      dist2inv = one/d2wall(i, j, k)**2
      chi = w(i, j, k, itu1)/nu
      chi2 = chi*chi
      chi3 = chi*chi2
      fv1 = chi3/(chi3+cv13)
      fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
      ft2 = rsact3*exp(-(rsact4*chi2))
! ft2 = zero
! correct the production term to account for the influence
! of the wall. make sure that this term remains positive
! (the function fv2 is negative between chi = 1 and 18.4,
! which can cause sst to go negative, which is undesirable).
      sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
      if (sst .lt. xminn) then
        sst = xminn
      else
        sst = sst
      end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
      rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
      if (rr .gt. 10.0_realtype) then
        rr = 10.0_realtype
      else
        rr = rr
      end if
      gg = rr + rsacw2*(rr**6-rr)
      gg6 = gg**6
      termfw = ((one+cw36)/(gg6+cw36))**sixth
      fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
      term1 = rsacb1*(one-ft2)*ss
      term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)
      scratch(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, k&
&       , itu1)
! compute some derivatives w.r.t. nutilde. these will occur
! in the left hand side, i.e. the matrix for the implicit
! treatment.
      dfv1 = three*chi2*cv13/(chi3+cv13)**2
      dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
      dft2 = -(two*rsact4*chi*ft2/nu)
      drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
      dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
      dfw = cw36/(gg6+cw36)*termfw*dgg
    end do
  end subroutine sasource
!  differentiation of saviscous in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *rlv *scratch *vol *si *sj
!                *sk
!   with respect to varying inputs: *w *rlv *scratch *vol *si *sj
!                *sk
!   plus diff mem management of: w:in rlv:in scratch:in vol:in
!                si:in sj:in sk:in
  subroutine saviscous_b()
!
!  viscous term.                                                  
!  determine the viscous contribution to the residual             
!  for all internal cells of the block.                           
    use blockpointers
    use paramturb
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: nu
    real(kind=realtype) :: nud
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: volid, volmid, volpid, xmd, ymd, zmd, xpd, &
&   ypd, zpd
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: xad, yad, zad, ttmd, ttpd, cnudd, camd, capd
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: nutmd, nutpd, numd, nupd, cdmd, cdpd
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    real(kind=realtype) :: c1md, c1pd, c10d
    intrinsic mod
    intrinsic max
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: temp13
    real(kind=realtype) :: temp12
    real(kind=realtype) :: temp11
    real(kind=realtype) :: temp10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd25
    real(kind=realtype) :: tempd24
    real(kind=realtype) :: tempd23
    real(kind=realtype) :: tempd22
    real(kind=realtype) :: tempd21
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp9
    real(kind=realtype) :: temp8
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: temp7
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: temp6
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: temp5
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: temp4
    real(kind=realtype) :: tempd15
    call pushinteger4(i)
    call pushreal8(c10)
    call pushinteger4(j)
    call pushinteger4(k)
    call pushreal8(xa)
    call pushreal8(xm)
    call pushreal8(xp)
    call pushreal8(volpi)
    call pushreal8(num)
    call pushreal8(cnud)
    call pushreal8(ya)
    call pushreal8(nup)
    call pushreal8(volmi)
    call pushreal8(nutm)
    call pushreal8(nutp)
    call pushreal8(ym)
    call pushreal8(voli)
    call pushreal8(yp)
    call pushreal8(c1m)
    call pushreal8(c1p)
    call pushreal8(za)
    call pushreal8(ttm)
    call pushreal8(ttp)
    call pushreal8(zm)
    call pushreal8(zp)
    call pushinteger4(i)
    call pushreal8(c10)
    call pushinteger4(j)
    call pushinteger4(k)
    call pushreal8(xa)
    call pushreal8(xm)
    call pushreal8(xp)
    call pushreal8(volpi)
    call pushreal8(num)
    call pushreal8(cnud)
    call pushreal8(ya)
    call pushreal8(nup)
    call pushreal8(volmi)
    call pushreal8(nutm)
    call pushreal8(nutp)
    call pushreal8(ym)
    call pushreal8(voli)
    call pushreal8(yp)
    call pushreal8(c1m)
    call pushreal8(c1p)
    call pushreal8(za)
    call pushreal8(ttm)
    call pushreal8(ttp)
    call pushreal8(zm)
    call pushreal8(zp)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
      nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
        call pushcontrol1b(0)
      else
        c1m = cdm + cam
        call pushcontrol1b(1)
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
        call pushcontrol1b(0)
      else
        c1p = cdp + cap
        call pushcontrol1b(1)
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i-1, j, k, itu1)*scratchd(i, j, k, idvt)
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i+1, j, k, itu1)*scratchd(i, j, k, idvt)
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd17 = cb3inv*cdpd
      nupd = ttp*tempd17
      nutpd = ttp*(one+rsacb2)*tempd17
      ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd17
      tempd18 = cb3inv*cdmd
      numd = ttm*tempd18
      nutmd = ttm*(one+rsacb2)*tempd18
      ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd18
      temp13 = w(i+1, j, k, irho)
      tempd19 = half*nupd/temp13
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + tempd19
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - rlv(i+1, j, k)*tempd19&
&       /temp13
      nud = half*numd + half*nupd
      temp12 = w(i-1, j, k, irho)
      tempd20 = half*numd/temp12
      rlvd(i-1, j, k) = rlvd(i-1, j, k) + tempd20
      wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - rlv(i-1, j, k)*tempd20&
&       /temp12
      temp11 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp11
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp11**2
      wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd21 = half*zad
      sid(i, j, k, 3) = sid(i, j, k, 3) + voli*tempd21
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*tempd21
      tempd22 = half*yad
      sid(i, j, k, 2) = sid(i, j, k, 2) + voli*tempd22
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*tempd22
      tempd23 = half*xad
      volid = (si(i, j, k, 2)+si(i-1, j, k, 2))*tempd22 + (si(i, j, k, 1&
&       )+si(i-1, j, k, 1))*tempd23 + (si(i, j, k, 3)+si(i-1, j, k, 3))*&
&       tempd21
      sid(i, j, k, 1) = sid(i, j, k, 1) + voli*tempd23
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*tempd23
      sid(i, j, k, 3) = sid(i, j, k, 3) + volpi*zpd
      volpid = si(i, j, k, 2)*ypd + si(i, j, k, 1)*xpd + si(i, j, k, 3)*&
&       zpd
      sid(i, j, k, 2) = sid(i, j, k, 2) + volpi*ypd
      sid(i, j, k, 1) = sid(i, j, k, 1) + volpi*xpd
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + volmi*zmd
      volmid = si(i-1, j, k, 2)*ymd + si(i-1, j, k, 1)*xmd + si(i-1, j, &
&       k, 3)*zmd
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + volmi*ymd
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + volmi*xmd
      temp10 = vol(i, j, k) + vol(i+1, j, k)
      tempd24 = -(two*volpid/temp10**2)
      vold(i, j, k) = vold(i, j, k) + tempd24
      vold(i+1, j, k) = vold(i+1, j, k) + tempd24
      temp9 = vol(i, j, k) + vol(i-1, j, k)
      tempd25 = -(two*volmid/temp9**2)
      vold(i, j, k) = vold(i, j, k) + tempd25
      vold(i-1, j, k) = vold(i-1, j, k) + tempd25
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
    call popreal8(zp)
    call popreal8(zm)
    call popreal8(ttp)
    call popreal8(ttm)
    call popreal8(za)
    call popreal8(c1p)
    call popreal8(c1m)
    call popreal8(yp)
    call popreal8(voli)
    call popreal8(ym)
    call popreal8(nutp)
    call popreal8(nutm)
    call popreal8(volmi)
    call popreal8(nup)
    call popreal8(ya)
    call popreal8(cnud)
    call popreal8(num)
    call popreal8(volpi)
    call popreal8(xp)
    call popreal8(xm)
    call popreal8(xa)
    call popinteger4(k)
    call popinteger4(j)
    call popreal8(c10)
    call popinteger4(i)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
      nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
        call pushcontrol1b(0)
      else
        c1m = cdm + cam
        call pushcontrol1b(1)
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
        call pushcontrol1b(0)
      else
        c1p = cdp + cap
        call pushcontrol1b(1)
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i, j-1, k, itu1)*scratchd(i, j, k, idvt)
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j+1, k, itu1)*scratchd(i, j, k, idvt)
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd8 = cb3inv*cdpd
      nupd = ttp*tempd8
      nutpd = ttp*(one+rsacb2)*tempd8
      ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd8
      tempd9 = cb3inv*cdmd
      numd = ttm*tempd9
      nutmd = ttm*(one+rsacb2)*tempd9
      ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd9
      temp8 = w(i, j+1, k, irho)
      tempd10 = half*nupd/temp8
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + tempd10
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - rlv(i, j+1, k)*tempd10&
&       /temp8
      nud = half*numd + half*nupd
      temp7 = w(i, j-1, k, irho)
      tempd11 = half*numd/temp7
      rlvd(i, j-1, k) = rlvd(i, j-1, k) + tempd11
      wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - rlv(i, j-1, k)*tempd11&
&       /temp7
      temp6 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp6
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp6**2
      wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd12 = half*zad
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*tempd12
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*tempd12
      tempd13 = half*yad
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*tempd13
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*tempd13
      tempd14 = half*xad
      volid = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempd13 + (sj(i, j, k, 1&
&       )+sj(i, j-1, k, 1))*tempd14 + (sj(i, j, k, 3)+sj(i, j-1, k, 3))*&
&       tempd12
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*tempd14
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*tempd14
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + volpi*zpd
      volpid = sj(i, j, k, 2)*ypd + sj(i, j, k, 1)*xpd + sj(i, j, k, 3)*&
&       zpd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + volpi*ypd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + volpi*xpd
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + volmi*zmd
      volmid = sj(i, j-1, k, 2)*ymd + sj(i, j-1, k, 1)*xmd + sj(i, j-1, &
&       k, 3)*zmd
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + volmi*ymd
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + volmi*xmd
      temp5 = vol(i, j, k) + vol(i, j+1, k)
      tempd15 = -(two*volpid/temp5**2)
      vold(i, j, k) = vold(i, j, k) + tempd15
      vold(i, j+1, k) = vold(i, j+1, k) + tempd15
      temp4 = vol(i, j, k) + vol(i, j-1, k)
      tempd16 = -(two*volmid/temp4**2)
      vold(i, j, k) = vold(i, j, k) + tempd16
      vold(i, j-1, k) = vold(i, j-1, k) + tempd16
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
    call popreal8(zp)
    call popreal8(zm)
    call popreal8(ttp)
    call popreal8(ttm)
    call popreal8(za)
    call popreal8(c1p)
    call popreal8(c1m)
    call popreal8(yp)
    call popreal8(voli)
    call popreal8(ym)
    call popreal8(nutp)
    call popreal8(nutm)
    call popreal8(volmi)
    call popreal8(nup)
    call popreal8(ya)
    call popreal8(cnud)
    call popreal8(num)
    call popreal8(volpi)
    call popreal8(xp)
    call popreal8(xm)
    call popreal8(xa)
    call popinteger4(k)
    call popinteger4(j)
    call popreal8(c10)
    call popinteger4(i)
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
      nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
        call pushcontrol1b(0)
      else
        c1m = cdm + cam
        call pushcontrol1b(1)
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
        call pushcontrol1b(0)
      else
        c1p = cdp + cap
        call pushcontrol1b(1)
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      c1md = w(i, j, k-1, itu1)*scratchd(i, j, k, idvt)
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + c1m*scratchd(i, j, k, &
&       idvt)
      c1pd = w(i, j, k+1, itu1)*scratchd(i, j, k, idvt)
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + c1p*scratchd(i, j, k, &
&       idvt)
      c10d = -(w(i, j, k, itu1)*scratchd(i, j, k, idvt))
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*scratchd(i, j, k, idvt&
&       )
      c1md = c1md + c10d
      c1pd = c1pd + c10d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdpd = 0.0_8
        capd = 0.0_8
      else
        cdpd = c1pd
        capd = c1pd
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        cdmd = 0.0_8
        camd = 0.0_8
      else
        cdmd = c1md
        camd = c1md
      end if
      tempd = cb3inv*cdpd
      nupd = ttp*tempd
      nutpd = ttp*(one+rsacb2)*tempd
      ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd
      tempd0 = cb3inv*cdmd
      numd = ttm*tempd0
      nutmd = ttm*(one+rsacb2)*tempd0
      ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd0
      temp3 = w(i, j, k+1, irho)
      tempd1 = half*nupd/temp3
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + tempd1
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - rlv(i, j, k+1)*tempd1/&
&       temp3
      nud = half*numd + half*nupd
      temp2 = w(i, j, k-1, irho)
      tempd2 = half*numd/temp2
      rlvd(i, j, k-1) = rlvd(i, j, k-1) + tempd2
      wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - rlv(i, j, k-1)*tempd2/&
&       temp2
      temp1 = w(i, j, k, irho)
      rlvd(i, j, k) = rlvd(i, j, k) + nud/temp1
      wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp1**2
      wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*nutpd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
      wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + half*nutmd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
      cnudd = ttm*camd + ttp*capd
      wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
      xpd = xa*ttpd
      xad = xm*ttmd + xp*ttpd
      ypd = ya*ttpd
      yad = ym*ttmd + yp*ttpd
      zpd = za*ttpd
      zad = zm*ttmd + zp*ttpd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd3 = half*zad
      skd(i, j, k, 3) = skd(i, j, k, 3) + voli*tempd3
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*tempd3
      tempd4 = half*yad
      skd(i, j, k, 2) = skd(i, j, k, 2) + voli*tempd4
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*tempd4
      tempd5 = half*xad
      volid = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempd4 + (sk(i, j, k, 1)&
&       +sk(i, j, k-1, 1))*tempd5 + (sk(i, j, k, 3)+sk(i, j, k-1, 3))*&
&       tempd3
      skd(i, j, k, 1) = skd(i, j, k, 1) + voli*tempd5
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*tempd5
      skd(i, j, k, 3) = skd(i, j, k, 3) + volpi*zpd
      volpid = sk(i, j, k, 2)*ypd + sk(i, j, k, 1)*xpd + sk(i, j, k, 3)*&
&       zpd
      skd(i, j, k, 2) = skd(i, j, k, 2) + volpi*ypd
      skd(i, j, k, 1) = skd(i, j, k, 1) + volpi*xpd
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + volmi*zmd
      volmid = sk(i, j, k-1, 2)*ymd + sk(i, j, k-1, 1)*xmd + sk(i, j, k-&
&       1, 3)*zmd
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + volmi*ymd
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + volmi*xmd
      temp0 = vol(i, j, k) + vol(i, j, k+1)
      tempd6 = -(two*volpid/temp0**2)
      vold(i, j, k) = vold(i, j, k) + tempd6
      vold(i, j, k+1) = vold(i, j, k+1) + tempd6
      temp = vol(i, j, k) + vol(i, j, k-1)
      tempd7 = -(two*volmid/temp**2)
      vold(i, j, k) = vold(i, j, k) + tempd7
      vold(i, j, k-1) = vold(i, j, k-1) + tempd7
      vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
    end do
  end subroutine saviscous_b
  subroutine saviscous()
!
!  viscous term.                                                  
!  determine the viscous contribution to the residual             
!  for all internal cells of the block.                           
    use blockpointers
    use paramturb
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype) :: nu
    real(kind=realtype) :: fv1, fv2, ft2
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    intrinsic mod
    intrinsic max
!
!       viscous terms in k-direction.                                  
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
      nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j, k-1&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
    end do
!
!       viscous terms in j-direction.                                  
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
      nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j-1, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
    end do
!
!       viscous terms in i-direction.                                  
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
      cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
      cam = ttm*cnud
      cap = ttp*cnud
      nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
      nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
      nu = rlv(i, j, k)/w(i, j, k, irho)
      num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
      nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
      cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
      cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
      if (cdm + cam .lt. zero) then
        c1m = zero
      else
        c1m = cdm + cam
      end if
      if (cdp + cap .lt. zero) then
        c1p = zero
      else
        c1p = cdp + cap
      end if
      c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
      scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i-1, j, k&
&       , itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
    end do
  end subroutine saviscous
!  differentiation of saresscale in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw *vol
!   with respect to varying inputs: *dw *scratch *vol
!   plus diff mem management of: dw:in scratch:in vol:in
  subroutine saresscale_b()
!
!  multiply the residual by the volume and store this in dw; this 
! * is done for monitoring reasons only. the multiplication with the
! * volume is present to be consistent with the flow residuals; also
!  the negative value is taken, again to be consistent with the   
! * flow equations. also multiply by iblank so that no updates occur
!  in holes or the overset boundary.                              
    use blockpointers
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    scratchd = 0.0_8
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      x1 = real(iblank(i, j, k), realtype)
      if (x1 .lt. zero) then
        rblank = zero
      else
        rblank = x1
      end if
      vold(i, j, k) = vold(i, j, k) - rblank*scratch(i, j, k, idvt)*dwd(&
&       i, j, k, itu1)
      scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) - rblank*vol(i, &
&       j, k)*dwd(i, j, k, itu1)
      dwd(i, j, k, itu1) = 0.0_8
    end do
  end subroutine saresscale_b
  subroutine saresscale()
!
!  multiply the residual by the volume and store this in dw; this 
! * is done for monitoring reasons only. the multiplication with the
! * volume is present to be consistent with the flow residuals; also
!  the negative value is taken, again to be consistent with the   
! * flow equations. also multiply by iblank so that no updates occur
!  in holes or the overset boundary.                              
    use blockpointers
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
    intrinsic max
    real(kind=realtype) :: x1
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      x1 = real(iblank(i, j, k), realtype)
      if (x1 .lt. zero) then
        rblank = zero
      else
        rblank = x1
      end if
      dw(i, j, k, itu1) = -(vol(i, j, k)*scratch(i, j, k, idvt)*rblank)
    end do
  end subroutine saresscale
  subroutine sasolve2()
!
!  sasolve solves the turbulent transport equation for the        
!  original spalart-allmaras model in a segregated manner using   
!  a diagonal dominant adi-scheme.                                
    use blockpointers
    use inputiteration
    use inputphysics
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k, nn, ii
    real(kind=realtype), dimension(2:max(kl, il, jl)) :: bb, cc, dd, ff
    real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
    real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
    real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
    real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
    real(kind=realtype) :: uu, um, up, factor, f, tu1p, nu, rblank
    logical, dimension(2:jl, 2:kl), target :: flagi2, flagil
    logical, dimension(2:il, 2:kl), target :: flagj2, flagjl
    logical, dimension(2:il, 2:jl), target :: flagk2, flagkl
    logical, dimension(:, :), pointer :: flag
    intrinsic max
    intrinsic real
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
! initialize the wall function flags to .false.
    flagi2 = .false.
    flagil = .false.
    flagj2 = .false.
    flagjl = .false.
    flagk2 = .false.
    flagkl = .false.
! modify the rhs of the 1st internal cell, if wall functions
! are used; their value is determined by the table.
    if (wallfunctions) then
bocos:do nn=1,nviscbocos
! determine the block face on which the subface is located
! and set some variables. as flag points to the entire array
! flagi2, etc., its starting indices are the starting indices
! of its target and not 1.
        select case  (bcfaceid(nn)) 
        case (imin) 
          flag => flagi2
          ddw => dw(2, 1:, 1:, 1:)
          ddvt => scratch(2, 1:, 1:, idvt:)
          ww => w(2, 1:, 1:, 1:)
          rrlv => rlv(2, 1:, 1:)
          dd2wall => d2wall(2, :, :)
        case (imax) 
          flag => flagil
          ddw => dw(il, 1:, 1:, 1:)
          ddvt => scratch(il, 1:, 1:, idvt:)
          ww => w(il, 1:, 1:, 1:)
          rrlv => rlv(il, 1:, 1:)
          dd2wall => d2wall(il, :, :)
        case (jmin) 
          flag => flagj2
          ddw => dw(1:, 2, 1:, 1:)
          ddvt => scratch(1:, 2, 1:, idvt:)
          ww => w(1:, 2, 1:, 1:)
          rrlv => rlv(1:, 2, 1:)
          dd2wall => d2wall(:, 2, :)
        case (jmax) 
          flag => flagjl
          ddw => dw(1:, jl, 1:, 1:)
          ddvt => scratch(1:, jl, 1:, idvt:)
          ww => w(1:, jl, 1:, 1:)
          rrlv => rlv(1:, jl, 1:)
          dd2wall => d2wall(:, jl, :)
        case (kmin) 
          flag => flagk2
          ddw => dw(1:, 1:, 2, 1:)
          ddvt => scratch(1:, 1:, 2, idvt:)
          ww => w(1:, 1:, 2, 1:)
          rrlv => rlv(1:, 1:, 2)
          dd2wall => d2wall(:, :, 2)
        case (kmax) 
          flag => flagkl
          ddw => dw(1:, 1:, kl, :)
          ddvt => scratch(1:, 1:, kl, idvt:)
          ww => w(1:, 1:, kl, 1:)
          rrlv => rlv(1:, 1:, kl)
          dd2wall => d2wall(:, :, kl)
        end select
! loop over the owned faces of this subface. therefore the
! nodal range of bcdata must be used. the offset of +1 is
! present, because the starting index of the cell range is
! 1 larger than the starting index of the nodal range.
        do j=bcdata(nn)%jnbeg+1,bcdata(nn)%jnend
          do i=bcdata(nn)%inbeg+1,bcdata(nn)%inend
! set ddw to zero.
            ddw(i, j, itu1) = zero
! enforce nu tilde in the 1st internal cell from the
! wall function table. there is an offset of -1 in the
! wall distance. note that the offset compared to the
! current value must be stored, because dvt contains
! the update. also note that the curve fits contain the
! non-dimensional value.
            yp = ww(i, j, irho)*dd2wall(i-1, j-1)*viscsubface(nn)%utau(i&
&             , j)/rrlv(i, j)
            call curvetupyp(tu1p, yp, itu1, itu1)
            ddvt(i, j, 1) = tu1p*rrlv(i, j)/ww(i, j, irho) - ww(i, j, &
&             itu1)
! set the wall flag to .true.
            flag(i, j) = .true.
          end do
        end do
      end do bocos
    end if
! for implicit relaxation take the local time step into account,
! where dt is the inverse of the central jacobian times the cfl
! number. the following system is solved:
! (i/dt + cc + bb + dd)*dw = rhs, in which i/dt = cc/cfl. as in
! the rest of the algorithm only the modified central jacobian is
! used, stored it now.
! compute the factor multiplying the central jacobian, which
! is 1 + 1/cfl (implicit relaxation only).
    factor = one
    if (turbrelax .eq. turbrelaximplicit) factor = one + (one-alfaturb)/&
&       alfaturb
    do k=2,kl
      do j=2,jl
        do i=2,il
          qq(i, j, k) = factor*qq(i, j, k)
! set qq to 1 if the value is determined by the
! wall function table.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) qq(i, j, k) = &
&             one
        end do
      end do
    end do
! initialize the grid velocity to zero. this value will be used
! if the block is not moving.
    qs = zero
!
!       dd-adi step in j-direction. there is no particular reason to   
!       start in j-direction, it just happened to be so. as we solve   
!       in j-direction, the j-loop is the innermost loop.              
!
    do k=2,kl
      do i=2,il
        do j=2,jl
! more or less the same code is executed here as above when
! the residual was built. however, now the off-diagonal
! terms for the dd-adi must be built and stored. this could
! have been done earlier, but then all the coefficients had
! to be stored. to save memory, they are recomputed.
! consequently, see the j-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! off-diagonal terms due to the diffusion terms
! in j-direction.
          nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
          nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          if (cdm + cam .lt. zero) then
            c1m = zero
          else
            c1m = cdm + cam
          end if
          if (cdp + cap .lt. zero) then
            c1p = zero
          else
            c1p = cdp + cap
          end if
          bb(j) = -c1m
          dd(j) = -c1p
! compute the grid velocity if present.
! it is taken as the average of j and j-1,
          if (addgridvelocities) qs = half*(sfacej(i, j, k)+sfacej(i, j-&
&             1, k))*voli
! off-diagonal terms due to the advection term in
! j-direction. first order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&           ivz) - qs
          um = zero
          up = zero
          if (uu .lt. zero) um = uu
          if (uu .gt. zero) up = uu
          bb(j) = bb(j) - up
          dd(j) = dd(j) + um
          x1 = real(iblank(i, j, k), realtype)
          if (x1 .lt. zero) then
            rblank = zero
          else
            rblank = x1
          end if
          cc(j) = qq(i, j, k)
          ff(j) = scratch(i, j, k, idvt)*rblank
          bb(j) = bb(j)*rblank
          dd(j) = dd(j)*rblank
! set the off diagonal terms to zero if the wall is flagged.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) then
            bb(j) = zero
            dd(j) = zero
          end if
        end do
! solve the tri-diagonal system in j-direction.
! first the backward sweep to eliminate the upper diagonal dd.
        do j=ny,2,-1
          f = dd(j)/cc(j+1)
          cc(j) = cc(j) - f*bb(j+1)
          ff(j) = ff(j) - f*ff(j+1)
        end do
! the matrix is now in lower block bi-diagonal form.
! perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        do j=3,jl
          ff(j) = ff(j) - bb(j)*ff(j-1)
          ff(j) = ff(j)/cc(j)
        end do
! determine the new rhs for the next direction.
        do j=2,jl
          scratch(i, j, k, idvt) = ff(j)*qq(i, j, k)
        end do
      end do
    end do
!
!       dd-adi step in i-direction. as we solve in i-direction, the    
!       i-loop is the innermost loop.                                  
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! more or less the same code is executed here as above when
! the residual was built. however, now the off-diagonal
! terms for the dd-adi must be built and stored. this could
! have been done earlier, but then all the coefficients had
! to be stored. to save memory, they are recomputed.
! consequently, see the i-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! off-diagonal terms due to the diffusion terms
! in i-direction.
          nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
          nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          if (cdm + cam .lt. zero) then
            c1m = zero
          else
            c1m = cdm + cam
          end if
          if (cdp + cap .lt. zero) then
            c1p = zero
          else
            c1p = cdp + cap
          end if
          bb(i) = -c1m
          dd(i) = -c1p
! compute the grid velocity if present.
! it is taken as the average of i and i-1,
          if (addgridvelocities) qs = half*(sfacei(i, j, k)+sfacei(i-1, &
&             j, k))*voli
! off-diagonal terms due to the advection term in
! i-direction. first order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&           ivz) - qs
          um = zero
          up = zero
          if (uu .lt. zero) um = uu
          if (uu .gt. zero) up = uu
          bb(i) = bb(i) - up
          dd(i) = dd(i) + um
          x2 = real(iblank(i, j, k), realtype)
          if (x2 .lt. zero) then
            rblank = zero
          else
            rblank = x2
          end if
          cc(i) = qq(i, j, k)
          ff(i) = scratch(i, j, k, idvt)*rblank
          bb(i) = bb(i)*rblank
          dd(i) = dd(i)*rblank
! set the off diagonal terms to zero if the wall is flagged.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) then
            bb(i) = zero
            dd(i) = zero
          end if
        end do
! solve the tri-diagonal system in i-direction.
! first the backward sweep to eliminate the upper diagonal dd.
        do i=nx,2,-1
          f = dd(i)/cc(i+1)
          cc(i) = cc(i) - f*bb(i+1)
          ff(i) = ff(i) - f*ff(i+1)
        end do
! the matrix is now in lower block bi-diagonal form.
! perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        do i=3,il
          ff(i) = ff(i) - bb(i)*ff(i-1)
          ff(i) = ff(i)/cc(i)
        end do
! determine the new rhs for the next direction.
        do i=2,il
          scratch(i, j, k, idvt) = ff(i)*qq(i, j, k)
        end do
      end do
    end do
!
!       dd-adi step in k-direction. as we solve in k-direction, the    
!       k-loop is the innermost loop.                                  
!
    do j=2,jl
      do i=2,il
        do k=2,kl
! more or less the same code is executed here as above when
! the residual was built. however, now the off-diagonal
! terms for the dd-adi must be built and stored. this could
! have been done earlier, but then all the coefficients had
! to be stored. to save memory, they are recomputed.
! consequently, see the k-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! off-diagonal terms due to the diffusion terms
! in k-direction.
          nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
          nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          if (cdm + cam .lt. zero) then
            c1m = zero
          else
            c1m = cdm + cam
          end if
          if (cdp + cap .lt. zero) then
            c1p = zero
          else
            c1p = cdp + cap
          end if
          bb(k) = -c1m
          dd(k) = -c1p
! compute the grid velocity if present.
! it is taken as the average of k and k-1,
          if (addgridvelocities) qs = half*(sfacek(i, j, k)+sfacek(i, j&
&             , k-1))*voli
! off-diagonal terms due to the advection term in
! k-direction. first order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&           ivz) - qs
          um = zero
          up = zero
          if (uu .lt. zero) um = uu
          if (uu .gt. zero) up = uu
          bb(k) = bb(k) - up
          dd(k) = dd(k) + um
          x3 = real(iblank(i, j, k), realtype)
          if (x3 .lt. zero) then
            rblank = zero
          else
            rblank = x3
          end if
          cc(k) = qq(i, j, k)
          ff(k) = scratch(i, j, k, idvt)*rblank
          bb(k) = bb(k)*rblank
          dd(k) = dd(k)*rblank
! set the off diagonal terms to zero if the wall is flagged.
          if ((((((i .eq. 2 .and. flagi2(j, k)) .or. (i .eq. il .and. &
&             flagil(j, k))) .or. (j .eq. 2 .and. flagj2(i, k))) .or. (j&
&             .eq. jl .and. flagjl(i, k))) .or. (k .eq. 2 .and. flagk2(i&
&             , j))) .or. (k .eq. kl .and. flagkl(i, j))) then
            bb(k) = zero
            dd(k) = zero
          end if
        end do
! solve the tri-diagonal system in k-direction.
! first the backward sweep to eliminate the upper diagonal dd.
        do k=nz,2,-1
          f = dd(k)/cc(k+1)
          cc(k) = cc(k) - f*bb(k+1)
          ff(k) = ff(k) - f*ff(k+1)
        end do
! the matrix is now in lower block bi-diagonal form.
! perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        do k=3,kl
          ff(k) = ff(k) - bb(k)*ff(k-1)
          ff(k) = ff(k)/cc(k)
        end do
! store the update in dvt.
        do k=2,kl
          scratch(i, j, k, idvt) = ff(k)
        end do
      end do
    end do
!
!       update the turbulent variables. for explicit relaxation the    
!       update must be relaxed; for implicit relaxation this has been  
!       done via the time step.                                        
!
    factor = one
    if (turbrelax .eq. turbrelaxexplicit) factor = alfaturb
    do k=2,kl
      do j=2,jl
        do i=2,il
          w(i, j, k, itu1) = w(i, j, k, itu1) + factor*scratch(i, j, k, &
&           idvt)
          if (w(i, j, k, itu1) .lt. zero) then
            w(i, j, k, itu1) = zero
          else
            w(i, j, k, itu1) = w(i, j, k, itu1)
          end if
        end do
      end do
    end do
  end subroutine sasolve2
end module samodule_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of invisciddissfluxmatrix in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *p *w *si *sj *sk *fw
!   with respect to varying inputs: pinfcorr *p *w *si *sj *sk
!   plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
!
!       file:          invisciddissfluxmatrix.f90                      
!       author:        edwin van der weide                             
!       starting date: 03-25-2003                                      
!       last modified: 10-29-2007                                      
!
subroutine invisciddissfluxmatrix_b()
!
!       invisciddissfluxmatrix computes the matrix artificial          
!       dissipation term. instead of the spectral radius, as used in   
!       the scalar dissipation scheme, the absolute value of the flux  
!       jacobian is used. this leads to a less diffusive and           
!       consequently more accurate scheme. it is assumed that the      
!       pointers in blockpointers already point to the correct block.  
!
  use constants
  use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, jb&
& , kb, w, wd, p, pd, pori, porj, pork, fw, fwd, gamma, si, sid, sj, sjd&
& , sk, skd, indfamilyi, indfamilyj, indfamilyk, spectralsol, &
& addgridvelocities, sfacei, sfacej, sfacek, factfamilyi, factfamilyj, &
& factfamilyk
  use flowvarrefstate, only : pinfcorr, pinfcorrd
  use inputdiscretization, only : vis2, vis4
  use inputphysics, only : equations
  use iteration, only : rfil
  use cgnsgrid, only : massflowfamilydiss
  use utils_b, only : getcorrectfork, mydim, mydim_b
  implicit none
!
!      local parameters.
!
  real(kind=realtype), parameter :: dpmax=0.25_realtype
  real(kind=realtype), parameter :: epsacoustic=0.25_realtype
  real(kind=realtype), parameter :: epsshear=0.025_realtype
  real(kind=realtype), parameter :: omega=0.5_realtype
  real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ind, ii
  real(kind=realtype) :: plim, sface
  real(kind=realtype) :: plimd, sfaced
  real(kind=realtype) :: sfil, fis2, fis4
  real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
  real(kind=realtype) :: ppor, rrad, dis2, dis4
  real(kind=realtype) :: rradd, dis2d, dis4d
  real(kind=realtype) :: dp1, dp2, tmp, fs
  real(kind=realtype) :: tmpd, fsd
  real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, ddw6
  real(kind=realtype) :: ddw1d, ddw2d, ddw3d, ddw4d, ddw5d, ddw6d
  real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
  real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd, sxd, syd, &
& szd
  real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
  real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
  real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
  real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
  real(kind=realtype) :: kavg, lam1, lam2, lam3, area
  real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d, aread
  real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
  real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, abv7d
  real(kind=realtype), dimension(ie, je, ke, 3) :: dss
  real(kind=realtype), dimension(ie, je, ke, 3) :: dssd
  logical :: correctfork
  intrinsic abs
  intrinsic mod
  intrinsic max
  intrinsic min
  intrinsic sqrt
  real(kind=realtype) :: arg1
  real(kind=realtype) :: arg1d
  integer :: branch
  real(kind=realtype) :: temp3
  real(kind=realtype) :: tempd14
  real(kind=realtype) :: temp29
  real(kind=realtype) :: temp2
  real(kind=realtype) :: tempd13
  real(kind=realtype) :: temp28
  real(kind=realtype) :: temp1
  real(kind=realtype) :: tempd12
  real(kind=realtype) :: temp27
  real(kind=realtype) :: max10d
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: temp26
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: temp25
  real(kind=realtype) :: temp24
  real(kind=realtype) :: temp23
  real(kind=realtype) :: temp22
  real(kind=realtype) :: temp59
  real(kind=realtype) :: temp21
  real(kind=realtype) :: temp58
  real(kind=realtype) :: temp20
  real(kind=realtype) :: temp57
  real(kind=realtype) :: abs1d
  real(kind=realtype) :: temp56
  real(kind=realtype) :: temp55
  real(kind=realtype) :: tempd40
  real(kind=realtype) :: temp54
  real(kind=realtype) :: max2d
  real(kind=realtype) :: temp53
  real(kind=realtype) :: min3
  real(kind=realtype) :: temp52
  real(kind=realtype) :: min2
  real(kind=realtype) :: temp51
  real(kind=realtype) :: min1
  real(kind=realtype) :: temp50
  real(kind=realtype) :: abs4d
  real(kind=realtype) :: max5d
  real(kind=realtype) :: min1d
  real(kind=realtype) :: max8d
  real(kind=realtype) :: x3
  real(kind=realtype) :: x2
  real(kind=realtype) :: x2d
  real(kind=realtype) :: x1
  real(kind=realtype) :: temp19
  real(kind=realtype) :: temp18
  real(kind=realtype) :: temp17
  real(kind=realtype) :: tempd39
  real(kind=realtype) :: temp16
  real(kind=realtype) :: tempd38
  real(kind=realtype) :: temp15
  real(kind=realtype) :: tempd37
  real(kind=realtype) :: temp14
  real(kind=realtype) :: tempd36
  real(kind=realtype) :: temp13
  real(kind=realtype) :: y3d
  real(kind=realtype) :: tempd35
  real(kind=realtype) :: temp12
  real(kind=realtype) :: temp49
  real(kind=realtype) :: tempd34
  real(kind=realtype) :: temp11
  real(kind=realtype) :: temp48
  real(kind=realtype) :: tempd33
  real(kind=realtype) :: temp10
  real(kind=realtype) :: temp47
  real(kind=realtype) :: tempd32
  real(kind=realtype) :: max12d
  real(kind=realtype) :: temp46
  real(kind=realtype) :: tempd31
  real(kind=realtype) :: temp45
  real(kind=realtype) :: tempd30
  real(kind=realtype) :: temp44
  real(kind=realtype) :: max1d
  real(kind=realtype) :: temp43
  real(kind=realtype) :: temp42
  real(kind=realtype) :: temp41
  real(kind=realtype) :: temp40
  real(kind=realtype) :: abs3d
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: max4d
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: abs6d
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: max7d
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: x1d
  real(kind=realtype) :: tempd29
  real(kind=realtype) :: min3d
  real(kind=realtype) :: tempd28
  real(kind=realtype) :: tempd27
  real(kind=realtype) :: tempd26
  real(kind=realtype) :: y2d
  real(kind=realtype) :: tempd25
  real(kind=realtype) :: tempd24
  real(kind=realtype) :: temp39
  real(kind=realtype) :: tempd23
  real(kind=realtype) :: temp38
  real(kind=realtype) :: tempd22
  real(kind=realtype) :: temp37
  real(kind=realtype) :: max11d
  real(kind=realtype) :: tempd21
  real(kind=realtype) :: temp36
  real(kind=realtype) :: tempd20
  real(kind=realtype) :: temp35
  real(kind=realtype) :: temp34
  real(kind=realtype) :: abs6
  real(kind=realtype) :: temp33
  real(kind=realtype) :: abs5
  real(kind=realtype) :: temp32
  real(kind=realtype) :: abs4
  real(kind=realtype) :: temp31
  real(kind=realtype) :: abs3
  real(kind=realtype) :: temp30
  real(kind=realtype) :: abs2
  real(kind=realtype) :: abs2d
  real(kind=realtype) :: abs1
  real(kind=realtype) :: abs0
  real(kind=realtype) :: temp64
  real(kind=realtype) :: max3d
  real(kind=realtype) :: temp63
  real(kind=realtype) :: temp62
  real(kind=realtype) :: temp61
  real(kind=realtype) :: temp60
  real(kind=realtype) :: max9
  real(kind=realtype) :: abs5d
  real(kind=realtype) :: max8
  real(kind=realtype) :: max7
  real(kind=realtype) :: max6
  real(kind=realtype) :: max6d
  real(kind=realtype) :: max5
  real(kind=realtype) :: max4
  real(kind=realtype) :: temp
  real(kind=realtype) :: max3
  real(kind=realtype) :: max2
  real(kind=realtype) :: max1
  real(kind=realtype) :: max12
  real(kind=realtype) :: temp9
  real(kind=realtype) :: max11
  real(kind=realtype) :: temp8
  real(kind=realtype) :: min2d
  real(kind=realtype) :: tempd19
  real(kind=realtype) :: max10
  real(kind=realtype) :: temp7
  real(kind=realtype) :: tempd18
  real(kind=realtype) :: max9d
  real(kind=realtype) :: y3
  real(kind=realtype) :: temp6
  real(kind=realtype) :: tempd17
  real(kind=realtype) :: y2
  real(kind=realtype) :: x3d
  real(kind=realtype) :: temp5
  real(kind=realtype) :: tempd16
  real(kind=realtype) :: y1
  real(kind=realtype) :: y1d
  real(kind=realtype) :: temp4
  real(kind=realtype) :: tempd15
  if (rfil .ge. 0.) then
    abs0 = rfil
  else
    abs0 = -rfil
  end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
  if (abs0 .lt. thresholdreal) then
    pinfcorrd = 0.0_8
  else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
    plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
! set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. 
! compute the pressure sensor for each cell, in each direction:
    do ii=0,ie*je*ke-1
      i = mod(ii, ie) + 1
      j = mod(ii/ie, je) + 1
      k = ii/(ie*je) + 1
      if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
        abs1 = p(i+1, j, k) - p(i, j, k)
      else
        abs1 = -(p(i+1, j, k)-p(i, j, k))
      end if
      if (p(i, j, k) - p(i-1, j, k) .ge. 0.) then
        abs4 = p(i, j, k) - p(i-1, j, k)
      else
        abs4 = -(p(i, j, k)-p(i-1, j, k))
      end if
      x1 = (p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))/(omega*(p(i+1, j, &
&       k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+abs4)+plim)
      if (x1 .ge. 0.) then
        dss(i, j, k, 1) = x1
      else
        dss(i, j, k, 1) = -x1
      end if
      if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
        abs2 = p(i, j+1, k) - p(i, j, k)
      else
        abs2 = -(p(i, j+1, k)-p(i, j, k))
      end if
      if (p(i, j, k) - p(i, j-1, k) .ge. 0.) then
        abs5 = p(i, j, k) - p(i, j-1, k)
      else
        abs5 = -(p(i, j, k)-p(i, j-1, k))
      end if
      x2 = (p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))/(omega*(p(i, j+1, &
&       k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+abs5)+plim)
      if (x2 .ge. 0.) then
        dss(i, j, k, 2) = x2
      else
        dss(i, j, k, 2) = -x2
      end if
      if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
        abs3 = p(i, j, k+1) - p(i, j, k)
      else
        abs3 = -(p(i, j, k+1)-p(i, j, k))
      end if
      if (p(i, j, k) - p(i, j, k-1) .ge. 0.) then
        abs6 = p(i, j, k) - p(i, j, k-1)
      else
        abs6 = -(p(i, j, k)-p(i, j, k-1))
      end if
      x3 = (p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))/(omega*(p(i, j, k+&
&       1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+abs6)+plim)
      if (x3 .ge. 0.) then
        dss(i, j, k, 3) = x3
      else
        dss(i, j, k, 3) = -x3
      end if
    end do
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8(sface)
!
!       dissipative fluxes in the i-direction.                         
!
    do ii=0,il*ny*nz-1
      i = mod(ii, il) + 1
      j = mod(ii/il, ny) + 2
      k = ii/(il*ny) + 2
! compute the dissipation coefficients for this face.
      ppor = zero
      if (pori(i, j, k) .eq. normalflux) ppor = one
      if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
        y1 = dss(i+1, j, k, 1)
      else
        y1 = dss(i, j, k, 1)
      end if
      if (dpmax .gt. y1) then
        min1 = y1
      else
        min1 = dpmax
      end if
      dis2 = ppor*fis2*min1
      arg1 = ppor*fis4
      dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
      ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
      dr = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-three&
&       *ddw1)
      ddw2 = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*w(i&
&       , j, k, ivx)
      dru = dis2*ddw2 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(i-1&
&       , j, k, irho)*w(i-1, j, k, ivx)-three*ddw2)
      ddw3 = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*w(i&
&       , j, k, ivy)
      drv = dis2*ddw3 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(i-1&
&       , j, k, irho)*w(i-1, j, k, ivy)-three*ddw3)
      ddw4 = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*w(i&
&       , j, k, ivz)
      drw = dis2*ddw4 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(i-1&
&       , j, k, irho)*w(i-1, j, k, ivz)-three*ddw4)
      ddw5 = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
      dre = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)-&
&       three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
      if (correctfork) then
        ddw6 = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, irho)*&
&         w(i, j, k, itu1)
        drk = dis2*ddw6 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)-w(&
&         i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw6)
        kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
      else
        drk = zero
        kavg = zero
      end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
      gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
      gm1 = gammaavg - one
      ovgm1 = one/gm1
      gm53 = gammaavg - five*third
! compute the average state at the interface.
      uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
      vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
      wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
      a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)+&
&       gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
      area = sqrt(si(i, j, k, 1)**2 + si(i, j, k, 2)**2 + si(i, j, k, 3)&
&       **2)
      if (1.e-25_realtype .lt. area) then
        max1 = area
      else
        max1 = 1.e-25_realtype
      end if
      tmp = one/max1
      sx = si(i, j, k, 1)*tmp
      sy = si(i, j, k, 2)*tmp
      sz = si(i, j, k, 3)*tmp
      alphaavg = half*(uavg**2+vavg**2+wavg**2)
      havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
      aavg = sqrt(a2avg)
      unavg = uavg*sx + vavg*sy + wavg*sz
      ovaavg = one/aavg
      ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
      if (addgridvelocities) sface = sfacei(i, j, k)*tmp
      if (unavg - sface + aavg .ge. 0.) then
        lam1 = unavg - sface + aavg
      else
        lam1 = -(unavg-sface+aavg)
      end if
      if (unavg - sface - aavg .ge. 0.) then
        lam2 = unavg - sface - aavg
      else
        lam2 = -(unavg-sface-aavg)
      end if
      if (unavg - sface .ge. 0.) then
        lam3 = unavg - sface
      else
        lam3 = -(unavg-sface)
      end if
      rrad = lam3 + aavg
      if (lam1 .lt. epsacoustic*rrad) then
        max2 = epsacoustic*rrad
      else
        max2 = lam1
      end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
      lam1 = max2*area
      if (lam2 .lt. epsacoustic*rrad) then
        max3 = epsacoustic*rrad
      else
        max3 = lam2
      end if
      lam2 = max3*area
      if (lam3 .lt. epsshear*rrad) then
        max4 = epsshear*rrad
      else
        max4 = lam3
      end if
      lam3 = max4*area
! some abbreviations, which occur quite often in the
! dissipation terms.
      abv1 = half*(lam1+lam2)
      abv2 = half*(lam1-lam2)
      abv3 = abv1 - lam3
      abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
      abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
      abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
      abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
      fs = lam3*dr + abv6
      fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
      fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
      fs = lam3*dru + uavg*abv6 + sx*abv7
      fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
      fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
      fs = lam3*drv + vavg*abv6 + sy*abv7
      fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
      fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
      fs = lam3*drw + wavg*abv6 + sz*abv7
      fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
      fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
      fs = lam3*dre + havg*abv6 + unavg*abv7
      fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
      fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
    end do
    call pushreal8(aavg)
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8(area)
    call pushreal8(dr)
    call pushreal8(abv4)
    call pushreal8(dis2)
    call pushreal8(dis4)
    call pushreal8(dre)
    call pushreal8(ddw2)
    call pushreal8(ddw3)
    call pushreal8(ddw4)
    call pushreal8(havg)
    call pushreal8(ddw6)
    call pushreal8(dru)
    call pushreal8(drv)
    call pushreal8(drw)
    call pushreal8(a2avg)
    call pushreal8(ppor)
    call pushreal8(sface)
!
!       dissipative fluxes in the j-direction.                         
!
    do ii=0,nx*jl*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, jl) + 1
      k = ii/(nx*jl) + 2
! compute the dissipation coefficients for this face.
      ppor = zero
      if (porj(i, j, k) .eq. normalflux) ppor = one
      if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
        y2 = dss(i, j+1, k, 2)
      else
        y2 = dss(i, j, k, 2)
      end if
      if (dpmax .gt. y2) then
        min2 = y2
      else
        min2 = dpmax
      end if
      dis2 = ppor*fis2*min2
      arg1 = ppor*fis4
      dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
      ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
      dr = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-three&
&       *ddw1)
      ddw2 = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*w(i&
&       , j, k, ivx)
      dru = dis2*ddw2 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(i, &
&       j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw2)
      ddw3 = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*w(i&
&       , j, k, ivy)
      drv = dis2*ddw3 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(i, &
&       j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw3)
      ddw4 = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*w(i&
&       , j, k, ivz)
      drw = dis2*ddw4 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(i, &
&       j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw4)
      ddw5 = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
      dre = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)-&
&       three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
      if (correctfork) then
        ddw6 = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, irho)*&
&         w(i, j, k, itu1)
        drk = dis2*ddw6 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)-w(&
&         i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw6)
        kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
      else
        drk = zero
        kavg = zero
      end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
      gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
      gm1 = gammaavg - one
      ovgm1 = one/gm1
      gm53 = gammaavg - five*third
! compute the average state at the interface.
      uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
      vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
      wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
      a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)+&
&       gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
      area = sqrt(sj(i, j, k, 1)**2 + sj(i, j, k, 2)**2 + sj(i, j, k, 3)&
&       **2)
      if (1.e-25_realtype .lt. area) then
        max5 = area
      else
        max5 = 1.e-25_realtype
      end if
      tmp = one/max5
      sx = sj(i, j, k, 1)*tmp
      sy = sj(i, j, k, 2)*tmp
      sz = sj(i, j, k, 3)*tmp
      alphaavg = half*(uavg**2+vavg**2+wavg**2)
      havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
      aavg = sqrt(a2avg)
      unavg = uavg*sx + vavg*sy + wavg*sz
      ovaavg = one/aavg
      ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
      if (addgridvelocities) sface = sfacej(i, j, k)*tmp
      if (unavg - sface + aavg .ge. 0.) then
        lam1 = unavg - sface + aavg
      else
        lam1 = -(unavg-sface+aavg)
      end if
      if (unavg - sface - aavg .ge. 0.) then
        lam2 = unavg - sface - aavg
      else
        lam2 = -(unavg-sface-aavg)
      end if
      if (unavg - sface .ge. 0.) then
        lam3 = unavg - sface
      else
        lam3 = -(unavg-sface)
      end if
      rrad = lam3 + aavg
      if (lam1 .lt. epsacoustic*rrad) then
        max6 = epsacoustic*rrad
      else
        max6 = lam1
      end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
      lam1 = max6*area
      if (lam2 .lt. epsacoustic*rrad) then
        max7 = epsacoustic*rrad
      else
        max7 = lam2
      end if
      lam2 = max7*area
      if (lam3 .lt. epsshear*rrad) then
        max8 = epsshear*rrad
      else
        max8 = lam3
      end if
      lam3 = max8*area
! some abbreviations, which occur quite often in the
! dissipation terms.
      abv1 = half*(lam1+lam2)
      abv2 = half*(lam1-lam2)
      abv3 = abv1 - lam3
      abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
      abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
      abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
      abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
      fs = lam3*dr + abv6
      fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
      fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
      fs = lam3*dru + uavg*abv6 + sx*abv7
      fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
      fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
      fs = lam3*drv + vavg*abv6 + sy*abv7
      fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
      fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
      fs = lam3*drw + wavg*abv6 + sz*abv7
      fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
      fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
      fs = lam3*dre + havg*abv6 + unavg*abv7
      fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
      fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
    end do
    call pushreal8(aavg)
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8(area)
    call pushreal8(dr)
    call pushreal8(abv4)
    call pushreal8(dis2)
    call pushreal8(dis4)
    call pushreal8(dre)
    call pushreal8(ddw2)
    call pushreal8(ddw3)
    call pushreal8(ddw4)
    call pushreal8(havg)
    call pushreal8(ddw6)
    call pushreal8(dru)
    call pushreal8(drv)
    call pushreal8(drw)
    call pushreal8(a2avg)
    call pushreal8(ppor)
    dssd = 0.0_8
    sfaced = 0.0_8
    do ii=0,nx*ny*kl-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 1
! compute the dissipation coefficients for this face.
      ppor = zero
      if (pork(i, j, k) .eq. normalflux) ppor = one
      if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
        y3 = dss(i, j, k+1, 3)
        call pushcontrol1b(0)
      else
        y3 = dss(i, j, k, 3)
        call pushcontrol1b(1)
      end if
      if (dpmax .gt. y3) then
        min3 = y3
        call pushcontrol1b(0)
      else
        min3 = dpmax
        call pushcontrol1b(1)
      end if
      dis2 = ppor*fis2*min3
      arg1 = ppor*fis4
      dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
      ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
      dr = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)-three&
&       *ddw1)
      ddw2 = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*w(i&
&       , j, k, ivx)
      dru = dis2*ddw2 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)-w(i, &
&       j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw2)
      ddw3 = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*w(i&
&       , j, k, ivy)
      drv = dis2*ddw3 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)-w(i, &
&       j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw3)
      ddw4 = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*w(i&
&       , j, k, ivz)
      drw = dis2*ddw4 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)-w(i, &
&       j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw4)
      ddw5 = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
      dre = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, irhoe)-&
&       three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
      if (correctfork) then
        ddw6 = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, irho)*&
&         w(i, j, k, itu1)
        drk = dis2*ddw6 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, itu1)-w(&
&         i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw6)
        kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
        call pushcontrol1b(1)
      else
        drk = zero
        kavg = zero
        call pushcontrol1b(0)
      end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
      gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
      gm1 = gammaavg - one
      ovgm1 = one/gm1
      gm53 = gammaavg - five*third
! compute the average state at the interface.
      uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
      vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
      wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
      a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)+&
&       gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
      area = sqrt(sk(i, j, k, 1)**2 + sk(i, j, k, 2)**2 + sk(i, j, k, 3)&
&       **2)
      if (1.e-25_realtype .lt. area) then
        max9 = area
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        max9 = 1.e-25_realtype
      end if
      tmp = one/max9
      sx = sk(i, j, k, 1)*tmp
      sy = sk(i, j, k, 2)*tmp
      sz = sk(i, j, k, 3)*tmp
      alphaavg = half*(uavg**2+vavg**2+wavg**2)
      havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
      aavg = sqrt(a2avg)
      unavg = uavg*sx + vavg*sy + wavg*sz
      ovaavg = one/aavg
      ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
      if (addgridvelocities) then
        sface = sfacek(i, j, k)*tmp
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
      if (unavg - sface + aavg .ge. 0.) then
        lam1 = unavg - sface + aavg
        call pushcontrol1b(0)
      else
        lam1 = -(unavg-sface+aavg)
        call pushcontrol1b(1)
      end if
      if (unavg - sface - aavg .ge. 0.) then
        lam2 = unavg - sface - aavg
        call pushcontrol1b(0)
      else
        lam2 = -(unavg-sface-aavg)
        call pushcontrol1b(1)
      end if
      if (unavg - sface .ge. 0.) then
        lam3 = unavg - sface
        call pushcontrol1b(0)
      else
        lam3 = -(unavg-sface)
        call pushcontrol1b(1)
      end if
      rrad = lam3 + aavg
      if (lam1 .lt. epsacoustic*rrad) then
        max10 = epsacoustic*rrad
        call pushcontrol1b(0)
      else
        max10 = lam1
        call pushcontrol1b(1)
      end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
      lam1 = max10*area
      if (lam2 .lt. epsacoustic*rrad) then
        max11 = epsacoustic*rrad
        call pushcontrol1b(0)
      else
        max11 = lam2
        call pushcontrol1b(1)
      end if
      lam2 = max11*area
      if (lam3 .lt. epsshear*rrad) then
        max12 = epsshear*rrad
        call pushcontrol1b(0)
      else
        max12 = lam3
        call pushcontrol1b(1)
      end if
      lam3 = max12*area
! some abbreviations, which occur quite often in the
! dissipation terms.
      abv1 = half*(lam1+lam2)
      abv2 = half*(lam1-lam2)
      abv3 = abv1 - lam3
      abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
      abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
      abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
      abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
      fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
      lam3d = dre*fsd
      dred = lam3*fsd
      havgd = abv6*fsd
      abv6d = havg*fsd
      unavgd = abv7*fsd
      abv7d = unavg*fsd
      fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
      lam3d = lam3d + drw*fsd
      drwd = lam3*fsd
      wavgd = abv6*fsd
      abv6d = abv6d + wavg*fsd
      szd = abv7*fsd
      abv7d = abv7d + sz*fsd
      fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
      lam3d = lam3d + drv*fsd
      drvd = lam3*fsd
      vavgd = abv6*fsd
      abv6d = abv6d + vavg*fsd
      syd = abv7*fsd
      abv7d = abv7d + sy*fsd
      fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
      lam3d = lam3d + dru*fsd
      drud = lam3*fsd
      uavgd = abv6*fsd
      abv6d = abv6d + uavg*fsd
      sxd = abv7*fsd
      abv7d = abv7d + sx*fsd
      fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
      abv6d = abv6d + fsd
      abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
      abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
      ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
      abv3d = ova2avg*abv4*abv6d + abv5*abv7d
      lam3d = lam3d + dr*fsd - abv3d
      abv5d = ovaavg*abv2*abv6d + abv3*abv7d
      ova2avgd = abv3*abv4*abv6d
      sxd = sxd + dru*abv5d
      syd = syd + drv*abv5d
      szd = szd + drw*abv5d
      unavgd = unavgd - dr*abv5d
      tempd40 = gm1*abv4d
      drd = alphaavg*tempd40 - unavg*abv5d + lam3*fsd
      drud = drud + sx*abv5d - uavg*tempd40
      drvd = drvd + sy*abv5d - vavg*tempd40
      drwd = drwd + sz*abv5d - wavg*tempd40
      alphaavgd = dr*tempd40
      uavgd = uavgd - dru*tempd40
      vavgd = vavgd - drv*tempd40
      dred = dred + tempd40
      wavgd = wavgd - drw*tempd40
      drkd = -(gm53*abv4d)
      abv1d = abv3d
      lam1d = half*abv1d + half*abv2d
      lam2d = half*abv1d - half*abv2d
      max12d = area*lam3d
      aread = max12*lam3d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = epsshear*max12d
        lam3d = 0.0_8
      else
        lam3d = max12d
        rradd = 0.0_8
      end if
      max11d = area*lam2d
      aread = aread + max11*lam2d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = rradd + epsacoustic*max11d
        lam2d = 0.0_8
      else
        lam2d = max11d
      end if
      max10d = area*lam1d
      aread = aread + max10*lam1d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = rradd + epsacoustic*max10d
        lam1d = 0.0_8
      else
        lam1d = max10d
      end if
      lam3d = lam3d + rradd
      aavgd = rradd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam3d
        sfaced = sfaced - lam3d
      else
        sfaced = sfaced + lam3d
        unavgd = unavgd - lam3d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam2d
        sfaced = sfaced - lam2d
        aavgd = aavgd - lam2d
      else
        sfaced = sfaced + lam2d
        unavgd = unavgd - lam2d
        aavgd = aavgd + lam2d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam1d
        sfaced = sfaced - lam1d
        aavgd = aavgd + lam1d
      else
        sfaced = sfaced + lam1d
        unavgd = unavgd - lam1d
        aavgd = aavgd - lam1d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tmpd = 0.0_8
      else
        tmpd = sfacek(i, j, k)*sfaced
        sfaced = 0.0_8
      end if
      alphaavgd = alphaavgd + havgd
      tempd39 = half*alphaavgd
      aavgd = aavgd - one*ovaavgd/aavg**2
      if (a2avg .eq. 0.0_8) then
        a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
      else
        a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*ova2avgd/&
&         a2avg**2
      end if
      uavgd = uavgd + 2*uavg*tempd39 + sx*unavgd
      sxd = sxd + uavg*unavgd
      vavgd = vavgd + 2*vavg*tempd39 + sy*unavgd
      syd = syd + vavg*unavgd
      wavgd = wavgd + 2*wavg*tempd39 + sz*unavgd
      szd = szd + wavg*unavgd
      kavgd = -(ovgm1*gm53*havgd)
      skd(i, j, k, 3) = skd(i, j, k, 3) + tmp*szd
      tmpd = tmpd + sk(i, j, k, 2)*syd + sk(i, j, k, 1)*sxd + sk(i, j, k&
&       , 3)*szd
      skd(i, j, k, 2) = skd(i, j, k, 2) + tmp*syd
      skd(i, j, k, 1) = skd(i, j, k, 1) + tmp*sxd
      max9d = -(one*tmpd/max9**2)
      call popcontrol1b(branch)
      if (branch .eq. 0) aread = aread + max9d
      temp64 = sk(i, j, k, 3)
      temp63 = sk(i, j, k, 2)
      temp62 = sk(i, j, k, 1)
      if (temp62**2 + temp63**2 + temp64**2 .eq. 0.0_8) then
        tempd36 = 0.0
      else
        tempd36 = aread/(2.0*sqrt(temp62**2+temp63**2+temp64**2))
      end if
      skd(i, j, k, 1) = skd(i, j, k, 1) + 2*temp62*tempd36
      skd(i, j, k, 2) = skd(i, j, k, 2) + 2*temp63*tempd36
      skd(i, j, k, 3) = skd(i, j, k, 3) + 2*temp64*tempd36
      temp61 = w(i, j, k, irho)
      temp60 = w(i, j, k+1, irho)
      tempd37 = gamma(i, j, k+1)*half*a2avgd/temp60
      tempd38 = gamma(i, j, k)*half*a2avgd/temp61
      pd(i, j, k+1) = pd(i, j, k+1) + tempd37
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - p(i, j, k+1)*tempd37/&
&       temp60
      pd(i, j, k) = pd(i, j, k) + tempd38
      wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd38/temp61
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wavgd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vavgd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*uavgd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        dis2d = 0.0_8
        dis4d = 0.0_8
      else
        wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*kavgd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
        temp59 = w(i, j, k-1, itu1)
        temp58 = w(i, j, k-1, irho)
        temp57 = w(i, j, k+2, itu1)
        temp56 = w(i, j, k+2, irho)
        tempd35 = -(dis4*drkd)
        dis2d = ddw6*drkd
        ddw6d = dis2*drkd - three*tempd35
        dis4d = -((temp56*temp57-temp58*temp59-three*ddw6)*drkd)
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp57*tempd35
        wd(i, j, k+2, itu1) = wd(i, j, k+2, itu1) + temp56*tempd35
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp59*tempd35
        wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) - temp58*tempd35
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, itu1)*&
&         ddw6d
        wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + w(i, j, k+1, irho)*&
&         ddw6d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*ddw6d
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*ddw6d
      end if
      temp44 = w(i, j, k+2, irho)
      temp45 = w(i, j, k+2, ivx)
      temp46 = w(i, j, k-1, irho)
      temp47 = w(i, j, k-1, ivx)
      temp48 = w(i, j, k+2, irho)
      temp49 = w(i, j, k+2, ivy)
      temp50 = w(i, j, k-1, irho)
      temp51 = w(i, j, k-1, ivy)
      temp52 = w(i, j, k+2, irho)
      temp53 = w(i, j, k+2, ivz)
      temp54 = w(i, j, k-1, irho)
      temp55 = w(i, j, k-1, ivz)
      tempd30 = -(dis4*dred)
      dis2d = dis2d + ddw4*drwd + ddw2*drud + ddw1*drd + ddw3*drvd + &
&       ddw5*dred
      ddw5d = dis2*dred - three*tempd30
      dis4d = dis4d - (temp52*temp53-temp54*temp55-three*ddw4)*drwd - (&
&       temp44*temp45-temp46*temp47-three*ddw2)*drud - (w(i, j, k+2, &
&       irho)-w(i, j, k-1, irho)-three*ddw1)*drd - (temp48*temp49-temp50&
&       *temp51-three*ddw3)*drvd - (w(i, j, k+2, irhoe)-w(i, j, k-1, &
&       irhoe)-three*ddw5)*dred
      wd(i, j, k+2, irhoe) = wd(i, j, k+2, irhoe) + tempd30
      wd(i, j, k-1, irhoe) = wd(i, j, k-1, irhoe) - tempd30
      wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddw5d
      wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
      tempd31 = -(dis4*drwd)
      ddw4d = dis2*drwd - three*tempd31
      wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp53*tempd31
      wd(i, j, k+2, ivz) = wd(i, j, k+2, ivz) + temp52*tempd31
      wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp55*tempd31
      wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - temp54*tempd31
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
&       ddw4d
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)*ddw4d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
      wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
      tempd32 = -(dis4*drvd)
      ddw3d = dis2*drvd - three*tempd32
      wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp49*tempd32
      wd(i, j, k+2, ivy) = wd(i, j, k+2, ivy) + temp48*tempd32
      wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp51*tempd32
      wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - temp50*tempd32
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
&       ddw3d
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)*ddw3d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
      wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
      tempd33 = -(dis4*drud)
      ddw2d = dis2*drud - three*tempd33
      wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp45*tempd33
      wd(i, j, k+2, ivx) = wd(i, j, k+2, ivx) + temp44*tempd33
      wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp47*tempd33
      wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - temp46*tempd33
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
&       ddw2d
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)*ddw2d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
      wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
      tempd34 = -(dis4*drd)
      ddw1d = dis2*drd - three*tempd34
      wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + tempd34
      wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - tempd34
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddw1d
      wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
      arg1d = 0.0_8
      call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
      min3d = ppor*fis2*dis2d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        y3d = min3d
      else
        y3d = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        dssd(i, j, k+1, 3) = dssd(i, j, k+1, 3) + y3d
      else
        dssd(i, j, k, 3) = dssd(i, j, k, 3) + y3d
      end if
    end do
    call popreal8(ppor)
    call popreal8(a2avg)
    call popreal8(drw)
    call popreal8(drv)
    call popreal8(dru)
    call popreal8(ddw6)
    call popreal8(havg)
    call popreal8(ddw4)
    call popreal8(ddw3)
    call popreal8(ddw2)
    call popreal8(dre)
    call popreal8(dis4)
    call popreal8(dis2)
    call popreal8(abv4)
    call popreal8(dr)
    call popreal8(area)
    call popinteger4(j)
    call popinteger4(i)
    call popreal8(aavg)
    call popreal8(sface)
    do ii=0,nx*jl*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, jl) + 1
      k = ii/(nx*jl) + 2
! compute the dissipation coefficients for this face.
      ppor = zero
      if (porj(i, j, k) .eq. normalflux) ppor = one
      if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
        y2 = dss(i, j+1, k, 2)
        call pushcontrol1b(0)
      else
        y2 = dss(i, j, k, 2)
        call pushcontrol1b(1)
      end if
      if (dpmax .gt. y2) then
        min2 = y2
        call pushcontrol1b(0)
      else
        min2 = dpmax
        call pushcontrol1b(1)
      end if
      dis2 = ppor*fis2*min2
      arg1 = ppor*fis4
      dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
      ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
      dr = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-three&
&       *ddw1)
      ddw2 = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*w(i&
&       , j, k, ivx)
      dru = dis2*ddw2 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(i, &
&       j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw2)
      ddw3 = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*w(i&
&       , j, k, ivy)
      drv = dis2*ddw3 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(i, &
&       j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw3)
      ddw4 = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*w(i&
&       , j, k, ivz)
      drw = dis2*ddw4 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(i, &
&       j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw4)
      ddw5 = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
      dre = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)-&
&       three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
      if (correctfork) then
        ddw6 = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, irho)*&
&         w(i, j, k, itu1)
        drk = dis2*ddw6 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)-w(&
&         i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw6)
        kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
        call pushcontrol1b(1)
      else
        drk = zero
        kavg = zero
        call pushcontrol1b(0)
      end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
      gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
      gm1 = gammaavg - one
      ovgm1 = one/gm1
      gm53 = gammaavg - five*third
! compute the average state at the interface.
      uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
      vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
      wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
      a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)+&
&       gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
      area = sqrt(sj(i, j, k, 1)**2 + sj(i, j, k, 2)**2 + sj(i, j, k, 3)&
&       **2)
      if (1.e-25_realtype .lt. area) then
        max5 = area
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        max5 = 1.e-25_realtype
      end if
      tmp = one/max5
      sx = sj(i, j, k, 1)*tmp
      sy = sj(i, j, k, 2)*tmp
      sz = sj(i, j, k, 3)*tmp
      alphaavg = half*(uavg**2+vavg**2+wavg**2)
      havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
      aavg = sqrt(a2avg)
      unavg = uavg*sx + vavg*sy + wavg*sz
      ovaavg = one/aavg
      ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
      if (addgridvelocities) then
        sface = sfacej(i, j, k)*tmp
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
      if (unavg - sface + aavg .ge. 0.) then
        lam1 = unavg - sface + aavg
        call pushcontrol1b(0)
      else
        lam1 = -(unavg-sface+aavg)
        call pushcontrol1b(1)
      end if
      if (unavg - sface - aavg .ge. 0.) then
        lam2 = unavg - sface - aavg
        call pushcontrol1b(0)
      else
        lam2 = -(unavg-sface-aavg)
        call pushcontrol1b(1)
      end if
      if (unavg - sface .ge. 0.) then
        lam3 = unavg - sface
        call pushcontrol1b(0)
      else
        lam3 = -(unavg-sface)
        call pushcontrol1b(1)
      end if
      rrad = lam3 + aavg
      if (lam1 .lt. epsacoustic*rrad) then
        max6 = epsacoustic*rrad
        call pushcontrol1b(0)
      else
        max6 = lam1
        call pushcontrol1b(1)
      end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
      lam1 = max6*area
      if (lam2 .lt. epsacoustic*rrad) then
        max7 = epsacoustic*rrad
        call pushcontrol1b(0)
      else
        max7 = lam2
        call pushcontrol1b(1)
      end if
      lam2 = max7*area
      if (lam3 .lt. epsshear*rrad) then
        max8 = epsshear*rrad
        call pushcontrol1b(0)
      else
        max8 = lam3
        call pushcontrol1b(1)
      end if
      lam3 = max8*area
! some abbreviations, which occur quite often in the
! dissipation terms.
      abv1 = half*(lam1+lam2)
      abv2 = half*(lam1-lam2)
      abv3 = abv1 - lam3
      abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
      abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
      abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
      abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
      fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
      lam3d = dre*fsd
      dred = lam3*fsd
      havgd = abv6*fsd
      abv6d = havg*fsd
      unavgd = abv7*fsd
      abv7d = unavg*fsd
      fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
      lam3d = lam3d + drw*fsd
      drwd = lam3*fsd
      wavgd = abv6*fsd
      abv6d = abv6d + wavg*fsd
      szd = abv7*fsd
      abv7d = abv7d + sz*fsd
      fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
      lam3d = lam3d + drv*fsd
      drvd = lam3*fsd
      vavgd = abv6*fsd
      abv6d = abv6d + vavg*fsd
      syd = abv7*fsd
      abv7d = abv7d + sy*fsd
      fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
      lam3d = lam3d + dru*fsd
      drud = lam3*fsd
      uavgd = abv6*fsd
      abv6d = abv6d + uavg*fsd
      sxd = abv7*fsd
      abv7d = abv7d + sx*fsd
      fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
      abv6d = abv6d + fsd
      abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
      abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
      ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
      abv3d = ova2avg*abv4*abv6d + abv5*abv7d
      lam3d = lam3d + dr*fsd - abv3d
      abv5d = ovaavg*abv2*abv6d + abv3*abv7d
      ova2avgd = abv3*abv4*abv6d
      sxd = sxd + dru*abv5d
      syd = syd + drv*abv5d
      szd = szd + drw*abv5d
      unavgd = unavgd - dr*abv5d
      tempd29 = gm1*abv4d
      drd = alphaavg*tempd29 - unavg*abv5d + lam3*fsd
      drud = drud + sx*abv5d - uavg*tempd29
      drvd = drvd + sy*abv5d - vavg*tempd29
      drwd = drwd + sz*abv5d - wavg*tempd29
      alphaavgd = dr*tempd29
      uavgd = uavgd - dru*tempd29
      vavgd = vavgd - drv*tempd29
      dred = dred + tempd29
      wavgd = wavgd - drw*tempd29
      drkd = -(gm53*abv4d)
      abv1d = abv3d
      lam1d = half*abv1d + half*abv2d
      lam2d = half*abv1d - half*abv2d
      max8d = area*lam3d
      aread = max8*lam3d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = epsshear*max8d
        lam3d = 0.0_8
      else
        lam3d = max8d
        rradd = 0.0_8
      end if
      max7d = area*lam2d
      aread = aread + max7*lam2d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = rradd + epsacoustic*max7d
        lam2d = 0.0_8
      else
        lam2d = max7d
      end if
      max6d = area*lam1d
      aread = aread + max6*lam1d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = rradd + epsacoustic*max6d
        lam1d = 0.0_8
      else
        lam1d = max6d
      end if
      lam3d = lam3d + rradd
      aavgd = rradd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam3d
        sfaced = sfaced - lam3d
      else
        sfaced = sfaced + lam3d
        unavgd = unavgd - lam3d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam2d
        sfaced = sfaced - lam2d
        aavgd = aavgd - lam2d
      else
        sfaced = sfaced + lam2d
        unavgd = unavgd - lam2d
        aavgd = aavgd + lam2d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam1d
        sfaced = sfaced - lam1d
        aavgd = aavgd + lam1d
      else
        sfaced = sfaced + lam1d
        unavgd = unavgd - lam1d
        aavgd = aavgd - lam1d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tmpd = 0.0_8
      else
        tmpd = sfacej(i, j, k)*sfaced
        sfaced = 0.0_8
      end if
      alphaavgd = alphaavgd + havgd
      tempd28 = half*alphaavgd
      aavgd = aavgd - one*ovaavgd/aavg**2
      if (a2avg .eq. 0.0_8) then
        a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
      else
        a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*ova2avgd/&
&         a2avg**2
      end if
      uavgd = uavgd + 2*uavg*tempd28 + sx*unavgd
      sxd = sxd + uavg*unavgd
      vavgd = vavgd + 2*vavg*tempd28 + sy*unavgd
      syd = syd + vavg*unavgd
      wavgd = wavgd + 2*wavg*tempd28 + sz*unavgd
      szd = szd + wavg*unavgd
      kavgd = -(ovgm1*gm53*havgd)
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + tmp*szd
      tmpd = tmpd + sj(i, j, k, 2)*syd + sj(i, j, k, 1)*sxd + sj(i, j, k&
&       , 3)*szd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + tmp*syd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + tmp*sxd
      max5d = -(one*tmpd/max5**2)
      call popcontrol1b(branch)
      if (branch .eq. 0) aread = aread + max5d
      temp43 = sj(i, j, k, 3)
      temp42 = sj(i, j, k, 2)
      temp41 = sj(i, j, k, 1)
      if (temp41**2 + temp42**2 + temp43**2 .eq. 0.0_8) then
        tempd25 = 0.0
      else
        tempd25 = aread/(2.0*sqrt(temp41**2+temp42**2+temp43**2))
      end if
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + 2*temp41*tempd25
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + 2*temp42*tempd25
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + 2*temp43*tempd25
      temp40 = w(i, j, k, irho)
      temp39 = w(i, j+1, k, irho)
      tempd26 = gamma(i, j+1, k)*half*a2avgd/temp39
      tempd27 = gamma(i, j, k)*half*a2avgd/temp40
      pd(i, j+1, k) = pd(i, j+1, k) + tempd26
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - p(i, j+1, k)*tempd26/&
&       temp39
      pd(i, j, k) = pd(i, j, k) + tempd27
      wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd27/temp40
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wavgd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vavgd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*uavgd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        dis2d = 0.0_8
        dis4d = 0.0_8
      else
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
        wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*kavgd
        temp38 = w(i, j-1, k, itu1)
        temp37 = w(i, j-1, k, irho)
        temp36 = w(i, j+2, k, itu1)
        temp35 = w(i, j+2, k, irho)
        tempd24 = -(dis4*drkd)
        dis2d = ddw6*drkd
        ddw6d = dis2*drkd - three*tempd24
        dis4d = -((temp35*temp36-temp37*temp38-three*ddw6)*drkd)
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp36*tempd24
        wd(i, j+2, k, itu1) = wd(i, j+2, k, itu1) + temp35*tempd24
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp38*tempd24
        wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) - temp37*tempd24
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, itu1)*&
&         ddw6d
        wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + w(i, j+1, k, irho)*&
&         ddw6d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*ddw6d
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*ddw6d
      end if
      temp23 = w(i, j+2, k, irho)
      temp24 = w(i, j+2, k, ivx)
      temp25 = w(i, j-1, k, irho)
      temp26 = w(i, j-1, k, ivx)
      temp27 = w(i, j+2, k, irho)
      temp28 = w(i, j+2, k, ivy)
      temp29 = w(i, j-1, k, irho)
      temp30 = w(i, j-1, k, ivy)
      temp31 = w(i, j+2, k, irho)
      temp32 = w(i, j+2, k, ivz)
      temp33 = w(i, j-1, k, irho)
      temp34 = w(i, j-1, k, ivz)
      tempd19 = -(dis4*dred)
      dis2d = dis2d + ddw4*drwd + ddw2*drud + ddw1*drd + ddw3*drvd + &
&       ddw5*dred
      ddw5d = dis2*dred - three*tempd19
      dis4d = dis4d - (temp31*temp32-temp33*temp34-three*ddw4)*drwd - (&
&       temp23*temp24-temp25*temp26-three*ddw2)*drud - (w(i, j+2, k, &
&       irho)-w(i, j-1, k, irho)-three*ddw1)*drd - (temp27*temp28-temp29&
&       *temp30-three*ddw3)*drvd - (w(i, j+2, k, irhoe)-w(i, j-1, k, &
&       irhoe)-three*ddw5)*dred
      wd(i, j+2, k, irhoe) = wd(i, j+2, k, irhoe) + tempd19
      wd(i, j-1, k, irhoe) = wd(i, j-1, k, irhoe) - tempd19
      wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddw5d
      wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
      tempd20 = -(dis4*drwd)
      ddw4d = dis2*drwd - three*tempd20
      wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp32*tempd20
      wd(i, j+2, k, ivz) = wd(i, j+2, k, ivz) + temp31*tempd20
      wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp34*tempd20
      wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - temp33*tempd20
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
&       ddw4d
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)*ddw4d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
      wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
      tempd21 = -(dis4*drvd)
      ddw3d = dis2*drvd - three*tempd21
      wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp28*tempd21
      wd(i, j+2, k, ivy) = wd(i, j+2, k, ivy) + temp27*tempd21
      wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp30*tempd21
      wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - temp29*tempd21
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
&       ddw3d
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)*ddw3d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
      wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
      tempd22 = -(dis4*drud)
      ddw2d = dis2*drud - three*tempd22
      wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp24*tempd22
      wd(i, j+2, k, ivx) = wd(i, j+2, k, ivx) + temp23*tempd22
      wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp26*tempd22
      wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - temp25*tempd22
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
&       ddw2d
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)*ddw2d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
      wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
      tempd23 = -(dis4*drd)
      ddw1d = dis2*drd - three*tempd23
      wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + tempd23
      wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - tempd23
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddw1d
      wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
      arg1d = 0.0_8
      call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
      min2d = ppor*fis2*dis2d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        y2d = min2d
      else
        y2d = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        dssd(i, j+1, k, 2) = dssd(i, j+1, k, 2) + y2d
      else
        dssd(i, j, k, 2) = dssd(i, j, k, 2) + y2d
      end if
    end do
    call popreal8(ppor)
    call popreal8(a2avg)
    call popreal8(drw)
    call popreal8(drv)
    call popreal8(dru)
    call popreal8(ddw6)
    call popreal8(havg)
    call popreal8(ddw4)
    call popreal8(ddw3)
    call popreal8(ddw2)
    call popreal8(dre)
    call popreal8(dis4)
    call popreal8(dis2)
    call popreal8(abv4)
    call popreal8(dr)
    call popreal8(area)
    call popinteger4(j)
    call popinteger4(i)
    call popreal8(aavg)
    call popreal8(sface)
    do ii=0,il*ny*nz-1
      i = mod(ii, il) + 1
      j = mod(ii/il, ny) + 2
      k = ii/(il*ny) + 2
! compute the dissipation coefficients for this face.
      ppor = zero
      if (pori(i, j, k) .eq. normalflux) ppor = one
      if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
        y1 = dss(i+1, j, k, 1)
        call pushcontrol1b(0)
      else
        y1 = dss(i, j, k, 1)
        call pushcontrol1b(1)
      end if
      if (dpmax .gt. y1) then
        min1 = y1
        call pushcontrol1b(0)
      else
        min1 = dpmax
        call pushcontrol1b(1)
      end if
      dis2 = ppor*fis2*min1
      arg1 = ppor*fis4
      dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
      ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
      dr = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-three&
&       *ddw1)
      ddw2 = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*w(i&
&       , j, k, ivx)
      dru = dis2*ddw2 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(i-1&
&       , j, k, irho)*w(i-1, j, k, ivx)-three*ddw2)
      ddw3 = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*w(i&
&       , j, k, ivy)
      drv = dis2*ddw3 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(i-1&
&       , j, k, irho)*w(i-1, j, k, ivy)-three*ddw3)
      ddw4 = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*w(i&
&       , j, k, ivz)
      drw = dis2*ddw4 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(i-1&
&       , j, k, irho)*w(i-1, j, k, ivz)-three*ddw4)
      ddw5 = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
      dre = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)-&
&       three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
      if (correctfork) then
        ddw6 = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, irho)*&
&         w(i, j, k, itu1)
        drk = dis2*ddw6 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)-w(&
&         i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw6)
        kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
        call pushcontrol1b(1)
      else
        drk = zero
        kavg = zero
        call pushcontrol1b(0)
      end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
      gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
      gm1 = gammaavg - one
      ovgm1 = one/gm1
      gm53 = gammaavg - five*third
! compute the average state at the interface.
      uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
      vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
      wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
      a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)+&
&       gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
      area = sqrt(si(i, j, k, 1)**2 + si(i, j, k, 2)**2 + si(i, j, k, 3)&
&       **2)
      if (1.e-25_realtype .lt. area) then
        max1 = area
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
        max1 = 1.e-25_realtype
      end if
      tmp = one/max1
      sx = si(i, j, k, 1)*tmp
      sy = si(i, j, k, 2)*tmp
      sz = si(i, j, k, 3)*tmp
      alphaavg = half*(uavg**2+vavg**2+wavg**2)
      havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
      aavg = sqrt(a2avg)
      unavg = uavg*sx + vavg*sy + wavg*sz
      ovaavg = one/aavg
      ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
      if (addgridvelocities) then
        sface = sfacei(i, j, k)*tmp
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
      if (unavg - sface + aavg .ge. 0.) then
        lam1 = unavg - sface + aavg
        call pushcontrol1b(0)
      else
        lam1 = -(unavg-sface+aavg)
        call pushcontrol1b(1)
      end if
      if (unavg - sface - aavg .ge. 0.) then
        lam2 = unavg - sface - aavg
        call pushcontrol1b(0)
      else
        lam2 = -(unavg-sface-aavg)
        call pushcontrol1b(1)
      end if
      if (unavg - sface .ge. 0.) then
        lam3 = unavg - sface
        call pushcontrol1b(0)
      else
        lam3 = -(unavg-sface)
        call pushcontrol1b(1)
      end if
      rrad = lam3 + aavg
      if (lam1 .lt. epsacoustic*rrad) then
        max2 = epsacoustic*rrad
        call pushcontrol1b(0)
      else
        max2 = lam1
        call pushcontrol1b(1)
      end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
      lam1 = max2*area
      if (lam2 .lt. epsacoustic*rrad) then
        max3 = epsacoustic*rrad
        call pushcontrol1b(0)
      else
        max3 = lam2
        call pushcontrol1b(1)
      end if
      lam2 = max3*area
      if (lam3 .lt. epsshear*rrad) then
        max4 = epsshear*rrad
        call pushcontrol1b(0)
      else
        max4 = lam3
        call pushcontrol1b(1)
      end if
      lam3 = max4*area
! some abbreviations, which occur quite often in the
! dissipation terms.
      abv1 = half*(lam1+lam2)
      abv2 = half*(lam1-lam2)
      abv3 = abv1 - lam3
      abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*drk
      abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
      abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
      abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
      fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
      lam3d = dre*fsd
      dred = lam3*fsd
      havgd = abv6*fsd
      abv6d = havg*fsd
      unavgd = abv7*fsd
      abv7d = unavg*fsd
      fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
      lam3d = lam3d + drw*fsd
      drwd = lam3*fsd
      wavgd = abv6*fsd
      abv6d = abv6d + wavg*fsd
      szd = abv7*fsd
      abv7d = abv7d + sz*fsd
      fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
      lam3d = lam3d + drv*fsd
      drvd = lam3*fsd
      vavgd = abv6*fsd
      abv6d = abv6d + vavg*fsd
      syd = abv7*fsd
      abv7d = abv7d + sy*fsd
      fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
      lam3d = lam3d + dru*fsd
      drud = lam3*fsd
      uavgd = abv6*fsd
      abv6d = abv6d + uavg*fsd
      sxd = abv7*fsd
      abv7d = abv7d + sx*fsd
      fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
      abv6d = abv6d + fsd
      abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
      abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
      ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
      abv3d = ova2avg*abv4*abv6d + abv5*abv7d
      lam3d = lam3d + dr*fsd - abv3d
      abv5d = ovaavg*abv2*abv6d + abv3*abv7d
      ova2avgd = abv3*abv4*abv6d
      sxd = sxd + dru*abv5d
      syd = syd + drv*abv5d
      szd = szd + drw*abv5d
      unavgd = unavgd - dr*abv5d
      tempd18 = gm1*abv4d
      drd = alphaavg*tempd18 - unavg*abv5d + lam3*fsd
      drud = drud + sx*abv5d - uavg*tempd18
      drvd = drvd + sy*abv5d - vavg*tempd18
      drwd = drwd + sz*abv5d - wavg*tempd18
      alphaavgd = dr*tempd18
      uavgd = uavgd - dru*tempd18
      vavgd = vavgd - drv*tempd18
      dred = dred + tempd18
      wavgd = wavgd - drw*tempd18
      drkd = -(gm53*abv4d)
      abv1d = abv3d
      lam1d = half*abv1d + half*abv2d
      lam2d = half*abv1d - half*abv2d
      max4d = area*lam3d
      aread = max4*lam3d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = epsshear*max4d
        lam3d = 0.0_8
      else
        lam3d = max4d
        rradd = 0.0_8
      end if
      max3d = area*lam2d
      aread = aread + max3*lam2d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = rradd + epsacoustic*max3d
        lam2d = 0.0_8
      else
        lam2d = max3d
      end if
      max2d = area*lam1d
      aread = aread + max2*lam1d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rradd = rradd + epsacoustic*max2d
        lam1d = 0.0_8
      else
        lam1d = max2d
      end if
      lam3d = lam3d + rradd
      aavgd = rradd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam3d
        sfaced = sfaced - lam3d
      else
        sfaced = sfaced + lam3d
        unavgd = unavgd - lam3d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam2d
        sfaced = sfaced - lam2d
        aavgd = aavgd - lam2d
      else
        sfaced = sfaced + lam2d
        unavgd = unavgd - lam2d
        aavgd = aavgd + lam2d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        unavgd = unavgd + lam1d
        sfaced = sfaced - lam1d
        aavgd = aavgd + lam1d
      else
        sfaced = sfaced + lam1d
        unavgd = unavgd - lam1d
        aavgd = aavgd - lam1d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tmpd = 0.0_8
      else
        tmpd = sfacei(i, j, k)*sfaced
        sfaced = 0.0_8
      end if
      alphaavgd = alphaavgd + havgd
      tempd17 = half*alphaavgd
      aavgd = aavgd - one*ovaavgd/aavg**2
      if (a2avg .eq. 0.0_8) then
        a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
      else
        a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*ova2avgd/&
&         a2avg**2
      end if
      uavgd = uavgd + 2*uavg*tempd17 + sx*unavgd
      sxd = sxd + uavg*unavgd
      vavgd = vavgd + 2*vavg*tempd17 + sy*unavgd
      syd = syd + vavg*unavgd
      wavgd = wavgd + 2*wavg*tempd17 + sz*unavgd
      szd = szd + wavg*unavgd
      kavgd = -(ovgm1*gm53*havgd)
      sid(i, j, k, 3) = sid(i, j, k, 3) + tmp*szd
      tmpd = tmpd + si(i, j, k, 2)*syd + si(i, j, k, 1)*sxd + si(i, j, k&
&       , 3)*szd
      sid(i, j, k, 2) = sid(i, j, k, 2) + tmp*syd
      sid(i, j, k, 1) = sid(i, j, k, 1) + tmp*sxd
      max1d = -(one*tmpd/max1**2)
      call popcontrol1b(branch)
      if (branch .eq. 0) aread = aread + max1d
      temp22 = si(i, j, k, 3)
      temp21 = si(i, j, k, 2)
      temp20 = si(i, j, k, 1)
      if (temp20**2 + temp21**2 + temp22**2 .eq. 0.0_8) then
        tempd14 = 0.0
      else
        tempd14 = aread/(2.0*sqrt(temp20**2+temp21**2+temp22**2))
      end if
      sid(i, j, k, 1) = sid(i, j, k, 1) + 2*temp20*tempd14
      sid(i, j, k, 2) = sid(i, j, k, 2) + 2*temp21*tempd14
      sid(i, j, k, 3) = sid(i, j, k, 3) + 2*temp22*tempd14
      temp19 = w(i, j, k, irho)
      temp18 = w(i+1, j, k, irho)
      tempd15 = gamma(i+1, j, k)*half*a2avgd/temp18
      tempd16 = gamma(i, j, k)*half*a2avgd/temp19
      pd(i+1, j, k) = pd(i+1, j, k) + tempd15
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - p(i+1, j, k)*tempd15/&
&       temp18
      pd(i, j, k) = pd(i, j, k) + tempd16
      wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd16/temp19
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wavgd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vavgd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*uavgd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        dis2d = 0.0_8
        dis4d = 0.0_8
      else
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
        wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*kavgd
        temp17 = w(i-1, j, k, itu1)
        temp16 = w(i-1, j, k, irho)
        temp15 = w(i+2, j, k, itu1)
        temp14 = w(i+2, j, k, irho)
        tempd13 = -(dis4*drkd)
        dis2d = ddw6*drkd
        ddw6d = dis2*drkd - three*tempd13
        dis4d = -((temp14*temp15-temp16*temp17-three*ddw6)*drkd)
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp15*tempd13
        wd(i+2, j, k, itu1) = wd(i+2, j, k, itu1) + temp14*tempd13
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp17*tempd13
        wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) - temp16*tempd13
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, itu1)*&
&         ddw6d
        wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + w(i+1, j, k, irho)*&
&         ddw6d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*ddw6d
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*ddw6d
      end if
      temp2 = w(i+2, j, k, irho)
      temp3 = w(i+2, j, k, ivx)
      temp4 = w(i-1, j, k, irho)
      temp5 = w(i-1, j, k, ivx)
      temp6 = w(i+2, j, k, irho)
      temp7 = w(i+2, j, k, ivy)
      temp8 = w(i-1, j, k, irho)
      temp9 = w(i-1, j, k, ivy)
      temp10 = w(i+2, j, k, irho)
      temp11 = w(i+2, j, k, ivz)
      temp12 = w(i-1, j, k, irho)
      temp13 = w(i-1, j, k, ivz)
      tempd8 = -(dis4*dred)
      dis2d = dis2d + ddw4*drwd + ddw2*drud + ddw1*drd + ddw3*drvd + &
&       ddw5*dred
      ddw5d = dis2*dred - three*tempd8
      dis4d = dis4d - (temp10*temp11-temp12*temp13-three*ddw4)*drwd - (&
&       temp2*temp3-temp4*temp5-three*ddw2)*drud - (w(i+2, j, k, irho)-w&
&       (i-1, j, k, irho)-three*ddw1)*drd - (temp6*temp7-temp8*temp9-&
&       three*ddw3)*drvd - (w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)-&
&       three*ddw5)*dred
      wd(i+2, j, k, irhoe) = wd(i+2, j, k, irhoe) + tempd8
      wd(i-1, j, k, irhoe) = wd(i-1, j, k, irhoe) - tempd8
      wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddw5d
      wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
      tempd9 = -(dis4*drwd)
      ddw4d = dis2*drwd - three*tempd9
      wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp11*tempd9
      wd(i+2, j, k, ivz) = wd(i+2, j, k, ivz) + temp10*tempd9
      wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp13*tempd9
      wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - temp12*tempd9
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
&       ddw4d
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)*ddw4d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
      wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
      tempd10 = -(dis4*drvd)
      ddw3d = dis2*drvd - three*tempd10
      wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp7*tempd10
      wd(i+2, j, k, ivy) = wd(i+2, j, k, ivy) + temp6*tempd10
      wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp9*tempd10
      wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - temp8*tempd10
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
&       ddw3d
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)*ddw3d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
      wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
      tempd11 = -(dis4*drud)
      ddw2d = dis2*drud - three*tempd11
      wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp3*tempd11
      wd(i+2, j, k, ivx) = wd(i+2, j, k, ivx) + temp2*tempd11
      wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp5*tempd11
      wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - temp4*tempd11
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
&       ddw2d
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)*ddw2d
      wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
      wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
      tempd12 = -(dis4*drd)
      ddw1d = dis2*drd - three*tempd12
      wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + tempd12
      wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - tempd12
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddw1d
      wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
      arg1d = 0.0_8
      call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
      min1d = ppor*fis2*dis2d
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        y1d = min1d
      else
        y1d = 0.0_8
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        dssd(i+1, j, k, 1) = dssd(i+1, j, k, 1) + y1d
      else
        dssd(i, j, k, 1) = dssd(i, j, k, 1) + y1d
      end if
    end do
    call popinteger4(j)
    call popinteger4(i)
    plimd = 0.0_8
    do ii=0,ie*je*ke-1
      i = mod(ii, ie) + 1
      j = mod(ii/ie, je) + 1
      k = ii/(ie*je) + 1
      if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
        abs1 = p(i+1, j, k) - p(i, j, k)
        call pushcontrol1b(1)
      else
        abs1 = -(p(i+1, j, k)-p(i, j, k))
        call pushcontrol1b(0)
      end if
      if (p(i, j, k) - p(i-1, j, k) .ge. 0.) then
        abs4 = p(i, j, k) - p(i-1, j, k)
        call pushcontrol1b(0)
      else
        abs4 = -(p(i, j, k)-p(i-1, j, k))
        call pushcontrol1b(1)
      end if
      x1 = (p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))/(omega*(p(i+1, j, &
&       k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+abs4)+plim)
      if (x1 .ge. 0.) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
        abs2 = p(i, j+1, k) - p(i, j, k)
        call pushcontrol1b(1)
      else
        abs2 = -(p(i, j+1, k)-p(i, j, k))
        call pushcontrol1b(0)
      end if
      if (p(i, j, k) - p(i, j-1, k) .ge. 0.) then
        abs5 = p(i, j, k) - p(i, j-1, k)
        call pushcontrol1b(0)
      else
        abs5 = -(p(i, j, k)-p(i, j-1, k))
        call pushcontrol1b(1)
      end if
      x2 = (p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))/(omega*(p(i, j+1, &
&       k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+abs5)+plim)
      if (x2 .ge. 0.) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
        abs3 = p(i, j, k+1) - p(i, j, k)
        call pushcontrol1b(1)
      else
        abs3 = -(p(i, j, k+1)-p(i, j, k))
        call pushcontrol1b(0)
      end if
      if (p(i, j, k) - p(i, j, k-1) .ge. 0.) then
        abs6 = p(i, j, k) - p(i, j, k-1)
        call pushcontrol1b(0)
      else
        abs6 = -(p(i, j, k)-p(i, j, k-1))
        call pushcontrol1b(1)
      end if
      x3 = (p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))/(omega*(p(i, j, k+&
&       1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+abs6)+plim)
      if (x3 .ge. 0.) then
        x3d = dssd(i, j, k, 3)
        dssd(i, j, k, 3) = 0.0_8
      else
        x3d = -dssd(i, j, k, 3)
        dssd(i, j, k, 3) = 0.0_8
      end if
      temp1 = omega*(p(i, j, k+1)+two*p(i, j, k)+p(i, j, k-1)) + &
&       oneminomega*(abs3+abs6) + plim
      tempd5 = x3d/temp1
      tempd6 = -((p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))*tempd5/temp1&
&       )
      tempd7 = omega*tempd6
      pd(i, j, k+1) = pd(i, j, k+1) + tempd7 + tempd5
      pd(i, j, k) = pd(i, j, k) + two*tempd7 - two*tempd5
      pd(i, j, k-1) = pd(i, j, k-1) + tempd7 + tempd5
      abs3d = oneminomega*tempd6
      abs6d = oneminomega*tempd6
      plimd = plimd + tempd6
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pd(i, j, k) = pd(i, j, k) + abs6d
        pd(i, j, k-1) = pd(i, j, k-1) - abs6d
      else
        pd(i, j, k-1) = pd(i, j, k-1) + abs6d
        pd(i, j, k) = pd(i, j, k) - abs6d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pd(i, j, k) = pd(i, j, k) + abs3d
        pd(i, j, k+1) = pd(i, j, k+1) - abs3d
      else
        pd(i, j, k+1) = pd(i, j, k+1) + abs3d
        pd(i, j, k) = pd(i, j, k) - abs3d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        x2d = dssd(i, j, k, 2)
        dssd(i, j, k, 2) = 0.0_8
      else
        x2d = -dssd(i, j, k, 2)
        dssd(i, j, k, 2) = 0.0_8
      end if
      temp0 = omega*(p(i, j+1, k)+two*p(i, j, k)+p(i, j-1, k)) + &
&       oneminomega*(abs2+abs5) + plim
      tempd2 = x2d/temp0
      tempd3 = -((p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))*tempd2/temp0&
&       )
      tempd4 = omega*tempd3
      pd(i, j+1, k) = pd(i, j+1, k) + tempd4 + tempd2
      pd(i, j, k) = pd(i, j, k) + two*tempd4 - two*tempd2
      pd(i, j-1, k) = pd(i, j-1, k) + tempd4 + tempd2
      abs2d = oneminomega*tempd3
      abs5d = oneminomega*tempd3
      plimd = plimd + tempd3
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pd(i, j, k) = pd(i, j, k) + abs5d
        pd(i, j-1, k) = pd(i, j-1, k) - abs5d
      else
        pd(i, j-1, k) = pd(i, j-1, k) + abs5d
        pd(i, j, k) = pd(i, j, k) - abs5d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pd(i, j, k) = pd(i, j, k) + abs2d
        pd(i, j+1, k) = pd(i, j+1, k) - abs2d
      else
        pd(i, j+1, k) = pd(i, j+1, k) + abs2d
        pd(i, j, k) = pd(i, j, k) - abs2d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        x1d = dssd(i, j, k, 1)
        dssd(i, j, k, 1) = 0.0_8
      else
        x1d = -dssd(i, j, k, 1)
        dssd(i, j, k, 1) = 0.0_8
      end if
      temp = omega*(p(i+1, j, k)+two*p(i, j, k)+p(i-1, j, k)) + &
&       oneminomega*(abs1+abs4) + plim
      tempd = x1d/temp
      tempd0 = -((p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))*tempd/temp)
      tempd1 = omega*tempd0
      pd(i+1, j, k) = pd(i+1, j, k) + tempd1 + tempd
      pd(i, j, k) = pd(i, j, k) + two*tempd1 - two*tempd
      pd(i-1, j, k) = pd(i-1, j, k) + tempd1 + tempd
      abs1d = oneminomega*tempd0
      abs4d = oneminomega*tempd0
      plimd = plimd + tempd0
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pd(i, j, k) = pd(i, j, k) + abs4d
        pd(i-1, j, k) = pd(i-1, j, k) - abs4d
      else
        pd(i-1, j, k) = pd(i-1, j, k) + abs4d
        pd(i, j, k) = pd(i, j, k) - abs4d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        pd(i, j, k) = pd(i, j, k) + abs1d
        pd(i+1, j, k) = pd(i+1, j, k) - abs1d
      else
        pd(i+1, j, k) = pd(i+1, j, k) + abs1d
        pd(i, j, k) = pd(i, j, k) - abs1d
      end if
    end do
    pinfcorrd = 0.001_realtype*plimd
  end if
end subroutine invisciddissfluxmatrix_b

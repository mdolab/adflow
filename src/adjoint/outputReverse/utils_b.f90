!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module utils_b
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
  function tsbeta(degreepolbeta, coefpolbeta, degreefourbeta, &
&   omegafourbeta, coscoeffourbeta, sincoeffourbeta, t)
!
!      ******************************************************************
!      *                                                                *
!      * tsbeta computes the angle of attack for a given time interval *
!      * in a time spectral solution.                                   *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsbeta
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolbeta
    integer(kind=inttype), intent(in) :: degreefourbeta
    real(kind=realtype), intent(in) :: omegafourbeta, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolbeta
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourbeta
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourbeta
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: beta, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsbeta = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      beta = coefpolbeta(0)
      do nn=1,degreepolbeta
        beta = beta + coefpolbeta(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      beta = beta + coscoeffourbeta(0)
      do nn=1,degreefourbeta
        val = nn*omegafourbeta*t
        beta = beta + coscoeffourbeta(nn)*cos(val) + sincoeffourbeta(nn)&
&         *sin(val)
      end do
! set tsbeta to phi.
      tsbeta = beta
    end if
  end function tsbeta
  function tsbetadot(degreepolbeta, coefpolbeta, degreefourbeta, &
&   omegafourbeta, coscoeffourbeta, sincoeffourbeta, t)
!
!      ******************************************************************
!      *                                                                *
!      * tsbeta computes the angle of attack for a given time interval  *
!      * in a time spectral solution.                                   *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsbetadot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolbeta
    integer(kind=inttype), intent(in) :: degreefourbeta
    real(kind=realtype), intent(in) :: omegafourbeta, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolbeta
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourbeta
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourbeta
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: betadot, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsbetadot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      betadot = zero
      do nn=1,degreepolbeta
        betadot = betadot + nn*coefpolbeta(nn)*t**(nn-1)
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefourbeta
        val = nn*omegafourbeta
        betadot = betadot - val*coscoeffourbeta(nn)*sin(val*t) + val*&
&         sincoeffourbeta(nn)*cos(val*t)
      end do
! set tsbeta to phi.
      tsbetadot = betadot
    end if
  end function tsbetadot
  function tsmach(degreepolmach, coefpolmach, degreefourmach, &
&   omegafourmach, coscoeffourmach, sincoeffourmach, t)
!
!      ******************************************************************
!      *                                                                *
!      * tsmach computes the mach number for a given time interval      *
!      * in a time spectral solution.                                   *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsmach
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolmach
    integer(kind=inttype), intent(in) :: degreefourmach
    real(kind=realtype), intent(in) :: omegafourmach, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolmach
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourmach
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourmach
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: intervalmach, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsmach = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      intervalmach = coefpolmach(0)
      do nn=1,degreepolmach
        intervalmach = intervalmach + coefpolmach(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      intervalmach = intervalmach + coscoeffourmach(0)
      do nn=1,degreefourmach
        val = nn*omegafourmach*t
        intervalmach = intervalmach + coscoeffourmach(nn)*cos(val) + &
&         sincoeffourmach(nn)*sin(val)
      end do
      print*, 'intsmach', intervalmach, nn, val, t
! set tsmach to phi.
      tsmach = intervalmach
    end if
  end function tsmach
  function tsmachdot(degreepolmach, coefpolmach, degreefourmach, &
&   omegafourmach, coscoeffourmach, sincoeffourmach, t)
!
!      ******************************************************************
!      *                                                                *
!      * tsmach computes the angle of attack for a given time interval *
!      * in a time spectral solution.                                   *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsmachdot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolmach
    integer(kind=inttype), intent(in) :: degreefourmach
    real(kind=realtype), intent(in) :: omegafourmach, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolmach
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourmach
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourmach
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: machdot, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsmachdot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      machdot = zero
      do nn=1,degreepolmach
        machdot = machdot + nn*coefpolmach(nn)*t**(nn-1)
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefourmach
        val = nn*omegafourmach
        machdot = machdot - val*coscoeffourmach(nn)*sin(val*t) + val*&
&         sincoeffourmach(nn)*cos(val*t)
      end do
! set tsmach to phi.
      tsmachdot = machdot
    end if
  end function tsmachdot
  function derivativerigidrotangle(degreepolrot, coefpolrot, &
&   degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!      ******************************************************************
!      *                                                                *
!      * derivativerigidrotangle computes the time derivative of the    *
!      * rigid body rotation angle at the given time for the given      *
!      * arguments. the angle is described by a combination of a        *
!      * polynomial and fourier series.                                 *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    use flowvarrefstate, only : timeref
    implicit none
!
!      function type
!
    real(kind=realtype) :: derivativerigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: dphi, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      derivativerigidrotangle = zero
      return
    else
! compute the polynomial contribution.
      dphi = zero
      do nn=1,degreepolrot
        dphi = dphi + nn*coefpolrot(nn)*t**(nn-1)
      end do
! compute the fourier contribution.
      do nn=1,degreefourrot
        val = nn*omegafourrot
        dphi = dphi - val*coscoeffourrot(nn)*sin(val*t)
        dphi = dphi + val*sincoeffourrot(nn)*cos(val*t)
      end do
! set derivativerigidrotangle to dphi. multiply by timeref
! to obtain the correct non-dimensional value.
      derivativerigidrotangle = timeref*dphi
    end if
  end function derivativerigidrotangle
!  differentiation of mydim in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: x y mydim
!   with respect to varying inputs: x y
  subroutine mydim_b(x, xd, y, yd, mydimd)
    use constants
    implicit none
    real(kind=realtype) :: x, y
    real(kind=realtype) :: xd, yd
    real(kind=realtype) :: mydim
    real(kind=realtype) :: mydimd
    mydim = x - y
    if (mydim .lt. 0.0) mydimd = 0.0_8
    xd = xd + mydimd
    yd = yd - mydimd
  end subroutine mydim_b
  function mydim(x, y)
    use constants
    implicit none
    real(kind=realtype) :: x, y
    real(kind=realtype) :: mydim
    mydim = x - y
    if (mydim .lt. 0.0) mydim = 0.0
  end function mydim
  function getcorrectfork()
    use constants
    use flowvarrefstate, only : kpresent
    use iteration, only : currentlevel, groundlevel
    implicit none
    logical :: getcorrectfork
    if (kpresent .and. currentlevel .le. groundlevel) then
      getcorrectfork = .true.
    else
      getcorrectfork = .false.
    end if
  end function getcorrectfork
  subroutine rotmatrixrigidbody(tnew, told, rotationmatrix, &
&   rotationpoint)
!
!      ******************************************************************
!      *                                                                *
!      * rotmatrixrigidbody determines the rotation matrix and the      *
!      * rotation point to determine the coordinates of the new time    *
!      * level starting from the coordinates of the old time level.     *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputmotion
    use flowvarrefstate, only : lref
    implicit none
!
!      subroutine arguments.
!
    real(kind=realtype), intent(in) :: tnew, told
    real(kind=realtype), dimension(3), intent(out) :: rotationpoint
    real(kind=realtype), dimension(3, 3), intent(out) :: rotationmatrix
!
!      local variables.
!
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: phi
    real(kind=realtype) :: cosx, cosy, cosz, sinx, siny, sinz
    real(kind=realtype), dimension(3, 3) :: mnew, mold
    intrinsic sin
    intrinsic cos
! determine the rotation angle around the x-axis for the new
! time level and the corresponding values of the sine and cosine.
    phi = rigidrotangle(degreepolxrot, coefpolxrot, degreefourxrot, &
&     omegafourxrot, coscoeffourxrot, sincoeffourxrot, tnew)
    sinx = sin(phi)
    cosx = cos(phi)
! idem for the y-axis.
    phi = rigidrotangle(degreepolyrot, coefpolyrot, degreefouryrot, &
&     omegafouryrot, coscoeffouryrot, sincoeffouryrot, tnew)
    siny = sin(phi)
    cosy = cos(phi)
! idem for the z-axis.
    phi = rigidrotangle(degreepolzrot, coefpolzrot, degreefourzrot, &
&     omegafourzrot, coscoeffourzrot, sincoeffourzrot, tnew)
    sinz = sin(phi)
    cosz = cos(phi)
! construct the transformation matrix at the new time level.
! it is assumed that the sequence of rotation is first around the
! x-axis then around the y-axis and finally around the z-axis.
    mnew(1, 1) = cosy*cosz
    mnew(2, 1) = cosy*sinz
    mnew(3, 1) = -siny
    mnew(1, 2) = sinx*siny*cosz - cosx*sinz
    mnew(2, 2) = sinx*siny*sinz + cosx*cosz
    mnew(3, 2) = sinx*cosy
    mnew(1, 3) = cosx*siny*cosz + sinx*sinz
    mnew(2, 3) = cosx*siny*sinz - sinx*cosz
    mnew(3, 3) = cosx*cosy
! determine the rotation angle around the x-axis for the old
! time level and the corresponding values of the sine and cosine.
    phi = rigidrotangle(degreepolxrot, coefpolxrot, degreefourxrot, &
&     omegafourxrot, coscoeffourxrot, sincoeffourxrot, told)
    sinx = sin(phi)
    cosx = cos(phi)
! idem for the y-axis.
    phi = rigidrotangle(degreepolyrot, coefpolyrot, degreefouryrot, &
&     omegafouryrot, coscoeffouryrot, sincoeffouryrot, told)
    siny = sin(phi)
    cosy = cos(phi)
! idem for the z-axis.
    phi = rigidrotangle(degreepolzrot, coefpolzrot, degreefourzrot, &
&     omegafourzrot, coscoeffourzrot, sincoeffourzrot, told)
    sinz = sin(phi)
    cosz = cos(phi)
! construct the transformation matrix at the old time level.
    mold(1, 1) = cosy*cosz
    mold(2, 1) = cosy*sinz
    mold(3, 1) = -siny
    mold(1, 2) = sinx*siny*cosz - cosx*sinz
    mold(2, 2) = sinx*siny*sinz + cosx*cosz
    mold(3, 2) = sinx*cosy
    mold(1, 3) = cosx*siny*cosz + sinx*sinz
    mold(2, 3) = cosx*siny*sinz - sinx*cosz
    mold(3, 3) = cosx*cosy
! construct the transformation matrix between the new and the
! old time level. this is mnew*inverse(mold). however the
! inverse of mold is the transpose.
    do j=1,3
      do i=1,3
        rotationmatrix(i, j) = mnew(i, 1)*mold(j, 1) + mnew(i, 2)*mold(j&
&         , 2) + mnew(i, 3)*mold(j, 3)
      end do
    end do
! determine the rotation point at the old time level; it is
! possible that this value changes due to translation of the grid.
!  ainf = sqrt(gammainf*pinf/rhoinf)
!  rotationpoint(1) = lref*rotpoint(1) &
!                   + machgrid(1)*ainf*told/timeref
!  rotationpoint(2) = lref*rotpoint(2) &
!                   + machgrid(2)*ainf*told/timeref
!  rotationpoint(3) = lref*rotpoint(3) &
!                   + machgrid(3)*ainf*told/timeref
    rotationpoint(1) = lref*rotpoint(1)
    rotationpoint(2) = lref*rotpoint(2)
    rotationpoint(3) = lref*rotpoint(3)
  end subroutine rotmatrixrigidbody
  function secondderivativerigidrotangle(degreepolrot, coefpolrot, &
&   degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!      ******************************************************************
!      *                                                                *
!      * 2ndderivativerigidrotangle computes the 2nd time derivative of *
!      * the rigid body rotation angle at the given time for the given  *
!      * arguments. the angle is described by a combination of a        *
!      * polynomial and fourier series.                                 *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use flowvarrefstate, only : timeref
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: secondderivativerigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: dphi, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      secondderivativerigidrotangle = zero
      return
    else
! compute the polynomial contribution.
      dphi = zero
      do nn=2,degreepolrot
        dphi = dphi + (nn-1)*nn*coefpolrot(nn)*t**(nn-2)
      end do
! compute the fourier contribution.
      do nn=1,degreefourrot
        val = nn*omegafourrot
        dphi = dphi - val**2*sincoeffourrot(nn)*sin(val*t)
        dphi = dphi - val**2*coscoeffourrot(nn)*cos(val*t)
      end do
! set derivativerigidrotangle to dphi. multiply by timeref
! to obtain the correct non-dimensional value.
      secondderivativerigidrotangle = timeref**2*dphi
    end if
  end function secondderivativerigidrotangle
  function rigidrotangle(degreepolrot, coefpolrot, degreefourrot, &
&   omegafourrot, coscoeffourrot, sincoeffourrot, t)
!
!      ******************************************************************
!      *                                                                *
!      * rigidrotangle computes the rigid body rotation angle at the    *
!      * given time for the given arguments. the angle is described by  *
!      * a combination of a polynomial and fourier series.              *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: rigidrotangle
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolrot
    integer(kind=inttype), intent(in) :: degreefourrot
    real(kind=realtype), intent(in) :: omegafourrot, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolrot
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffourrot
    real(kind=realtype), dimension(*), intent(in) :: sincoeffourrot
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: phi, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      rigidrotangle = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      phi = coefpolrot(0)
      do nn=1,degreepolrot
        phi = phi + coefpolrot(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      phi = phi + coscoeffourrot(0)
      do nn=1,degreefourrot
        val = nn*omegafourrot*t
        phi = phi + coscoeffourrot(nn)*cos(val) + sincoeffourrot(nn)*sin&
&         (val)
      end do
! set rigidrotangle to phi.
      rigidrotangle = phi
    end if
  end function rigidrotangle
!  differentiation of setbcpointers in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *xx *rev0 *rev1 *rev2 *rev3
!                *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi
!                *ww0 *ww1 *ww2 *ww3 *rev *p *w *rlv *x *si *sj
!                *sk
!   with respect to varying inputs: *xx *rev0 *rev1 *rev2 *rev3
!                *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi
!                *ww0 *ww1 *ww2 *ww3 *rev *p *w *rlv *x *si *sj
!                *sk
!   plus diff mem management of: xx:in rev0:in rev1:in rev2:in
!                rev3:in pp0:in pp1:in pp2:in pp3:in rlv0:in rlv1:in
!                rlv2:in rlv3:in ssi:in ww0:in ww1:in ww2:in ww3:in
!                rev:in p:in w:in rlv:in x:in si:in sj:in sk:in
!                bcdata:in
  subroutine setbcpointers_b(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * setbcpointers sets the pointers needed for the boundary        *
!      * condition treatment on a general face, such that the boundary  *
!      * routines are only implemented once instead of 6 times.         *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use blockpointers, only : w, wd, p, pd, rlv, rlvd, rev, revd, &
&   gamma, x, xd, d2wall, d2walld, si, sid, sj, sjd, sk, skd, s, &
&   globalcell, bcdata, bcdatad, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid
    use bcpointers_b, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, ww3, ww3d,&
&   pp0, pp0d, pp1, pp1d, pp2, pp2d, pp3, pp3d, rlv0, rlv0d, rlv1, rlv1d&
&   , rlv2, rlv2d, rlv3, rlv3d, rev0, rev0d, rev1, rev1d, rev2, rev2d, &
&   rev3, rev3d, gamma0, gamma1, gamma2, gamma3, gcp, xx, xxd, ss, ssi, &
&   ssid, ssj, ssk, dd2wall, istart, iend, jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    integer :: branch
! determine the sizes of each face and point to just the range we
! need on each face. 
! set the size of the subface
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
      call pushcontrol3b(1)
    case (imax) 
      call pushcontrol3b(2)
    case (jmin) 
      call pushcontrol3b(3)
    case (jmax) 
      call pushcontrol3b(4)
    case (kmin) 
      call pushcontrol3b(5)
    case (kmax) 
      call pushcontrol3b(6)
    case default
      call pushcontrol3b(0)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        sid(1, 1:je, 1:ke, :) = sid(1, 1:je, 1:ke, :) + ssid(1:je, 1:ke&
&         , :)
        ssid(1:je, 1:ke, :) = 0.0_8
        xd(1, 0:je, 0:ke, :) = xd(1, 0:je, 0:ke, :) + xxd(1:je+1, 1:ke+1&
&         , :)
        xxd(1:je+1, 1:ke+1, :) = 0.0_8
      case (imax) 
        sid(il, 1:je, 1:ke, :) = sid(il, 1:je, 1:ke, :) + ssid(1:je, 1:&
&         ke, :)
        ssid(1:je, 1:ke, :) = 0.0_8
        xd(il, 0:je, 0:ke, :) = xd(il, 0:je, 0:ke, :) + xxd(1:je+1, 1:ke&
&         +1, :)
        xxd(1:je+1, 1:ke+1, :) = 0.0_8
      case (jmin) 
        sjd(1:ie, 1, 1:ke, :) = sjd(1:ie, 1, 1:ke, :) + ssid(1:ie, 1:ke&
&         , :)
        ssid(1:ie, 1:ke, :) = 0.0_8
        xd(0:ie, 1, 0:ke, :) = xd(0:ie, 1, 0:ke, :) + xxd(1:ie+1, 1:ke+1&
&         , :)
        xxd(1:ie+1, 1:ke+1, :) = 0.0_8
      case (jmax) 
        sjd(1:ie, jl, 1:ke, :) = sjd(1:ie, jl, 1:ke, :) + ssid(1:ie, 1:&
&         ke, :)
        ssid(1:ie, 1:ke, :) = 0.0_8
        xd(0:ie, jl, 0:ke, :) = xd(0:ie, jl, 0:ke, :) + xxd(1:ie+1, 1:ke&
&         +1, :)
        xxd(1:ie+1, 1:ke+1, :) = 0.0_8
      case (kmin) 
        skd(1:ie, 1:je, 1, :) = skd(1:ie, 1:je, 1, :) + ssid(1:ie, 1:je&
&         , :)
        ssid(1:ie, 1:je, :) = 0.0_8
        xd(0:ie, 0:je, 1, :) = xd(0:ie, 0:je, 1, :) + xxd(1:ie+1, 1:je+1&
&         , :)
        xxd(1:ie+1, 1:je+1, :) = 0.0_8
      case (kmax) 
        skd(1:ie, 1:je, kl, :) = skd(1:ie, 1:je, kl, :) + ssid(1:ie, 1:&
&         je, :)
        ssid(1:ie, 1:je, :) = 0.0_8
        xd(0:ie, 0:je, kl, :) = xd(0:ie, 0:je, kl, :) + xxd(1:ie+1, 1:je&
&         +1, :)
        xxd(1:ie+1, 1:je+1, :) = 0.0_8
      end select
    end if
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .ne. 0) then
        if (branch .eq. 1) then
          revd(0, 1:je, 1:ke) = revd(0, 1:je, 1:ke) + rev0d(1:je, 1:ke)
          rev0d(1:je, 1:ke) = 0.0_8
          revd(1, 1:je, 1:ke) = revd(1, 1:je, 1:ke) + rev1d(1:je, 1:ke)
          rev1d(1:je, 1:ke) = 0.0_8
          revd(2, 1:je, 1:ke) = revd(2, 1:je, 1:ke) + rev2d(1:je, 1:ke)
          rev2d(1:je, 1:ke) = 0.0_8
          revd(3, 1:je, 1:ke) = revd(3, 1:je, 1:ke) + rev3d(1:je, 1:ke)
          rev3d(1:je, 1:ke) = 0.0_8
          rlvd(0, 1:je, 1:ke) = rlvd(0, 1:je, 1:ke) + rlv0d(1:je, 1:ke)
          rlv0d(1:je, 1:ke) = 0.0_8
          rlvd(1, 1:je, 1:ke) = rlvd(1, 1:je, 1:ke) + rlv1d(1:je, 1:ke)
          rlv1d(1:je, 1:ke) = 0.0_8
          rlvd(2, 1:je, 1:ke) = rlvd(2, 1:je, 1:ke) + rlv2d(1:je, 1:ke)
          rlv2d(1:je, 1:ke) = 0.0_8
          rlvd(3, 1:je, 1:ke) = rlvd(3, 1:je, 1:ke) + rlv3d(1:je, 1:ke)
          rlv3d(1:je, 1:ke) = 0.0_8
          pd(0, 1:je, 1:ke) = pd(0, 1:je, 1:ke) + pp0d(1:je, 1:ke)
          pp0d(1:je, 1:ke) = 0.0_8
          pd(1, 1:je, 1:ke) = pd(1, 1:je, 1:ke) + pp1d(1:je, 1:ke)
          pp1d(1:je, 1:ke) = 0.0_8
          pd(2, 1:je, 1:ke) = pd(2, 1:je, 1:ke) + pp2d(1:je, 1:ke)
          pp2d(1:je, 1:ke) = 0.0_8
          pd(3, 1:je, 1:ke) = pd(3, 1:je, 1:ke) + pp3d(1:je, 1:ke)
          pp3d(1:je, 1:ke) = 0.0_8
          wd(0, 1:je, 1:ke, :) = wd(0, 1:je, 1:ke, :) + ww0d(1:je, 1:ke&
&           , :)
          ww0d(1:je, 1:ke, :) = 0.0_8
          wd(1, 1:je, 1:ke, :) = wd(1, 1:je, 1:ke, :) + ww1d(1:je, 1:ke&
&           , :)
          ww1d(1:je, 1:ke, :) = 0.0_8
          wd(2, 1:je, 1:ke, :) = wd(2, 1:je, 1:ke, :) + ww2d(1:je, 1:ke&
&           , :)
          ww2d(1:je, 1:ke, :) = 0.0_8
          wd(3, 1:je, 1:ke, :) = wd(3, 1:je, 1:ke, :) + ww3d(1:je, 1:ke&
&           , :)
          ww3d(1:je, 1:ke, :) = 0.0_8
        else
          revd(ib, 1:je, 1:ke) = revd(ib, 1:je, 1:ke) + rev0d(1:je, 1:ke&
&           )
          rev0d(1:je, 1:ke) = 0.0_8
          revd(ie, 1:je, 1:ke) = revd(ie, 1:je, 1:ke) + rev1d(1:je, 1:ke&
&           )
          rev1d(1:je, 1:ke) = 0.0_8
          revd(il, 1:je, 1:ke) = revd(il, 1:je, 1:ke) + rev2d(1:je, 1:ke&
&           )
          rev2d(1:je, 1:ke) = 0.0_8
          revd(nx, 1:je, 1:ke) = revd(nx, 1:je, 1:ke) + rev3d(1:je, 1:ke&
&           )
          rev3d(1:je, 1:ke) = 0.0_8
          rlvd(ib, 1:je, 1:ke) = rlvd(ib, 1:je, 1:ke) + rlv0d(1:je, 1:ke&
&           )
          rlv0d(1:je, 1:ke) = 0.0_8
          rlvd(ie, 1:je, 1:ke) = rlvd(ie, 1:je, 1:ke) + rlv1d(1:je, 1:ke&
&           )
          rlv1d(1:je, 1:ke) = 0.0_8
          rlvd(il, 1:je, 1:ke) = rlvd(il, 1:je, 1:ke) + rlv2d(1:je, 1:ke&
&           )
          rlv2d(1:je, 1:ke) = 0.0_8
          rlvd(nx, 1:je, 1:ke) = rlvd(nx, 1:je, 1:ke) + rlv3d(1:je, 1:ke&
&           )
          rlv3d(1:je, 1:ke) = 0.0_8
          pd(ib, 1:je, 1:ke) = pd(ib, 1:je, 1:ke) + pp0d(1:je, 1:ke)
          pp0d(1:je, 1:ke) = 0.0_8
          pd(ie, 1:je, 1:ke) = pd(ie, 1:je, 1:ke) + pp1d(1:je, 1:ke)
          pp1d(1:je, 1:ke) = 0.0_8
          pd(il, 1:je, 1:ke) = pd(il, 1:je, 1:ke) + pp2d(1:je, 1:ke)
          pp2d(1:je, 1:ke) = 0.0_8
          pd(nx, 1:je, 1:ke) = pd(nx, 1:je, 1:ke) + pp3d(1:je, 1:ke)
          pp3d(1:je, 1:ke) = 0.0_8
          wd(ib, 1:je, 1:ke, :) = wd(ib, 1:je, 1:ke, :) + ww0d(1:je, 1:&
&           ke, :)
          ww0d(1:je, 1:ke, :) = 0.0_8
          wd(ie, 1:je, 1:ke, :) = wd(ie, 1:je, 1:ke, :) + ww1d(1:je, 1:&
&           ke, :)
          ww1d(1:je, 1:ke, :) = 0.0_8
          wd(il, 1:je, 1:ke, :) = wd(il, 1:je, 1:ke, :) + ww2d(1:je, 1:&
&           ke, :)
          ww2d(1:je, 1:ke, :) = 0.0_8
          wd(nx, 1:je, 1:ke, :) = wd(nx, 1:je, 1:ke, :) + ww3d(1:je, 1:&
&           ke, :)
          ww3d(1:je, 1:ke, :) = 0.0_8
        end if
      end if
    else if (branch .lt. 5) then
      if (branch .eq. 3) then
        revd(1:ie, 0, 1:ke) = revd(1:ie, 0, 1:ke) + rev0d(1:ie, 1:ke)
        rev0d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, 1, 1:ke) = revd(1:ie, 1, 1:ke) + rev1d(1:ie, 1:ke)
        rev1d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, 2, 1:ke) = revd(1:ie, 2, 1:ke) + rev2d(1:ie, 1:ke)
        rev2d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, 3, 1:ke) = revd(1:ie, 3, 1:ke) + rev3d(1:ie, 1:ke)
        rev3d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 0, 1:ke) = rlvd(1:ie, 0, 1:ke) + rlv0d(1:ie, 1:ke)
        rlv0d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 1, 1:ke) = rlvd(1:ie, 1, 1:ke) + rlv1d(1:ie, 1:ke)
        rlv1d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 2, 1:ke) = rlvd(1:ie, 2, 1:ke) + rlv2d(1:ie, 1:ke)
        rlv2d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, 3, 1:ke) = rlvd(1:ie, 3, 1:ke) + rlv3d(1:ie, 1:ke)
        rlv3d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 0, 1:ke) = pd(1:ie, 0, 1:ke) + pp0d(1:ie, 1:ke)
        pp0d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 1, 1:ke) = pd(1:ie, 1, 1:ke) + pp1d(1:ie, 1:ke)
        pp1d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 2, 1:ke) = pd(1:ie, 2, 1:ke) + pp2d(1:ie, 1:ke)
        pp2d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, 3, 1:ke) = pd(1:ie, 3, 1:ke) + pp3d(1:ie, 1:ke)
        pp3d(1:ie, 1:ke) = 0.0_8
        wd(1:ie, 0, 1:ke, :) = wd(1:ie, 0, 1:ke, :) + ww0d(1:ie, 1:ke, :&
&         )
        ww0d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, 1, 1:ke, :) = wd(1:ie, 1, 1:ke, :) + ww1d(1:ie, 1:ke, :&
&         )
        ww1d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, 2, 1:ke, :) = wd(1:ie, 2, 1:ke, :) + ww2d(1:ie, 1:ke, :&
&         )
        ww2d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, 3, 1:ke, :) = wd(1:ie, 3, 1:ke, :) + ww3d(1:ie, 1:ke, :&
&         )
        ww3d(1:ie, 1:ke, :) = 0.0_8
      else
        revd(1:ie, jb, 1:ke) = revd(1:ie, jb, 1:ke) + rev0d(1:ie, 1:ke)
        rev0d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, je, 1:ke) = revd(1:ie, je, 1:ke) + rev1d(1:ie, 1:ke)
        rev1d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, jl, 1:ke) = revd(1:ie, jl, 1:ke) + rev2d(1:ie, 1:ke)
        rev2d(1:ie, 1:ke) = 0.0_8
        revd(1:ie, ny, 1:ke) = revd(1:ie, ny, 1:ke) + rev3d(1:ie, 1:ke)
        rev3d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, jb, 1:ke) = rlvd(1:ie, jb, 1:ke) + rlv0d(1:ie, 1:ke)
        rlv0d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, je, 1:ke) = rlvd(1:ie, je, 1:ke) + rlv1d(1:ie, 1:ke)
        rlv1d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, jl, 1:ke) = rlvd(1:ie, jl, 1:ke) + rlv2d(1:ie, 1:ke)
        rlv2d(1:ie, 1:ke) = 0.0_8
        rlvd(1:ie, ny, 1:ke) = rlvd(1:ie, ny, 1:ke) + rlv3d(1:ie, 1:ke)
        rlv3d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, jb, 1:ke) = pd(1:ie, jb, 1:ke) + pp0d(1:ie, 1:ke)
        pp0d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, je, 1:ke) = pd(1:ie, je, 1:ke) + pp1d(1:ie, 1:ke)
        pp1d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, jl, 1:ke) = pd(1:ie, jl, 1:ke) + pp2d(1:ie, 1:ke)
        pp2d(1:ie, 1:ke) = 0.0_8
        pd(1:ie, ny, 1:ke) = pd(1:ie, ny, 1:ke) + pp3d(1:ie, 1:ke)
        pp3d(1:ie, 1:ke) = 0.0_8
        wd(1:ie, jb, 1:ke, :) = wd(1:ie, jb, 1:ke, :) + ww0d(1:ie, 1:ke&
&         , :)
        ww0d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, je, 1:ke, :) = wd(1:ie, je, 1:ke, :) + ww1d(1:ie, 1:ke&
&         , :)
        ww1d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, jl, 1:ke, :) = wd(1:ie, jl, 1:ke, :) + ww2d(1:ie, 1:ke&
&         , :)
        ww2d(1:ie, 1:ke, :) = 0.0_8
        wd(1:ie, ny, 1:ke, :) = wd(1:ie, ny, 1:ke, :) + ww3d(1:ie, 1:ke&
&         , :)
        ww3d(1:ie, 1:ke, :) = 0.0_8
      end if
    else if (branch .eq. 5) then
      revd(1:ie, 1:je, 0) = revd(1:ie, 1:je, 0) + rev0d(1:ie, 1:je)
      rev0d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, 1) = revd(1:ie, 1:je, 1) + rev1d(1:ie, 1:je)
      rev1d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, 2) = revd(1:ie, 1:je, 2) + rev2d(1:ie, 1:je)
      rev2d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, 3) = revd(1:ie, 1:je, 3) + rev3d(1:ie, 1:je)
      rev3d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 0) = rlvd(1:ie, 1:je, 0) + rlv0d(1:ie, 1:je)
      rlv0d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 1) = rlvd(1:ie, 1:je, 1) + rlv1d(1:ie, 1:je)
      rlv1d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 2) = rlvd(1:ie, 1:je, 2) + rlv2d(1:ie, 1:je)
      rlv2d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, 3) = rlvd(1:ie, 1:je, 3) + rlv3d(1:ie, 1:je)
      rlv3d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 0) = pd(1:ie, 1:je, 0) + pp0d(1:ie, 1:je)
      pp0d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 1) = pd(1:ie, 1:je, 1) + pp1d(1:ie, 1:je)
      pp1d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 2) = pd(1:ie, 1:je, 2) + pp2d(1:ie, 1:je)
      pp2d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, 3) = pd(1:ie, 1:je, 3) + pp3d(1:ie, 1:je)
      pp3d(1:ie, 1:je) = 0.0_8
      wd(1:ie, 1:je, 0, :) = wd(1:ie, 1:je, 0, :) + ww0d(1:ie, 1:je, :)
      ww0d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, 1, :) = wd(1:ie, 1:je, 1, :) + ww1d(1:ie, 1:je, :)
      ww1d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, 2, :) = wd(1:ie, 1:je, 2, :) + ww2d(1:ie, 1:je, :)
      ww2d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, 3, :) = wd(1:ie, 1:je, 3, :) + ww3d(1:ie, 1:je, :)
      ww3d(1:ie, 1:je, :) = 0.0_8
    else
      revd(1:ie, 1:je, kb) = revd(1:ie, 1:je, kb) + rev0d(1:ie, 1:je)
      rev0d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, ke) = revd(1:ie, 1:je, ke) + rev1d(1:ie, 1:je)
      rev1d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, kl) = revd(1:ie, 1:je, kl) + rev2d(1:ie, 1:je)
      rev2d(1:ie, 1:je) = 0.0_8
      revd(1:ie, 1:je, nz) = revd(1:ie, 1:je, nz) + rev3d(1:ie, 1:je)
      rev3d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, kb) = rlvd(1:ie, 1:je, kb) + rlv0d(1:ie, 1:je)
      rlv0d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, ke) = rlvd(1:ie, 1:je, ke) + rlv1d(1:ie, 1:je)
      rlv1d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, kl) = rlvd(1:ie, 1:je, kl) + rlv2d(1:ie, 1:je)
      rlv2d(1:ie, 1:je) = 0.0_8
      rlvd(1:ie, 1:je, nz) = rlvd(1:ie, 1:je, nz) + rlv3d(1:ie, 1:je)
      rlv3d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, kb) = pd(1:ie, 1:je, kb) + pp0d(1:ie, 1:je)
      pp0d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, ke) = pd(1:ie, 1:je, ke) + pp1d(1:ie, 1:je)
      pp1d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, kl) = pd(1:ie, 1:je, kl) + pp2d(1:ie, 1:je)
      pp2d(1:ie, 1:je) = 0.0_8
      pd(1:ie, 1:je, nz) = pd(1:ie, 1:je, nz) + pp3d(1:ie, 1:je)
      pp3d(1:ie, 1:je) = 0.0_8
      wd(1:ie, 1:je, kb, :) = wd(1:ie, 1:je, kb, :) + ww0d(1:ie, 1:je, :&
&       )
      ww0d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, ke, :) = wd(1:ie, 1:je, ke, :) + ww1d(1:ie, 1:je, :&
&       )
      ww1d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, kl, :) = wd(1:ie, 1:je, kl, :) + ww2d(1:ie, 1:je, :&
&       )
      ww2d(1:ie, 1:je, :) = 0.0_8
      wd(1:ie, 1:je, nz, :) = wd(1:ie, 1:je, nz, :) + ww3d(1:ie, 1:je, :&
&       )
      ww3d(1:ie, 1:je, :) = 0.0_8
    end if
  end subroutine setbcpointers_b
  subroutine setbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * setbcpointers sets the pointers needed for the boundary        *
!      * condition treatment on a general face, such that the boundary  *
!      * routines are only implemented once instead of 6 times.         *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use blockpointers, only : w, p, rlv, rev, gamma, x, d2wall, si, sj&
&   , sk, s, globalcell, bcdata, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid
    use bcpointers_b, only : ww0, ww1, ww2, ww3, pp0, pp1, pp2, pp3, &
&   rlv0, rlv1, rlv2, rlv3, rev0, rev1, rev2, rev3, gamma0, gamma1, &
&   gamma2, gamma3, gcp, xx, ss, ssi, ssj, ssk, dd2wall, istart, iend, &
&   jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
! determine the sizes of each face and point to just the range we
! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
! set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
! determine the face id on which the subface is located and set
! the pointers accordinly.
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      ww3(1:je, 1:ke, :) = w(3, 1:je, 1:ke, :)
      ww2(1:je, 1:ke, :) = w(2, 1:je, 1:ke, :)
      ww1(1:je, 1:ke, :) = w(1, 1:je, 1:ke, :)
      ww0(1:je, 1:ke, :) = w(0, 1:je, 1:ke, :)
      pp3(1:je, 1:ke) = p(3, 1:je, 1:ke)
      pp2(1:je, 1:ke) = p(2, 1:je, 1:ke)
      pp1(1:je, 1:ke) = p(1, 1:je, 1:ke)
      pp0(1:je, 1:ke) = p(0, 1:je, 1:ke)
      rlv3(1:je, 1:ke) = rlv(3, 1:je, 1:ke)
      rlv2(1:je, 1:ke) = rlv(2, 1:je, 1:ke)
      rlv1(1:je, 1:ke) = rlv(1, 1:je, 1:ke)
      rlv0(1:je, 1:ke) = rlv(0, 1:je, 1:ke)
      rev3(1:je, 1:ke) = rev(3, 1:je, 1:ke)
      rev2(1:je, 1:ke) = rev(2, 1:je, 1:ke)
      rev1(1:je, 1:ke) = rev(1, 1:je, 1:ke)
      rev0(1:je, 1:ke) = rev(0, 1:je, 1:ke)
      gamma3(1:je, 1:ke) = gamma(3, 1:je, 1:ke)
      gamma2(1:je, 1:ke) = gamma(2, 1:je, 1:ke)
      gamma1(1:je, 1:ke) = gamma(1, 1:je, 1:ke)
      gamma0(1:je, 1:ke) = gamma(0, 1:je, 1:ke)
      gcp(1:je, 1:ke) = globalcell(2, 1:je, 1:ke)
    case (imax) 
!===============================================================
      ww3(1:je, 1:ke, :) = w(nx, 1:je, 1:ke, :)
      ww2(1:je, 1:ke, :) = w(il, 1:je, 1:ke, :)
      ww1(1:je, 1:ke, :) = w(ie, 1:je, 1:ke, :)
      ww0(1:je, 1:ke, :) = w(ib, 1:je, 1:ke, :)
      pp3(1:je, 1:ke) = p(nx, 1:je, 1:ke)
      pp2(1:je, 1:ke) = p(il, 1:je, 1:ke)
      pp1(1:je, 1:ke) = p(ie, 1:je, 1:ke)
      pp0(1:je, 1:ke) = p(ib, 1:je, 1:ke)
      rlv3(1:je, 1:ke) = rlv(nx, 1:je, 1:ke)
      rlv2(1:je, 1:ke) = rlv(il, 1:je, 1:ke)
      rlv1(1:je, 1:ke) = rlv(ie, 1:je, 1:ke)
      rlv0(1:je, 1:ke) = rlv(ib, 1:je, 1:ke)
      rev3(1:je, 1:ke) = rev(nx, 1:je, 1:ke)
      rev2(1:je, 1:ke) = rev(il, 1:je, 1:ke)
      rev1(1:je, 1:ke) = rev(ie, 1:je, 1:ke)
      rev0(1:je, 1:ke) = rev(ib, 1:je, 1:ke)
      gamma3(1:je, 1:ke) = gamma(nx, 1:je, 1:ke)
      gamma2(1:je, 1:ke) = gamma(il, 1:je, 1:ke)
      gamma1(1:je, 1:ke) = gamma(ie, 1:je, 1:ke)
      gamma0(1:je, 1:ke) = gamma(ib, 1:je, 1:ke)
      gcp(1:je, 1:ke) = globalcell(il, 1:je, 1:ke)
    case (jmin) 
!===============================================================
      ww3(1:ie, 1:ke, :) = w(1:ie, 3, 1:ke, :)
      ww2(1:ie, 1:ke, :) = w(1:ie, 2, 1:ke, :)
      ww1(1:ie, 1:ke, :) = w(1:ie, 1, 1:ke, :)
      ww0(1:ie, 1:ke, :) = w(1:ie, 0, 1:ke, :)
      pp3(1:ie, 1:ke) = p(1:ie, 3, 1:ke)
      pp2(1:ie, 1:ke) = p(1:ie, 2, 1:ke)
      pp1(1:ie, 1:ke) = p(1:ie, 1, 1:ke)
      pp0(1:ie, 1:ke) = p(1:ie, 0, 1:ke)
      rlv3(1:ie, 1:ke) = rlv(1:ie, 3, 1:ke)
      rlv2(1:ie, 1:ke) = rlv(1:ie, 2, 1:ke)
      rlv1(1:ie, 1:ke) = rlv(1:ie, 1, 1:ke)
      rlv0(1:ie, 1:ke) = rlv(1:ie, 0, 1:ke)
      rev3(1:ie, 1:ke) = rev(1:ie, 3, 1:ke)
      rev2(1:ie, 1:ke) = rev(1:ie, 2, 1:ke)
      rev1(1:ie, 1:ke) = rev(1:ie, 1, 1:ke)
      rev0(1:ie, 1:ke) = rev(1:ie, 0, 1:ke)
      gamma3(1:ie, 1:ke) = gamma(1:ie, 3, 1:ke)
      gamma2(1:ie, 1:ke) = gamma(1:ie, 2, 1:ke)
      gamma1(1:ie, 1:ke) = gamma(1:ie, 1, 1:ke)
      gamma0(1:ie, 1:ke) = gamma(1:ie, 0, 1:ke)
      gcp(1:ie, 1:ke) = globalcell(1:ie, 2, 1:ke)
    case (jmax) 
!===============================================================
      ww3(1:ie, 1:ke, :) = w(1:ie, ny, 1:ke, :)
      ww2(1:ie, 1:ke, :) = w(1:ie, jl, 1:ke, :)
      ww1(1:ie, 1:ke, :) = w(1:ie, je, 1:ke, :)
      ww0(1:ie, 1:ke, :) = w(1:ie, jb, 1:ke, :)
      pp3(1:ie, 1:ke) = p(1:ie, ny, 1:ke)
      pp2(1:ie, 1:ke) = p(1:ie, jl, 1:ke)
      pp1(1:ie, 1:ke) = p(1:ie, je, 1:ke)
      pp0(1:ie, 1:ke) = p(1:ie, jb, 1:ke)
      rlv3(1:ie, 1:ke) = rlv(1:ie, ny, 1:ke)
      rlv2(1:ie, 1:ke) = rlv(1:ie, jl, 1:ke)
      rlv1(1:ie, 1:ke) = rlv(1:ie, je, 1:ke)
      rlv0(1:ie, 1:ke) = rlv(1:ie, jb, 1:ke)
      rev3(1:ie, 1:ke) = rev(1:ie, ny, 1:ke)
      rev2(1:ie, 1:ke) = rev(1:ie, jl, 1:ke)
      rev1(1:ie, 1:ke) = rev(1:ie, je, 1:ke)
      rev0(1:ie, 1:ke) = rev(1:ie, jb, 1:ke)
      gamma3(1:ie, 1:ke) = gamma(1:ie, ny, 1:ke)
      gamma2(1:ie, 1:ke) = gamma(1:ie, jl, 1:ke)
      gamma1(1:ie, 1:ke) = gamma(1:ie, je, 1:ke)
      gamma0(1:ie, 1:ke) = gamma(1:ie, jb, 1:ke)
      gcp(1:ie, 1:ke) = globalcell(1:ie, jl, 1:ke)
    case (kmin) 
!===============================================================
      ww3(1:ie, 1:je, :) = w(1:ie, 1:je, 3, :)
      ww2(1:ie, 1:je, :) = w(1:ie, 1:je, 2, :)
      ww1(1:ie, 1:je, :) = w(1:ie, 1:je, 1, :)
      ww0(1:ie, 1:je, :) = w(1:ie, 1:je, 0, :)
      pp3(1:ie, 1:je) = p(1:ie, 1:je, 3)
      pp2(1:ie, 1:je) = p(1:ie, 1:je, 2)
      pp1(1:ie, 1:je) = p(1:ie, 1:je, 1)
      pp0(1:ie, 1:je) = p(1:ie, 1:je, 0)
      rlv3(1:ie, 1:je) = rlv(1:ie, 1:je, 3)
      rlv2(1:ie, 1:je) = rlv(1:ie, 1:je, 2)
      rlv1(1:ie, 1:je) = rlv(1:ie, 1:je, 1)
      rlv0(1:ie, 1:je) = rlv(1:ie, 1:je, 0)
      rev3(1:ie, 1:je) = rev(1:ie, 1:je, 3)
      rev2(1:ie, 1:je) = rev(1:ie, 1:je, 2)
      rev1(1:ie, 1:je) = rev(1:ie, 1:je, 1)
      rev0(1:ie, 1:je) = rev(1:ie, 1:je, 0)
      gamma3(1:ie, 1:je) = gamma(1:ie, 1:je, 3)
      gamma2(1:ie, 1:je) = gamma(1:ie, 1:je, 2)
      gamma1(1:ie, 1:je) = gamma(1:ie, 1:je, 1)
      gamma0(1:ie, 1:je) = gamma(1:ie, 1:je, 0)
      gcp(1:ie, 1:je) = globalcell(1:ie, 1:je, 2)
    case (kmax) 
!===============================================================
      ww3(1:ie, 1:je, :) = w(1:ie, 1:je, nz, :)
      ww2(1:ie, 1:je, :) = w(1:ie, 1:je, kl, :)
      ww1(1:ie, 1:je, :) = w(1:ie, 1:je, ke, :)
      ww0(1:ie, 1:je, :) = w(1:ie, 1:je, kb, :)
      pp3(1:ie, 1:je) = p(1:ie, 1:je, nz)
      pp2(1:ie, 1:je) = p(1:ie, 1:je, kl)
      pp1(1:ie, 1:je) = p(1:ie, 1:je, ke)
      pp0(1:ie, 1:je) = p(1:ie, 1:je, kb)
      rlv3(1:ie, 1:je) = rlv(1:ie, 1:je, nz)
      rlv2(1:ie, 1:je) = rlv(1:ie, 1:je, kl)
      rlv1(1:ie, 1:je) = rlv(1:ie, 1:je, ke)
      rlv0(1:ie, 1:je) = rlv(1:ie, 1:je, kb)
      rev3(1:ie, 1:je) = rev(1:ie, 1:je, nz)
      rev2(1:ie, 1:je) = rev(1:ie, 1:je, kl)
      rev1(1:ie, 1:je) = rev(1:ie, 1:je, ke)
      rev0(1:ie, 1:je) = rev(1:ie, 1:je, kb)
      gamma3(1:ie, 1:je) = gamma(1:ie, 1:je, nz)
      gamma2(1:ie, 1:je) = gamma(1:ie, 1:je, kl)
      gamma1(1:ie, 1:je) = gamma(1:ie, 1:je, ke)
      gamma0(1:ie, 1:je) = gamma(1:ie, 1:je, kb)
      gcp(1:ie, 1:je) = globalcell(1:ie, 1:je, 2)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        xx(1:je+1, 1:ke+1, :) = x(1, 0:je, 0:ke, :)
        ssi(1:je, 1:ke, :) = si(1, 1:je, 1:ke, :)
      case (imax) 
        xx(1:je+1, 1:ke+1, :) = x(il, 0:je, 0:ke, :)
        ssi(1:je, 1:ke, :) = si(il, 1:je, 1:ke, :)
      case (jmin) 
        xx(1:ie+1, 1:ke+1, :) = x(0:ie, 1, 0:ke, :)
        ssi(1:ie, 1:ke, :) = sj(1:ie, 1, 1:ke, :)
      case (jmax) 
        xx(1:ie+1, 1:ke+1, :) = x(0:ie, jl, 0:ke, :)
        ssi(1:ie, 1:ke, :) = sj(1:ie, jl, 1:ke, :)
      case (kmin) 
        xx(1:ie+1, 1:je+1, :) = x(0:ie, 0:je, 1, :)
        ssi(1:ie, 1:je, :) = sk(1:ie, 1:je, 1, :)
      case (kmax) 
        xx(1:ie+1, 1:je+1, :) = x(0:ie, 0:je, kl, :)
        ssi(1:ie, 1:je, :) = sk(1:ie, 1:je, kl, :)
      end select
    end if
  end subroutine setbcpointers
!  differentiation of resetbcpointers in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *xx *rev0 *rev1 *rev2 *rev3
!                *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi
!                *ww0 *ww1 *ww2 *ww3 *rev *p *w *rlv *x *si *sj
!                *sk
!   with respect to varying inputs: *xx *rev0 *rev1 *rev2 *rev3
!                *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi
!                *ww0 *ww1 *ww2 *ww3 *rev *p *w *rlv *x *si *sj
!                *sk
!   plus diff mem management of: xx:in rev0:in rev1:in rev2:in
!                rev3:in pp0:in pp1:in pp2:in pp3:in rlv0:in rlv1:in
!                rlv2:in rlv3:in ssi:in ww0:in ww1:in ww2:in ww3:in
!                rev:in p:in w:in rlv:in x:in si:in sj:in sk:in
  subroutine resetbcpointers_b(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * resetbcpointers nullifyies the boundary pointers. for reverse  *
!      * mode ad it copies the values back in to the respective arrays  *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use blockpointers, only : w, wd, p, pd, rlv, rlvd, rev, revd, &
&   gamma, x, xd, d2wall, d2walld, si, sid, sj, sjd, sk, skd, s, &
&   globalcell, bcdata, bcdatad, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid
    use bcpointers_b, only : ww0, ww0d, ww1, ww1d, ww2, ww2d, ww3, ww3d,&
&   pp0, pp0d, pp1, pp1d, pp2, pp2d, pp3, pp3d, rlv0, rlv0d, rlv1, rlv1d&
&   , rlv2, rlv2d, rlv3, rlv3d, rev0, rev0d, rev1, rev1d, rev2, rev2d, &
&   rev3, rev3d, gamma0, gamma1, gamma2, gamma3, gcp, xx, xxd, ss, ssi, &
&   ssid, ssj, ssk, dd2wall, istart, iend, jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    integer :: branch
    select case  (bcfaceid(nn)) 
    case (imin) 
      call pushcontrol3b(1)
    case (imax) 
      call pushcontrol3b(2)
    case (jmin) 
      call pushcontrol3b(3)
    case (jmax) 
      call pushcontrol3b(4)
    case (kmin) 
      call pushcontrol3b(5)
    case (kmax) 
      call pushcontrol3b(6)
    case default
      call pushcontrol3b(0)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        ssid(1:je, 1:ke, :) = ssid(1:je, 1:ke, :) + sid(1, 1:je, 1:ke, :&
&         )
        sid(1, 1:je, 1:ke, :) = 0.0_8
        xxd(1:je+1, 1:ke+1, :) = xxd(1:je+1, 1:ke+1, :) + xd(1, 0:je, 0:&
&         ke, :)
        xd(1, 0:je, 0:ke, :) = 0.0_8
      case (imax) 
        ssid(1:je, 1:ke, :) = ssid(1:je, 1:ke, :) + sid(il, 1:je, 1:ke, &
&         :)
        sid(il, 1:je, 1:ke, :) = 0.0_8
        xxd(1:je+1, 1:ke+1, :) = xxd(1:je+1, 1:ke+1, :) + xd(il, 0:je, 0&
&         :ke, :)
        xd(il, 0:je, 0:ke, :) = 0.0_8
      case (jmin) 
        ssid(1:ie, 1:ke, :) = ssid(1:ie, 1:ke, :) + sjd(1:ie, 1, 1:ke, :&
&         )
        sjd(1:ie, 1, 1:ke, :) = 0.0_8
        xxd(1:ie+1, 1:ke+1, :) = xxd(1:ie+1, 1:ke+1, :) + xd(0:ie, 1, 0:&
&         ke, :)
        xd(0:ie, 1, 0:ke, :) = 0.0_8
      case (jmax) 
        ssid(1:ie, 1:ke, :) = ssid(1:ie, 1:ke, :) + sjd(1:ie, jl, 1:ke, &
&         :)
        sjd(1:ie, jl, 1:ke, :) = 0.0_8
        xxd(1:ie+1, 1:ke+1, :) = xxd(1:ie+1, 1:ke+1, :) + xd(0:ie, jl, 0&
&         :ke, :)
        xd(0:ie, jl, 0:ke, :) = 0.0_8
      case (kmin) 
        ssid(1:ie, 1:je, :) = ssid(1:ie, 1:je, :) + skd(1:ie, 1:je, 1, :&
&         )
        skd(1:ie, 1:je, 1, :) = 0.0_8
        xxd(1:ie+1, 1:je+1, :) = xxd(1:ie+1, 1:je+1, :) + xd(0:ie, 0:je&
&         , 1, :)
        xd(0:ie, 0:je, 1, :) = 0.0_8
      case (kmax) 
        ssid(1:ie, 1:je, :) = ssid(1:ie, 1:je, :) + skd(1:ie, 1:je, kl, &
&         :)
        skd(1:ie, 1:je, kl, :) = 0.0_8
        xxd(1:ie+1, 1:je+1, :) = xxd(1:ie+1, 1:je+1, :) + xd(0:ie, 0:je&
&         , kl, :)
        xd(0:ie, 0:je, kl, :) = 0.0_8
      end select
    end if
    call popcontrol3b(branch)
    if (branch .lt. 3) then
      if (branch .ne. 0) then
        if (branch .eq. 1) then
          rev0d(1:je, 1:ke) = rev0d(1:je, 1:ke) + revd(0, 1:je, 1:ke)
          revd(0, 1:je, 1:ke) = 0.0_8
          rev1d(1:je, 1:ke) = rev1d(1:je, 1:ke) + revd(1, 1:je, 1:ke)
          revd(1, 1:je, 1:ke) = 0.0_8
          rev2d(1:je, 1:ke) = rev2d(1:je, 1:ke) + revd(2, 1:je, 1:ke)
          revd(2, 1:je, 1:ke) = 0.0_8
          rev3d(1:je, 1:ke) = rev3d(1:je, 1:ke) + revd(3, 1:je, 1:ke)
          revd(3, 1:je, 1:ke) = 0.0_8
          rlv0d(1:je, 1:ke) = rlv0d(1:je, 1:ke) + rlvd(0, 1:je, 1:ke)
          rlvd(0, 1:je, 1:ke) = 0.0_8
          rlv1d(1:je, 1:ke) = rlv1d(1:je, 1:ke) + rlvd(1, 1:je, 1:ke)
          rlvd(1, 1:je, 1:ke) = 0.0_8
          rlv2d(1:je, 1:ke) = rlv2d(1:je, 1:ke) + rlvd(2, 1:je, 1:ke)
          rlvd(2, 1:je, 1:ke) = 0.0_8
          rlv3d(1:je, 1:ke) = rlv3d(1:je, 1:ke) + rlvd(3, 1:je, 1:ke)
          rlvd(3, 1:je, 1:ke) = 0.0_8
          pp0d(1:je, 1:ke) = pp0d(1:je, 1:ke) + pd(0, 1:je, 1:ke)
          pd(0, 1:je, 1:ke) = 0.0_8
          pp1d(1:je, 1:ke) = pp1d(1:je, 1:ke) + pd(1, 1:je, 1:ke)
          pd(1, 1:je, 1:ke) = 0.0_8
          pp2d(1:je, 1:ke) = pp2d(1:je, 1:ke) + pd(2, 1:je, 1:ke)
          pd(2, 1:je, 1:ke) = 0.0_8
          pp3d(1:je, 1:ke) = pp3d(1:je, 1:ke) + pd(3, 1:je, 1:ke)
          pd(3, 1:je, 1:ke) = 0.0_8
          ww0d(1:je, 1:ke, :) = ww0d(1:je, 1:ke, :) + wd(0, 1:je, 1:ke, &
&           :)
          wd(0, 1:je, 1:ke, :) = 0.0_8
          ww1d(1:je, 1:ke, :) = ww1d(1:je, 1:ke, :) + wd(1, 1:je, 1:ke, &
&           :)
          wd(1, 1:je, 1:ke, :) = 0.0_8
          ww2d(1:je, 1:ke, :) = ww2d(1:je, 1:ke, :) + wd(2, 1:je, 1:ke, &
&           :)
          wd(2, 1:je, 1:ke, :) = 0.0_8
          ww3d(1:je, 1:ke, :) = ww3d(1:je, 1:ke, :) + wd(3, 1:je, 1:ke, &
&           :)
          wd(3, 1:je, 1:ke, :) = 0.0_8
        else
          rev0d(1:je, 1:ke) = rev0d(1:je, 1:ke) + revd(ib, 1:je, 1:ke)
          revd(ib, 1:je, 1:ke) = 0.0_8
          rev1d(1:je, 1:ke) = rev1d(1:je, 1:ke) + revd(ie, 1:je, 1:ke)
          revd(ie, 1:je, 1:ke) = 0.0_8
          rev2d(1:je, 1:ke) = rev2d(1:je, 1:ke) + revd(il, 1:je, 1:ke)
          revd(il, 1:je, 1:ke) = 0.0_8
          rev3d(1:je, 1:ke) = rev3d(1:je, 1:ke) + revd(nx, 1:je, 1:ke)
          revd(nx, 1:je, 1:ke) = 0.0_8
          rlv0d(1:je, 1:ke) = rlv0d(1:je, 1:ke) + rlvd(ib, 1:je, 1:ke)
          rlvd(ib, 1:je, 1:ke) = 0.0_8
          rlv1d(1:je, 1:ke) = rlv1d(1:je, 1:ke) + rlvd(ie, 1:je, 1:ke)
          rlvd(ie, 1:je, 1:ke) = 0.0_8
          rlv2d(1:je, 1:ke) = rlv2d(1:je, 1:ke) + rlvd(il, 1:je, 1:ke)
          rlvd(il, 1:je, 1:ke) = 0.0_8
          rlv3d(1:je, 1:ke) = rlv3d(1:je, 1:ke) + rlvd(nx, 1:je, 1:ke)
          rlvd(nx, 1:je, 1:ke) = 0.0_8
          pp0d(1:je, 1:ke) = pp0d(1:je, 1:ke) + pd(ib, 1:je, 1:ke)
          pd(ib, 1:je, 1:ke) = 0.0_8
          pp1d(1:je, 1:ke) = pp1d(1:je, 1:ke) + pd(ie, 1:je, 1:ke)
          pd(ie, 1:je, 1:ke) = 0.0_8
          pp2d(1:je, 1:ke) = pp2d(1:je, 1:ke) + pd(il, 1:je, 1:ke)
          pd(il, 1:je, 1:ke) = 0.0_8
          pp3d(1:je, 1:ke) = pp3d(1:je, 1:ke) + pd(nx, 1:je, 1:ke)
          pd(nx, 1:je, 1:ke) = 0.0_8
          ww0d(1:je, 1:ke, :) = ww0d(1:je, 1:ke, :) + wd(ib, 1:je, 1:ke&
&           , :)
          wd(ib, 1:je, 1:ke, :) = 0.0_8
          ww1d(1:je, 1:ke, :) = ww1d(1:je, 1:ke, :) + wd(ie, 1:je, 1:ke&
&           , :)
          wd(ie, 1:je, 1:ke, :) = 0.0_8
          ww2d(1:je, 1:ke, :) = ww2d(1:je, 1:ke, :) + wd(il, 1:je, 1:ke&
&           , :)
          wd(il, 1:je, 1:ke, :) = 0.0_8
          ww3d(1:je, 1:ke, :) = ww3d(1:je, 1:ke, :) + wd(nx, 1:je, 1:ke&
&           , :)
          wd(nx, 1:je, 1:ke, :) = 0.0_8
        end if
      end if
    else if (branch .lt. 5) then
      if (branch .eq. 3) then
        rev0d(1:ie, 1:ke) = rev0d(1:ie, 1:ke) + revd(1:ie, 0, 1:ke)
        revd(1:ie, 0, 1:ke) = 0.0_8
        rev1d(1:ie, 1:ke) = rev1d(1:ie, 1:ke) + revd(1:ie, 1, 1:ke)
        revd(1:ie, 1, 1:ke) = 0.0_8
        rev2d(1:ie, 1:ke) = rev2d(1:ie, 1:ke) + revd(1:ie, 2, 1:ke)
        revd(1:ie, 2, 1:ke) = 0.0_8
        rev3d(1:ie, 1:ke) = rev3d(1:ie, 1:ke) + revd(1:ie, 3, 1:ke)
        revd(1:ie, 3, 1:ke) = 0.0_8
        rlv0d(1:ie, 1:ke) = rlv0d(1:ie, 1:ke) + rlvd(1:ie, 0, 1:ke)
        rlvd(1:ie, 0, 1:ke) = 0.0_8
        rlv1d(1:ie, 1:ke) = rlv1d(1:ie, 1:ke) + rlvd(1:ie, 1, 1:ke)
        rlvd(1:ie, 1, 1:ke) = 0.0_8
        rlv2d(1:ie, 1:ke) = rlv2d(1:ie, 1:ke) + rlvd(1:ie, 2, 1:ke)
        rlvd(1:ie, 2, 1:ke) = 0.0_8
        rlv3d(1:ie, 1:ke) = rlv3d(1:ie, 1:ke) + rlvd(1:ie, 3, 1:ke)
        rlvd(1:ie, 3, 1:ke) = 0.0_8
        pp0d(1:ie, 1:ke) = pp0d(1:ie, 1:ke) + pd(1:ie, 0, 1:ke)
        pd(1:ie, 0, 1:ke) = 0.0_8
        pp1d(1:ie, 1:ke) = pp1d(1:ie, 1:ke) + pd(1:ie, 1, 1:ke)
        pd(1:ie, 1, 1:ke) = 0.0_8
        pp2d(1:ie, 1:ke) = pp2d(1:ie, 1:ke) + pd(1:ie, 2, 1:ke)
        pd(1:ie, 2, 1:ke) = 0.0_8
        pp3d(1:ie, 1:ke) = pp3d(1:ie, 1:ke) + pd(1:ie, 3, 1:ke)
        pd(1:ie, 3, 1:ke) = 0.0_8
        ww0d(1:ie, 1:ke, :) = ww0d(1:ie, 1:ke, :) + wd(1:ie, 0, 1:ke, :)
        wd(1:ie, 0, 1:ke, :) = 0.0_8
        ww1d(1:ie, 1:ke, :) = ww1d(1:ie, 1:ke, :) + wd(1:ie, 1, 1:ke, :)
        wd(1:ie, 1, 1:ke, :) = 0.0_8
        ww2d(1:ie, 1:ke, :) = ww2d(1:ie, 1:ke, :) + wd(1:ie, 2, 1:ke, :)
        wd(1:ie, 2, 1:ke, :) = 0.0_8
        ww3d(1:ie, 1:ke, :) = ww3d(1:ie, 1:ke, :) + wd(1:ie, 3, 1:ke, :)
        wd(1:ie, 3, 1:ke, :) = 0.0_8
      else
        rev0d(1:ie, 1:ke) = rev0d(1:ie, 1:ke) + revd(1:ie, jb, 1:ke)
        revd(1:ie, jb, 1:ke) = 0.0_8
        rev1d(1:ie, 1:ke) = rev1d(1:ie, 1:ke) + revd(1:ie, je, 1:ke)
        revd(1:ie, je, 1:ke) = 0.0_8
        rev2d(1:ie, 1:ke) = rev2d(1:ie, 1:ke) + revd(1:ie, jl, 1:ke)
        revd(1:ie, jl, 1:ke) = 0.0_8
        rev3d(1:ie, 1:ke) = rev3d(1:ie, 1:ke) + revd(1:ie, ny, 1:ke)
        revd(1:ie, ny, 1:ke) = 0.0_8
        rlv0d(1:ie, 1:ke) = rlv0d(1:ie, 1:ke) + rlvd(1:ie, jb, 1:ke)
        rlvd(1:ie, jb, 1:ke) = 0.0_8
        rlv1d(1:ie, 1:ke) = rlv1d(1:ie, 1:ke) + rlvd(1:ie, je, 1:ke)
        rlvd(1:ie, je, 1:ke) = 0.0_8
        rlv2d(1:ie, 1:ke) = rlv2d(1:ie, 1:ke) + rlvd(1:ie, jl, 1:ke)
        rlvd(1:ie, jl, 1:ke) = 0.0_8
        rlv3d(1:ie, 1:ke) = rlv3d(1:ie, 1:ke) + rlvd(1:ie, ny, 1:ke)
        rlvd(1:ie, ny, 1:ke) = 0.0_8
        pp0d(1:ie, 1:ke) = pp0d(1:ie, 1:ke) + pd(1:ie, jb, 1:ke)
        pd(1:ie, jb, 1:ke) = 0.0_8
        pp1d(1:ie, 1:ke) = pp1d(1:ie, 1:ke) + pd(1:ie, je, 1:ke)
        pd(1:ie, je, 1:ke) = 0.0_8
        pp2d(1:ie, 1:ke) = pp2d(1:ie, 1:ke) + pd(1:ie, jl, 1:ke)
        pd(1:ie, jl, 1:ke) = 0.0_8
        pp3d(1:ie, 1:ke) = pp3d(1:ie, 1:ke) + pd(1:ie, ny, 1:ke)
        pd(1:ie, ny, 1:ke) = 0.0_8
        ww0d(1:ie, 1:ke, :) = ww0d(1:ie, 1:ke, :) + wd(1:ie, jb, 1:ke, :&
&         )
        wd(1:ie, jb, 1:ke, :) = 0.0_8
        ww1d(1:ie, 1:ke, :) = ww1d(1:ie, 1:ke, :) + wd(1:ie, je, 1:ke, :&
&         )
        wd(1:ie, je, 1:ke, :) = 0.0_8
        ww2d(1:ie, 1:ke, :) = ww2d(1:ie, 1:ke, :) + wd(1:ie, jl, 1:ke, :&
&         )
        wd(1:ie, jl, 1:ke, :) = 0.0_8
        ww3d(1:ie, 1:ke, :) = ww3d(1:ie, 1:ke, :) + wd(1:ie, ny, 1:ke, :&
&         )
        wd(1:ie, ny, 1:ke, :) = 0.0_8
      end if
    else if (branch .eq. 5) then
      rev0d(1:ie, 1:je) = rev0d(1:ie, 1:je) + revd(1:ie, 1:je, 0)
      revd(1:ie, 1:je, 0) = 0.0_8
      rev1d(1:ie, 1:je) = rev1d(1:ie, 1:je) + revd(1:ie, 1:je, 1)
      revd(1:ie, 1:je, 1) = 0.0_8
      rev2d(1:ie, 1:je) = rev2d(1:ie, 1:je) + revd(1:ie, 1:je, 2)
      revd(1:ie, 1:je, 2) = 0.0_8
      rev3d(1:ie, 1:je) = rev3d(1:ie, 1:je) + revd(1:ie, 1:je, 3)
      revd(1:ie, 1:je, 3) = 0.0_8
      rlv0d(1:ie, 1:je) = rlv0d(1:ie, 1:je) + rlvd(1:ie, 1:je, 0)
      rlvd(1:ie, 1:je, 0) = 0.0_8
      rlv1d(1:ie, 1:je) = rlv1d(1:ie, 1:je) + rlvd(1:ie, 1:je, 1)
      rlvd(1:ie, 1:je, 1) = 0.0_8
      rlv2d(1:ie, 1:je) = rlv2d(1:ie, 1:je) + rlvd(1:ie, 1:je, 2)
      rlvd(1:ie, 1:je, 2) = 0.0_8
      rlv3d(1:ie, 1:je) = rlv3d(1:ie, 1:je) + rlvd(1:ie, 1:je, 3)
      rlvd(1:ie, 1:je, 3) = 0.0_8
      pp0d(1:ie, 1:je) = pp0d(1:ie, 1:je) + pd(1:ie, 1:je, 0)
      pd(1:ie, 1:je, 0) = 0.0_8
      pp1d(1:ie, 1:je) = pp1d(1:ie, 1:je) + pd(1:ie, 1:je, 1)
      pd(1:ie, 1:je, 1) = 0.0_8
      pp2d(1:ie, 1:je) = pp2d(1:ie, 1:je) + pd(1:ie, 1:je, 2)
      pd(1:ie, 1:je, 2) = 0.0_8
      pp3d(1:ie, 1:je) = pp3d(1:ie, 1:je) + pd(1:ie, 1:je, 3)
      pd(1:ie, 1:je, 3) = 0.0_8
      ww0d(1:ie, 1:je, :) = ww0d(1:ie, 1:je, :) + wd(1:ie, 1:je, 0, :)
      wd(1:ie, 1:je, 0, :) = 0.0_8
      ww1d(1:ie, 1:je, :) = ww1d(1:ie, 1:je, :) + wd(1:ie, 1:je, 1, :)
      wd(1:ie, 1:je, 1, :) = 0.0_8
      ww2d(1:ie, 1:je, :) = ww2d(1:ie, 1:je, :) + wd(1:ie, 1:je, 2, :)
      wd(1:ie, 1:je, 2, :) = 0.0_8
      ww3d(1:ie, 1:je, :) = ww3d(1:ie, 1:je, :) + wd(1:ie, 1:je, 3, :)
      wd(1:ie, 1:je, 3, :) = 0.0_8
    else
      rev0d(1:ie, 1:je) = rev0d(1:ie, 1:je) + revd(1:ie, 1:je, kb)
      revd(1:ie, 1:je, kb) = 0.0_8
      rev1d(1:ie, 1:je) = rev1d(1:ie, 1:je) + revd(1:ie, 1:je, ke)
      revd(1:ie, 1:je, ke) = 0.0_8
      rev2d(1:ie, 1:je) = rev2d(1:ie, 1:je) + revd(1:ie, 1:je, kl)
      revd(1:ie, 1:je, kl) = 0.0_8
      rev3d(1:ie, 1:je) = rev3d(1:ie, 1:je) + revd(1:ie, 1:je, nz)
      revd(1:ie, 1:je, nz) = 0.0_8
      rlv0d(1:ie, 1:je) = rlv0d(1:ie, 1:je) + rlvd(1:ie, 1:je, kb)
      rlvd(1:ie, 1:je, kb) = 0.0_8
      rlv1d(1:ie, 1:je) = rlv1d(1:ie, 1:je) + rlvd(1:ie, 1:je, ke)
      rlvd(1:ie, 1:je, ke) = 0.0_8
      rlv2d(1:ie, 1:je) = rlv2d(1:ie, 1:je) + rlvd(1:ie, 1:je, kl)
      rlvd(1:ie, 1:je, kl) = 0.0_8
      rlv3d(1:ie, 1:je) = rlv3d(1:ie, 1:je) + rlvd(1:ie, 1:je, nz)
      rlvd(1:ie, 1:je, nz) = 0.0_8
      pp0d(1:ie, 1:je) = pp0d(1:ie, 1:je) + pd(1:ie, 1:je, kb)
      pd(1:ie, 1:je, kb) = 0.0_8
      pp1d(1:ie, 1:je) = pp1d(1:ie, 1:je) + pd(1:ie, 1:je, ke)
      pd(1:ie, 1:je, ke) = 0.0_8
      pp2d(1:ie, 1:je) = pp2d(1:ie, 1:je) + pd(1:ie, 1:je, kl)
      pd(1:ie, 1:je, kl) = 0.0_8
      pp3d(1:ie, 1:je) = pp3d(1:ie, 1:je) + pd(1:ie, 1:je, nz)
      pd(1:ie, 1:je, nz) = 0.0_8
      ww0d(1:ie, 1:je, :) = ww0d(1:ie, 1:je, :) + wd(1:ie, 1:je, kb, :)
      wd(1:ie, 1:je, kb, :) = 0.0_8
      ww1d(1:ie, 1:je, :) = ww1d(1:ie, 1:je, :) + wd(1:ie, 1:je, ke, :)
      wd(1:ie, 1:je, ke, :) = 0.0_8
      ww2d(1:ie, 1:je, :) = ww2d(1:ie, 1:je, :) + wd(1:ie, 1:je, kl, :)
      wd(1:ie, 1:je, kl, :) = 0.0_8
      ww3d(1:ie, 1:je, :) = ww3d(1:ie, 1:je, :) + wd(1:ie, 1:je, nz, :)
      wd(1:ie, 1:je, nz, :) = 0.0_8
    end if
  end subroutine resetbcpointers_b
  subroutine resetbcpointers(nn, spatialpointers)
!
!      ******************************************************************
!      *                                                                *
!      * resetbcpointers nullifyies the boundary pointers. for reverse  *
!      * mode ad it copies the values back in to the respective arrays  *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use blockpointers, only : w, p, rlv, rev, gamma, x, d2wall, si, sj&
&   , sk, s, globalcell, bcdata, nx, il, ie, ib, ny, jl, je, jb, nz, kl,&
&   ke, kb, bcfaceid
    use bcpointers_b, only : ww0, ww1, ww2, ww3, pp0, pp1, pp2, pp3, &
&   rlv0, rlv1, rlv2, rlv3, rev0, rev1, rev2, rev3, gamma0, gamma1, &
&   gamma2, gamma3, gcp, xx, ss, ssi, ssj, ssk, dd2wall, istart, iend, &
&   jstart, jend, isize, jsize
    use inputphysics, only : cpmodel, equations
    implicit none
! subroutine arguments.
    integer(kind=inttype), intent(in) :: nn
    logical, intent(in) :: spatialpointers
    select case  (bcfaceid(nn)) 
    case (imin) 
!===============================================================
      w(3, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(2, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(1, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(0, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(3, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(2, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(1, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(0, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(3, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(2, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(1, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(0, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(3, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(2, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(1, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(0, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(3, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(2, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(1, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(0, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (imax) 
!===============================================================
      w(nx, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
      w(il, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
      w(ie, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
      w(ib, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
      p(nx, 1:je, 1:ke) = pp3(1:je, 1:ke)
      p(il, 1:je, 1:ke) = pp2(1:je, 1:ke)
      p(ie, 1:je, 1:ke) = pp1(1:je, 1:ke)
      p(ib, 1:je, 1:ke) = pp0(1:je, 1:ke)
      rlv(nx, 1:je, 1:ke) = rlv3(1:je, 1:ke)
      rlv(il, 1:je, 1:ke) = rlv2(1:je, 1:ke)
      rlv(ie, 1:je, 1:ke) = rlv1(1:je, 1:ke)
      rlv(ib, 1:je, 1:ke) = rlv0(1:je, 1:ke)
      rev(nx, 1:je, 1:ke) = rev3(1:je, 1:ke)
      rev(il, 1:je, 1:ke) = rev2(1:je, 1:ke)
      rev(ie, 1:je, 1:ke) = rev1(1:je, 1:ke)
      rev(ib, 1:je, 1:ke) = rev0(1:je, 1:ke)
      gamma(nx, 1:je, 1:ke) = gamma3(1:je, 1:ke)
      gamma(il, 1:je, 1:ke) = gamma2(1:je, 1:ke)
      gamma(ie, 1:je, 1:ke) = gamma1(1:je, 1:ke)
      gamma(ib, 1:je, 1:ke) = gamma0(1:je, 1:ke)
    case (jmin) 
!===============================================================
      w(1:ie, 3, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, 2, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, 1, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, 0, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, 3, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, 2, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, 1, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, 0, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, 3, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, 2, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, 1, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, 0, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, 3, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, 2, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, 1, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, 0, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, 3, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, 2, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, 1, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, 0, 1:ke) = gamma0(1:ie, 1:ke)
    case (jmax) 
!===============================================================
      w(1:ie, ny, 1:ke, :) = ww3(1:ie, 1:ke, :)
      w(1:ie, jl, 1:ke, :) = ww2(1:ie, 1:ke, :)
      w(1:ie, je, 1:ke, :) = ww1(1:ie, 1:ke, :)
      w(1:ie, jb, 1:ke, :) = ww0(1:ie, 1:ke, :)
      p(1:ie, ny, 1:ke) = pp3(1:ie, 1:ke)
      p(1:ie, jl, 1:ke) = pp2(1:ie, 1:ke)
      p(1:ie, je, 1:ke) = pp1(1:ie, 1:ke)
      p(1:ie, jb, 1:ke) = pp0(1:ie, 1:ke)
      rlv(1:ie, ny, 1:ke) = rlv3(1:ie, 1:ke)
      rlv(1:ie, jl, 1:ke) = rlv2(1:ie, 1:ke)
      rlv(1:ie, je, 1:ke) = rlv1(1:ie, 1:ke)
      rlv(1:ie, jb, 1:ke) = rlv0(1:ie, 1:ke)
      rev(1:ie, ny, 1:ke) = rev3(1:ie, 1:ke)
      rev(1:ie, jl, 1:ke) = rev2(1:ie, 1:ke)
      rev(1:ie, je, 1:ke) = rev1(1:ie, 1:ke)
      rev(1:ie, jb, 1:ke) = rev0(1:ie, 1:ke)
      gamma(1:ie, ny, 1:ke) = gamma3(1:ie, 1:ke)
      gamma(1:ie, jl, 1:ke) = gamma2(1:ie, 1:ke)
      gamma(1:ie, je, 1:ke) = gamma1(1:ie, 1:ke)
      gamma(1:ie, jb, 1:ke) = gamma0(1:ie, 1:ke)
    case (kmin) 
!===============================================================
      w(1:ie, 1:je, 3, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, 2, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, 1, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, 0, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, 3) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, 2) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, 1) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, 0) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, 3) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, 2) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, 1) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, 0) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, 3) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, 2) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, 1) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, 0) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, 3) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, 2) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, 1) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, 0) = gamma0(1:ie, 1:je)
    case (kmax) 
!===============================================================
      w(1:ie, 1:je, nz, :) = ww3(1:ie, 1:je, :)
      w(1:ie, 1:je, kl, :) = ww2(1:ie, 1:je, :)
      w(1:ie, 1:je, ke, :) = ww1(1:ie, 1:je, :)
      w(1:ie, 1:je, kb, :) = ww0(1:ie, 1:je, :)
      p(1:ie, 1:je, nz) = pp3(1:ie, 1:je)
      p(1:ie, 1:je, kl) = pp2(1:ie, 1:je)
      p(1:ie, 1:je, ke) = pp1(1:ie, 1:je)
      p(1:ie, 1:je, kb) = pp0(1:ie, 1:je)
      rlv(1:ie, 1:je, nz) = rlv3(1:ie, 1:je)
      rlv(1:ie, 1:je, kl) = rlv2(1:ie, 1:je)
      rlv(1:ie, 1:je, ke) = rlv1(1:ie, 1:je)
      rlv(1:ie, 1:je, kb) = rlv0(1:ie, 1:je)
      rev(1:ie, 1:je, nz) = rev3(1:ie, 1:je)
      rev(1:ie, 1:je, kl) = rev2(1:ie, 1:je)
      rev(1:ie, 1:je, ke) = rev1(1:ie, 1:je)
      rev(1:ie, 1:je, kb) = rev0(1:ie, 1:je)
      gamma(1:ie, 1:je, nz) = gamma3(1:ie, 1:je)
      gamma(1:ie, 1:je, kl) = gamma2(1:ie, 1:je)
      gamma(1:ie, 1:je, ke) = gamma1(1:ie, 1:je)
      gamma(1:ie, 1:je, kb) = gamma0(1:ie, 1:je)
    end select
! these spatial pointers are only required for
! forcesandmoments. eulerwall normal moment is is reverse ad'ed.
    if (spatialpointers) then
      select case  (bcfaceid(nn)) 
      case (imin) 
        x(1, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(1, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (imax) 
        x(il, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
        si(il, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
      case (jmin) 
        x(0:ie, 1, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, 1, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (jmax) 
        x(0:ie, jl, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
        sj(1:ie, jl, 1:ke, :) = ssi(1:ie, 1:ke, :)
      case (kmin) 
        x(0:ie, 0:je, 1, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, 1, :) = ssi(1:ie, 1:je, :)
      case (kmax) 
        x(0:ie, 0:je, kl, :) = xx(1:ie+1, 1:je+1, :)
        sk(1:ie, 1:je, kl, :) = ssi(1:ie, 1:je, :)
      end select
    end if
  end subroutine resetbcpointers
!  differentiation of computerootbendingmoment in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: lengthref pointref bendingmoment
!   with respect to varying inputs: lengthref pointref cf cm
  subroutine computerootbendingmoment_b(cf, cfd, cm, cmd, liftindex, &
&   bendingmoment, bendingmomentd)
!*******************************************************
!                                                      *
! compute a normalized bending moment coefficient from *
! the force and moment coefficient. at the moment this *
! routine only works for a half body. additional logic *
! would be needed for a full body.                     *
!                                                      *
!*******************************************************
    use constants
    use inputphysics, only : lengthref, lengthrefd, pointref, &
&   pointrefd, pointrefec
    implicit none
!input/output variables
    real(kind=realtype), dimension(3), intent(in) :: cf, cm
    real(kind=realtype), dimension(3) :: cfd, cmd
    integer(kind=inttype), intent(in) :: liftindex
    real(kind=realtype) :: bendingmoment
    real(kind=realtype) :: bendingmomentd
!subroutine variables
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    real(kind=realtype) :: elasticmomentxd, elasticmomentyd, &
&   elasticmomentzd
    intrinsic sqrt
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp6
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp4
    if (liftindex .eq. 2) then
!z out wing sum momentx,momentz
      elasticmomentx = cm(1) + cf(2)*(pointrefec(3)-pointref(3))/&
&       lengthref - cf(3)*(pointrefec(2)-pointref(2))/lengthref
      elasticmomentz = cm(3) - cf(2)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(2)-pointref(2))/lengthref
      temp0 = cf(3)/lengthref
      if (elasticmomentx**2 + elasticmomentz**2 .eq. 0.0_8) then
        tempd = 0.0
      else
        tempd = bendingmomentd/(2.0*sqrt(elasticmomentx**2+&
&         elasticmomentz**2))
      end if
      elasticmomentxd = 2*elasticmomentx*tempd
      elasticmomentzd = 2*elasticmomentz*tempd
      cfd = 0.0_8
      cmd = 0.0_8
      tempd0 = -((pointrefec(1)-pointref(1))*elasticmomentzd/lengthref)
      temp1 = cf(2)/lengthref
      tempd1 = (pointrefec(2)-pointref(2))*elasticmomentzd/lengthref
      temp2 = cf(1)/lengthref
      cmd(3) = cmd(3) + elasticmomentzd
      cfd(2) = cfd(2) + tempd0
      pointrefd(1) = pointrefd(1) + temp1*elasticmomentzd
      cfd(1) = cfd(1) + tempd1
      pointrefd(2) = pointrefd(2) - temp2*elasticmomentzd
      tempd2 = (pointrefec(3)-pointref(3))*elasticmomentxd/lengthref
      temp = cf(2)/lengthref
      tempd3 = -((pointrefec(2)-pointref(2))*elasticmomentxd/lengthref)
      lengthrefd = lengthrefd - temp*tempd2 - temp0*tempd3 - temp2*&
&       tempd1 - temp1*tempd0
      cmd(1) = cmd(1) + elasticmomentxd
      cfd(2) = cfd(2) + tempd2
      pointrefd(3) = pointrefd(3) - temp*elasticmomentxd
      cfd(3) = cfd(3) + tempd3
      pointrefd(2) = pointrefd(2) + temp0*elasticmomentxd
    else if (liftindex .eq. 3) then
!y out wing sum momentx,momenty
      elasticmomentx = cm(1) + cf(3)*(pointrefec(2)-pointref(2))/&
&       lengthref + cf(3)*(pointrefec(3)-pointref(3))/lengthref
      elasticmomenty = cm(2) + cf(3)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(3)-pointref(3))/lengthref
      temp4 = cf(3)/lengthref
      if (elasticmomentx**2 + elasticmomenty**2 .eq. 0.0_8) then
        tempd4 = 0.0
      else
        tempd4 = bendingmomentd/(2.0*sqrt(elasticmomentx**2+&
&         elasticmomenty**2))
      end if
      elasticmomentxd = 2*elasticmomentx*tempd4
      elasticmomentyd = 2*elasticmomenty*tempd4
      cfd = 0.0_8
      cmd = 0.0_8
      tempd5 = (pointrefec(1)-pointref(1))*elasticmomentyd/lengthref
      temp5 = cf(3)/lengthref
      tempd6 = (pointrefec(3)-pointref(3))*elasticmomentyd/lengthref
      temp6 = cf(1)/lengthref
      cmd(2) = cmd(2) + elasticmomentyd
      cfd(3) = cfd(3) + tempd5
      pointrefd(1) = pointrefd(1) - temp5*elasticmomentyd
      cfd(1) = cfd(1) + tempd6
      pointrefd(3) = pointrefd(3) - temp6*elasticmomentyd
      tempd7 = (pointrefec(2)-pointref(2))*elasticmomentxd/lengthref
      temp3 = cf(3)/lengthref
      tempd8 = (pointrefec(3)-pointref(3))*elasticmomentxd/lengthref
      lengthrefd = lengthrefd - temp3*tempd7 - temp4*tempd8 - temp6*&
&       tempd6 - temp5*tempd5
      cmd(1) = cmd(1) + elasticmomentxd
      cfd(3) = cfd(3) + tempd8 + tempd7
      pointrefd(2) = pointrefd(2) - temp3*elasticmomentxd
      pointrefd(3) = pointrefd(3) - temp4*elasticmomentxd
    else
      cfd = 0.0_8
      cmd = 0.0_8
    end if
  end subroutine computerootbendingmoment_b
  subroutine computerootbendingmoment(cf, cm, liftindex, bendingmoment)
!*******************************************************
!                                                      *
! compute a normalized bending moment coefficient from *
! the force and moment coefficient. at the moment this *
! routine only works for a half body. additional logic *
! would be needed for a full body.                     *
!                                                      *
!*******************************************************
    use constants
    use inputphysics, only : lengthref, pointref, pointrefec
    implicit none
!input/output variables
    real(kind=realtype), dimension(3), intent(in) :: cf, cm
    integer(kind=inttype), intent(in) :: liftindex
    real(kind=realtype), intent(out) :: bendingmoment
!subroutine variables
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    intrinsic sqrt
    bendingmoment = zero
    if (liftindex .eq. 2) then
!z out wing sum momentx,momentz
      elasticmomentx = cm(1) + cf(2)*(pointrefec(3)-pointref(3))/&
&       lengthref - cf(3)*(pointrefec(2)-pointref(2))/lengthref
      elasticmomentz = cm(3) - cf(2)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(2)-pointref(2))/lengthref
      bendingmoment = sqrt(elasticmomentx**2 + elasticmomentz**2)
    else if (liftindex .eq. 3) then
!y out wing sum momentx,momenty
      elasticmomentx = cm(1) + cf(3)*(pointrefec(2)-pointref(2))/&
&       lengthref + cf(3)*(pointrefec(3)-pointref(3))/lengthref
      elasticmomenty = cm(2) + cf(3)*(pointrefec(1)-pointref(1))/&
&       lengthref + cf(1)*(pointrefec(3)-pointref(3))/lengthref
      bendingmoment = sqrt(elasticmomentx**2 + elasticmomenty**2)
    end if
  end subroutine computerootbendingmoment
!  differentiation of computetsderivatives in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: lengthref dragdirection liftdirection
!                moment dcdalphadot coef0 force dcdalpha
!   with respect to varying inputs: gammainf pinf rhoinfdim pinfdim
!                pref machgrid lengthref machcoef dragdirection
!                liftdirection moment force
  subroutine computetsderivatives_b(force, forced, moment, momentd, &
&   liftindex, coef0, coef0d, dcdalpha, dcdalphad, dcdalphadot, &
&   dcdalphadotd, dcdq, dcdqdot)
!
!     ******************************************************************
!     *                                                                *
!     * computes the stability derivatives based on the time spectral  *
!     * solution of a given mesh. takes in the force coefficients at   *
!     * all time instantces and computes the agregate parameters       *
!     *                                                                *
!     ******************************************************************
!
    use constants
    use communication
    use inputphysics
    use inputtimespectral
    use inputtsstabderiv
    use flowvarrefstate
    use monitor
    use section
    use inputmotion
    implicit none
!
!     subroutine arguments.
!
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced&
&   , momentd
    real(kind=realtype), dimension(8) :: dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
    real(kind=realtype), dimension(8) :: dcdalphad, dcdalphadotd
    real(kind=realtype), dimension(8) :: coef0
    real(kind=realtype), dimension(8) :: coef0d
    integer(kind=inttype) :: liftindex
! working variables
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoefd
    real(kind=realtype), dimension(8) :: coef0dot
    real(kind=realtype), dimension(8) :: coef0dotd
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   resbasecoef
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   resbasecoefd
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalalpha, intervalalphadot
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalmach, intervalmachdot
    real(kind=realtype), dimension(nsections) :: t
    real(kind=realtype) :: alpha, beta
    integer(kind=inttype) :: i, sps, nn
!speed of sound: for normalization of q derivatives
    real(kind=realtype) :: a
    real(kind=realtype) :: ad
    real(kind=realtype) :: scaledim, fact, factmoment
    real(kind=realtype) :: scaledimd, factd, factmomentd
! functions
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphix, &
&   dphiy, dphiz
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphixdot, &
&   dphiydot, dphizdot
    real(kind=realtype) :: derivativerigidrotangle, &
&   secondderivativerigidrotangle
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4(8)
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    scaledim = pref/pinf
    fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
    factmoment = fact/(lengthref*lref)
    if (tsqmode) then
      stop
! !q is pitch
! do sps =1,ntimeintervalsspectral
!    !compute the time of this intervavc
!    t = timeunsteadyrestart
!    if(equationmode == timespectral) then
!       do nn=1,nsections
!          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod &
!               /         (ntimeintervalsspectral*1.0)
!       enddo
!    endif
!    ! compute the time derivative of the rotation angles around the
!    ! z-axis. i.e. compute q
!    dphiz(sps) = derivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
!    ! add in q_dot computation
!    dphizdot(sps) = secondderivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
! end do
! !now compute dcl/dq
! do i =1,8
!    call computeleastsquaresregression(basecoef(:,i),dphiz,ntimeintervalsspectral,dcdq(i),coef0(i))
! end do
! ! now subtract off estimated cl,cmz and use remainder to compute 
! ! clqdot and cmzqdot.
! do i = 1,8
!    do sps = 1,ntimeintervalsspectral
!       resbasecoef(sps,i) = basecoef(sps,i)-(dcdq(i)*dphiz(sps)+coef0(i))
!    enddo
! enddo
! !now normalize the results...
! a  = sqrt(gammainf*pinfdim/rhoinfdim)
! dcdq = dcdq*timeref*2*(machgrid*a)/lengthref
! !now compute dcl/dpdot
! do i = 1,8
!    call computeleastsquaresregression(resbasecoef(:,i),dphizdot,ntimeintervalsspectral,dcdqdot(i),coef0dot(i))
! enddo
    else
      if (tsalphamode) then
        do sps=1,ntimeintervalsspectral
!compute the time of this interval
          t = timeunsteadyrestart
          if (equationmode .eq. timespectral) then
            do nn=1,nsections
              t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&               ntimeintervalsspectral*1.0)
            end do
          end if
          intervalalpha(sps) = tsalpha(degreepolalpha, coefpolalpha, &
&           degreefouralpha, omegafouralpha, coscoeffouralpha, &
&           sincoeffouralpha, t(1))
          intervalalphadot(sps) = tsalphadot(degreepolalpha, &
&           coefpolalpha, degreefouralpha, omegafouralpha, &
&           coscoeffouralpha, sincoeffouralpha, t(1))
          basecoef(sps, 1) = fact*(force(1, sps)*liftdirection(1)+force(&
&           2, sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
          basecoef(sps, 2) = fact*(force(1, sps)*dragdirection(1)+force(&
&           2, sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
          basecoef(sps, 3) = force(1, sps)*fact
          basecoef(sps, 4) = force(2, sps)*fact
          basecoef(sps, 5) = force(3, sps)*fact
          basecoef(sps, 6) = moment(1, sps)*factmoment
          basecoef(sps, 7) = moment(2, sps)*factmoment
          basecoef(sps, 8) = moment(3, sps)*factmoment
        end do
!now compute dcl/dalpha
        do i=1,8
          call computeleastsquaresregression(basecoef(:, i), &
&                                      intervalalpha, &
&                                      ntimeintervalsspectral, dcdalpha(&
&                                      i), coef0(i))
        end do
! now subtract off estimated cl,cmz and use remainder to compute 
! clalphadot and cmzalphadot.
        do i=1,8
          do sps=1,ntimeintervalsspectral
            resbasecoef(sps, i) = basecoef(sps, i) - (dcdalpha(i)*&
&             intervalalpha(sps)+coef0(i))
          end do
        end do
!now compute dci/dalphadot
        do i=1,8
          call computeleastsquaresregression(resbasecoef(:, i), &
&                                      intervalalphadot, &
&                                      ntimeintervalsspectral, &
&                                      dcdalphadot(i), coef0dot(i))
        end do
        a = sqrt(gammainf*pinfdim/rhoinfdim)
        tempd4 = 2*a*dcdalphadotd/lengthref
        tempd5 = 2*sum(dcdalphadot*machgrid*dcdalphadotd)/lengthref
        machgridd = sum(dcdalphadot*tempd4)
        ad = tempd5
        lengthrefd = lengthrefd - a*tempd5/lengthref
        dcdalphadotd = machgrid*tempd4
        temp2 = gammainf*pinfdim/rhoinfdim
        if (temp2 .eq. 0.0_8) then
          tempd6 = 0.0
        else
          tempd6 = ad/(2.0*sqrt(temp2)*rhoinfdim)
        end if
        gammainfd = pinfdim*tempd6
        pinfdimd = gammainf*tempd6
        rhoinfdimd = -(temp2*tempd6)
        resbasecoefd = 0.0_8
        do i=8,1,-1
          coef0dotd = 0.0_8
          call computeleastsquaresregression_b(resbasecoef(:, i), &
&                                        resbasecoefd(:, i), &
&                                        intervalalphadot, &
&                                        ntimeintervalsspectral, &
&                                        dcdalphadot(i), dcdalphadotd(i)&
&                                        , coef0dot(i), coef0dotd(i))
          dcdalphadotd(i) = 0.0_8
          coef0dotd(i) = 0.0_8
        end do
        basecoefd = 0.0_8
        do i=8,1,-1
          do sps=ntimeintervalsspectral,1,-1
            basecoefd(sps, i) = basecoefd(sps, i) + resbasecoefd(sps, i)
            dcdalphad(i) = dcdalphad(i) - intervalalpha(sps)*&
&             resbasecoefd(sps, i)
            coef0d(i) = coef0d(i) - resbasecoefd(sps, i)
            resbasecoefd(sps, i) = 0.0_8
          end do
        end do
        do i=8,1,-1
          call computeleastsquaresregression_b(basecoef(:, i), basecoefd&
&                                        (:, i), intervalalpha, &
&                                        ntimeintervalsspectral, &
&                                        dcdalpha(i), dcdalphad(i), &
&                                        coef0(i), coef0d(i))
          dcdalphad(i) = 0.0_8
          coef0d(i) = 0.0_8
        end do
        factmomentd = 0.0_8
        factd = 0.0_8
        do sps=ntimeintervalsspectral,1,-1
          momentd(3, sps) = momentd(3, sps) + factmoment*basecoefd(sps, &
&           8)
          factmomentd = factmomentd + moment(3, sps)*basecoefd(sps, 8)
          basecoefd(sps, 8) = 0.0_8
          momentd(2, sps) = momentd(2, sps) + factmoment*basecoefd(sps, &
&           7)
          factmomentd = factmomentd + moment(2, sps)*basecoefd(sps, 7)
          basecoefd(sps, 7) = 0.0_8
          momentd(1, sps) = momentd(1, sps) + factmoment*basecoefd(sps, &
&           6)
          factmomentd = factmomentd + moment(1, sps)*basecoefd(sps, 6)
          basecoefd(sps, 6) = 0.0_8
          forced(3, sps) = forced(3, sps) + fact*basecoefd(sps, 5)
          factd = factd + force(3, sps)*basecoefd(sps, 5)
          basecoefd(sps, 5) = 0.0_8
          forced(2, sps) = forced(2, sps) + fact*basecoefd(sps, 4)
          factd = factd + force(2, sps)*basecoefd(sps, 4)
          basecoefd(sps, 4) = 0.0_8
          forced(1, sps) = forced(1, sps) + fact*basecoefd(sps, 3)
          factd = factd + force(1, sps)*basecoefd(sps, 3)
          basecoefd(sps, 3) = 0.0_8
          tempd2 = fact*basecoefd(sps, 2)
          factd = factd + (force(1, sps)*dragdirection(1)+force(2, sps)*&
&           dragdirection(2)+force(3, sps)*dragdirection(3))*basecoefd(&
&           sps, 2)
          forced(1, sps) = forced(1, sps) + dragdirection(1)*tempd2
          dragdirectiond(1) = dragdirectiond(1) + force(1, sps)*tempd2
          forced(2, sps) = forced(2, sps) + dragdirection(2)*tempd2
          dragdirectiond(2) = dragdirectiond(2) + force(2, sps)*tempd2
          forced(3, sps) = forced(3, sps) + dragdirection(3)*tempd2
          dragdirectiond(3) = dragdirectiond(3) + force(3, sps)*tempd2
          basecoefd(sps, 2) = 0.0_8
          tempd3 = fact*basecoefd(sps, 1)
          factd = factd + (force(1, sps)*liftdirection(1)+force(2, sps)*&
&           liftdirection(2)+force(3, sps)*liftdirection(3))*basecoefd(&
&           sps, 1)
          forced(1, sps) = forced(1, sps) + liftdirection(1)*tempd3
          liftdirectiond(1) = liftdirectiond(1) + force(1, sps)*tempd3
          forced(2, sps) = forced(2, sps) + liftdirection(2)*tempd3
          liftdirectiond(2) = liftdirectiond(2) + force(2, sps)*tempd3
          forced(3, sps) = forced(3, sps) + liftdirection(3)*tempd3
          liftdirectiond(3) = liftdirectiond(3) + force(3, sps)*tempd3
          basecoefd(sps, 1) = 0.0_8
        end do
      else
        gammainfd = 0.0_8
        rhoinfdimd = 0.0_8
        pinfdimd = 0.0_8
        machgridd = 0.0_8
        factmomentd = 0.0_8
        factd = 0.0_8
      end if
      tempd = factmomentd/(lref*lengthref)
      factd = factd + tempd
      lengthrefd = lengthrefd - fact*tempd/lengthref
      temp1 = machcoef**2*scaledim
      temp0 = surfaceref*lref**2
      temp = temp0*gammainf*pinf
      tempd0 = -(two*factd/(temp**2*temp1**2))
      tempd1 = temp1*temp0*tempd0
      gammainfd = gammainfd + pinf*tempd1
      machcoefd = scaledim*temp*2*machcoef*tempd0
      scaledimd = temp*machcoef**2*tempd0
      pinfd = gammainf*tempd1 - pref*scaledimd/pinf**2
      prefd = scaledimd/pinf
    end if
  end subroutine computetsderivatives_b
!  differentiation of computeleastsquaresregression in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: m y b
!   with respect to varying inputs: y
  subroutine computeleastsquaresregression_b(y, yd, x, npts, m, md0, b, &
&   bd)
!
!      ******************************************************************
!      *                                                                *
!      * computes the slope of best fit for a set of x,y data of length *
!      * npts                                                           *
!      *                                                                *
!      ******************************************************************
!
    use constants
    implicit none
!subroutine arguments 
    integer(kind=inttype) :: npts
    real(kind=realtype), dimension(npts) :: x, y
    real(kind=realtype), dimension(npts) :: yd
    real(kind=realtype) :: m, b
    real(kind=realtype) :: md0, bd
!local variables
    real(kind=realtype) :: sumx, sumy, sumx2, sumxy
    real(kind=realtype) :: sumyd, sumxyd
    integer(kind=inttype) :: i
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
!begin execution
    sumx = 0.0
    sumx2 = 0.0
    do i=1,npts
      sumx = sumx + x(i)
      sumx2 = sumx2 + x(i)*x(i)
    end do
    tempd0 = md0/(npts*sumx2-sumx**2)
    tempd = bd/(npts*sumx2-sumx**2)
    sumyd = sumx2*tempd - sumx*tempd0
    sumxyd = npts*tempd0 - sumx*tempd
    do i=npts,1,-1
      yd(i) = yd(i) + sumyd + x(i)*sumxyd
    end do
  end subroutine computeleastsquaresregression_b
  subroutine computetsderivatives(force, moment, liftindex, coef0, &
&   dcdalpha, dcdalphadot, dcdq, dcdqdot)
!
!     ******************************************************************
!     *                                                                *
!     * computes the stability derivatives based on the time spectral  *
!     * solution of a given mesh. takes in the force coefficients at   *
!     * all time instantces and computes the agregate parameters       *
!     *                                                                *
!     ******************************************************************
!
    use constants
    use communication
    use inputphysics
    use inputtimespectral
    use inputtsstabderiv
    use flowvarrefstate
    use monitor
    use section
    use inputmotion
    implicit none
!
!     subroutine arguments.
!
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype), dimension(8) :: dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
    real(kind=realtype), dimension(8) :: coef0
    integer(kind=inttype) :: liftindex
! working variables
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(8) :: coef0dot
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   resbasecoef
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalalpha, intervalalphadot
    real(kind=realtype), dimension(ntimeintervalsspectral) :: &
&   intervalmach, intervalmachdot
    real(kind=realtype), dimension(nsections) :: t
    real(kind=realtype) :: alpha, beta
    integer(kind=inttype) :: i, sps, nn
!speed of sound: for normalization of q derivatives
    real(kind=realtype) :: a
    real(kind=realtype) :: scaledim, fact, factmoment
! functions
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphix, &
&   dphiy, dphiz
    real(kind=realtype), dimension(ntimeintervalsspectral) :: dphixdot, &
&   dphiydot, dphizdot
    real(kind=realtype) :: derivativerigidrotangle, &
&   secondderivativerigidrotangle
    intrinsic sqrt
    real(kind=realtype) :: arg1
    scaledim = pref/pinf
    fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
    factmoment = fact/(lengthref*lref)
    call getdirangle(veldirfreestream, liftdirection, liftindex, &
&                 alpha, beta)
    if (tsqmode) then
      print*, &
&     'ts q mode code needs to be updated in computetsderivatives!'
      stop
! !q is pitch
! do sps =1,ntimeintervalsspectral
!    !compute the time of this intervavc
!    t = timeunsteadyrestart
!    if(equationmode == timespectral) then
!       do nn=1,nsections
!          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod &
!               /         (ntimeintervalsspectral*1.0)
!       enddo
!    endif
!    ! compute the time derivative of the rotation angles around the
!    ! z-axis. i.e. compute q
!    dphiz(sps) = derivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
!    ! add in q_dot computation
!    dphizdot(sps) = secondderivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
! end do
! !now compute dcl/dq
! do i =1,8
!    call computeleastsquaresregression(basecoef(:,i),dphiz,ntimeintervalsspectral,dcdq(i),coef0(i))
! end do
! ! now subtract off estimated cl,cmz and use remainder to compute 
! ! clqdot and cmzqdot.
! do i = 1,8
!    do sps = 1,ntimeintervalsspectral
!       resbasecoef(sps,i) = basecoef(sps,i)-(dcdq(i)*dphiz(sps)+coef0(i))
!    enddo
! enddo
! !now normalize the results...
! a  = sqrt(gammainf*pinfdim/rhoinfdim)
! dcdq = dcdq*timeref*2*(machgrid*a)/lengthref
! !now compute dcl/dpdot
! do i = 1,8
!    call computeleastsquaresregression(resbasecoef(:,i),dphizdot,ntimeintervalsspectral,dcdqdot(i),coef0dot(i))
! enddo
    else if (tsalphamode) then
      do sps=1,ntimeintervalsspectral
!compute the time of this interval
        t = timeunsteadyrestart
        if (equationmode .eq. timespectral) then
          do nn=1,nsections
            t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&             ntimeintervalsspectral*1.0)
          end do
        end if
        intervalalpha(sps) = tsalpha(degreepolalpha, coefpolalpha, &
&         degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        intervalalphadot(sps) = tsalphadot(degreepolalpha, coefpolalpha&
&         , degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        arg1 = alpha + intervalalpha(sps)
        call getdirangle(veldirfreestream, liftdirection, liftindex, &
&                     arg1, beta)
        basecoef(sps, 1) = fact*(force(1, sps)*liftdirection(1)+force(2&
&         , sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
        basecoef(sps, 2) = fact*(force(1, sps)*dragdirection(1)+force(2&
&         , sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
        basecoef(sps, 3) = force(1, sps)*fact
        basecoef(sps, 4) = force(2, sps)*fact
        basecoef(sps, 5) = force(3, sps)*fact
        basecoef(sps, 6) = moment(1, sps)*factmoment
        basecoef(sps, 7) = moment(2, sps)*factmoment
        basecoef(sps, 8) = moment(3, sps)*factmoment
      end do
!now compute dcl/dalpha
      do i=1,8
        call computeleastsquaresregression(basecoef(:, i), intervalalpha&
&                                    , ntimeintervalsspectral, dcdalpha(&
&                                    i), coef0(i))
      end do
! now subtract off estimated cl,cmz and use remainder to compute 
! clalphadot and cmzalphadot.
      do i=1,8
        do sps=1,ntimeintervalsspectral
          resbasecoef(sps, i) = basecoef(sps, i) - (dcdalpha(i)*&
&           intervalalpha(sps)+coef0(i))
        end do
      end do
!now compute dci/dalphadot
      do i=1,8
        call computeleastsquaresregression(resbasecoef(:, i), &
&                                    intervalalphadot, &
&                                    ntimeintervalsspectral, dcdalphadot&
&                                    (i), coef0dot(i))
      end do
      a = sqrt(gammainf*pinfdim/rhoinfdim)
      dcdalphadot = dcdalphadot*2*(machgrid*a)/lengthref
    else
      call terminate('computetsderivatives', &
&              'not a valid stability motion')
    end if
  end subroutine computetsderivatives
  function tsalpha(degreepolalpha, coefpolalpha, degreefouralpha, &
&   omegafouralpha, coscoeffouralpha, sincoeffouralpha, t)
!
!      ******************************************************************
!      *                                                                *
!      * tsalpha computes the angle of attack for a given time interval *
!      * in a time spectral solution.                                   *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsalpha
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolalpha
    integer(kind=inttype), intent(in) :: degreefouralpha
    real(kind=realtype), intent(in) :: omegafouralpha, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolalpha
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffouralpha
    real(kind=realtype), dimension(*), intent(in) :: sincoeffouralpha
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: alpha, val
    intrinsic cos
    intrinsic sin
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsalpha = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      alpha = coefpolalpha(0)
      do nn=1,degreepolalpha
        alpha = alpha + coefpolalpha(nn)*t**nn
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      alpha = alpha + coscoeffouralpha(0)
      do nn=1,degreefouralpha
        val = nn*omegafouralpha*t
        alpha = alpha + coscoeffouralpha(nn)*cos(val) + sincoeffouralpha&
&         (nn)*sin(val)
      end do
!print *,'intsalpha',alpha,nn,val,t
! set tsalpha to phi.
      tsalpha = alpha
    end if
  end function tsalpha
  function tsalphadot(degreepolalpha, coefpolalpha, degreefouralpha, &
&   omegafouralpha, coscoeffouralpha, sincoeffouralpha, t)
!
!      ******************************************************************
!      *                                                                *
!      * tsalpha computes the angle of attack for a given time interval *
!      * in a time spectral solution.                                   *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use inputphysics, only : equationmode
    implicit none
!
!      function type
!
    real(kind=realtype) :: tsalphadot
!
!      function arguments.
!
    integer(kind=inttype), intent(in) :: degreepolalpha
    integer(kind=inttype), intent(in) :: degreefouralpha
    real(kind=realtype), intent(in) :: omegafouralpha, t
    real(kind=realtype), dimension(0:*), intent(in) :: coefpolalpha
    real(kind=realtype), dimension(0:*), intent(in) :: coscoeffouralpha
    real(kind=realtype), dimension(*), intent(in) :: sincoeffouralpha
!
!      local variables.
!
    integer(kind=inttype) :: nn
    real(kind=realtype) :: alphadot, val
    intrinsic sin
    intrinsic cos
! return immediately if this is a steady computation.
    if (equationmode .eq. steady) then
      tsalphadot = zero
      return
    else
! compute the polynomial contribution. if no polynomial was
! specified, the value of index 0 is set to zero automatically.
      alphadot = zero
      do nn=1,degreepolalpha
        alphadot = alphadot + nn*coefpolalpha(nn)*t**(nn-1)
      end do
! compute the fourier contribution. again the cosine coefficient
! of index 0 is defaulted to zero if not specified.
      do nn=1,degreefouralpha
        val = nn*omegafouralpha
        alphadot = alphadot - val*coscoeffouralpha(nn)*sin(val*t) + val*&
&         sincoeffouralpha(nn)*cos(val*t)
      end do
! set tsalpha to phi.
      tsalphadot = alphadot
    end if
  end function tsalphadot
  subroutine terminate(routinename, errormessage)
!
!      ******************************************************************
!      *                                                                *
!      * terminate writes an error message to standard output and       *
!      * terminates the execution of the program.                       *
!      *                                                                *
!      ******************************************************************
!
    use constants
    use communication, only : sumb_comm_world, myid
    implicit none
!
!      subroutine arguments
!
    character(len=*), intent(in) :: routinename
    character(len=*), intent(in) :: errormessage
  end subroutine terminate
  subroutine computeleastsquaresregression(y, x, npts, m, b)
!
!      ******************************************************************
!      *                                                                *
!      * computes the slope of best fit for a set of x,y data of length *
!      * npts                                                           *
!      *                                                                *
!      ******************************************************************
!
    use constants
    implicit none
!subroutine arguments 
    integer(kind=inttype) :: npts
    real(kind=realtype), dimension(npts) :: x, y
    real(kind=realtype) :: m, b
!local variables
    real(kind=realtype) :: sumx, sumy, sumx2, sumxy
    integer(kind=inttype) :: i
!begin execution
    sumx = 0.0
    sumy = 0.0
    sumx2 = 0.0
    sumxy = 0.0
    do i=1,npts
      sumx = sumx + x(i)
      sumy = sumy + y(i)
      sumx2 = sumx2 + x(i)*x(i)
      sumxy = sumxy + x(i)*y(i)
    end do
    m = (npts*sumxy-sumy*sumx)/(npts*sumx2-sumx**2)
    b = (sumy*sumx2-sumx*sumxy)/(npts*sumx2-sumx**2)
  end subroutine computeleastsquaresregression
end module utils_b

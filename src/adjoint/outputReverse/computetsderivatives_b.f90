!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of computetsderivatives in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: lengthref dragdirection liftdirection
!                moment dcdalphadot coef0 force dcdalpha
!   with respect to varying inputs: gammainf pinf rhoinfdim pinfdim
!                pref machgrid lengthref machcoef dragdirection
!                liftdirection moment force
!
!     ******************************************************************
!     *                                                                *
!     * file:          computetsderivatives.f90                        *
!     * author:        c.a.(sandy) mader, g. kenway                    *
!     * starting date: 11-25-2009                                      *
!     * last modified: 11-26-2009                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine computetsderivatives_b(force, forced, moment, momentd, &
& liftindex, coef0, coef0d, dcdalpha, dcdalphad, dcdalphadot, &
& dcdalphadotd, dcdq, dcdqdot)
!
!     ******************************************************************
!     *                                                                *
!     * computes the stability derivatives based on the time spectral  *
!     * solution of a given mesh. takes in the force coefficients at   *
!     * all time instantces and computes the agregate parameters       *
!     *                                                                *
!     ******************************************************************
!
  use constants
  use communication
  use inputphysics
  use inputtimespectral
  use inputtsstabderiv
  use flowvarrefstate
  use monitor
  use section
  use inputmotion
  use utils_b, only : tsalpha, tsalphadot, terminate
  implicit none
!
!     subroutine arguments.
!
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
& moment
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced, &
& momentd
  real(kind=realtype), dimension(8) :: dcdq, dcdqdot
  real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
  real(kind=realtype), dimension(8) :: dcdalphad, dcdalphadotd
  real(kind=realtype), dimension(8) :: coef0
  real(kind=realtype), dimension(8) :: coef0d
  integer(kind=inttype) :: liftindex
! working variables
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: basecoef
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: basecoefd
  real(kind=realtype), dimension(8) :: coef0dot
  real(kind=realtype), dimension(8) :: coef0dotd
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
& resbasecoef
  real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
& resbasecoefd
  real(kind=realtype), dimension(ntimeintervalsspectral) :: &
& intervalalpha, intervalalphadot
  real(kind=realtype), dimension(ntimeintervalsspectral) :: intervalmach&
& , intervalmachdot
  real(kind=realtype), dimension(nsections) :: t
  real(kind=realtype) :: alpha, beta
  integer(kind=inttype) :: i, sps, nn
!speed of sound: for normalization of q derivatives
  real(kind=realtype) :: a
  real(kind=realtype) :: ad
  real(kind=realtype) :: scaledim, fact, factmoment
  real(kind=realtype) :: scaledimd, factd, factmomentd
! functions
  real(kind=realtype), dimension(ntimeintervalsspectral) :: dphix, dphiy&
& , dphiz
  real(kind=realtype), dimension(ntimeintervalsspectral) :: dphixdot, &
& dphiydot, dphizdot
  real(kind=realtype) :: derivativerigidrotangle, &
& secondderivativerigidrotangle
  intrinsic sqrt
  real(kind=realtype) :: arg1
  real(kind=realtype) :: temp2
  real(kind=realtype) :: temp1
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4(8)
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: temp
  scaledim = pref/pinf
  fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
  factmoment = fact/(lengthref*lref)
  if (tsqmode) then
    stop
! !q is pitch
! do sps =1,ntimeintervalsspectral
!    !compute the time of this intervavc
!    t = timeunsteadyrestart
!    if(equationmode == timespectral) then
!       do nn=1,nsections
!          t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod &
!               /         (ntimeintervalsspectral*1.0)
!       enddo
!    endif
!    ! compute the time derivative of the rotation angles around the
!    ! z-axis. i.e. compute q
!    dphiz(sps) = derivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
!    ! add in q_dot computation
!    dphizdot(sps) = secondderivativerigidrotangle(degreepolzrot,   &
!         coefpolzrot,     &
!         degreefourzrot,  &
!         omegafourzrot,   &
!         coscoeffourzrot, &
!         sincoeffourzrot, t)
! end do
! !now compute dcl/dq
! do i =1,8
!    call computeleastsquaresregression(basecoef(:,i),dphiz,ntimeintervalsspectral,dcdq(i),coef0(i))
! end do
! ! now subtract off estimated cl,cmz and use remainder to compute 
! ! clqdot and cmzqdot.
! do i = 1,8
!    do sps = 1,ntimeintervalsspectral
!       resbasecoef(sps,i) = basecoef(sps,i)-(dcdq(i)*dphiz(sps)+coef0(i))
!    enddo
! enddo
! !now normalize the results...
! a  = sqrt(gammainf*pinfdim/rhoinfdim)
! dcdq = dcdq*timeref*2*(machgrid*a)/lengthref
! !now compute dcl/dpdot
! do i = 1,8
!    call computeleastsquaresregression(resbasecoef(:,i),dphizdot,ntimeintervalsspectral,dcdqdot(i),coef0dot(i))
! enddo
  else
    if (tsalphamode) then
      do sps=1,ntimeintervalsspectral
!compute the time of this interval
        t = timeunsteadyrestart
        if (equationmode .eq. timespectral) then
          do nn=1,nsections
            t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
&             ntimeintervalsspectral*1.0)
          end do
        end if
        intervalalpha(sps) = tsalpha(degreepolalpha, coefpolalpha, &
&         degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        intervalalphadot(sps) = tsalphadot(degreepolalpha, coefpolalpha&
&         , degreefouralpha, omegafouralpha, coscoeffouralpha, &
&         sincoeffouralpha, t(1))
        basecoef(sps, 1) = fact*(force(1, sps)*liftdirection(1)+force(2&
&         , sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
        basecoef(sps, 2) = fact*(force(1, sps)*dragdirection(1)+force(2&
&         , sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
        basecoef(sps, 3) = force(1, sps)*fact
        basecoef(sps, 4) = force(2, sps)*fact
        basecoef(sps, 5) = force(3, sps)*fact
        basecoef(sps, 6) = moment(1, sps)*factmoment
        basecoef(sps, 7) = moment(2, sps)*factmoment
        basecoef(sps, 8) = moment(3, sps)*factmoment
      end do
!now compute dcl/dalpha
      do i=1,8
        call computeleastsquaresregression(basecoef(:, i), &
&                                       intervalalpha, &
&                                       ntimeintervalsspectral, dcdalpha&
&                                       (i), coef0(i))
      end do
! now subtract off estimated cl,cmz and use remainder to compute 
! clalphadot and cmzalphadot.
      do i=1,8
        do sps=1,ntimeintervalsspectral
          resbasecoef(sps, i) = basecoef(sps, i) - (dcdalpha(i)*&
&           intervalalpha(sps)+coef0(i))
        end do
      end do
!now compute dci/dalphadot
      do i=1,8
        call computeleastsquaresregression(resbasecoef(:, i), &
&                                       intervalalphadot, &
&                                       ntimeintervalsspectral, &
&                                       dcdalphadot(i), coef0dot(i))
      end do
      a = sqrt(gammainf*pinfdim/rhoinfdim)
      tempd4 = 2*a*dcdalphadotd/lengthref
      tempd5 = 2*sum(dcdalphadot*machgrid*dcdalphadotd)/lengthref
      machgridd = sum(dcdalphadot*tempd4)
      ad = tempd5
      lengthrefd = lengthrefd - a*tempd5/lengthref
      dcdalphadotd = machgrid*tempd4
      temp2 = gammainf*pinfdim/rhoinfdim
      if (temp2 .eq. 0.0_8) then
        tempd6 = 0.0
      else
        tempd6 = ad/(2.0*sqrt(temp2)*rhoinfdim)
      end if
      gammainfd = pinfdim*tempd6
      pinfdimd = gammainf*tempd6
      rhoinfdimd = -(temp2*tempd6)
      resbasecoefd = 0.0_8
      do i=8,1,-1
        coef0dotd = 0.0_8
        call computeleastsquaresregression_b(resbasecoef(:, i), &
&                                      resbasecoefd(:, i), &
&                                      intervalalphadot, &
&                                      ntimeintervalsspectral, &
&                                      dcdalphadot(i), dcdalphadotd(i), &
&                                      coef0dot(i), coef0dotd(i))
        dcdalphadotd(i) = 0.0_8
        coef0dotd(i) = 0.0_8
      end do
      basecoefd = 0.0_8
      do i=8,1,-1
        do sps=ntimeintervalsspectral,1,-1
          basecoefd(sps, i) = basecoefd(sps, i) + resbasecoefd(sps, i)
          dcdalphad(i) = dcdalphad(i) - intervalalpha(sps)*resbasecoefd(&
&           sps, i)
          coef0d(i) = coef0d(i) - resbasecoefd(sps, i)
          resbasecoefd(sps, i) = 0.0_8
        end do
      end do
      do i=8,1,-1
        call computeleastsquaresregression_b(basecoef(:, i), basecoefd(:&
&                                      , i), intervalalpha, &
&                                      ntimeintervalsspectral, dcdalpha(&
&                                      i), dcdalphad(i), coef0(i), &
&                                      coef0d(i))
        dcdalphad(i) = 0.0_8
        coef0d(i) = 0.0_8
      end do
      factmomentd = 0.0_8
      factd = 0.0_8
      do sps=ntimeintervalsspectral,1,-1
        momentd(3, sps) = momentd(3, sps) + factmoment*basecoefd(sps, 8)
        factmomentd = factmomentd + moment(3, sps)*basecoefd(sps, 8)
        basecoefd(sps, 8) = 0.0_8
        momentd(2, sps) = momentd(2, sps) + factmoment*basecoefd(sps, 7)
        factmomentd = factmomentd + moment(2, sps)*basecoefd(sps, 7)
        basecoefd(sps, 7) = 0.0_8
        momentd(1, sps) = momentd(1, sps) + factmoment*basecoefd(sps, 6)
        factmomentd = factmomentd + moment(1, sps)*basecoefd(sps, 6)
        basecoefd(sps, 6) = 0.0_8
        forced(3, sps) = forced(3, sps) + fact*basecoefd(sps, 5)
        factd = factd + force(3, sps)*basecoefd(sps, 5)
        basecoefd(sps, 5) = 0.0_8
        forced(2, sps) = forced(2, sps) + fact*basecoefd(sps, 4)
        factd = factd + force(2, sps)*basecoefd(sps, 4)
        basecoefd(sps, 4) = 0.0_8
        forced(1, sps) = forced(1, sps) + fact*basecoefd(sps, 3)
        factd = factd + force(1, sps)*basecoefd(sps, 3)
        basecoefd(sps, 3) = 0.0_8
        tempd2 = fact*basecoefd(sps, 2)
        factd = factd + (force(1, sps)*dragdirection(1)+force(2, sps)*&
&         dragdirection(2)+force(3, sps)*dragdirection(3))*basecoefd(sps&
&         , 2)
        forced(1, sps) = forced(1, sps) + dragdirection(1)*tempd2
        dragdirectiond(1) = dragdirectiond(1) + force(1, sps)*tempd2
        forced(2, sps) = forced(2, sps) + dragdirection(2)*tempd2
        dragdirectiond(2) = dragdirectiond(2) + force(2, sps)*tempd2
        forced(3, sps) = forced(3, sps) + dragdirection(3)*tempd2
        dragdirectiond(3) = dragdirectiond(3) + force(3, sps)*tempd2
        basecoefd(sps, 2) = 0.0_8
        tempd3 = fact*basecoefd(sps, 1)
        factd = factd + (force(1, sps)*liftdirection(1)+force(2, sps)*&
&         liftdirection(2)+force(3, sps)*liftdirection(3))*basecoefd(sps&
&         , 1)
        forced(1, sps) = forced(1, sps) + liftdirection(1)*tempd3
        liftdirectiond(1) = liftdirectiond(1) + force(1, sps)*tempd3
        forced(2, sps) = forced(2, sps) + liftdirection(2)*tempd3
        liftdirectiond(2) = liftdirectiond(2) + force(2, sps)*tempd3
        forced(3, sps) = forced(3, sps) + liftdirection(3)*tempd3
        liftdirectiond(3) = liftdirectiond(3) + force(3, sps)*tempd3
        basecoefd(sps, 1) = 0.0_8
      end do
    else
      gammainfd = 0.0_8
      rhoinfdimd = 0.0_8
      pinfdimd = 0.0_8
      machgridd = 0.0_8
      factmomentd = 0.0_8
      factd = 0.0_8
    end if
    tempd = factmomentd/(lref*lengthref)
    factd = factd + tempd
    lengthrefd = lengthrefd - fact*tempd/lengthref
    temp1 = machcoef**2*scaledim
    temp0 = surfaceref*lref**2
    temp = temp0*gammainf*pinf
    tempd0 = -(two*factd/(temp**2*temp1**2))
    tempd1 = temp1*temp0*tempd0
    gammainfd = gammainfd + pinf*tempd1
    machcoefd = scaledim*temp*2*machcoef*tempd0
    scaledimd = temp*machcoef**2*tempd0
    pinfd = gammainf*tempd1 - pref*scaledimd/pinf**2
    prefd = scaledimd/pinf
  end if
end subroutine computetsderivatives_b

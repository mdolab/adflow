!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module adjointextra_b
  implicit none

contains
!  differentiation of block_res in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(flowdoms.x) *(flowdoms.w)
!                *(flowdoms.dw) *(*bcdata.fv) *(*bcdata.fp) *(*bcdata.area)
!                *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2 *pp3
!                *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2 *ww3
!                funcvalues
!   with respect to varying inputs: *(flowdoms.x) *(flowdoms.w)
!                *(flowdoms.dw) *(*bcdata.fv) *(*bcdata.fp) *(*bcdata.area)
!                *xsurf mach alpha machgrid lengthref beta machcoef
!                pointref tinfdim rhoinfdim pinfdim *xx *rev0 *rev1
!                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
!                *rlv3 *ssi *ww0 *ww1 *ww2 *ww3 funcvalues
!   rw status of diff variables: *(flowdoms.x):in-out *(flowdoms.vol):(loc)
!                *(flowdoms.w):in-out *(flowdoms.dw):in-out *rev:(loc)
!                *aa:(loc) *bvtj1:(loc) *bvtj2:(loc) *wx:(loc)
!                *wy:(loc) *wz:(loc) *p:(loc) *rlv:(loc) *qx:(loc)
!                *qy:(loc) *qz:(loc) *scratch:(loc) *bvtk1:(loc)
!                *bvtk2:(loc) *ux:(loc) *uy:(loc) *uz:(loc) *d2wall:(loc)
!                *si:(loc) *sj:(loc) *sk:(loc) *bvti1:(loc) *bvti2:(loc)
!                *vx:(loc) *vy:(loc) *vz:(loc) *fw:(loc) *(*viscsubface.tau):(loc)
!                *(*bcdata.norm):(loc) *(*bcdata.fv):in-out *(*bcdata.fp):in-out
!                *(*bcdata.area):in-out *radi:(loc) *radj:(loc)
!                *radk:(loc) *xsurf:out mach:out alpha:out veldirfreestream:(loc)
!                machgrid:out lengthref:out beta:out machcoef:out
!                dragdirection:(loc) liftdirection:(loc) pointref:out
!                tinfdim:out pinf:(loc) timeref:(loc) rhoinf:(loc)
!                muref:(loc) rhoinfdim:out tref:(loc) winf:(loc)
!                muinf:(loc) uinf:(loc) pinfcorr:(loc) rgas:(loc)
!                muinfdim:(loc) pinfdim:out pref:(loc) rhoref:(loc)
!                *xx:in-out *rev0:in-out *rev1:in-out *rev2:in-out
!                *rev3:in-out *pp0:in-out *pp1:in-out *pp2:in-out
!                *pp3:in-out *rlv0:in-out *rlv1:in-out *rlv2:in-out
!                *rlv3:in-out *ssi:in-out *ww0:in-out *ww1:in-out
!                *ww2:in-out *ww3:in-out funcvalues:in-zero
!   plus diff mem management of: flowdoms.x:in flowdoms.vol:in
!                flowdoms.w:in flowdoms.dw:in rev:in aa:in bvtj1:in
!                bvtj2:in wx:in wy:in wz:in p:in rlv:in qx:in qy:in
!                qz:in scratch:in bvtk1:in bvtk2:in ux:in uy:in
!                uz:in d2wall:in si:in sj:in sk:in bvti1:in bvti2:in
!                vx:in vy:in vz:in fw:in viscsubface:in *viscsubface.tau:in
!                bcdata:in *bcdata.norm:in *bcdata.fv:in *bcdata.fp:in
!                *bcdata.area:in radi:in radj:in radk:in xsurf:in
!                xx:in rev0:in rev1:in rev2:in rev3:in pp0:in pp1:in
!                pp2:in pp3:in rlv0:in rlv1:in rlv2:in rlv3:in
!                ssi:in ww0:in ww1:in ww2:in ww3:in
! this is a super-combined function that combines the original
! functionality of: 
! pressure computation
! timestep
! applyallbcs
! initres
! residual 
! the real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the nominal
! block/sps loop is outside the calculation. this routine is suitable
! for forward mode ad with tapenade
  subroutine block_res_b(nn, sps, usespatial, frozenturb)
! note that we import all the pointers from block res that will be
! used in any routine. otherwise, tapenade gives warnings about
! saving a hidden variable. 
    use constants
    use block, only : flowdoms, flowdomsd
    use bcroutines_b
    use bcpointers_b
    use blockpointers, only : w, wd, dw, dwd, x, xd, vol, vold, il, jl&
&   , kl, sectionid, wold, volold, bcdata, bcdatad, si, sid, sj, sjd, sk&
&   , skd, sfacei, sfacej, sfacek, rlv, rlvd, gamma, p, pd, rev, revd, &
&   bmtj1, bmtj2, scratch, scratchd, bmtk2, bmtk1, fw, fwd, aa, aad, &
&   d2wall, d2walld, bmti1, bmti2, s
    use flowvarrefstate
    use inputphysics
    use inputiteration
    use inputtimespectral
    use section
    use monitor
    use iteration
    use diffsizes
    use costfunctions
    use initializeflow_b, only : referencestate, referencestate_b
    use walldistance_b, only : updatewalldistancesquickly, &
&   updatewalldistancesquickly_b, xsurf, xsurfd
    use inputdiscretization
    use sa_b
    use inputunsteady
    use turbbcroutines_b
    use turbutils_b
    use utils_b, only : terminate
    use flowutils_b, only : adjustinflowangle, adjustinflowangle_b, &
&   computepressuresimple, computepressuresimple_b, computelamviscosity,&
&   computelamviscosity_b
    use solverutils_b, only : gridvelocitiesfinelevel_block, &
&   normalvelocities_block, slipvelocitiesfinelevel_block, &
&   timestep_block, timestep_block_b
    use residuals_b, only : residual_block, residual_block_b
    use surfaceintegrations_b, only : forcesandmoments, &
&   forcesandmoments_b
    implicit none
! input arguments:
    integer(kind=inttype), intent(in) :: nn, sps
    logical, intent(in) :: usespatial, frozenturb
! output variables
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced&
&   , momentd
    real(kind=realtype) :: sepsensor, cavitation, sepsensoravg(3)
    real(kind=realtype) :: sepsensord, cavitationd, sepsensoravgd(3)
! working variables
    real(kind=realtype) :: gm1, v2, fact, tmp
    real(kind=realtype) :: tmpd
    integer(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj, m
    integer(kind=inttype) :: nstate
    real(kind=realtype), dimension(nsections) :: t
    logical :: useoldcoor
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype) :: yplusmax, oneoverdt
    real(kind=realtype) :: oneoverdtd
    real(kind=realtype) :: localvalues(nlocalvalues)
    real(kind=realtype) :: localvaluesd(nlocalvalues)
    integer :: branch
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    integer :: ii3
    integer :: ii2
    integer :: ii1
    real(kind=realtype) :: temp
! setup number of state variable based on turbulence assumption
    if (frozenturb) then
      nstate = nwf
    else
      nstate = nw
    end if
! set pointers to input/output variables
    wd => flowdomsd(nn, currentlevel, sps)%w
    w => flowdoms(nn, currentlevel, sps)%w
    dwd => flowdomsd(nn, 1, sps)%dw
    dw => flowdoms(nn, 1, sps)%dw
    xd => flowdomsd(nn, currentlevel, sps)%x
    x => flowdoms(nn, currentlevel, sps)%x
    vold => flowdomsd(nn, currentlevel, sps)%vol
    vol => flowdoms(nn, currentlevel, sps)%vol
! ------------------------------------------------
!        additional 'extra' components
! ------------------------------------------------ 
    call adjustinflowangle()
    call pushreal8(gammainf)
    call referencestate()
! ------------------------------------------------
!        additional spatial components
! ------------------------------------------------
    if (usespatial) then
      call volume_block()
      call metric_block()
      call boundarynormals()
      if (equations .eq. ransequations .and. useapproxwalldistance) then
        call updatewalldistancesquickly(nn, 1, sps)
        call pushcontrol2b(0)
      else
        call pushcontrol2b(1)
      end if
    else
      call pushcontrol2b(2)
    end if
! ------------------------------------------------
!        normal residual computation
! ------------------------------------------------
! compute the pressures
    call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call computepressuresimple(.true.)
! compute laminar/eddy viscosity if required
    call computelamviscosity(.true.)
    call computeeddyviscosity(.true.)
    call pushreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call pushreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call pushreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3))
    call pushreal8array(sface, size(sface, 1)*size(sface, 2))
    call pushreal8array(rlv3, size(rlv3, 1)*size(rlv3, 2))
    call pushreal8array(rlv2, size(rlv2, 1)*size(rlv2, 2))
    call pushreal8array(rlv1, size(rlv1, 1)*size(rlv1, 2))
    call pushreal8array(rlv0, size(rlv0, 1)*size(rlv0, 2))
    call pushreal8array(pp3, size(pp3, 1)*size(pp3, 2))
    call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call pushreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call pushreal8array(rev3, size(rev3, 1)*size(rev3, 2))
    call pushreal8array(rev2, size(rev2, 1)*size(rev2, 2))
    call pushreal8array(rev1, size(rev1, 1)*size(rev1, 2))
    call pushreal8array(rev0, size(rev0, 1)*size(rev0, 2))
    call pushreal8array(xx, size(xx, 1)*size(xx, 2)*size(xx, 3))
    call pushreal8array(gamma3, size(gamma3, 1)*size(gamma3, 2))
    call pushreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call pushreal8array(gamma1, size(gamma1, 1)*size(gamma1, 2))
    call pushreal8array(gamma0, size(gamma0, 1)*size(gamma0, 2))
    call pushreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk&
&                 , 4))
    call pushreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj&
&                 , 4))
    call pushreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si&
&                 , 4))
    call pushreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call pushreal8array(sfacek, size(sfacek, 1)*size(sfacek, 2)*size(&
&                 sfacek, 3))
    call pushreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma&
&                 , 3))
    call pushreal8array(sfacej, size(sfacej, 1)*size(sfacej, 2)*size(&
&                 sfacej, 3))
    call pushreal8array(sfacei, size(sfacei, 1)*size(sfacei, 2)*size(&
&                 sfacei, 3))
    call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call pushreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          call pushreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms(&
&                       ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, ii1&
&                       )%w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*size(&
&                       flowdoms(ii3, ii2, ii1)%w, 4))
        end do
      end do
    end do
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          call pushreal8array(flowdoms(ii3, ii2, ii1)%x, size(flowdoms(&
&                       ii3, ii2, ii1)%x, 1)*size(flowdoms(ii3, ii2, ii1&
&                       )%x, 2)*size(flowdoms(ii3, ii2, ii1)%x, 3)*size(&
&                       flowdoms(ii3, ii2, ii1)%x, 4))
        end do
      end do
    end do
    call applyallbc_block(.true.)
    if (equations .eq. ransequations) then
      call bcturbtreatment()
      do ii1=1,ntimeintervalsspectral
        do ii2=1,1
          do ii3=nn,nn
            call pushreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms&
&                         (ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, &
&                         ii1)%w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*&
&                         size(flowdoms(ii3, ii2, ii1)%w, 4))
          end do
        end do
      end do
      call applyallturbbcthisblock(.true.)
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
! compute skin_friction velocity (only for wall functions)
! #ifndef 1
!   call computeutau_block
! #endif
! compute time step and spectral radius
    call timestep_block(.false.)
spectralloop0:do sps2=1,ntimeintervalsspectral
      flowdoms(nn, 1, sps2)%dw(:, :, :, :) = zero
    end do spectralloop0
! -------------------------------
! compute turbulence residual for rans equations
    if (equations .eq. ransequations) then
! ! initialize only the turblent variables
! call unsteadyturbspectral_block(itu1, itu1, nn, sps)
      select case  (turbmodel) 
      case (spalartallmaras) 
        call pushreal8array(bmtj2, size(bmtj2, 1)*size(bmtj2, 2)*size(&
&                     bmtj2, 3)*size(bmtj2, 4))
        call pushreal8array(bmtj1, size(bmtj1, 1)*size(bmtj1, 2)*size(&
&                     bmtj1, 3)*size(bmtj1, 4))
        call pushreal8array(bmti2, size(bmti2, 1)*size(bmti2, 2)*size(&
&                     bmti2, 3)*size(bmti2, 4))
        call pushreal8array(bmti1, size(bmti1, 1)*size(bmti1, 2)*size(&
&                     bmti1, 3)*size(bmti1, 4))
        call pushreal8array(scratch, size(scratch, 1)*size(scratch, 2)*&
&                     size(scratch, 3)*size(scratch, 4))
        call pushreal8array(bmtk2, size(bmtk2, 1)*size(bmtk2, 2)*size(&
&                     bmtk2, 3)*size(bmtk2, 4))
        call pushreal8array(bmtk1, size(bmtk1, 1)*size(bmtk1, 2)*size(&
&                     bmtk1, 3)*size(bmtk1, 4))
        do ii1=1,ntimeintervalsspectral
          do ii2=1,1
            do ii3=nn,nn
              call pushreal8array(flowdoms(ii3, ii2, ii1)%dw, size(&
&                           flowdoms(ii3, ii2, ii1)%dw, 1)*size(flowdoms&
&                           (ii3, ii2, ii1)%dw, 2)*size(flowdoms(ii3, &
&                           ii2, ii1)%dw, 3)*size(flowdoms(ii3, ii2, ii1&
&                           )%dw, 4))
            end do
          end do
        end do
        call sa_block(.true.)
        call pushcontrol2b(0)
      case default
        call pushcontrol2b(1)
      end select
    else
      call pushcontrol2b(2)
    end if
! -------------------------------  
! next initialize residual for flow variables. the is the only place
! where there is an n^2 dependance. there are issues with
! initres. so only the necesary timespectral code has been copied
! here. see initres for more information and comments.
!call initres_block(1, nwf, nn, sps)
    if (equationmode .eq. steady) then
      dw(:, :, :, 1:nwf) = zero
      call pushcontrol2b(0)
    else if (equationmode .eq. timespectral) then
! zero dw on all spectral instances
spectralloop1:do sps2=1,ntimeintervalsspectral
        flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
      end do spectralloop1
spectralloop2:do sps2=1,ntimeintervalsspectral
        call pushinteger4(jj)
        jj = sectionid
timeloopfine:do mm=1,ntimeintervalsspectral
          call pushinteger4(ii)
          ii = 3*(mm-1)
varloopfine:do l=1,nwf
            if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
              if (l .eq. ivx) then
                call pushinteger4(ll)
                ll = 3*sps2 - 2
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              if (l .eq. ivy) then
                call pushinteger4(ll)
                ll = 3*sps2 - 1
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              if (l .eq. ivz) then
                call pushinteger4(ll)
                ll = 3*sps2
                call pushcontrol1b(1)
              else
                call pushcontrol1b(0)
              end if
              do k=2,kl
                do j=2,jl
                  do i=2,il
                    call pushreal8(tmp)
                    tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i&
&                     , j, k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, &
&                     1, mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
&                     flowdoms(nn, 1, mm)%w(i, j, k, ivz)
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%&
&                     vol(i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
                  end do
                end do
              end do
              call pushcontrol1b(1)
            else
              do k=2,kl
                do j=2,jl
                  do i=2,il
! this is: dw = dw + dscalar*vol*w
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
&                     flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, &
&                     mm)%w(i, j, k, l)
                  end do
                end do
              end do
              call pushcontrol1b(0)
            end if
          end do varloopfine
        end do timeloopfine
      end do spectralloop2
      call pushcontrol2b(1)
    else if (equationmode .eq. unsteady) then
! assume only md or bdf types
! store the inverse of the physical nondimensional
! time step a bit easier.
      oneoverdt = timeref/deltat
! ground level of the multigrid cycle. initialize the
! owned cells to the unsteady source term. first the
! term for the current time level. note that in w the
! velocities are stored and not the momentum variables.
! therefore the if-statement is present to correct this.
      do l=1,nw
        if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
! momentum variables.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)*w(i, j, k, irho)
              end do
            end do
          end do
          call pushcontrol1b(1)
        else
! non-momentum variables, for which the variable
! to be solved is stored; for the flow equations this
! is the conservative variable, for the turbulent
! equations the primitive variable.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)
              end do
            end do
          end do
          call pushcontrol1b(0)
        end if
      end do
! the terms from the older time levels. here the
! conservative variables are stored. in case of a
! deforming mesh, also the old volumes must be taken.
      if (deforming_grid) then
        call pushcontrol1b(1)
! mesh is deforming and thus the volumes can change.
! use the old volumes as well.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*volold(m, i, j, k)&
&                   *wold(m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      else
! rigid mesh. the volumes remain constant.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*vol(i, j, k)*wold(&
&                   m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
        call pushcontrol1b(0)
      end if
! multiply the time derivative by the inverse of the
! time step to obtain the true time derivative.
! this is done after the summation has been done, because
! otherwise you run into finite accuracy problems for
! very small time steps.
      do l=1,nw
        do k=2,kl
          do j=2,jl
            do i=2,il
              call pushreal8(flowdoms(nn, 1, sps)%dw(i, j, k, l))
              flowdoms(nn, 1, sps)%dw(i, j, k, l) = oneoverdt*flowdoms(&
&               nn, 1, sps)%dw(i, j, k, l)
            end do
          end do
        end do
      end do
      call pushcontrol2b(2)
    else
      call pushcontrol2b(3)
    end if
!  actual residual calc
    call pushreal8array(fw, size(fw, 1)*size(fw, 2)*size(fw, 3)*size(fw&
&                 , 4))
    call pushreal8array(aa, size(aa, 1)*size(aa, 2)*size(aa, 3))
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          call pushreal8array(flowdoms(ii3, ii2, ii1)%dw, size(flowdoms(&
&                       ii3, ii2, ii1)%dw, 1)*size(flowdoms(ii3, ii2, &
&                       ii1)%dw, 2)*size(flowdoms(ii3, ii2, ii1)%dw, 3)*&
&                       size(flowdoms(ii3, ii2, ii1)%dw, 4))
        end do
      end do
    end do
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          call pushreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms(&
&                       ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, ii1&
&                       )%w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*size(&
&                       flowdoms(ii3, ii2, ii1)%w, 4))
        end do
      end do
    end do
    call residual_block()
    localvalues = zero
    call pushreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call pushreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call pushreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call pushreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3))
    call pushreal8array(sface, size(sface, 1)*size(sface, 2))
    call pushreal8array(rlv3, size(rlv3, 1)*size(rlv3, 2))
    call pushreal8array(rlv2, size(rlv2, 1)*size(rlv2, 2))
    call pushreal8array(rlv1, size(rlv1, 1)*size(rlv1, 2))
    call pushreal8array(rlv0, size(rlv0, 1)*size(rlv0, 2))
    call pushreal8array(pp3, size(pp3, 1)*size(pp3, 2))
    call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call pushreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call pushreal8array(rev3, size(rev3, 1)*size(rev3, 2))
    call pushreal8array(rev2, size(rev2, 1)*size(rev2, 2))
    call pushreal8array(rev1, size(rev1, 1)*size(rev1, 2))
    call pushreal8array(rev0, size(rev0, 1)*size(rev0, 2))
    call pushreal8array(xx, size(xx, 1)*size(xx, 2)*size(xx, 3))
    call pushreal8array(gamma3, size(gamma3, 1)*size(gamma3, 2))
    call pushreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call pushreal8array(gamma1, size(gamma1, 1)*size(gamma1, 2))
    call pushreal8array(gamma0, size(gamma0, 1)*size(gamma0, 2))
    call pushreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk&
&                 , 4))
    call pushreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj&
&                 , 4))
    call pushreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si&
&                 , 4))
    call pushreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call pushreal8array(sfacek, size(sfacek, 1)*size(sfacek, 2)*size(&
&                 sfacek, 3))
    call pushreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma&
&                 , 3))
    call pushreal8array(sfacej, size(sfacej, 1)*size(sfacej, 2)*size(&
&                 sfacej, 3))
    call pushreal8array(sfacei, size(sfacei, 1)*size(sfacei, 2)*size(&
&                 sfacei, 3))
    call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call pushreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          call pushreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms(&
&                       ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, ii1&
&                       )%w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*size(&
&                       flowdoms(ii3, ii2, ii1)%w, 4))
        end do
      end do
    end do
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          call pushreal8array(flowdoms(ii3, ii2, ii1)%x, size(flowdoms(&
&                       ii3, ii2, ii1)%x, 1)*size(flowdoms(ii3, ii2, ii1&
&                       )%x, 2)*size(flowdoms(ii3, ii2, ii1)%x, 3)*size(&
&                       flowdoms(ii3, ii2, ii1)%x, 4))
        end do
      end do
    end do
    call forcesandmoments(localvalues)
! convert back to actual forces. note that even though we use
! machcoef, lref, and surfaceref here, they are not differented,
! since f doesn't actually depend on them. ideally we would just get
! the raw forces and moment form forcesandmoments. 
    force = zero
    moment = zero
    do sps2=1,ntimeintervalsspectral
      force(:, sps2) = localvalues(ifp:ifp+2) + localvalues(ifv:ifv+2)
      moment(:, sps2) = localvalues(imp:imp+2) + localvalues(imv:imv+2)
    end do
    sepsensor = localvalues(isepsensor)
    sepsensoravg = localvalues(isepavg:isepavg+2)
    cavitation = localvalues(icavitation)
    call getcostfunction_b(force, forced, moment, momentd, sepsensor, &
&                    sepsensord, sepsensoravg, sepsensoravgd, cavitation&
&                    , cavitationd)
    localvaluesd = 0.0_8
    localvaluesd(icavitation) = localvaluesd(icavitation) + cavitationd
    localvaluesd(isepavg:isepavg+2) = localvaluesd(isepavg:isepavg+2) + &
&     sepsensoravgd
    localvaluesd(isepsensor) = localvaluesd(isepsensor) + sepsensord
    do sps2=ntimeintervalsspectral,1,-1
      localvaluesd(imp:imp+2) = localvaluesd(imp:imp+2) + momentd(:, &
&       sps2)
      localvaluesd(imv:imv+2) = localvaluesd(imv:imv+2) + momentd(:, &
&       sps2)
      momentd(:, sps2) = 0.0_8
      localvaluesd(ifp:ifp+2) = localvaluesd(ifp:ifp+2) + forced(:, sps2&
&       )
      localvaluesd(ifv:ifv+2) = localvaluesd(ifv:ifv+2) + forced(:, sps2&
&       )
      forced(:, sps2) = 0.0_8
    end do
    do ii1=ntimeintervalsspectral,1,-1
      do ii2=1,1,-1
        do ii3=nn,nn,-1
          call popreal8array(flowdoms(ii3, ii2, ii1)%x, size(flowdoms(&
&                      ii3, ii2, ii1)%x, 1)*size(flowdoms(ii3, ii2, ii1)&
&                      %x, 2)*size(flowdoms(ii3, ii2, ii1)%x, 3)*size(&
&                      flowdoms(ii3, ii2, ii1)%x, 4))
        end do
      end do
    end do
    do ii1=ntimeintervalsspectral,1,-1
      do ii2=1,1,-1
        do ii3=nn,nn,-1
          call popreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms(&
&                      ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, ii1)&
&                      %w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*size(&
&                      flowdoms(ii3, ii2, ii1)%w, 4))
        end do
      end do
    end do
    call popreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call popreal8array(sfacei, size(sfacei, 1)*size(sfacei, 2)*size(&
&                sfacei, 3))
    call popreal8array(sfacej, size(sfacej, 1)*size(sfacej, 2)*size(&
&                sfacej, 3))
    call popreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma, &
&                3))
    call popreal8array(sfacek, size(sfacek, 1)*size(sfacek, 2)*size(&
&                sfacek, 3))
    call popreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call popreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si, &
&                4))
    call popreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj, &
&                4))
    call popreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk, &
&                4))
    call popreal8array(gamma0, size(gamma0, 1)*size(gamma0, 2))
    call popreal8array(gamma1, size(gamma1, 1)*size(gamma1, 2))
    call popreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call popreal8array(gamma3, size(gamma3, 1)*size(gamma3, 2))
    call popreal8array(xx, size(xx, 1)*size(xx, 2)*size(xx, 3))
    call popreal8array(rev0, size(rev0, 1)*size(rev0, 2))
    call popreal8array(rev1, size(rev1, 1)*size(rev1, 2))
    call popreal8array(rev2, size(rev2, 1)*size(rev2, 2))
    call popreal8array(rev3, size(rev3, 1)*size(rev3, 2))
    call popreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call popreal8array(pp3, size(pp3, 1)*size(pp3, 2))
    call popreal8array(rlv0, size(rlv0, 1)*size(rlv0, 2))
    call popreal8array(rlv1, size(rlv1, 1)*size(rlv1, 2))
    call popreal8array(rlv2, size(rlv2, 1)*size(rlv2, 2))
    call popreal8array(rlv3, size(rlv3, 1)*size(rlv3, 2))
    call popreal8array(sface, size(sface, 1)*size(sface, 2))
    call popreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3))
    call popreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call popreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call forcesandmoments_b(localvalues, localvaluesd)
    do sps2=ntimeintervalsspectral,1,-1
      do l=nstate,nt1,-1
        do k=kl,2,-1
          do j=jl,2,-1
            do i=il,2,-1
              flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = turbresscale(l-nt1&
&               +1)*flowdomsd(nn, 1, sps2)%dw(i, j, k, l)/flowdoms(nn, &
&               currentlevel, sps2)%volref(i, j, k)
            end do
          end do
        end do
      end do
      do l=nwf,1,-1
        do k=kl,2,-1
          do j=jl,2,-1
            do i=il,2,-1
              flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)
            end do
          end do
        end do
      end do
    end do
    do ii1=ntimeintervalsspectral,1,-1
      do ii2=1,1,-1
        do ii3=nn,nn,-1
          call popreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms(&
&                      ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, ii1)&
&                      %w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*size(&
&                      flowdoms(ii3, ii2, ii1)%w, 4))
        end do
      end do
    end do
    do ii1=ntimeintervalsspectral,1,-1
      do ii2=1,1,-1
        do ii3=nn,nn,-1
          call popreal8array(flowdoms(ii3, ii2, ii1)%dw, size(flowdoms(&
&                      ii3, ii2, ii1)%dw, 1)*size(flowdoms(ii3, ii2, ii1&
&                      )%dw, 2)*size(flowdoms(ii3, ii2, ii1)%dw, 3)*size&
&                      (flowdoms(ii3, ii2, ii1)%dw, 4))
        end do
      end do
    end do
    call popreal8array(aa, size(aa, 1)*size(aa, 2)*size(aa, 3))
    call popreal8array(fw, size(fw, 1)*size(fw, 2)*size(fw, 3)*size(fw, &
&                4))
    call residual_block_b()
    call popcontrol2b(branch)
    if (branch .lt. 2) then
      if (branch .eq. 0) then
        dwd(:, :, :, 1:nwf) = 0.0_8
      else
        do sps2=ntimeintervalsspectral,1,-1
          do mm=ntimeintervalsspectral,1,-1
            do l=nwf,1,-1
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                do k=kl,2,-1
                  do j=jl,2,-1
                    do i=il,2,-1
                      tempd0 = dscalar(jj, sps2, mm)*flowdomsd(nn, 1, &
&                       sps2)%dw(i, j, k, l)
                      flowdomsd(nn, 1, mm)%vol(i, j, k) = flowdomsd(nn, &
&                       1, mm)%vol(i, j, k) + flowdoms(nn, 1, mm)%w(i, j&
&                       , k, l)*tempd0
                      flowdomsd(nn, 1, mm)%w(i, j, k, l) = flowdomsd(nn&
&                       , 1, mm)%w(i, j, k, l) + flowdoms(nn, 1, mm)%vol&
&                       (i, j, k)*tempd0
                    end do
                  end do
                end do
              else
                do k=kl,2,-1
                  do j=jl,2,-1
                    do i=il,2,-1
                      tempd = flowdoms(nn, 1, mm)%w(i, j, k, irho)*&
&                       flowdomsd(nn, 1, sps2)%dw(i, j, k, l)
                      temp = flowdoms(nn, 1, mm)%vol(i, j, k)
                      tmpd = temp*tempd
                      flowdomsd(nn, 1, mm)%vol(i, j, k) = flowdomsd(nn, &
&                       1, mm)%vol(i, j, k) + tmp*tempd
                      flowdomsd(nn, 1, mm)%w(i, j, k, irho) = flowdomsd(&
&                       nn, 1, mm)%w(i, j, k, irho) + tmp*temp*flowdomsd&
&                       (nn, 1, sps2)%dw(i, j, k, l)
                      call popreal8(tmp)
                      flowdomsd(nn, 1, mm)%w(i, j, k, ivx) = flowdomsd(&
&                       nn, 1, mm)%w(i, j, k, ivx) + dvector(jj, ll, ii+&
&                       1)*tmpd
                      flowdomsd(nn, 1, mm)%w(i, j, k, ivy) = flowdomsd(&
&                       nn, 1, mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+&
&                       2)*tmpd
                      flowdomsd(nn, 1, mm)%w(i, j, k, ivz) = flowdomsd(&
&                       nn, 1, mm)%w(i, j, k, ivz) + dvector(jj, ll, ii+&
&                       3)*tmpd
                    end do
                  end do
                end do
                call popcontrol1b(branch)
                if (branch .ne. 0) call popinteger4(ll)
                call popcontrol1b(branch)
                if (branch .eq. 0) call popinteger4(ll)
                call popcontrol1b(branch)
                if (branch .eq. 0) call popinteger4(ll)
              end if
            end do
            call popinteger4(ii)
          end do
          call popinteger4(jj)
        end do
        do sps2=ntimeintervalsspectral,1,-1
          flowdomsd(nn, 1, sps2)%dw(:, :, :, 1:nwf) = 0.0_8
        end do
      end if
    else if (branch .eq. 2) then
      oneoverdtd = 0.0_8
      do l=nw,1,-1
        do k=kl,2,-1
          do j=jl,2,-1
            do i=il,2,-1
              call popreal8(flowdoms(nn, 1, sps)%dw(i, j, k, l))
              oneoverdtd = oneoverdtd + flowdoms(nn, 1, sps)%dw(i, j, k&
&               , l)*flowdomsd(nn, 1, sps)%dw(i, j, k, l)
              flowdomsd(nn, 1, sps)%dw(i, j, k, l) = oneoverdt*flowdomsd&
&               (nn, 1, sps)%dw(i, j, k, l)
            end do
          end do
        end do
      end do
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        do m=noldlevels,1,-1
          do l=nw,1,-1
            do k=kl,2,-1
              do j=jl,2,-1
                do i=il,2,-1
                  vold(i, j, k) = vold(i, j, k) + wold(m, i, j, k, l)*&
&                   coeftime(m)*flowdomsd(nn, 1, sps)%dw(i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      end if
      do l=nw,1,-1
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          do k=kl,2,-1
            do j=jl,2,-1
              do i=il,2,-1
                vold(i, j, k) = vold(i, j, k) + coeftime(0)*w(i, j, k, l&
&                 )*flowdomsd(nn, 1, sps)%dw(i, j, k, l)
                wd(i, j, k, l) = wd(i, j, k, l) + coeftime(0)*vol(i, j, &
&                 k)*flowdomsd(nn, 1, sps)%dw(i, j, k, l)
                flowdomsd(nn, 1, sps)%dw(i, j, k, l) = 0.0_8
              end do
            end do
          end do
        else
          do k=kl,2,-1
            do j=jl,2,-1
              do i=il,2,-1
                temp0 = w(i, j, k, l)
                tempd1 = coeftime(0)*w(i, j, k, irho)*flowdomsd(nn, 1, &
&                 sps)%dw(i, j, k, l)
                vold(i, j, k) = vold(i, j, k) + temp0*tempd1
                wd(i, j, k, l) = wd(i, j, k, l) + vol(i, j, k)*tempd1
                wd(i, j, k, irho) = wd(i, j, k, irho) + coeftime(0)*vol(&
&                 i, j, k)*temp0*flowdomsd(nn, 1, sps)%dw(i, j, k, l)
                flowdomsd(nn, 1, sps)%dw(i, j, k, l) = 0.0_8
              end do
            end do
          end do
        end if
      end do
      timerefd = timerefd + oneoverdtd/deltat
    end if
    call popcontrol2b(branch)
    if (branch .eq. 0) then
      do ii1=ntimeintervalsspectral,1,-1
        do ii2=1,1,-1
          do ii3=nn,nn,-1
            call popreal8array(flowdoms(ii3, ii2, ii1)%dw, size(flowdoms&
&                        (ii3, ii2, ii1)%dw, 1)*size(flowdoms(ii3, ii2, &
&                        ii1)%dw, 2)*size(flowdoms(ii3, ii2, ii1)%dw, 3)&
&                        *size(flowdoms(ii3, ii2, ii1)%dw, 4))
          end do
        end do
      end do
      call popreal8array(bmtk1, size(bmtk1, 1)*size(bmtk1, 2)*size(bmtk1&
&                  , 3)*size(bmtk1, 4))
      call popreal8array(bmtk2, size(bmtk2, 1)*size(bmtk2, 2)*size(bmtk2&
&                  , 3)*size(bmtk2, 4))
      call popreal8array(scratch, size(scratch, 1)*size(scratch, 2)*size&
&                  (scratch, 3)*size(scratch, 4))
      call popreal8array(bmti1, size(bmti1, 1)*size(bmti1, 2)*size(bmti1&
&                  , 3)*size(bmti1, 4))
      call popreal8array(bmti2, size(bmti2, 1)*size(bmti2, 2)*size(bmti2&
&                  , 3)*size(bmti2, 4))
      call popreal8array(bmtj1, size(bmtj1, 1)*size(bmtj1, 2)*size(bmtj1&
&                  , 3)*size(bmtj1, 4))
      call popreal8array(bmtj2, size(bmtj2, 1)*size(bmtj2, 2)*size(bmtj2&
&                  , 3)*size(bmtj2, 4))
      call sa_block_b(.true.)
    else if (branch .eq. 1) then
      d2walld = 0.0_8
    else
      d2walld = 0.0_8
    end if
    do sps2=ntimeintervalsspectral,1,-1
      flowdomsd(nn, 1, sps2)%dw = 0.0_8
    end do
    call timestep_block_b(.false.)
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      do ii1=ntimeintervalsspectral,1,-1
        do ii2=1,1,-1
          do ii3=nn,nn,-1
            call popreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms(&
&                        ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, &
&                        ii1)%w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*&
&                        size(flowdoms(ii3, ii2, ii1)%w, 4))
          end do
        end do
      end do
      call applyallturbbcthisblock_b(.true.)
      call bcturbtreatment_b()
    end if
    do ii1=ntimeintervalsspectral,1,-1
      do ii2=1,1,-1
        do ii3=nn,nn,-1
          call popreal8array(flowdoms(ii3, ii2, ii1)%x, size(flowdoms(&
&                      ii3, ii2, ii1)%x, 1)*size(flowdoms(ii3, ii2, ii1)&
&                      %x, 2)*size(flowdoms(ii3, ii2, ii1)%x, 3)*size(&
&                      flowdoms(ii3, ii2, ii1)%x, 4))
        end do
      end do
    end do
    do ii1=ntimeintervalsspectral,1,-1
      do ii2=1,1,-1
        do ii3=nn,nn,-1
          call popreal8array(flowdoms(ii3, ii2, ii1)%w, size(flowdoms(&
&                      ii3, ii2, ii1)%w, 1)*size(flowdoms(ii3, ii2, ii1)&
&                      %w, 2)*size(flowdoms(ii3, ii2, ii1)%w, 3)*size(&
&                      flowdoms(ii3, ii2, ii1)%w, 4))
        end do
      end do
    end do
    call popreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
    call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call popreal8array(sfacei, size(sfacei, 1)*size(sfacei, 2)*size(&
&                sfacei, 3))
    call popreal8array(sfacej, size(sfacej, 1)*size(sfacej, 2)*size(&
&                sfacej, 3))
    call popreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(gamma, &
&                3))
    call popreal8array(sfacek, size(sfacek, 1)*size(sfacek, 2)*size(&
&                sfacek, 3))
    call popreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
    call popreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(si, &
&                4))
    call popreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(sj, &
&                4))
    call popreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(sk, &
&                4))
    call popreal8array(gamma0, size(gamma0, 1)*size(gamma0, 2))
    call popreal8array(gamma1, size(gamma1, 1)*size(gamma1, 2))
    call popreal8array(gamma2, size(gamma2, 1)*size(gamma2, 2))
    call popreal8array(gamma3, size(gamma3, 1)*size(gamma3, 2))
    call popreal8array(xx, size(xx, 1)*size(xx, 2)*size(xx, 3))
    call popreal8array(rev0, size(rev0, 1)*size(rev0, 2))
    call popreal8array(rev1, size(rev1, 1)*size(rev1, 2))
    call popreal8array(rev2, size(rev2, 1)*size(rev2, 2))
    call popreal8array(rev3, size(rev3, 1)*size(rev3, 2))
    call popreal8array(pp0, size(pp0, 1)*size(pp0, 2))
    call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
    call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
    call popreal8array(pp3, size(pp3, 1)*size(pp3, 2))
    call popreal8array(rlv0, size(rlv0, 1)*size(rlv0, 2))
    call popreal8array(rlv1, size(rlv1, 1)*size(rlv1, 2))
    call popreal8array(rlv2, size(rlv2, 1)*size(rlv2, 2))
    call popreal8array(rlv3, size(rlv3, 1)*size(rlv3, 2))
    call popreal8array(sface, size(sface, 1)*size(sface, 2))
    call popreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3))
    call popreal8array(ww0, size(ww0, 1)*size(ww0, 2)*size(ww0, 3))
    call popreal8array(ww1, size(ww1, 1)*size(ww1, 2)*size(ww1, 3))
    call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
    call popreal8array(ww3, size(ww3, 1)*size(ww3, 2)*size(ww3, 3))
    call applyallbc_block_b(.true.)
    call computeeddyviscosity_b(.true.)
    call computelamviscosity_b(.true.)
    call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
    call computepressuresimple_b(.true.)
    call popcontrol2b(branch)
    if (branch .eq. 0) then
      call updatewalldistancesquickly_b(nn, 1, sps)
    else if (branch .eq. 1) then
      xsurfd = 0.0_8
    else
      xsurfd = 0.0_8
      goto 100
    end if
    call boundarynormals_b()
    call metric_block_b()
    call volume_block_b()
 100 call popreal8(gammainf)
    call referencestate_b()
    call adjustinflowangle_b()
    funcvaluesd = 0.0_8
  end subroutine block_res_b
! this is a super-combined function that combines the original
! functionality of: 
! pressure computation
! timestep
! applyallbcs
! initres
! residual 
! the real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the nominal
! block/sps loop is outside the calculation. this routine is suitable
! for forward mode ad with tapenade
  subroutine block_res(nn, sps, usespatial, frozenturb)
! note that we import all the pointers from block res that will be
! used in any routine. otherwise, tapenade gives warnings about
! saving a hidden variable. 
    use constants
    use block, only : flowdoms
    use bcroutines_b
    use bcpointers_b
    use blockpointers, only : w, dw, x, vol, il, jl, kl, sectionid, &
&   wold, volold, bcdata, si, sj, sk, sfacei, sfacej, sfacek, rlv, gamma&
&   , p, rev, bmtj1, bmtj2, scratch, bmtk2, bmtk1, fw, aa, d2wall, bmti1&
&   , bmti2, s
    use flowvarrefstate
    use inputphysics
    use inputiteration
    use inputtimespectral
    use section
    use monitor
    use iteration
    use diffsizes
    use costfunctions
    use initializeflow_b, only : referencestate
    use walldistance_b, only : updatewalldistancesquickly, xsurf
    use inputdiscretization
    use sa_b
    use inputunsteady
    use turbbcroutines_b
    use turbutils_b
    use utils_b, only : terminate
    use flowutils_b, only : adjustinflowangle, computepressuresimple, &
&   computelamviscosity
    use solverutils_b, only : gridvelocitiesfinelevel_block, &
&   normalvelocities_block, slipvelocitiesfinelevel_block, &
&   timestep_block
    use residuals_b, only : residual_block
    use surfaceintegrations_b, only : forcesandmoments
    implicit none
! input arguments:
    integer(kind=inttype), intent(in) :: nn, sps
    logical, intent(in) :: usespatial, frozenturb
! output variables
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   moment
    real(kind=realtype) :: sepsensor, cavitation, sepsensoravg(3)
! working variables
    real(kind=realtype) :: gm1, v2, fact, tmp
    integer(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj, m
    integer(kind=inttype) :: nstate
    real(kind=realtype), dimension(nsections) :: t
    logical :: useoldcoor
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype) :: yplusmax, oneoverdt
    real(kind=realtype) :: localvalues(nlocalvalues)
    useoldcoor = .false.
! setup number of state variable based on turbulence assumption
    if (frozenturb) then
      nstate = nwf
    else
      nstate = nw
    end if
! set pointers to input/output variables
    w => flowdoms(nn, currentlevel, sps)%w
    dw => flowdoms(nn, 1, sps)%dw
    x => flowdoms(nn, currentlevel, sps)%x
    vol => flowdoms(nn, currentlevel, sps)%vol
! ------------------------------------------------
!        additional 'extra' components
! ------------------------------------------------ 
    call adjustinflowangle()
    call referencestate()
! ------------------------------------------------
!        additional spatial components
! ------------------------------------------------
    if (usespatial) then
      call volume_block()
      call metric_block()
      call boundarynormals()
      if (equations .eq. ransequations .and. useapproxwalldistance) call&
&       updatewalldistancesquickly(nn, 1, sps)
    end if
! ------------------------------------------------
!        normal residual computation
! ------------------------------------------------
! compute the pressures
    call computepressuresimple(.true.)
! compute laminar/eddy viscosity if required
    call computelamviscosity(.true.)
    call computeeddyviscosity(.true.)
    call applyallbc_block(.true.)
    if (equations .eq. ransequations) then
      call bcturbtreatment()
      call applyallturbbcthisblock(.true.)
    end if
! compute skin_friction velocity (only for wall functions)
! #ifndef 1
!   call computeutau_block
! #endif
! compute time step and spectral radius
    call timestep_block(.false.)
spectralloop0:do sps2=1,ntimeintervalsspectral
      flowdoms(nn, 1, sps2)%dw(:, :, :, :) = zero
    end do spectralloop0
! -------------------------------
! compute turbulence residual for rans equations
    if (equations .eq. ransequations) then
! ! initialize only the turblent variables
! call unsteadyturbspectral_block(itu1, itu1, nn, sps)
      select case  (turbmodel) 
      case (spalartallmaras) 
        call sa_block(.true.)
      case default
!case (mentersst)
! not implemented yet
!call sst_block(.true.)
        call terminate('turbresidual', &
&                'only sa turbulence adjoint implemented')
      end select
    end if
! -------------------------------  
! next initialize residual for flow variables. the is the only place
! where there is an n^2 dependance. there are issues with
! initres. so only the necesary timespectral code has been copied
! here. see initres for more information and comments.
!call initres_block(1, nwf, nn, sps)
    if (equationmode .eq. steady) then
      dw(:, :, :, 1:nwf) = zero
    else if (equationmode .eq. timespectral) then
! zero dw on all spectral instances
spectralloop1:do sps2=1,ntimeintervalsspectral
        flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
      end do spectralloop1
spectralloop2:do sps2=1,ntimeintervalsspectral
        jj = sectionid
timeloopfine:do mm=1,ntimeintervalsspectral
          ii = 3*(mm-1)
varloopfine:do l=1,nwf
            if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
              if (l .eq. ivx) ll = 3*sps2 - 2
              if (l .eq. ivy) ll = 3*sps2 - 1
              if (l .eq. ivz) ll = 3*sps2
              do k=2,kl
                do j=2,jl
                  do i=2,il
                    tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i&
&                     , j, k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, &
&                     1, mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
&                     flowdoms(nn, 1, mm)%w(i, j, k, ivz)
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%&
&                     vol(i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
                  end do
                end do
              end do
            else
              do k=2,kl
                do j=2,jl
                  do i=2,il
! this is: dw = dw + dscalar*vol*w
                    flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, &
&                     1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
&                     flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, &
&                     mm)%w(i, j, k, l)
                  end do
                end do
              end do
            end if
          end do varloopfine
        end do timeloopfine
      end do spectralloop2
    else if (equationmode .eq. unsteady) then
! assume only md or bdf types
! store the inverse of the physical nondimensional
! time step a bit easier.
      oneoverdt = timeref/deltat
! ground level of the multigrid cycle. initialize the
! owned cells to the unsteady source term. first the
! term for the current time level. note that in w the
! velocities are stored and not the momentum variables.
! therefore the if-statement is present to correct this.
      do l=1,nw
        if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
! momentum variables.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)*w(i, j, k, irho)
              end do
            end do
          end do
        else
! non-momentum variables, for which the variable
! to be solved is stored; for the flow equations this
! is the conservative variable, for the turbulent
! equations the primitive variable.
          do k=2,kl
            do j=2,jl
              do i=2,il
                flowdoms(nn, 1, sps)%dw(i, j, k, l) = coeftime(0)*vol(i&
&                 , j, k)*w(i, j, k, l)
              end do
            end do
          end do
        end if
      end do
! the terms from the older time levels. here the
! conservative variables are stored. in case of a
! deforming mesh, also the old volumes must be taken.
      if (deforming_grid) then
! mesh is deforming and thus the volumes can change.
! use the old volumes as well.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*volold(m, i, j, k)&
&                   *wold(m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      else
! rigid mesh. the volumes remain constant.
        do m=1,noldlevels
          do l=1,nw
            do k=2,kl
              do j=2,jl
                do i=2,il
                  flowdoms(nn, 1, sps)%dw(i, j, k, l) = flowdoms(nn, 1, &
&                   sps)%dw(i, j, k, l) + coeftime(m)*vol(i, j, k)*wold(&
&                   m, i, j, k, l)
                end do
              end do
            end do
          end do
        end do
      end if
! multiply the time derivative by the inverse of the
! time step to obtain the true time derivative.
! this is done after the summation has been done, because
! otherwise you run into finite accuracy problems for
! very small time steps.
      do l=1,nw
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdoms(nn, 1, sps)%dw(i, j, k, l) = oneoverdt*flowdoms(&
&               nn, 1, sps)%dw(i, j, k, l)
            end do
          end do
        end do
      end do
    end if
!  actual residual calc
    call residual_block()
! divide through by the reference volume
    do sps2=1,ntimeintervalsspectral
      do l=1,nwf
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)
            end do
          end do
        end do
      end do
! treat the turblent residual with the scaling factor on the
! residual
      do l=nt1,nstate
        do k=2,kl
          do j=2,jl
            do i=2,il
              flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, &
&               sps2)%dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%&
&               volref(i, j, k)*turbresscale(l-nt1+1)
            end do
          end do
        end do
      end do
    end do
    localvalues = zero
    call forcesandmoments(localvalues)
! convert back to actual forces. note that even though we use
! machcoef, lref, and surfaceref here, they are not differented,
! since f doesn't actually depend on them. ideally we would just get
! the raw forces and moment form forcesandmoments. 
    force = zero
    moment = zero
    do sps2=1,ntimeintervalsspectral
      force(:, sps2) = localvalues(ifp:ifp+2) + localvalues(ifv:ifv+2)
      moment(:, sps2) = localvalues(imp:imp+2) + localvalues(imv:imv+2)
    end do
    sepsensor = localvalues(isepsensor)
    sepsensoravg = localvalues(isepavg:isepavg+2)
    cavitation = localvalues(icavitation)
    call getcostfunction(force, moment, sepsensor, sepsensoravg, &
&                  cavitation)
  end subroutine block_res
  subroutine resscale()
    use blockpointers
    use flowvarrefstate
    use inputiteration
    implicit none
! local variables
    integer(kind=inttype) :: i, j, k, l
    real(kind=realtype) :: ovol
! divide through by the reference volume
    do k=2,kl
      do j=2,jl
        do i=2,il
          ovol = one/volref(i, j, k)
          do l=1,nwf
            dw(i, j, k, l) = (dw(i, j, k, l)+fw(i, j, k, l))*ovol
          end do
          do l=nt1,nt2
            dw(i, j, k, l) = (dw(i, j, k, l)+fw(i, j, k, l))*ovol*&
&             turbresscale(l-nt1+1)
          end do
        end do
      end do
    end do
  end subroutine resscale
!  differentiation of getcostfunction in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: funcvalues
!   with respect to varying inputs: machgrid lengthref machcoef
!                dragdirection liftdirection pointref pinf rhoinfdim
!                pinfdim pref moment sepsensoravg force cavitation
!                sepsensor
  subroutine getcostfunction_b(force, forced, moment, momentd, sepsensor&
&   , sepsensord, sepsensoravg, sepsensoravgd, cavitation, cavitationd)
! compute the value of the actual objective function based on the
! (summed) forces and moments and any other "extra" design
! variables. the index of the objective is determined by 'idv'. this
! function is intended to be ad'ed in reverse mode. 
    use constants
    use inputtimespectral
    use costfunctions
    use inputphysics
    use flowvarrefstate
    use inputtsstabderiv
    use utils_b, only : computetsderivatives, computetsderivatives_b, &
&   computerootbendingmoment, computerootbendingmoment_b
    implicit none
! input 
    real(kind=realtype), dimension(3, ntimeintervalsspectral), intent(in&
&   ) :: force, moment
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced&
&   , momentd
    real(kind=realtype), intent(in) :: sepsensor, cavitation, &
&   sepsensoravg(3)
    real(kind=realtype) :: sepsensord, cavitationd, sepsensoravgd(3)
! working
    real(kind=realtype) :: fact, factmoment, ovrnts
    real(kind=realtype) :: factd, factmomentd
    real(kind=realtype), dimension(3) :: cf, cm
    real(kind=realtype), dimension(3) :: cfd, cmd
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(8) :: coef0, dcdalpha, dcdalphadot, &
&   dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: coef0d, dcdalphad, dcdalphadotd
    real(kind=realtype) :: bendingmoment
    real(kind=realtype) :: bendingmomentd
    integer(kind=inttype) :: sps
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmp2
    real(kind=realtype) :: tmp3
    real(kind=realtype) :: tmp4
    real(kind=realtype) :: tmp5
    real(kind=realtype) :: tmp6
    real(kind=realtype) :: tmp7
    real(kind=realtype) :: tmp8
    integer :: branch
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tmpd8
    real(kind=realtype) :: tmpd7
    real(kind=realtype) :: tmpd6
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd5
    real(kind=realtype) :: tmpd4
    real(kind=realtype) :: tmpd3
    real(kind=realtype) :: tmpd2
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
    real(kind=realtype) :: temp
! generate constants
    fact = two/(gammainf*machcoef**2*surfaceref*lref**2*pref)
    factmoment = fact/(lengthref*lref)
    ovrnts = one/ntimeintervalsspectral
! pre-compute ts stability info if required:
    if (tsstability) then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    funcvalues = zero
! now we just compute each cost function:
    do sps=1,ntimeintervalsspectral
      funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
&       force(1, sps)
      funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
&       force(2, sps)
      funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
&       force(3, sps)
      funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*&
&       moment(1, sps)
      funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*&
&       moment(2, sps)
      funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*&
&       moment(3, sps)
      funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
&       ovrnts*sepsensor
      funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
&       ovrnts*cavitation
      funcvalues(costfuncsepsensoravgx) = funcvalues(&
&       costfuncsepsensoravgx) + ovrnts*sepsensoravg(1)
      funcvalues(costfuncsepsensoravgy) = funcvalues(&
&       costfuncsepsensoravgy) + ovrnts*sepsensoravg(2)
      funcvalues(costfuncsepsensoravgz) = funcvalues(&
&       costfuncsepsensoravgz) + ovrnts*sepsensoravg(3)
! bending moment calc
      cm = factmoment*moment(:, sps)
      cf = fact*force(:, sps)
      call computerootbendingmoment(cf, cm, bendingmoment)
      funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) &
&       + ovrnts*bendingmoment
    end do
    tmp = funcvalues(costfuncforcex)*fact
    call pushreal8(funcvalues(costfuncforcexcoef))
    funcvalues(costfuncforcexcoef) = tmp
    tmp0 = funcvalues(costfuncforcey)*fact
    call pushreal8(funcvalues(costfuncforceycoef))
    funcvalues(costfuncforceycoef) = tmp0
    tmp1 = funcvalues(costfuncforcez)*fact
    call pushreal8(funcvalues(costfuncforcezcoef))
    funcvalues(costfuncforcezcoef) = tmp1
    tmp2 = funcvalues(costfuncmomx)*factmoment
    call pushreal8(funcvalues(costfuncmomxcoef))
    funcvalues(costfuncmomxcoef) = tmp2
    tmp3 = funcvalues(costfuncmomy)*factmoment
    call pushreal8(funcvalues(costfuncmomycoef))
    funcvalues(costfuncmomycoef) = tmp3
    tmp4 = funcvalues(costfuncmomz)*factmoment
    call pushreal8(funcvalues(costfuncmomzcoef))
    funcvalues(costfuncmomzcoef) = tmp4
    tmp5 = funcvalues(costfuncforcex)*liftdirection(1) + funcvalues(&
&     costfuncforcey)*liftdirection(2) + funcvalues(costfuncforcez)*&
&     liftdirection(3)
    call pushreal8(funcvalues(costfunclift))
    funcvalues(costfunclift) = tmp5
    tmp6 = funcvalues(costfuncforcex)*dragdirection(1) + funcvalues(&
&     costfuncforcey)*dragdirection(2) + funcvalues(costfuncforcez)*&
&     dragdirection(3)
    call pushreal8(funcvalues(costfuncdrag))
    funcvalues(costfuncdrag) = tmp6
    tmp7 = funcvalues(costfunclift)*fact
    call pushreal8(funcvalues(costfuncliftcoef))
    funcvalues(costfuncliftcoef) = tmp7
! -------------------- time spectral objectives ------------------
    funcvaluesd(costfunccmzqdot) = 0.0_8
    funcvaluesd(costfunccdqdot) = 0.0_8
    funcvaluesd(costfuncclqdot) = 0.0_8
    funcvaluesd(costfunccmzq) = 0.0_8
    funcvaluesd(costfunccdq) = 0.0_8
    funcvaluesd(costfuncclq) = 0.0_8
    dcdalphadotd = 0.0_8
    dcdalphadotd(8) = dcdalphadotd(8) + funcvaluesd(costfunccmzalphadot)
    funcvaluesd(costfunccmzalphadot) = 0.0_8
    dcdalphadotd(2) = dcdalphadotd(2) + funcvaluesd(costfunccdalphadot)
    funcvaluesd(costfunccdalphadot) = 0.0_8
    dcdalphadotd(1) = dcdalphadotd(1) + funcvaluesd(costfuncclalphadot)
    funcvaluesd(costfuncclalphadot) = 0.0_8
    dcdalphad = 0.0_8
    dcdalphad(8) = dcdalphad(8) + funcvaluesd(costfunccmzalpha)
    funcvaluesd(costfunccmzalpha) = 0.0_8
    dcdalphad(2) = dcdalphad(2) + funcvaluesd(costfunccdalpha)
    funcvaluesd(costfunccdalpha) = 0.0_8
    dcdalphad(1) = dcdalphad(1) + funcvaluesd(costfuncclalpha)
    funcvaluesd(costfuncclalpha) = 0.0_8
    coef0d = 0.0_8
    coef0d(8) = coef0d(8) + funcvaluesd(costfunccm0)
    funcvaluesd(costfunccm0) = 0.0_8
    coef0d(2) = coef0d(2) + funcvaluesd(costfunccd0)
    funcvaluesd(costfunccd0) = 0.0_8
    coef0d(1) = coef0d(1) + funcvaluesd(costfunccl0)
    funcvaluesd(costfunccl0) = 0.0_8
    tmpd = funcvaluesd(costfuncdragcoef)
    funcvaluesd(costfuncdragcoef) = 0.0_8
    funcvaluesd(costfuncdrag) = funcvaluesd(costfuncdrag) + fact*tmpd
    factd = funcvalues(costfuncdrag)*tmpd
    call popreal8(funcvalues(costfuncliftcoef))
    tmpd0 = funcvaluesd(costfuncliftcoef)
    funcvaluesd(costfuncliftcoef) = 0.0_8
    funcvaluesd(costfunclift) = funcvaluesd(costfunclift) + fact*tmpd0
    factd = factd + funcvalues(costfunclift)*tmpd0
    dragdirectiond = 0.0_8
    call popreal8(funcvalues(costfuncdrag))
    tmpd1 = funcvaluesd(costfuncdrag)
    funcvaluesd(costfuncdrag) = 0.0_8
    dragdirectiond = 0.0_8
    funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + &
&     dragdirection(1)*tmpd1
    dragdirectiond(1) = dragdirectiond(1) + funcvalues(costfuncforcex)*&
&     tmpd1
    funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + &
&     dragdirection(2)*tmpd1
    dragdirectiond(2) = dragdirectiond(2) + funcvalues(costfuncforcey)*&
&     tmpd1
    funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + &
&     dragdirection(3)*tmpd1
    dragdirectiond(3) = dragdirectiond(3) + funcvalues(costfuncforcez)*&
&     tmpd1
    liftdirectiond = 0.0_8
    call popreal8(funcvalues(costfunclift))
    tmpd2 = funcvaluesd(costfunclift)
    funcvaluesd(costfunclift) = 0.0_8
    liftdirectiond = 0.0_8
    funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + &
&     liftdirection(1)*tmpd2
    liftdirectiond(1) = liftdirectiond(1) + funcvalues(costfuncforcex)*&
&     tmpd2
    funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + &
&     liftdirection(2)*tmpd2
    liftdirectiond(2) = liftdirectiond(2) + funcvalues(costfuncforcey)*&
&     tmpd2
    funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + &
&     liftdirection(3)*tmpd2
    liftdirectiond(3) = liftdirectiond(3) + funcvalues(costfuncforcez)*&
&     tmpd2
    call popreal8(funcvalues(costfuncmomzcoef))
    tmpd3 = funcvaluesd(costfuncmomzcoef)
    funcvaluesd(costfuncmomzcoef) = 0.0_8
    funcvaluesd(costfuncmomz) = funcvaluesd(costfuncmomz) + factmoment*&
&     tmpd3
    factmomentd = funcvalues(costfuncmomz)*tmpd3
    call popreal8(funcvalues(costfuncmomycoef))
    tmpd4 = funcvaluesd(costfuncmomycoef)
    funcvaluesd(costfuncmomycoef) = 0.0_8
    funcvaluesd(costfuncmomy) = funcvaluesd(costfuncmomy) + factmoment*&
&     tmpd4
    factmomentd = factmomentd + funcvalues(costfuncmomy)*tmpd4
    call popreal8(funcvalues(costfuncmomxcoef))
    tmpd5 = funcvaluesd(costfuncmomxcoef)
    funcvaluesd(costfuncmomxcoef) = 0.0_8
    funcvaluesd(costfuncmomx) = funcvaluesd(costfuncmomx) + factmoment*&
&     tmpd5
    factmomentd = factmomentd + funcvalues(costfuncmomx)*tmpd5
    call popreal8(funcvalues(costfuncforcezcoef))
    tmpd6 = funcvaluesd(costfuncforcezcoef)
    funcvaluesd(costfuncforcezcoef) = 0.0_8
    funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + fact*&
&     tmpd6
    factd = factd + funcvalues(costfuncforcez)*tmpd6
    call popreal8(funcvalues(costfuncforceycoef))
    tmpd7 = funcvaluesd(costfuncforceycoef)
    funcvaluesd(costfuncforceycoef) = 0.0_8
    funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + fact*&
&     tmpd7
    factd = factd + funcvalues(costfuncforcey)*tmpd7
    call popreal8(funcvalues(costfuncforcexcoef))
    tmpd8 = funcvaluesd(costfuncforcexcoef)
    funcvaluesd(costfuncforcexcoef) = 0.0_8
    funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + fact*&
&     tmpd8
    factd = factd + funcvalues(costfuncforcex)*tmpd8
    lengthrefd = 0.0_8
    pointrefd = 0.0_8
    momentd = 0.0_8
    sepsensoravgd = 0.0_8
    forced = 0.0_8
    cavitationd = 0.0_8
    sepsensord = 0.0_8
    do sps=ntimeintervalsspectral,1,-1
      bendingmomentd = ovrnts*funcvaluesd(costfuncbendingcoef)
      cf = fact*force(:, sps)
      cm = factmoment*moment(:, sps)
      call computerootbendingmoment_b(cf, cfd, cm, cmd, bendingmoment, &
&                               bendingmomentd)
      factd = factd + sum(force(:, sps)*cfd)
      forced(:, sps) = forced(:, sps) + fact*cfd
      factmomentd = factmomentd + sum(moment(:, sps)*cmd)
      momentd(:, sps) = momentd(:, sps) + factmoment*cmd
      sepsensoravgd(3) = sepsensoravgd(3) + ovrnts*funcvaluesd(&
&       costfuncsepsensoravgz)
      sepsensoravgd(2) = sepsensoravgd(2) + ovrnts*funcvaluesd(&
&       costfuncsepsensoravgy)
      sepsensoravgd(1) = sepsensoravgd(1) + ovrnts*funcvaluesd(&
&       costfuncsepsensoravgx)
      cavitationd = cavitationd + ovrnts*funcvaluesd(costfunccavitation)
      sepsensord = sepsensord + ovrnts*funcvaluesd(costfuncsepsensor)
      momentd(3, sps) = momentd(3, sps) + ovrnts*funcvaluesd(&
&       costfuncmomz)
      momentd(2, sps) = momentd(2, sps) + ovrnts*funcvaluesd(&
&       costfuncmomy)
      momentd(1, sps) = momentd(1, sps) + ovrnts*funcvaluesd(&
&       costfuncmomx)
      forced(3, sps) = forced(3, sps) + ovrnts*funcvaluesd(&
&       costfuncforcez)
      forced(2, sps) = forced(2, sps) + ovrnts*funcvaluesd(&
&       costfuncforcey)
      forced(1, sps) = forced(1, sps) + ovrnts*funcvaluesd(&
&       costfuncforcex)
    end do
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      call computetsderivatives_b(force, forced, moment, momentd, coef0&
&                           , coef0d, dcdalpha, dcdalphad, dcdalphadot, &
&                           dcdalphadotd, dcdq, dcdqdot)
    else
      machgridd = 0.0_8
      machcoefd = 0.0_8
      pinfd = 0.0_8
      rhoinfdimd = 0.0_8
      pinfdimd = 0.0_8
    end if
    tempd = factmomentd/(lref*lengthref)
    factd = factd + tempd
    lengthrefd = lengthrefd - fact*tempd/lengthref
    temp0 = gammainf*surfaceref*lref**2
    temp = temp0*machcoef**2*pref
    tempd0 = -(two*temp0*factd/temp**2)
    machcoefd = machcoefd + pref*2*machcoef*tempd0
    prefd = machcoef**2*tempd0
  end subroutine getcostfunction_b
  subroutine getcostfunction(force, moment, sepsensor, sepsensoravg, &
&   cavitation)
! compute the value of the actual objective function based on the
! (summed) forces and moments and any other "extra" design
! variables. the index of the objective is determined by 'idv'. this
! function is intended to be ad'ed in reverse mode. 
    use constants
    use inputtimespectral
    use costfunctions
    use inputphysics
    use flowvarrefstate
    use inputtsstabderiv
    use utils_b, only : computetsderivatives, computerootbendingmoment
    implicit none
! input 
    real(kind=realtype), dimension(3, ntimeintervalsspectral), intent(in&
&   ) :: force, moment
    real(kind=realtype), intent(in) :: sepsensor, cavitation, &
&   sepsensoravg(3)
! working
    real(kind=realtype) :: fact, factmoment, ovrnts
    real(kind=realtype), dimension(3) :: cf, cm
    real(kind=realtype) :: elasticmomentx, elasticmomenty, &
&   elasticmomentz
    real(kind=realtype), dimension(ntimeintervalsspectral, 8) :: &
&   basecoef
    real(kind=realtype), dimension(8) :: coef0, dcdalpha, dcdalphadot, &
&   dcdq, dcdqdot
    real(kind=realtype) :: bendingmoment
    integer(kind=inttype) :: sps
! generate constants
    fact = two/(gammainf*machcoef**2*surfaceref*lref**2*pref)
    factmoment = fact/(lengthref*lref)
    ovrnts = one/ntimeintervalsspectral
! pre-compute ts stability info if required:
    if (tsstability) then
      coef0 = zero
      dcdalpha = zero
      dcdalphadot = zero
      dcdq = zero
      dcdqdot = zero
      call computetsderivatives(force, moment, coef0, dcdalpha, &
&                         dcdalphadot, dcdq, dcdqdot)
    end if
    funcvalues = zero
! now we just compute each cost function:
    do sps=1,ntimeintervalsspectral
      funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
&       force(1, sps)
      funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
&       force(2, sps)
      funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
&       force(3, sps)
      funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*&
&       moment(1, sps)
      funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*&
&       moment(2, sps)
      funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*&
&       moment(3, sps)
      funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
&       ovrnts*sepsensor
      funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
&       ovrnts*cavitation
      funcvalues(costfuncsepsensoravgx) = funcvalues(&
&       costfuncsepsensoravgx) + ovrnts*sepsensoravg(1)
      funcvalues(costfuncsepsensoravgy) = funcvalues(&
&       costfuncsepsensoravgy) + ovrnts*sepsensoravg(2)
      funcvalues(costfuncsepsensoravgz) = funcvalues(&
&       costfuncsepsensoravgz) + ovrnts*sepsensoravg(3)
! bending moment calc
      cm = factmoment*moment(:, sps)
      cf = fact*force(:, sps)
      call computerootbendingmoment(cf, cm, bendingmoment)
      funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) &
&       + ovrnts*bendingmoment
    end do
    funcvalues(costfuncforcexcoef) = funcvalues(costfuncforcex)*fact
    funcvalues(costfuncforceycoef) = funcvalues(costfuncforcey)*fact
    funcvalues(costfuncforcezcoef) = funcvalues(costfuncforcez)*fact
    funcvalues(costfuncmomxcoef) = funcvalues(costfuncmomx)*factmoment
    funcvalues(costfuncmomycoef) = funcvalues(costfuncmomy)*factmoment
    funcvalues(costfuncmomzcoef) = funcvalues(costfuncmomz)*factmoment
    funcvalues(costfunclift) = funcvalues(costfuncforcex)*liftdirection(&
&     1) + funcvalues(costfuncforcey)*liftdirection(2) + funcvalues(&
&     costfuncforcez)*liftdirection(3)
    funcvalues(costfuncdrag) = funcvalues(costfuncforcex)*dragdirection(&
&     1) + funcvalues(costfuncforcey)*dragdirection(2) + funcvalues(&
&     costfuncforcez)*dragdirection(3)
    funcvalues(costfuncliftcoef) = funcvalues(costfunclift)*fact
    funcvalues(costfuncdragcoef) = funcvalues(costfuncdrag)*fact
! -------------------- time spectral objectives ------------------
    funcvalues(costfunccl0) = coef0(1)
    funcvalues(costfunccd0) = coef0(2)
    funcvalues(costfunccm0) = coef0(8)
    funcvalues(costfuncclalpha) = dcdalpha(1)
    funcvalues(costfunccdalpha) = dcdalpha(2)
    funcvalues(costfunccmzalpha) = dcdalpha(8)
    funcvalues(costfuncclalphadot) = dcdalphadot(1)
    funcvalues(costfunccdalphadot) = dcdalphadot(2)
    funcvalues(costfunccmzalphadot) = dcdalphadot(8)
    funcvalues(costfuncclq) = dcdq(1)
    funcvalues(costfunccdq) = dcdq(2)
    funcvalues(costfunccmzq) = dcdq(8)
    funcvalues(costfuncclqdot) = dcdqdot(1)
    funcvalues(costfunccdqdot) = dcdqdot(2)
    funcvalues(costfunccmzqdot) = dcdqdot(8)
  end subroutine getcostfunction
  subroutine volume_block()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vol = zero
    do k=1,ke
      n = k - 1
      do j=1,je
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x&
&               (i, m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2&
&               ), x(i, m, k, 3), vp1)
          call volpym(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, &
&               m, k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2&
&               ), x(l, j, n, 3), vp2)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, &
&               j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x&
&               (l, j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2&
&               ), x(i, j, n, 3), vp3)
          call volpym(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, &
&               m, n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2&
&               ), x(l, m, k, 3), vp4)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x&
&               (l, m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2&
&               ), x(l, j, k, 3), vp5)
          call volpym(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, &
&               j, n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2&
&               ), x(i, m, n, 3), vp6)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            vol(i, j, k) = vol(i, j, k)
          else
            vol(i, j, k) = -vol(i, j, k)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) vol(1, j, k)&
&          = vol(2, j, k)
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) vol(ie, j, k&
&         ) = vol(il, j, k)
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) vol(i, 1, k)&
&          = vol(i, 2, k)
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) vol(i, je, k&
&         ) = vol(i, jl, k)
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) vol(i, j, 1)&
&          = vol(i, j, 2)
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) vol(i, j, ke&
&         ) = vol(i, j, kl)
      end do
    end do

  contains
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,     
!         whose coordinates are set in the subroutine metric itself,   
!         is the top node and a-b-c-d is the quadrilateral surface.    
!         it is assumed that the cross product vca * vdb points in     
!         the direction of the top node. here vca is the diagonal      
!         running from node c to node a and vdb the diagonal from      
!         node d to node b.                                            
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block
!  differentiation of volume_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *x *vol
!   with respect to varying inputs: *x
!   plus diff mem management of: x:in vol:in
  subroutine volume_block_b()
! this is copy of metric.f90. it was necessary to copy this file
! since there is debugging stuff in the original that is not
! necessary for ad.
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: thresvolume=1.e-2_realtype
    real(kind=realtype), parameter :: halocellratio=1e-10_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
    real(kind=realtype) :: xpd, ypd, zpd, vp1d, vp2d, vp3d, vp4d, vp5d, &
&   vp6d
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic abs
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    integer :: branch
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
! compute the volumes. the hexahedron is split into 6 pyramids
! whose volumes are computed. the volume is positive for a
! right handed block.
! initialize the volumes to zero. the reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
    vol = zero
    do k=1,ke
      call pushinteger4(n)
      n = k - 1
      do j=1,je
        call pushinteger4(m)
        m = j - 1
        do i=1,ie
          l = i - 1
! compute the coordinates of the center of gravity.
          call pushreal8(xp)
          xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j&
&           , n, 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n&
&           , 1))
          call pushreal8(yp)
          yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j&
&           , n, 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n&
&           , 2))
          call pushreal8(zp)
          zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j&
&           , n, 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n&
&           , 3))
! compute the volumes of the 6 sub pyramids. the
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x&
&               (i, m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2&
&               ), x(i, m, k, 3), vp1)
          call volpym(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, &
&               m, k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2&
&               ), x(l, j, n, 3), vp2)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, &
&               j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x&
&               (l, j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2&
&               ), x(i, j, n, 3), vp3)
          call volpym(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, &
&               m, n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2&
&               ), x(l, m, k, 3), vp4)
          call volpym(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, &
&               m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x&
&               (l, m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2&
&               ), x(l, j, k, 3), vp5)
          call volpym(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, &
&               j, n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x&
&               (l, m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2&
&               ), x(i, m, n, 3), vp6)
! set the volume to 1/6 of the sum of the volumes of the
! pyramid. remember that volpym computes 6 times the
! volume.
          vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
          if (vol(i, j, k) .ge. 0.) then
            call pushcontrol1b(0)
            vol(i, j, k) = vol(i, j, k)
          else
            vol(i, j, k) = -vol(i, j, k)
            call pushcontrol1b(1)
          end if
        end do
      end do
    end do
! some additional safety stuff for halo volumes.
    do k=2,kl
      do j=2,jl
        if (vol(1, j, k)/vol(2, j, k) .lt. halocellratio) then
          vol(1, j, k) = vol(2, j, k)
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (vol(ie, j, k)/vol(il, j, k) .lt. halocellratio) then
          tmp = vol(il, j, k)
          vol(ie, j, k) = tmp
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do
    end do
    do k=2,kl
      do i=1,ie
        if (vol(i, 1, k)/vol(i, 2, k) .lt. halocellratio) then
          vol(i, 1, k) = vol(i, 2, k)
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (vol(i, je, k)/vol(i, jl, k) .lt. halocellratio) then
          tmp0 = vol(i, jl, k)
          vol(i, je, k) = tmp0
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do
    end do
    do j=1,je
      do i=1,ie
        if (vol(i, j, 1)/vol(i, j, 2) .lt. halocellratio) then
          vol(i, j, 1) = vol(i, j, 2)
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (vol(i, j, ke)/vol(i, j, kl) .lt. halocellratio) then
          tmp1 = vol(i, j, kl)
          vol(i, j, ke) = tmp1
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
      end do
    end do
    do j=je,1,-1
      do i=ie,1,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          tmpd1 = vold(i, j, ke)
          vold(i, j, ke) = 0.0_8
          vold(i, j, kl) = vold(i, j, kl) + tmpd1
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          vold(i, j, 2) = vold(i, j, 2) + vold(i, j, 1)
          vold(i, j, 1) = 0.0_8
        end if
      end do
    end do
    do k=kl,2,-1
      do i=ie,1,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          tmpd0 = vold(i, je, k)
          vold(i, je, k) = 0.0_8
          vold(i, jl, k) = vold(i, jl, k) + tmpd0
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          vold(i, 2, k) = vold(i, 2, k) + vold(i, 1, k)
          vold(i, 1, k) = 0.0_8
        end if
      end do
    end do
    do k=kl,2,-1
      do j=jl,2,-1
        call popcontrol1b(branch)
        if (branch .ne. 0) then
          tmpd = vold(ie, j, k)
          vold(ie, j, k) = 0.0_8
          vold(il, j, k) = vold(il, j, k) + tmpd
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          vold(2, j, k) = vold(2, j, k) + vold(1, j, k)
          vold(1, j, k) = 0.0_8
        end if
      end do
    end do
    vp1d = 0.0_8
    vp2d = 0.0_8
    vp3d = 0.0_8
    vp4d = 0.0_8
    vp5d = 0.0_8
    vp6d = 0.0_8
    do k=ke,1,-1
      do j=je,1,-1
        do i=ie,1,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) vold(i, j, k) = -vold(i, j, k)
          tempd = sixth*vold(i, j, k)
          vp1d = vp1d + tempd
          vp2d = vp2d + tempd
          vp3d = vp3d + tempd
          vp4d = vp4d + tempd
          vp5d = vp5d + tempd
          vp6d = vp6d + tempd
          vold(i, j, k) = 0.0_8
          l = i - 1
          zpd = 0.0_8
          ypd = 0.0_8
          xpd = 0.0_8
          call volpym_b(x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd&
&                 (i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), x(l, j, n&
&                 , 1), xd(l, j, n, 1), x(l, j, n, 2), xd(l, j, n, 2), x&
&                 (l, j, n, 3), xd(l, j, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(i, m, n, 1), xd(i, m, n, 1), x(i, m&
&                 , n, 2), xd(i, m, n, 2), x(i, m, n, 3), xd(i, m, n, 3)&
&                 , vp6, vp6d)
          vp6d = 0.0_8
          call volpym_b(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, m, k&
&                 , 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i, m, k, 2), x&
&                 (i, m, k, 3), xd(i, m, k, 3), x(l, m, k, 1), xd(l, m, &
&                 k, 1), x(l, m, k, 2), xd(l, m, k, 2), x(l, m, k, 3), &
&                 xd(l, m, k, 3), x(l, j, k, 1), xd(l, j, k, 1), x(l, j&
&                 , k, 2), xd(l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3)&
&                 , vp5, vp5d)
          vp5d = 0.0_8
          call volpym_b(x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd&
&                 (i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), x(i, m, n&
&                 , 1), xd(i, m, n, 1), x(i, m, n, 2), xd(i, m, n, 2), x&
&                 (i, m, n, 3), xd(i, m, n, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, m, k, 1), xd(l, m, k, 1), x(l, m&
&                 , k, 2), xd(l, m, k, 2), x(l, m, k, 3), xd(l, m, k, 3)&
&                 , vp4, vp4d)
          vp4d = 0.0_8
          call volpym_b(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(l, j, k&
&                 , 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l, j, k, 2), x&
&                 (l, j, k, 3), xd(l, j, k, 3), x(l, j, n, 1), xd(l, j, &
&                 n, 1), x(l, j, n, 2), xd(l, j, n, 2), x(l, j, n, 3), &
&                 xd(l, j, n, 3), x(i, j, n, 1), xd(i, j, n, 1), x(i, j&
&                 , n, 2), xd(i, j, n, 2), x(i, j, n, 3), xd(i, j, n, 3)&
&                 , vp3, vp3d)
          vp3d = 0.0_8
          call volpym_b(x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd&
&                 (l, j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), x(l, m, k&
&                 , 1), xd(l, m, k, 1), x(l, m, k, 2), xd(l, m, k, 2), x&
&                 (l, m, k, 3), xd(l, m, k, 3), x(l, m, n, 1), xd(l, m, &
&                 n, 1), x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), &
&                 xd(l, m, n, 3), x(l, j, n, 1), xd(l, j, n, 1), x(l, j&
&                 , n, 2), xd(l, j, n, 2), x(l, j, n, 3), xd(l, j, n, 3)&
&                 , vp2, vp2d)
          vp2d = 0.0_8
          call volpym_b(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd&
&                 (i, j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, j, n&
&                 , 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i, j, n, 2), x&
&                 (i, j, n, 3), xd(i, j, n, 3), x(i, m, n, 1), xd(i, m, &
&                 n, 1), x(i, m, n, 2), xd(i, m, n, 2), x(i, m, n, 3), &
&                 xd(i, m, n, 3), x(i, m, k, 1), xd(i, m, k, 1), x(i, m&
&                 , k, 2), xd(i, m, k, 2), x(i, m, k, 3), xd(i, m, k, 3)&
&                 , vp1, vp1d)
          vp1d = 0.0_8
          call popreal8(zp)
          tempd0 = eighth*zpd
          xd(i, j, k, 3) = xd(i, j, k, 3) + tempd0
          xd(i, m, k, 3) = xd(i, m, k, 3) + tempd0
          xd(i, m, n, 3) = xd(i, m, n, 3) + tempd0
          xd(i, j, n, 3) = xd(i, j, n, 3) + tempd0
          xd(l, j, k, 3) = xd(l, j, k, 3) + tempd0
          xd(l, m, k, 3) = xd(l, m, k, 3) + tempd0
          xd(l, m, n, 3) = xd(l, m, n, 3) + tempd0
          xd(l, j, n, 3) = xd(l, j, n, 3) + tempd0
          call popreal8(yp)
          tempd1 = eighth*ypd
          xd(i, j, k, 2) = xd(i, j, k, 2) + tempd1
          xd(i, m, k, 2) = xd(i, m, k, 2) + tempd1
          xd(i, m, n, 2) = xd(i, m, n, 2) + tempd1
          xd(i, j, n, 2) = xd(i, j, n, 2) + tempd1
          xd(l, j, k, 2) = xd(l, j, k, 2) + tempd1
          xd(l, m, k, 2) = xd(l, m, k, 2) + tempd1
          xd(l, m, n, 2) = xd(l, m, n, 2) + tempd1
          xd(l, j, n, 2) = xd(l, j, n, 2) + tempd1
          call popreal8(xp)
          tempd2 = eighth*xpd
          xd(i, j, k, 1) = xd(i, j, k, 1) + tempd2
          xd(i, m, k, 1) = xd(i, m, k, 1) + tempd2
          xd(i, m, n, 1) = xd(i, m, n, 1) + tempd2
          xd(i, j, n, 1) = xd(i, j, n, 1) + tempd2
          xd(l, j, k, 1) = xd(l, j, k, 1) + tempd2
          xd(l, m, k, 1) = xd(l, m, k, 1) + tempd2
          xd(l, m, n, 1) = xd(l, m, n, 1) + tempd2
          xd(l, j, n, 1) = xd(l, j, n, 1) + tempd2
        end do
        call popinteger4(m)
      end do
      call popinteger4(n)
    end do

  contains
!  differentiation of volpym in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: xp yp zp xa xb xc xd ya yb
!                yc yd za zb zc zd volume
!   with respect to varying inputs: xp yp zp xa xb xc xd ya yb
!                yc yd za zb zc zd
    subroutine volpym_b(xa, xad, ya, yad, za, zad, xb, xbd, yb, ybd, zb&
&     , zbd, xc, xcd, yc, ycd, zc, zcd, xd, xdd, yd, ydd, zd, zdd, &
&     volume, volumed)
!
!         volpym computes 6 times the volume of a pyramid. node p,     
!         whose coordinates are set in the subroutine metric itself,   
!         is the top node and a-b-c-d is the quadrilateral surface.    
!         it is assumed that the cross product vca * vdb points in     
!         the direction of the top node. here vca is the diagonal      
!         running from node c to node a and vdb the diagonal from      
!         node d to node b.                                            
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
      real(kind=realtype) :: volumed
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype) :: xad, yad, zad, xbd, ybd, zbd
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      real(kind=realtype) :: xcd, ycd, zcd, xdd, ydd, zdd
      real(kind=realtype) :: tempd
      real(kind=realtype) :: tempd7
      real(kind=realtype) :: tempd6
      real(kind=realtype) :: tempd5
      real(kind=realtype) :: tempd4
      real(kind=realtype) :: tempd3
      real(kind=realtype) :: tempd2
      real(kind=realtype) :: tempd1
      real(kind=realtype) :: tempd0
      tempd = ((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))*volumed
      tempd0 = -(fourth*tempd)
      tempd1 = (xp-fourth*(xa+xb+xc+xd))*volumed
      tempd2 = ((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))*volumed
      tempd3 = -(fourth*tempd2)
      tempd4 = (yp-fourth*(ya+yb+yc+yd))*volumed
      tempd5 = ((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))*volumed
      tempd6 = -(fourth*tempd5)
      tempd7 = (zp-fourth*(za+zb+zc+zd))*volumed
      xpd = xpd + tempd
      xad = xad + (yb-yd)*tempd7 - (zb-zd)*tempd4 + tempd0
      xbd = xbd + (za-zc)*tempd4 - (ya-yc)*tempd7 + tempd0
      xcd = xcd + (zb-zd)*tempd4 - (yb-yd)*tempd7 + tempd0
      xdd = xdd + (ya-yc)*tempd7 - (za-zc)*tempd4 + tempd0
      yad = yad + tempd3 - (xb-xd)*tempd7 + (zb-zd)*tempd1
      ycd = ycd + (xb-xd)*tempd7 + tempd3 - (zb-zd)*tempd1
      zbd = zbd + tempd6 - (xa-xc)*tempd4 + (ya-yc)*tempd1
      zdd = zdd + tempd6 + (xa-xc)*tempd4 - (ya-yc)*tempd1
      zad = zad + tempd6 + (xb-xd)*tempd4 - (yb-yd)*tempd1
      zcd = zcd + tempd6 - (xb-xd)*tempd4 + (yb-yd)*tempd1
      ybd = ybd + (xa-xc)*tempd7 + tempd3 - (za-zc)*tempd1
      ydd = ydd + tempd3 - (xa-xc)*tempd7 + (za-zc)*tempd1
      ypd = ypd + tempd2
      zpd = zpd + tempd5
    end subroutine volpym_b
    subroutine volpym(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
&     volume)
!
!         volpym computes 6 times the volume of a pyramid. node p,     
!         whose coordinates are set in the subroutine metric itself,   
!         is the top node and a-b-c-d is the quadrilateral surface.    
!         it is assumed that the cross product vca * vdb points in     
!         the direction of the top node. here vca is the diagonal      
!         running from node c to node a and vdb the diagonal from      
!         node d to node b.                                            
!
      use precision
      implicit none
!
!        function type.
!
      real(kind=realtype) :: volume
!
!        function arguments.
!
      real(kind=realtype), intent(in) :: xa, ya, za, xb, yb, zb
      real(kind=realtype), intent(in) :: xc, yc, zc, xd, yd, zd
      volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd&
&       )) + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))&
&       + (zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
    end subroutine volpym
  end subroutine volume_block_b
!  differentiation of metric_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *x *si *sj *sk
!   with respect to varying inputs: *x
!   plus diff mem management of: x:in si:in sj:in sk:in
  subroutine metric_block_b()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    real(kind=realtype), dimension(3) :: v1d, v2d
    intrinsic mod
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
    else
      fact = -half
    end if
    call pushreal8array(v1, 3)
    call pushreal8array(v2, 3)
!
!  computation of the face normals in i-, j- and k-direction. 
!  formula's are valid for a right handed block; for a left   
!  handed block the correct orientation is obtained via fact. 
!  the normals point in the direction of increasing index.    
!  the absolute value of fact is 0.5, because the cross       
!  product of the two diagonals is twice the normal vector.   
!  note that also the normals of the first level halo cells   
!  are computed. these are needed for the viscous fluxes.     
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8array(v1, 3)
    call pushreal8array(v2, 3)
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8array(v1, 3)
    call pushreal8array(v2, 3)
    call pushinteger4(l)
    call pushinteger4(m)
    v1d = 0.0_8
    v2d = 0.0_8
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      tempd5 = fact*skd(i, j, k, 3)
      v1d(1) = v1d(1) + v2(2)*tempd5
      v2d(2) = v2d(2) + v1(1)*tempd5
      v1d(2) = v1d(2) - v2(1)*tempd5
      skd(i, j, k, 3) = 0.0_8
      tempd6 = fact*skd(i, j, k, 2)
      v2d(1) = v2d(1) + v1(3)*tempd6 - v1(2)*tempd5
      v1d(3) = v1d(3) + v2(1)*tempd6
      v1d(1) = v1d(1) - v2(3)*tempd6
      skd(i, j, k, 2) = 0.0_8
      tempd7 = fact*skd(i, j, k, 1)
      v2d(3) = v2d(3) + v1(2)*tempd7 - v1(1)*tempd6
      v1d(2) = v1d(2) + v2(3)*tempd7
      v1d(3) = v1d(3) - v2(2)*tempd7
      v2d(2) = v2d(2) - v1(3)*tempd7
      skd(i, j, k, 1) = 0.0_8
      xd(l, j, k, 3) = xd(l, j, k, 3) + v2d(3)
      xd(i, m, k, 3) = xd(i, m, k, 3) - v2d(3)
      v2d(3) = 0.0_8
      xd(l, j, k, 2) = xd(l, j, k, 2) + v2d(2)
      xd(i, m, k, 2) = xd(i, m, k, 2) - v2d(2)
      v2d(2) = 0.0_8
      xd(l, j, k, 1) = xd(l, j, k, 1) + v2d(1)
      xd(i, m, k, 1) = xd(i, m, k, 1) - v2d(1)
      v2d(1) = 0.0_8
      xd(i, j, k, 3) = xd(i, j, k, 3) + v1d(3)
      xd(l, m, k, 3) = xd(l, m, k, 3) - v1d(3)
      v1d(3) = 0.0_8
      xd(i, j, k, 2) = xd(i, j, k, 2) + v1d(2)
      xd(l, m, k, 2) = xd(l, m, k, 2) - v1d(2)
      v1d(2) = 0.0_8
      xd(i, j, k, 1) = xd(i, j, k, 1) + v1d(1)
      xd(l, m, k, 1) = xd(l, m, k, 1) - v1d(1)
      v1d(1) = 0.0_8
    end do
    call popinteger4(m)
    call popinteger4(l)
    call popreal8array(v2, 3)
    call popreal8array(v1, 3)
    call popinteger4(j)
    call popinteger4(i)
    call lookreal8array(v2, 3)
    call lookreal8array(v1, 3)
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      tempd2 = fact*sjd(i, j, k, 3)
      v1d(1) = v1d(1) + v2(2)*tempd2
      v2d(2) = v2d(2) + v1(1)*tempd2
      v1d(2) = v1d(2) - v2(1)*tempd2
      sjd(i, j, k, 3) = 0.0_8
      tempd3 = fact*sjd(i, j, k, 2)
      v2d(1) = v2d(1) + v1(3)*tempd3 - v1(2)*tempd2
      v1d(3) = v1d(3) + v2(1)*tempd3
      v1d(1) = v1d(1) - v2(3)*tempd3
      sjd(i, j, k, 2) = 0.0_8
      tempd4 = fact*sjd(i, j, k, 1)
      v2d(3) = v2d(3) + v1(2)*tempd4 - v1(1)*tempd3
      v1d(2) = v1d(2) + v2(3)*tempd4
      v1d(3) = v1d(3) - v2(2)*tempd4
      v2d(2) = v2d(2) - v1(3)*tempd4
      sjd(i, j, k, 1) = 0.0_8
      xd(l, j, n, 3) = xd(l, j, n, 3) + v2d(3)
      xd(i, j, k, 3) = xd(i, j, k, 3) - v2d(3)
      v2d(3) = 0.0_8
      xd(l, j, n, 2) = xd(l, j, n, 2) + v2d(2)
      xd(i, j, k, 2) = xd(i, j, k, 2) - v2d(2)
      v2d(2) = 0.0_8
      xd(l, j, n, 1) = xd(l, j, n, 1) + v2d(1)
      xd(i, j, k, 1) = xd(i, j, k, 1) - v2d(1)
      v2d(1) = 0.0_8
      xd(i, j, n, 3) = xd(i, j, n, 3) + v1d(3)
      xd(l, j, k, 3) = xd(l, j, k, 3) - v1d(3)
      v1d(3) = 0.0_8
      xd(i, j, n, 2) = xd(i, j, n, 2) + v1d(2)
      xd(l, j, k, 2) = xd(l, j, k, 2) - v1d(2)
      v1d(2) = 0.0_8
      xd(i, j, n, 1) = xd(i, j, n, 1) + v1d(1)
      xd(l, j, k, 1) = xd(l, j, k, 1) - v1d(1)
      v1d(1) = 0.0_8
    end do
    call popreal8array(v2, 3)
    call popreal8array(v1, 3)
    call popinteger4(j)
    call popinteger4(i)
    call popreal8array(v2, 3)
    call popreal8array(v1, 3)
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      tempd = fact*sid(i, j, k, 3)
      v1d(1) = v1d(1) + v2(2)*tempd
      v2d(2) = v2d(2) + v1(1)*tempd
      v1d(2) = v1d(2) - v2(1)*tempd
      sid(i, j, k, 3) = 0.0_8
      tempd0 = fact*sid(i, j, k, 2)
      v2d(1) = v2d(1) + v1(3)*tempd0 - v1(2)*tempd
      v1d(3) = v1d(3) + v2(1)*tempd0
      v1d(1) = v1d(1) - v2(3)*tempd0
      sid(i, j, k, 2) = 0.0_8
      tempd1 = fact*sid(i, j, k, 1)
      v2d(3) = v2d(3) + v1(2)*tempd1 - v1(1)*tempd0
      v1d(2) = v1d(2) + v2(3)*tempd1
      v1d(3) = v1d(3) - v2(2)*tempd1
      v2d(2) = v2d(2) - v1(3)*tempd1
      sid(i, j, k, 1) = 0.0_8
      xd(i, j, k, 3) = xd(i, j, k, 3) + v2d(3)
      xd(i, m, n, 3) = xd(i, m, n, 3) - v2d(3)
      v2d(3) = 0.0_8
      xd(i, j, k, 2) = xd(i, j, k, 2) + v2d(2)
      xd(i, m, n, 2) = xd(i, m, n, 2) - v2d(2)
      v2d(2) = 0.0_8
      xd(i, j, k, 1) = xd(i, j, k, 1) + v2d(1)
      xd(i, m, n, 1) = xd(i, m, n, 1) - v2d(1)
      v2d(1) = 0.0_8
      xd(i, j, n, 3) = xd(i, j, n, 3) + v1d(3)
      xd(i, m, k, 3) = xd(i, m, k, 3) - v1d(3)
      v1d(3) = 0.0_8
      xd(i, j, n, 2) = xd(i, j, n, 2) + v1d(2)
      xd(i, m, k, 2) = xd(i, m, k, 2) - v1d(2)
      v1d(2) = 0.0_8
      xd(i, j, n, 1) = xd(i, j, n, 1) + v1d(1)
      xd(i, m, k, 1) = xd(i, m, k, 1) - v1d(1)
      v1d(1) = 0.0_8
    end do
  end subroutine metric_block_b
  subroutine metric_block()
    use constants
    use blockpointers
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, k, n, m, l, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype), dimension(3) :: v1, v2
    intrinsic mod
! set the factor in the surface normals computation. for a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! the formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
    if (righthanded) then
      fact = half
    else
      fact = -half
    end if
!
!  computation of the face normals in i-, j- and k-direction. 
!  formula's are valid for a right handed block; for a left   
!  handed block the correct orientation is obtained via fact. 
!  the normals point in the direction of increasing index.    
!  the absolute value of fact is 0.5, because the cross       
!  product of the two diagonals is twice the normal vector.   
!  note that also the normals of the first level halo cells   
!  are computed. these are needed for the viscous fluxes.     
!
! projected areas of cell faces in the i direction.
    do ii=0,ke*je*(ie+1)-1
! 0:ie
      i = mod(ii, ie + 1) + 0
!1:je
      j = mod(ii/(ie+1), je) + 1
!1:ke
      k = ii/((ie+1)*je) + 1
      n = k - 1
      m = j - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
      v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
      v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
      v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
      v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
      v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the j direction
    do ii=0,ke*(je+1)*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!0:je
      j = mod(ii/ie, je + 1) + 0
!1:ke
      k = ii/(ie*(je+1)) + 1
      n = k - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
      v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
      v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
      v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
      v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
      v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
! projected areas of cell faces in the k direction.
    do ii=0,(ke+1)*je*ie-1
! 1:ie
      i = mod(ii, ie) + 1
!1:je
      j = mod(ii/ie, je) + 1
!0:ke
      k = ii/(ie*je) + 0
      m = j - 1
      l = i - 1
! determine the two diagonal vectors of the face.
      v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
      v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
      v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
      v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
      v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
      v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! the face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
      sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
      sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
      sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
    end do
  end subroutine metric_block
!  differentiation of boundarynormals in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *si *sj *sk *(*bcdata.norm)
!   with respect to varying inputs: *si *sj *sk
!   plus diff mem management of: si:in sj:in sk:in bcdata:in *bcdata.norm:in
  subroutine boundarynormals_b()
!  the unit normals on the boundary faces. these always point 
!  out of the domain, so a multiplication by -1 is needed for 
!  the imin, jmin and kmin boundaries.                        
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: factd
    real(kind=realtype) :: xxp, yyp, zzp
    real(kind=realtype) :: xxpd, yypd, zzpd
    intrinsic mod
    intrinsic sqrt
    integer :: branch
    real(kind=realtype) :: tempd
    zzpd = 0.0_8
    yypd = 0.0_8
    xxpd = 0.0_8
    do mm=1,nbocos
      call pushinteger4(i)
      call pushreal8(fact)
      call pushreal8(mult)
      call pushreal8(zzp)
      call pushreal8(yyp)
      call pushreal8(xxp)
      call pushinteger4(mm)
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
        if (fact .gt. zero) fact = mult/fact
! compute the unit normal.
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
      call popinteger4(mm)
      call lookreal8(xxp)
      call lookreal8(yyp)
      call lookreal8(zzp)
      call lookreal8(mult)
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
          call pushcontrol3b(1)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
          call pushcontrol3b(2)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
          call pushcontrol3b(3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
          call pushcontrol3b(4)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
          call pushcontrol3b(5)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
          call pushcontrol3b(6)
        case default
          call pushcontrol3b(0)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
        if (fact .gt. zero) then
          call pushreal8(fact)
          fact = mult/fact
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        factd = zzp*bcdatad(mm)%norm(i, j, 3)
        zzpd = zzpd + fact*bcdatad(mm)%norm(i, j, 3)
        bcdatad(mm)%norm(i, j, 3) = 0.0_8
        factd = factd + yyp*bcdatad(mm)%norm(i, j, 2)
        yypd = yypd + fact*bcdatad(mm)%norm(i, j, 2)
        bcdatad(mm)%norm(i, j, 2) = 0.0_8
        factd = factd + xxp*bcdatad(mm)%norm(i, j, 1)
        xxpd = xxpd + fact*bcdatad(mm)%norm(i, j, 1)
        bcdatad(mm)%norm(i, j, 1) = 0.0_8
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(fact)
          factd = -(mult*factd/fact**2)
        end if
        if (xxp**2 + yyp**2 + zzp**2 .eq. 0.0_8) then
          tempd = 0.0
        else
          tempd = factd/(2.0*sqrt(xxp**2+yyp**2+zzp**2))
        end if
        xxpd = xxpd + 2*xxp*tempd
        yypd = yypd + 2*yyp*tempd
        zzpd = zzpd + 2*zzp*tempd
        call popcontrol3b(branch)
        if (branch .lt. 3) then
          if (branch .ne. 0) then
            if (branch .eq. 1) then
              sid(1, i, j, 3) = sid(1, i, j, 3) + zzpd
              sid(1, i, j, 2) = sid(1, i, j, 2) + yypd
              sid(1, i, j, 1) = sid(1, i, j, 1) + xxpd
              zzpd = 0.0_8
              yypd = 0.0_8
              xxpd = 0.0_8
            else
              sid(il, i, j, 3) = sid(il, i, j, 3) + zzpd
              sid(il, i, j, 2) = sid(il, i, j, 2) + yypd
              sid(il, i, j, 1) = sid(il, i, j, 1) + xxpd
              zzpd = 0.0_8
              yypd = 0.0_8
              xxpd = 0.0_8
            end if
          end if
        else if (branch .lt. 5) then
          if (branch .eq. 3) then
            sjd(i, 1, j, 3) = sjd(i, 1, j, 3) + zzpd
            sjd(i, 1, j, 2) = sjd(i, 1, j, 2) + yypd
            sjd(i, 1, j, 1) = sjd(i, 1, j, 1) + xxpd
            zzpd = 0.0_8
            yypd = 0.0_8
            xxpd = 0.0_8
          else
            sjd(i, jl, j, 3) = sjd(i, jl, j, 3) + zzpd
            sjd(i, jl, j, 2) = sjd(i, jl, j, 2) + yypd
            sjd(i, jl, j, 1) = sjd(i, jl, j, 1) + xxpd
            zzpd = 0.0_8
            yypd = 0.0_8
            xxpd = 0.0_8
          end if
        else if (branch .eq. 5) then
          skd(i, j, 1, 3) = skd(i, j, 1, 3) + zzpd
          skd(i, j, 1, 2) = skd(i, j, 1, 2) + yypd
          skd(i, j, 1, 1) = skd(i, j, 1, 1) + xxpd
          zzpd = 0.0_8
          yypd = 0.0_8
          xxpd = 0.0_8
        else
          skd(i, j, kl, 3) = skd(i, j, kl, 3) + zzpd
          skd(i, j, kl, 2) = skd(i, j, kl, 2) + yypd
          skd(i, j, kl, 1) = skd(i, j, kl, 1) + xxpd
          zzpd = 0.0_8
          yypd = 0.0_8
          xxpd = 0.0_8
        end if
      end do
      call popreal8(xxp)
      call popreal8(yyp)
      call popreal8(zzp)
      call popreal8(mult)
      call popreal8(fact)
      call popinteger4(i)
    end do
  end subroutine boundarynormals_b
  subroutine boundarynormals()
!  the unit normals on the boundary faces. these always point 
!  out of the domain, so a multiplication by -1 is needed for 
!  the imin, jmin and kmin boundaries.                        
!
    use constants
    use blockpointers
    use cgnsgrid
    use communication
    use inputtimespectral
    implicit none
! local variables.
    integer(kind=inttype) :: i, j, ii
    integer(kind=inttype) :: mm
    real(kind=realtype) :: fact, mult
    real(kind=realtype) :: xxp, yyp, zzp
    intrinsic mod
    intrinsic sqrt
!loop over the boundary subfaces of this block.
bocoloop:do mm=1,nbocos
! loop over the boundary faces of the subface.
      do ii=0,(bcdata(mm)%jcend-bcdata(mm)%jcbeg+1)*(bcdata(mm)%icend-&
&         bcdata(mm)%icbeg+1)-1
        i = mod(ii, bcdata(mm)%icend - bcdata(mm)%icbeg + 1) + bcdata(mm&
&         )%icbeg
        j = ii/(bcdata(mm)%icend-bcdata(mm)%icbeg+1) + bcdata(mm)%jcbeg
        select case  (bcfaceid(mm)) 
        case (imin) 
          mult = -one
          xxp = si(1, i, j, 1)
          yyp = si(1, i, j, 2)
          zzp = si(1, i, j, 3)
        case (imax) 
          mult = one
          xxp = si(il, i, j, 1)
          yyp = si(il, i, j, 2)
          zzp = si(il, i, j, 3)
        case (jmin) 
          mult = -one
          xxp = sj(i, 1, j, 1)
          yyp = sj(i, 1, j, 2)
          zzp = sj(i, 1, j, 3)
        case (jmax) 
          mult = one
          xxp = sj(i, jl, j, 1)
          yyp = sj(i, jl, j, 2)
          zzp = sj(i, jl, j, 3)
        case (kmin) 
          mult = -one
          xxp = sk(i, j, 1, 1)
          yyp = sk(i, j, 1, 2)
          zzp = sk(i, j, 1, 3)
        case (kmax) 
          mult = one
          xxp = sk(i, j, kl, 1)
          yyp = sk(i, j, kl, 2)
          zzp = sk(i, j, kl, 3)
        end select
! compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        fact = sqrt(xxp*xxp + yyp*yyp + zzp*zzp)
        if (fact .gt. zero) fact = mult/fact
! compute the unit normal.
        bcdata(mm)%norm(i, j, 1) = fact*xxp
        bcdata(mm)%norm(i, j, 2) = fact*yyp
        bcdata(mm)%norm(i, j, 3) = fact*zzp
      end do
    end do bocoloop
  end subroutine boundarynormals
!  differentiation of xhalo_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *x
!   with respect to varying inputs: *x
!   rw status of diff variables: *x:in-out
!   plus diff mem management of: x:in
  subroutine xhalo_block_b()
!
!       xhalo determines the coordinates of the nodal halo's.          
!       first it sets all halo coordinates by simple extrapolation,    
!       then the symmetry planes are treated (also the unit normal of  
!       symmetry planes are determined) and finally an exchange is     
!       made for the internal halo's.                                  
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype) :: dotd
    real(kind=realtype), dimension(3) :: v1, v2, norm
    real(kind=realtype), dimension(3) :: v1d
    intrinsic sqrt
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmp2
    real(kind=realtype) :: tmp3
    real(kind=realtype) :: tmp4
    real(kind=realtype) :: tmp5
    real(kind=realtype) :: tmp6
    real(kind=realtype) :: tmp7
    real(kind=realtype) :: tmp8
    real(kind=realtype) :: tmp9
    real(kind=realtype) :: tmp10
    real(kind=realtype) :: tmp11
    real(kind=realtype) :: tmp12
    real(kind=realtype) :: tmp13
    real(kind=realtype) :: tmp14
    real(kind=realtype) :: tmp15
    real(kind=realtype) :: tmp16
    integer :: ad_from
    integer :: ad_to
    integer :: ad_from0
    integer :: ad_to0
    integer :: ad_from1
    integer :: ad_to1
    integer :: ad_from2
    integer :: ad_to2
    integer :: ad_from3
    integer :: ad_to3
    integer :: ad_from4
    integer :: ad_to4
    integer :: ad_from5
    integer :: ad_to5
    integer :: ad_from6
    integer :: ad_to6
    integer :: ad_from7
    integer :: ad_to7
    integer :: ad_from8
    integer :: ad_to8
    integer :: ad_from9
    integer :: ad_to9
    integer :: ad_from10
    integer :: ad_to10
    integer :: branch
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd16
    real(kind=realtype) :: tmpd15
    real(kind=realtype) :: tmpd14
    real(kind=realtype) :: tmpd13
    real(kind=realtype) :: tmpd12
    real(kind=realtype) :: tmpd11
    real(kind=realtype) :: tmpd10
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tmpd9
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tmpd8
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tmpd7
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tmpd6
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tmpd5
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd4
    real(kind=realtype) :: tmpd3
    real(kind=realtype) :: tmpd2
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
!
!           mirror the halo coordinates adjacent to the symmetry       
!           planes                                                     
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        call pushreal8(norm(1))
        norm(1) = bcdata(mm)%symnorm(1)
        call pushreal8(norm(2))
        norm(2) = bcdata(mm)%symnorm(2)
        call pushreal8(norm(3))
        norm(3) = bcdata(mm)%symnorm(3)
        length = sqrt(norm(1)**2 + norm(2)**2 + norm(3)**2)
! compute the unit normal of the subface.
        call pushreal8(norm(1))
        norm(1) = norm(1)/length
        call pushreal8(norm(2))
        norm(2) = norm(2)/length
        call pushreal8(norm(3))
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from0 = jbeg
            do j=ad_from0,jend
              ad_from = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from0)
            call pushcontrol4b(7)
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from2 = jbeg
            do j=ad_from2,jend
              ad_from1 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from1)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from2)
            call pushcontrol4b(6)
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from4 = jbeg
            do j=ad_from4,jend
              ad_from3 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from3)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from4)
            call pushcontrol4b(5)
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from6 = jbeg
            do j=ad_from6,jend
              ad_from5 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from5)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from6)
            call pushcontrol4b(4)
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from8 = jbeg
            do j=ad_from8,jend
              ad_from7 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from7)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from8)
            call pushcontrol4b(3)
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            ad_from10 = jbeg
            do j=ad_from10,jend
              ad_from9 = ibeg
              i = iend + 1
              call pushinteger4(i - 1)
              call pushinteger4(ad_from9)
            end do
            call pushinteger4(j - 1)
            call pushinteger4(ad_from10)
            call pushcontrol4b(2)
          case default
            call pushcontrol4b(8)
          end select
        else
          call pushcontrol4b(1)
        end if
      else
        call pushcontrol4b(0)
      end if
    end do loopbocos
    v1d = 0.0_8
    do 100 mm=nbocos,1,-1
      call popcontrol4b(branch)
      if (branch .lt. 4) then
        if (branch .lt. 2) then
          if (branch .eq. 0) goto 100
        else if (branch .eq. 2) then
          call popinteger4(ad_from10)
          call popinteger4(ad_to10)
          do j=ad_to10,ad_from10,-1
            call popinteger4(ad_from9)
            call popinteger4(ad_to9)
            do i=ad_to9,ad_from9,-1
              tmpd14 = xd(i, j, ke, 3)
              xd(i, j, ke, 3) = 0.0_8
              xd(i, j, nz, 3) = xd(i, j, nz, 3) + tmpd14
              tmpd15 = xd(i, j, ke, 2)
              xd(i, j, ke, 2) = 0.0_8
              xd(i, j, nz, 2) = xd(i, j, nz, 2) + tmpd15
              tmpd16 = xd(i, j, ke, 1)
              dotd = norm(2)*tmpd15 + norm(1)*tmpd16 + norm(3)*tmpd14
              xd(i, j, ke, 1) = 0.0_8
              xd(i, j, nz, 1) = xd(i, j, nz, 1) + tmpd16
              tempd4 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd4
              v1d(2) = v1d(2) + norm(2)*tempd4
              v1d(3) = v1d(3) + norm(3)*tempd4
              xd(i, j, kl, 3) = xd(i, j, kl, 3) + v1d(3)
              xd(i, j, nz, 3) = xd(i, j, nz, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, j, kl, 2) = xd(i, j, kl, 2) + v1d(2)
              xd(i, j, nz, 2) = xd(i, j, nz, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, j, kl, 1) = xd(i, j, kl, 1) + v1d(1)
              xd(i, j, nz, 1) = xd(i, j, nz, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        else
          call popinteger4(ad_from8)
          call popinteger4(ad_to8)
          do j=ad_to8,ad_from8,-1
            call popinteger4(ad_from7)
            call popinteger4(ad_to7)
            do i=ad_to7,ad_from7,-1
              xd(i, j, 2, 3) = xd(i, j, 2, 3) + xd(i, j, 0, 3)
              dotd = norm(3)*xd(i, j, 0, 3)
              xd(i, j, 0, 3) = 0.0_8
              xd(i, j, 2, 2) = xd(i, j, 2, 2) + xd(i, j, 0, 2)
              dotd = dotd + norm(2)*xd(i, j, 0, 2)
              xd(i, j, 0, 2) = 0.0_8
              xd(i, j, 2, 1) = xd(i, j, 2, 1) + xd(i, j, 0, 1)
              dotd = dotd + norm(1)*xd(i, j, 0, 1)
              xd(i, j, 0, 1) = 0.0_8
              tempd3 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd3
              v1d(2) = v1d(2) + norm(2)*tempd3
              v1d(3) = v1d(3) + norm(3)*tempd3
              xd(i, j, 1, 3) = xd(i, j, 1, 3) + v1d(3)
              xd(i, j, 2, 3) = xd(i, j, 2, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, j, 1, 2) = xd(i, j, 1, 2) + v1d(2)
              xd(i, j, 2, 2) = xd(i, j, 2, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, j, 1, 1) = xd(i, j, 1, 1) + v1d(1)
              xd(i, j, 2, 1) = xd(i, j, 2, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        end if
      else if (branch .lt. 6) then
        if (branch .eq. 4) then
          call popinteger4(ad_from6)
          call popinteger4(ad_to6)
          do j=ad_to6,ad_from6,-1
            call popinteger4(ad_from5)
            call popinteger4(ad_to5)
            do i=ad_to5,ad_from5,-1
              tmpd11 = xd(i, je, j, 3)
              xd(i, je, j, 3) = 0.0_8
              xd(i, ny, j, 3) = xd(i, ny, j, 3) + tmpd11
              tmpd12 = xd(i, je, j, 2)
              xd(i, je, j, 2) = 0.0_8
              xd(i, ny, j, 2) = xd(i, ny, j, 2) + tmpd12
              tmpd13 = xd(i, je, j, 1)
              dotd = norm(2)*tmpd12 + norm(1)*tmpd13 + norm(3)*tmpd11
              xd(i, je, j, 1) = 0.0_8
              xd(i, ny, j, 1) = xd(i, ny, j, 1) + tmpd13
              tempd2 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd2
              v1d(2) = v1d(2) + norm(2)*tempd2
              v1d(3) = v1d(3) + norm(3)*tempd2
              xd(i, jl, j, 3) = xd(i, jl, j, 3) + v1d(3)
              xd(i, ny, j, 3) = xd(i, ny, j, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, jl, j, 2) = xd(i, jl, j, 2) + v1d(2)
              xd(i, ny, j, 2) = xd(i, ny, j, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, jl, j, 1) = xd(i, jl, j, 1) + v1d(1)
              xd(i, ny, j, 1) = xd(i, ny, j, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        else
          call popinteger4(ad_from4)
          call popinteger4(ad_to4)
          do j=ad_to4,ad_from4,-1
            call popinteger4(ad_from3)
            call popinteger4(ad_to3)
            do i=ad_to3,ad_from3,-1
              xd(i, 2, j, 3) = xd(i, 2, j, 3) + xd(i, 0, j, 3)
              dotd = norm(3)*xd(i, 0, j, 3)
              xd(i, 0, j, 3) = 0.0_8
              xd(i, 2, j, 2) = xd(i, 2, j, 2) + xd(i, 0, j, 2)
              dotd = dotd + norm(2)*xd(i, 0, j, 2)
              xd(i, 0, j, 2) = 0.0_8
              xd(i, 2, j, 1) = xd(i, 2, j, 1) + xd(i, 0, j, 1)
              dotd = dotd + norm(1)*xd(i, 0, j, 1)
              xd(i, 0, j, 1) = 0.0_8
              tempd1 = two*dotd
              v1d(1) = v1d(1) + norm(1)*tempd1
              v1d(2) = v1d(2) + norm(2)*tempd1
              v1d(3) = v1d(3) + norm(3)*tempd1
              xd(i, 1, j, 3) = xd(i, 1, j, 3) + v1d(3)
              xd(i, 2, j, 3) = xd(i, 2, j, 3) - v1d(3)
              v1d(3) = 0.0_8
              xd(i, 1, j, 2) = xd(i, 1, j, 2) + v1d(2)
              xd(i, 2, j, 2) = xd(i, 2, j, 2) - v1d(2)
              v1d(2) = 0.0_8
              xd(i, 1, j, 1) = xd(i, 1, j, 1) + v1d(1)
              xd(i, 2, j, 1) = xd(i, 2, j, 1) - v1d(1)
              v1d(1) = 0.0_8
            end do
          end do
        end if
      else if (branch .eq. 6) then
        call popinteger4(ad_from2)
        call popinteger4(ad_to2)
        do j=ad_to2,ad_from2,-1
          call popinteger4(ad_from1)
          call popinteger4(ad_to1)
          do i=ad_to1,ad_from1,-1
            tmpd8 = xd(ie, i, j, 3)
            xd(ie, i, j, 3) = 0.0_8
            xd(nx, i, j, 3) = xd(nx, i, j, 3) + tmpd8
            tmpd9 = xd(ie, i, j, 2)
            xd(ie, i, j, 2) = 0.0_8
            xd(nx, i, j, 2) = xd(nx, i, j, 2) + tmpd9
            tmpd10 = xd(ie, i, j, 1)
            dotd = norm(2)*tmpd9 + norm(1)*tmpd10 + norm(3)*tmpd8
            xd(ie, i, j, 1) = 0.0_8
            xd(nx, i, j, 1) = xd(nx, i, j, 1) + tmpd10
            tempd0 = two*dotd
            v1d(1) = v1d(1) + norm(1)*tempd0
            v1d(2) = v1d(2) + norm(2)*tempd0
            v1d(3) = v1d(3) + norm(3)*tempd0
            xd(il, i, j, 3) = xd(il, i, j, 3) + v1d(3)
            xd(nx, i, j, 3) = xd(nx, i, j, 3) - v1d(3)
            v1d(3) = 0.0_8
            xd(il, i, j, 2) = xd(il, i, j, 2) + v1d(2)
            xd(nx, i, j, 2) = xd(nx, i, j, 2) - v1d(2)
            v1d(2) = 0.0_8
            xd(il, i, j, 1) = xd(il, i, j, 1) + v1d(1)
            xd(nx, i, j, 1) = xd(nx, i, j, 1) - v1d(1)
            v1d(1) = 0.0_8
          end do
        end do
      else if (branch .eq. 7) then
        call popinteger4(ad_from0)
        call popinteger4(ad_to0)
        do j=ad_to0,ad_from0,-1
          call popinteger4(ad_from)
          call popinteger4(ad_to)
          do i=ad_to,ad_from,-1
            xd(2, i, j, 3) = xd(2, i, j, 3) + xd(0, i, j, 3)
            dotd = norm(3)*xd(0, i, j, 3)
            xd(0, i, j, 3) = 0.0_8
            xd(2, i, j, 2) = xd(2, i, j, 2) + xd(0, i, j, 2)
            dotd = dotd + norm(2)*xd(0, i, j, 2)
            xd(0, i, j, 2) = 0.0_8
            xd(2, i, j, 1) = xd(2, i, j, 1) + xd(0, i, j, 1)
            dotd = dotd + norm(1)*xd(0, i, j, 1)
            xd(0, i, j, 1) = 0.0_8
            tempd = two*dotd
            v1d(1) = v1d(1) + norm(1)*tempd
            v1d(2) = v1d(2) + norm(2)*tempd
            v1d(3) = v1d(3) + norm(3)*tempd
            xd(1, i, j, 3) = xd(1, i, j, 3) + v1d(3)
            xd(2, i, j, 3) = xd(2, i, j, 3) - v1d(3)
            v1d(3) = 0.0_8
            xd(1, i, j, 2) = xd(1, i, j, 2) + v1d(2)
            xd(2, i, j, 2) = xd(2, i, j, 2) - v1d(2)
            v1d(2) = 0.0_8
            xd(1, i, j, 1) = xd(1, i, j, 1) + v1d(1)
            xd(2, i, j, 1) = xd(2, i, j, 1) - v1d(1)
            v1d(1) = 0.0_8
          end do
        end do
      end if
      call popreal8(norm(3))
      call popreal8(norm(2))
      call popreal8(norm(1))
      call popreal8(norm(3))
      call popreal8(norm(2))
      call popreal8(norm(1))
 100 continue
    do j=je,0,-1
      do i=ie,0,-1
        tmpd5 = xd(i, j, ke, 3)
        xd(i, j, ke, 3) = 0.0_8
        xd(i, j, kl, 3) = xd(i, j, kl, 3) + two*tmpd5
        xd(i, j, nz, 3) = xd(i, j, nz, 3) - tmpd5
        tmpd6 = xd(i, j, ke, 2)
        xd(i, j, ke, 2) = 0.0_8
        xd(i, j, kl, 2) = xd(i, j, kl, 2) + two*tmpd6
        xd(i, j, nz, 2) = xd(i, j, nz, 2) - tmpd6
        tmpd7 = xd(i, j, ke, 1)
        xd(i, j, ke, 1) = 0.0_8
        xd(i, j, kl, 1) = xd(i, j, kl, 1) + two*tmpd7
        xd(i, j, nz, 1) = xd(i, j, nz, 1) - tmpd7
        xd(i, j, 1, 3) = xd(i, j, 1, 3) + two*xd(i, j, 0, 3)
        xd(i, j, 2, 3) = xd(i, j, 2, 3) - xd(i, j, 0, 3)
        xd(i, j, 0, 3) = 0.0_8
        xd(i, j, 1, 2) = xd(i, j, 1, 2) + two*xd(i, j, 0, 2)
        xd(i, j, 2, 2) = xd(i, j, 2, 2) - xd(i, j, 0, 2)
        xd(i, j, 0, 2) = 0.0_8
        xd(i, j, 1, 1) = xd(i, j, 1, 1) + two*xd(i, j, 0, 1)
        xd(i, j, 2, 1) = xd(i, j, 2, 1) - xd(i, j, 0, 1)
        xd(i, j, 0, 1) = 0.0_8
      end do
    end do
    do k=kl,1,-1
      do i=ie,0,-1
        tmpd2 = xd(i, je, k, 3)
        xd(i, je, k, 3) = 0.0_8
        xd(i, jl, k, 3) = xd(i, jl, k, 3) + two*tmpd2
        xd(i, ny, k, 3) = xd(i, ny, k, 3) - tmpd2
        tmpd3 = xd(i, je, k, 2)
        xd(i, je, k, 2) = 0.0_8
        xd(i, jl, k, 2) = xd(i, jl, k, 2) + two*tmpd3
        xd(i, ny, k, 2) = xd(i, ny, k, 2) - tmpd3
        tmpd4 = xd(i, je, k, 1)
        xd(i, je, k, 1) = 0.0_8
        xd(i, jl, k, 1) = xd(i, jl, k, 1) + two*tmpd4
        xd(i, ny, k, 1) = xd(i, ny, k, 1) - tmpd4
        xd(i, 1, k, 3) = xd(i, 1, k, 3) + two*xd(i, 0, k, 3)
        xd(i, 2, k, 3) = xd(i, 2, k, 3) - xd(i, 0, k, 3)
        xd(i, 0, k, 3) = 0.0_8
        xd(i, 1, k, 2) = xd(i, 1, k, 2) + two*xd(i, 0, k, 2)
        xd(i, 2, k, 2) = xd(i, 2, k, 2) - xd(i, 0, k, 2)
        xd(i, 0, k, 2) = 0.0_8
        xd(i, 1, k, 1) = xd(i, 1, k, 1) + two*xd(i, 0, k, 1)
        xd(i, 2, k, 1) = xd(i, 2, k, 1) - xd(i, 0, k, 1)
        xd(i, 0, k, 1) = 0.0_8
      end do
    end do
    do k=kl,1,-1
      do j=jl,1,-1
        tmpd = xd(ie, j, k, 3)
        xd(ie, j, k, 3) = 0.0_8
        xd(il, j, k, 3) = xd(il, j, k, 3) + two*tmpd
        xd(nx, j, k, 3) = xd(nx, j, k, 3) - tmpd
        tmpd0 = xd(ie, j, k, 2)
        xd(ie, j, k, 2) = 0.0_8
        xd(il, j, k, 2) = xd(il, j, k, 2) + two*tmpd0
        xd(nx, j, k, 2) = xd(nx, j, k, 2) - tmpd0
        tmpd1 = xd(ie, j, k, 1)
        xd(ie, j, k, 1) = 0.0_8
        xd(il, j, k, 1) = xd(il, j, k, 1) + two*tmpd1
        xd(nx, j, k, 1) = xd(nx, j, k, 1) - tmpd1
        xd(1, j, k, 3) = xd(1, j, k, 3) + two*xd(0, j, k, 3)
        xd(2, j, k, 3) = xd(2, j, k, 3) - xd(0, j, k, 3)
        xd(0, j, k, 3) = 0.0_8
        xd(1, j, k, 2) = xd(1, j, k, 2) + two*xd(0, j, k, 2)
        xd(2, j, k, 2) = xd(2, j, k, 2) - xd(0, j, k, 2)
        xd(0, j, k, 2) = 0.0_8
        xd(1, j, k, 1) = xd(1, j, k, 1) + two*xd(0, j, k, 1)
        xd(2, j, k, 1) = xd(2, j, k, 1) - xd(0, j, k, 1)
        xd(0, j, k, 1) = 0.0_8
      end do
    end do
  end subroutine xhalo_block_b
  subroutine xhalo_block()
!
!       xhalo determines the coordinates of the nodal halo's.          
!       first it sets all halo coordinates by simple extrapolation,    
!       then the symmetry planes are treated (also the unit normal of  
!       symmetry planes are determined) and finally an exchange is     
!       made for the internal halo's.                                  
!
    use constants
    use blockpointers
    use communication
    use inputtimespectral
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: mm, i, j, k
    integer(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
    logical :: err
    real(kind=realtype) :: length, dot
    real(kind=realtype), dimension(3) :: v1, v2, norm
    intrinsic sqrt
! extrapolation in i-direction.
    do k=1,kl
      do j=1,jl
        x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
        x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
        x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
        x(ie, j, k, 1) = two*x(il, j, k, 1) - x(nx, j, k, 1)
        x(ie, j, k, 2) = two*x(il, j, k, 2) - x(nx, j, k, 2)
        x(ie, j, k, 3) = two*x(il, j, k, 3) - x(nx, j, k, 3)
      end do
    end do
! extrapolation in j-direction.
    do k=1,kl
      do i=0,ie
        x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
        x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
        x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
        x(i, je, k, 1) = two*x(i, jl, k, 1) - x(i, ny, k, 1)
        x(i, je, k, 2) = two*x(i, jl, k, 2) - x(i, ny, k, 2)
        x(i, je, k, 3) = two*x(i, jl, k, 3) - x(i, ny, k, 3)
      end do
    end do
! extrapolation in k-direction.
    do j=0,je
      do i=0,ie
        x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
        x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
        x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
        x(i, j, ke, 1) = two*x(i, j, kl, 1) - x(i, j, nz, 1)
        x(i, j, ke, 2) = two*x(i, j, kl, 2) - x(i, j, nz, 2)
        x(i, j, ke, 3) = two*x(i, j, kl, 3) - x(i, j, nz, 3)
      end do
    end do
!
!           mirror the halo coordinates adjacent to the symmetry       
!           planes                                                     
!
! loop over boundary subfaces.
loopbocos:do mm=1,nbocos
! the actual correction of the coordinates only takes
! place for symmetry planes.
      if (bctype(mm) .eq. symm) then
! set some variables, depending on the block face on
! which the subface is located.
        norm(1) = bcdata(mm)%symnorm(1)
        norm(2) = bcdata(mm)%symnorm(2)
        norm(3) = bcdata(mm)%symnorm(3)
        length = sqrt(norm(1)**2 + norm(2)**2 + norm(3)**2)
! compute the unit normal of the subface.
        norm(1) = norm(1)/length
        norm(2) = norm(2)/length
        norm(3) = norm(3)/length
! see xhalo_block for comments for below:
        if (length .gt. eps) then
          select case  (bcfaceid(mm)) 
          case (imin) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(1, i, j, 1) - x(2, i, j, 1)
                v1(2) = x(1, i, j, 2) - x(2, i, j, 2)
                v1(3) = x(1, i, j, 3) - x(2, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(0, i, j, 1) = x(2, i, j, 1) + dot*norm(1)
                x(0, i, j, 2) = x(2, i, j, 2) + dot*norm(2)
                x(0, i, j, 3) = x(2, i, j, 3) + dot*norm(3)
              end do
            end do
          case (imax) 
            ibeg = jnbeg(mm)
            iend = jnend(mm)
            iimax = jl
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(il, i, j, 1) - x(nx, i, j, 1)
                v1(2) = x(il, i, j, 2) - x(nx, i, j, 2)
                v1(3) = x(il, i, j, 3) - x(nx, i, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(ie, i, j, 1) = x(nx, i, j, 1) + dot*norm(1)
                x(ie, i, j, 2) = x(nx, i, j, 2) + dot*norm(2)
                x(ie, i, j, 3) = x(nx, i, j, 3) + dot*norm(3)
              end do
            end do
          case (jmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, 1, j, 1) - x(i, 2, j, 1)
                v1(2) = x(i, 1, j, 2) - x(i, 2, j, 2)
                v1(3) = x(i, 1, j, 3) - x(i, 2, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, 0, j, 1) = x(i, 2, j, 1) + dot*norm(1)
                x(i, 0, j, 2) = x(i, 2, j, 2) + dot*norm(2)
                x(i, 0, j, 3) = x(i, 2, j, 3) + dot*norm(3)
              end do
            end do
          case (jmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = knbeg(mm)
            jend = knend(mm)
            jjmax = kl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, jl, j, 1) - x(i, ny, j, 1)
                v1(2) = x(i, jl, j, 2) - x(i, ny, j, 2)
                v1(3) = x(i, jl, j, 3) - x(i, ny, j, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, je, j, 1) = x(i, ny, j, 1) + dot*norm(1)
                x(i, je, j, 2) = x(i, ny, j, 2) + dot*norm(2)
                x(i, je, j, 3) = x(i, ny, j, 3) + dot*norm(3)
              end do
            end do
          case (kmin) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, 1, 1) - x(i, j, 2, 1)
                v1(2) = x(i, j, 1, 2) - x(i, j, 2, 2)
                v1(3) = x(i, j, 1, 3) - x(i, j, 2, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, 0, 1) = x(i, j, 2, 1) + dot*norm(1)
                x(i, j, 0, 2) = x(i, j, 2, 2) + dot*norm(2)
                x(i, j, 0, 3) = x(i, j, 2, 3) + dot*norm(3)
              end do
            end do
          case (kmax) 
            ibeg = inbeg(mm)
            iend = inend(mm)
            iimax = il
            jbeg = jnbeg(mm)
            jend = jnend(mm)
            jjmax = jl
            if (ibeg .eq. 1) ibeg = 0
            if (iend .eq. iimax) iend = iimax + 1
            if (jbeg .eq. 1) jbeg = 0
            if (jend .eq. jjmax) jend = jjmax + 1
            do j=jbeg,jend
              do i=ibeg,iend
                v1(1) = x(i, j, kl, 1) - x(i, j, nz, 1)
                v1(2) = x(i, j, kl, 2) - x(i, j, nz, 2)
                v1(3) = x(i, j, kl, 3) - x(i, j, nz, 3)
                dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                x(i, j, ke, 1) = x(i, j, nz, 1) + dot*norm(1)
                x(i, j, ke, 2) = x(i, j, nz, 2) + dot*norm(2)
                x(i, j, ke, 3) = x(i, j, nz, 3) + dot*norm(3)
              end do
            end do
          end select
        end if
      end if
    end do loopbocos
  end subroutine xhalo_block
end module adjointextra_b

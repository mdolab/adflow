!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module turbbcroutines_b
  implicit none

contains
!  differentiation of applyallturbbcthisblock in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev *w
!   with respect to varying inputs: *rev *bvtj1 *bvtj2 *w *bvtk1
!                *bvtk2 *bvti1 *bvti2
!   plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
!                bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
!      ==================================================================
  subroutine applyallturbbcthisblock_b(secondhalo)
!
!       applyallturbbcthisblock sets the halo values of the            
!       turbulent variables and eddy viscosity for the block the       
!       variables in blockpointers currently point to.                 
!
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    implicit none
!
!      subroutine arguments.
!
    logical, intent(in) :: secondhalo
!
!      local variables.
!
    integer(kind=inttype) :: nn, i, j, l, m
    real(kind=realtype), dimension(:, :, :, :), pointer :: bmt
    real(kind=realtype), dimension(:, :, :), pointer :: bvt, ww1, ww2
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    integer :: ad_from
    integer :: ad_to
    integer :: ad_from0
    integer :: ad_to0
    integer :: ad_from1
    integer :: ad_to1
    integer :: ad_from2
    integer :: ad_to2
    integer :: ad_from3
    integer :: ad_to3
    integer :: ad_from4
    integer :: ad_to4
    integer :: ad_from5
    integer :: ad_to5
    integer :: ad_from6
    integer :: ad_to6
    integer :: ad_from7
    integer :: ad_to7
    integer :: ad_from8
    integer :: ad_to8
    integer :: ad_from9
    integer :: ad_to9
    integer :: ad_from10
    integer :: ad_to10
    integer :: branch
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
! loop over the boundary condition subfaces of this block.
bocos:do nn=1,nbocos
! loop over the faces and set the state in
! the turbulent halo cells.
      if (wallfunctions) then
        call pushcontrol3b(0)
      else
        select case  (bcfaceid(nn)) 
        case (imin) 
          ad_from0 = bcdata(nn)%jcbeg
          do j=ad_from0,bcdata(nn)%jcend
            ad_from = bcdata(nn)%icbeg
            i = bcdata(nn)%icend + 1
            call pushinteger4(i - 1)
            call pushinteger4(ad_from)
          end do
          call pushinteger4(j - 1)
          call pushinteger4(ad_from0)
          call pushcontrol3b(2)
        case (imax) 
          ad_from2 = bcdata(nn)%jcbeg
          do j=ad_from2,bcdata(nn)%jcend
            ad_from1 = bcdata(nn)%icbeg
            i = bcdata(nn)%icend + 1
            call pushinteger4(i - 1)
            call pushinteger4(ad_from1)
          end do
          call pushinteger4(j - 1)
          call pushinteger4(ad_from2)
          call pushcontrol3b(3)
        case (jmin) 
          ad_from4 = bcdata(nn)%jcbeg
          do j=ad_from4,bcdata(nn)%jcend
            ad_from3 = bcdata(nn)%icbeg
            i = bcdata(nn)%icend + 1
            call pushinteger4(i - 1)
            call pushinteger4(ad_from3)
          end do
          call pushinteger4(j - 1)
          call pushinteger4(ad_from4)
          call pushcontrol3b(4)
        case (jmax) 
          ad_from6 = bcdata(nn)%jcbeg
          do j=ad_from6,bcdata(nn)%jcend
            ad_from5 = bcdata(nn)%icbeg
            i = bcdata(nn)%icend + 1
            call pushinteger4(i - 1)
            call pushinteger4(ad_from5)
          end do
          call pushinteger4(j - 1)
          call pushinteger4(ad_from6)
          call pushcontrol3b(5)
        case (kmin) 
          ad_from8 = bcdata(nn)%jcbeg
          do j=ad_from8,bcdata(nn)%jcend
            ad_from7 = bcdata(nn)%icbeg
            i = bcdata(nn)%icend + 1
            call pushinteger4(i - 1)
            call pushinteger4(ad_from7)
          end do
          call pushinteger4(j - 1)
          call pushinteger4(ad_from8)
          call pushcontrol3b(6)
        case (kmax) 
          ad_from10 = bcdata(nn)%jcbeg
          do j=ad_from10,bcdata(nn)%jcend
            ad_from9 = bcdata(nn)%icbeg
            i = bcdata(nn)%icend + 1
            call pushinteger4(i - 1)
            call pushinteger4(ad_from9)
          end do
          call pushinteger4(j - 1)
          call pushinteger4(ad_from10)
          call pushcontrol3b(7)
        case default
          call pushcontrol3b(1)
        end select
      end if
! set the value of the eddy viscosity, depending on the type of
! boundary condition. only if the turbulence model is an eddy
! viscosity model of course.
      if (eddymodel) then
        if (bctype(nn) .eq. nswalladiabatic .or. bctype(nn) .eq. &
&           nswallisothermal) then
          call pushcontrol2b(0)
        else
          call pushcontrol2b(1)
        end if
      else
        call pushcontrol2b(2)
      end if
! extrapolate the turbulent variables in case a second halo
! is needed.
      if (secondhalo) then
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
    end do bocos
    bvtj1d = 0.0_8
    bvtj2d = 0.0_8
    bvtk1d = 0.0_8
    bvtk2d = 0.0_8
    bvti1d = 0.0_8
    bvti2d = 0.0_8
    do nn=nbocos,1,-1
      call popcontrol1b(branch)
      if (branch .ne. 0) call turb2ndhalo_b(nn)
      call popcontrol2b(branch)
      if (branch .eq. 0) then
        call bceddywall_b(nn)
      else if (branch .eq. 1) then
        call bceddynowall_b(nn)
      end if
      call popcontrol3b(branch)
      if (branch .lt. 4) then
        if (branch .ge. 2) then
          if (branch .eq. 2) then
            call popinteger4(ad_from0)
            call popinteger4(ad_to0)
            do j=ad_to0,ad_from0,-1
              call popinteger4(ad_from)
              call popinteger4(ad_to)
              do i=ad_to,ad_from,-1
                do l=nt2,nt1,-1
                  do m=nt2,nt1,-1
                    wd(2, i, j, m) = wd(2, i, j, m) - bmti1(i, j, l, m)*&
&                     wd(1, i, j, l)
                  end do
                  bvti1d(i, j, l) = bvti1d(i, j, l) + wd(1, i, j, l)
                  wd(1, i, j, l) = 0.0_8
                end do
              end do
            end do
          else
            call popinteger4(ad_from2)
            call popinteger4(ad_to2)
            do j=ad_to2,ad_from2,-1
              call popinteger4(ad_from1)
              call popinteger4(ad_to1)
              do i=ad_to1,ad_from1,-1
                do l=nt2,nt1,-1
                  do m=nt2,nt1,-1
                    tmpd = wd(ie, i, j, l)
                    wd(ie, i, j, l) = tmpd
                    wd(il, i, j, m) = wd(il, i, j, m) - bmti2(i, j, l, m&
&                     )*tmpd
                  end do
                  bvti2d(i, j, l) = bvti2d(i, j, l) + wd(ie, i, j, l)
                  wd(ie, i, j, l) = 0.0_8
                end do
              end do
            end do
          end if
        end if
      else if (branch .lt. 6) then
        if (branch .eq. 4) then
          call popinteger4(ad_from4)
          call popinteger4(ad_to4)
          do j=ad_to4,ad_from4,-1
            call popinteger4(ad_from3)
            call popinteger4(ad_to3)
            do i=ad_to3,ad_from3,-1
              do l=nt2,nt1,-1
                do m=nt2,nt1,-1
                  wd(i, 2, j, m) = wd(i, 2, j, m) - bmtj1(i, j, l, m)*wd&
&                   (i, 1, j, l)
                end do
                bvtj1d(i, j, l) = bvtj1d(i, j, l) + wd(i, 1, j, l)
                wd(i, 1, j, l) = 0.0_8
              end do
            end do
          end do
        else
          call popinteger4(ad_from6)
          call popinteger4(ad_to6)
          do j=ad_to6,ad_from6,-1
            call popinteger4(ad_from5)
            call popinteger4(ad_to5)
            do i=ad_to5,ad_from5,-1
              do l=nt2,nt1,-1
                do m=nt2,nt1,-1
                  tmpd0 = wd(i, je, j, l)
                  wd(i, je, j, l) = tmpd0
                  wd(i, jl, j, m) = wd(i, jl, j, m) - bmtj2(i, j, l, m)*&
&                   tmpd0
                end do
                bvtj2d(i, j, l) = bvtj2d(i, j, l) + wd(i, je, j, l)
                wd(i, je, j, l) = 0.0_8
              end do
            end do
          end do
        end if
      else if (branch .eq. 6) then
        call popinteger4(ad_from8)
        call popinteger4(ad_to8)
        do j=ad_to8,ad_from8,-1
          call popinteger4(ad_from7)
          call popinteger4(ad_to7)
          do i=ad_to7,ad_from7,-1
            do l=nt2,nt1,-1
              do m=nt2,nt1,-1
                wd(i, j, 2, m) = wd(i, j, 2, m) - bmtk1(i, j, l, m)*wd(i&
&                 , j, 1, l)
              end do
              bvtk1d(i, j, l) = bvtk1d(i, j, l) + wd(i, j, 1, l)
              wd(i, j, 1, l) = 0.0_8
            end do
          end do
        end do
      else
        call popinteger4(ad_from10)
        call popinteger4(ad_to10)
        do j=ad_to10,ad_from10,-1
          call popinteger4(ad_from9)
          call popinteger4(ad_to9)
          do i=ad_to9,ad_from9,-1
            do l=nt2,nt1,-1
              do m=nt2,nt1,-1
                tmpd1 = wd(i, j, ke, l)
                wd(i, j, ke, l) = tmpd1
                wd(i, j, kl, m) = wd(i, j, kl, m) - bmtk2(i, j, l, m)*&
&                 tmpd1
              end do
              bvtk2d(i, j, l) = bvtk2d(i, j, l) + wd(i, j, ke, l)
              wd(i, j, ke, l) = 0.0_8
            end do
          end do
        end do
      end if
    end do
  end subroutine applyallturbbcthisblock_b
!      ==================================================================
  subroutine applyallturbbcthisblock(secondhalo)
!
!       applyallturbbcthisblock sets the halo values of the            
!       turbulent variables and eddy viscosity for the block the       
!       variables in blockpointers currently point to.                 
!
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    implicit none
!
!      subroutine arguments.
!
    logical, intent(in) :: secondhalo
!
!      local variables.
!
    integer(kind=inttype) :: nn, i, j, l, m
    real(kind=realtype), dimension(:, :, :, :), pointer :: bmt
    real(kind=realtype), dimension(:, :, :), pointer :: bvt, ww1, ww2
! loop over the boundary condition subfaces of this block.
bocos:do nn=1,nbocos
! loop over the faces and set the state in
! the turbulent halo cells.
      if (.not.wallfunctions) then
        select case  (bcfaceid(nn)) 
        case (imin) 
          do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
            do i=bcdata(nn)%icbeg,bcdata(nn)%icend
              do l=nt1,nt2
                w(1, i, j, l) = bvti1(i, j, l)
                do m=nt1,nt2
                  w(1, i, j, l) = w(1, i, j, l) - bmti1(i, j, l, m)*w(2&
&                   , i, j, m)
                end do
              end do
            end do
          end do
        case (imax) 
          do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
            do i=bcdata(nn)%icbeg,bcdata(nn)%icend
              do l=nt1,nt2
                w(ie, i, j, l) = bvti2(i, j, l)
                do m=nt1,nt2
                  w(ie, i, j, l) = w(ie, i, j, l) - bmti2(i, j, l, m)*w(&
&                   il, i, j, m)
                end do
              end do
            end do
          end do
        case (jmin) 
          do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
            do i=bcdata(nn)%icbeg,bcdata(nn)%icend
              do l=nt1,nt2
                w(i, 1, j, l) = bvtj1(i, j, l)
                do m=nt1,nt2
                  w(i, 1, j, l) = w(i, 1, j, l) - bmtj1(i, j, l, m)*w(i&
&                   , 2, j, m)
                end do
              end do
            end do
          end do
        case (jmax) 
          do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
            do i=bcdata(nn)%icbeg,bcdata(nn)%icend
              do l=nt1,nt2
                w(i, je, j, l) = bvtj2(i, j, l)
                do m=nt1,nt2
                  w(i, je, j, l) = w(i, je, j, l) - bmtj2(i, j, l, m)*w(&
&                   i, jl, j, m)
                end do
              end do
            end do
          end do
        case (kmin) 
          do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
            do i=bcdata(nn)%icbeg,bcdata(nn)%icend
              do l=nt1,nt2
                w(i, j, 1, l) = bvtk1(i, j, l)
                do m=nt1,nt2
                  w(i, j, 1, l) = w(i, j, 1, l) - bmtk1(i, j, l, m)*w(i&
&                   , j, 2, m)
                end do
              end do
            end do
          end do
        case (kmax) 
          do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
            do i=bcdata(nn)%icbeg,bcdata(nn)%icend
              do l=nt1,nt2
                w(i, j, ke, l) = bvtk2(i, j, l)
                do m=nt1,nt2
                  w(i, j, ke, l) = w(i, j, ke, l) - bmtk2(i, j, l, m)*w(&
&                   i, j, kl, m)
                end do
              end do
            end do
          end do
        end select
      end if
! set the value of the eddy viscosity, depending on the type of
! boundary condition. only if the turbulence model is an eddy
! viscosity model of course.
      if (eddymodel) then
        if (bctype(nn) .eq. nswalladiabatic .or. bctype(nn) .eq. &
&           nswallisothermal) then
! viscous wall boundary condition. eddy viscosity is
! zero at the wall.
          call bceddywall(nn)
        else
! any boundary condition but viscous wall. a homogeneous
! neumann condition is applied to the eddy viscosity.
          call bceddynowall(nn)
        end if
      end if
! extrapolate the turbulent variables in case a second halo
! is needed.
      if (secondhalo) call turb2ndhalo(nn)
    end do bocos
  end subroutine applyallturbbcthisblock
!  differentiation of bceddynowall in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev
!   with respect to varying inputs: *rev
!   plus diff mem management of: rev:in bcdata:in
  subroutine bceddynowall_b(nn)
!
!       bceddynowall sets the eddy viscosity in the halo cells of      
!       subface nn of the block given in blockpointers. the boundary   
!       condition on the subface can be anything but a viscous wall.   
!       a homogeneous neumann condition is applied, which means that   
!       the eddy viscosity is simply copied from the interior cell.    
!
    use constants
    use blockpointers
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
! determine the face id on which the subface and copy
    select case  (bcfaceid(nn)) 
    case (imin) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          revd(2, i, j) = revd(2, i, j) + revd(1, i, j)
          revd(1, i, j) = 0.0_8
        end do
      end do
    case (imax) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          tmpd = revd(ie, i, j)
          revd(ie, i, j) = 0.0_8
          revd(il, i, j) = revd(il, i, j) + tmpd
        end do
      end do
    case (jmin) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          revd(i, 2, j) = revd(i, 2, j) + revd(i, 1, j)
          revd(i, 1, j) = 0.0_8
        end do
      end do
    case (jmax) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          tmpd0 = revd(i, je, j)
          revd(i, je, j) = 0.0_8
          revd(i, jl, j) = revd(i, jl, j) + tmpd0
        end do
      end do
    case (kmin) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          revd(i, j, 2) = revd(i, j, 2) + revd(i, j, 1)
          revd(i, j, 1) = 0.0_8
        end do
      end do
    case (kmax) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          tmpd1 = revd(i, j, ke)
          revd(i, j, ke) = 0.0_8
          revd(i, j, kl) = revd(i, j, kl) + tmpd1
        end do
      end do
    end select
  end subroutine bceddynowall_b
  subroutine bceddynowall(nn)
!
!       bceddynowall sets the eddy viscosity in the halo cells of      
!       subface nn of the block given in blockpointers. the boundary   
!       condition on the subface can be anything but a viscous wall.   
!       a homogeneous neumann condition is applied, which means that   
!       the eddy viscosity is simply copied from the interior cell.    
!
    use constants
    use blockpointers
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j
! determine the face id on which the subface and copy
    select case  (bcfaceid(nn)) 
    case (imin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(1, i, j) = rev(2, i, j)
        end do
      end do
    case (imax) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(ie, i, j) = rev(il, i, j)
        end do
      end do
    case (jmin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, 1, j) = rev(i, 2, j)
        end do
      end do
    case (jmax) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, je, j) = rev(i, jl, j)
        end do
      end do
    case (kmin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, j, 1) = rev(i, j, 2)
        end do
      end do
    case (kmax) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, j, ke) = rev(i, j, kl)
        end do
      end do
    end select
  end subroutine bceddynowall
!  differentiation of bceddywall in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev
!   with respect to varying inputs: *rev
!   plus diff mem management of: rev:in bcdata:in
  subroutine bceddywall_b(nn)
!
!       bceddywall sets the eddy viscosity in the halo cells of        
!       viscous subface nn of the block given in blockpointers.        
!       as the eddy viscosity is zero at the wall, the value in the    
!       halo is simply the negative value of the first interior cell.  
!
    use constants
    use blockpointers
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
! determine the face id on which the subface is located and
! loop over the faces of the subface and set the eddy viscosity
! in the halo cells.
    select case  (bcfaceid(nn)) 
    case (imin) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          revd(2, i, j) = revd(2, i, j) - revd(1, i, j)
          revd(1, i, j) = 0.0_8
        end do
      end do
    case (imax) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          tmpd = revd(ie, i, j)
          revd(ie, i, j) = 0.0_8
          revd(il, i, j) = revd(il, i, j) - tmpd
        end do
      end do
    case (jmin) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          revd(i, 2, j) = revd(i, 2, j) - revd(i, 1, j)
          revd(i, 1, j) = 0.0_8
        end do
      end do
    case (jmax) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          tmpd0 = revd(i, je, j)
          revd(i, je, j) = 0.0_8
          revd(i, jl, j) = revd(i, jl, j) - tmpd0
        end do
      end do
    case (kmin) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          revd(i, j, 2) = revd(i, j, 2) - revd(i, j, 1)
          revd(i, j, 1) = 0.0_8
        end do
      end do
    case (kmax) 
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          tmpd1 = revd(i, j, ke)
          revd(i, j, ke) = 0.0_8
          revd(i, j, kl) = revd(i, j, kl) - tmpd1
        end do
      end do
    end select
  end subroutine bceddywall_b
  subroutine bceddywall(nn)
!
!       bceddywall sets the eddy viscosity in the halo cells of        
!       viscous subface nn of the block given in blockpointers.        
!       as the eddy viscosity is zero at the wall, the value in the    
!       halo is simply the negative value of the first interior cell.  
!
    use constants
    use blockpointers
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j
! determine the face id on which the subface is located and
! loop over the faces of the subface and set the eddy viscosity
! in the halo cells.
    select case  (bcfaceid(nn)) 
    case (imin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(1, i, j) = -rev(2, i, j)
        end do
      end do
    case (imax) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(ie, i, j) = -rev(il, i, j)
        end do
      end do
    case (jmin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, 1, j) = -rev(i, 2, j)
        end do
      end do
    case (jmax) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, je, j) = -rev(i, jl, j)
        end do
      end do
    case (kmin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, j, 1) = -rev(i, j, 2)
        end do
      end do
    case (kmax) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          rev(i, j, ke) = -rev(i, j, kl)
        end do
      end do
    end select
  end subroutine bceddywall
  subroutine bcturbinflow(nn)
!
!       bcturbinflow applies the implicit treatment of the inflow      
!       boundary conditions to subface nn. as the inflow boundary      
!       condition is independent of the turbulence model, this routine 
!       is valid for all models. it is assumed that the pointers in    
!       blockpointers are already set to the correct block on the      
!       correct grid level.                                            
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
! loop over the faces of the subfaces and set the values of
! bvt and bmt such that the inflow state is linearly extrapolated
! with a fixed state at the face.
    do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      do i=bcdata(nn)%icbeg,bcdata(nn)%icend
! loop over the number of turbulent variables.
        do l=nt1,nt2
          select case  (bcfaceid(nn)) 
          case (imin) 
            bvti1(i, j, l) = two*bcdata(nn)%turbinlet(i, j, l)
            bmti1(i, j, l, l) = one
          case (imax) 
            bvti2(i, j, l) = two*bcdata(nn)%turbinlet(i, j, l)
            bmti2(i, j, l, l) = one
          case (jmin) 
            bvtj1(i, j, l) = two*bcdata(nn)%turbinlet(i, j, l)
            bmtj1(i, j, l, l) = one
          case (jmax) 
            bvtj2(i, j, l) = two*bcdata(nn)%turbinlet(i, j, l)
            bmtj2(i, j, l, l) = one
          case (kmin) 
            bvtk1(i, j, l) = two*bcdata(nn)%turbinlet(i, j, l)
            bmtk1(i, j, l, l) = one
          case (kmax) 
            bvtk2(i, j, l) = two*bcdata(nn)%turbinlet(i, j, l)
            bmtk2(i, j, l, l) = one
          end select
        end do
      end do
    end do
  end subroutine bcturbinflow
  subroutine bcturboutflow(nn)
!
!       bcturboutflow applies the implicit treatment of the outflow    
!       boundary conditions to subface nn. as the outflow boundary     
!       condition is independent of the turbulence model, either       
!       extrapolation or zero neumann, this routine is valid for all   
!       models. it is assumed that the pointers in blockpointers are   
!       already set to the correct block on the correct grid level.    
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
! loop over the faces of the subfaces and set the values of bmt
! for an implicit treatment. for an outflow the turbulent variable
! variable is either extrapolated or zero neumann. as constant
! extrapolation is used this leads to an identical treatment, i.e.
! the halo value is identical to the value of the internal cell.
    do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      do i=bcdata(nn)%icbeg,bcdata(nn)%icend
        do l=nt1,nt2
          select case  (bcfaceid(nn)) 
          case (imin) 
            bmti1(i, j, l, l) = -one
          case (imax) 
            bmti2(i, j, l, l) = -one
          case (jmin) 
            bmtj1(i, j, l, l) = -one
          case (jmax) 
            bmtj2(i, j, l, l) = -one
          case (kmin) 
            bmtk1(i, j, l, l) = -one
          case (kmax) 
            bmtk2(i, j, l, l) = -one
          end select
        end do
      end do
    end do
  end subroutine bcturboutflow
!  differentiation of bcturbtreatment in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: winf *bvtj1 *bvtj2 *w *rlv
!                *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2
!   with respect to varying inputs: winf *w *rlv *d2wall
!   plus diff mem management of: bvtj1:in bvtj2:in w:in rlv:in
!                bvtk1:in bvtk2:in d2wall:in bvti1:in bvti2:in
!                bcdata:in
  subroutine bcturbtreatment_b()
!
!       bcturbtreatment sets the arrays bmti1, bvti1, etc, such that   
!       the physical boundary conditions are treated correctly.        
!       it is assumed that the variables in blockpointers already      
!       point to the correct block.                                    
!       the turbulent variable in the halo is computed as follows:     
!       whalo = -bmt*winternal + bvt for every block facer. as it is   
!       possible to have a coupling in the boundary conditions bmt     
!       actually are matrices. if there is no coupling between the     
!       boundary conditions of the turbulence equations bmt is a       
!       diagonal matrix.                                               
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      local variable.
!
    integer(kind=inttype) :: nn, i, j, k, l, m
    integer :: branch
! loop over the boundary condition subfaces of this block.
bocos:do nn=1,nbocos
! determine the kind of boundary condition for this subface.
      select case  (bctype(nn)) 
      case (nswalladiabatic, nswallisothermal) 
        call pushcontrol2b(2)
      case (symm, symmpolar, eulerwall) 
        call pushcontrol2b(3)
      case (farfield) 
        call pushcontrol2b(1)
      case (slidinginterface, oversetouterbound, domaininterfaceall, &
&     domaininterfacerhouvw, domaininterfacep, domaininterfacerho, &
&     domaininterfacetotal) 
        call pushcontrol2b(0)
      case default
        call pushcontrol2b(3)
      end select
    end do bocos
    do nn=nbocos,1,-1
      call popcontrol2b(branch)
      if (branch .lt. 2) then
        if (branch .eq. 0) then
          call bcturbinterface_b(nn)
        else
          call bcturbfarfield_b(nn)
        end if
      else if (branch .eq. 2) then
        call bcturbwall_b(nn)
      end if
    end do
  end subroutine bcturbtreatment_b
!  differentiation of bcturbfarfield in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: winf *bvtj1 *bvtj2 *bvtk1 *bvtk2
!                *bvti1 *bvti2
!   with respect to varying inputs: winf *bvtj1 *bvtj2 *bvtk1 *bvtk2
!                *bvti1 *bvti2
!   plus diff mem management of: bvtj1:in bvtj2:in bvtk1:in bvtk2:in
!                bvti1:in bvti2:in bcdata:in
  subroutine bcturbfarfield_b(nn)
!
!       bcturbfarfield applies the implicit treatment of the           
!       farfield boundary condition to subface nn. as the farfield     
!       boundary condition is independent of the turbulence model,     
!       this routine is valid for all models. it is assumed that the   
!       pointers in blockpointers are already set to the correct       
!       block on the correct grid level.                               
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
    real(kind=realtype) :: nnx, nny, nnz, dot
    integer :: branch
! loop over the faces of the subfaces and set the values of
! bmt and bvt for an implicit treatment.
    do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      do i=bcdata(nn)%icbeg,bcdata(nn)%icend
! determine the dot product between the outward pointing
! normal and the free stream velocity direction and add the
! possible grid velocity.
        dot = bcdata(nn)%norm(i, j, 1)*winf(ivx) + bcdata(nn)%norm(i, j&
&         , 2)*winf(ivy) + bcdata(nn)%norm(i, j, 3)*winf(ivz) - bcdata(&
&         nn)%rface(i, j)
! determine whether we are dealing with an inflow or
! outflow boundary here.
        if (dot .gt. zero) then
          call pushcontrol1b(1)
        else
! inflow. turbulent variables are prescribed.
          do l=nt1,nt2
            select case  (bcfaceid(nn)) 
            case (imin) 
              call pushcontrol3b(5)
            case (imax) 
              call pushcontrol3b(4)
            case (jmin) 
              call pushcontrol3b(3)
            case (jmax) 
              call pushcontrol3b(2)
            case (kmin) 
              call pushcontrol3b(1)
            case (kmax) 
              call pushcontrol3b(0)
            case default
              call pushcontrol3b(6)
            end select
          end do
          call pushcontrol1b(0)
        end if
      end do
    end do
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          do l=nt2,nt1,-1
            call popcontrol3b(branch)
            if (branch .lt. 3) then
              if (branch .eq. 0) then
                winfd(l) = winfd(l) + bvtk2d(i, j, l)
                bvtk2d(i, j, l) = 0.0_8
              else if (branch .eq. 1) then
                winfd(l) = winfd(l) + bvtk1d(i, j, l)
                bvtk1d(i, j, l) = 0.0_8
              else
                winfd(l) = winfd(l) + bvtj2d(i, j, l)
                bvtj2d(i, j, l) = 0.0_8
              end if
            else if (branch .lt. 5) then
              if (branch .eq. 3) then
                winfd(l) = winfd(l) + bvtj1d(i, j, l)
                bvtj1d(i, j, l) = 0.0_8
              else
                winfd(l) = winfd(l) + bvti2d(i, j, l)
                bvti2d(i, j, l) = 0.0_8
              end if
            else if (branch .eq. 5) then
              winfd(l) = winfd(l) + bvti1d(i, j, l)
              bvti1d(i, j, l) = 0.0_8
            end if
          end do
        end if
      end do
    end do
  end subroutine bcturbfarfield_b
!  differentiation of bcturbinterface in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *bvtj1 *bvtj2 *w *bvtk1 *bvtk2
!                *bvti1 *bvti2
!   with respect to varying inputs: *bvtj1 *bvtj2 *w *bvtk1 *bvtk2
!                *bvti1 *bvti2
!   plus diff mem management of: bvtj1:in bvtj2:in w:in bvtk1:in
!                bvtk2:in bvti1:in bvti2:in bcdata:in
  subroutine bcturbinterface_b(nn)
!
!       bcturbinterface applies the halo treatment for interface halo  
!       cells, sliding mesh interface and domain interface. as these   
!       are not really boundary conditions, the variable bvt is simply 
!       set to keep the current value.                                 
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
! note that the original code had an error in the pointers...they
! were pointing to {il,jl,kl} and not {ie, je, ke}.
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
    integer :: branch
! loop over the faces of the subfaces and set the values of
! bvt to keep the current value.
    do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      do i=bcdata(nn)%icbeg,bcdata(nn)%icend
        do l=nt1,nt2
          select case  (bcfaceid(nn)) 
          case (imin) 
            call pushcontrol3b(5)
          case (imax) 
            call pushcontrol3b(4)
          case (jmin) 
            call pushcontrol3b(3)
          case (jmax) 
            call pushcontrol3b(2)
          case (kmin) 
            call pushcontrol3b(1)
          case (kmax) 
            call pushcontrol3b(0)
          case default
            call pushcontrol3b(6)
          end select
        end do
      end do
    end do
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        do l=nt2,nt1,-1
          call popcontrol3b(branch)
          if (branch .lt. 3) then
            if (branch .eq. 0) then
              wd(i, j, ke, l) = wd(i, j, ke, l) + bvtk2d(i, j, l)
              bvtk2d(i, j, l) = 0.0_8
            else if (branch .eq. 1) then
              wd(i, j, 1, l) = wd(i, j, 1, l) + bvtk1d(i, j, l)
              bvtk1d(i, j, l) = 0.0_8
            else
              wd(i, je, j, l) = wd(i, je, j, l) + bvtj2d(i, j, l)
              bvtj2d(i, j, l) = 0.0_8
            end if
          else if (branch .lt. 5) then
            if (branch .eq. 3) then
              wd(i, 1, j, l) = wd(i, 1, j, l) + bvtj1d(i, j, l)
              bvtj1d(i, j, l) = 0.0_8
            else
              wd(ie, i, j, l) = wd(ie, i, j, l) + bvti2d(i, j, l)
              bvti2d(i, j, l) = 0.0_8
            end if
          else if (branch .eq. 5) then
            wd(1, i, j, l) = wd(1, i, j, l) + bvti1d(i, j, l)
            bvti1d(i, j, l) = 0.0_8
          end if
        end do
      end do
    end do
  end subroutine bcturbinterface_b
  subroutine bcturbtreatment()
!
!       bcturbtreatment sets the arrays bmti1, bvti1, etc, such that   
!       the physical boundary conditions are treated correctly.        
!       it is assumed that the variables in blockpointers already      
!       point to the correct block.                                    
!       the turbulent variable in the halo is computed as follows:     
!       whalo = -bmt*winternal + bvt for every block facer. as it is   
!       possible to have a coupling in the boundary conditions bmt     
!       actually are matrices. if there is no coupling between the     
!       boundary conditions of the turbulence equations bmt is a       
!       diagonal matrix.                                               
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      local variable.
!
    integer(kind=inttype) :: nn, i, j, k, l, m
! initialize the arrays for the boundary condition treatment
! to zero, such that internal block boundaries are solved
! correctly (i.e. explicitly).
    do k=1,ke
      do j=1,je
        do l=nt1,nt2
          do m=nt1,nt2
            bmti1(j, k, l, m) = zero
            bmti2(j, k, l, m) = zero
          end do
          bvti1(j, k, l) = zero
          bvti2(j, k, l) = zero
        end do
      end do
    end do
    do k=1,ke
      do i=1,ie
        do l=nt1,nt2
          do m=nt1,nt2
            bmtj1(i, k, l, m) = zero
            bmtj2(i, k, l, m) = zero
          end do
          bvtj1(i, k, l) = zero
          bvtj2(i, k, l) = zero
        end do
      end do
    end do
    do j=1,je
      do i=1,ie
        do l=nt1,nt2
          do m=nt1,nt2
            bmtk1(i, j, l, m) = zero
            bmtk2(i, j, l, m) = zero
          end do
          bvtk1(i, j, l) = zero
          bvtk2(i, j, l) = zero
        end do
      end do
    end do
! loop over the boundary condition subfaces of this block.
bocos:do nn=1,nbocos
! determine the kind of boundary condition for this subface.
      select case  (bctype(nn)) 
      case (nswalladiabatic, nswallisothermal) 
! viscous wall. there is no difference between an adiabatic
! and an isothermal wall for the turbulent equations.
! set the implicit treatment of the wall boundary conditions.
        call bcturbwall(nn)
      case (symm, symmpolar, eulerwall) 
!=============================================================
!=============================================================
! symmetry, polar symmetry or inviscid wall. treatment of
! the turbulent equations is identical.
        call bcturbsymm(nn)
      case (farfield) 
!=============================================================
! farfield. the kind of boundary condition to be applied,
! inflow or outflow, depends on the local conditions.
        call bcturbfarfield(nn)
      case (slidinginterface, oversetouterbound, domaininterfaceall, &
&     domaininterfacerhouvw, domaininterfacep, domaininterfacerho, &
&     domaininterfacetotal) 
!=============================================================
! sliding mesh interface, overset outer boudaries, and 
! domain interface with another code are not really boundary
! condition and therefore the values are kept.
        call bcturbinterface(nn)
      end select
    end do bocos
  end subroutine bcturbtreatment
  subroutine bcturbfarfield(nn)
!
!       bcturbfarfield applies the implicit treatment of the           
!       farfield boundary condition to subface nn. as the farfield     
!       boundary condition is independent of the turbulence model,     
!       this routine is valid for all models. it is assumed that the   
!       pointers in blockpointers are already set to the correct       
!       block on the correct grid level.                               
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
    real(kind=realtype) :: nnx, nny, nnz, dot
! loop over the faces of the subfaces and set the values of
! bmt and bvt for an implicit treatment.
    do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      do i=bcdata(nn)%icbeg,bcdata(nn)%icend
! determine the dot product between the outward pointing
! normal and the free stream velocity direction and add the
! possible grid velocity.
        dot = bcdata(nn)%norm(i, j, 1)*winf(ivx) + bcdata(nn)%norm(i, j&
&         , 2)*winf(ivy) + bcdata(nn)%norm(i, j, 3)*winf(ivz) - bcdata(&
&         nn)%rface(i, j)
! determine whether we are dealing with an inflow or
! outflow boundary here.
        if (dot .gt. zero) then
! outflow. simply extrapolation or zero neumann bc
! of the turbulent variables.
          do l=nt1,nt2
            select case  (bcfaceid(nn)) 
            case (imin) 
              bmti1(i, j, l, l) = -one
            case (imax) 
              bmti2(i, j, l, l) = -one
            case (jmin) 
              bmtj1(i, j, l, l) = -one
            case (jmax) 
              bmtj2(i, j, l, l) = -one
            case (kmin) 
              bmtk1(i, j, l, l) = -one
            case (kmax) 
              bmtk2(i, j, l, l) = -one
            end select
          end do
        else
! inflow. turbulent variables are prescribed.
          do l=nt1,nt2
            select case  (bcfaceid(nn)) 
            case (imin) 
              bvti1(i, j, l) = winf(l)
            case (imax) 
              bvti2(i, j, l) = winf(l)
            case (jmin) 
              bvtj1(i, j, l) = winf(l)
            case (jmax) 
              bvtj2(i, j, l) = winf(l)
            case (kmin) 
              bvtk1(i, j, l) = winf(l)
            case (kmax) 
              bvtk2(i, j, l) = winf(l)
            end select
          end do
        end if
      end do
    end do
  end subroutine bcturbfarfield
  subroutine bcturbinterface(nn)
!
!       bcturbinterface applies the halo treatment for interface halo  
!       cells, sliding mesh interface and domain interface. as these   
!       are not really boundary conditions, the variable bvt is simply 
!       set to keep the current value.                                 
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
! note that the original code had an error in the pointers...they
! were pointing to {il,jl,kl} and not {ie, je, ke}.
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
! loop over the faces of the subfaces and set the values of
! bvt to keep the current value.
    do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      do i=bcdata(nn)%icbeg,bcdata(nn)%icend
        do l=nt1,nt2
          select case  (bcfaceid(nn)) 
          case (imin) 
            bvti1(i, j, l) = w(1, i, j, l)
          case (imax) 
            bvti2(i, j, l) = w(ie, i, j, l)
          case (jmin) 
            bvtj1(i, j, l) = w(i, 1, j, l)
          case (jmax) 
            bvtj2(i, j, l) = w(i, je, j, l)
          case (kmin) 
            bvtk1(i, j, l) = w(i, j, 1, l)
          case (kmax) 
            bvtk2(i, j, l) = w(i, j, ke, l)
          end select
        end do
      end do
    end do
  end subroutine bcturbinterface
  subroutine bcturbsymm(nn)
!
!       bcturbsymm applies the implicit treatment of the symmetry      
!       boundary condition (or inviscid wall) to subface nn. as the    
!       symmetry boundary condition is independent of the turbulence   
!       model, this routine is valid for all models. it is assumed     
!       that the pointers in blockpointers are already set to the      
!       correct block on the correct grid level.                       
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
! loop over the faces of the subfaces and set the values of bmt
! for an implicit treatment. for a symmetry face this means
! that the halo value is set to the internal value.
    do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      do i=bcdata(nn)%icbeg,bcdata(nn)%icend
        do l=nt1,nt2
          select case  (bcfaceid(nn)) 
          case (imin) 
            bmti1(i, j, l, l) = -one
          case (imax) 
            bmti2(i, j, l, l) = -one
          case (jmin) 
            bmtj1(i, j, l, l) = -one
          case (jmax) 
            bmtj2(i, j, l, l) = -one
          case (kmin) 
            bmtk1(i, j, l, l) = -one
          case (kmax) 
            bmtk2(i, j, l, l) = -one
          end select
        end do
      end do
    end do
  end subroutine bcturbsymm
!  differentiation of bcturbwall in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *bvtj1 *bvtj2 *w *rlv *bvtk1
!                *bvtk2 *d2wall *bvti1 *bvti2
!   with respect to varying inputs: *bvtj1 *bvtj2 *w *rlv *bvtk1
!                *bvtk2 *d2wall *bvti1 *bvti2
!   plus diff mem management of: bvtj1:in bvtj2:in w:in rlv:in
!                bvtk1:in bvtk2:in d2wall:in bvti1:in bvti2:in
!                bcdata:in
  subroutine bcturbwall_b(nn)
!
!       bcturbwall applies the implicit treatment of the viscous       
!       wall boundary condition for the turbulence model used to the   
!       given subface nn.                                              
!       it is assumed that the pointers in blockpointers are           
!       already set to the correct block.                              
!
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use constants
    use paramturb
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, ii, jj, iimax, jjmax
    real(kind=realtype) :: tmpd, tmpe, tmpf, nu
    real(kind=realtype) :: tmpdd, nud
    real(kind=realtype), dimension(:, :, :, :), pointer :: bmt
    real(kind=realtype), dimension(:, :, :), pointer :: bvt, ww2
    real(kind=realtype), dimension(:, :), pointer :: rlv2, dd2wall
    intrinsic min
    intrinsic max
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp10
    integer(kind=inttype) :: y12
    integer(kind=inttype) :: y11
    integer(kind=inttype) :: y10
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    integer(kind=inttype) :: y9
    real(kind=realtype) :: temp
    integer(kind=inttype) :: y8
    integer(kind=inttype) :: y7
    integer(kind=inttype) :: y6
    real(kind=realtype) :: temp9
    integer(kind=inttype) :: y5
    real(kind=realtype) :: temp8
    integer(kind=inttype) :: y4
    real(kind=realtype) :: temp7
    integer(kind=inttype) :: y3
    real(kind=realtype) :: temp6
    integer(kind=inttype) :: y2
    real(kind=realtype) :: temp5
    integer(kind=inttype) :: y1
    real(kind=realtype) :: temp4
!        ================================================================
! determine the turbulence model used and loop over the faces
! of the subface and set the values of bmt and bvt for an
! implicit treatment.
    select case  (turbmodel) 
    case (spalartallmaras, spalartallmarasedwards) 

    case (komegawilcox, komegamodified, mentersst) 
!        ================================================================
! k-omega type of models. k is zero on the wall and thus the
! halo value is the negative of the first internal cell.
! for omega the situation is a bit more complicated.
! theoretically omega is infinity, but it is set to a large
! value, see menter's paper. the halo value is constructed
! such that the wall value is correct. make sure that i and j
! are limited to physical dimensions of the face for the wall
! distance. due to the usage of the dd2wall pointer and the
! fact that the original d2wall array starts at 2, there is
! an offset of -1 present in dd2wall.
      select case  (bcfaceid(nn)) 
      case (imin) 
        iimax = jl
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y1 = jjmax
          else
            y1 = j
          end if
          if (2 .lt. y1) then
            call pushinteger4(jj)
            jj = y1
            call pushcontrol1b(0)
          else
            call pushinteger4(jj)
            jj = 2
            call pushcontrol1b(1)
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y2 = iimax
            else
              y2 = i
            end if
            if (2 .lt. y2) then
              call pushinteger4(ii)
              ii = y2
              call pushcontrol1b(0)
            else
              call pushinteger4(ii)
              ii = 2
              call pushcontrol1b(1)
            end if
          end do
        end do
        do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
          do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
            nu = rlv(2, i, j)/w(2, i, j, irho)
            tmpd = one/(rkwbeta1*d2wall(2, ii, jj)**2)
            tempd = two*60.0_realtype*bvti1d(i, j, itu2)
            nud = tmpd*tempd
            tmpdd = nu*tempd
            bvti1d(i, j, itu2) = 0.0_8
            temp0 = rkwbeta1*d2wall(2, ii, jj)**2
            d2walld(2, ii, jj) = d2walld(2, ii, jj) - rkwbeta1*one*2*&
&             d2wall(2, ii, jj)*tmpdd/temp0**2
            temp = w(2, i, j, irho)
            rlvd(2, i, j) = rlvd(2, i, j) + nud/temp
            wd(2, i, j, irho) = wd(2, i, j, irho) - rlv(2, i, j)*nud/&
&             temp**2
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popinteger4(ii)
            else
              call popinteger4(ii)
            end if
          end do
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popinteger4(jj)
          else
            call popinteger4(jj)
          end if
        end do
      case (imax) 
        iimax = jl
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y3 = jjmax
          else
            y3 = j
          end if
          if (2 .lt. y3) then
            call pushinteger4(jj)
            jj = y3
            call pushcontrol1b(0)
          else
            call pushinteger4(jj)
            jj = 2
            call pushcontrol1b(1)
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y4 = iimax
            else
              y4 = i
            end if
            if (2 .lt. y4) then
              call pushinteger4(ii)
              ii = y4
              call pushcontrol1b(0)
            else
              call pushinteger4(ii)
              ii = 2
              call pushcontrol1b(1)
            end if
          end do
        end do
        do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
          do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
            nu = rlv(jl, i, j)/w(il, i, j, irho)
            tmpd = one/(rkwbeta1*d2wall(il, ii, jj)**2)
            tempd0 = two*60.0_realtype*bvti2d(i, j, itu2)
            nud = tmpd*tempd0
            tmpdd = nu*tempd0
            bvti2d(i, j, itu2) = 0.0_8
            temp2 = rkwbeta1*d2wall(il, ii, jj)**2
            d2walld(il, ii, jj) = d2walld(il, ii, jj) - rkwbeta1*one*2*&
&             d2wall(il, ii, jj)*tmpdd/temp2**2
            temp1 = w(il, i, j, irho)
            rlvd(jl, i, j) = rlvd(jl, i, j) + nud/temp1
            wd(il, i, j, irho) = wd(il, i, j, irho) - rlv(jl, i, j)*nud/&
&             temp1**2
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popinteger4(ii)
            else
              call popinteger4(ii)
            end if
          end do
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popinteger4(jj)
          else
            call popinteger4(jj)
          end if
        end do
      case (jmin) 
        iimax = il
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y5 = jjmax
          else
            y5 = j
          end if
          if (2 .lt. y5) then
            call pushinteger4(jj)
            jj = y5
            call pushcontrol1b(0)
          else
            call pushinteger4(jj)
            jj = 2
            call pushcontrol1b(1)
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y6 = iimax
            else
              y6 = i
            end if
            if (2 .lt. y6) then
              call pushinteger4(ii)
              ii = y6
              call pushcontrol1b(0)
            else
              call pushinteger4(ii)
              ii = 2
              call pushcontrol1b(1)
            end if
          end do
        end do
        do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
          do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
            nu = rlv(i, 2, j)/w(i, 2, j, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, 2, jj)**2)
            tempd1 = two*60.0_realtype*bvtj1d(i, j, itu2)
            nud = tmpd*tempd1
            tmpdd = nu*tempd1
            bvtj1d(i, j, itu2) = 0.0_8
            temp4 = rkwbeta1*d2wall(ii, 2, jj)**2
            d2walld(ii, 2, jj) = d2walld(ii, 2, jj) - rkwbeta1*one*2*&
&             d2wall(ii, 2, jj)*tmpdd/temp4**2
            temp3 = w(i, 2, j, irho)
            rlvd(i, 2, j) = rlvd(i, 2, j) + nud/temp3
            wd(i, 2, j, irho) = wd(i, 2, j, irho) - rlv(i, 2, j)*nud/&
&             temp3**2
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popinteger4(ii)
            else
              call popinteger4(ii)
            end if
          end do
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popinteger4(jj)
          else
            call popinteger4(jj)
          end if
        end do
      case (jmax) 
        iimax = il
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y7 = jjmax
          else
            y7 = j
          end if
          if (2 .lt. y7) then
            call pushinteger4(jj)
            jj = y7
            call pushcontrol1b(0)
          else
            call pushinteger4(jj)
            jj = 2
            call pushcontrol1b(1)
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y8 = iimax
            else
              y8 = i
            end if
            if (2 .lt. y8) then
              call pushinteger4(ii)
              ii = y8
              call pushcontrol1b(0)
            else
              call pushinteger4(ii)
              ii = 2
              call pushcontrol1b(1)
            end if
          end do
        end do
        do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
          do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
            nu = rlv(i, jl, j)/w(i, jl, j, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, jl, jj)**2)
            tempd2 = two*60.0_realtype*bvtj2d(i, j, itu2)
            nud = tmpd*tempd2
            tmpdd = nu*tempd2
            bvtj2d(i, j, itu2) = 0.0_8
            temp6 = rkwbeta1*d2wall(ii, jl, jj)**2
            d2walld(ii, jl, jj) = d2walld(ii, jl, jj) - rkwbeta1*one*2*&
&             d2wall(ii, jl, jj)*tmpdd/temp6**2
            temp5 = w(i, jl, j, irho)
            rlvd(i, jl, j) = rlvd(i, jl, j) + nud/temp5
            wd(i, jl, j, irho) = wd(i, jl, j, irho) - rlv(i, jl, j)*nud/&
&             temp5**2
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popinteger4(ii)
            else
              call popinteger4(ii)
            end if
          end do
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popinteger4(jj)
          else
            call popinteger4(jj)
          end if
        end do
      case (kmin) 
        iimax = il
        jjmax = jl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y9 = jjmax
          else
            y9 = j
          end if
          if (2 .lt. y9) then
            call pushinteger4(jj)
            jj = y9
            call pushcontrol1b(0)
          else
            call pushinteger4(jj)
            jj = 2
            call pushcontrol1b(1)
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y10 = iimax
            else
              y10 = i
            end if
            if (2 .lt. y10) then
              call pushinteger4(ii)
              ii = y10
              call pushcontrol1b(0)
            else
              call pushinteger4(ii)
              ii = 2
              call pushcontrol1b(1)
            end if
          end do
        end do
        do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
          do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
            nu = rlv(i, j, 2)/w(i, j, 2, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, jj, 2)**2)
            tempd3 = two*60.0_realtype*bvtk1d(i, j, itu2)
            nud = tmpd*tempd3
            tmpdd = nu*tempd3
            bvtk1d(i, j, itu2) = 0.0_8
            temp8 = rkwbeta1*d2wall(ii, jj, 2)**2
            d2walld(ii, jj, 2) = d2walld(ii, jj, 2) - rkwbeta1*one*2*&
&             d2wall(ii, jj, 2)*tmpdd/temp8**2
            temp7 = w(i, j, 2, irho)
            rlvd(i, j, 2) = rlvd(i, j, 2) + nud/temp7
            wd(i, j, 2, irho) = wd(i, j, 2, irho) - rlv(i, j, 2)*nud/&
&             temp7**2
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popinteger4(ii)
            else
              call popinteger4(ii)
            end if
          end do
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popinteger4(jj)
          else
            call popinteger4(jj)
          end if
        end do
      case (kmax) 
        iimax = il
        jjmax = jl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y11 = jjmax
          else
            y11 = j
          end if
          if (2 .lt. y11) then
            call pushinteger4(jj)
            jj = y11
            call pushcontrol1b(0)
          else
            call pushinteger4(jj)
            jj = 2
            call pushcontrol1b(1)
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y12 = iimax
            else
              y12 = i
            end if
            if (2 .lt. y12) then
              call pushinteger4(ii)
              ii = y12
              call pushcontrol1b(0)
            else
              call pushinteger4(ii)
              ii = 2
              call pushcontrol1b(1)
            end if
          end do
        end do
        do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
          do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
            nu = rlv(i, j, kl)/w(i, j, kl, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, jj, kl)**2)
            tempd4 = two*60.0_realtype*bvtk2d(i, j, itu2)
            nud = tmpd*tempd4
            tmpdd = nu*tempd4
            bvtk2d(i, j, itu2) = 0.0_8
            temp10 = rkwbeta1*d2wall(ii, jj, kl)**2
            d2walld(ii, jj, kl) = d2walld(ii, jj, kl) - rkwbeta1*one*2*&
&             d2wall(ii, jj, kl)*tmpdd/temp10**2
            temp9 = w(i, j, kl, irho)
            rlvd(i, j, kl) = rlvd(i, j, kl) + nud/temp9
            wd(i, j, kl, irho) = wd(i, j, kl, irho) - rlv(i, j, kl)*nud/&
&             temp9**2
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popinteger4(ii)
            else
              call popinteger4(ii)
            end if
          end do
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popinteger4(jj)
          else
            call popinteger4(jj)
          end if
        end do
      end select
    end select
  end subroutine bcturbwall_b
!  differentiation of turb2ndhalo in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev *w
!   with respect to varying inputs: *rev *w
!   plus diff mem management of: rev:in w:in bcdata:in
  subroutine turb2ndhalo_b(nn)
!
!       turb2ndhalo sets the turbulent variables in the second halo    
!       cell for the given subface. simple constant extrapolation is   
!       used to avoid problems.                                        
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmp2
    real(kind=realtype) :: tmp3
    real(kind=realtype) :: tmp4
    integer :: branch
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd4
    real(kind=realtype) :: tmpd3
    real(kind=realtype) :: tmpd2
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
! determine the face on which this subface is located and set
! some pointers accordingly.
! loop over the turbulent variables and set the second halo
! value. if this is an eddy model, also set the eddy viscosity.
    select case  (bcfaceid(nn)) 
    case (imin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          if (eddymodel) then
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
        end do
      end do
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            revd(1, i, j) = revd(1, i, j) + revd(0, i, j)
            revd(0, i, j) = 0.0_8
          end if
          do l=nt2,nt1,-1
            wd(1, i, j, l) = wd(1, i, j, l) + wd(0, i, j, l)
            wd(0, i, j, l) = 0.0_8
          end do
        end do
      end do
    case (imax) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          if (eddymodel) then
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
        end do
      end do
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            tmpd0 = revd(ib, i, j)
            revd(ib, i, j) = 0.0_8
            revd(ie, i, j) = revd(ie, i, j) + tmpd0
          end if
          do l=nt2,nt1,-1
            tmpd = wd(ib, i, j, l)
            wd(ib, i, j, l) = 0.0_8
            wd(ie, i, j, l) = wd(ie, i, j, l) + tmpd
          end do
        end do
      end do
    case (jmin) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          if (eddymodel) then
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
        end do
      end do
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            revd(i, 1, j) = revd(i, 1, j) + revd(i, 0, j)
            revd(i, 0, j) = 0.0_8
          end if
          do l=nt2,nt1,-1
            wd(i, 1, j, l) = wd(i, 1, j, l) + wd(i, 0, j, l)
            wd(i, 0, j, l) = 0.0_8
          end do
        end do
      end do
    case (jmax) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          if (eddymodel) then
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
        end do
      end do
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            tmpd2 = revd(i, jb, j)
            revd(i, jb, j) = 0.0_8
            revd(i, je, j) = revd(i, je, j) + tmpd2
          end if
          do l=nt2,nt1,-1
            tmpd1 = wd(i, jb, j, l)
            wd(i, jb, j, l) = 0.0_8
            wd(i, je, j, l) = wd(i, je, j, l) + tmpd1
          end do
        end do
      end do
    case (kmin) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          if (eddymodel) then
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
        end do
      end do
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            revd(i, j, 1) = revd(i, j, 1) + revd(i, j, 0)
            revd(i, j, 0) = 0.0_8
          end if
          do l=nt2,nt1,-1
            wd(i, j, 1, l) = wd(i, j, 1, l) + wd(i, j, 0, l)
            wd(i, j, 0, l) = 0.0_8
          end do
        end do
      end do
    case (kmax) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          if (eddymodel) then
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
        end do
      end do
      do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
        do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            tmpd4 = revd(i, j, kb)
            revd(i, j, kb) = 0.0_8
            revd(i, j, ke) = revd(i, j, ke) + tmpd4
          end if
          do l=nt2,nt1,-1
            tmpd3 = wd(i, j, kb, l)
            wd(i, j, kb, l) = 0.0_8
            wd(i, j, ke, l) = wd(i, j, ke, l) + tmpd3
          end do
        end do
      end do
    end select
  end subroutine turb2ndhalo_b
  subroutine turb2ndhalo(nn)
!
!       turb2ndhalo sets the turbulent variables in the second halo    
!       cell for the given subface. simple constant extrapolation is   
!       used to avoid problems.                                        
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, l
! determine the face on which this subface is located and set
! some pointers accordingly.
! loop over the turbulent variables and set the second halo
! value. if this is an eddy model, also set the eddy viscosity.
    select case  (bcfaceid(nn)) 
    case (imin) 
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          do l=nt1,nt2
            w(0, i, j, l) = w(1, i, j, l)
          end do
          if (eddymodel) rev(0, i, j) = rev(1, i, j)
        end do
      end do
    case (imax) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          do l=nt1,nt2
            w(ib, i, j, l) = w(ie, i, j, l)
          end do
          if (eddymodel) rev(ib, i, j) = rev(ie, i, j)
        end do
      end do
    case (jmin) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          do l=nt1,nt2
            w(i, 0, j, l) = w(i, 1, j, l)
          end do
          if (eddymodel) rev(i, 0, j) = rev(i, 1, j)
        end do
      end do
    case (jmax) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          do l=nt1,nt2
            w(i, jb, j, l) = w(i, je, j, l)
          end do
          if (eddymodel) rev(i, jb, j) = rev(i, je, j)
        end do
      end do
    case (kmin) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          do l=nt1,nt2
            w(i, j, 0, l) = w(i, j, 1, l)
          end do
          if (eddymodel) rev(i, j, 0) = rev(i, j, 1)
        end do
      end do
    case (kmax) 
!===============================================================
      do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        do i=bcdata(nn)%icbeg,bcdata(nn)%icend
          do l=nt1,nt2
            w(i, j, kb, l) = w(i, j, ke, l)
          end do
          if (eddymodel) rev(i, j, kb) = rev(i, j, ke)
        end do
      end do
    end select
  end subroutine turb2ndhalo
  subroutine turbbcnswall(secondhalo)
!
!       turbbcnswall applies the viscous wall boundary conditions      
!       of the turbulent transport equations to a block. it is assumed 
!       that the pointers in blockpointers are already set to the      
!       correct block on the correct grid level.                       
!
    use constants
    use blockpointers
    use flowvarrefstate
    implicit none
!
!      subroutine argument.
!
    logical, intent(in) :: secondhalo
!
!      local variables.
!
    integer(kind=inttype) :: nn, i, j, l, m
! loop over the viscous subfaces of this block.
bocos:do nn=1,nviscbocos
! set the corresponding arrays.
      call bcturbwall(nn)
! loop over the faces and set the state in
! the turbulent halo cells.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              w(1, i, j, l) = bvti1(i, j, l)
              do m=nt1,nt2
                w(1, i, j, l) = w(1, i, j, l) - bmti1(i, j, l, m)*w(2, i&
&                 , j, m)
              end do
              if (secondhalo) w(0, i, j, l) = w(1, i, j, l)
            end do
            if (eddymodel) then
              rev(1, i, j) = -rev(2, i, j)
              if (secondhalo) rev(0, i, j) = rev(1, i, j)
            end if
          end do
        end do
      case (imax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              w(ie, i, j, l) = bvti2(i, j, l)
              do m=nt1,nt2
                w(ie, i, j, l) = w(ie, i, j, l) - bmti2(i, j, l, m)*w(il&
&                 , i, j, m)
              end do
              if (secondhalo) w(ib, i, j, l) = w(ie, i, j, l)
            end do
            if (eddymodel) then
              rev(ie, i, j) = -rev(il, i, j)
              if (secondhalo) rev(ib, i, j) = rev(ie, i, j)
            end if
          end do
        end do
      case (jmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              w(i, 1, j, l) = bvtj1(i, j, l)
              do m=nt1,nt2
                w(i, 1, j, l) = w(i, 1, j, l) - bmtj1(i, j, l, m)*w(i, 2&
&                 , j, m)
              end do
              if (secondhalo) w(i, 0, j, l) = w(i, 1, j, l)
            end do
            if (eddymodel) then
              rev(i, 1, j) = -rev(i, 2, j)
              if (secondhalo) rev(i, 0, j) = rev(i, 1, j)
            end if
          end do
        end do
      case (jmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              w(i, je, j, l) = bvtj2(i, j, l)
              do m=nt1,nt2
                w(i, je, j, l) = w(i, je, j, l) - bmtj2(i, j, l, m)*w(i&
&                 , jl, j, m)
              end do
              if (secondhalo) w(i, jb, j, l) = w(i, je, j, l)
            end do
            if (eddymodel) then
              rev(i, je, j) = -rev(i, jl, j)
              if (secondhalo) rev(i, jb, j) = rev(i, je, j)
            end if
          end do
        end do
      case (kmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              w(i, j, 1, l) = bvtk1(i, j, l)
              do m=nt1,nt2
                w(i, j, 1, l) = w(i, j, 1, l) - bmtk1(i, j, l, m)*w(i, j&
&                 , 2, m)
              end do
              if (secondhalo) w(i, j, 0, l) = w(i, j, 1, l)
            end do
            if (eddymodel) then
              rev(i, j, 1) = -rev(i, j, 2)
              if (secondhalo) rev(i, j, 0) = rev(i, j, 1)
            end if
          end do
        end do
      case (kmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            do l=nt1,nt2
              w(i, j, ke, l) = bvtk2(i, j, l)
              do m=nt1,nt2
                w(i, j, ke, l) = w(i, j, ke, l) - bmtk2(i, j, l, m)*w(i&
&                 , j, kl, m)
              end do
              if (secondhalo) w(i, j, kb, l) = w(i, j, ke, l)
            end do
            if (eddymodel) then
              rev(i, j, ke) = -rev(i, j, kl)
              if (secondhalo) rev(i, j, kb) = rev(i, j, ke)
            end if
          end do
        end do
      end select
    end do bocos
  end subroutine turbbcnswall
  subroutine bcturbwall(nn)
!
!       bcturbwall applies the implicit treatment of the viscous       
!       wall boundary condition for the turbulence model used to the   
!       given subface nn.                                              
!       it is assumed that the pointers in blockpointers are           
!       already set to the correct block.                              
!
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use constants
    use paramturb
    implicit none
!
!      subroutine arguments.
!
    integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
    integer(kind=inttype) :: i, j, ii, jj, iimax, jjmax
    real(kind=realtype) :: tmpd, tmpe, tmpf, nu
    real(kind=realtype), dimension(:, :, :, :), pointer :: bmt
    real(kind=realtype), dimension(:, :, :), pointer :: bvt, ww2
    real(kind=realtype), dimension(:, :), pointer :: rlv2, dd2wall
    intrinsic min
    intrinsic max
    integer(kind=inttype) :: y12
    integer(kind=inttype) :: y11
    integer(kind=inttype) :: y10
    integer(kind=inttype) :: y9
    integer(kind=inttype) :: y8
    integer(kind=inttype) :: y7
    integer(kind=inttype) :: y6
    integer(kind=inttype) :: y5
    integer(kind=inttype) :: y4
    integer(kind=inttype) :: y3
    integer(kind=inttype) :: y2
    integer(kind=inttype) :: y1
!        ================================================================
! determine the turbulence model used and loop over the faces
! of the subface and set the values of bmt and bvt for an
! implicit treatment.
    select case  (turbmodel) 
    case (spalartallmaras, spalartallmarasedwards) 
! spalart-allmaras type of model. value at the wall is zero,
! so simply negate the internal value.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmti1(i, j, itu1, itu1) = one
          end do
        end do
      case (imax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmti2(i, j, itu1, itu1) = one
          end do
        end do
      case (jmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtj1(i, j, itu1, itu1) = one
          end do
        end do
      case (jmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtj2(i, j, itu1, itu1) = one
          end do
        end do
      case (kmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtk1(i, j, itu1, itu1) = one
          end do
        end do
      case (kmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtk2(i, j, itu1, itu1) = one
          end do
        end do
      end select
    case (komegawilcox, komegamodified, mentersst) 
!        ================================================================
! k-omega type of models. k is zero on the wall and thus the
! halo value is the negative of the first internal cell.
! for omega the situation is a bit more complicated.
! theoretically omega is infinity, but it is set to a large
! value, see menter's paper. the halo value is constructed
! such that the wall value is correct. make sure that i and j
! are limited to physical dimensions of the face for the wall
! distance. due to the usage of the dd2wall pointer and the
! fact that the original d2wall array starts at 2, there is
! an offset of -1 present in dd2wall.
      select case  (bcfaceid(nn)) 
      case (imin) 
        iimax = jl
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y1 = jjmax
          else
            y1 = j
          end if
          if (2 .lt. y1) then
            jj = y1
          else
            jj = 2
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y2 = iimax
            else
              y2 = i
            end if
            if (2 .lt. y2) then
              ii = y2
            else
              ii = 2
            end if
            nu = rlv(2, i, j)/w(2, i, j, irho)
            tmpd = one/(rkwbeta1*d2wall(2, ii, jj)**2)
            bmti1(i, j, itu1, itu1) = one
            bmti1(i, j, itu2, itu2) = one
            bvti1(i, j, itu2) = two*60.0_realtype*nu*tmpd
          end do
        end do
      case (imax) 
        iimax = jl
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y3 = jjmax
          else
            y3 = j
          end if
          if (2 .lt. y3) then
            jj = y3
          else
            jj = 2
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y4 = iimax
            else
              y4 = i
            end if
            if (2 .lt. y4) then
              ii = y4
            else
              ii = 2
            end if
            nu = rlv(jl, i, j)/w(il, i, j, irho)
            tmpd = one/(rkwbeta1*d2wall(il, ii, jj)**2)
            bmti2(i, j, itu1, itu1) = one
            bmti2(i, j, itu2, itu2) = one
            bvti2(i, j, itu2) = two*60.0_realtype*nu*tmpd
          end do
        end do
      case (jmin) 
        iimax = il
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y5 = jjmax
          else
            y5 = j
          end if
          if (2 .lt. y5) then
            jj = y5
          else
            jj = 2
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y6 = iimax
            else
              y6 = i
            end if
            if (2 .lt. y6) then
              ii = y6
            else
              ii = 2
            end if
            nu = rlv(i, 2, j)/w(i, 2, j, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, 2, jj)**2)
            bmtj1(i, j, itu1, itu1) = one
            bmtj1(i, j, itu2, itu2) = one
            bvtj1(i, j, itu2) = two*60.0_realtype*nu*tmpd
          end do
        end do
      case (jmax) 
        iimax = il
        jjmax = kl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y7 = jjmax
          else
            y7 = j
          end if
          if (2 .lt. y7) then
            jj = y7
          else
            jj = 2
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y8 = iimax
            else
              y8 = i
            end if
            if (2 .lt. y8) then
              ii = y8
            else
              ii = 2
            end if
            nu = rlv(i, jl, j)/w(i, jl, j, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, jl, jj)**2)
            bmtj2(i, j, itu1, itu1) = one
            bmtj2(i, j, itu2, itu2) = one
            bvtj2(i, j, itu2) = two*60.0_realtype*nu*tmpd
          end do
        end do
      case (kmin) 
        iimax = il
        jjmax = jl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y9 = jjmax
          else
            y9 = j
          end if
          if (2 .lt. y9) then
            jj = y9
          else
            jj = 2
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y10 = iimax
            else
              y10 = i
            end if
            if (2 .lt. y10) then
              ii = y10
            else
              ii = 2
            end if
            nu = rlv(i, j, 2)/w(i, j, 2, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, jj, 2)**2)
            bmtk1(i, j, itu1, itu1) = one
            bmtk1(i, j, itu2, itu2) = one
            bvtk1(i, j, itu2) = two*60.0_realtype*nu*tmpd
          end do
        end do
      case (kmax) 
        iimax = il
        jjmax = jl
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          if (j .gt. jjmax) then
            y11 = jjmax
          else
            y11 = j
          end if
          if (2 .lt. y11) then
            jj = y11
          else
            jj = 2
          end if
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            if (i .gt. iimax) then
              y12 = iimax
            else
              y12 = i
            end if
            if (2 .lt. y12) then
              ii = y12
            else
              ii = 2
            end if
            nu = rlv(i, j, kl)/w(i, j, kl, irho)
            tmpd = one/(rkwbeta1*d2wall(ii, jj, kl)**2)
            bmtk2(i, j, itu1, itu1) = one
            bmtk2(i, j, itu2, itu2) = one
            bvtk2(i, j, itu2) = two*60.0_realtype*nu*tmpd
          end do
        end do
      end select
    case (ktau) 
!        ================================================================
! k-tau model. both k and tau are zero at the wall, so the
! negative value of the internal cell is taken for the halo.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmti1(i, j, itu1, itu1) = one
            bmti1(i, j, itu2, itu2) = one
          end do
        end do
      case (imax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmti2(i, j, itu1, itu1) = one
            bmti2(i, j, itu2, itu2) = one
          end do
        end do
      case (jmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtj1(i, j, itu1, itu1) = one
            bmtj1(i, j, itu2, itu2) = one
          end do
        end do
      case (jmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtj2(i, j, itu1, itu1) = one
            bmtj2(i, j, itu2, itu2) = one
          end do
        end do
      case (kmin) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtk1(i, j, itu1, itu1) = one
            bmtk1(i, j, itu2, itu2) = one
          end do
        end do
      case (kmax) 
        do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
          do i=bcdata(nn)%icbeg,bcdata(nn)%icend
            bmtk2(i, j, itu1, itu1) = one
            bmtk2(i, j, itu2, itu2) = one
          end do
        end do
      end select
    end select
  end subroutine bcturbwall
end module turbbcroutines_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module surfaceintegrations_b
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
  subroutine flowproperties(localvalues)
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use bcroutines_b
    use costfunctions
    use surfacefamilies
    use sorting, only : bsearchintegers
    use utils_b, only : setbcpointers, resetbcpointers
    use flowutils_b, only : computeptot, computettot
    use bcpointers_b
    implicit none
!
!      subroutine arguments
!
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
! local variables
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps
    integer(kind=inttype) :: nn, i, j, ii
    real(kind=realtype) :: fact
    real(kind=realtype) :: sf, vnm, vxm, vym, vzm
    real(kind=realtype) :: pm, ptot, ttot, rhom, massflowratelocal, tmp
    intrinsic size
    intrinsic mod
    massflowrate = zero
    mass_ptot = zero
    mass_ttot = zero
    mass_ps = zero
    sf = zero
bocos:do nn=1,nbocos
      if (bsearchintegers(bcdata(nn)%famid, famgroups, size(famgroups)) &
&         .gt. 0) then
        call setbcpointers(nn, .true.)
        if (((bctype(nn) .eq. subsonicinflow .or. bctype(nn) .eq. &
&           supersonicinflow) .or. bctype(nn) .eq. subsonicoutflow) .or.&
&           bctype(nn) .eq. supersonicoutflow) then
          select case  (bcfaceid(nn)) 
          case (imin) 
            fact = -one
          case (imax) 
            fact = one
          case (jmin) 
            fact = -one
          case (jmax) 
            fact = one
          case (kmin) 
            fact = -one
          case (kmax) 
            fact = one
          end select
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(nn)%jnbeg+1),bcdata(nn)%jnend
!    do i=(bcdata(nn)%inbeg+1),bcdata(nn)%inend
          do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
&             bcdata(nn)%inbeg)-1
            i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn&
&             )%inbeg + 1
            j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&             jnbeg + 1
            if (addgridvelocities) sf = sface(i, j)
            vxm = half*(ww1(i, j, ivx)+ww2(i, j, ivx))
            vym = half*(ww1(i, j, ivy)+ww2(i, j, ivy))
            vzm = half*(ww1(i, j, ivz)+ww2(i, j, ivz))
            rhom = half*(ww1(i, j, irho)+ww2(i, j, irho))
            pm = half*(pp1(i, j)+pp2(i, j))
            vnm = vxm*ssi(i, j, 1) + vym*ssi(i, j, 2) + vzm*ssi(i, j, 3)&
&             - sf
            massflowratelocal = rhom*vnm
            massflowrate = massflowrate + massflowratelocal
            call computeptot(rhom, vxm, vym, vzm, pm, ptot)
            call computettot(rhom, vxm, vym, vzm, pm, ttot)
            mass_ptot = mass_ptot + ptot*massflowratelocal
            mass_ttot = mass_ttot + ttot*massflowratelocal
            mass_ps = mass_ps + pm*massflowratelocal
          end do
          massflowrate = massflowrate*fact
          mass_ptot = mass_ptot*fact
          mass_ttot = mass_ttot*fact
          mass_ps = mass_ps*fact
        end if
      end if
    end do bocos
! increment the local values array with what we computed here
    localvalues(imassflow) = localvalues(imassflow) + massflowrate
    localvalues(imassptot) = localvalues(imassptot) + mass_ptot
    localvalues(imassttot) = localvalues(imassttot) + mass_ttot
    localvalues(imassps) = localvalues(imassps) + mass_ps
  end subroutine flowproperties
!  differentiation of forcesandmoments in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *x *(*bcdata.fv) *(*bcdata.fp)
!                *(*bcdata.area) machcoef pointref gammainf pinf
!                pref *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
!                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
!                *ww3 localvalues
!   with respect to varying inputs: *rev *p *w *rlv *x *si *sj
!                *sk *(*viscsubface.tau) *(*bcdata.fv) *(*bcdata.fp)
!                *(*bcdata.area) veldirfreestream machcoef pointref
!                gammainf pinf pref *xx *rev0 *rev1 *rev2 *rev3
!                *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi
!                *ww0 *ww1 *ww2 *ww3
!   plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
!                sj:in sk:in viscsubface:in *viscsubface.tau:in
!                bcdata:in *bcdata.fv:in *bcdata.fp:in *bcdata.area:in
!                xx:in rev0:in rev1:in rev2:in rev3:in pp0:in pp1:in
!                pp2:in pp3:in rlv0:in rlv1:in rlv2:in rlv3:in
!                ssi:in ww0:in ww1:in ww2:in ww3:in
  subroutine forcesandmoments_b(localvalues, localvaluesd)
!
!       forcesandmoments computes the contribution of the block
!       given by the pointers in blockpointers to the force and
!       moment of the geometry. a distinction is made
!       between the inviscid and viscous parts. in case the maximum
!       yplus value must be monitored (only possible for rans), this
!       value is also computed. the separation sensor and the cavita-
!       tion sensor is also computed
!       here.
!
    use constants
    use communication
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use bcroutines_b
    use costfunctions
    use surfacefamilies
    use sorting, only : bsearchintegers
    use utils_b, only : setbcpointers, setbcpointers_b, resetbcpointers,&
&   resetbcpointers_b
    use bcpointers_b
    implicit none
!
!      subroutine arguments
!
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvaluesd
!
!      local variables.
!
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype), dimension(3) :: fpd, fvd, mpd, mvd
    real(kind=realtype) :: yplusmax, sepsensor, sepsensoravg(3), &
&   cavitation
    real(kind=realtype) :: sepsensord, sepsensoravgd(3), cavitationd
    integer(kind=inttype) :: nn, i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
    real(kind=realtype) :: pm1d, fxd, fyd, fzd
    real(kind=realtype) :: xc, yc, zc, qf(3)
    real(kind=realtype) :: xcd, ycd, zcd
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: v(3), sensor, sensor1, cp, tmp, plocal
    real(kind=realtype) :: vd(3), sensord, sensor1d, cpd, tmpd, plocald
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxxd, tauyyd, tauzzd
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxyd, tauxzd, tauyzd
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype), dimension(3) :: refpointd
    real(kind=realtype) :: mx, my, mz, cellarea
    real(kind=realtype) :: mxd, myd, mzd, cellaread
    logical :: viscoussubface
    intrinsic size
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
    integer(kind=inttype) :: res
    real(kind=realtype), dimension(3) :: tmp0
    integer :: branch
    integer :: ad_to
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd13(3)
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd0(3)
    integer :: ii1
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp4
    real(kind=realtype) :: tempd15
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
! loop over the boundary subfaces of this block.
bocos:do nn=1,nbocos
!
!         integrate the inviscid contribution over the solid walls,
!         either inviscid or viscous. the integration is done with
!         cp. for closed contours this is equal to the integration
!         of p; for open contours this is not the case anymore.
!         question is whether a force for an open contour is
!         meaningful anyway.
!
      res = bsearchintegers(bcdata(nn)%famid, famgroups, size(famgroups)&
&       )
      if (res .gt. 0) then
        if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&           nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! subface is a wall. check if it is a viscous wall.
          viscoussubface = .true.
          if (bctype(nn) .eq. eulerwall) viscoussubface = .false.
! set a bunch of pointers depending on the face id to make
! a generic treatment possible. the routine setbcpointers
! is not used, because quite a few other ones are needed.
          call pushreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3&
&                       ))
          call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
          call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
          call setbcpointers(nn, .true.)
          select case  (bcfaceid(nn)) 
          case (imin) 
            call pushreal8(fact)
            fact = -one
            call pushcontrol3b(5)
          case (imax) 
            call pushreal8(fact)
            fact = one
            call pushcontrol3b(4)
          case (jmin) 
            call pushreal8(fact)
            fact = -one
            call pushcontrol3b(3)
          case (jmax) 
            call pushreal8(fact)
            fact = one
            call pushcontrol3b(2)
          case (kmin) 
            call pushreal8(fact)
            fact = -one
            call pushcontrol3b(1)
          case (kmax) 
            call pushreal8(fact)
            fact = one
            call pushcontrol3b(0)
          case default
            call pushcontrol3b(6)
          end select
          call pushinteger4(i)
          call pushinteger4(j)
          call pushreal8(xc)
          call pushinteger4(blk)
          call pushreal8(plocal)
          call pushreal8(yc)
          call pushreal8(tmp)
          call pushreal8(sensor)
          call pushreal8(cellarea)
          call pushreal8(zc)
          call pushreal8(fx)
          call pushreal8(fy)
          call pushreal8(fz)
          call pushreal8(sensor1)
          call pushreal8array(v, 3)
          call pushreal8array(xx, size(xx, 1)*size(xx, 2)*size(xx, 3))
          call pushreal8array(pp1, size(pp1, 1)*size(pp1, 2))
          call pushreal8array(pp2, size(pp2, 1)*size(pp2, 2))
          call pushreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3&
&                       ))
          call pushreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3&
&                       ))
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(nn)%jnbeg+1),bcdata(nn)%jnend
!    do i=(bcdata(nn)%inbeg+1),bcdata(nn)%inend
          do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
&             bcdata(nn)%inbeg)-1
            i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn&
&             )%inbeg + 1
            j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&             jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
            pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1)) - refpoint(1)
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2)) - refpoint(2)
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3)) - refpoint(3)
            if (bcdata(nn)%iblank(i, j) .lt. 0) then
              blk = 0
            else
              blk = bcdata(nn)%iblank(i, j)
            end if
            fx = pm1*ssi(i, j, 1)
            fy = pm1*ssi(i, j, 2)
            fz = pm1*ssi(i, j, 3)
! iblank forces
            fx = fx*blk
            fy = fy*blk
            fz = fz*blk
! update the inviscid force and moment coefficients.
            fp(1) = fp(1) + fx
            fp(2) = fp(2) + fy
            fp(3) = fp(3) + fz
            mx = yc*fz - zc*fy
            my = zc*fx - xc*fz
            mz = xc*fy - yc*fx
            mp(1) = mp(1) + mx
            mp(2) = mp(2) + my
            mp(3) = mp(3) + mz
! save the face-based forces and area
            bcdata(nn)%fp(i, j, 1) = fx
            bcdata(nn)%fp(i, j, 2) = fy
            bcdata(nn)%fp(i, j, 3) = fz
            cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j&
&             , 3)**2)
            bcdata(nn)%area(i, j) = cellarea
! get normalized surface velocity:
            v(1) = ww2(i, j, ivx)
            v(2) = ww2(i, j, ivy)
            v(3) = ww2(i, j, ivz)
            v = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
! dot product with free stream
            sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)&
&             +v(3)*veldirfreestream(3))
!now run through a smooth heaviside function:
            sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&             sepsensoroffset))))
! and integrate over the area of this cell and save:
            sensor = sensor*cellarea
            sepsensor = sepsensor + sensor
! also accumulate into the sepsensoravg
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1))
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2))
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3))
            sepsensoravg(1) = sepsensoravg(1) + sensor*xc
            sepsensoravg(2) = sepsensoravg(2) + sensor*yc
            sepsensoravg(3) = sepsensoravg(3) + sensor*zc
            plocal = pp2(i, j)
            tmp = two/(gammainf*machcoef*machcoef)
            cp = tmp*(plocal-pinf)
            sigma = 1.4
            sensor1 = -cp - sigma
            sensor1 = one/(one+exp(-(2*10*sensor1)))
            sensor1 = sensor1*cellarea
            cavitation = cavitation + sensor1
          end do
!
!           integration of the viscous forces.
!           only for viscous boundaries.
!
          if (viscoussubface) then
! replace norm with bcdata norm - peter lyu
!norm => bcdata(nn)%norm
! loop over the quadrilateral faces of the subface and
! compute the viscous contribution to the force and
! moment and update the maximum value of y+.
            do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%&
&               inend-bcdata(nn)%inbeg)-1
              call pushinteger4(i)
              i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(&
&               nn)%inbeg + 1
              call pushinteger4(j)
              j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&               jnbeg + 1
              if (bcdata(nn)%iblank(i, j) .lt. 0) then
                call pushinteger4(blk)
                blk = 0
                call pushcontrol1b(0)
              else
                call pushinteger4(blk)
                blk = bcdata(nn)%iblank(i, j)
                call pushcontrol1b(1)
              end if
              tauxx = viscsubface(nn)%tau(i, j, 1)
              tauyy = viscsubface(nn)%tau(i, j, 2)
              tauzz = viscsubface(nn)%tau(i, j, 3)
              tauxy = viscsubface(nn)%tau(i, j, 4)
              tauxz = viscsubface(nn)%tau(i, j, 5)
              tauyz = viscsubface(nn)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
              call pushreal8(fx)
              fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*&
&               ssi(i, j, 3))*pref)
              call pushreal8(fy)
              fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*&
&               ssi(i, j, 3))*pref)
              call pushreal8(fz)
              fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*&
&               ssi(i, j, 3))*pref)
! iblank forces after saving for zipper mesh
              fx = fx*blk
              fy = fy*blk
              fz = fz*blk
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
              call pushreal8(xc)
              xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+&
&               1, j+1, 1)) - refpoint(1)
              call pushreal8(yc)
              yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+&
&               1, j+1, 2)) - refpoint(2)
              call pushreal8(zc)
              zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+&
&               1, j+1, 3)) - refpoint(3)
! update the viscous force and moment coefficients.
! save the face based forces for the slice operations
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
            end do
            call pushinteger4(ii - 1)
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
          end if
          call pushreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*&
&                       size(sk, 4))
          call pushreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*&
&                       size(sj, 4))
          call pushreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*&
&                       size(si, 4))
          call pushreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x&
&                       , 4))
          call pushreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3&
&                       ))
          call pushreal8array(sfacek, size(sfacek, 1)*size(sfacek, 2)*&
&                       size(sfacek, 3))
          call pushreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(&
&                       gamma, 3))
          call pushreal8array(sfacej, size(sfacej, 1)*size(sfacej, 2)*&
&                       size(sfacej, 3))
          call pushreal8array(sfacei, size(sfacei, 1)*size(sfacei, 2)*&
&                       size(sfacei, 3))
          call pushreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
          call pushreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3&
&                       ))
          call resetbcpointers(nn, .true.)
          call pushcontrol2b(3)
        else
          call pushcontrol2b(2)
        end if
      else if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&         nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! if it wasn't included, but still a wall...zero
        call pushcontrol2b(1)
      else
        call pushcontrol2b(0)
      end if
    end do bocos
    sepsensoravgd = 0.0_8
    sepsensoravgd = localvaluesd(isepavg:isepavg+2)
    cavitationd = localvaluesd(icavitation)
    sepsensord = localvaluesd(isepsensor)
    mvd = 0.0_8
    mvd = localvaluesd(imv:imv+2)
    mpd = 0.0_8
    mpd = localvaluesd(imp:imp+2)
    fvd = 0.0_8
    fvd = localvaluesd(ifv:ifv+2)
    fpd = 0.0_8
    fpd = localvaluesd(ifp:ifp+2)
    revd = 0.0_8
    pd = 0.0_8
    rlvd = 0.0_8
    sid = 0.0_8
    sjd = 0.0_8
    skd = 0.0_8
    do ii1=1,size(viscsubfaced)
      viscsubfaced(ii1)%tau = 0.0_8
    end do
    veldirfreestreamd = 0.0_8
    vd = 0.0_8
    refpointd = 0.0_8
    do nn=nbocos,1,-1
      call popcontrol2b(branch)
      if (branch .lt. 2) then
        if (branch .ne. 0) then
          bcdatad(nn)%fv = 0.0_8
          bcdatad(nn)%fp = 0.0_8
          bcdatad(nn)%area = 0.0_8
        end if
      else if (branch .ne. 2) then
        call popreal8array(rev, size(rev, 1)*size(rev, 2)*size(rev, 3))
        call popreal8array(p, size(p, 1)*size(p, 2)*size(p, 3))
        call popreal8array(sfacei, size(sfacei, 1)*size(sfacei, 2)*size(&
&                    sfacei, 3))
        call popreal8array(sfacej, size(sfacej, 1)*size(sfacej, 2)*size(&
&                    sfacej, 3))
        call popreal8array(gamma, size(gamma, 1)*size(gamma, 2)*size(&
&                    gamma, 3))
        call popreal8array(sfacek, size(sfacek, 1)*size(sfacek, 2)*size(&
&                    sfacek, 3))
        call popreal8array(rlv, size(rlv, 1)*size(rlv, 2)*size(rlv, 3))
        call popreal8array(x, size(x, 1)*size(x, 2)*size(x, 3)*size(x, 4&
&                    ))
        call popreal8array(si, size(si, 1)*size(si, 2)*size(si, 3)*size(&
&                    si, 4))
        call popreal8array(sj, size(sj, 1)*size(sj, 2)*size(sj, 3)*size(&
&                    sj, 4))
        call popreal8array(sk, size(sk, 1)*size(sk, 2)*size(sk, 3)*size(&
&                    sk, 4))
        call resetbcpointers_b(nn, .true.)
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popinteger4(ad_to)
          do ii=ad_to,0,-1
            mxd = mvd(1)
            myd = mvd(2)
            mzd = mvd(3)
            j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&             jnbeg + 1
            fzd = fvd(3) - xc*myd + yc*mxd + bcdatad(nn)%fv(i, j, 3)
            bcdatad(nn)%fv(i, j, 3) = 0.0_8
            fyd = xc*mzd + fvd(2) - zc*mxd + bcdatad(nn)%fv(i, j, 2)
            bcdatad(nn)%fv(i, j, 2) = 0.0_8
            fxd = fvd(1) - yc*mzd + zc*myd + bcdatad(nn)%fv(i, j, 1)
            bcdatad(nn)%fv(i, j, 1) = 0.0_8
            xcd = fy*mzd - fz*myd
            ycd = fz*mxd - fx*mzd
            zcd = fx*myd - fy*mxd
            call popreal8(zc)
            tempd = fourth*zcd
            xxd(i, j, 3) = xxd(i, j, 3) + tempd
            xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd
            xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd
            xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd
            refpointd(3) = refpointd(3) - zcd
            call popreal8(yc)
            tempd0 = fourth*ycd
            xxd(i, j, 2) = xxd(i, j, 2) + tempd0
            xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd0
            xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd0
            xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd0
            refpointd(2) = refpointd(2) - ycd
            call popreal8(xc)
            tempd1 = fourth*xcd
            xxd(i, j, 1) = xxd(i, j, 1) + tempd1
            xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd1
            xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd1
            xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd1
            refpointd(1) = refpointd(1) - xcd
            fzd = blk*fzd
            fyd = blk*fyd
            fxd = blk*fxd
            tauzz = viscsubface(nn)%tau(i, j, 3)
            tauxz = viscsubface(nn)%tau(i, j, 5)
            tauyz = viscsubface(nn)%tau(i, j, 6)
            call popreal8(fz)
            tempd2 = -(fact*pref*fzd)
            ssid(i, j, 1) = ssid(i, j, 1) + tauxz*tempd2
            ssid(i, j, 2) = ssid(i, j, 2) + tauyz*tempd2
            tauzzd = ssi(i, j, 3)*tempd2
            ssid(i, j, 3) = ssid(i, j, 3) + tauzz*tempd2
            tauxy = viscsubface(nn)%tau(i, j, 4)
            tauyy = viscsubface(nn)%tau(i, j, 2)
            call popreal8(fy)
            tempd4 = -(fact*pref*fyd)
            tauyzd = ssi(i, j, 3)*tempd4 + ssi(i, j, 2)*tempd2
            ssid(i, j, 1) = ssid(i, j, 1) + tauxy*tempd4
            tauyyd = ssi(i, j, 2)*tempd4
            ssid(i, j, 2) = ssid(i, j, 2) + tauyy*tempd4
            ssid(i, j, 3) = ssid(i, j, 3) + tauyz*tempd4
            tauxx = viscsubface(nn)%tau(i, j, 1)
            prefd = prefd - fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+&
&             tauyz*ssi(i, j, 3))*fyd - fact*(tauxx*ssi(i, j, 1)+tauxy*&
&             ssi(i, j, 2)+tauxz*ssi(i, j, 3))*fxd - fact*(tauxz*ssi(i, &
&             j, 1)+tauyz*ssi(i, j, 2)+tauzz*ssi(i, j, 3))*fzd
            call popreal8(fx)
            tempd3 = -(fact*pref*fxd)
            tauxzd = ssi(i, j, 3)*tempd3 + ssi(i, j, 1)*tempd2
            tauxyd = ssi(i, j, 2)*tempd3 + ssi(i, j, 1)*tempd4
            tauxxd = ssi(i, j, 1)*tempd3
            ssid(i, j, 1) = ssid(i, j, 1) + tauxx*tempd3
            ssid(i, j, 2) = ssid(i, j, 2) + tauxy*tempd3
            ssid(i, j, 3) = ssid(i, j, 3) + tauxz*tempd3
            viscsubfaced(nn)%tau(i, j, 6) = viscsubfaced(nn)%tau(i, j, 6&
&             ) + tauyzd
            viscsubfaced(nn)%tau(i, j, 5) = viscsubfaced(nn)%tau(i, j, 5&
&             ) + tauxzd
            viscsubfaced(nn)%tau(i, j, 4) = viscsubfaced(nn)%tau(i, j, 4&
&             ) + tauxyd
            viscsubfaced(nn)%tau(i, j, 3) = viscsubfaced(nn)%tau(i, j, 3&
&             ) + tauzzd
            viscsubfaced(nn)%tau(i, j, 2) = viscsubfaced(nn)%tau(i, j, 2&
&             ) + tauyyd
            viscsubfaced(nn)%tau(i, j, 1) = viscsubfaced(nn)%tau(i, j, 1&
&             ) + tauxxd
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popinteger4(blk)
            else
              call popinteger4(blk)
            end if
            call popinteger4(j)
            call popinteger4(i)
          end do
        else
          bcdatad(nn)%fv = 0.0_8
        end if
        call popreal8array(ww2, size(ww2, 1)*size(ww2, 2)*size(ww2, 3))
        call popreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3))
        call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
        call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
        call popreal8array(xx, size(xx, 1)*size(xx, 2)*size(xx, 3))
        call lookreal8array(v, 3)
        do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
&           bcdata(nn)%inbeg)-1
          i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn)%&
&           inbeg + 1
          j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%jnbeg &
&           + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
          pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
          xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j&
&           +1, 1)) - refpoint(1)
          yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j&
&           +1, 2)) - refpoint(2)
          zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j&
&           +1, 3)) - refpoint(3)
          if (bcdata(nn)%iblank(i, j) .lt. 0) then
            blk = 0
          else
            blk = bcdata(nn)%iblank(i, j)
          end if
          fx = pm1*ssi(i, j, 1)
          fy = pm1*ssi(i, j, 2)
          fz = pm1*ssi(i, j, 3)
! iblank forces
          fx = fx*blk
          fy = fy*blk
          fz = fz*blk
! update the inviscid force and moment coefficients.
! save the face-based forces and area
          cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, &
&           3)**2)
! get normalized surface velocity:
          v(1) = ww2(i, j, ivx)
          v(2) = ww2(i, j, ivy)
          v(3) = ww2(i, j, ivz)
          tmp0 = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
          call pushreal8array(v, 3)
          v = tmp0
! dot product with free stream
          sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v&
&           (3)*veldirfreestream(3))
!now run through a smooth heaviside function:
          call pushreal8(sensor)
          sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&           sepsensoroffset))))
! and integrate over the area of this cell and save:
          call pushreal8(sensor)
          sensor = sensor*cellarea
! also accumulate into the sepsensoravg
          call pushreal8(xc)
          xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j&
&           +1, 1))
          call pushreal8(yc)
          yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j&
&           +1, 2))
          call pushreal8(zc)
          zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j&
&           +1, 3))
          plocal = pp2(i, j)
          tmp = two/(gammainf*machcoef*machcoef)
          cp = tmp*(plocal-pinf)
          sigma = 1.4
          sensor1 = -cp - sigma
          call pushreal8(sensor1)
          sensor1 = one/(one+exp(-(2*10*sensor1)))
          mxd = mpd(1)
          myd = mpd(2)
          mzd = mpd(3)
          sensor1d = cavitationd
          cellaread = sensor1*sensor1d
          sensor1d = cellarea*sensor1d
          call popreal8(sensor1)
          temp5 = -(10*2*sensor1)
          temp4 = one + exp(temp5)
          sensor1d = exp(temp5)*one*10*2*sensor1d/temp4**2
          cpd = -sensor1d
          tmpd = (plocal-pinf)*cpd
          plocald = tmp*cpd
          pinfd = pinfd - tmp*cpd
          temp3 = gammainf*machcoef**2
          tempd9 = -(two*tmpd/temp3**2)
          gammainfd = gammainfd + machcoef**2*tempd9
          machcoefd = machcoefd + gammainf*2*machcoef*tempd9
          pp2d(i, j) = pp2d(i, j) + plocald
          sensord = yc*sepsensoravgd(2) + sepsensord + xc*sepsensoravgd(&
&           1) + zc*sepsensoravgd(3)
          zcd = sensor*sepsensoravgd(3)
          ycd = sensor*sepsensoravgd(2)
          xcd = sensor*sepsensoravgd(1)
          call popreal8(zc)
          tempd10 = fourth*zcd
          xxd(i, j, 3) = xxd(i, j, 3) + tempd10
          xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd10
          xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd10
          xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd10
          call popreal8(yc)
          tempd11 = fourth*ycd
          xxd(i, j, 2) = xxd(i, j, 2) + tempd11
          xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd11
          xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd11
          xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd11
          call popreal8(xc)
          tempd12 = fourth*xcd
          xxd(i, j, 1) = xxd(i, j, 1) + tempd12
          xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd12
          xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd12
          xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd12
          call popreal8(sensor)
          cellaread = cellaread + sensor*sensord
          sensord = cellarea*sensord
          call popreal8(sensor)
          temp2 = -(2*sepsensorsharpness*(sensor-sepsensoroffset))
          temp1 = one + exp(temp2)
          sensord = exp(temp2)*one*sepsensorsharpness*2*sensord/temp1**2
          vd(1) = vd(1) - veldirfreestream(1)*sensord
          veldirfreestreamd(1) = veldirfreestreamd(1) - v(1)*sensord
          vd(2) = vd(2) - veldirfreestream(2)*sensord
          veldirfreestreamd(2) = veldirfreestreamd(2) - v(2)*sensord
          vd(3) = vd(3) - veldirfreestream(3)*sensord
          veldirfreestreamd(3) = veldirfreestreamd(3) - v(3)*sensord
          call popreal8array(v, 3)
          tmpd0 = vd
          temp = v(1)**2 + v(2)**2 + v(3)**2
          temp0 = sqrt(temp)
          tempd13 = tmpd0/(temp0+1e-16)
          vd = tempd13
          if (temp .eq. 0.0_8) then
            tempd14 = 0.0
          else
            tempd14 = sum(-(v*tempd13/(temp0+1e-16)))/(2.0*temp0)
          end if
          vd(1) = vd(1) + 2*v(1)*tempd14
          vd(2) = vd(2) + 2*v(2)*tempd14
          vd(3) = vd(3) + 2*v(3)*tempd14
          ww2d(i, j, ivz) = ww2d(i, j, ivz) + vd(3)
          vd(3) = 0.0_8
          ww2d(i, j, ivy) = ww2d(i, j, ivy) + vd(2)
          vd(2) = 0.0_8
          ww2d(i, j, ivx) = ww2d(i, j, ivx) + vd(1)
          vd(1) = 0.0_8
          cellaread = cellaread + bcdatad(nn)%area(i, j)
          bcdatad(nn)%area(i, j) = 0.0_8
          if (ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**2 .eq. &
&             0.0_8) then
            tempd15 = 0.0
          else
            tempd15 = cellaread/(2.0*sqrt(ssi(i, j, 1)**2+ssi(i, j, 2)**&
&             2+ssi(i, j, 3)**2))
          end if
          ssid(i, j, 1) = ssid(i, j, 1) + 2*ssi(i, j, 1)*tempd15
          ssid(i, j, 2) = ssid(i, j, 2) + 2*ssi(i, j, 2)*tempd15
          ssid(i, j, 3) = ssid(i, j, 3) + 2*ssi(i, j, 3)*tempd15
          fzd = fpd(3) - xc*myd + yc*mxd + bcdatad(nn)%fp(i, j, 3)
          bcdatad(nn)%fp(i, j, 3) = 0.0_8
          fyd = xc*mzd + fpd(2) - zc*mxd + bcdatad(nn)%fp(i, j, 2)
          bcdatad(nn)%fp(i, j, 2) = 0.0_8
          fxd = fpd(1) - yc*mzd + zc*myd + bcdatad(nn)%fp(i, j, 1)
          bcdatad(nn)%fp(i, j, 1) = 0.0_8
          xcd = fy*mzd - fz*myd
          ycd = fz*mxd - fx*mzd
          zcd = fx*myd - fy*mxd
          fzd = blk*fzd
          fyd = blk*fyd
          fxd = blk*fxd
          pm1d = ssi(i, j, 2)*fyd + ssi(i, j, 1)*fxd + ssi(i, j, 3)*fzd
          ssid(i, j, 3) = ssid(i, j, 3) + pm1*fzd
          ssid(i, j, 2) = ssid(i, j, 2) + pm1*fyd
          ssid(i, j, 1) = ssid(i, j, 1) + pm1*fxd
          tempd5 = fourth*zcd
          xxd(i, j, 3) = xxd(i, j, 3) + tempd5
          xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd5
          xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd5
          xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd5
          refpointd(3) = refpointd(3) - zcd
          tempd6 = fourth*ycd
          xxd(i, j, 2) = xxd(i, j, 2) + tempd6
          xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd6
          xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd6
          xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd6
          refpointd(2) = refpointd(2) - ycd
          tempd7 = fourth*xcd
          xxd(i, j, 1) = xxd(i, j, 1) + tempd7
          xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd7
          xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd7
          xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd7
          refpointd(1) = refpointd(1) - xcd
          tempd8 = fact*pref*pm1d
          pp2d(i, j) = pp2d(i, j) + half*tempd8
          pp1d(i, j) = pp1d(i, j) + half*tempd8
          pinfd = pinfd - tempd8
          prefd = prefd + fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pm1d
        end do
        call popreal8array(v, 3)
        call popreal8(sensor1)
        call popreal8(fz)
        call popreal8(fy)
        call popreal8(fx)
        call popreal8(zc)
        call popreal8(cellarea)
        call popreal8(sensor)
        call popreal8(tmp)
        call popreal8(yc)
        call popreal8(plocal)
        call popinteger4(blk)
        call popreal8(xc)
        call popinteger4(j)
        call popinteger4(i)
        call popcontrol3b(branch)
        if (branch .lt. 3) then
          if (branch .eq. 0) then
            call popreal8(fact)
          else if (branch .eq. 1) then
            call popreal8(fact)
          else
            call popreal8(fact)
          end if
        else if (branch .lt. 5) then
          if (branch .eq. 3) then
            call popreal8(fact)
          else
            call popreal8(fact)
          end if
        else if (branch .eq. 5) then
          call popreal8(fact)
        end if
        call popreal8array(pp1, size(pp1, 1)*size(pp1, 2))
        call popreal8array(pp2, size(pp2, 1)*size(pp2, 2))
        call popreal8array(ssi, size(ssi, 1)*size(ssi, 2)*size(ssi, 3))
        call setbcpointers_b(nn, .true.)
      end if
    end do
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine forcesandmoments_b
  subroutine forcesandmoments(localvalues)
!
!       forcesandmoments computes the contribution of the block
!       given by the pointers in blockpointers to the force and
!       moment of the geometry. a distinction is made
!       between the inviscid and viscous parts. in case the maximum
!       yplus value must be monitored (only possible for rans), this
!       value is also computed. the separation sensor and the cavita-
!       tion sensor is also computed
!       here.
!
    use constants
    use communication
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use bcroutines_b
    use costfunctions
    use surfacefamilies
    use sorting, only : bsearchintegers
    use utils_b, only : setbcpointers, resetbcpointers
    use bcpointers_b
    implicit none
!
!      subroutine arguments
!
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
!
!      local variables.
!
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype) :: yplusmax, sepsensor, sepsensoravg(3), &
&   cavitation
    integer(kind=inttype) :: nn, i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
    real(kind=realtype) :: xc, yc, zc, qf(3)
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: v(3), sensor, sensor1, cp, tmp, plocal
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype) :: mx, my, mz, cellarea
    logical :: viscoussubface
    intrinsic size
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
    fp = zero
    fv = zero
    mp = zero
    mv = zero
    yplusmax = zero
    sepsensor = zero
    cavitation = zero
    sepsensoravg = zero
! loop over the boundary subfaces of this block.
bocos:do nn=1,nbocos
!
!         integrate the inviscid contribution over the solid walls,
!         either inviscid or viscous. the integration is done with
!         cp. for closed contours this is equal to the integration
!         of p; for open contours this is not the case anymore.
!         question is whether a force for an open contour is
!         meaningful anyway.
!
      if (bsearchintegers(bcdata(nn)%famid, famgroups, size(famgroups)) &
&         .gt. 0) then
        if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&           nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! subface is a wall. check if it is a viscous wall.
          viscoussubface = .true.
          if (bctype(nn) .eq. eulerwall) viscoussubface = .false.
! set a bunch of pointers depending on the face id to make
! a generic treatment possible. the routine setbcpointers
! is not used, because quite a few other ones are needed.
          call setbcpointers(nn, .true.)
          select case  (bcfaceid(nn)) 
          case (imin) 
            fact = -one
          case (imax) 
            fact = one
          case (jmin) 
            fact = -one
          case (jmax) 
            fact = one
          case (kmin) 
            fact = -one
          case (kmax) 
            fact = one
          end select
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(nn)%jnbeg+1),bcdata(nn)%jnend
!    do i=(bcdata(nn)%inbeg+1),bcdata(nn)%inend
          do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
&             bcdata(nn)%inbeg)-1
            i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn&
&             )%inbeg + 1
            j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&             jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
            pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1)) - refpoint(1)
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2)) - refpoint(2)
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3)) - refpoint(3)
            if (bcdata(nn)%iblank(i, j) .lt. 0) then
              blk = 0
            else
              blk = bcdata(nn)%iblank(i, j)
            end if
            fx = pm1*ssi(i, j, 1)
            fy = pm1*ssi(i, j, 2)
            fz = pm1*ssi(i, j, 3)
! iblank forces
            fx = fx*blk
            fy = fy*blk
            fz = fz*blk
! update the inviscid force and moment coefficients.
            fp(1) = fp(1) + fx
            fp(2) = fp(2) + fy
            fp(3) = fp(3) + fz
            mx = yc*fz - zc*fy
            my = zc*fx - xc*fz
            mz = xc*fy - yc*fx
            mp(1) = mp(1) + mx
            mp(2) = mp(2) + my
            mp(3) = mp(3) + mz
! save the face-based forces and area
            bcdata(nn)%fp(i, j, 1) = fx
            bcdata(nn)%fp(i, j, 2) = fy
            bcdata(nn)%fp(i, j, 3) = fz
            cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j&
&             , 3)**2)
            bcdata(nn)%area(i, j) = cellarea
! get normalized surface velocity:
            v(1) = ww2(i, j, ivx)
            v(2) = ww2(i, j, ivy)
            v(3) = ww2(i, j, ivz)
            v = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
! dot product with free stream
            sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)&
&             +v(3)*veldirfreestream(3))
!now run through a smooth heaviside function:
            sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&             sepsensoroffset))))
! and integrate over the area of this cell and save:
            sensor = sensor*cellarea
            sepsensor = sepsensor + sensor
! also accumulate into the sepsensoravg
            xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
&             , j+1, 1))
            yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
&             , j+1, 2))
            zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
&             , j+1, 3))
            sepsensoravg(1) = sepsensoravg(1) + sensor*xc
            sepsensoravg(2) = sepsensoravg(2) + sensor*yc
            sepsensoravg(3) = sepsensoravg(3) + sensor*zc
            plocal = pp2(i, j)
            tmp = two/(gammainf*machcoef*machcoef)
            cp = tmp*(plocal-pinf)
            sigma = 1.4
            sensor1 = -cp - sigma
            sensor1 = one/(one+exp(-(2*10*sensor1)))
            sensor1 = sensor1*cellarea
            cavitation = cavitation + sensor1
          end do
!
!           integration of the viscous forces.
!           only for viscous boundaries.
!
          if (viscoussubface) then
! initialize dwall for the laminar case and set the pointer
! for the unit normals.
            dwall = zero
! replace norm with bcdata norm - peter lyu
!norm => bcdata(nn)%norm
! loop over the quadrilateral faces of the subface and
! compute the viscous contribution to the force and
! moment and update the maximum value of y+.
            do ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%&
&               inend-bcdata(nn)%inbeg)-1
              i = mod(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(&
&               nn)%inbeg + 1
              j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%&
&               jnbeg + 1
              if (bcdata(nn)%iblank(i, j) .lt. 0) then
                blk = 0
              else
                blk = bcdata(nn)%iblank(i, j)
              end if
              tauxx = viscsubface(nn)%tau(i, j, 1)
              tauyy = viscsubface(nn)%tau(i, j, 2)
              tauzz = viscsubface(nn)%tau(i, j, 3)
              tauxy = viscsubface(nn)%tau(i, j, 4)
              tauxz = viscsubface(nn)%tau(i, j, 5)
              tauyz = viscsubface(nn)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
              fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*&
&               ssi(i, j, 3))*pref)
              fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*&
&               ssi(i, j, 3))*pref)
              fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*&
&               ssi(i, j, 3))*pref)
! iblank forces after saving for zipper mesh
              tauxx = tauxx*blk
              tauyy = tauyy*blk
              tauzz = tauzz*blk
              tauxy = tauxy*blk
              tauxz = tauxz*blk
              tauyz = tauyz*blk
              fx = fx*blk
              fy = fy*blk
              fz = fz*blk
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
              xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+&
&               1, j+1, 1)) - refpoint(1)
              yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+&
&               1, j+1, 2)) - refpoint(2)
              zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+&
&               1, j+1, 3)) - refpoint(3)
! update the viscous force and moment coefficients.
              fv(1) = fv(1) + fx
              fv(2) = fv(2) + fy
              fv(3) = fv(3) + fz
              mx = yc*fz - zc*fy
              my = zc*fx - xc*fz
              mz = xc*fy - yc*fx
              mv(1) = mv(1) + mx
              mv(2) = mv(2) + my
              mv(3) = mv(3) + mz
! save the face based forces for the slice operations
              bcdata(nn)%fv(i, j, 1) = fx
              bcdata(nn)%fv(i, j, 2) = fy
              bcdata(nn)%fv(i, j, 3) = fz
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
              fx = tauxx*bcdata(nn)%norm(i, j, 1) + tauxy*bcdata(nn)%&
&               norm(i, j, 2) + tauxz*bcdata(nn)%norm(i, j, 3)
              fy = tauxy*bcdata(nn)%norm(i, j, 1) + tauyy*bcdata(nn)%&
&               norm(i, j, 2) + tauyz*bcdata(nn)%norm(i, j, 3)
              fz = tauxz*bcdata(nn)%norm(i, j, 1) + tauyz*bcdata(nn)%&
&               norm(i, j, 2) + tauzz*bcdata(nn)%norm(i, j, 3)
              fn = fx*bcdata(nn)%norm(i, j, 1) + fy*bcdata(nn)%norm(i, j&
&               , 2) + fz*bcdata(nn)%norm(i, j, 3)
              fx = fx - fn*bcdata(nn)%norm(i, j, 1)
              fy = fy - fn*bcdata(nn)%norm(i, j, 2)
              fz = fz - fn*bcdata(nn)%norm(i, j, 3)
            end do
          else
! compute the local value of y+. due to the usage
! of pointers there is on offset of -1 in dd2wall..
! if we had no viscous force, set the viscous component to zero
            bcdata(nn)%fv = zero
          end if
          call resetbcpointers(nn, .true.)
        end if
      else if ((bctype(nn) .eq. eulerwall .or. bctype(nn) .eq. &
&         nswalladiabatic) .or. bctype(nn) .eq. nswallisothermal) then
! if it wasn't included, but still a wall...zero
        bcdata(nn)%area = zero
        bcdata(nn)%fp = zero
        bcdata(nn)%fv = zero
      end if
    end do bocos
! increment the local values array with the values we computed here.
    localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
    localvalues(ifv:ifv+2) = localvalues(ifv:ifv+2) + fv
    localvalues(imp:imp+2) = localvalues(imp:imp+2) + mp
    localvalues(imv:imv+2) = localvalues(imv:imv+2) + mv
    localvalues(isepsensor) = localvalues(isepsensor) + sepsensor
    localvalues(icavitation) = localvalues(icavitation) + cavitation
    localvalues(isepavg:isepavg+2) = localvalues(isepavg:isepavg+2) + &
&     sepsensoravg
  end subroutine forcesandmoments
end module surfaceintegrations_b

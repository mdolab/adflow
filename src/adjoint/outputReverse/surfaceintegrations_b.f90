!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module surfaceintegrations_b
  use constants
  use communication, only : commtype, internalcommtype
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------
! data required on each proc:
! ndonor: the number of donor points the proc will provide
! frac (3, ndonor) : the uvw coordinates of the interpolation point
! donorinfo(4, ndonor) : donor information. 1 is the local block id and 2-4 is the 
!    starting i,j,k indices for the interpolation. 
! procsizes(0:nproc-1) : the number of donors on each proc
! procdisps(0:nproc) : cumulative form of procsizes
! inv(nconn) : array allocated only on root processor used to
! reorder the nodes or elements back to the original order. 
  type usersurfcommtype
      integer(kind=inttype) :: ndonor
      real(kind=realtype), dimension(:, :), allocatable :: frac
      integer(kind=inttype), dimension(:, :), allocatable :: donorinfo
      integer(kind=inttype), dimension(:), allocatable :: procsizes, &
&     procdisps
      integer(kind=inttype), dimension(:), allocatable :: inv
      logical, dimension(:), allocatable :: valid
  end type usersurfcommtype
! two separate commes: one for the nodes (based on the primal
! mesh) and one for the variables (based on the dual mesh)
  type userintsurf
      character(len=maxstringlen) :: famname
      integer(kind=inttype) :: famid
      real(kind=realtype), dimension(:, :), allocatable :: pts
      integer(kind=inttype), dimension(:, :), allocatable :: conn
      type(usersurfcommtype) :: nodecomm, facecomm
  end type userintsurf
  integer(kind=inttype), parameter :: nuserintsurfsmax=25
  type(userintsurf), dimension(nuserintsurfsmax), target :: userintsurfs
  integer(kind=inttype) :: nuserintsurfs=0

contains
  subroutine integratesurfaces(localvalues, famlist)
! this is a shell routine that calls the specific surface
! integration routines. currently we have have the forceandmoment
! routine as well as the flow properties routine. this routine
! takes care of setting pointers, while the actual computational
! routine just acts on a specific fast pointed to by pointers. 
    use constants
    use blockpointers, only : nbocos, bcdata, bctype, sk, sj, si, x, &
&   rlv, sfacei, sfacej, sfacek, gamma, rev, p, viscsubface
    use utils_b, only : setbcpointers, iswalltype
    use sorting, only : bsearchintegers
    use costfunctions, only : nlocalvalues
! tapenade needs to see these modules that the callees use.
    use bcpointers_b
    use flowvarrefstate
    use inputphysics
    implicit none
! input/output variables
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), dimension(:), intent(in) :: famlist
! working variables
    integer(kind=inttype) :: mm
! loop over all possible boundary conditions
bocos:do mm=1,nbocos
! determine if this boundary condition is to be incldued in the
! currently active group
      if (bsearchintegers(bcdata(mm)%famid, famlist) .gt. 0) then
! set a bunch of pointers depending on the face id to make
! a generic treatment possible. 
        call setbcpointers(mm, .true.)
        if (iswalltype(bctype(mm))) call wallintegrationface(localvalues&
&                                                      , mm)
        if (bctype(mm) .eq. subsonicinflow .or. bctype(mm) .eq. &
&           supersonicinflow) then
          call flowintegrationface(.true., localvalues, mm)
        else if (bctype(mm) .eq. subsonicoutflow .or. bctype(mm) .eq. &
&           supersonicoutflow) then
          call flowintegrationface(.false., localvalues, mm)
        end if
      end if
    end do bocos
  end subroutine integratesurfaces
  subroutine integratesurfaceswithgathered(globalcfvalues, localvalues, &
&   famlist)
! this is a shell routine that calls the specific surface
! integration routines, which need access to gethered values. this routine
! takes care of setting pointers, while the actual computational
! routine just acts on a specific fast pointed to by pointers. 
    use constants
    use costfunctions
    use blockpointers, only : nbocos, bcdata, bctype, sk, sj, si, x, &
&   rlv, sfacei, sfacej, sfacek, gamma, rev, p, viscsubface
    use utils_b, only : setbcpointers, iswalltype
    use sorting, only : bsearchintegers
    use costfunctions, only : nlocalvalues
! tapenade needs to see these modules that the callees use.
    use bcpointers_b
    use flowvarrefstate
    use inputphysics
    implicit none
! input/output variables
    real(kind=realtype), dimension(ncostfunction), intent(in) :: &
&   globalcfvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), dimension(:), intent(in) :: famlist
! working variables
    integer(kind=inttype) :: mm
! loop over all possible boundary conditions
bocos:do mm=1,nbocos
! determine if this boundary condition is to be incldued in the
! currently active group
      if (bsearchintegers(bcdata(mm)%famid, famlist) .gt. 0) then
! set a bunch of pointers depending on the face id to make
! a generic treatment possible. 
        call setbcpointers(mm, .true.)
! no wall functions yet
! iswall: if( iswalltype(bctype(mm))) then 
!    call wallintegrationface(localvalues, mm)
! end if iswall
        if (bctype(mm) .eq. subsonicinflow .or. bctype(mm) .eq. &
&           supersonicinflow) then
          call flowintegrationfacewithgathered(.true., globalcfvalues, &
&                                        localvalues, mm)
        else if (bctype(mm) .eq. subsonicoutflow .or. bctype(mm) .eq. &
&           supersonicoutflow) then
          call flowintegrationfacewithgathered(.false., globalcfvalues, &
&                                        localvalues, mm)
        end if
      end if
    end do bocos
  end subroutine integratesurfaceswithgathered
!  differentiation of wallintegrationface in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *(*viscsubface.tau) *(*bcdata.fv)
!                *(*bcdata.fp) *(*bcdata.area) veldirfreestream
!                machcoef pointref pinf pref *xx *pp1 *pp2 *ssi
!                *ww2 localvalues
!   with respect to varying inputs: *(*viscsubface.tau) *(*bcdata.fv)
!                *(*bcdata.fp) *(*bcdata.area) veldirfreestream
!                machcoef pointref pinf pref *xx *pp1 *pp2 *ssi
!                *ww2 localvalues
!   rw status of diff variables: *(*viscsubface.tau):incr *(*bcdata.fv):in-out
!                *(*bcdata.fp):in-out *(*bcdata.area):in-out veldirfreestream:incr
!                machcoef:incr pointref:incr pinf:incr pref:incr
!                *xx:incr *pp1:incr *pp2:incr *ssi:incr *ww2:incr
!                localvalues:in-out
!   plus diff mem management of: viscsubface:in *viscsubface.tau:in
!                bcdata:in *bcdata.fv:in *bcdata.fp:in *bcdata.area:in
!                xx:in pp1:in pp2:in ssi:in ww2:in
  subroutine wallintegrationface_b(localvalues, localvaluesd, mm)
!
!       wallintegrations computes the contribution of the block
!       given by the pointers in blockpointers to the force and
!       moment of the geometry. a distinction is made
!       between the inviscid and viscous parts. in case the maximum
!       yplus value must be monitored (only possible for rans), this
!       value is also computed. the separation sensor and the cavita-
!       tion sensor is also computed
!       here.
!
    use constants
    use costfunctions
    use communication
    use blockpointers
    use flowvarrefstate
    use inputphysics, only : machcoef, machcoefd, pointref, pointrefd,&
&   veldirfreestream, veldirfreestreamd, equations
    use costfunctions, only : nlocalvalues, ifp, ifv, imp, imv, &
&   isepsensor, isepavg, icavitation, sepsensorsharpness, &
&   sepsensoroffset, iyplus
    use sorting, only : bsearchintegers
    use bcpointers_b
    implicit none
! input/output variables
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvaluesd
    integer(kind=inttype) :: mm
! local variables.
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype), dimension(3) :: fpd, fvd, mpd, mvd
    real(kind=realtype) :: yplusmax, sepsensor, sepsensoravg(3), &
&   cavitation
    real(kind=realtype) :: sepsensord, sepsensoravgd(3), cavitationd
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
    real(kind=realtype) :: pm1d, fxd, fyd, fzd
    real(kind=realtype) :: xc, yc, zc, qf(3)
    real(kind=realtype) :: xcd, ycd, zcd
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: v(3), sensor, sensor1, cp, tmp, plocal
    real(kind=realtype) :: vd(3), sensord, sensor1d, cpd, tmpd, plocald
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxxd, tauyyd, tauzzd
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxyd, tauxzd, tauyzd
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype), dimension(3) :: refpointd
    real(kind=realtype) :: mx, my, mz, cellarea
    real(kind=realtype) :: mxd, myd, mzd, cellaread
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
    real(kind=realtype), dimension(3) :: tmp0
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6(3)
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd0(3)
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp4
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = -one
    case (imax, jmax, kmax) 
      fact = one
    end select
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
!
! integration of the viscous forces.
! only for viscous boundaries.
!
    if (bctype(mm) .eq. nswalladiabatic .or. bctype(mm) .eq. &
&       nswallisothermal) then
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(xc)
      call pushinteger4(blk)
      call pushreal8(yc)
      call pushreal8(zc)
      call pushreal8(fx)
      call pushreal8(fy)
      call pushreal8(fz)
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    sepsensoravgd = 0.0_8
    sepsensoravgd = localvaluesd(isepavg:isepavg+2)
    cavitationd = localvaluesd(icavitation)
    sepsensord = localvaluesd(isepsensor)
    mvd = 0.0_8
    mvd = localvaluesd(imv:imv+2)
    mpd = 0.0_8
    mpd = localvaluesd(imp:imp+2)
    fvd = 0.0_8
    fvd = localvaluesd(ifv:ifv+2)
    fpd = 0.0_8
    fpd = localvaluesd(ifp:ifp+2)
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      refpointd = 0.0_8
      do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-&
&         bcdata(mm)%inbeg)-1
        i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&         inbeg + 1
        j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + &
&         1
        if (bcdata(mm)%iblank(i, j) .lt. 0) then
          blk = 0
        else
          blk = bcdata(mm)%iblank(i, j)
        end if
        tauxx = viscsubface(mm)%tau(i, j, 1)
        tauyy = viscsubface(mm)%tau(i, j, 2)
        tauzz = viscsubface(mm)%tau(i, j, 3)
        tauxy = viscsubface(mm)%tau(i, j, 4)
        tauxz = viscsubface(mm)%tau(i, j, 5)
        tauyz = viscsubface(mm)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
        fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*ssi(i, &
&         j, 3))*pref)
        fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*ssi(i, &
&         j, 3))*pref)
        fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*ssi(i, &
&         j, 3))*pref)
! iblank forces after saving for zipper mesh
        fx = fx*blk
        fy = fy*blk
        fz = fz*blk
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
        xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&         , 1)) - refpoint(1)
        yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&         , 2)) - refpoint(2)
        zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&         , 3)) - refpoint(3)
! update the viscous force and moment coefficients.
! save the face based forces for the slice operations
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
        mxd = mvd(1)
        myd = mvd(2)
        mzd = mvd(3)
        fzd = fvd(3) - xc*myd + yc*mxd + bcdatad(mm)%fv(i, j, 3)
        bcdatad(mm)%fv(i, j, 3) = 0.0_8
        fyd = xc*mzd + fvd(2) - zc*mxd + bcdatad(mm)%fv(i, j, 2)
        bcdatad(mm)%fv(i, j, 2) = 0.0_8
        fxd = fvd(1) - yc*mzd + zc*myd + bcdatad(mm)%fv(i, j, 1)
        bcdatad(mm)%fv(i, j, 1) = 0.0_8
        xcd = fy*mzd - fz*myd
        ycd = fz*mxd - fx*mzd
        zcd = fx*myd - fy*mxd
        tempd9 = fourth*zcd
        xxd(i, j, 3) = xxd(i, j, 3) + tempd9
        xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd9
        xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd9
        xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd9
        refpointd(3) = refpointd(3) - zcd
        tempd10 = fourth*ycd
        xxd(i, j, 2) = xxd(i, j, 2) + tempd10
        xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd10
        xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd10
        xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd10
        refpointd(2) = refpointd(2) - ycd
        tempd11 = fourth*xcd
        xxd(i, j, 1) = xxd(i, j, 1) + tempd11
        xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd11
        xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd11
        xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd11
        refpointd(1) = refpointd(1) - xcd
        fzd = blk*fzd
        fyd = blk*fyd
        fxd = blk*fxd
        tempd12 = -(fact*pref*fzd)
        ssid(i, j, 1) = ssid(i, j, 1) + tauxz*tempd12
        ssid(i, j, 2) = ssid(i, j, 2) + tauyz*tempd12
        tauzzd = ssi(i, j, 3)*tempd12
        ssid(i, j, 3) = ssid(i, j, 3) + tauzz*tempd12
        prefd = prefd - fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+&
&         tauzz*ssi(i, j, 3))*fzd
        tempd14 = -(fact*pref*fyd)
        tauyzd = ssi(i, j, 3)*tempd14 + ssi(i, j, 2)*tempd12
        ssid(i, j, 1) = ssid(i, j, 1) + tauxy*tempd14
        tauyyd = ssi(i, j, 2)*tempd14
        ssid(i, j, 2) = ssid(i, j, 2) + tauyy*tempd14
        ssid(i, j, 3) = ssid(i, j, 3) + tauyz*tempd14
        prefd = prefd - fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+&
&         tauyz*ssi(i, j, 3))*fyd
        tempd13 = -(fact*pref*fxd)
        tauxzd = ssi(i, j, 3)*tempd13 + ssi(i, j, 1)*tempd12
        tauxyd = ssi(i, j, 2)*tempd13 + ssi(i, j, 1)*tempd14
        tauxxd = ssi(i, j, 1)*tempd13
        ssid(i, j, 1) = ssid(i, j, 1) + tauxx*tempd13
        ssid(i, j, 2) = ssid(i, j, 2) + tauxy*tempd13
        ssid(i, j, 3) = ssid(i, j, 3) + tauxz*tempd13
        prefd = prefd - fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+&
&         tauxz*ssi(i, j, 3))*fxd
        viscsubfaced(mm)%tau(i, j, 6) = viscsubfaced(mm)%tau(i, j, 6) + &
&         tauyzd
        viscsubfaced(mm)%tau(i, j, 5) = viscsubfaced(mm)%tau(i, j, 5) + &
&         tauxzd
        viscsubfaced(mm)%tau(i, j, 4) = viscsubfaced(mm)%tau(i, j, 4) + &
&         tauxyd
        viscsubfaced(mm)%tau(i, j, 3) = viscsubfaced(mm)%tau(i, j, 3) + &
&         tauzzd
        viscsubfaced(mm)%tau(i, j, 2) = viscsubfaced(mm)%tau(i, j, 2) + &
&         tauyyd
        viscsubfaced(mm)%tau(i, j, 1) = viscsubfaced(mm)%tau(i, j, 1) + &
&         tauxxd
      end do
      call popreal8(fz)
      call popreal8(fy)
      call popreal8(fx)
      call popreal8(zc)
      call popreal8(yc)
      call popinteger4(blk)
      call popreal8(xc)
      call popinteger4(j)
      call popinteger4(i)
    else
      bcdatad(mm)%fv = 0.0_8
      refpointd = 0.0_8
    end if
    vd = 0.0_8
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
      pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      fx = pm1*ssi(i, j, 1)
      fy = pm1*ssi(i, j, 2)
      fz = pm1*ssi(i, j, 3)
! iblank forces
      fx = fx*blk
      fy = fy*blk
      fz = fz*blk
! update the inviscid force and moment coefficients.
! save the face-based forces and area
      cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**&
&       2)
! get normalized surface velocity:
      v(1) = ww2(i, j, ivx)
      v(2) = ww2(i, j, ivy)
      v(3) = ww2(i, j, ivz)
      tmp0 = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
      call pushreal8array(v, 3)
      v = tmp0
! dot product with free stream
      sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v(3)*&
&       veldirfreestream(3))
!now run through a smooth heaviside function:
      call pushreal8(sensor)
      sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&       sepsensoroffset))))
! and integrate over the area of this cell and save:
      call pushreal8(sensor)
      sensor = sensor*cellarea
! also accumulate into the sepsensoravg
      call pushreal8(xc)
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1))
      call pushreal8(yc)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2))
      call pushreal8(zc)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3))
      plocal = pp2(i, j)
      tmp = two/(gammainf*machcoef*machcoef)
      cp = tmp*(plocal-pinf)
      sigma = 1.4
      sensor1 = -cp - sigma
      call pushreal8(sensor1)
      sensor1 = one/(one+exp(-(2*10*sensor1)))
      mxd = mpd(1)
      myd = mpd(2)
      mzd = mpd(3)
      sensor1d = cavitationd
      cellaread = sensor1*sensor1d
      sensor1d = cellarea*sensor1d
      call popreal8(sensor1)
      temp5 = -(10*2*sensor1)
      temp4 = one + exp(temp5)
      sensor1d = exp(temp5)*one*10*2*sensor1d/temp4**2
      cpd = -sensor1d
      tmpd = (plocal-pinf)*cpd
      plocald = tmp*cpd
      pinfd = pinfd - tmp*cpd
      temp3 = gammainf*machcoef**2
      machcoefd = machcoefd - gammainf*two*2*machcoef*tmpd/temp3**2
      pp2d(i, j) = pp2d(i, j) + plocald
      sensord = yc*sepsensoravgd(2) + sepsensord + xc*sepsensoravgd(1) +&
&       zc*sepsensoravgd(3)
      zcd = sensor*sepsensoravgd(3)
      ycd = sensor*sepsensoravgd(2)
      xcd = sensor*sepsensoravgd(1)
      call popreal8(zc)
      tempd3 = fourth*zcd
      xxd(i, j, 3) = xxd(i, j, 3) + tempd3
      xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd3
      xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd3
      xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd3
      call popreal8(yc)
      tempd4 = fourth*ycd
      xxd(i, j, 2) = xxd(i, j, 2) + tempd4
      xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd4
      xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd4
      xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd4
      call popreal8(xc)
      tempd5 = fourth*xcd
      xxd(i, j, 1) = xxd(i, j, 1) + tempd5
      xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd5
      xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd5
      xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd5
      call popreal8(sensor)
      cellaread = cellaread + sensor*sensord
      sensord = cellarea*sensord
      call popreal8(sensor)
      temp2 = -(2*sepsensorsharpness*(sensor-sepsensoroffset))
      temp1 = one + exp(temp2)
      sensord = exp(temp2)*one*sepsensorsharpness*2*sensord/temp1**2
      vd(1) = vd(1) - veldirfreestream(1)*sensord
      veldirfreestreamd(1) = veldirfreestreamd(1) - v(1)*sensord
      vd(2) = vd(2) - veldirfreestream(2)*sensord
      veldirfreestreamd(2) = veldirfreestreamd(2) - v(2)*sensord
      vd(3) = vd(3) - veldirfreestream(3)*sensord
      veldirfreestreamd(3) = veldirfreestreamd(3) - v(3)*sensord
      call popreal8array(v, 3)
      tmpd0 = vd
      temp = v(1)**2 + v(2)**2 + v(3)**2
      temp0 = sqrt(temp)
      tempd6 = tmpd0/(temp0+1e-16)
      vd = tempd6
      if (temp .eq. 0.0_8) then
        tempd7 = 0.0
      else
        tempd7 = sum(-(v*tempd6/(temp0+1e-16)))/(2.0*temp0)
      end if
      vd(1) = vd(1) + 2*v(1)*tempd7
      vd(2) = vd(2) + 2*v(2)*tempd7
      vd(3) = vd(3) + 2*v(3)*tempd7
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + vd(3)
      vd(3) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + vd(2)
      vd(2) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + vd(1)
      vd(1) = 0.0_8
      cellaread = cellaread + bcdatad(mm)%area(i, j)
      bcdatad(mm)%area(i, j) = 0.0_8
      if (ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**2 .eq. 0.0_8&
&     ) then
        tempd8 = 0.0
      else
        tempd8 = cellaread/(2.0*sqrt(ssi(i, j, 1)**2+ssi(i, j, 2)**2+ssi&
&         (i, j, 3)**2))
      end if
      ssid(i, j, 1) = ssid(i, j, 1) + 2*ssi(i, j, 1)*tempd8
      ssid(i, j, 2) = ssid(i, j, 2) + 2*ssi(i, j, 2)*tempd8
      ssid(i, j, 3) = ssid(i, j, 3) + 2*ssi(i, j, 3)*tempd8
      fzd = fpd(3) - xc*myd + yc*mxd + bcdatad(mm)%fp(i, j, 3)
      bcdatad(mm)%fp(i, j, 3) = 0.0_8
      fyd = xc*mzd + fpd(2) - zc*mxd + bcdatad(mm)%fp(i, j, 2)
      bcdatad(mm)%fp(i, j, 2) = 0.0_8
      fxd = fpd(1) - yc*mzd + zc*myd + bcdatad(mm)%fp(i, j, 1)
      bcdatad(mm)%fp(i, j, 1) = 0.0_8
      xcd = fy*mzd - fz*myd
      ycd = fz*mxd - fx*mzd
      zcd = fx*myd - fy*mxd
      fzd = blk*fzd
      fyd = blk*fyd
      fxd = blk*fxd
      pm1d = ssi(i, j, 2)*fyd + ssi(i, j, 1)*fxd + ssi(i, j, 3)*fzd
      ssid(i, j, 3) = ssid(i, j, 3) + pm1*fzd
      ssid(i, j, 2) = ssid(i, j, 2) + pm1*fyd
      ssid(i, j, 1) = ssid(i, j, 1) + pm1*fxd
      tempd = fourth*zcd
      xxd(i, j, 3) = xxd(i, j, 3) + tempd
      xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd
      xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd
      xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd
      refpointd(3) = refpointd(3) - zcd
      tempd0 = fourth*ycd
      xxd(i, j, 2) = xxd(i, j, 2) + tempd0
      xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd0
      xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd0
      xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd0
      refpointd(2) = refpointd(2) - ycd
      tempd1 = fourth*xcd
      xxd(i, j, 1) = xxd(i, j, 1) + tempd1
      xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd1
      xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd1
      xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd1
      refpointd(1) = refpointd(1) - xcd
      tempd2 = fact*pref*pm1d
      pp2d(i, j) = pp2d(i, j) + half*tempd2
      pp1d(i, j) = pp1d(i, j) + half*tempd2
      pinfd = pinfd - tempd2
      prefd = prefd + fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pm1d
    end do
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine wallintegrationface_b
  subroutine wallintegrationface(localvalues, mm)
!
!       wallintegrations computes the contribution of the block
!       given by the pointers in blockpointers to the force and
!       moment of the geometry. a distinction is made
!       between the inviscid and viscous parts. in case the maximum
!       yplus value must be monitored (only possible for rans), this
!       value is also computed. the separation sensor and the cavita-
!       tion sensor is also computed
!       here.
!
    use constants
    use costfunctions
    use communication
    use blockpointers
    use flowvarrefstate
    use inputphysics, only : machcoef, pointref, veldirfreestream, &
&   equations
    use costfunctions, only : nlocalvalues, ifp, ifv, imp, imv, &
&   isepsensor, isepavg, icavitation, sepsensorsharpness, &
&   sepsensoroffset, iyplus
    use sorting, only : bsearchintegers
    use bcpointers_b
    implicit none
! input/output variables
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype) :: mm
! local variables.
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype) :: yplusmax, sepsensor, sepsensoravg(3), &
&   cavitation
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
    real(kind=realtype) :: xc, yc, zc, qf(3)
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: v(3), sensor, sensor1, cp, tmp, plocal
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype) :: mx, my, mz, cellarea
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = -one
    case (imax, jmax, kmax) 
      fact = one
    end select
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
    fp = zero
    fv = zero
    mp = zero
    mv = zero
    yplusmax = zero
    sepsensor = zero
    cavitation = zero
    sepsensoravg = zero
!
!         integrate the inviscid contribution over the solid walls,
!         either inviscid or viscous. the integration is done with
!         cp. for closed contours this is equal to the integration
!         of p; for open contours this is not the case anymore.
!         question is whether a force for an open contour is
!         meaningful anyway.
!
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
      pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      fx = pm1*ssi(i, j, 1)
      fy = pm1*ssi(i, j, 2)
      fz = pm1*ssi(i, j, 3)
! iblank forces
      fx = fx*blk
      fy = fy*blk
      fz = fz*blk
! update the inviscid force and moment coefficients.
      fp(1) = fp(1) + fx
      fp(2) = fp(2) + fy
      fp(3) = fp(3) + fz
      mx = yc*fz - zc*fy
      my = zc*fx - xc*fz
      mz = xc*fy - yc*fx
      mp(1) = mp(1) + mx
      mp(2) = mp(2) + my
      mp(3) = mp(3) + mz
! save the face-based forces and area
      bcdata(mm)%fp(i, j, 1) = fx
      bcdata(mm)%fp(i, j, 2) = fy
      bcdata(mm)%fp(i, j, 3) = fz
      cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**&
&       2)
      bcdata(mm)%area(i, j) = cellarea
! get normalized surface velocity:
      v(1) = ww2(i, j, ivx)
      v(2) = ww2(i, j, ivy)
      v(3) = ww2(i, j, ivz)
      v = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
! dot product with free stream
      sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v(3)*&
&       veldirfreestream(3))
!now run through a smooth heaviside function:
      sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&       sepsensoroffset))))
! and integrate over the area of this cell and save:
      sensor = sensor*cellarea
      sepsensor = sepsensor + sensor
! also accumulate into the sepsensoravg
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1))
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2))
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3))
      sepsensoravg(1) = sepsensoravg(1) + sensor*xc
      sepsensoravg(2) = sepsensoravg(2) + sensor*yc
      sepsensoravg(3) = sepsensoravg(3) + sensor*zc
      plocal = pp2(i, j)
      tmp = two/(gammainf*machcoef*machcoef)
      cp = tmp*(plocal-pinf)
      sigma = 1.4
      sensor1 = -cp - sigma
      sensor1 = one/(one+exp(-(2*10*sensor1)))
      sensor1 = sensor1*cellarea
      cavitation = cavitation + sensor1
    end do
!
! integration of the viscous forces.
! only for viscous boundaries.
!
    if (bctype(mm) .eq. nswalladiabatic .or. bctype(mm) .eq. &
&       nswallisothermal) then
! initialize dwall for the laminar case and set the pointer
! for the unit normals.
      dwall = zero
! loop over the quadrilateral faces of the subface and
! compute the viscous contribution to the force and
! moment and update the maximum value of y+.
      do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-&
&         bcdata(mm)%inbeg)-1
        i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&         inbeg + 1
        j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + &
&         1
        if (bcdata(mm)%iblank(i, j) .lt. 0) then
          blk = 0
        else
          blk = bcdata(mm)%iblank(i, j)
        end if
        tauxx = viscsubface(mm)%tau(i, j, 1)
        tauyy = viscsubface(mm)%tau(i, j, 2)
        tauzz = viscsubface(mm)%tau(i, j, 3)
        tauxy = viscsubface(mm)%tau(i, j, 4)
        tauxz = viscsubface(mm)%tau(i, j, 5)
        tauyz = viscsubface(mm)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
        fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*ssi(i, &
&         j, 3))*pref)
        fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*ssi(i, &
&         j, 3))*pref)
        fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*ssi(i, &
&         j, 3))*pref)
! iblank forces after saving for zipper mesh
        tauxx = tauxx*blk
        tauyy = tauyy*blk
        tauzz = tauzz*blk
        tauxy = tauxy*blk
        tauxz = tauxz*blk
        tauyz = tauyz*blk
        fx = fx*blk
        fy = fy*blk
        fz = fz*blk
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
        xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&         , 1)) - refpoint(1)
        yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&         , 2)) - refpoint(2)
        zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&         , 3)) - refpoint(3)
! update the viscous force and moment coefficients.
        fv(1) = fv(1) + fx
        fv(2) = fv(2) + fy
        fv(3) = fv(3) + fz
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mv(1) = mv(1) + mx
        mv(2) = mv(2) + my
        mv(3) = mv(3) + mz
! save the face based forces for the slice operations
        bcdata(mm)%fv(i, j, 1) = fx
        bcdata(mm)%fv(i, j, 2) = fy
        bcdata(mm)%fv(i, j, 3) = fz
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
        fx = tauxx*bcdata(mm)%norm(i, j, 1) + tauxy*bcdata(mm)%norm(i, j&
&         , 2) + tauxz*bcdata(mm)%norm(i, j, 3)
        fy = tauxy*bcdata(mm)%norm(i, j, 1) + tauyy*bcdata(mm)%norm(i, j&
&         , 2) + tauyz*bcdata(mm)%norm(i, j, 3)
        fz = tauxz*bcdata(mm)%norm(i, j, 1) + tauyz*bcdata(mm)%norm(i, j&
&         , 2) + tauzz*bcdata(mm)%norm(i, j, 3)
        fn = fx*bcdata(mm)%norm(i, j, 1) + fy*bcdata(mm)%norm(i, j, 2) +&
&         fz*bcdata(mm)%norm(i, j, 3)
        fx = fx - fn*bcdata(mm)%norm(i, j, 1)
        fy = fy - fn*bcdata(mm)%norm(i, j, 2)
        fz = fz - fn*bcdata(mm)%norm(i, j, 3)
      end do
    else
! compute the local value of y+. due to the usage
! of pointers there is on offset of -1 in dd2wall..
! if we had no viscous force, set the viscous component to zero
      bcdata(mm)%fv = zero
    end if
! increment the local values array with the values we computed here.
    localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
    localvalues(ifv:ifv+2) = localvalues(ifv:ifv+2) + fv
    localvalues(imp:imp+2) = localvalues(imp:imp+2) + mp
    localvalues(imv:imv+2) = localvalues(imv:imv+2) + mv
    localvalues(isepsensor) = localvalues(isepsensor) + sepsensor
    localvalues(icavitation) = localvalues(icavitation) + cavitation
    localvalues(isepavg:isepavg+2) = localvalues(isepavg:isepavg+2) + &
&     sepsensoravg
  end subroutine wallintegrationface
!  differentiation of flowintegrationface in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: pointref timeref tref rgas
!                pref rhoref *xx *pp1 *pp2 *ssi *ww1 *ww2 localvalues
!   with respect to varying inputs: pointref timeref tref rgas
!                pref rhoref *xx *pp1 *pp2 *ssi *ww1 *ww2 localvalues
!   rw status of diff variables: pointref:incr timeref:incr tref:incr
!                rgas:incr pref:incr rhoref:incr *xx:incr *pp1:incr
!                *pp2:incr *ssi:incr *ww1:incr *ww2:incr localvalues:in-out
!   plus diff mem management of: xx:in pp1:in pp2:in ssi:in ww1:in
!                ww2:in
  subroutine flowintegrationface_b(isinflow, localvalues, localvaluesd, &
&   mm)
    use constants
    use costfunctions
    use blockpointers, only : bctype, bcfaceid, bcdata, bcdatad, &
&   addgridvelocities
    use costfunctions, only : nlocalvalues, imassflow, imassptot, &
&   imassttot, imassps, imassmn
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : pref, prefd, pinf, pinfd, rhoref, &
&   rhorefd, timeref, timerefd, lref, tref, trefd, rgas, rgasd, uref, &
&   uinf, uinfd
    use inputphysics, only : pointref, pointrefd, flowtype, &
&   veldirfreestream, veldirfreestreamd, alpha, alphad, beta, betad, &
&   liftindex
    use flowutils_b, only : computeptot, computeptot_b, computettot, &
&   computettot_b, getdirvector, getdirvector_b
    use bcpointers_b, only : ssi, ssid, sface, ww1, ww1d, ww2, ww2d, pp1&
&   , pp1d, pp2, pp2d, xx, xxd, gamma1, gamma2
    use utils_b, only : mynorm2, mynorm2_b
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvaluesd
    integer(kind=inttype), intent(in) :: mm
! local variables
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn, mredim, pk
    real(kind=realtype) :: massflowrated, mass_ptotd, mass_ttotd, &
&   mass_psd, mass_mnd, mredimd, pkd
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: internalflowfact, inflowfact, fact, xc, yc, &
&   zc, cellarea, mx, my, mz
    real(kind=realtype) :: xcd, ycd, zcd, cellaread, mxd, myd, mzd
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, fx, fy, fz, u, &
&   v, w
    real(kind=realtype) :: vmagd, vnmd, vxmd, vymd, vzmd, fxd, fyd, fzd&
&   , wd
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, a2, mnm, &
&   massflowratelocal
    real(kind=realtype) :: pmd, ptotd, ttotd, rhomd, mnmd, &
&   massflowratelocald
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   vcoordref, vfreestreamref, sfacefreestreamref
    real(kind=realtype), dimension(3) :: fpd, mpd, fmomd, mmomd, &
&   refpointd
    intrinsic sqrt
    intrinsic mod
    intrinsic max
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! note that these are *opposite* of force integrations. the reason
! is that we want positive mass flow into the domain and negative
! mass flow out of the domain. since the low faces have ssi
! vectors pointining into the domain, this is correct. the high
! end faces need to flip this. 
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = one
    case (imax, jmax, kmax) 
      fact = -one
    end select
! the sign of momentum forces are flipped for internal flows
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    mredim = sqrt(pref*rhoref)
    mmomd = 0.0_8
    mmomd = localvaluesd(iflowmm:iflowmm+2)
    mpd = 0.0_8
    mpd = localvaluesd(iflowmp:iflowmp+2)
    fmomd = 0.0_8
    fmomd = localvaluesd(iflowfm:iflowfm+2)
    fpd = 0.0_8
    fpd = localvaluesd(iflowfp:iflowfp+2)
    pkd = localvaluesd(ipk)
    mass_mnd = localvaluesd(imassmn)
    mass_psd = localvaluesd(imassps)
    mass_ttotd = localvaluesd(imassttot)
    mass_ptotd = localvaluesd(imassptot)
    massflowrated = localvaluesd(imassflow)
    mredimd = 0.0_8
    ptotd = 0.0_8
    refpointd = 0.0_8
    ttotd = 0.0_8
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
      if (addgridvelocities) then
        sf = sface(i, j)
      else
        sf = zero
      end if
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      vxm = half*(ww1(i, j, ivx)+ww2(i, j, ivx))
      vym = half*(ww1(i, j, ivy)+ww2(i, j, ivy))
      vzm = half*(ww1(i, j, ivz)+ww2(i, j, ivz))
      rhom = half*(ww1(i, j, irho)+ww2(i, j, irho))
      pm = half*(pp1(i, j)+pp2(i, j))
      gammam = half*(gamma1(i, j)+gamma2(i, j))
      vnm = vxm*ssi(i, j, 1) + vym*ssi(i, j, 2) + vzm*ssi(i, j, 3) - sf
      vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
! a = sqrt(gamma*p/rho); sqrt(v**2/a**2)
      mnm = vmag/sqrt(gammam*pm/rhom)
      call computeptot(rhom, vxm, vym, vzm, pm, ptot)
      call computettot(rhom, vxm, vym, vzm, pm, ttot)
      massflowratelocal = rhom*vnm*blk*fact*mredim
! re-dimentionalize quantities
      call pushreal8(pm)
      pm = pm*pref
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
! pressure forces. note that these need a *negative* and to subtract 
! the reference pressure sign to be consistent with the force 
! computation on the walls. 
      call pushreal8(pm)
      pm = -((pm-pinf*pref)*fact*blk)
! update the pressure force and moment coefficients.
! momentum forces are a little tricky.  we negate because 
! have to re-apply fact to massflowratelocal to undoo it, because 
! we need the signed behavior of ssi to get the momentum forces correct. 
! also, the sign is flipped between inflow and outflow types 
      cellarea = mynorm2(ssi(i, j, :))
      call pushreal8(massflowratelocal)
      massflowratelocal = massflowratelocal*fact/timeref*blk/cellarea*&
&       internalflowfact*inflowfact
      fx = massflowratelocal*ssi(i, j, 1)*vxm
      fy = massflowratelocal*ssi(i, j, 2)*vym
      fz = massflowratelocal*ssi(i, j, 3)*vzm
      mzd = mmomd(3)
      myd = mmomd(2)
      mxd = mmomd(1)
      xcd = fy*mzd - fz*myd
      fyd = fmomd(2) - zc*mxd + xc*mzd
      ycd = fz*mxd - fx*mzd
      fxd = zc*myd + fmomd(1) - yc*mzd
      zcd = fx*myd - fy*mxd
      fzd = yc*mxd + fmomd(3) - xc*myd
      tempd0 = ssi(i, j, 3)*fzd
      ssid(i, j, 3) = ssid(i, j, 3) + massflowratelocal*vzm*fzd
      vzmd = massflowratelocal*tempd0
      tempd1 = ssi(i, j, 2)*fyd
      ssid(i, j, 2) = ssid(i, j, 2) + massflowratelocal*vym*fyd
      vymd = massflowratelocal*tempd1
      tempd2 = ssi(i, j, 1)*fxd
      massflowratelocald = vym*tempd1 + vxm*tempd2 + vzm*tempd0
      ssid(i, j, 1) = ssid(i, j, 1) + massflowratelocal*vxm*fxd
      vxmd = massflowratelocal*tempd2
      call popreal8(massflowratelocal)
      tempd3 = fact*blk*internalflowfact*inflowfact*massflowratelocald/(&
&       timeref*cellarea)
      tempd4 = -(massflowratelocal*tempd3/(timeref*cellarea))
      timerefd = timerefd + cellarea*tempd4
      cellaread = timeref*tempd4
      call mynorm2_b(ssi(i, j, :), ssid(i, j, :), cellaread)
      mzd = mpd(3)
      myd = mpd(2)
      mxd = mpd(1)
      fx = pm*ssi(i, j, 1)
      fy = pm*ssi(i, j, 2)
      fyd = fpd(2) - zc*mxd + xc*mzd
      fxd = zc*myd + fpd(1) - yc*mzd
      fz = pm*ssi(i, j, 3)
      xcd = xcd + fy*mzd - fz*myd
      ycd = ycd + fz*mxd - fx*mzd
      zcd = zcd + fx*myd - fy*mxd
      fzd = yc*mxd + fpd(3) - xc*myd
      pmd = ssi(i, j, 2)*fyd + ssi(i, j, 1)*fxd + ssi(i, j, 3)*fzd
      ssid(i, j, 3) = ssid(i, j, 3) + pm*fzd
      ssid(i, j, 2) = ssid(i, j, 2) + pm*fyd
      ssid(i, j, 1) = ssid(i, j, 1) + pm*fxd
      call popreal8(pm)
      massflowratelocald = mnm*mass_mnd + tref*ttot*mass_ttotd + &
&       massflowrated + pref*ptot*mass_ptotd + pm*mass_psd + tempd3
      tempd5 = -(fact*blk*pmd)
      prefd = prefd - pinf*tempd5
      pmd = massflowratelocal*mass_psd + tempd5
      tempd6 = fourth*zcd
      xxd(i, j, 3) = xxd(i, j, 3) + tempd6
      xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd6
      xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd6
      xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd6
      refpointd(3) = refpointd(3) - zcd
      tempd7 = fourth*ycd
      xxd(i, j, 2) = xxd(i, j, 2) + tempd7
      xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd7
      xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd7
      xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd7
      refpointd(2) = refpointd(2) - ycd
      tempd8 = fourth*xcd
      xxd(i, j, 1) = xxd(i, j, 1) + tempd8
      xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd8
      xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd8
      xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd8
      refpointd(1) = refpointd(1) - xcd
      mnmd = massflowratelocal*mass_mnd
      ttotd = ttotd + tref*massflowratelocal*mass_ttotd
      trefd = trefd + ttot*massflowratelocal*mass_ttotd
      ptotd = ptotd + pref*massflowratelocal*mass_ptotd
      call popreal8(pm)
      temp1 = vmag**2 - uinf**2
      tempd11 = uref*fact*pkd
      tempd10 = vnm*pref*tempd11
      tempd9 = (pm-pinf+half*(rhom*temp1))*tempd11
      prefd = prefd + pm*pmd + vnm*tempd9 + ptot*massflowratelocal*&
&       mass_ptotd
      pmd = tempd10 + pref*pmd
      tempd12 = blk*fact*massflowratelocald
      rhomd = mredim*vnm*tempd12 + half*temp1*tempd10
      vnmd = mredim*rhom*tempd12 + pref*tempd9
      mredimd = mredimd + rhom*vnm*tempd12
      call computettot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, vzmd, &
&                  pm, pmd, ttot, ttotd)
      call computeptot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, vzmd, &
&                  pm, pmd, ptot, ptotd)
      temp = pm/rhom
      temp0 = sqrt(gammam*temp)
      vmagd = mnmd/temp0 + rhom*half*2*vmag*tempd10
      if (gammam*temp .eq. 0.0_8) then
        tempd13 = 0.0
      else
        tempd13 = -(gammam*vmag*mnmd/(2.0*temp0**3*rhom))
      end if
      pmd = pmd + tempd13
      rhomd = rhomd - temp*tempd13
      if (vxm**2 + vym**2 + vzm**2 .eq. 0.0_8) then
        tempd14 = 0.0
      else
        tempd14 = vmagd/(2.0*sqrt(vxm**2+vym**2+vzm**2))
      end if
      vxmd = vxmd + ssi(i, j, 1)*vnmd + 2*vxm*tempd14
      vymd = vymd + ssi(i, j, 2)*vnmd + 2*vym*tempd14
      vzmd = vzmd + ssi(i, j, 3)*vnmd + 2*vzm*tempd14
      ssid(i, j, 1) = ssid(i, j, 1) + vxm*vnmd
      ssid(i, j, 2) = ssid(i, j, 2) + vym*vnmd
      ssid(i, j, 3) = ssid(i, j, 3) + vzm*vnmd
      pp1d(i, j) = pp1d(i, j) + half*pmd
      pp2d(i, j) = pp2d(i, j) + half*pmd
      ww1d(i, j, irho) = ww1d(i, j, irho) + half*rhomd
      ww2d(i, j, irho) = ww2d(i, j, irho) + half*rhomd
      ww1d(i, j, ivz) = ww1d(i, j, ivz) + half*vzmd
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + half*vzmd
      ww1d(i, j, ivy) = ww1d(i, j, ivy) + half*vymd
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + half*vymd
      ww1d(i, j, ivx) = ww1d(i, j, ivx) + half*vxmd
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + half*vxmd
    end do
    if (pref*rhoref .eq. 0.0_8) then
      tempd = 0.0
    else
      tempd = mredimd/(2.0*sqrt(pref*rhoref))
    end if
    prefd = prefd + rhoref*tempd
    rhorefd = rhorefd + pref*tempd
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine flowintegrationface_b
  subroutine flowintegrationface(isinflow, localvalues, mm)
    use constants
    use costfunctions
    use blockpointers, only : bctype, bcfaceid, bcdata, &
&   addgridvelocities
    use costfunctions, only : nlocalvalues, imassflow, imassptot, &
&   imassttot, imassps, imassmn
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : pref, pinf, rhoref, timeref, lref, &
&   tref, rgas, uref, uinf
    use inputphysics, only : pointref, flowtype, veldirfreestream, &
&   alpha, beta, liftindex
    use flowutils_b, only : computeptot, computettot, getdirvector
    use bcpointers_b, only : ssi, sface, ww1, ww2, pp1, pp2, xx, gamma1,&
&   gamma2
    use utils_b, only : mynorm2
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), intent(in) :: mm
! local variables
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn, mredim, pk
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: internalflowfact, inflowfact, fact, xc, yc, &
&   zc, cellarea, mx, my, mz
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, fx, fy, fz, u, &
&   v, w
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, a2, mnm, &
&   massflowratelocal
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   vcoordref, vfreestreamref, sfacefreestreamref
    intrinsic sqrt
    intrinsic mod
    intrinsic max
    massflowrate = zero
    mass_ptot = zero
    mass_ttot = zero
    mass_ps = zero
    mass_mn = zero
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! note that these are *opposite* of force integrations. the reason
! is that we want positive mass flow into the domain and negative
! mass flow out of the domain. since the low faces have ssi
! vectors pointining into the domain, this is correct. the high
! end faces need to flip this. 
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = one
    case (imax, jmax, kmax) 
      fact = -one
    end select
! the sign of momentum forces are flipped for internal flows
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    fp = zero
    mp = zero
    fmom = zero
    mmom = zero
    pk = zero
    mredim = sqrt(pref*rhoref)
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
      if (addgridvelocities) then
        sf = sface(i, j)
      else
        sf = zero
      end if
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      vxm = half*(ww1(i, j, ivx)+ww2(i, j, ivx))
      vym = half*(ww1(i, j, ivy)+ww2(i, j, ivy))
      vzm = half*(ww1(i, j, ivz)+ww2(i, j, ivz))
      rhom = half*(ww1(i, j, irho)+ww2(i, j, irho))
      pm = half*(pp1(i, j)+pp2(i, j))
      gammam = half*(gamma1(i, j)+gamma2(i, j))
      vnm = vxm*ssi(i, j, 1) + vym*ssi(i, j, 2) + vzm*ssi(i, j, 3) - sf
      vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
! a = sqrt(gamma*p/rho); sqrt(v**2/a**2)
      mnm = vmag/sqrt(gammam*pm/rhom)
      call computeptot(rhom, vxm, vym, vzm, pm, ptot)
      call computettot(rhom, vxm, vym, vzm, pm, ttot)
      massflowratelocal = rhom*vnm*blk*fact*mredim
      massflowrate = massflowrate + massflowratelocal
      pk = pk + (pm-pinf+half*rhom*(vmag**2-uinf**2))*vnm*pref*uref*fact
! re-dimentionalize quantities
      pm = pm*pref
      mass_ptot = mass_ptot + ptot*massflowratelocal*pref
      mass_ttot = mass_ttot + ttot*massflowratelocal*tref
      mass_ps = mass_ps + pm*massflowratelocal
      mass_mn = mass_mn + mnm*massflowratelocal
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
! pressure forces. note that these need a *negative* and to subtract 
! the reference pressure sign to be consistent with the force 
! computation on the walls. 
      pm = -((pm-pinf*pref)*fact*blk)
      fx = pm*ssi(i, j, 1)
      fy = pm*ssi(i, j, 2)
      fz = pm*ssi(i, j, 3)
! update the pressure force and moment coefficients.
      fp(1) = fp(1) + fx
      fp(2) = fp(2) + fy
      fp(3) = fp(3) + fz
      mx = yc*fz - zc*fy
      my = zc*fx - xc*fz
      mz = xc*fy - yc*fx
      mp(1) = mp(1) + mx
      mp(2) = mp(2) + my
      mp(3) = mp(3) + mz
! momentum forces are a little tricky.  we negate because 
! have to re-apply fact to massflowratelocal to undoo it, because 
! we need the signed behavior of ssi to get the momentum forces correct. 
! also, the sign is flipped between inflow and outflow types 
      cellarea = mynorm2(ssi(i, j, :))
      massflowratelocal = massflowratelocal*fact/timeref*blk/cellarea*&
&       internalflowfact*inflowfact
      fx = massflowratelocal*ssi(i, j, 1)*vxm
      fy = massflowratelocal*ssi(i, j, 2)*vym
      fz = massflowratelocal*ssi(i, j, 3)*vzm
      fmom(1) = fmom(1) + fx
      fmom(2) = fmom(2) + fy
      fmom(3) = fmom(3) + fz
      mx = yc*fz - zc*fy
      my = zc*fx - xc*fz
      mz = xc*fy - yc*fx
      mmom(1) = mmom(1) + mx
      mmom(2) = mmom(2) + my
      mmom(3) = mmom(3) + mz
    end do
! ! computes the normalized vector maped into the freestream direction, so we multiply by the magnitude after
! vcoordref(1) = vxm
! vcoordref(2) = vym
! vcoordref(3) = vzm
! call getdirvector(vcoordref, -alpha, -beta, vfreestreamref, liftindex)
! vfreestreamref = vfreestreamref * vmag
! !project the face normal into the freestream velocity and scale by the face
! call getdirvector(ssi(i,j,:), -alpha, -beta, sfacefreestreamref, liftindex)
! sfacefreestreamref = sfacefreestreamref * sf
! ! compute the pertubations of the flow from the free-stream velocity
! u = vfreestreamref(1) - sfacefreestreamref(1) - uinf
! v = vfreestreamref(2) - sfacefreestreamref(2)
! w = vfreestreamref(3) - sfacefreestreamref(3)
! !edota = edota + half*(rhom)
! increment the local values array with what we computed here
    localvalues(imassflow) = localvalues(imassflow) + massflowrate
    localvalues(imassptot) = localvalues(imassptot) + mass_ptot
    localvalues(imassttot) = localvalues(imassttot) + mass_ttot
    localvalues(imassps) = localvalues(imassps) + mass_ps
    localvalues(imassmn) = localvalues(imassmn) + mass_mn
    localvalues(ipk) = localvalues(ipk) + pk
    localvalues(iflowfp:iflowfp+2) = localvalues(iflowfp:iflowfp+2) + fp
    localvalues(iflowfm:iflowfm+2) = localvalues(iflowfm:iflowfm+2) + &
&     fmom
    localvalues(iflowmp:iflowmp+2) = localvalues(iflowmp:iflowmp+2) + mp
    localvalues(iflowmm:iflowmm+2) = localvalues(iflowmm:iflowmm+2) + &
&     mmom
  end subroutine flowintegrationface
  subroutine flowintegrationfacewithgathered(isinflow, globalcfvals, &
&   localvalues, mm)
    use constants
    use costfunctions
    use blockpointers, only : bctype, bcfaceid, bcdata, &
&   addgridvelocities
    use costfunctions, only : nlocalvalues, imassflow, imassptot, &
&   imassttot, imassps, imassmn
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : pref, pinf, rhoref, timeref, lref, &
&   tref, rgas
    use inputphysics, only : pointref, flowtype
    use flowutils_b, only : computeptot
    use bcpointers_b, only : ssi, sface, ww1, ww2, pp1, pp2, xx, gamma1,&
&   gamma2
    use utils_b, only : mynorm2
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    real(kind=realtype), dimension(ncostfunction), intent(in) :: &
&   globalcfvals
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), intent(in) :: mm
! local variables
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: internalflowfact, fact, xc, yc, zc, cellarea&
&   , mx, my, mz
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, mredim
    real(kind=realtype) :: pm, ptot, rhom, gammam, massavgptot
    real(kind=realtype) :: mnm, massflowratelocal, massavgmn
    intrinsic sqrt
    intrinsic mod
    intrinsic max
! note that these are *opposite* of force integrations. the reason
! is that we want positive mass flow into the domain and negative
! mass flow out of the domain. since the low faces have ssi
! vectors pointining into the domain, this is correct. the high
! end faces need to flip this. 
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = one
    case (imax, jmax, kmax) 
      fact = -one
    end select
! the sign of momentum forces are flipped for internal flows
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    mredim = sqrt(pref*rhoref)
    massavgmn = globalcfvals(costfuncmavgmn)
    massavgptot = globalcfvals(costfuncmavgptot)
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
      if (addgridvelocities) then
        sf = sface(i, j)
      else
        sf = zero
      end if
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      vxm = half*(ww1(i, j, ivx)+ww2(i, j, ivx))
      vym = half*(ww1(i, j, ivy)+ww2(i, j, ivy))
      vzm = half*(ww1(i, j, ivz)+ww2(i, j, ivz))
      rhom = half*(ww1(i, j, irho)+ww2(i, j, irho))
      pm = half*(pp1(i, j)+pp2(i, j))
      gammam = half*(gamma1(i, j)+gamma2(i, j))
      call computeptot(rhom, vxm, vym, vzm, pm, ptot)
      ptot = ptot*pref
      vnm = vxm*ssi(i, j, 1) + vym*ssi(i, j, 2) + vzm*ssi(i, j, 3) - sf
      vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
! a = sqrt(gamma*p/rho); sqrt(v**2/a**2)
      mnm = vmag/sqrt(gammam*pm/rhom)
      massflowratelocal = rhom*vnm*mredim*blk*fact
      localvalues(isigmamn) = localvalues(isigmamn) + massflowratelocal*&
&       (mnm-massavgmn)**2
      localvalues(isigmaptot) = localvalues(isigmaptot) + &
&       massflowratelocal*(ptot-massavgptot)**2
    end do
  end subroutine flowintegrationfacewithgathered
!  differentiation of flowintegrationzipper in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: pointref timeref tref rgas
!                pref rhoref vars localvalues
!   with respect to varying inputs: pointref timeref tref rgas
!                pref rhoref vars localvalues
!   rw status of diff variables: pointref:incr timeref:incr tref:incr
!                rgas:incr pref:incr rhoref:incr vars:incr localvalues:in-out
  subroutine flowintegrationzipper_b(isinflow, zipper, vars, varsd, &
&   localvalues, localvaluesd, famlist, sps)
! integrate over the trianges for the inflow/outflow conditions. 
    use constants
    use costfunctions, only : nlocalvalues, imassflow, imassptot, &
&   imassttot, imassps, iflowmm, iflowmp, iflowfm, iflowfp, imassmn, ipk
    use blockpointers, only : bctype
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : pref, prefd, pinf, pinfd, rhoref, &
&   rhorefd, pref, prefd, timeref, timerefd, lref, tref, trefd, rgas, &
&   rgasd, uref, uinf, uinfd
    use inputphysics, only : pointref, pointrefd, flowtype
    use flowutils_b, only : computeptot, computeptot_b, computettot, &
&   computettot_b
    use overset, only : zippermeshes, zippermesh
    use surfacefamilies, only : familyexchange, bcfamexchange
    use utils_b, only : mynorm2, mynorm2_b, cross_prod, cross_prod_b
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    type(zippermesh), intent(in) :: zipper
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), dimension(:, :) :: varsd
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvaluesd
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
! working variables
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, mredim, fx, fy&
&   , fz
    real(kind=realtype) :: sfd, vmagd, vnmd, vxmd, vymd, vzmd, mredimd, &
&   fxd, fyd, fzd
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   ss, x1, x2, x3, norm
    real(kind=realtype), dimension(3) :: fpd, mpd, fmomd, mmomd, &
&   refpointd, ssd, x1d, x2d, x3d, normd
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, mnm, &
&   massflowratelocal
    real(kind=realtype) :: pmd, ptotd, ttotd, rhomd, gammamd, mnmd, &
&   massflowratelocald
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn, pk
    real(kind=realtype) :: massflowrated, mass_ptotd, mass_ttotd, &
&   mass_psd, mass_mnd, pkd
    real(kind=realtype) :: internalflowfact, inflowfact, xc, yc, zc, &
&   cellarea, mx, my, mz
    real(kind=realtype) :: xcd, ycd, zcd, mxd, myd, mzd
    real(kind=realtype), dimension(:), pointer :: localptr
    intrinsic sqrt
    intrinsic size
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1d
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype), dimension(3) :: arg2d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    integer(kind=inttype) :: res
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp4
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    mredim = sqrt(pref*rhoref)
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
    mmomd = 0.0_8
    mmomd = localvaluesd(iflowmm:iflowmm+2)
    mpd = 0.0_8
    mpd = localvaluesd(iflowmp:iflowmp+2)
    fmomd = 0.0_8
    fmomd = localvaluesd(iflowfm:iflowfm+2)
    fpd = 0.0_8
    fpd = localvaluesd(iflowfp:iflowfp+2)
    pkd = localvaluesd(ipk)
    mass_mnd = localvaluesd(imassmn)
    mass_psd = localvaluesd(imassps)
    mass_ttotd = localvaluesd(imassttot)
    mass_ptotd = localvaluesd(imassptot)
    massflowrated = localvaluesd(imassflow)
    mredimd = 0.0_8
    normd = 0.0_8
    ptotd = 0.0_8
    refpointd = 0.0_8
    gammamd = 0.0_8
    ttotd = 0.0_8
    do i=1,size(zipper%conn, 2)
      res = bsearchintegers(zipper%fam(i), famlist)
      if (res .gt. 0) then
! compute the averaged values for this trianlge
        vxm = zero
        vym = zero
        vzm = zero
        rhom = zero
        pm = zero
        sf = zero
        do j=1,3
          rhom = rhom + vars(zipper%conn(j, i), irho)
          vxm = vxm + vars(zipper%conn(j, i), ivx)
          vym = vym + vars(zipper%conn(j, i), ivy)
          vzm = vzm + vars(zipper%conn(j, i), ivz)
          pm = pm + vars(zipper%conn(j, i), irhoe)
          gammam = gammam + vars(zipper%conn(j, i), 6)
          sf = sf + vars(zipper%conn(j, i), 7)
        end do
! divide by 3 due to the summation above:
        rhom = third*rhom
        vxm = third*vxm
        vym = third*vym
        vzm = third*vzm
        pm = third*pm
        gammam = third*gammam
        sf = third*sf
! get the nodes of triangle.
        x1 = vars(zipper%conn(1, i), 7:9)
        x2 = vars(zipper%conn(2, i), 7:9)
        x3 = vars(zipper%conn(3, i), 7:9)
        arg1(:) = x2 - x1
        arg2(:) = x3 - x1
        call cross_prod(arg1(:), arg2(:), norm)
        ss = -(half*norm)
        call computeptot(rhom, vxm, vym, vzm, pm, ptot)
        call computettot(rhom, vxm, vym, vzm, pm, ttot)
        vnm = vxm*ss(1) + vym*ss(2) + vzm*ss(3) - sf
        vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
! a = sqrt(gamma*p/rho); sqrt(v**2/a**2)
        mnm = vmag/sqrt(gammam*pm/rhom)
        massflowratelocal = rhom*vnm*mredim
        call pushreal8(pm)
        pm = pm*pref
! compute the average cell center. 
        xc = zero
        yc = zero
        zc = zero
        do j=1,3
          xc = xc + vars(zipper%conn(1, i), 7)
          yc = yc + vars(zipper%conn(2, i), 8)
          zc = zc + vars(zipper%conn(3, i), 9)
        end do
! finish average for cell center
        xc = third*xc
        yc = third*yc
        zc = third*zc
        xc = xc - refpoint(1)
        yc = yc - refpoint(2)
        zc = zc - refpoint(3)
        call pushreal8(pm)
        pm = -(pm-pinf*pref)
! update the pressure force and moment coefficients.
! momentum forces
! get unit normal vector. 
        result1 = mynorm2(ss)
        call pushreal8array(ss, 3)
        ss = ss/result1
        call pushreal8(massflowratelocal)
        massflowratelocal = massflowratelocal/timeref*internalflowfact*&
&         inflowfact
        fx = massflowratelocal*ss(1)*vxm/timeref
        fy = massflowratelocal*ss(2)*vym/timeref
        fz = massflowratelocal*ss(3)*vzm/timeref
        temp2 = ss(1)/timeref
        temp3 = ss(2)/timeref
        mzd = mmomd(3)
        myd = mmomd(2)
        mxd = mmomd(1)
        xcd = fy*mzd - fz*myd
        fyd = xc*mzd - fmomd(2) - zc*mxd
        ycd = fz*mxd - fx*mzd
        fxd = zc*myd - fmomd(1) - yc*mzd
        zcd = fx*myd - fy*mxd
        fzd = yc*mxd - fmomd(3) - xc*myd
        ssd = 0.0_8
        tempd4 = massflowratelocal*vzm*fzd/timeref
        temp4 = ss(3)/timeref
        ssd(3) = ssd(3) + tempd4
        massflowratelocald = temp3*vym*fyd + temp2*vxm*fxd + temp4*vzm*&
&         fzd
        vzmd = temp4*massflowratelocal*fzd
        tempd5 = massflowratelocal*vym*fyd/timeref
        ssd(2) = ssd(2) + tempd5
        vymd = temp3*massflowratelocal*fyd
        tempd7 = massflowratelocal*vxm*fxd/timeref
        ssd(1) = ssd(1) + tempd7
        vxmd = temp2*massflowratelocal*fxd
        call popreal8(massflowratelocal)
        tempd6 = internalflowfact*inflowfact*massflowratelocald/timeref
        timerefd = timerefd - temp3*tempd5 - massflowratelocal*tempd6/&
&         timeref - temp2*tempd7 - temp4*tempd4
        massflowratelocald = tempd6
        call popreal8array(ss, 3)
        result1d = sum(-(ss*ssd/result1))/result1
        ssd = ssd/result1
        call mynorm2_b(ss, ssd, result1d)
        mzd = mpd(3)
        myd = mpd(2)
        mxd = mpd(1)
        fx = pm*ss(1)
        fy = pm*ss(2)
        fyd = fpd(2) - zc*mxd + xc*mzd
        fxd = zc*myd + fpd(1) - yc*mzd
        fz = pm*ss(3)
        xcd = xcd + fy*mzd - fz*myd
        ycd = ycd + fz*mxd - fx*mzd
        zcd = zcd + fx*myd - fy*mxd
        fzd = yc*mxd + fpd(3) - xc*myd
        pmd = ss(2)*fyd + ss(1)*fxd + ss(3)*fzd
        ssd(3) = ssd(3) + pm*fzd
        ssd(2) = ssd(2) + pm*fyd
        ssd(1) = ssd(1) + pm*fxd
        call popreal8(pm)
        prefd = prefd + pinf*pmd
        pmd = -pmd
        refpointd(3) = refpointd(3) - zcd
        refpointd(2) = refpointd(2) - ycd
        refpointd(1) = refpointd(1) - xcd
        zcd = third*zcd
        ycd = third*ycd
        xcd = third*xcd
        do j=3,1,-1
          varsd(zipper%conn(3, i), 9) = varsd(zipper%conn(3, i), 9) + &
&           zcd
          varsd(zipper%conn(2, i), 8) = varsd(zipper%conn(2, i), 8) + &
&           ycd
          varsd(zipper%conn(1, i), 7) = varsd(zipper%conn(1, i), 7) + &
&           xcd
        end do
        mnmd = massflowratelocal*mass_mnd
        massflowratelocald = massflowratelocald + pm*mass_psd + pref*&
&         ptot*mass_ptotd + massflowrated + tref*ttot*mass_ttotd + mnm*&
&         mass_mnd
        pmd = pmd + massflowratelocal*mass_psd
        ttotd = ttotd + tref*massflowratelocal*mass_ttotd
        trefd = trefd + ttot*massflowratelocal*mass_ttotd
        ptotd = ptotd + pref*massflowratelocal*mass_ptotd
        call popreal8(pm)
        temp1 = vmag**2 - uinf**2
        tempd1 = uref*vnm*pref*pkd
        tempd0 = uref*(pm-pinf+half*(rhom*temp1))*pkd
        prefd = prefd + pm*pmd + vnm*tempd0 + ptot*massflowratelocal*&
&         mass_ptotd
        vnmd = mredim*rhom*massflowratelocald + pref*tempd0
        mredimd = mredimd + rhom*vnm*massflowratelocald
        temp = gammam*pm/rhom
        temp0 = sqrt(temp)
        vmagd = mnmd/temp0 + rhom*half*2*vmag*tempd1
        if (temp .eq. 0.0_8) then
          tempd2 = 0.0
        else
          tempd2 = -(vmag*mnmd/(2.0*temp0**3*rhom))
        end if
        pmd = tempd1 + gammam*tempd2 + pref*pmd
        rhomd = mredim*vnm*massflowratelocald - temp*tempd2 + half*temp1&
&         *tempd1
        gammamd = gammamd + pm*tempd2
        if (vxm**2 + vym**2 + vzm**2 .eq. 0.0_8) then
          tempd3 = 0.0
        else
          tempd3 = vmagd/(2.0*sqrt(vxm**2+vym**2+vzm**2))
        end if
        vxmd = vxmd + ss(1)*vnmd + 2*vxm*tempd3
        vymd = vymd + ss(2)*vnmd + 2*vym*tempd3
        vzmd = vzmd + ss(3)*vnmd + 2*vzm*tempd3
        sfd = -vnmd - vmagd
        ssd(1) = ssd(1) + vxm*vnmd
        ssd(2) = ssd(2) + vym*vnmd
        ssd(3) = ssd(3) + vzm*vnmd
        call computettot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, vzmd&
&                    , pm, pmd, ttot, ttotd)
        call computeptot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, vzmd&
&                    , pm, pmd, ptot, ptotd)
        normd = normd - half*ssd
        call cross_prod_b(arg1(:), arg1d(:), arg2(:), arg2d(:), norm, &
&                   normd)
        x1d = 0.0_8
        x3d = 0.0_8
        x3d = arg2d(:)
        x1d = -arg1d(:) - arg2d(:)
        x2d = 0.0_8
        x2d = arg1d(:)
        varsd(zipper%conn(3, i), 7:9) = varsd(zipper%conn(3, i), 7:9) + &
&         x3d
        varsd(zipper%conn(2, i), 7:9) = varsd(zipper%conn(2, i), 7:9) + &
&         x2d
        varsd(zipper%conn(1, i), 7:9) = varsd(zipper%conn(1, i), 7:9) + &
&         x1d
        sfd = third*sfd
        gammamd = third*gammamd
        pmd = third*pmd
        vzmd = third*vzmd
        vymd = third*vymd
        vxmd = third*vxmd
        rhomd = third*rhomd
        do j=3,1,-1
          varsd(zipper%conn(j, i), 7) = varsd(zipper%conn(j, i), 7) + &
&           sfd
          varsd(zipper%conn(j, i), 6) = varsd(zipper%conn(j, i), 6) + &
&           gammamd
          varsd(zipper%conn(j, i), irhoe) = varsd(zipper%conn(j, i), &
&           irhoe) + pmd
          varsd(zipper%conn(j, i), ivz) = varsd(zipper%conn(j, i), ivz) &
&           + vzmd
          varsd(zipper%conn(j, i), ivy) = varsd(zipper%conn(j, i), ivy) &
&           + vymd
          varsd(zipper%conn(j, i), ivx) = varsd(zipper%conn(j, i), ivx) &
&           + vxmd
          varsd(zipper%conn(j, i), irho) = varsd(zipper%conn(j, i), irho&
&           ) + rhomd
        end do
      end if
    end do
    if (pref*rhoref .eq. 0.0_8) then
      tempd = 0.0
    else
      tempd = mredimd/(2.0*sqrt(pref*rhoref))
    end if
    prefd = prefd + rhoref*tempd
    rhorefd = rhorefd + pref*tempd
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine flowintegrationzipper_b
  subroutine flowintegrationzipper(isinflow, zipper, vars, localvalues, &
&   famlist, sps)
! integrate over the trianges for the inflow/outflow conditions. 
    use constants
    use costfunctions, only : nlocalvalues, imassflow, imassptot, &
&   imassttot, imassps, iflowmm, iflowmp, iflowfm, iflowfp, imassmn, ipk
    use blockpointers, only : bctype
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : pref, pinf, rhoref, pref, timeref, &
&   lref, tref, rgas, uref, uinf
    use inputphysics, only : pointref, flowtype
    use flowutils_b, only : computeptot, computettot
    use overset, only : zippermeshes, zippermesh
    use surfacefamilies, only : familyexchange, bcfamexchange
    use utils_b, only : mynorm2, cross_prod
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    type(zippermesh), intent(in) :: zipper
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
! working variables
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, mredim, fx, fy&
&   , fz
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   ss, x1, x2, x3, norm
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, mnm, &
&   massflowratelocal
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn, pk
    real(kind=realtype) :: internalflowfact, inflowfact, xc, yc, zc, &
&   cellarea, mx, my, mz
    real(kind=realtype), dimension(:), pointer :: localptr
    intrinsic sqrt
    intrinsic size
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype) :: result1
    massflowrate = zero
    mass_ptot = zero
    mass_ttot = zero
    mass_ps = zero
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    mredim = sqrt(pref*rhoref)
    fp = zero
    mp = zero
    fmom = zero
    mmom = zero
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
    do i=1,size(zipper%conn, 2)
      if (bsearchintegers(zipper%fam(i), famlist) .gt. 0) then
! compute the averaged values for this trianlge
        vxm = zero
        vym = zero
        vzm = zero
        rhom = zero
        pm = zero
        mnm = zero
        sf = zero
        do j=1,3
          rhom = rhom + vars(zipper%conn(j, i), irho)
          vxm = vxm + vars(zipper%conn(j, i), ivx)
          vym = vym + vars(zipper%conn(j, i), ivy)
          vzm = vzm + vars(zipper%conn(j, i), ivz)
          pm = pm + vars(zipper%conn(j, i), irhoe)
          gammam = gammam + vars(zipper%conn(j, i), 6)
          sf = sf + vars(zipper%conn(j, i), 7)
        end do
! divide by 3 due to the summation above:
        rhom = third*rhom
        vxm = third*vxm
        vym = third*vym
        vzm = third*vzm
        pm = third*pm
        gammam = third*gammam
        sf = third*sf
! get the nodes of triangle.
        x1 = vars(zipper%conn(1, i), 7:9)
        x2 = vars(zipper%conn(2, i), 7:9)
        x3 = vars(zipper%conn(3, i), 7:9)
        arg1(:) = x2 - x1
        arg2(:) = x3 - x1
        call cross_prod(arg1(:), arg2(:), norm)
        ss = -(half*norm)
        call computeptot(rhom, vxm, vym, vzm, pm, ptot)
        call computettot(rhom, vxm, vym, vzm, pm, ttot)
        vnm = vxm*ss(1) + vym*ss(2) + vzm*ss(3) - sf
        vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
! a = sqrt(gamma*p/rho); sqrt(v**2/a**2)
        mnm = vmag/sqrt(gammam*pm/rhom)
        massflowratelocal = rhom*vnm*mredim
        massflowrate = massflowrate + massflowratelocal
        pk = pk + (pm-pinf+half*rhom*(vmag**2-uinf**2))*vnm*pref*uref
        pm = pm*pref
        mass_ptot = mass_ptot + ptot*massflowratelocal*pref
        mass_ttot = mass_ttot + ttot*massflowratelocal*tref
        mass_ps = mass_ps + pm*massflowratelocal
        mass_mn = mass_mn + mnm*massflowratelocal
! compute the average cell center. 
        xc = zero
        yc = zero
        zc = zero
        do j=1,3
          xc = xc + vars(zipper%conn(1, i), 7)
          yc = yc + vars(zipper%conn(2, i), 8)
          zc = zc + vars(zipper%conn(3, i), 9)
        end do
! finish average for cell center
        xc = third*xc
        yc = third*yc
        zc = third*zc
        xc = xc - refpoint(1)
        yc = yc - refpoint(2)
        zc = zc - refpoint(3)
        pm = -(pm-pinf*pref)
        fx = pm*ss(1)
        fy = pm*ss(2)
        fz = pm*ss(3)
! update the pressure force and moment coefficients.
        fp(1) = fp(1) + fx
        fp(2) = fp(2) + fy
        fp(3) = fp(3) + fz
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mp(1) = mp(1) + mx
        mp(2) = mp(2) + my
        mp(3) = mp(3) + mz
! momentum forces
! get unit normal vector. 
        result1 = mynorm2(ss)
        ss = ss/result1
        massflowratelocal = massflowratelocal/timeref*internalflowfact*&
&         inflowfact
        fx = massflowratelocal*ss(1)*vxm/timeref
        fy = massflowratelocal*ss(2)*vym/timeref
        fz = massflowratelocal*ss(3)*vzm/timeref
        fmom(1) = fmom(1) - fx
        fmom(2) = fmom(2) - fy
        fmom(3) = fmom(3) - fz
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mmom(1) = mmom(1) + mx
        mmom(2) = mmom(2) + my
        mmom(3) = mmom(3) + mz
      end if
    end do
! increment the local values array with what we computed here
    localvalues(imassflow) = localvalues(imassflow) + massflowrate
    localvalues(imassptot) = localvalues(imassptot) + mass_ptot
    localvalues(imassttot) = localvalues(imassttot) + mass_ttot
    localvalues(imassps) = localvalues(imassps) + mass_ps
    localvalues(imassmn) = localvalues(imassmn) + mass_mn
    localvalues(ipk) = localvalues(ipk) + pk
    localvalues(iflowfp:iflowfp+2) = localvalues(iflowfp:iflowfp+2) + fp
    localvalues(iflowfm:iflowfm+2) = localvalues(iflowfm:iflowfm+2) + &
&     fmom
    localvalues(iflowmp:iflowmp+2) = localvalues(iflowmp:iflowmp+2) + mp
    localvalues(iflowmm:iflowmm+2) = localvalues(iflowmm:iflowmm+2) + &
&     mmom
  end subroutine flowintegrationzipper
  subroutine flowintegrationzipperwithgathered(isinflow, zipper, vars, &
&   globalcfvals, localvalues, famlist, sps)
! integrate over the trianges for the inflow/outflow conditions. 
    use constants
    use costfunctions, only : nlocalvalues, isigmamn, isigmaptot, &
&   costfuncmavgmn, costfuncmavgptot, ncostfunction
    use blockpointers, only : bctype
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : pref, pinf, rhoref, pref, timeref, &
&   lref, tref, rgas
    use inputphysics, only : pointref, flowtype
    use flowutils_b, only : computeptot
    use overset, only : zippermeshes, zippermesh
    use surfacefamilies, only : familyexchange, bcfamexchange
    use utils_b, only : mynorm2, cross_prod
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    type(zippermesh), intent(in) :: zipper
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), dimension(ncostfunction), intent(in) :: &
&   globalcfvals
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
! working variables
    integer(kind=inttype) :: i, j
    real(kind=realtype) :: sf, vmag, vnm, vxm, vym, vzm, mredim
    real(kind=realtype), dimension(3) :: ss, x1, x2, x3, norm
    real(kind=realtype) :: pm, ptot, rhom, gammam, massavgptot, &
&   sigmaptot
    real(kind=realtype) :: mnm, massflowratelocal, sigmamn, massavgmn
    real(kind=realtype) :: internalflowfact, inflowfact
    real(kind=realtype), dimension(:), pointer :: localptr
    intrinsic sqrt
    intrinsic size
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg2
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
    mredim = sqrt(pref*rhoref)
    massavgmn = globalcfvals(costfuncmavgmn)
    massavgptot = globalcfvals(costfuncmavgptot)
    sigmamn = zero
    sigmaptot = zero
    do i=1,size(zipper%conn, 2)
      if (bsearchintegers(zipper%fam(i), famlist) .gt. 0) then
! compute the averaged values for this trianlge
        vxm = zero
        vym = zero
        vzm = zero
        rhom = zero
        pm = zero
        mnm = zero
        sf = zero
        do j=1,3
          rhom = rhom + vars(zipper%conn(j, i), irho)
          vxm = vxm + vars(zipper%conn(j, i), ivx)
          vym = vym + vars(zipper%conn(j, i), ivy)
          vzm = vzm + vars(zipper%conn(j, i), ivz)
          pm = pm + vars(zipper%conn(j, i), irhoe)
          gammam = gammam + vars(zipper%conn(j, i), 6)
          sf = sf + vars(zipper%conn(j, i), 7)
        end do
! divide by 3 due to the summation above:
        rhom = third*rhom
        vxm = third*vxm
        vym = third*vym
        vzm = third*vzm
        pm = third*pm
        gammam = third*gammam
        sf = third*sf
! get the nodes of triangle.
        x1 = vars(zipper%conn(1, i), 7:9)
        x2 = vars(zipper%conn(2, i), 7:9)
        x3 = vars(zipper%conn(3, i), 7:9)
        arg1(:) = x2 - x1
        arg2(:) = x3 - x1
        call cross_prod(arg1(:), arg2(:), norm)
        ss = -(half*norm)
        vnm = vxm*ss(1) + vym*ss(2) + vzm*ss(3) - sf
        vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
        mnm = sqrt((vxm**2+vym**2+vzm**2)*rhom/(gammam*pm))
        call computeptot(rhom, vxm, vym, vzm, pm, ptot)
        ptot = ptot*pref
        massflowratelocal = rhom*vnm*mredim
        sigmamn = sigmamn + massflowratelocal*(mnm-massavgmn)**2
        sigmaptot = sigmaptot + massflowratelocal*(ptot-massavgptot)**2
      end if
    end do
    localvalues(isigmamn) = localvalues(isigmamn) + sigmamn
    localvalues(isigmaptot) = localvalues(isigmaptot) + sigmaptot
  end subroutine flowintegrationzipperwithgathered
!  differentiation of wallintegrationzipper in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: pointref vars localvalues
!   with respect to varying inputs: pointref vars localvalues
!   rw status of diff variables: pointref:incr vars:incr localvalues:in-out
  subroutine wallintegrationzipper_b(zipper, vars, varsd, localvalues, &
&   localvaluesd, famlist, sps)
    use constants
    use costfunctions
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : lref
    use inputphysics, only : pointref, pointrefd
    use overset, only : zippermeshes, zippermesh
    use utils_b, only : mynorm2, mynorm2_b, cross_prod, cross_prod_b
    implicit none
! input/output
    type(zippermesh), intent(in) :: zipper
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), dimension(:, :) :: varsd
    real(kind=realtype), intent(inout) :: localvalues(nlocalvalues)
    real(kind=realtype) :: localvaluesd(nlocalvalues)
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
! working
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype), dimension(3) :: fpd, fvd, mpd, mvd
    integer(kind=inttype) :: i, j
    real(kind=realtype), dimension(3) :: ss, norm, refpoint
    real(kind=realtype), dimension(3) :: ssd, normd, refpointd
    real(kind=realtype), dimension(3) :: p1, p2, p3, v1, v2, v3, x1, x2&
&   , x3
    real(kind=realtype), dimension(3) :: p1d, p2d, p3d, v1d, v2d, v3d, &
&   x1d, x2d, x3d
    real(kind=realtype) :: fact, triarea, fx, fy, fz, mx, my, mz, xc, yc&
&   , zc
    real(kind=realtype) :: triaread, fxd, fyd, fzd, mxd, myd, mzd, xcd, &
&   ycd, zcd
    intrinsic size
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg1d
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype), dimension(3) :: arg2d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    integer(kind=inttype) :: res
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    mvd = 0.0_8
    mvd = localvaluesd(imv:imv+2)
    mpd = 0.0_8
    mpd = localvaluesd(imp:imp+2)
    fvd = 0.0_8
    fvd = localvaluesd(ifv:ifv+2)
    fpd = 0.0_8
    fpd = localvaluesd(ifp:ifp+2)
    normd = 0.0_8
    refpointd = 0.0_8
    do i=1,size(zipper%conn, 2)
      res = bsearchintegers(zipper%fam(i), famlist)
      if (res .gt. 0) then
! get the nodes of triangle. the *3 is becuase of the
! blanket third above. 
        x1 = vars(zipper%conn(1, i), 7:9)
        x2 = vars(zipper%conn(2, i), 7:9)
        x3 = vars(zipper%conn(3, i), 7:9)
        arg1(:) = x2 - x1
        arg2(:) = x3 - x1
        call cross_prod(arg1(:), arg2(:), norm)
        ss = half*norm
! the third here is to account for the summation of p1, p2
! and p3
        result1 = mynorm2(ss)
        triarea = result1*third
! compute the average cell center. 
        xc = third*(x1(1)+x2(1)+x3(1))
        yc = third*(x1(2)+x2(2)+x3(2))
        zc = third*(x1(3)+x2(3)+x3(3))
        xc = xc - refpoint(1)
        yc = yc - refpoint(2)
        zc = zc - refpoint(3)
! update the pressure force and moment coefficients.
        p1 = vars(zipper%conn(1, i), 1:3)
        p2 = vars(zipper%conn(2, i), 1:3)
        p3 = vars(zipper%conn(3, i), 1:3)
! update the viscous force and moment coefficients
        v1 = vars(zipper%conn(1, i), 4:6)
        v2 = vars(zipper%conn(2, i), 4:6)
        v3 = vars(zipper%conn(3, i), 4:6)
        fx = (v1(1)+v2(1)+v3(1))*triarea
        fy = (v1(2)+v2(2)+v3(2))*triarea
        fz = (v1(3)+v2(3)+v3(3))*triarea
! note: momentum forces have opposite sign to pressure forces
        mzd = mvd(3)
        myd = mvd(2)
        mxd = mvd(1)
        xcd = fy*mzd - fz*myd
        fyd = fvd(2) - zc*mxd + xc*mzd
        ycd = fz*mxd - fx*mzd
        fxd = zc*myd + fvd(1) - yc*mzd
        zcd = fx*myd - fy*mxd
        fzd = yc*mxd + fvd(3) - xc*myd
        v1d = 0.0_8
        v2d = 0.0_8
        v3d = 0.0_8
        tempd = triarea*fzd
        v1d(3) = v1d(3) + tempd
        v2d(3) = v2d(3) + tempd
        v3d(3) = v3d(3) + tempd
        triaread = (v1(2)+v2(2)+v3(2))*fyd + (v1(1)+v2(1)+v3(1))*fxd + (&
&         v1(3)+v2(3)+v3(3))*fzd
        tempd0 = triarea*fyd
        v1d(2) = v1d(2) + tempd0
        v2d(2) = v2d(2) + tempd0
        v3d(2) = v3d(2) + tempd0
        tempd1 = triarea*fxd
        v1d(1) = v1d(1) + tempd1
        v2d(1) = v2d(1) + tempd1
        v3d(1) = v3d(1) + tempd1
        varsd(zipper%conn(3, i), 4:6) = varsd(zipper%conn(3, i), 4:6) + &
&         v3d
        varsd(zipper%conn(2, i), 4:6) = varsd(zipper%conn(2, i), 4:6) + &
&         v2d
        varsd(zipper%conn(1, i), 4:6) = varsd(zipper%conn(1, i), 4:6) + &
&         v1d
        mzd = mpd(3)
        myd = mpd(2)
        mxd = mpd(1)
        fx = (p1(1)+p2(1)+p3(1))*triarea
        fy = (p1(2)+p2(2)+p3(2))*triarea
        fyd = fpd(2) - zc*mxd + xc*mzd
        fxd = zc*myd + fpd(1) - yc*mzd
        fz = (p1(3)+p2(3)+p3(3))*triarea
        xcd = xcd + fy*mzd - fz*myd
        ycd = ycd + fz*mxd - fx*mzd
        zcd = zcd + fx*myd - fy*mxd
        fzd = yc*mxd + fpd(3) - xc*myd
        p1d = 0.0_8
        p2d = 0.0_8
        p3d = 0.0_8
        tempd2 = triarea*fzd
        p1d(3) = p1d(3) + tempd2
        p2d(3) = p2d(3) + tempd2
        p3d(3) = p3d(3) + tempd2
        triaread = triaread + (p1(2)+p2(2)+p3(2))*fyd + (p1(1)+p2(1)+p3(&
&         1))*fxd + (p1(3)+p2(3)+p3(3))*fzd
        tempd3 = triarea*fyd
        p1d(2) = p1d(2) + tempd3
        p2d(2) = p2d(2) + tempd3
        p3d(2) = p3d(2) + tempd3
        tempd4 = triarea*fxd
        p1d(1) = p1d(1) + tempd4
        p2d(1) = p2d(1) + tempd4
        p3d(1) = p3d(1) + tempd4
        varsd(zipper%conn(3, i), 1:3) = varsd(zipper%conn(3, i), 1:3) + &
&         p3d
        varsd(zipper%conn(2, i), 1:3) = varsd(zipper%conn(2, i), 1:3) + &
&         p2d
        varsd(zipper%conn(1, i), 1:3) = varsd(zipper%conn(1, i), 1:3) + &
&         p1d
        refpointd(3) = refpointd(3) - zcd
        refpointd(2) = refpointd(2) - ycd
        refpointd(1) = refpointd(1) - xcd
        x1d = 0.0_8
        x2d = 0.0_8
        x3d = 0.0_8
        tempd5 = third*zcd
        x1d(3) = x1d(3) + tempd5
        x2d(3) = x2d(3) + tempd5
        x3d(3) = x3d(3) + tempd5
        tempd6 = third*ycd
        x1d(2) = x1d(2) + tempd6
        x2d(2) = x2d(2) + tempd6
        x3d(2) = x3d(2) + tempd6
        tempd7 = third*xcd
        x1d(1) = x1d(1) + tempd7
        x2d(1) = x2d(1) + tempd7
        x3d(1) = x3d(1) + tempd7
        result1d = third*triaread
        ssd = 0.0_8
        call mynorm2_b(ss, ssd, result1d)
        normd = normd + half*ssd
        call cross_prod_b(arg1(:), arg1d(:), arg2(:), arg2d(:), norm, &
&                   normd)
        x3d = x3d + arg2d
        x1d = x1d - arg1d - arg2d
        x2d = x2d + arg1d
        varsd(zipper%conn(3, i), 7:9) = varsd(zipper%conn(3, i), 7:9) + &
&         x3d
        varsd(zipper%conn(2, i), 7:9) = varsd(zipper%conn(2, i), 7:9) + &
&         x2d
        varsd(zipper%conn(1, i), 7:9) = varsd(zipper%conn(1, i), 7:9) + &
&         x1d
      end if
    end do
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine wallintegrationzipper_b
  subroutine wallintegrationzipper(zipper, vars, localvalues, famlist, &
&   sps)
    use constants
    use costfunctions
    use sorting, only : bsearchintegers
    use flowvarrefstate, only : lref
    use inputphysics, only : pointref
    use overset, only : zippermeshes, zippermesh
    use utils_b, only : mynorm2, cross_prod
    implicit none
! input/output
    type(zippermesh), intent(in) :: zipper
    real(kind=realtype), dimension(:, :), intent(in) :: vars
    real(kind=realtype), intent(inout) :: localvalues(nlocalvalues)
    integer(kind=inttype), dimension(:), intent(in) :: famlist
    integer(kind=inttype), intent(in) :: sps
! working
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    integer(kind=inttype) :: i, j
    real(kind=realtype), dimension(3) :: ss, norm, refpoint
    real(kind=realtype), dimension(3) :: p1, p2, p3, v1, v2, v3, x1, x2&
&   , x3
    real(kind=realtype) :: fact, triarea, fx, fy, fz, mx, my, mz, xc, yc&
&   , zc
    intrinsic size
    real(kind=realtype), dimension(3) :: arg1
    real(kind=realtype), dimension(3) :: arg2
    real(kind=realtype) :: result1
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
    fp = zero
    fv = zero
    mp = zero
    mv = zero
    do i=1,size(zipper%conn, 2)
      if (bsearchintegers(zipper%fam(i), famlist) .gt. 0) then
! get the nodes of triangle. the *3 is becuase of the
! blanket third above. 
        x1 = vars(zipper%conn(1, i), 7:9)
        x2 = vars(zipper%conn(2, i), 7:9)
        x3 = vars(zipper%conn(3, i), 7:9)
        arg1(:) = x2 - x1
        arg2(:) = x3 - x1
        call cross_prod(arg1(:), arg2(:), norm)
        ss = half*norm
! the third here is to account for the summation of p1, p2
! and p3
        result1 = mynorm2(ss)
        triarea = result1*third
! compute the average cell center. 
        xc = third*(x1(1)+x2(1)+x3(1))
        yc = third*(x1(2)+x2(2)+x3(2))
        zc = third*(x1(3)+x2(3)+x3(3))
        xc = xc - refpoint(1)
        yc = yc - refpoint(2)
        zc = zc - refpoint(3)
! update the pressure force and moment coefficients.
        p1 = vars(zipper%conn(1, i), 1:3)
        p2 = vars(zipper%conn(2, i), 1:3)
        p3 = vars(zipper%conn(3, i), 1:3)
        fx = (p1(1)+p2(1)+p3(1))*triarea
        fy = (p1(2)+p2(2)+p3(2))*triarea
        fz = (p1(3)+p2(3)+p3(3))*triarea
        fp(1) = fp(1) + fx
        fp(2) = fp(2) + fy
        fp(3) = fp(3) + fz
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mp(1) = mp(1) + mx
        mp(2) = mp(2) + my
        mp(3) = mp(3) + mz
! update the viscous force and moment coefficients
        v1 = vars(zipper%conn(1, i), 4:6)
        v2 = vars(zipper%conn(2, i), 4:6)
        v3 = vars(zipper%conn(3, i), 4:6)
        fx = (v1(1)+v2(1)+v3(1))*triarea
        fy = (v1(2)+v2(2)+v3(2))*triarea
        fz = (v1(3)+v2(3)+v3(3))*triarea
! note: momentum forces have opposite sign to pressure forces
        fv(1) = fv(1) + fx
        fv(2) = fv(2) + fy
        fv(3) = fv(3) + fz
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mv(1) = mv(1) + mx
        mv(2) = mv(2) + my
        mv(3) = mv(3) + mz
      end if
    end do
! increment into the local vector
    localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
    localvalues(ifv:ifv+2) = localvalues(ifv:ifv+2) + fv
    localvalues(imp:imp+2) = localvalues(imp:imp+2) + mp
    localvalues(imv:imv+2) = localvalues(imv:imv+2) + mv
  end subroutine wallintegrationzipper
end module surfaceintegrations_b

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module surfaceintegrations_b
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
!  differentiation of getcostfunctions in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: machcoef dragdirection liftdirection
!                pref funcvalues
!   with respect to varying inputs: machcoef dragdirection liftdirection
!                pref globalvals funcvalues
!   rw status of diff variables: machcoef:incr dragdirection:incr
!                liftdirection:incr pref:incr globalvals:out funcvalues:in-zero
  subroutine getcostfunctions_b(globalvals, globalvalsd, funcvalues, &
&   funcvaluesd)
    use constants
    use inputtimespectral, only : ntimeintervalsspectral
    use flowvarrefstate, only : pref, prefd, rhoref, rhorefd, tref, &
&   trefd, lref, gammainf, pinf, pinfd, uref, urefd, uinf, uinfd
    use inputphysics, only : liftdirection, liftdirectiond, &
&   dragdirection, dragdirectiond, surfaceref, machcoef, machcoefd, &
&   lengthref, alpha, alphad, beta, betad, liftindex
    use inputtsstabderiv, only : tsstability
    use utils_b, only : computetsderivatives
    use flowutils_b, only : getdirvector, getdirvector_b
    implicit none
! input/output
    real(kind=realtype), dimension(:, :), intent(in) :: globalvals
    real(kind=realtype), dimension(:, :) :: globalvalsd
    real(kind=realtype), dimension(:) :: funcvalues
    real(kind=realtype), dimension(:) :: funcvaluesd
! working
    real(kind=realtype) :: fact, factmoment, ovrnts
    real(kind=realtype) :: factd
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   forcep, forcev, forcem, moment, cforce, cforcep, cforcev, cforcem, &
&   cmoment
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced&
&   , forcepd, forcevd, forcemd, momentd, cforced, cforcepd, cforcevd, &
&   cforcemd, cmomentd
    real(kind=realtype), dimension(3) :: vcoordref, vfreestreamref
    real(kind=realtype) :: mavgptot, mavgttot, mavgrho, mavgps, mflow, &
&   mavgmn, mavga, mavgvx, mavgvy, mavgvz, garea
    real(kind=realtype) :: mavgptotd, mavgttotd, mavgrhod, mavgpsd, &
&   mflowd, mavgmnd, mavgad, mavgvxd, mavgvyd, mavgvzd, garead
    real(kind=realtype) :: vdotn, mag, u, v, w
    integer(kind=inttype) :: sps
    real(kind=realtype), dimension(8) :: dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
    real(kind=realtype), dimension(8) :: coef0
    intrinsic sqrt
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmp2
    real(kind=realtype) :: tmp3
    real(kind=realtype) :: tmp4
    real(kind=realtype) :: tmp5
    real(kind=realtype) :: tmp6
    real(kind=realtype) :: tmp7
    real(kind=realtype) :: tmp8
    real(kind=realtype) :: tmp9
    real(kind=realtype) :: tmp10
    real(kind=realtype) :: tmp11
    real(kind=realtype) :: tmp12
    real(kind=realtype) :: tmp13
    real(kind=realtype) :: tmp14
    integer :: branch
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd14
    real(kind=realtype) :: tmpd13
    real(kind=realtype) :: tmpd12
    real(kind=realtype) :: tmpd11
    real(kind=realtype) :: tmpd10
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tmpd9
    real(kind=realtype) :: tmpd8
    real(kind=realtype) :: tmpd7
    real(kind=realtype) :: tmpd6
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tmpd5
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd4
    real(kind=realtype) :: tmpd3
    real(kind=realtype) :: tmpd2
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
    real(kind=realtype) :: temp
! factor used for time-averaged quantities.
    ovrnts = one/ntimeintervalsspectral
! sum pressure and viscous contributions
    force = globalvals(ifp:ifp+2, :) + globalvals(ifv:ifv+2, :) + &
&     globalvals(iflowfm:iflowfm+2, :)
    forcep = globalvals(ifp:ifp+2, :)
    forcev = globalvals(ifv:ifv+2, :)
    forcem = globalvals(iflowfm:iflowfm+2, :)
    moment = globalvals(imp:imp+2, :) + globalvals(imv:imv+2, :) + &
&     globalvals(iflowmm:iflowmm+2, :)
    fact = two/(gammainf*machcoef*machcoef*surfaceref*lref*lref*pref)
    cforce = fact*force
    cforcep = fact*forcep
    cforcev = fact*forcev
    cforcem = fact*forcem
! moment factor has an extra lengthref
    call pushreal8(fact)
    fact = fact/(lengthref*lref)
    cmoment = fact*moment
! zero values since we are summing.
    funcvalues = zero
! here we finally assign the final function values
    do sps=1,ntimeintervalsspectral
      funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
&       force(1, sps)
      funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
&       force(2, sps)
      funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
&       force(3, sps)
      funcvalues(costfuncforcexpressure) = funcvalues(&
&       costfuncforcexpressure) + ovrnts*forcep(1, sps)
      funcvalues(costfuncforceypressure) = funcvalues(&
&       costfuncforceypressure) + ovrnts*forcep(2, sps)
      funcvalues(costfuncforcezpressure) = funcvalues(&
&       costfuncforcezpressure) + ovrnts*forcep(3, sps)
      funcvalues(costfuncforcexviscous) = funcvalues(&
&       costfuncforcexviscous) + ovrnts*forcev(1, sps)
      funcvalues(costfuncforceyviscous) = funcvalues(&
&       costfuncforceyviscous) + ovrnts*forcev(2, sps)
      funcvalues(costfuncforcezviscous) = funcvalues(&
&       costfuncforcezviscous) + ovrnts*forcev(3, sps)
      funcvalues(costfuncforcexmomentum) = funcvalues(&
&       costfuncforcexmomentum) + ovrnts*forcem(1, sps)
      funcvalues(costfuncforceymomentum) = funcvalues(&
&       costfuncforceymomentum) + ovrnts*forcem(2, sps)
      funcvalues(costfuncforcezmomentum) = funcvalues(&
&       costfuncforcezmomentum) + ovrnts*forcem(3, sps)
! ------------
      funcvalues(costfuncforcexcoef) = funcvalues(costfuncforcexcoef) + &
&       ovrnts*cforce(1, sps)
      funcvalues(costfuncforceycoef) = funcvalues(costfuncforceycoef) + &
&       ovrnts*cforce(2, sps)
      funcvalues(costfuncforcezcoef) = funcvalues(costfuncforcezcoef) + &
&       ovrnts*cforce(3, sps)
      funcvalues(costfuncforcexcoefpressure) = funcvalues(&
&       costfuncforcexcoefpressure) + ovrnts*cforcep(1, sps)
      funcvalues(costfuncforceycoefpressure) = funcvalues(&
&       costfuncforceycoefpressure) + ovrnts*cforcep(2, sps)
      funcvalues(costfuncforcezcoefpressure) = funcvalues(&
&       costfuncforcezcoefpressure) + ovrnts*cforcep(3, sps)
      funcvalues(costfuncforcexcoefviscous) = funcvalues(&
&       costfuncforcexcoefviscous) + ovrnts*cforcev(1, sps)
      funcvalues(costfuncforceycoefviscous) = funcvalues(&
&       costfuncforceycoefviscous) + ovrnts*cforcev(2, sps)
      funcvalues(costfuncforcezcoefviscous) = funcvalues(&
&       costfuncforcezcoefviscous) + ovrnts*cforcev(3, sps)
      funcvalues(costfuncforcexcoefmomentum) = funcvalues(&
&       costfuncforcexcoefmomentum) + ovrnts*cforcem(1, sps)
      funcvalues(costfuncforceycoefmomentum) = funcvalues(&
&       costfuncforceycoefmomentum) + ovrnts*cforcem(2, sps)
      funcvalues(costfuncforcezcoefmomentum) = funcvalues(&
&       costfuncforcezcoefmomentum) + ovrnts*cforcem(3, sps)
! ------------
      funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*&
&       moment(1, sps)
      funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*&
&       moment(2, sps)
      funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*&
&       moment(3, sps)
      funcvalues(costfuncmomxcoef) = funcvalues(costfuncmomxcoef) + &
&       ovrnts*cmoment(1, sps)
      funcvalues(costfuncmomycoef) = funcvalues(costfuncmomycoef) + &
&       ovrnts*cmoment(2, sps)
      funcvalues(costfuncmomzcoef) = funcvalues(costfuncmomzcoef) + &
&       ovrnts*cmoment(3, sps)
      funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
&       ovrnts*globalvals(isepsensor, sps)
      funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
&       ovrnts*globalvals(icavitation, sps)
      funcvalues(costfuncaxismoment) = funcvalues(costfuncaxismoment) + &
&       ovrnts*globalvals(iaxismoment, sps)
      funcvalues(costfuncsepsensoravgx) = funcvalues(&
&       costfuncsepsensoravgx) + ovrnts*globalvals(isepavg, sps)
      funcvalues(costfuncsepsensoravgy) = funcvalues(&
&       costfuncsepsensoravgy) + ovrnts*globalvals(isepavg+1, sps)
      funcvalues(costfuncsepsensoravgz) = funcvalues(&
&       costfuncsepsensoravgz) + ovrnts*globalvals(isepavg+2, sps)
      funcvalues(costfuncarea) = funcvalues(costfuncarea) + ovrnts*&
&       globalvals(iarea, sps)
      funcvalues(costfuncflowpower) = funcvalues(costfuncflowpower) + &
&       ovrnts*globalvals(ipower, sps)
      funcvalues(costfunccperror2) = funcvalues(costfunccperror2) + &
&       ovrnts*globalvals(icperror2, sps)
! mass flow like objective
      mflow = globalvals(imassflow, sps)
      if (mflow .ne. zero) then
        mavgptot = globalvals(imassptot, sps)/mflow
        mavgttot = globalvals(imassttot, sps)/mflow
        mavgrho = globalvals(imassrho, sps)/mflow
        mavgps = globalvals(imassps, sps)/mflow
        mavgmn = globalvals(imassmn, sps)/mflow
        mavga = globalvals(imassa, sps)/mflow
        mavgvx = globalvals(imassvx, sps)/mflow
        mavgvy = globalvals(imassvy, sps)/mflow
        mavgvz = globalvals(imassvz, sps)/mflow
        mag = sqrt(globalvals(imassnx, sps)**2 + globalvals(imassny, sps&
&         )**2 + globalvals(imassnz, sps)**2)
      else
        mavgptot = zero
        mavgttot = zero
        mavgrho = zero
        mavgps = zero
        mavgmn = zero
        mavga = zero
        mavgvx = zero
        mavgvy = zero
        mavgvz = zero
      end if
! area averaged objectives
      garea = globalvals(iarea, sps)
      if (garea .ne. zero) then
! area averaged pressure
        funcvalues(costfuncaavgptot) = funcvalues(costfuncaavgptot) + &
&         ovrnts*globalvals(iareaptot, sps)/garea
        funcvalues(costfuncaavgps) = funcvalues(costfuncaavgps) + ovrnts&
&         *globalvals(iareaps, sps)/garea
      end if
      funcvalues(costfuncmdot) = funcvalues(costfuncmdot) + ovrnts*mflow
      funcvalues(costfuncmavgptot) = funcvalues(costfuncmavgptot) + &
&       ovrnts*mavgptot
      funcvalues(costfuncmavgttot) = funcvalues(costfuncmavgttot) + &
&       ovrnts*mavgttot
      funcvalues(costfuncmavgrho) = funcvalues(costfuncmavgrho) + ovrnts&
&       *mavgrho
      funcvalues(costfuncmavgps) = funcvalues(costfuncmavgps) + ovrnts*&
&       mavgps
      funcvalues(costfuncmavgmn) = funcvalues(costfuncmavgmn) + ovrnts*&
&       mavgmn
      funcvalues(costfuncmavga) = funcvalues(costfuncmavga) + ovrnts*&
&       mavga
      funcvalues(costfuncmavgvx) = funcvalues(costfuncmavgvx) + ovrnts*&
&       mavgvx
      funcvalues(costfuncmavgvy) = funcvalues(costfuncmavgvy) + ovrnts*&
&       mavgvy
      funcvalues(costfuncmavgvz) = funcvalues(costfuncmavgvz) + ovrnts*&
&       mavgvz
    end do
! bending moment calc - also broken.
! call computerootbendingmoment(cforce, cmoment, liftindex, bendingmoment)
! funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) + ovrnts*bendingmoment
! lift and drag (coefficients): dot product with the lift/drag direction.
    tmp = funcvalues(costfuncforcex)*liftdirection(1) + funcvalues(&
&     costfuncforcey)*liftdirection(2) + funcvalues(costfuncforcez)*&
&     liftdirection(3)
    call pushreal8(funcvalues(costfunclift))
    funcvalues(costfunclift) = tmp
    tmp0 = funcvalues(costfuncforcexpressure)*liftdirection(1) + &
&     funcvalues(costfuncforceypressure)*liftdirection(2) + funcvalues(&
&     costfuncforcezpressure)*liftdirection(3)
    call pushreal8(funcvalues(costfuncliftpressure))
    funcvalues(costfuncliftpressure) = tmp0
    tmp1 = funcvalues(costfuncforcexviscous)*liftdirection(1) + &
&     funcvalues(costfuncforceyviscous)*liftdirection(2) + funcvalues(&
&     costfuncforcezviscous)*liftdirection(3)
    call pushreal8(funcvalues(costfuncliftviscous))
    funcvalues(costfuncliftviscous) = tmp1
    tmp2 = funcvalues(costfuncforcexmomentum)*liftdirection(1) + &
&     funcvalues(costfuncforceymomentum)*liftdirection(2) + funcvalues(&
&     costfuncforcezmomentum)*liftdirection(3)
    call pushreal8(funcvalues(costfuncliftmomentum))
    funcvalues(costfuncliftmomentum) = tmp2
!-----
    tmp3 = funcvalues(costfuncforcex)*dragdirection(1) + funcvalues(&
&     costfuncforcey)*dragdirection(2) + funcvalues(costfuncforcez)*&
&     dragdirection(3)
    call pushreal8(funcvalues(costfuncdrag))
    funcvalues(costfuncdrag) = tmp3
    tmp4 = funcvalues(costfuncforcexpressure)*dragdirection(1) + &
&     funcvalues(costfuncforceypressure)*dragdirection(2) + funcvalues(&
&     costfuncforcezpressure)*dragdirection(3)
    call pushreal8(funcvalues(costfuncdragpressure))
    funcvalues(costfuncdragpressure) = tmp4
    tmp5 = funcvalues(costfuncforcexviscous)*dragdirection(1) + &
&     funcvalues(costfuncforceyviscous)*dragdirection(2) + funcvalues(&
&     costfuncforcezviscous)*dragdirection(3)
    call pushreal8(funcvalues(costfuncdragviscous))
    funcvalues(costfuncdragviscous) = tmp5
    tmp6 = funcvalues(costfuncforcexmomentum)*dragdirection(1) + &
&     funcvalues(costfuncforceymomentum)*dragdirection(2) + funcvalues(&
&     costfuncforcezmomentum)*dragdirection(3)
    call pushreal8(funcvalues(costfuncdragmomentum))
    funcvalues(costfuncdragmomentum) = tmp6
!-----
    tmp7 = funcvalues(costfuncforcexcoef)*liftdirection(1) + funcvalues(&
&     costfuncforceycoef)*liftdirection(2) + funcvalues(&
&     costfuncforcezcoef)*liftdirection(3)
    call pushreal8(funcvalues(costfuncliftcoef))
    funcvalues(costfuncliftcoef) = tmp7
    tmp8 = funcvalues(costfuncforcexcoefpressure)*liftdirection(1) + &
&     funcvalues(costfuncforceycoefpressure)*liftdirection(2) + &
&     funcvalues(costfuncforcezcoefpressure)*liftdirection(3)
    call pushreal8(funcvalues(costfuncliftcoefpressure))
    funcvalues(costfuncliftcoefpressure) = tmp8
    tmp9 = funcvalues(costfuncforcexcoefviscous)*liftdirection(1) + &
&     funcvalues(costfuncforceycoefviscous)*liftdirection(2) + &
&     funcvalues(costfuncforcezcoefviscous)*liftdirection(3)
    call pushreal8(funcvalues(costfuncliftcoefviscous))
    funcvalues(costfuncliftcoefviscous) = tmp9
    tmp10 = funcvalues(costfuncforcexcoefmomentum)*liftdirection(1) + &
&     funcvalues(costfuncforceycoefmomentum)*liftdirection(2) + &
&     funcvalues(costfuncforcezcoefmomentum)*liftdirection(3)
    call pushreal8(funcvalues(costfuncliftcoefmomentum))
    funcvalues(costfuncliftcoefmomentum) = tmp10
!-----
    tmp11 = funcvalues(costfuncforcexcoef)*dragdirection(1) + funcvalues&
&     (costfuncforceycoef)*dragdirection(2) + funcvalues(&
&     costfuncforcezcoef)*dragdirection(3)
    call pushreal8(funcvalues(costfuncdragcoef))
    funcvalues(costfuncdragcoef) = tmp11
    tmp12 = funcvalues(costfuncforcexcoefpressure)*dragdirection(1) + &
&     funcvalues(costfuncforceycoefpressure)*dragdirection(2) + &
&     funcvalues(costfuncforcezcoefpressure)*dragdirection(3)
    call pushreal8(funcvalues(costfuncdragcoefpressure))
    funcvalues(costfuncdragcoefpressure) = tmp12
    tmp13 = funcvalues(costfuncforcexcoefviscous)*dragdirection(1) + &
&     funcvalues(costfuncforceycoefviscous)*dragdirection(2) + &
&     funcvalues(costfuncforcezcoefviscous)*dragdirection(3)
    call pushreal8(funcvalues(costfuncdragcoefviscous))
    funcvalues(costfuncdragcoefviscous) = tmp13
! -------------------- time spectral objectives ------------------
    if (tsstability) then
      stop
    else
      tmpd = funcvaluesd(costfuncdragcoefmomentum)
      funcvaluesd(costfuncdragcoefmomentum) = 0.0_8
      funcvaluesd(costfuncforcexcoefmomentum) = funcvaluesd(&
&       costfuncforcexcoefmomentum) + dragdirection(1)*tmpd
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(&
&       costfuncforcexcoefmomentum)*tmpd
      funcvaluesd(costfuncforceycoefmomentum) = funcvaluesd(&
&       costfuncforceycoefmomentum) + dragdirection(2)*tmpd
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(&
&       costfuncforceycoefmomentum)*tmpd
      funcvaluesd(costfuncforcezcoefmomentum) = funcvaluesd(&
&       costfuncforcezcoefmomentum) + dragdirection(3)*tmpd
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(&
&       costfuncforcezcoefmomentum)*tmpd
      call popreal8(funcvalues(costfuncdragcoefviscous))
      tmpd0 = funcvaluesd(costfuncdragcoefviscous)
      funcvaluesd(costfuncdragcoefviscous) = 0.0_8
      funcvaluesd(costfuncforcexcoefviscous) = funcvaluesd(&
&       costfuncforcexcoefviscous) + dragdirection(1)*tmpd0
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(&
&       costfuncforcexcoefviscous)*tmpd0
      funcvaluesd(costfuncforceycoefviscous) = funcvaluesd(&
&       costfuncforceycoefviscous) + dragdirection(2)*tmpd0
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(&
&       costfuncforceycoefviscous)*tmpd0
      funcvaluesd(costfuncforcezcoefviscous) = funcvaluesd(&
&       costfuncforcezcoefviscous) + dragdirection(3)*tmpd0
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(&
&       costfuncforcezcoefviscous)*tmpd0
      call popreal8(funcvalues(costfuncdragcoefpressure))
      tmpd1 = funcvaluesd(costfuncdragcoefpressure)
      funcvaluesd(costfuncdragcoefpressure) = 0.0_8
      funcvaluesd(costfuncforcexcoefpressure) = funcvaluesd(&
&       costfuncforcexcoefpressure) + dragdirection(1)*tmpd1
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(&
&       costfuncforcexcoefpressure)*tmpd1
      funcvaluesd(costfuncforceycoefpressure) = funcvaluesd(&
&       costfuncforceycoefpressure) + dragdirection(2)*tmpd1
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(&
&       costfuncforceycoefpressure)*tmpd1
      funcvaluesd(costfuncforcezcoefpressure) = funcvaluesd(&
&       costfuncforcezcoefpressure) + dragdirection(3)*tmpd1
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(&
&       costfuncforcezcoefpressure)*tmpd1
      call popreal8(funcvalues(costfuncdragcoef))
      tmpd2 = funcvaluesd(costfuncdragcoef)
      funcvaluesd(costfuncdragcoef) = 0.0_8
      funcvaluesd(costfuncforcexcoef) = funcvaluesd(costfuncforcexcoef) &
&       + dragdirection(1)*tmpd2
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(&
&       costfuncforcexcoef)*tmpd2
      funcvaluesd(costfuncforceycoef) = funcvaluesd(costfuncforceycoef) &
&       + dragdirection(2)*tmpd2
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(&
&       costfuncforceycoef)*tmpd2
      funcvaluesd(costfuncforcezcoef) = funcvaluesd(costfuncforcezcoef) &
&       + dragdirection(3)*tmpd2
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(&
&       costfuncforcezcoef)*tmpd2
      call popreal8(funcvalues(costfuncliftcoefmomentum))
      tmpd3 = funcvaluesd(costfuncliftcoefmomentum)
      funcvaluesd(costfuncliftcoefmomentum) = 0.0_8
      funcvaluesd(costfuncforcexcoefmomentum) = funcvaluesd(&
&       costfuncforcexcoefmomentum) + liftdirection(1)*tmpd3
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(&
&       costfuncforcexcoefmomentum)*tmpd3
      funcvaluesd(costfuncforceycoefmomentum) = funcvaluesd(&
&       costfuncforceycoefmomentum) + liftdirection(2)*tmpd3
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(&
&       costfuncforceycoefmomentum)*tmpd3
      funcvaluesd(costfuncforcezcoefmomentum) = funcvaluesd(&
&       costfuncforcezcoefmomentum) + liftdirection(3)*tmpd3
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(&
&       costfuncforcezcoefmomentum)*tmpd3
      call popreal8(funcvalues(costfuncliftcoefviscous))
      tmpd4 = funcvaluesd(costfuncliftcoefviscous)
      funcvaluesd(costfuncliftcoefviscous) = 0.0_8
      funcvaluesd(costfuncforcexcoefviscous) = funcvaluesd(&
&       costfuncforcexcoefviscous) + liftdirection(1)*tmpd4
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(&
&       costfuncforcexcoefviscous)*tmpd4
      funcvaluesd(costfuncforceycoefviscous) = funcvaluesd(&
&       costfuncforceycoefviscous) + liftdirection(2)*tmpd4
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(&
&       costfuncforceycoefviscous)*tmpd4
      funcvaluesd(costfuncforcezcoefviscous) = funcvaluesd(&
&       costfuncforcezcoefviscous) + liftdirection(3)*tmpd4
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(&
&       costfuncforcezcoefviscous)*tmpd4
      call popreal8(funcvalues(costfuncliftcoefpressure))
      tmpd5 = funcvaluesd(costfuncliftcoefpressure)
      funcvaluesd(costfuncliftcoefpressure) = 0.0_8
      funcvaluesd(costfuncforcexcoefpressure) = funcvaluesd(&
&       costfuncforcexcoefpressure) + liftdirection(1)*tmpd5
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(&
&       costfuncforcexcoefpressure)*tmpd5
      funcvaluesd(costfuncforceycoefpressure) = funcvaluesd(&
&       costfuncforceycoefpressure) + liftdirection(2)*tmpd5
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(&
&       costfuncforceycoefpressure)*tmpd5
      funcvaluesd(costfuncforcezcoefpressure) = funcvaluesd(&
&       costfuncforcezcoefpressure) + liftdirection(3)*tmpd5
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(&
&       costfuncforcezcoefpressure)*tmpd5
      call popreal8(funcvalues(costfuncliftcoef))
      tmpd6 = funcvaluesd(costfuncliftcoef)
      funcvaluesd(costfuncliftcoef) = 0.0_8
      funcvaluesd(costfuncforcexcoef) = funcvaluesd(costfuncforcexcoef) &
&       + liftdirection(1)*tmpd6
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(&
&       costfuncforcexcoef)*tmpd6
      funcvaluesd(costfuncforceycoef) = funcvaluesd(costfuncforceycoef) &
&       + liftdirection(2)*tmpd6
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(&
&       costfuncforceycoef)*tmpd6
      funcvaluesd(costfuncforcezcoef) = funcvaluesd(costfuncforcezcoef) &
&       + liftdirection(3)*tmpd6
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(&
&       costfuncforcezcoef)*tmpd6
      call popreal8(funcvalues(costfuncdragmomentum))
      tmpd7 = funcvaluesd(costfuncdragmomentum)
      funcvaluesd(costfuncdragmomentum) = 0.0_8
      funcvaluesd(costfuncforcexmomentum) = funcvaluesd(&
&       costfuncforcexmomentum) + dragdirection(1)*tmpd7
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(&
&       costfuncforcexmomentum)*tmpd7
      funcvaluesd(costfuncforceymomentum) = funcvaluesd(&
&       costfuncforceymomentum) + dragdirection(2)*tmpd7
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(&
&       costfuncforceymomentum)*tmpd7
      funcvaluesd(costfuncforcezmomentum) = funcvaluesd(&
&       costfuncforcezmomentum) + dragdirection(3)*tmpd7
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(&
&       costfuncforcezmomentum)*tmpd7
      call popreal8(funcvalues(costfuncdragviscous))
      tmpd8 = funcvaluesd(costfuncdragviscous)
      funcvaluesd(costfuncdragviscous) = 0.0_8
      funcvaluesd(costfuncforcexviscous) = funcvaluesd(&
&       costfuncforcexviscous) + dragdirection(1)*tmpd8
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(&
&       costfuncforcexviscous)*tmpd8
      funcvaluesd(costfuncforceyviscous) = funcvaluesd(&
&       costfuncforceyviscous) + dragdirection(2)*tmpd8
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(&
&       costfuncforceyviscous)*tmpd8
      funcvaluesd(costfuncforcezviscous) = funcvaluesd(&
&       costfuncforcezviscous) + dragdirection(3)*tmpd8
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(&
&       costfuncforcezviscous)*tmpd8
      call popreal8(funcvalues(costfuncdragpressure))
      tmpd9 = funcvaluesd(costfuncdragpressure)
      funcvaluesd(costfuncdragpressure) = 0.0_8
      funcvaluesd(costfuncforcexpressure) = funcvaluesd(&
&       costfuncforcexpressure) + dragdirection(1)*tmpd9
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(&
&       costfuncforcexpressure)*tmpd9
      funcvaluesd(costfuncforceypressure) = funcvaluesd(&
&       costfuncforceypressure) + dragdirection(2)*tmpd9
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(&
&       costfuncforceypressure)*tmpd9
      funcvaluesd(costfuncforcezpressure) = funcvaluesd(&
&       costfuncforcezpressure) + dragdirection(3)*tmpd9
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(&
&       costfuncforcezpressure)*tmpd9
      call popreal8(funcvalues(costfuncdrag))
      tmpd10 = funcvaluesd(costfuncdrag)
      funcvaluesd(costfuncdrag) = 0.0_8
      funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + &
&       dragdirection(1)*tmpd10
      dragdirectiond(1) = dragdirectiond(1) + funcvalues(costfuncforcex)&
&       *tmpd10
      funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + &
&       dragdirection(2)*tmpd10
      dragdirectiond(2) = dragdirectiond(2) + funcvalues(costfuncforcey)&
&       *tmpd10
      funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + &
&       dragdirection(3)*tmpd10
      dragdirectiond(3) = dragdirectiond(3) + funcvalues(costfuncforcez)&
&       *tmpd10
      call popreal8(funcvalues(costfuncliftmomentum))
      tmpd11 = funcvaluesd(costfuncliftmomentum)
      funcvaluesd(costfuncliftmomentum) = 0.0_8
      funcvaluesd(costfuncforcexmomentum) = funcvaluesd(&
&       costfuncforcexmomentum) + liftdirection(1)*tmpd11
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(&
&       costfuncforcexmomentum)*tmpd11
      funcvaluesd(costfuncforceymomentum) = funcvaluesd(&
&       costfuncforceymomentum) + liftdirection(2)*tmpd11
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(&
&       costfuncforceymomentum)*tmpd11
      funcvaluesd(costfuncforcezmomentum) = funcvaluesd(&
&       costfuncforcezmomentum) + liftdirection(3)*tmpd11
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(&
&       costfuncforcezmomentum)*tmpd11
      call popreal8(funcvalues(costfuncliftviscous))
      tmpd12 = funcvaluesd(costfuncliftviscous)
      funcvaluesd(costfuncliftviscous) = 0.0_8
      funcvaluesd(costfuncforcexviscous) = funcvaluesd(&
&       costfuncforcexviscous) + liftdirection(1)*tmpd12
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(&
&       costfuncforcexviscous)*tmpd12
      funcvaluesd(costfuncforceyviscous) = funcvaluesd(&
&       costfuncforceyviscous) + liftdirection(2)*tmpd12
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(&
&       costfuncforceyviscous)*tmpd12
      funcvaluesd(costfuncforcezviscous) = funcvaluesd(&
&       costfuncforcezviscous) + liftdirection(3)*tmpd12
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(&
&       costfuncforcezviscous)*tmpd12
      call popreal8(funcvalues(costfuncliftpressure))
      tmpd13 = funcvaluesd(costfuncliftpressure)
      funcvaluesd(costfuncliftpressure) = 0.0_8
      funcvaluesd(costfuncforcexpressure) = funcvaluesd(&
&       costfuncforcexpressure) + liftdirection(1)*tmpd13
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(&
&       costfuncforcexpressure)*tmpd13
      funcvaluesd(costfuncforceypressure) = funcvaluesd(&
&       costfuncforceypressure) + liftdirection(2)*tmpd13
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(&
&       costfuncforceypressure)*tmpd13
      funcvaluesd(costfuncforcezpressure) = funcvaluesd(&
&       costfuncforcezpressure) + liftdirection(3)*tmpd13
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(&
&       costfuncforcezpressure)*tmpd13
      call popreal8(funcvalues(costfunclift))
      tmpd14 = funcvaluesd(costfunclift)
      funcvaluesd(costfunclift) = 0.0_8
      funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + &
&       liftdirection(1)*tmpd14
      liftdirectiond(1) = liftdirectiond(1) + funcvalues(costfuncforcex)&
&       *tmpd14
      funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + &
&       liftdirection(2)*tmpd14
      liftdirectiond(2) = liftdirectiond(2) + funcvalues(costfuncforcey)&
&       *tmpd14
      funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + &
&       liftdirection(3)*tmpd14
      liftdirectiond(3) = liftdirectiond(3) + funcvalues(costfuncforcez)&
&       *tmpd14
      globalvalsd = 0.0_8
      momentd = 0.0_8
      cforced = 0.0_8
      forced = 0.0_8
      cforcemd = 0.0_8
      forcemd = 0.0_8
      cforcepd = 0.0_8
      forcepd = 0.0_8
      cforcevd = 0.0_8
      cmomentd = 0.0_8
      forcevd = 0.0_8
      do sps=1,ntimeintervalsspectral
! ------------
! ------------
! mass flow like objective
        mflow = globalvals(imassflow, sps)
        if (mflow .ne. zero) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
! area averaged objectives
        garea = globalvals(iarea, sps)
        if (garea .ne. zero) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        mavgvzd = ovrnts*funcvaluesd(costfuncmavgvz)
        mavgvyd = ovrnts*funcvaluesd(costfuncmavgvy)
        mavgvxd = ovrnts*funcvaluesd(costfuncmavgvx)
        mavgad = ovrnts*funcvaluesd(costfuncmavga)
        mavgmnd = ovrnts*funcvaluesd(costfuncmavgmn)
        mavgpsd = ovrnts*funcvaluesd(costfuncmavgps)
        mavgrhod = ovrnts*funcvaluesd(costfuncmavgrho)
        mavgttotd = ovrnts*funcvaluesd(costfuncmavgttot)
        mavgptotd = ovrnts*funcvaluesd(costfuncmavgptot)
        mflowd = ovrnts*funcvaluesd(costfuncmdot)
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          tempd1 = ovrnts*funcvaluesd(costfuncaavgptot)/garea
          tempd0 = ovrnts*funcvaluesd(costfuncaavgps)/garea
          globalvalsd(iareaps, sps) = globalvalsd(iareaps, sps) + tempd0
          garead = -(globalvals(iareaptot, sps)*tempd1/garea) - &
&           globalvals(iareaps, sps)*tempd0/garea
          globalvalsd(iareaptot, sps) = globalvalsd(iareaptot, sps) + &
&           tempd1
        else
          garead = 0.0_8
        end if
        globalvalsd(iarea, sps) = globalvalsd(iarea, sps) + garead
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          globalvalsd(imassvz, sps) = globalvalsd(imassvz, sps) + &
&           mavgvzd/mflow
          mflowd = mflowd - globalvals(imassvy, sps)*mavgvyd/mflow**2 - &
&           globalvals(imassa, sps)*mavgad/mflow**2 - globalvals(imassps&
&           , sps)*mavgpsd/mflow**2 - globalvals(imassttot, sps)*&
&           mavgttotd/mflow**2 - globalvals(imassptot, sps)*mavgptotd/&
&           mflow**2 - globalvals(imassrho, sps)*mavgrhod/mflow**2 - &
&           globalvals(imassmn, sps)*mavgmnd/mflow**2 - globalvals(&
&           imassvx, sps)*mavgvxd/mflow**2 - globalvals(imassvz, sps)*&
&           mavgvzd/mflow**2
          globalvalsd(imassvy, sps) = globalvalsd(imassvy, sps) + &
&           mavgvyd/mflow
          globalvalsd(imassvx, sps) = globalvalsd(imassvx, sps) + &
&           mavgvxd/mflow
          globalvalsd(imassa, sps) = globalvalsd(imassa, sps) + mavgad/&
&           mflow
          globalvalsd(imassmn, sps) = globalvalsd(imassmn, sps) + &
&           mavgmnd/mflow
          globalvalsd(imassps, sps) = globalvalsd(imassps, sps) + &
&           mavgpsd/mflow
          globalvalsd(imassrho, sps) = globalvalsd(imassrho, sps) + &
&           mavgrhod/mflow
          globalvalsd(imassttot, sps) = globalvalsd(imassttot, sps) + &
&           mavgttotd/mflow
          globalvalsd(imassptot, sps) = globalvalsd(imassptot, sps) + &
&           mavgptotd/mflow
        end if
        globalvalsd(imassflow, sps) = globalvalsd(imassflow, sps) + &
&         mflowd
        globalvalsd(icperror2, sps) = globalvalsd(icperror2, sps) + &
&         ovrnts*funcvaluesd(costfunccperror2)
        globalvalsd(ipower, sps) = globalvalsd(ipower, sps) + ovrnts*&
&         funcvaluesd(costfuncflowpower)
        globalvalsd(iarea, sps) = globalvalsd(iarea, sps) + ovrnts*&
&         funcvaluesd(costfuncarea)
        globalvalsd(isepavg+2, sps) = globalvalsd(isepavg+2, sps) + &
&         ovrnts*funcvaluesd(costfuncsepsensoravgz)
        globalvalsd(isepavg+1, sps) = globalvalsd(isepavg+1, sps) + &
&         ovrnts*funcvaluesd(costfuncsepsensoravgy)
        globalvalsd(isepavg, sps) = globalvalsd(isepavg, sps) + ovrnts*&
&         funcvaluesd(costfuncsepsensoravgx)
        globalvalsd(iaxismoment, sps) = globalvalsd(iaxismoment, sps) + &
&         ovrnts*funcvaluesd(costfuncaxismoment)
        globalvalsd(icavitation, sps) = globalvalsd(icavitation, sps) + &
&         ovrnts*funcvaluesd(costfunccavitation)
        globalvalsd(isepsensor, sps) = globalvalsd(isepsensor, sps) + &
&         ovrnts*funcvaluesd(costfuncsepsensor)
        cmomentd(3, sps) = cmomentd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncmomzcoef)
        cmomentd(2, sps) = cmomentd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncmomycoef)
        cmomentd(1, sps) = cmomentd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncmomxcoef)
        momentd(3, sps) = momentd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncmomz)
        momentd(2, sps) = momentd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncmomy)
        momentd(1, sps) = momentd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncmomx)
        cforcemd(3, sps) = cforcemd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcezcoefmomentum)
        cforcemd(2, sps) = cforcemd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforceycoefmomentum)
        cforcemd(1, sps) = cforcemd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcexcoefmomentum)
        cforcevd(3, sps) = cforcevd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcezcoefviscous)
        cforcevd(2, sps) = cforcevd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforceycoefviscous)
        cforcevd(1, sps) = cforcevd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcexcoefviscous)
        cforcepd(3, sps) = cforcepd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcezcoefpressure)
        cforcepd(2, sps) = cforcepd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforceycoefpressure)
        cforcepd(1, sps) = cforcepd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcexcoefpressure)
        cforced(3, sps) = cforced(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcezcoef)
        cforced(2, sps) = cforced(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforceycoef)
        cforced(1, sps) = cforced(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcexcoef)
        forcemd(3, sps) = forcemd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcezmomentum)
        forcemd(2, sps) = forcemd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforceymomentum)
        forcemd(1, sps) = forcemd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcexmomentum)
        forcevd(3, sps) = forcevd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcezviscous)
        forcevd(2, sps) = forcevd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforceyviscous)
        forcevd(1, sps) = forcevd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcexviscous)
        forcepd(3, sps) = forcepd(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcezpressure)
        forcepd(2, sps) = forcepd(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforceypressure)
        forcepd(1, sps) = forcepd(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcexpressure)
        forced(3, sps) = forced(3, sps) + ovrnts*funcvaluesd(&
&         costfuncforcez)
        forced(2, sps) = forced(2, sps) + ovrnts*funcvaluesd(&
&         costfuncforcey)
        forced(1, sps) = forced(1, sps) + ovrnts*funcvaluesd(&
&         costfuncforcex)
      end do
      factd = sum(moment*cmomentd)
      momentd = momentd + fact*cmomentd
      call popreal8(fact)
      factd = sum(forcem*cforcemd) + sum(forcep*cforcepd) + sum(force*&
&       cforced) + sum(forcev*cforcevd) + factd/(lengthref*lref)
      forcemd = forcemd + fact*cforcemd
      forcevd = forcevd + fact*cforcevd
      forcepd = forcepd + fact*cforcepd
      forced = forced + fact*cforced
      temp0 = gammainf*surfaceref*lref**2
      temp = temp0*machcoef**2*pref
      tempd = -(two*temp0*factd/temp**2)
      machcoefd = machcoefd + pref*2*machcoef*tempd
      prefd = prefd + machcoef**2*tempd
      globalvalsd(imp:imp+2, :) = globalvalsd(imp:imp+2, :) + momentd
      globalvalsd(imv:imv+2, :) = globalvalsd(imv:imv+2, :) + momentd
      globalvalsd(iflowmm:iflowmm+2, :) = globalvalsd(iflowmm:iflowmm+2&
&       , :) + momentd
      globalvalsd(iflowfm:iflowfm+2, :) = globalvalsd(iflowfm:iflowfm+2&
&       , :) + forcemd
      globalvalsd(ifv:ifv+2, :) = globalvalsd(ifv:ifv+2, :) + forcevd
      globalvalsd(ifp:ifp+2, :) = globalvalsd(ifp:ifp+2, :) + forced + &
&       forcepd
      globalvalsd(ifv:ifv+2, :) = globalvalsd(ifv:ifv+2, :) + forced
      globalvalsd(iflowfm:iflowfm+2, :) = globalvalsd(iflowfm:iflowfm+2&
&       , :) + forced
      funcvaluesd = 0.0_8
    end if
  end subroutine getcostfunctions_b
  subroutine getcostfunctions(globalvals, funcvalues)
    use constants
    use inputtimespectral, only : ntimeintervalsspectral
    use flowvarrefstate, only : pref, rhoref, tref, lref, gammainf, &
&   pinf, uref, uinf
    use inputphysics, only : liftdirection, dragdirection, surfaceref,&
&   machcoef, lengthref, alpha, beta, liftindex
    use inputtsstabderiv, only : tsstability
    use utils_b, only : computetsderivatives
    use flowutils_b, only : getdirvector
    implicit none
! input/output
    real(kind=realtype), dimension(:, :), intent(in) :: globalvals
    real(kind=realtype), dimension(:), intent(out) :: funcvalues
! working
    real(kind=realtype) :: fact, factmoment, ovrnts
    real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
&   forcep, forcev, forcem, moment, cforce, cforcep, cforcev, cforcem, &
&   cmoment
    real(kind=realtype), dimension(3) :: vcoordref, vfreestreamref
    real(kind=realtype) :: mavgptot, mavgttot, mavgrho, mavgps, mflow, &
&   mavgmn, mavga, mavgvx, mavgvy, mavgvz, garea
    real(kind=realtype) :: vdotn, mag, u, v, w
    integer(kind=inttype) :: sps
    real(kind=realtype), dimension(8) :: dcdq, dcdqdot
    real(kind=realtype), dimension(8) :: dcdalpha, dcdalphadot
    real(kind=realtype), dimension(8) :: coef0
    intrinsic sqrt
! factor used for time-averaged quantities.
    ovrnts = one/ntimeintervalsspectral
! sum pressure and viscous contributions
    force = globalvals(ifp:ifp+2, :) + globalvals(ifv:ifv+2, :) + &
&     globalvals(iflowfm:iflowfm+2, :)
    forcep = globalvals(ifp:ifp+2, :)
    forcev = globalvals(ifv:ifv+2, :)
    forcem = globalvals(iflowfm:iflowfm+2, :)
    moment = globalvals(imp:imp+2, :) + globalvals(imv:imv+2, :) + &
&     globalvals(iflowmm:iflowmm+2, :)
    fact = two/(gammainf*machcoef*machcoef*surfaceref*lref*lref*pref)
    cforce = fact*force
    cforcep = fact*forcep
    cforcev = fact*forcev
    cforcem = fact*forcem
! moment factor has an extra lengthref
    fact = fact/(lengthref*lref)
    cmoment = fact*moment
! zero values since we are summing.
    funcvalues = zero
! here we finally assign the final function values
    do sps=1,ntimeintervalsspectral
      funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
&       force(1, sps)
      funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
&       force(2, sps)
      funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
&       force(3, sps)
      funcvalues(costfuncforcexpressure) = funcvalues(&
&       costfuncforcexpressure) + ovrnts*forcep(1, sps)
      funcvalues(costfuncforceypressure) = funcvalues(&
&       costfuncforceypressure) + ovrnts*forcep(2, sps)
      funcvalues(costfuncforcezpressure) = funcvalues(&
&       costfuncforcezpressure) + ovrnts*forcep(3, sps)
      funcvalues(costfuncforcexviscous) = funcvalues(&
&       costfuncforcexviscous) + ovrnts*forcev(1, sps)
      funcvalues(costfuncforceyviscous) = funcvalues(&
&       costfuncforceyviscous) + ovrnts*forcev(2, sps)
      funcvalues(costfuncforcezviscous) = funcvalues(&
&       costfuncforcezviscous) + ovrnts*forcev(3, sps)
      funcvalues(costfuncforcexmomentum) = funcvalues(&
&       costfuncforcexmomentum) + ovrnts*forcem(1, sps)
      funcvalues(costfuncforceymomentum) = funcvalues(&
&       costfuncforceymomentum) + ovrnts*forcem(2, sps)
      funcvalues(costfuncforcezmomentum) = funcvalues(&
&       costfuncforcezmomentum) + ovrnts*forcem(3, sps)
! ------------
      funcvalues(costfuncforcexcoef) = funcvalues(costfuncforcexcoef) + &
&       ovrnts*cforce(1, sps)
      funcvalues(costfuncforceycoef) = funcvalues(costfuncforceycoef) + &
&       ovrnts*cforce(2, sps)
      funcvalues(costfuncforcezcoef) = funcvalues(costfuncforcezcoef) + &
&       ovrnts*cforce(3, sps)
      funcvalues(costfuncforcexcoefpressure) = funcvalues(&
&       costfuncforcexcoefpressure) + ovrnts*cforcep(1, sps)
      funcvalues(costfuncforceycoefpressure) = funcvalues(&
&       costfuncforceycoefpressure) + ovrnts*cforcep(2, sps)
      funcvalues(costfuncforcezcoefpressure) = funcvalues(&
&       costfuncforcezcoefpressure) + ovrnts*cforcep(3, sps)
      funcvalues(costfuncforcexcoefviscous) = funcvalues(&
&       costfuncforcexcoefviscous) + ovrnts*cforcev(1, sps)
      funcvalues(costfuncforceycoefviscous) = funcvalues(&
&       costfuncforceycoefviscous) + ovrnts*cforcev(2, sps)
      funcvalues(costfuncforcezcoefviscous) = funcvalues(&
&       costfuncforcezcoefviscous) + ovrnts*cforcev(3, sps)
      funcvalues(costfuncforcexcoefmomentum) = funcvalues(&
&       costfuncforcexcoefmomentum) + ovrnts*cforcem(1, sps)
      funcvalues(costfuncforceycoefmomentum) = funcvalues(&
&       costfuncforceycoefmomentum) + ovrnts*cforcem(2, sps)
      funcvalues(costfuncforcezcoefmomentum) = funcvalues(&
&       costfuncforcezcoefmomentum) + ovrnts*cforcem(3, sps)
! ------------
      funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*&
&       moment(1, sps)
      funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*&
&       moment(2, sps)
      funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*&
&       moment(3, sps)
      funcvalues(costfuncmomxcoef) = funcvalues(costfuncmomxcoef) + &
&       ovrnts*cmoment(1, sps)
      funcvalues(costfuncmomycoef) = funcvalues(costfuncmomycoef) + &
&       ovrnts*cmoment(2, sps)
      funcvalues(costfuncmomzcoef) = funcvalues(costfuncmomzcoef) + &
&       ovrnts*cmoment(3, sps)
      funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
&       ovrnts*globalvals(isepsensor, sps)
      funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
&       ovrnts*globalvals(icavitation, sps)
      funcvalues(costfuncaxismoment) = funcvalues(costfuncaxismoment) + &
&       ovrnts*globalvals(iaxismoment, sps)
      funcvalues(costfuncsepsensoravgx) = funcvalues(&
&       costfuncsepsensoravgx) + ovrnts*globalvals(isepavg, sps)
      funcvalues(costfuncsepsensoravgy) = funcvalues(&
&       costfuncsepsensoravgy) + ovrnts*globalvals(isepavg+1, sps)
      funcvalues(costfuncsepsensoravgz) = funcvalues(&
&       costfuncsepsensoravgz) + ovrnts*globalvals(isepavg+2, sps)
      funcvalues(costfuncarea) = funcvalues(costfuncarea) + ovrnts*&
&       globalvals(iarea, sps)
      funcvalues(costfuncflowpower) = funcvalues(costfuncflowpower) + &
&       ovrnts*globalvals(ipower, sps)
      funcvalues(costfunccperror2) = funcvalues(costfunccperror2) + &
&       ovrnts*globalvals(icperror2, sps)
! mass flow like objective
      mflow = globalvals(imassflow, sps)
      if (mflow .ne. zero) then
        mavgptot = globalvals(imassptot, sps)/mflow
        mavgttot = globalvals(imassttot, sps)/mflow
        mavgrho = globalvals(imassrho, sps)/mflow
        mavgps = globalvals(imassps, sps)/mflow
        mavgmn = globalvals(imassmn, sps)/mflow
        mavga = globalvals(imassa, sps)/mflow
        mavgvx = globalvals(imassvx, sps)/mflow
        mavgvy = globalvals(imassvy, sps)/mflow
        mavgvz = globalvals(imassvz, sps)/mflow
        mag = sqrt(globalvals(imassnx, sps)**2 + globalvals(imassny, sps&
&         )**2 + globalvals(imassnz, sps)**2)
      else
        mavgptot = zero
        mavgttot = zero
        mavgrho = zero
        mavgps = zero
        mavgmn = zero
        mavga = zero
        mavgvx = zero
        mavgvy = zero
        mavgvz = zero
      end if
! area averaged objectives
      garea = globalvals(iarea, sps)
      if (garea .ne. zero) then
! area averaged pressure
        funcvalues(costfuncaavgptot) = funcvalues(costfuncaavgptot) + &
&         ovrnts*globalvals(iareaptot, sps)/garea
        funcvalues(costfuncaavgps) = funcvalues(costfuncaavgps) + ovrnts&
&         *globalvals(iareaps, sps)/garea
      end if
      funcvalues(costfuncmdot) = funcvalues(costfuncmdot) + ovrnts*mflow
      funcvalues(costfuncmavgptot) = funcvalues(costfuncmavgptot) + &
&       ovrnts*mavgptot
      funcvalues(costfuncmavgttot) = funcvalues(costfuncmavgttot) + &
&       ovrnts*mavgttot
      funcvalues(costfuncmavgrho) = funcvalues(costfuncmavgrho) + ovrnts&
&       *mavgrho
      funcvalues(costfuncmavgps) = funcvalues(costfuncmavgps) + ovrnts*&
&       mavgps
      funcvalues(costfuncmavgmn) = funcvalues(costfuncmavgmn) + ovrnts*&
&       mavgmn
      funcvalues(costfuncmavga) = funcvalues(costfuncmavga) + ovrnts*&
&       mavga
      funcvalues(costfuncmavgvx) = funcvalues(costfuncmavgvx) + ovrnts*&
&       mavgvx
      funcvalues(costfuncmavgvy) = funcvalues(costfuncmavgvy) + ovrnts*&
&       mavgvy
      funcvalues(costfuncmavgvz) = funcvalues(costfuncmavgvz) + ovrnts*&
&       mavgvz
    end do
! bending moment calc - also broken.
! call computerootbendingmoment(cforce, cmoment, liftindex, bendingmoment)
! funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) + ovrnts*bendingmoment
! lift and drag (coefficients): dot product with the lift/drag direction.
    funcvalues(costfunclift) = funcvalues(costfuncforcex)*liftdirection(&
&     1) + funcvalues(costfuncforcey)*liftdirection(2) + funcvalues(&
&     costfuncforcez)*liftdirection(3)
    funcvalues(costfuncliftpressure) = funcvalues(costfuncforcexpressure&
&     )*liftdirection(1) + funcvalues(costfuncforceypressure)*&
&     liftdirection(2) + funcvalues(costfuncforcezpressure)*&
&     liftdirection(3)
    funcvalues(costfuncliftviscous) = funcvalues(costfuncforcexviscous)*&
&     liftdirection(1) + funcvalues(costfuncforceyviscous)*liftdirection&
&     (2) + funcvalues(costfuncforcezviscous)*liftdirection(3)
    funcvalues(costfuncliftmomentum) = funcvalues(costfuncforcexmomentum&
&     )*liftdirection(1) + funcvalues(costfuncforceymomentum)*&
&     liftdirection(2) + funcvalues(costfuncforcezmomentum)*&
&     liftdirection(3)
!-----
    funcvalues(costfuncdrag) = funcvalues(costfuncforcex)*dragdirection(&
&     1) + funcvalues(costfuncforcey)*dragdirection(2) + funcvalues(&
&     costfuncforcez)*dragdirection(3)
    funcvalues(costfuncdragpressure) = funcvalues(costfuncforcexpressure&
&     )*dragdirection(1) + funcvalues(costfuncforceypressure)*&
&     dragdirection(2) + funcvalues(costfuncforcezpressure)*&
&     dragdirection(3)
    funcvalues(costfuncdragviscous) = funcvalues(costfuncforcexviscous)*&
&     dragdirection(1) + funcvalues(costfuncforceyviscous)*dragdirection&
&     (2) + funcvalues(costfuncforcezviscous)*dragdirection(3)
    funcvalues(costfuncdragmomentum) = funcvalues(costfuncforcexmomentum&
&     )*dragdirection(1) + funcvalues(costfuncforceymomentum)*&
&     dragdirection(2) + funcvalues(costfuncforcezmomentum)*&
&     dragdirection(3)
!-----
    funcvalues(costfuncliftcoef) = funcvalues(costfuncforcexcoef)*&
&     liftdirection(1) + funcvalues(costfuncforceycoef)*liftdirection(2)&
&     + funcvalues(costfuncforcezcoef)*liftdirection(3)
    funcvalues(costfuncliftcoefpressure) = funcvalues(&
&     costfuncforcexcoefpressure)*liftdirection(1) + funcvalues(&
&     costfuncforceycoefpressure)*liftdirection(2) + funcvalues(&
&     costfuncforcezcoefpressure)*liftdirection(3)
    funcvalues(costfuncliftcoefviscous) = funcvalues(&
&     costfuncforcexcoefviscous)*liftdirection(1) + funcvalues(&
&     costfuncforceycoefviscous)*liftdirection(2) + funcvalues(&
&     costfuncforcezcoefviscous)*liftdirection(3)
    funcvalues(costfuncliftcoefmomentum) = funcvalues(&
&     costfuncforcexcoefmomentum)*liftdirection(1) + funcvalues(&
&     costfuncforceycoefmomentum)*liftdirection(2) + funcvalues(&
&     costfuncforcezcoefmomentum)*liftdirection(3)
!-----
    funcvalues(costfuncdragcoef) = funcvalues(costfuncforcexcoef)*&
&     dragdirection(1) + funcvalues(costfuncforceycoef)*dragdirection(2)&
&     + funcvalues(costfuncforcezcoef)*dragdirection(3)
    funcvalues(costfuncdragcoefpressure) = funcvalues(&
&     costfuncforcexcoefpressure)*dragdirection(1) + funcvalues(&
&     costfuncforceycoefpressure)*dragdirection(2) + funcvalues(&
&     costfuncforcezcoefpressure)*dragdirection(3)
    funcvalues(costfuncdragcoefviscous) = funcvalues(&
&     costfuncforcexcoefviscous)*dragdirection(1) + funcvalues(&
&     costfuncforceycoefviscous)*dragdirection(2) + funcvalues(&
&     costfuncforcezcoefviscous)*dragdirection(3)
    funcvalues(costfuncdragcoefmomentum) = funcvalues(&
&     costfuncforcexcoefmomentum)*dragdirection(1) + funcvalues(&
&     costfuncforceycoefmomentum)*dragdirection(2) + funcvalues(&
&     costfuncforcezcoefmomentum)*dragdirection(3)
! -------------------- time spectral objectives ------------------
    if (tsstability) then
      print*, &
&     'error: tsstabilityderivatives are *broken*. they need to be ', &
&     'completely verifed from scratch'
      stop
    end if
  end subroutine getcostfunctions
!  differentiation of wallintegrationface in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: veldirfreestream machcoef pointref
!                pinf pref *xx *pp1 *pp2 *ssi *ww2 *(*viscsubface.tau)
!                *(*bcdata.fv) *(*bcdata.fp) *(*bcdata.area) localvalues
!   with respect to varying inputs: veldirfreestream machcoef pointref
!                pinf pref *xx *pp1 *pp2 *ssi *ww2 *(*viscsubface.tau)
!                *(*bcdata.fv) *(*bcdata.fp) *(*bcdata.area) localvalues
!   rw status of diff variables: veldirfreestream:incr machcoef:incr
!                pointref:incr pinf:incr pref:incr *xx:incr *pp1:incr
!                *pp2:incr *ssi:incr *ww2:incr *(*viscsubface.tau):incr
!                *(*bcdata.fv):in-out *(*bcdata.fp):in-out *(*bcdata.area):in-out
!                localvalues:in-out
!   plus diff mem management of: xx:in pp1:in pp2:in ssi:in ww2:in
!                viscsubface:in *viscsubface.tau:in bcdata:in *bcdata.fv:in
!                *bcdata.fp:in *bcdata.area:in
  subroutine wallintegrationface_b(localvalues, localvaluesd, mm)
!
!       wallintegrations computes the contribution of the block
!       given by the pointers in blockpointers to the force and
!       moment of the geometry. a distinction is made
!       between the inviscid and viscous parts. in case the maximum
!       yplus value must be monitored (only possible for rans), this
!       value is also computed. the separation sensor and the cavita-
!       tion sensor is also computed
!       here.
!
    use constants
    use communication
    use blockpointers
    use flowvarrefstate
    use inputcostfunctions
    use inputphysics, only : machcoef, machcoefd, pointref, pointrefd,&
&   veldirfreestream, veldirfreestreamd, equations, momentaxis, cavitationnumber
    use bcpointers_b
    implicit none
! input/output variables
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvaluesd
    integer(kind=inttype) :: mm
! local variables.
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype), dimension(3) :: fpd, fvd, mpd, mvd
    real(kind=realtype) :: yplusmax, sepsensor, sepsensoravg(3), &
&   cavitation
    real(kind=realtype) :: sepsensord, sepsensoravgd(3), cavitationd
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn
    real(kind=realtype) :: pm1d, fxd, fyd, fzd
    real(kind=realtype) :: xc, yc, zc, qf(3), r(3), n(3), l
    real(kind=realtype) :: xcd, ycd, zcd, rd(3)
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: v(3), sensor, sensor1, cp, tmp, plocal
    real(kind=realtype) :: vd(3), sensord, sensor1d, cpd, tmpd, plocald
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxxd, tauyyd, tauzzd
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxyd, tauxzd, tauyzd
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype), dimension(3) :: refpointd
    real(kind=realtype), dimension(3, 2) :: axispoints
    real(kind=realtype) :: mx, my, mz, cellarea, m0x, m0y, m0z, mvaxis, &
&   mpaxis
    real(kind=realtype) :: mxd, myd, mzd, cellaread, m0xd, m0yd, m0zd, &
&   mvaxisd, mpaxisd
    real(kind=realtype) :: cperror, cperror2
    real(kind=realtype) :: cperrord, cperror2d
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
    real(kind=realtype), dimension(3) :: tmp0
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8(3)
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tmpd0(3)
    real(kind=realtype) :: tempd24
    real(kind=realtype) :: tempd23
    real(kind=realtype) :: tempd22
    real(kind=realtype) :: tempd21
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: temp6
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: temp5
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: temp4
    real(kind=realtype) :: tempd15
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = -one
    case (imax, jmax, kmax) 
      fact = one
    end select
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! determine the points defining the axis about which to compute a moment
    axispoints(1, 1) = lref*momentaxis(1, 1)
    axispoints(1, 2) = lref*momentaxis(1, 2)
    axispoints(2, 1) = lref*momentaxis(2, 1)
    axispoints(2, 2) = lref*momentaxis(2, 2)
    axispoints(3, 1) = lref*momentaxis(3, 1)
    axispoints(3, 2) = lref*momentaxis(3, 2)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
    call pushreal8array(n, 3)
    call pushreal8array(r, 3)
    call pushreal8array(v, 3)
!
!         integrate the inviscid contribution over the solid walls,
!         either inviscid or viscous. the integration is done with
!         cp. for closed contours this is equal to the integration
!         of p; for open contours this is not the case anymore.
!         question is whether a force for an open contour is
!         meaningful anyway.
!
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
      pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
      tmp = two/(gammainf*pinf*machcoef*machcoef)
      cp = (half*(pp2(i, j)+pp1(i, j))-pinf)*tmp
      cperror = cp - bcdata(mm)%cptarget(i, j)
      cperror2 = cperror2 + cperror*cperror
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      fx = pm1*ssi(i, j, 1)
      fy = pm1*ssi(i, j, 2)
      fz = pm1*ssi(i, j, 3)
! update the inviscid force and moment coefficients. iblank as we sum
      fp(1) = fp(1) + fx*blk
      fp(2) = fp(2) + fy*blk
      fp(3) = fp(3) + fz*blk
      mx = yc*fz - zc*fy
      my = zc*fx - xc*fz
      mz = xc*fy - yc*fx
      mp(1) = mp(1) + mx*blk
      mp(2) = mp(2) + my*blk
      mp(3) = mp(3) + mz*blk
! compute the r and n vectores for the moment around an
! axis computation where r is the distance from the
! force to the first point on the axis and n is a unit
! normal in the direction of the axis
      r(1) = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&       , 1)) - axispoints(1, 1)
      r(2) = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&       , 2)) - axispoints(2, 1)
      r(3) = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&       , 3)) - axispoints(3, 1)
      l = sqrt((axispoints(1, 2)-axispoints(1, 1))**2 + (axispoints(2, 2&
&       )-axispoints(2, 1))**2 + (axispoints(3, 2)-axispoints(3, 1))**2)
      n(1) = (axispoints(1, 2)-axispoints(1, 1))/l
      n(2) = (axispoints(2, 2)-axispoints(2, 1))/l
      n(3) = (axispoints(3, 2)-axispoints(3, 1))/l
! compute the moment of the force about the first point
! used to define the axis, and the project that axis in
! the n direction
      m0x = r(2)*fz - r(3)*fy
      m0y = r(3)*fx - r(1)*fz
      m0z = r(1)*fy - r(2)*fx
      mpaxis = mpaxis + (m0x*n(1)+m0y*n(2)+m0z*n(3))*blk
! save the face-based forces and area
      bcdata(mm)%fp(i, j, 1) = fx
      bcdata(mm)%fp(i, j, 2) = fy
      bcdata(mm)%fp(i, j, 3) = fz
      cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**&
&       2)
      bcdata(mm)%area(i, j) = cellarea
! get normalized surface velocity:
      v(1) = ww2(i, j, ivx)
      v(2) = ww2(i, j, ivy)
      v(3) = ww2(i, j, ivz)
      v = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
! dot product with free stream
      sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v(3)*&
&       veldirfreestream(3))
!now run through a smooth heaviside function:
      sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&       sepsensoroffset))))
! and integrate over the area of this cell and save, blanking as we go.
      sensor = sensor*cellarea*blk
      sepsensor = sepsensor + sensor
! also accumulate into the sepsensoravg
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1))
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2))
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3))
      sepsensoravg(1) = sepsensoravg(1) + sensor*xc
      sepsensoravg(2) = sepsensoravg(2) + sensor*yc
      sepsensoravg(3) = sepsensoravg(3) + sensor*zc
      if (computecavitation) then
        plocal = pp2(i, j)
        tmp = two/(gammainf*machcoef*machcoef)
        cp = tmp*(plocal-pinf)
        sensor1 = -cp - cavitationnumber
        sensor1 = one/(one+exp(-(2*10*sensor1)))
        sensor1 = sensor1*cellarea*blk
        cavitation = cavitation + sensor1
      end if
    end do
!
! integration of the viscous forces.
! only for viscous boundaries.
!
    if (bctype(mm) .eq. nswalladiabatic .or. bctype(mm) .eq. &
&       nswallisothermal) then
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8array(n, 3)
      call pushreal8array(r, 3)
      call pushreal8(xc)
      call pushinteger4(blk)
      call pushreal8(yc)
      call pushreal8(zc)
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    cperror2d = localvaluesd(icperror2)
    mpaxisd = localvaluesd(iaxismoment)
    mvaxisd = localvaluesd(iaxismoment)
    sepsensoravgd = 0.0_8
    sepsensoravgd = localvaluesd(isepavg:isepavg+2)
    cavitationd = localvaluesd(icavitation)
    sepsensord = localvaluesd(isepsensor)
    mvd = 0.0_8
    mvd = localvaluesd(imv:imv+2)
    mpd = 0.0_8
    mpd = localvaluesd(imp:imp+2)
    fvd = 0.0_8
    fvd = localvaluesd(ifv:ifv+2)
    fpd = 0.0_8
    fpd = localvaluesd(ifp:ifp+2)
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      rd = 0.0_8
      refpointd = 0.0_8
      do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-&
&         bcdata(mm)%inbeg)-1
        i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&         inbeg + 1
        j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + &
&         1
        if (bcdata(mm)%iblank(i, j) .lt. 0) then
          blk = 0
        else
          blk = bcdata(mm)%iblank(i, j)
        end if
        tauxx = viscsubface(mm)%tau(i, j, 1)
        tauyy = viscsubface(mm)%tau(i, j, 2)
        tauzz = viscsubface(mm)%tau(i, j, 3)
        tauxy = viscsubface(mm)%tau(i, j, 4)
        tauxz = viscsubface(mm)%tau(i, j, 5)
        tauyz = viscsubface(mm)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
        fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*ssi(i, &
&         j, 3))*pref)
        fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*ssi(i, &
&         j, 3))*pref)
        fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*ssi(i, &
&         j, 3))*pref)
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
        xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&         , 1)) - refpoint(1)
        yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&         , 2)) - refpoint(2)
        zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&         , 3)) - refpoint(3)
! update the viscous force and moment coefficients, blanking as we go.
! compute the r and n vectors for the moment around an
! axis computation where r is the distance from the
! force to the first point on the axis and n is a unit
! normal in the direction of the axis
        r(1) = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j&
&         +1, 1)) - axispoints(1, 1)
        r(2) = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j&
&         +1, 2)) - axispoints(2, 1)
        r(3) = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j&
&         +1, 3)) - axispoints(3, 1)
        l = sqrt((axispoints(1, 2)-axispoints(1, 1))**2 + (axispoints(2&
&         , 2)-axispoints(2, 1))**2 + (axispoints(3, 2)-axispoints(3, 1)&
&         )**2)
        n(1) = (axispoints(1, 2)-axispoints(1, 1))/l
        n(2) = (axispoints(2, 2)-axispoints(2, 1))/l
        n(3) = (axispoints(3, 2)-axispoints(3, 1))/l
! compute the moment of the force about the first point
! used to define the axis, and then project that axis in
! the n direction
! save the face based forces for the slice operations
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
        mxd = blk*mvd(1)
        myd = blk*mvd(2)
        mzd = blk*mvd(3)
        tempd15 = blk*mvaxisd
        m0xd = n(1)*tempd15
        m0yd = n(2)*tempd15
        m0zd = n(3)*tempd15
        fzd = blk*fvd(3) - xc*myd - r(1)*m0yd + yc*mxd + r(2)*m0xd + &
&         bcdatad(mm)%fv(i, j, 3)
        bcdatad(mm)%fv(i, j, 3) = 0.0_8
        fyd = r(1)*m0zd + xc*mzd + blk*fvd(2) - zc*mxd - r(3)*m0xd + &
&         bcdatad(mm)%fv(i, j, 2)
        bcdatad(mm)%fv(i, j, 2) = 0.0_8
        fxd = blk*fvd(1) - yc*mzd - r(2)*m0zd + zc*myd + r(3)*m0yd + &
&         bcdatad(mm)%fv(i, j, 1)
        bcdatad(mm)%fv(i, j, 1) = 0.0_8
        rd(1) = rd(1) + fy*m0zd
        rd(2) = rd(2) - fx*m0zd
        rd(3) = rd(3) + fx*m0yd
        rd(1) = rd(1) - fz*m0yd
        rd(2) = rd(2) + fz*m0xd
        rd(3) = rd(3) - fy*m0xd
        tempd16 = fourth*rd(3)
        xxd(i, j, 3) = xxd(i, j, 3) + tempd16
        xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd16
        xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd16
        xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd16
        rd(3) = 0.0_8
        tempd17 = fourth*rd(2)
        xxd(i, j, 2) = xxd(i, j, 2) + tempd17
        xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd17
        xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd17
        xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd17
        rd(2) = 0.0_8
        tempd18 = fourth*rd(1)
        xxd(i, j, 1) = xxd(i, j, 1) + tempd18
        xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd18
        xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd18
        xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd18
        rd(1) = 0.0_8
        xcd = fy*mzd - fz*myd
        ycd = fz*mxd - fx*mzd
        zcd = fx*myd - fy*mxd
        tempd19 = fourth*zcd
        xxd(i, j, 3) = xxd(i, j, 3) + tempd19
        xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd19
        xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd19
        xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd19
        refpointd(3) = refpointd(3) - zcd
        tempd20 = fourth*ycd
        xxd(i, j, 2) = xxd(i, j, 2) + tempd20
        xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd20
        xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd20
        xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd20
        refpointd(2) = refpointd(2) - ycd
        tempd21 = fourth*xcd
        xxd(i, j, 1) = xxd(i, j, 1) + tempd21
        xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd21
        xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd21
        xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd21
        refpointd(1) = refpointd(1) - xcd
        tempd22 = -(fact*pref*fzd)
        ssid(i, j, 1) = ssid(i, j, 1) + tauxz*tempd22
        ssid(i, j, 2) = ssid(i, j, 2) + tauyz*tempd22
        tauzzd = ssi(i, j, 3)*tempd22
        ssid(i, j, 3) = ssid(i, j, 3) + tauzz*tempd22
        prefd = prefd - fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+&
&         tauzz*ssi(i, j, 3))*fzd
        tempd24 = -(fact*pref*fyd)
        tauyzd = ssi(i, j, 3)*tempd24 + ssi(i, j, 2)*tempd22
        ssid(i, j, 1) = ssid(i, j, 1) + tauxy*tempd24
        tauyyd = ssi(i, j, 2)*tempd24
        ssid(i, j, 2) = ssid(i, j, 2) + tauyy*tempd24
        ssid(i, j, 3) = ssid(i, j, 3) + tauyz*tempd24
        prefd = prefd - fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+&
&         tauyz*ssi(i, j, 3))*fyd
        tempd23 = -(fact*pref*fxd)
        tauxzd = ssi(i, j, 3)*tempd23 + ssi(i, j, 1)*tempd22
        tauxyd = ssi(i, j, 2)*tempd23 + ssi(i, j, 1)*tempd24
        tauxxd = ssi(i, j, 1)*tempd23
        ssid(i, j, 1) = ssid(i, j, 1) + tauxx*tempd23
        ssid(i, j, 2) = ssid(i, j, 2) + tauxy*tempd23
        ssid(i, j, 3) = ssid(i, j, 3) + tauxz*tempd23
        prefd = prefd - fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+&
&         tauxz*ssi(i, j, 3))*fxd
        viscsubfaced(mm)%tau(i, j, 6) = viscsubfaced(mm)%tau(i, j, 6) + &
&         tauyzd
        viscsubfaced(mm)%tau(i, j, 5) = viscsubfaced(mm)%tau(i, j, 5) + &
&         tauxzd
        viscsubfaced(mm)%tau(i, j, 4) = viscsubfaced(mm)%tau(i, j, 4) + &
&         tauxyd
        viscsubfaced(mm)%tau(i, j, 3) = viscsubfaced(mm)%tau(i, j, 3) + &
&         tauzzd
        viscsubfaced(mm)%tau(i, j, 2) = viscsubfaced(mm)%tau(i, j, 2) + &
&         tauyyd
        viscsubfaced(mm)%tau(i, j, 1) = viscsubfaced(mm)%tau(i, j, 1) + &
&         tauxxd
      end do
      call popreal8(zc)
      call popreal8(yc)
      call popinteger4(blk)
      call popreal8(xc)
      call popreal8array(r, 3)
      call popreal8array(n, 3)
      call popinteger4(j)
      call popinteger4(i)
    else
      bcdatad(mm)%fv = 0.0_8
      rd = 0.0_8
      refpointd = 0.0_8
    end if
    vd = 0.0_8
    call popreal8array(v, 3)
    call popreal8array(r, 3)
    call popreal8array(n, 3)
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
      pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
      tmp = two/(gammainf*pinf*machcoef*machcoef)
      cp = (half*(pp2(i, j)+pp1(i, j))-pinf)*tmp
      cperror = cp - bcdata(mm)%cptarget(i, j)
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      fx = pm1*ssi(i, j, 1)
      fy = pm1*ssi(i, j, 2)
      fz = pm1*ssi(i, j, 3)
! update the inviscid force and moment coefficients. iblank as we sum
! compute the r and n vectores for the moment around an
! axis computation where r is the distance from the
! force to the first point on the axis and n is a unit
! normal in the direction of the axis
      r(1) = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&       , 1)) - axispoints(1, 1)
      r(2) = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&       , 2)) - axispoints(2, 1)
      r(3) = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&       , 3)) - axispoints(3, 1)
      l = sqrt((axispoints(1, 2)-axispoints(1, 1))**2 + (axispoints(2, 2&
&       )-axispoints(2, 1))**2 + (axispoints(3, 2)-axispoints(3, 1))**2)
      n(1) = (axispoints(1, 2)-axispoints(1, 1))/l
      n(2) = (axispoints(2, 2)-axispoints(2, 1))/l
      n(3) = (axispoints(3, 2)-axispoints(3, 1))/l
! compute the moment of the force about the first point
! used to define the axis, and the project that axis in
! the n direction
! save the face-based forces and area
      cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**&
&       2)
! get normalized surface velocity:
      v(1) = ww2(i, j, ivx)
      v(2) = ww2(i, j, ivy)
      v(3) = ww2(i, j, ivz)
      tmp0 = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
      call pushreal8array(v, 3)
      v = tmp0
! dot product with free stream
      sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v(3)*&
&       veldirfreestream(3))
!now run through a smooth heaviside function:
      call pushreal8(sensor)
      sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&       sepsensoroffset))))
! and integrate over the area of this cell and save, blanking as we go.
      call pushreal8(sensor)
      sensor = sensor*cellarea*blk
! also accumulate into the sepsensoravg
      call pushreal8(xc)
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1))
      call pushreal8(yc)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2))
      call pushreal8(zc)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3))
      if (computecavitation) then
        plocal = pp2(i, j)
        tmp = two/(gammainf*machcoef*machcoef)
        cp = tmp*(plocal-pinf)
        sensor1 = -cp - cavitationnumber
        call pushreal8(sensor1)
        sensor1 = one/(one+exp(-(2*10*sensor1)))
        sensor1d = cavitationd
        cellaread = blk*sensor1*sensor1d
        sensor1d = blk*cellarea*sensor1d
        call popreal8(sensor1)
        temp6 = -(10*2*sensor1)
        temp5 = one + exp(temp6)
        sensor1d = exp(temp6)*one*10*2*sensor1d/temp5**2
        cpd = -sensor1d
        tmpd = (plocal-pinf)*cpd
        plocald = tmp*cpd
        pinfd = pinfd - tmp*cpd
        temp4 = gammainf*machcoef**2
        machcoefd = machcoefd - gammainf*two*2*machcoef*tmpd/temp4**2
        tmp = two/(gammainf*pinf*machcoef*machcoef)
        pp2d(i, j) = pp2d(i, j) + plocald
      else
        cellaread = 0.0_8
      end if
      mxd = blk*mpd(1)
      myd = blk*mpd(2)
      mzd = blk*mpd(3)
      tempd11 = blk*mpaxisd
      m0xd = n(1)*tempd11
      m0yd = n(2)*tempd11
      m0zd = n(3)*tempd11
      sensord = yc*sepsensoravgd(2) + sepsensord + xc*sepsensoravgd(1) +&
&       zc*sepsensoravgd(3)
      zcd = sensor*sepsensoravgd(3)
      ycd = sensor*sepsensoravgd(2)
      xcd = sensor*sepsensoravgd(1)
      call popreal8(zc)
      tempd5 = fourth*zcd
      xxd(i, j, 3) = xxd(i, j, 3) + tempd5
      xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd5
      xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd5
      xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd5
      call popreal8(yc)
      tempd6 = fourth*ycd
      xxd(i, j, 2) = xxd(i, j, 2) + tempd6
      xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd6
      xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd6
      xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd6
      call popreal8(xc)
      tempd7 = fourth*xcd
      xxd(i, j, 1) = xxd(i, j, 1) + tempd7
      xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd7
      xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd7
      xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd7
      call popreal8(sensor)
      cellaread = cellaread + blk*sensor*sensord
      sensord = blk*cellarea*sensord
      call popreal8(sensor)
      temp3 = -(2*sepsensorsharpness*(sensor-sepsensoroffset))
      temp2 = one + exp(temp3)
      sensord = exp(temp3)*one*sepsensorsharpness*2*sensord/temp2**2
      vd(1) = vd(1) - veldirfreestream(1)*sensord
      veldirfreestreamd(1) = veldirfreestreamd(1) - v(1)*sensord
      vd(2) = vd(2) - veldirfreestream(2)*sensord
      veldirfreestreamd(2) = veldirfreestreamd(2) - v(2)*sensord
      vd(3) = vd(3) - veldirfreestream(3)*sensord
      veldirfreestreamd(3) = veldirfreestreamd(3) - v(3)*sensord
      call popreal8array(v, 3)
      tmpd0 = vd
      temp0 = v(1)**2 + v(2)**2 + v(3)**2
      temp1 = sqrt(temp0)
      tempd8 = tmpd0/(temp1+1e-16)
      vd = tempd8
      if (temp0 .eq. 0.0_8) then
        tempd9 = 0.0
      else
        tempd9 = sum(-(v*tempd8/(temp1+1e-16)))/(2.0*temp1)
      end if
      vd(1) = vd(1) + 2*v(1)*tempd9
      vd(2) = vd(2) + 2*v(2)*tempd9
      vd(3) = vd(3) + 2*v(3)*tempd9
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + vd(3)
      vd(3) = 0.0_8
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + vd(2)
      vd(2) = 0.0_8
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + vd(1)
      vd(1) = 0.0_8
      cellaread = cellaread + bcdatad(mm)%area(i, j)
      bcdatad(mm)%area(i, j) = 0.0_8
      if (ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**2 .eq. 0.0_8&
&     ) then
        tempd10 = 0.0
      else
        tempd10 = cellaread/(2.0*sqrt(ssi(i, j, 1)**2+ssi(i, j, 2)**2+&
&         ssi(i, j, 3)**2))
      end if
      ssid(i, j, 1) = ssid(i, j, 1) + 2*ssi(i, j, 1)*tempd10
      ssid(i, j, 2) = ssid(i, j, 2) + 2*ssi(i, j, 2)*tempd10
      ssid(i, j, 3) = ssid(i, j, 3) + 2*ssi(i, j, 3)*tempd10
      fzd = blk*fpd(3) - xc*myd - r(1)*m0yd + yc*mxd + r(2)*m0xd + &
&       bcdatad(mm)%fp(i, j, 3)
      bcdatad(mm)%fp(i, j, 3) = 0.0_8
      fyd = r(1)*m0zd + xc*mzd + blk*fpd(2) - zc*mxd - r(3)*m0xd + &
&       bcdatad(mm)%fp(i, j, 2)
      bcdatad(mm)%fp(i, j, 2) = 0.0_8
      fxd = blk*fpd(1) - yc*mzd - r(2)*m0zd + zc*myd + r(3)*m0yd + &
&       bcdatad(mm)%fp(i, j, 1)
      bcdatad(mm)%fp(i, j, 1) = 0.0_8
      rd(1) = rd(1) + fy*m0zd
      rd(2) = rd(2) - fx*m0zd
      rd(3) = rd(3) + fx*m0yd
      rd(1) = rd(1) - fz*m0yd
      rd(2) = rd(2) + fz*m0xd
      rd(3) = rd(3) - fy*m0xd
      tempd12 = fourth*rd(3)
      xxd(i, j, 3) = xxd(i, j, 3) + tempd12
      xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd12
      xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd12
      xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd12
      rd(3) = 0.0_8
      tempd13 = fourth*rd(2)
      xxd(i, j, 2) = xxd(i, j, 2) + tempd13
      xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd13
      xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd13
      xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd13
      rd(2) = 0.0_8
      tempd14 = fourth*rd(1)
      xxd(i, j, 1) = xxd(i, j, 1) + tempd14
      xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd14
      xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd14
      xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd14
      rd(1) = 0.0_8
      xcd = fy*mzd - fz*myd
      ycd = fz*mxd - fx*mzd
      zcd = fx*myd - fy*mxd
      pm1d = ssi(i, j, 2)*fyd + ssi(i, j, 1)*fxd + ssi(i, j, 3)*fzd
      ssid(i, j, 3) = ssid(i, j, 3) + pm1*fzd
      ssid(i, j, 2) = ssid(i, j, 2) + pm1*fyd
      ssid(i, j, 1) = ssid(i, j, 1) + pm1*fxd
      tempd = fourth*zcd
      xxd(i, j, 3) = xxd(i, j, 3) + tempd
      xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd
      xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd
      xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd
      refpointd(3) = refpointd(3) - zcd
      tempd0 = fourth*ycd
      xxd(i, j, 2) = xxd(i, j, 2) + tempd0
      xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd0
      xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd0
      xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd0
      refpointd(2) = refpointd(2) - ycd
      tempd1 = fourth*xcd
      xxd(i, j, 1) = xxd(i, j, 1) + tempd1
      xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd1
      xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd1
      xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd1
      refpointd(1) = refpointd(1) - xcd
      cperrord = 2*cperror*cperror2d
      cpd = cperrord
      tempd2 = tmp*cpd
      pp2d(i, j) = pp2d(i, j) + half*tempd2
      pp1d(i, j) = pp1d(i, j) + half*tempd2
      tmpd = (half*(pp2(i, j)+pp1(i, j))-pinf)*cpd
      temp = gammainf*pinf*machcoef**2
      tempd3 = -(two*tmpd/temp**2)
      pinfd = pinfd + machcoef**2*gammainf*tempd3 - tempd2
      machcoefd = machcoefd + gammainf*pinf*2*machcoef*tempd3
      tempd4 = fact*pref*pm1d
      pp2d(i, j) = pp2d(i, j) + half*tempd4
      pp1d(i, j) = pp1d(i, j) + half*tempd4
      pinfd = pinfd - tempd4
      prefd = prefd + fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pm1d
    end do
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine wallintegrationface_b
  subroutine wallintegrationface(localvalues, mm)
!
!       wallintegrations computes the contribution of the block
!       given by the pointers in blockpointers to the force and
!       moment of the geometry. a distinction is made
!       between the inviscid and viscous parts. in case the maximum
!       yplus value must be monitored (only possible for rans), this
!       value is also computed. the separation sensor and the cavita-
!       tion sensor is also computed
!       here.
!
    use constants
    use communication
    use blockpointers
    use flowvarrefstate
    use inputcostfunctions
    use inputphysics, only : machcoef, pointref, veldirfreestream, &
&   equations, momentaxis, cavitationnumber
    use bcpointers_b
    implicit none
! input/output variables
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype) :: mm
! local variables.
    real(kind=realtype), dimension(3) :: fp, fv, mp, mv
    real(kind=realtype) :: yplusmax, sepsensor, sepsensoravg(3), &
&   cavitation
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: pm1, fx, fy, fz, fn
    real(kind=realtype) :: xc, yc, zc, qf(3), r(3), n(3), l
    real(kind=realtype) :: fact, rho, mul, yplus, dwall
    real(kind=realtype) :: v(3), sensor, sensor1, cp, tmp, plocal
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype), dimension(3) :: refpoint
    real(kind=realtype), dimension(3, 2) :: axispoints
    real(kind=realtype) :: mx, my, mz, cellarea, m0x, m0y, m0z, mvaxis, &
&   mpaxis
    real(kind=realtype) :: cperror, cperror2
    intrinsic mod
    intrinsic max
    intrinsic sqrt
    intrinsic exp
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = -one
    case (imax, jmax, kmax) 
      fact = one
    end select
! determine the reference point for the moment computation in
! meters.
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! determine the points defining the axis about which to compute a moment
    axispoints(1, 1) = lref*momentaxis(1, 1)
    axispoints(1, 2) = lref*momentaxis(1, 2)
    axispoints(2, 1) = lref*momentaxis(2, 1)
    axispoints(2, 2) = lref*momentaxis(2, 2)
    axispoints(3, 1) = lref*momentaxis(3, 1)
    axispoints(3, 2) = lref*momentaxis(3, 2)
! initialize the force and moment coefficients to 0 as well as
! yplusmax.
    fp = zero
    fv = zero
    mp = zero
    mv = zero
    yplusmax = zero
    sepsensor = zero
    cavitation = zero
    sepsensoravg = zero
    mpaxis = zero
    mvaxis = zero
    cperror2 = zero
!
!         integrate the inviscid contribution over the solid walls,
!         either inviscid or viscous. the integration is done with
!         cp. for closed contours this is equal to the integration
!         of p; for open contours this is not the case anymore.
!         question is whether a force for an open contour is
!         meaningful anyway.
!
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
! compute the average pressure minus 1 and the coordinates
! of the centroid of the face relative from from the
! moment reference point. due to the usage of pointers for
! the coordinates, whose original array starts at 0, an
! offset of 1 must be used. the pressure is multipled by
! fact to account for the possibility of an inward or
! outward pointing normal.
      pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*pref
      tmp = two/(gammainf*pinf*machcoef*machcoef)
      cp = (half*(pp2(i, j)+pp1(i, j))-pinf)*tmp
      cperror = cp - bcdata(mm)%cptarget(i, j)
      cperror2 = cperror2 + cperror*cperror
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      fx = pm1*ssi(i, j, 1)
      fy = pm1*ssi(i, j, 2)
      fz = pm1*ssi(i, j, 3)
! update the inviscid force and moment coefficients. iblank as we sum
      fp(1) = fp(1) + fx*blk
      fp(2) = fp(2) + fy*blk
      fp(3) = fp(3) + fz*blk
      mx = yc*fz - zc*fy
      my = zc*fx - xc*fz
      mz = xc*fy - yc*fx
      mp(1) = mp(1) + mx*blk
      mp(2) = mp(2) + my*blk
      mp(3) = mp(3) + mz*blk
! compute the r and n vectores for the moment around an
! axis computation where r is the distance from the
! force to the first point on the axis and n is a unit
! normal in the direction of the axis
      r(1) = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&       , 1)) - axispoints(1, 1)
      r(2) = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&       , 2)) - axispoints(2, 1)
      r(3) = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&       , 3)) - axispoints(3, 1)
      l = sqrt((axispoints(1, 2)-axispoints(1, 1))**2 + (axispoints(2, 2&
&       )-axispoints(2, 1))**2 + (axispoints(3, 2)-axispoints(3, 1))**2)
      n(1) = (axispoints(1, 2)-axispoints(1, 1))/l
      n(2) = (axispoints(2, 2)-axispoints(2, 1))/l
      n(3) = (axispoints(3, 2)-axispoints(3, 1))/l
! compute the moment of the force about the first point
! used to define the axis, and the project that axis in
! the n direction
      m0x = r(2)*fz - r(3)*fy
      m0y = r(3)*fx - r(1)*fz
      m0z = r(1)*fy - r(2)*fx
      mpaxis = mpaxis + (m0x*n(1)+m0y*n(2)+m0z*n(3))*blk
! save the face-based forces and area
      bcdata(mm)%fp(i, j, 1) = fx
      bcdata(mm)%fp(i, j, 2) = fy
      bcdata(mm)%fp(i, j, 3) = fz
      cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**&
&       2)
      bcdata(mm)%area(i, j) = cellarea
! get normalized surface velocity:
      v(1) = ww2(i, j, ivx)
      v(2) = ww2(i, j, ivy)
      v(3) = ww2(i, j, ivz)
      v = v/(sqrt(v(1)**2+v(2)**2+v(3)**2)+1e-16)
! dot product with free stream
      sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v(3)*&
&       veldirfreestream(3))
!now run through a smooth heaviside function:
      sensor = one/(one+exp(-(2*sepsensorsharpness*(sensor-&
&       sepsensoroffset))))
! and integrate over the area of this cell and save, blanking as we go.
      sensor = sensor*cellarea*blk
      sepsensor = sepsensor + sensor
! also accumulate into the sepsensoravg
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1))
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2))
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3))
      sepsensoravg(1) = sepsensoravg(1) + sensor*xc
      sepsensoravg(2) = sepsensoravg(2) + sensor*yc
      sepsensoravg(3) = sepsensoravg(3) + sensor*zc
      if (computecavitation) then
        plocal = pp2(i, j)
        tmp = two/(gammainf*machcoef*machcoef)
        cp = tmp*(plocal-pinf)
        sensor1 = -cp - cavitationnumber
        sensor1 = one/(one+exp(-(2*10*sensor1)))
        sensor1 = sensor1*cellarea*blk
        cavitation = cavitation + sensor1
      end if
    end do
!
! integration of the viscous forces.
! only for viscous boundaries.
!
    if (bctype(mm) .eq. nswalladiabatic .or. bctype(mm) .eq. &
&       nswallisothermal) then
! initialize dwall for the laminar case and set the pointer
! for the unit normals.
      dwall = zero
! loop over the quadrilateral faces of the subface and
! compute the viscous contribution to the force and
! moment and update the maximum value of y+.
      do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-&
&         bcdata(mm)%inbeg)-1
        i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&         inbeg + 1
        j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + &
&         1
        if (bcdata(mm)%iblank(i, j) .lt. 0) then
          blk = 0
        else
          blk = bcdata(mm)%iblank(i, j)
        end if
        tauxx = viscsubface(mm)%tau(i, j, 1)
        tauyy = viscsubface(mm)%tau(i, j, 2)
        tauzz = viscsubface(mm)%tau(i, j, 3)
        tauxy = viscsubface(mm)%tau(i, j, 4)
        tauxz = viscsubface(mm)%tau(i, j, 5)
        tauyz = viscsubface(mm)%tau(i, j, 6)
! compute the viscous force on the face. a minus sign
! is now present, due to the definition of this force.
        fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*ssi(i, &
&         j, 3))*pref)
        fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*ssi(i, &
&         j, 3))*pref)
        fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*ssi(i, &
&         j, 3))*pref)
! compute the coordinates of the centroid of the face
! relative from the moment reference point. due to the
! usage of pointers for xx and offset of 1 is present,
! because x originally starts at 0.
        xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
&         , 1)) - refpoint(1)
        yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
&         , 2)) - refpoint(2)
        zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
&         , 3)) - refpoint(3)
! update the viscous force and moment coefficients, blanking as we go.
        fv(1) = fv(1) + fx*blk
        fv(2) = fv(2) + fy*blk
        fv(3) = fv(3) + fz*blk
        mx = yc*fz - zc*fy
        my = zc*fx - xc*fz
        mz = xc*fy - yc*fx
        mv(1) = mv(1) + mx*blk
        mv(2) = mv(2) + my*blk
        mv(3) = mv(3) + mz*blk
! compute the r and n vectors for the moment around an
! axis computation where r is the distance from the
! force to the first point on the axis and n is a unit
! normal in the direction of the axis
        r(1) = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j&
&         +1, 1)) - axispoints(1, 1)
        r(2) = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j&
&         +1, 2)) - axispoints(2, 1)
        r(3) = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j&
&         +1, 3)) - axispoints(3, 1)
        l = sqrt((axispoints(1, 2)-axispoints(1, 1))**2 + (axispoints(2&
&         , 2)-axispoints(2, 1))**2 + (axispoints(3, 2)-axispoints(3, 1)&
&         )**2)
        n(1) = (axispoints(1, 2)-axispoints(1, 1))/l
        n(2) = (axispoints(2, 2)-axispoints(2, 1))/l
        n(3) = (axispoints(3, 2)-axispoints(3, 1))/l
! compute the moment of the force about the first point
! used to define the axis, and then project that axis in
! the n direction
        m0x = r(2)*fz - r(3)*fy
        m0y = r(3)*fx - r(1)*fz
        m0z = r(1)*fy - r(2)*fx
        mvaxis = mvaxis + (m0x*n(1)+m0y*n(2)+m0z*n(3))*blk
! save the face based forces for the slice operations
        bcdata(mm)%fv(i, j, 1) = fx
        bcdata(mm)%fv(i, j, 2) = fy
        bcdata(mm)%fv(i, j, 3) = fz
! compute the tangential component of the stress tensor,
! which is needed to monitor y+. the result is stored
! in fx, fy, fz, although it is not really a force.
! as later on only the magnitude of the tangential
! component is important, there is no need to take the
! sign into account (it should be a minus sign).
        fx = tauxx*bcdata(mm)%norm(i, j, 1) + tauxy*bcdata(mm)%norm(i, j&
&         , 2) + tauxz*bcdata(mm)%norm(i, j, 3)
        fy = tauxy*bcdata(mm)%norm(i, j, 1) + tauyy*bcdata(mm)%norm(i, j&
&         , 2) + tauyz*bcdata(mm)%norm(i, j, 3)
        fz = tauxz*bcdata(mm)%norm(i, j, 1) + tauyz*bcdata(mm)%norm(i, j&
&         , 2) + tauzz*bcdata(mm)%norm(i, j, 3)
        fn = fx*bcdata(mm)%norm(i, j, 1) + fy*bcdata(mm)%norm(i, j, 2) +&
&         fz*bcdata(mm)%norm(i, j, 3)
        fx = fx - fn*bcdata(mm)%norm(i, j, 1)
        fy = fy - fn*bcdata(mm)%norm(i, j, 2)
        fz = fz - fn*bcdata(mm)%norm(i, j, 3)
      end do
    else
! compute the local value of y+. due to the usage
! of pointers there is on offset of -1 in dd2wall..
! if we had no viscous force, set the viscous component to zero
      bcdata(mm)%fv = zero
    end if
! increment the local values array with the values we computed here.
    localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
    localvalues(ifv:ifv+2) = localvalues(ifv:ifv+2) + fv
    localvalues(imp:imp+2) = localvalues(imp:imp+2) + mp
    localvalues(imv:imv+2) = localvalues(imv:imv+2) + mv
    localvalues(isepsensor) = localvalues(isepsensor) + sepsensor
    localvalues(icavitation) = localvalues(icavitation) + cavitation
    localvalues(isepavg:isepavg+2) = localvalues(isepavg:isepavg+2) + &
&     sepsensoravg
    localvalues(iaxismoment) = localvalues(iaxismoment) + mpaxis + &
&     mvaxis
    localvalues(icperror2) = localvalues(icperror2) + cperror2
  end subroutine wallintegrationface
!  differentiation of flowintegrationface in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: pointref timeref tref rgas
!                pref rhoref *xx *pp1 *pp2 *ssi *ww1 *ww2 localvalues
!   with respect to varying inputs: pointref timeref tref rgas
!                pref rhoref *xx *pp1 *pp2 *ssi *ww1 *ww2 localvalues
!   rw status of diff variables: pointref:incr timeref:incr tref:incr
!                rgas:incr pref:incr rhoref:incr *xx:incr *pp1:incr
!                *pp2:incr *ssi:incr *ww1:incr *ww2:incr localvalues:in-out
!   plus diff mem management of: xx:in pp1:in pp2:in ssi:in ww1:in
!                ww2:in
  subroutine flowintegrationface_b(isinflow, localvalues, localvaluesd, &
&   mm)
    use constants
    use blockpointers, only : bctype, bcfaceid, bcdata, bcdatad, &
&   addgridvelocities
    use flowvarrefstate, only : pref, prefd, pinf, pinfd, rhoref, &
&   rhorefd, timeref, timerefd, lref, tref, trefd, rgas, rgasd, uref, &
&   urefd, uinf, uinfd, rhoinf, rhoinfd
    use inputphysics, only : pointref, pointrefd, flowtype
    use flowutils_b, only : computeptot, computeptot_b, computettot, &
&   computettot_b
    use bcpointers_b, only : ssi, ssid, sface, ww1, ww1d, ww2, ww2d, pp1&
&   , pp1d, pp2, pp2d, xx, xxd, gamma1, gamma2
    use utils_b, only : mynorm2, mynorm2_b
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvaluesd
    integer(kind=inttype), intent(in) :: mm
! local variables
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn, mass_a, mass_rho, mass_vx, mass_vy, mass_vz, mass_nx, &
&   mass_ny, mass_nz
    real(kind=realtype) :: massflowrated, mass_ptotd, mass_ttotd, &
&   mass_psd, mass_mnd, mass_ad, mass_rhod, mass_vxd, mass_vyd, mass_vzd&
&   , mass_nxd, mass_nyd, mass_nzd
    real(kind=realtype) :: area_ptot, area_ps
    real(kind=realtype) :: area_ptotd, area_psd
    real(kind=realtype) :: mredim
    real(kind=realtype) :: mredimd
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: internalflowfact, inflowfact, fact, xc, yc, &
&   zc, mx, my, mz
    real(kind=realtype) :: xcd, ycd, zcd, mxd, myd, mzd
    real(kind=realtype) :: sf, vmag, vnm, vnmfreestreamref, vxm, vym, &
&   vzm, fx, fy, fz, u, v, w
    real(kind=realtype) :: vmagd, vnmd, vxmd, vymd, vzmd, fxd, fyd, fzd&
&   , wd
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, am
    real(kind=realtype) :: pmd, ptotd, ttotd, rhomd, amd
    real(kind=realtype) :: area, cellarea, overcellarea
    real(kind=realtype) :: aread, cellaread, overcellaread
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   sfacecoordref
    real(kind=realtype), dimension(3) :: fpd, mpd, fmomd, mmomd, &
&   refpointd, sfacecoordrefd
    real(kind=realtype) :: mnm, massflowratelocal
    real(kind=realtype) :: mnmd, massflowratelocald
    intrinsic sqrt
    intrinsic mod
    intrinsic max
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: tempd15
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! note that these are *opposite* of force integrations. the reason
! is that we want positive mass flow into the domain and negative
! mass flow out of the domain. since the low faces have ssi
! vectors pointining into the domain, this is correct. the high
! end faces need to flip this.
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = one
    case (imax, jmax, kmax) 
      fact = -one
    end select
! the sign of momentum forces are flipped for internal flows
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    mredim = sqrt(pref*rhoref)
    mass_nzd = localvaluesd(imassnz)
    mass_nyd = localvaluesd(imassny)
    mass_nxd = localvaluesd(imassnx)
    mass_vzd = localvaluesd(imassvz)
    mass_vyd = localvaluesd(imassvy)
    mass_vxd = localvaluesd(imassvx)
    area_psd = localvaluesd(iareaps)
    area_ptotd = localvaluesd(iareaptot)
    mmomd = 0.0_8
    mmomd = localvaluesd(iflowmm:iflowmm+2)
    mpd = 0.0_8
    mpd = localvaluesd(iflowmp:iflowmp+2)
    fmomd = 0.0_8
    fmomd = localvaluesd(iflowfm:iflowfm+2)
    fpd = 0.0_8
    fpd = localvaluesd(ifp:ifp+2)
    mass_mnd = localvaluesd(imassmn)
    mass_psd = localvaluesd(imassps)
    mass_ttotd = localvaluesd(imassttot)
    mass_ptotd = localvaluesd(imassptot)
    mass_ad = localvaluesd(imassa)
    mass_rhod = localvaluesd(imassrho)
    aread = localvaluesd(iarea)
    massflowrated = localvaluesd(imassflow)
    mredimd = 0.0_8
    ptotd = 0.0_8
    refpointd = 0.0_8
    sfacecoordrefd = 0.0_8
    ttotd = 0.0_8
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
      if (addgridvelocities) then
        sf = sface(i, j)
      else
        sf = zero
      end if
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      vxm = half*(ww1(i, j, ivx)+ww2(i, j, ivx))
      vym = half*(ww1(i, j, ivy)+ww2(i, j, ivy))
      vzm = half*(ww1(i, j, ivz)+ww2(i, j, ivz))
      rhom = half*(ww1(i, j, irho)+ww2(i, j, irho))
      pm = half*(pp1(i, j)+pp2(i, j))
      gammam = half*(gamma1(i, j)+gamma2(i, j))
      vnm = vxm*ssi(i, j, 1) + vym*ssi(i, j, 2) + vzm*ssi(i, j, 3) - sf
      vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
      am = sqrt(gammam*pm/rhom)
      mnm = vmag/am
      cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**&
&       2)
      overcellarea = 1/cellarea
      call computeptot(rhom, vxm, vym, vzm, pm, ptot)
      call computettot(rhom, vxm, vym, vzm, pm, ttot)
      massflowratelocal = rhom*vnm*blk*fact*mredim
! re-dimentionalize quantities
      call pushreal8(pm)
      pm = pm*pref
      sfacecoordref(1) = sf*ssi(i, j, 1)*overcellarea
      sfacecoordref(2) = sf*ssi(i, j, 2)*overcellarea
      sfacecoordref(3) = sf*ssi(i, j, 3)*overcellarea
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
! pressure forces. note that these need a *negative* and to subtract
! the reference pressure sign to be consistent with the force
! computation on the walls.
      call pushreal8(pm)
      pm = -((pm-pinf*pref)*fact*blk)
! update the pressure force and moment coefficients.
! momentum forces are a little tricky.  we negate because
! have to re-apply fact to massflowratelocal to undoo it, because
! we need the signed behavior of ssi to get the momentum forces correct.
! also, the sign is flipped between inflow and outflow types
      call pushreal8(massflowratelocal)
      massflowratelocal = massflowratelocal*fact/timeref*blk/cellarea*&
&       internalflowfact*inflowfact
      fx = massflowratelocal*ssi(i, j, 1)*vxm
      fy = massflowratelocal*ssi(i, j, 2)*vym
      fz = massflowratelocal*ssi(i, j, 3)*vzm
      tempd5 = blk*area_ptotd
      tempd7 = ssi(i, j, 1)*mass_nxd
      tempd8 = ssi(i, j, 2)*mass_nyd
      tempd6 = ssi(i, j, 3)*mass_nzd
      mzd = mmomd(3)
      myd = mmomd(2)
      mxd = mmomd(1)
      xcd = fy*mzd - fz*myd
      fyd = fmomd(2) - zc*mxd + xc*mzd
      ycd = fz*mxd - fx*mzd
      fxd = zc*myd + fmomd(1) - yc*mzd
      zcd = fx*myd - fy*mxd
      fzd = yc*mxd + fmomd(3) - xc*myd
      tempd0 = ssi(i, j, 3)*fzd
      ssid(i, j, 3) = ssid(i, j, 3) + massflowratelocal*vzm*fzd
      vzmd = massflowratelocal*tempd0
      tempd1 = ssi(i, j, 2)*fyd
      ssid(i, j, 2) = ssid(i, j, 2) + massflowratelocal*vym*fyd
      vymd = massflowratelocal*tempd1
      tempd2 = ssi(i, j, 1)*fxd
      massflowratelocald = vym*tempd1 + vxm*tempd2 + vzm*tempd0
      ssid(i, j, 1) = ssid(i, j, 1) + massflowratelocal*vxm*fxd
      vxmd = massflowratelocal*tempd2
      call popreal8(massflowratelocal)
      tempd3 = fact*blk*internalflowfact*inflowfact*massflowratelocald/(&
&       timeref*cellarea)
      tempd4 = -(massflowratelocal*tempd3/(timeref*cellarea))
      timerefd = timerefd + cellarea*tempd4
      mzd = mpd(3)
      myd = mpd(2)
      mxd = mpd(1)
      fx = pm*ssi(i, j, 1)
      fy = pm*ssi(i, j, 2)
      fyd = fpd(2) - zc*mxd + xc*mzd
      fxd = zc*myd + fpd(1) - yc*mzd
      fz = pm*ssi(i, j, 3)
      xcd = xcd + fy*mzd - fz*myd
      ycd = ycd + fz*mxd - fx*mzd
      zcd = zcd + fx*myd - fy*mxd
      fzd = yc*mxd + fpd(3) - xc*myd
      pmd = ssi(i, j, 2)*fyd + ssi(i, j, 1)*fxd + ssi(i, j, 3)*fzd
      ssid(i, j, 3) = ssid(i, j, 3) + pm*fzd
      ssid(i, j, 2) = ssid(i, j, 2) + pm*fyd
      ssid(i, j, 1) = ssid(i, j, 1) + pm*fxd
      call popreal8(pm)
      massflowratelocald = overcellarea*tempd6 + overcellarea*tempd7 + (&
&       uref*vym-sfacecoordref(2))*mass_vyd + mnm*mass_mnd + uref*am*&
&       mass_ad + tref*ttot*mass_ttotd + massflowrated + pref*ptot*&
&       mass_ptotd + rhoref*rhom*mass_rhod + pm*mass_psd + (uref*vxm-&
&       sfacecoordref(1))*mass_vxd + (uref*vzm-sfacecoordref(3))*&
&       mass_vzd + overcellarea*tempd8 + tempd3
      tempd9 = -(fact*blk*pmd)
      prefd = prefd - pinf*tempd9
      pmd = blk*cellarea*area_psd + massflowratelocal*mass_psd + tempd9
      tempd10 = fourth*zcd
      xxd(i, j, 3) = xxd(i, j, 3) + tempd10
      xxd(i+1, j, 3) = xxd(i+1, j, 3) + tempd10
      xxd(i, j+1, 3) = xxd(i, j+1, 3) + tempd10
      xxd(i+1, j+1, 3) = xxd(i+1, j+1, 3) + tempd10
      refpointd(3) = refpointd(3) - zcd
      tempd11 = fourth*ycd
      xxd(i, j, 2) = xxd(i, j, 2) + tempd11
      xxd(i+1, j, 2) = xxd(i+1, j, 2) + tempd11
      xxd(i, j+1, 2) = xxd(i, j+1, 2) + tempd11
      xxd(i+1, j+1, 2) = xxd(i+1, j+1, 2) + tempd11
      refpointd(2) = refpointd(2) - ycd
      tempd12 = fourth*xcd
      xxd(i, j, 1) = xxd(i, j, 1) + tempd12
      xxd(i+1, j, 1) = xxd(i+1, j, 1) + tempd12
      xxd(i, j+1, 1) = xxd(i, j+1, 1) + tempd12
      xxd(i+1, j+1, 1) = xxd(i+1, j+1, 1) + tempd12
      refpointd(1) = refpointd(1) - xcd
      ssid(i, j, 3) = ssid(i, j, 3) + overcellarea*massflowratelocal*&
&       mass_nzd
      ssid(i, j, 2) = ssid(i, j, 2) + overcellarea*massflowratelocal*&
&       mass_nyd
      ssid(i, j, 1) = ssid(i, j, 1) + overcellarea*massflowratelocal*&
&       mass_nxd
      vzmd = vzmd + massflowratelocal*uref*mass_vzd
      sfacecoordrefd(3) = sfacecoordrefd(3) - massflowratelocal*mass_vzd
      vymd = vymd + massflowratelocal*uref*mass_vyd
      sfacecoordrefd(2) = sfacecoordrefd(2) - massflowratelocal*mass_vyd
      vxmd = vxmd + massflowratelocal*uref*mass_vxd
      sfacecoordrefd(1) = sfacecoordrefd(1) - massflowratelocal*mass_vxd
      overcellaread = massflowratelocal*tempd8 + sf*ssi(i, j, 3)*&
&       sfacecoordrefd(3) + massflowratelocal*tempd7 + massflowratelocal&
&       *tempd6
      ssid(i, j, 3) = ssid(i, j, 3) + sf*overcellarea*sfacecoordrefd(3)
      sfacecoordrefd(3) = 0.0_8
      ssid(i, j, 2) = ssid(i, j, 2) + sf*overcellarea*sfacecoordrefd(2)
      overcellaread = overcellaread + sf*ssi(i, j, 2)*sfacecoordrefd(2)
      sfacecoordrefd(2) = 0.0_8
      ssid(i, j, 1) = ssid(i, j, 1) + sf*overcellarea*sfacecoordrefd(1)
      overcellaread = overcellaread + sf*ssi(i, j, 1)*sfacecoordrefd(1)
      cellaread = blk*pm*area_psd - overcellaread/cellarea**2 + blk*&
&       aread + ptot*pref*tempd5 + timeref*tempd4
      sfacecoordrefd(1) = 0.0_8
      ptotd = ptotd + pref*massflowratelocal*mass_ptotd + cellarea*pref*&
&       tempd5
      mnmd = massflowratelocal*mass_mnd
      amd = uref*massflowratelocal*mass_ad - vmag*mnmd/am**2
      rhorefd = rhorefd + rhom*massflowratelocal*mass_rhod
      ttotd = ttotd + tref*massflowratelocal*mass_ttotd
      trefd = trefd + ttot*massflowratelocal*mass_ttotd
      call popreal8(pm)
      prefd = prefd + ptot*massflowratelocal*mass_ptotd + pm*pmd + &
&       cellarea*ptot*tempd5
      pmd = pref*pmd
      tempd13 = blk*fact*massflowratelocald
      rhomd = mredim*vnm*tempd13 + rhoref*massflowratelocal*mass_rhod
      vnmd = mredim*rhom*tempd13
      mredimd = mredimd + rhom*vnm*tempd13
      call computettot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, vzmd, &
&                  pm, pmd, ttot, ttotd)
      call computeptot_b(rhom, rhomd, vxm, vxmd, vym, vymd, vzm, vzmd, &
&                  pm, pmd, ptot, ptotd)
      if (ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**2 .eq. 0.0_8&
&     ) then
        tempd14 = 0.0
      else
        tempd14 = cellaread/(2.0*sqrt(ssi(i, j, 1)**2+ssi(i, j, 2)**2+&
&         ssi(i, j, 3)**2))
      end if
      ssid(i, j, 1) = ssid(i, j, 1) + 2*ssi(i, j, 1)*tempd14
      ssid(i, j, 2) = ssid(i, j, 2) + 2*ssi(i, j, 2)*tempd14
      ssid(i, j, 3) = ssid(i, j, 3) + 2*ssi(i, j, 3)*tempd14
      vmagd = mnmd/am
      if (gammam*(pm/rhom) .eq. 0.0_8) then
        tempd15 = 0.0
      else
        tempd15 = gammam*amd/(2.0*sqrt(gammam*(pm/rhom))*rhom)
      end if
      pmd = pmd + tempd15
      rhomd = rhomd - pm*tempd15/rhom
      if (vxm**2 + vym**2 + vzm**2 .eq. 0.0_8) then
        tempd16 = 0.0
      else
        tempd16 = vmagd/(2.0*sqrt(vxm**2+vym**2+vzm**2))
      end if
      vxmd = vxmd + ssi(i, j, 1)*vnmd + 2*vxm*tempd16
      vymd = vymd + ssi(i, j, 2)*vnmd + 2*vym*tempd16
      vzmd = vzmd + ssi(i, j, 3)*vnmd + 2*vzm*tempd16
      ssid(i, j, 1) = ssid(i, j, 1) + vxm*vnmd
      ssid(i, j, 2) = ssid(i, j, 2) + vym*vnmd
      ssid(i, j, 3) = ssid(i, j, 3) + vzm*vnmd
      pp1d(i, j) = pp1d(i, j) + half*pmd
      pp2d(i, j) = pp2d(i, j) + half*pmd
      ww1d(i, j, irho) = ww1d(i, j, irho) + half*rhomd
      ww2d(i, j, irho) = ww2d(i, j, irho) + half*rhomd
      ww1d(i, j, ivz) = ww1d(i, j, ivz) + half*vzmd
      ww2d(i, j, ivz) = ww2d(i, j, ivz) + half*vzmd
      ww1d(i, j, ivy) = ww1d(i, j, ivy) + half*vymd
      ww2d(i, j, ivy) = ww2d(i, j, ivy) + half*vymd
      ww1d(i, j, ivx) = ww1d(i, j, ivx) + half*vxmd
      ww2d(i, j, ivx) = ww2d(i, j, ivx) + half*vxmd
    end do
    if (pref*rhoref .eq. 0.0_8) then
      tempd = 0.0
    else
      tempd = mredimd/(2.0*sqrt(pref*rhoref))
    end if
    prefd = prefd + rhoref*tempd
    rhorefd = rhorefd + pref*tempd
    pointrefd(3) = pointrefd(3) + lref*refpointd(3)
    refpointd(3) = 0.0_8
    pointrefd(2) = pointrefd(2) + lref*refpointd(2)
    refpointd(2) = 0.0_8
    pointrefd(1) = pointrefd(1) + lref*refpointd(1)
  end subroutine flowintegrationface_b
  subroutine flowintegrationface(isinflow, localvalues, mm)
    use constants
    use blockpointers, only : bctype, bcfaceid, bcdata, &
&   addgridvelocities
    use flowvarrefstate, only : pref, pinf, rhoref, timeref, lref, &
&   tref, rgas, uref, uinf, rhoinf
    use inputphysics, only : pointref, flowtype
    use flowutils_b, only : computeptot, computettot
    use bcpointers_b, only : ssi, sface, ww1, ww2, pp1, pp2, xx, gamma1,&
&   gamma2
    use utils_b, only : mynorm2
    implicit none
! input/output variables
    logical, intent(in) :: isinflow
    real(kind=realtype), dimension(nlocalvalues), intent(inout) :: &
&   localvalues
    integer(kind=inttype), intent(in) :: mm
! local variables
    real(kind=realtype) :: massflowrate, mass_ptot, mass_ttot, mass_ps, &
&   mass_mn, mass_a, mass_rho, mass_vx, mass_vy, mass_vz, mass_nx, &
&   mass_ny, mass_nz
    real(kind=realtype) :: area_ptot, area_ps
    real(kind=realtype) :: mredim
    integer(kind=inttype) :: i, j, ii, blk
    real(kind=realtype) :: internalflowfact, inflowfact, fact, xc, yc, &
&   zc, mx, my, mz
    real(kind=realtype) :: sf, vmag, vnm, vnmfreestreamref, vxm, vym, &
&   vzm, fx, fy, fz, u, v, w
    real(kind=realtype) :: pm, ptot, ttot, rhom, gammam, am
    real(kind=realtype) :: area, cellarea, overcellarea
    real(kind=realtype), dimension(3) :: fp, mp, fmom, mmom, refpoint, &
&   sfacecoordref
    real(kind=realtype) :: mnm, massflowratelocal
    intrinsic sqrt
    intrinsic mod
    intrinsic max
    refpoint(1) = lref*pointref(1)
    refpoint(2) = lref*pointref(2)
    refpoint(3) = lref*pointref(3)
! note that these are *opposite* of force integrations. the reason
! is that we want positive mass flow into the domain and negative
! mass flow out of the domain. since the low faces have ssi
! vectors pointining into the domain, this is correct. the high
! end faces need to flip this.
    select case  (bcfaceid(mm)) 
    case (imin, jmin, kmin) 
      fact = one
    case (imax, jmax, kmax) 
      fact = -one
    end select
! the sign of momentum forces are flipped for internal flows
    internalflowfact = one
    if (flowtype .eq. internalflow) internalflowfact = -one
    inflowfact = one
    if (isinflow) inflowfact = -one
! loop over the quadrilateral faces of the subface. note that
! the nodal range of bcdata must be used and not the cell
! range, because the latter may include the halo's in i and
! j-direction. the offset +1 is there, because inbeg and jnbeg
! refer to nodal ranges and not to cell ranges. the loop
! (without the ad stuff) would look like:
!
! do j=(bcdata(mm)%jnbeg+1),bcdata(mm)%jnend
!    do i=(bcdata(mm)%inbeg+1),bcdata(mm)%inend
    mredim = sqrt(pref*rhoref)
    fp = zero
    mp = zero
    fmom = zero
    mmom = zero
    massflowrate = zero
    area = zero
    mass_ptot = zero
    mass_ttot = zero
    mass_ps = zero
    mass_mn = zero
    mass_a = zero
    mass_rho = zero
    mass_vx = zero
    mass_vy = zero
    mass_vz = zero
    mass_nx = zero
    mass_ny = zero
    mass_nz = zero
    area_ptot = zero
    area_ps = zero
    do ii=0,(bcdata(mm)%jnend-bcdata(mm)%jnbeg)*(bcdata(mm)%inend-bcdata&
&       (mm)%inbeg)-1
      i = mod(ii, bcdata(mm)%inend - bcdata(mm)%inbeg) + bcdata(mm)%&
&       inbeg + 1
      j = ii/(bcdata(mm)%inend-bcdata(mm)%inbeg) + bcdata(mm)%jnbeg + 1
      if (addgridvelocities) then
        sf = sface(i, j)
      else
        sf = zero
      end if
      if (bcdata(mm)%iblank(i, j) .lt. 0) then
        blk = 0
      else
        blk = bcdata(mm)%iblank(i, j)
      end if
      vxm = half*(ww1(i, j, ivx)+ww2(i, j, ivx))
      vym = half*(ww1(i, j, ivy)+ww2(i, j, ivy))
      vzm = half*(ww1(i, j, ivz)+ww2(i, j, ivz))
      rhom = half*(ww1(i, j, irho)+ww2(i, j, irho))
      pm = half*(pp1(i, j)+pp2(i, j))
      gammam = half*(gamma1(i, j)+gamma2(i, j))
      vnm = vxm*ssi(i, j, 1) + vym*ssi(i, j, 2) + vzm*ssi(i, j, 3) - sf
      vmag = sqrt(vxm**2 + vym**2 + vzm**2) - sf
      am = sqrt(gammam*pm/rhom)
      mnm = vmag/am
      cellarea = sqrt(ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**&
&       2)
      area = area + cellarea*blk
      overcellarea = 1/cellarea
      call computeptot(rhom, vxm, vym, vzm, pm, ptot)
      call computettot(rhom, vxm, vym, vzm, pm, ttot)
      massflowratelocal = rhom*vnm*blk*fact*mredim
      massflowrate = massflowrate + massflowratelocal
! re-dimentionalize quantities
      pm = pm*pref
      mass_ptot = mass_ptot + ptot*massflowratelocal*pref
      mass_ttot = mass_ttot + ttot*massflowratelocal*tref
      mass_rho = mass_rho + rhom*massflowratelocal*rhoref
      mass_a = mass_a + am*massflowratelocal*uref
      mass_ps = mass_ps + pm*massflowratelocal
      mass_mn = mass_mn + mnm*massflowratelocal
      area_ptot = area_ptot + ptot*pref*cellarea*blk
      area_ps = area_ps + pm*cellarea*blk
      sfacecoordref(1) = sf*ssi(i, j, 1)*overcellarea
      sfacecoordref(2) = sf*ssi(i, j, 2)*overcellarea
      sfacecoordref(3) = sf*ssi(i, j, 3)*overcellarea
      mass_vx = mass_vx + (vxm*uref-sfacecoordref(1))*massflowratelocal
      mass_vy = mass_vy + (vym*uref-sfacecoordref(2))*massflowratelocal
      mass_vz = mass_vz + (vzm*uref-sfacecoordref(3))*massflowratelocal
      mass_nx = mass_nx + ssi(i, j, 1)*overcellarea*massflowratelocal
      mass_ny = mass_ny + ssi(i, j, 2)*overcellarea*massflowratelocal
      mass_nz = mass_nz + ssi(i, j, 3)*overcellarea*massflowratelocal
      xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1, &
&       1)) - refpoint(1)
      yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1, &
&       2)) - refpoint(2)
      zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1, &
&       3)) - refpoint(3)
! pressure forces. note that these need a *negative* and to subtract
! the reference pressure sign to be consistent with the force
! computation on the walls.
      pm = -((pm-pinf*pref)*fact*blk)
      fx = pm*ssi(i, j, 1)
      fy = pm*ssi(i, j, 2)
      fz = pm*ssi(i, j, 3)
! update the pressure force and moment coefficients.
      fp(1) = fp(1) + fx
      fp(2) = fp(2) + fy
      fp(3) = fp(3) + fz
      mx = yc*fz - zc*fy
      my = zc*fx - xc*fz
      mz = xc*fy - yc*fx
      mp(1) = mp(1) + mx
      mp(2) = mp(2) + my
      mp(3) = mp(3) + mz
! momentum forces are a little tricky.  we negate because
! have to re-apply fact to massflowratelocal to undoo it, because
! we need the signed behavior of ssi to get the momentum forces correct.
! also, the sign is flipped between inflow and outflow types
      massflowratelocal = massflowratelocal*fact/timeref*blk/cellarea*&
&       internalflowfact*inflowfact
      fx = massflowratelocal*ssi(i, j, 1)*vxm
      fy = massflowratelocal*ssi(i, j, 2)*vym
      fz = massflowratelocal*ssi(i, j, 3)*vzm
      fmom(1) = fmom(1) + fx
      fmom(2) = fmom(2) + fy
      fmom(3) = fmom(3) + fz
      mx = yc*fz - zc*fy
      my = zc*fx - xc*fz
      mz = xc*fy - yc*fx
      mmom(1) = mmom(1) + mx
      mmom(2) = mmom(2) + my
      mmom(3) = mmom(3) + mz
    end do
! increment the local values array with what we computed here
    localvalues(imassflow) = localvalues(imassflow) + massflowrate
    localvalues(iarea) = localvalues(iarea) + area
    localvalues(imassrho) = localvalues(imassrho) + mass_rho
    localvalues(imassa) = localvalues(imassa) + mass_a
    localvalues(imassptot) = localvalues(imassptot) + mass_ptot
    localvalues(imassttot) = localvalues(imassttot) + mass_ttot
    localvalues(imassps) = localvalues(imassps) + mass_ps
    localvalues(imassmn) = localvalues(imassmn) + mass_mn
    localvalues(ifp:ifp+2) = localvalues(ifp:ifp+2) + fp
    localvalues(iflowfm:iflowfm+2) = localvalues(iflowfm:iflowfm+2) + &
&     fmom
    localvalues(iflowmp:iflowmp+2) = localvalues(iflowmp:iflowmp+2) + mp
    localvalues(iflowmm:iflowmm+2) = localvalues(iflowmm:iflowmm+2) + &
&     mmom
    localvalues(iareaptot) = localvalues(iareaptot) + area_ptot
    localvalues(iareaps) = localvalues(iareaps) + area_ps
    localvalues(imassvx) = localvalues(imassvx) + mass_vx
    localvalues(imassvy) = localvalues(imassvy) + mass_vy
    localvalues(imassvz) = localvalues(imassvz) + mass_vz
    localvalues(imassnx) = localvalues(imassnx) + mass_nx
    localvalues(imassny) = localvalues(imassny) + mass_ny
    localvalues(imassnz) = localvalues(imassnz) + mass_nz
  end subroutine flowintegrationface
end module surfaceintegrations_b

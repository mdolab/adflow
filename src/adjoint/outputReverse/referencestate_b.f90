!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of referencestate in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: gammainf pinf timeref rhoinf
!                muref rhoinfdim tref muinf uinf rgas pinfdim pref
!                veldirfreestream machcoef
!   with respect to varying inputs: pref mach tempfreestream reynolds
!                veldirfreestream machcoef
!
!      ******************************************************************
!      *                                                                *
!      * file:          referencestate.f90                              *
!      * author:        edwin van der weide, seonghyeon hahn            *
!      * starting date: 05-29-2003                                      *
!      * last modified: 04-22-2006                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine referencestate_b()
!
!      ******************************************************************
!      *                                                                *
!      * referencestate computes the reference state values in case     *
!      * these have not been specified. a distinction is made between   *
!      * internal and external flows. in case nothing has been          *
!      * specified for the former a dimensional computation will be     *
!      * made. for the latter the reference state is set to an          *
!      * arbitrary state for an inviscid computation and computed for a *
!      * viscous computation. furthermore for internal flows an average *
!      * velocity direction is computed from the boundary conditions,   *
!      * which is used for initialization.                              *
!      *                                                                *
!      * the original version has been nuked since the computations are *
!      * no longer necessary when calling from python                   *
!      ******************************************************************
!
  use bctypes
  use block
  use communication
  use constants
  use flowvarrefstate
  use inputmotion
  use inputphysics
  use inputtimespectral
  use iteration
  implicit none
!
!      local variables.
!
  integer :: ierr
  integer(kind=inttype) :: sps, nn, mm
  real(kind=realtype) :: gm1, ratio, tmp
  real(kind=realtype) :: mx, my, mz, re, v, tinfdim
  real(kind=realtype) :: mxd, myd, mzd, red, vd, tinfdimd
  intrinsic sqrt
  integer :: branch
  real(kind=realtype) :: temp1
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: temp
! the following values must be set:
! pinfdim, reynolds, tempfreestream
! pref, rhoref and tref may be optionally set of if less than 0
! will take free stream values.
  tinfdim = tempfreestream
  rhoinfdim = pinfdim/(rgasdim*tinfdim)
  mudim = musuthdim*((tsuthdim+ssuthdim)/(tinfdim+ssuthdim))*(tinfdim/&
&   tsuthdim)**1.5_realtype
! external flow. compute the value of gammainf.
  call computegamma(tempfreestream, gammainf, 1)
! in case of a viscous problem, compute the
! dimensional free stream density and pressure.
  if (equations .eq. nsequations .or. equations .eq. ransequations) then
! compute the x, y, and z-components of the mach number
! relative to the body; i.e. the mesh velocity must be
! taken into account here.
    mx = machcoef*veldirfreestream(1)
    my = machcoef*veldirfreestream(2)
    mz = machcoef*veldirfreestream(3)
! reynolds number per meter, the viscosity using sutherland's
! law and the free stream velocity relative to the body.
    re = reynolds/reynoldslength
    mudim = musuthdim*((tsuthdim+ssuthdim)/(tempfreestream+ssuthdim))*(&
&     tempfreestream/tsuthdim)**1.5
    v = sqrt((mx*mx+my*my+mz*mz)*gammainf*rgasdim*tempfreestream)
! compute the free stream density and pressure.
! set tinfdim to tempfreestream.
    rhoinfdim = re*mudim/v
    call pushreal8(pinfdim)
    pinfdim = rhoinfdim*rgasdim*tempfreestream
    call pushcontrol1b(0)
  else
    call pushcontrol1b(1)
  end if
! in case the reference pressure, density and temperature were
! not specified, set them to the infinity values.
  if (pref .le. zero) then
    pref = pinfdim
    call pushcontrol1b(0)
  else
    call pushcontrol1b(1)
  end if
  if (rhoref .le. zero) then
    rhoref = rhoinfdim
    call pushcontrol1b(0)
  else
    call pushcontrol1b(1)
  end if
  if (tref .le. zero) then
    tref = tinfdim
    call pushcontrol1b(0)
  else
    call pushcontrol1b(1)
  end if
! compute the value of muref, such that the nondimensional
! equations are identical to the dimensional ones.
! note that in the non-dimensionalization of muref there is
! a reference length. however this reference length is 1.0
! in this code, because the coordinates are converted to
! meters.
  muref = sqrt(pref*rhoref)
! compute timeref for a correct nondimensionalization of the
! unsteady equations. some story as for the reference viscosity
! concerning the reference length.
! compute the nondimensional pressure, density, velocity,
! viscosity and gas constant.
  pinf = pinfdim/pref
  rhoinf = rhoinfdim/rhoref
  mudimd = muinfd/muref
  murefd = murefd - mudim*muinfd/muref**2
  tempd4 = rgasdim*rgasd/pref
  trefd = trefd + rhoref*tempd4
  temp0 = gammainf*pinf/rhoinf
  temp1 = sqrt(temp0)
  if (temp0 .eq. 0.0_8) then
    tempd7 = 0.0
  else
    tempd7 = mach*uinfd/(2.0*temp1*rhoinf)
  end if
  machd = temp1*uinfd
  gammainfd = gammainfd + pinf*tempd7
  pinfd = pinfd + gammainf*tempd7
  rhoinfd = rhoinfd - temp0*tempd7
  rhoinfdimd = rhoinfdimd + rhoinfd/rhoref
  pinfdimd = pinfdimd + pinfd/pref
  if (rhoref/pref .eq. 0.0_8) then
    tempd6 = 0.0
  else
    tempd6 = timerefd/(2.0*sqrt(rhoref/pref)*pref)
  end if
  if (pref*rhoref .eq. 0.0_8) then
    tempd5 = 0.0
  else
    tempd5 = murefd/(2.0*sqrt(pref*rhoref))
  end if
  rhorefd = pref*tempd5 - rhoinfdim*rhoinfd/rhoref**2 + tempd6 + tref*&
&   tempd4
  prefd = prefd + rhoref*tempd5 - pinfdim*pinfd/pref**2 - rhoref*tempd6/&
&   pref - rhoref*tref*tempd4/pref
  call popcontrol1b(branch)
  if (branch .eq. 0) then
    tinfdimd = trefd
  else
    tinfdimd = 0.0_8
  end if
  call popcontrol1b(branch)
  if (branch .eq. 0) rhoinfdimd = rhoinfdimd + rhorefd
  call popcontrol1b(branch)
  if (branch .eq. 0) then
    pinfdimd = pinfdimd + prefd
    prefd = 0.0_8
  end if
  call popcontrol1b(branch)
  if (branch .eq. 0) then
    call popreal8(pinfdim)
    rhoinfdimd = rhoinfdimd + rgasdim*tempfreestream*pinfdimd
    tempd2 = rhoinfdimd/v
    red = mudim*tempd2
    mudimd = mudimd + re*tempd2
    vd = -(re*mudim*tempd2/v)
    temp = mx**2 + my**2 + mz**2
    if (rgasdim*(temp*(gammainf*tempfreestream)) .eq. 0.0_8) then
      tempd0 = 0.0
    else
      tempd0 = rgasdim*vd/(2.0*sqrt(rgasdim*(temp*(gammainf*&
&       tempfreestream))))
    end if
    tempd3 = gammainf*tempfreestream*tempd0
    mxd = 2*mx*tempd3
    myd = 2*my*tempd3
    mzd = 2*mz*tempd3
    gammainfd = gammainfd + temp*tempfreestream*tempd0
    tempd1 = musuthdim*(tsuthdim+ssuthdim)*mudimd/(ssuthdim+&
&     tempfreestream)
    tempfreestreamd = temp*gammainf*tempd0 + (1.5*(tempfreestream/&
&     tsuthdim)**0.5/tsuthdim-(tempfreestream/tsuthdim)**1.5/(ssuthdim+&
&     tempfreestream))*tempd1 + rgasdim*rhoinfdim*pinfdimd
    reynoldsd = red/reynoldslength
    machcoefd = machcoefd + veldirfreestream(2)*myd + veldirfreestream(1&
&     )*mxd + veldirfreestream(3)*mzd
    veldirfreestreamd(3) = veldirfreestreamd(3) + machcoef*mzd
    veldirfreestreamd(2) = veldirfreestreamd(2) + machcoef*myd
    veldirfreestreamd(1) = veldirfreestreamd(1) + machcoef*mxd
    mudimd = 0.0_8
    rhoinfdimd = 0.0_8
  else
    tempfreestreamd = 0.0_8
    reynoldsd = 0.0_8
  end if
  call computegamma_b(tempfreestream, tempfreestreamd, gammainf, &
&               gammainfd, 1)
  tempd = musuthdim*(tsuthdim+ssuthdim)*mudimd/(ssuthdim+tinfdim)
  tinfdimd = tinfdimd + (1.5_realtype*(tinfdim/tsuthdim)**0.5/tsuthdim-(&
&   tinfdim/tsuthdim)**1.5_realtype/(ssuthdim+tinfdim))*tempd - pinfdim*&
&   rhoinfdimd/(rgasdim*tinfdim**2)
  tempfreestreamd = tempfreestreamd + tinfdimd
end subroutine referencestate_b

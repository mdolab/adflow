!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of invisciddissfluxscalarapprox in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: gammainf *p *w *fw
!   with respect to varying inputs: gammainf rhoinf pinfcorr *p
!                w *radi *radj 
!   plus diff mem management of: p:in w:in fw:in radi:in radj:in
!                radk:in
!
!       file:          invisciddissfluxscalar.f90                      
!       author:        edwin van der weide                             
!       starting date: 03-24-2003                                      
!       last modified: 10-29-2007                                      
!
subroutine invisciddissfluxscalarapprox_b()
!
!       invisciddissfluxscalar computes the scalar artificial          
!       dissipation, see aiaa paper 81-1259, for a given block.        
!       therefore it is assumed that the pointers in  blockpointers    
!       already point to the correct block.                            
!
  use blockpointers
  use cgnsgrid
  use constants
  use flowvarrefstate
  use inputdiscretization
  use inputphysics
  use iteration
  implicit none
!
!      local parameter.
!
  real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ind
  real(kind=realtype) :: sslim, rhoi
  real(kind=realtype) :: sslimd, rhoid
  real(kind=realtype) :: sfil, fis2, fis4
  real(kind=realtype) :: ppor, rrad, dis2
  real(kind=realtype) :: rradd, dis2d
  real(kind=realtype) :: dss1, dss2, ddw, fs
  real(kind=realtype) :: dss1d, dss2d, ddwd, fsd
  intrinsic abs
  intrinsic max
  intrinsic min
  real(kind=realtype) :: tmp
  real(kind=realtype) :: tmp0
  real(kind=realtype) :: tmp1
  real(kind=realtype) :: tmp2
  real(kind=realtype) :: tmp3
  real(kind=realtype) :: tmp4
  real(kind=realtype) :: tmp5
  real(kind=realtype) :: tmp6
  real(kind=realtype) :: tmp7
  real(kind=realtype) :: tmp8
  real(kind=realtype) :: tmp9
  real(kind=realtype) :: tmp10
  real(kind=realtype) :: tmp11
  real(kind=realtype) :: tmp12
  real(kind=realtype) :: tmp13
  real(kind=realtype) :: tmp14
  real(kind=realtype) :: tmp15
  real(kind=realtype) :: tmp16
  real(kind=realtype) :: tmp17
  real(kind=realtype) :: tmp18
  real(kind=realtype) :: tmp19
  real(kind=realtype) :: tmp20
  real(kind=realtype) :: tmp21
  real(kind=realtype) :: tmp22
  real(kind=realtype) :: tmp23
  real(kind=realtype) :: tmp24
  real(kind=realtype) :: tmp25
  integer :: branch
  real(kind=realtype) :: tmpd20
  real(kind=realtype) :: temp3
  real(kind=realtype) :: temp2
  real(kind=realtype) :: temp1
  real(kind=realtype) :: temp0
  real(kind=realtype) :: x6d
  real(kind=realtype) :: min3
  real(kind=realtype) :: min2
  real(kind=realtype) :: min1
  real(kind=realtype) :: tmpd
  real(kind=realtype) :: tmpd19
  real(kind=realtype) :: tmpd18
  real(kind=realtype) :: tmpd17
  real(kind=realtype) :: x6
  real(kind=realtype) :: tmpd16
  real(kind=realtype) :: x5
  real(kind=realtype) :: tmpd15
  real(kind=realtype) :: min1d
  real(kind=realtype) :: x4
  real(kind=realtype) :: tmpd14
  real(kind=realtype) :: x3
  real(kind=realtype) :: tmpd13
  real(kind=realtype) :: x2
  real(kind=realtype) :: tmpd12
  real(kind=realtype) :: x2d
  real(kind=realtype) :: x1
  real(kind=realtype) :: tmpd11
  real(kind=realtype) :: tmpd10
  real(kind=realtype) :: x5d
  real(kind=realtype) :: temp14
  real(kind=realtype) :: y3d
  real(kind=realtype) :: temp13
  real(kind=realtype) :: temp12
  real(kind=realtype) :: temp11
  real(kind=realtype) :: temp10
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tmpd9
  real(kind=realtype) :: tmpd8
  real(kind=realtype) :: tmpd7
  real(kind=realtype) :: tmpd6
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: tmpd5
  real(kind=realtype) :: tmpd4
  real(kind=realtype) :: x1d
  real(kind=realtype) :: tmpd3
  real(kind=realtype) :: tmpd2
  real(kind=realtype) :: tmpd1
  real(kind=realtype) :: tmpd0
  real(kind=realtype) :: min3d
  real(kind=realtype) :: x4d
  real(kind=realtype) :: y2d
  real(kind=realtype) :: abs0
  real(kind=realtype) :: temp
  real(kind=realtype) :: temp9
  real(kind=realtype) :: tmpd25
  real(kind=realtype) :: min2d
  real(kind=realtype) :: temp8
  real(kind=realtype) :: tmpd24
  real(kind=realtype) :: temp7
  real(kind=realtype) :: y3
  real(kind=realtype) :: tmpd23
  real(kind=realtype) :: temp6
  real(kind=realtype) :: y2
  real(kind=realtype) :: tmpd22
  real(kind=realtype) :: x3d
  real(kind=realtype) :: temp5
  real(kind=realtype) :: y1
  real(kind=realtype) :: tmpd21
  real(kind=realtype) :: y1d
  real(kind=realtype) :: temp4
  if (rfil .ge. 0.) then
    abs0 = rfil
  else
    abs0 = -rfil
  end if
!
!       begin execution                                                
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
  if (abs0 .lt. thresholdreal) then
    rhoinfd = 0.0_8
    pinfcorrd = 0.0_8
    radid = 0.0_8
    radjd = 0.0_8
    radkd = 0.0_8
  else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
    select case  (equations) 
    case (eulerequations) 
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
      sslim = 0.001_realtype*pinfcorr
      call pushcontrol2b(1)
    case (nsequations, ransequations) 
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
      sslim = 0.001_realtype*pinfcorr/rhoinf**gammainf
      call pushcontrol2b(2)
    case default
      call pushcontrol2b(0)
    end select
! set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
! replace the total energy by rho times the total enthalpy.
! in this way the numerical solution is total enthalpy preserving
! for the steady euler equations. also replace the velocities by
! the momentum. only done for the entries used in the
! discretization, i.e. ignore the corner halo's.
    do k=0,kb
      do j=2,jl
        do i=2,il
          tmp = w(i, j, k, irho)*w(i, j, k, ivx)
          call pushreal8(w(i, j, k, ivx))
          w(i, j, k, ivx) = tmp
          tmp0 = w(i, j, k, irho)*w(i, j, k, ivy)
          call pushreal8(w(i, j, k, ivy))
          w(i, j, k, ivy) = tmp0
          tmp1 = w(i, j, k, irho)*w(i, j, k, ivz)
          call pushreal8(w(i, j, k, ivz))
          w(i, j, k, ivz) = tmp1
          call pushreal8(w(i, j, k, irhoe))
          w(i, j, k, irhoe) = w(i, j, k, irhoe) + p(i, j, k)
        end do
      end do
    end do
    do k=2,kl
      do j=2,jl
        tmp2 = w(0, j, k, irho)*w(0, j, k, ivx)
        call pushreal8(w(0, j, k, ivx))
        w(0, j, k, ivx) = tmp2
        tmp3 = w(0, j, k, irho)*w(0, j, k, ivy)
        call pushreal8(w(0, j, k, ivy))
        w(0, j, k, ivy) = tmp3
        tmp4 = w(0, j, k, irho)*w(0, j, k, ivz)
        call pushreal8(w(0, j, k, ivz))
        w(0, j, k, ivz) = tmp4
        call pushreal8(w(0, j, k, irhoe))
        w(0, j, k, irhoe) = w(0, j, k, irhoe) + p(0, j, k)
        tmp5 = w(1, j, k, irho)*w(1, j, k, ivx)
        call pushreal8(w(1, j, k, ivx))
        w(1, j, k, ivx) = tmp5
        tmp6 = w(1, j, k, irho)*w(1, j, k, ivy)
        call pushreal8(w(1, j, k, ivy))
        w(1, j, k, ivy) = tmp6
        tmp7 = w(1, j, k, irho)*w(1, j, k, ivz)
        call pushreal8(w(1, j, k, ivz))
        w(1, j, k, ivz) = tmp7
        call pushreal8(w(1, j, k, irhoe))
        w(1, j, k, irhoe) = w(1, j, k, irhoe) + p(1, j, k)
        tmp8 = w(ie, j, k, irho)*w(ie, j, k, ivx)
        call pushreal8(w(ie, j, k, ivx))
        w(ie, j, k, ivx) = tmp8
        tmp9 = w(ie, j, k, irho)*w(ie, j, k, ivy)
        call pushreal8(w(ie, j, k, ivy))
        w(ie, j, k, ivy) = tmp9
        tmp10 = w(ie, j, k, irho)*w(ie, j, k, ivz)
        call pushreal8(w(ie, j, k, ivz))
        w(ie, j, k, ivz) = tmp10
        call pushreal8(w(ie, j, k, irhoe))
        w(ie, j, k, irhoe) = w(ie, j, k, irhoe) + p(ie, j, k)
        tmp11 = w(ib, j, k, irho)*w(ib, j, k, ivx)
        call pushreal8(w(ib, j, k, ivx))
        w(ib, j, k, ivx) = tmp11
        tmp12 = w(ib, j, k, irho)*w(ib, j, k, ivy)
        call pushreal8(w(ib, j, k, ivy))
        w(ib, j, k, ivy) = tmp12
        tmp13 = w(ib, j, k, irho)*w(ib, j, k, ivz)
        call pushreal8(w(ib, j, k, ivz))
        w(ib, j, k, ivz) = tmp13
        call pushreal8(w(ib, j, k, irhoe))
        w(ib, j, k, irhoe) = w(ib, j, k, irhoe) + p(ib, j, k)
      end do
    end do
    do k=2,kl
      do i=2,il
        tmp14 = w(i, 0, k, irho)*w(i, 0, k, ivx)
        call pushreal8(w(i, 0, k, ivx))
        w(i, 0, k, ivx) = tmp14
        tmp15 = w(i, 0, k, irho)*w(i, 0, k, ivy)
        call pushreal8(w(i, 0, k, ivy))
        w(i, 0, k, ivy) = tmp15
        tmp16 = w(i, 0, k, irho)*w(i, 0, k, ivz)
        call pushreal8(w(i, 0, k, ivz))
        w(i, 0, k, ivz) = tmp16
        call pushreal8(w(i, 0, k, irhoe))
        w(i, 0, k, irhoe) = w(i, 0, k, irhoe) + p(i, 0, k)
        tmp17 = w(i, 1, k, irho)*w(i, 1, k, ivx)
        call pushreal8(w(i, 1, k, ivx))
        w(i, 1, k, ivx) = tmp17
        tmp18 = w(i, 1, k, irho)*w(i, 1, k, ivy)
        call pushreal8(w(i, 1, k, ivy))
        w(i, 1, k, ivy) = tmp18
        tmp19 = w(i, 1, k, irho)*w(i, 1, k, ivz)
        call pushreal8(w(i, 1, k, ivz))
        w(i, 1, k, ivz) = tmp19
        call pushreal8(w(i, 1, k, irhoe))
        w(i, 1, k, irhoe) = w(i, 1, k, irhoe) + p(i, 1, k)
        tmp20 = w(i, je, k, irho)*w(i, je, k, ivx)
        call pushreal8(w(i, je, k, ivx))
        w(i, je, k, ivx) = tmp20
        tmp21 = w(i, je, k, irho)*w(i, je, k, ivy)
        call pushreal8(w(i, je, k, ivy))
        w(i, je, k, ivy) = tmp21
        tmp22 = w(i, je, k, irho)*w(i, je, k, ivz)
        call pushreal8(w(i, je, k, ivz))
        w(i, je, k, ivz) = tmp22
        call pushreal8(w(i, je, k, irhoe))
        w(i, je, k, irhoe) = w(i, je, k, irhoe) + p(i, je, k)
        tmp23 = w(i, jb, k, irho)*w(i, jb, k, ivx)
        call pushreal8(w(i, jb, k, ivx))
        w(i, jb, k, ivx) = tmp23
        tmp24 = w(i, jb, k, irho)*w(i, jb, k, ivy)
        call pushreal8(w(i, jb, k, ivy))
        w(i, jb, k, ivy) = tmp24
        tmp25 = w(i, jb, k, irho)*w(i, jb, k, ivz)
        call pushreal8(w(i, jb, k, ivz))
        w(i, jb, k, ivz) = tmp25
        call pushreal8(w(i, jb, k, irhoe))
        w(i, jb, k, irhoe) = w(i, jb, k, irhoe) + p(i, jb, k)
      end do
    end do
!
!       dissipative fluxes in the i-direction.                         
!
    do k=2,kl
      do j=2,jl
        x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+shocksensor(&
&         0, j, k))/(shocksensor(2, j, k)+two*shocksensor(1, j, k)+&
&         shocksensor(0, j, k)+sslim)
        if (x1 .ge. 0.) then
          dss1 = x1
          call pushcontrol1b(0)
        else
          dss1 = -x1
          call pushcontrol1b(1)
        end if
! loop in i-direction.
        do i=1,il
          x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&           shocksensor(i, j, k))/(shocksensor(i+2, j, k)+two*&
&           shocksensor(i+1, j, k)+shocksensor(i, j, k)+sslim)
          if (x2 .ge. 0.) then
            dss2 = x2
            call pushcontrol1b(0)
          else
            dss2 = -x2
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (pori(i, j, k) .eq. normalflux) ppor = half
          if (dss1 .lt. dss2) then
            y1 = dss2
            call pushcontrol1b(0)
          else
            y1 = dss1
            call pushcontrol1b(1)
          end if
          if (dssmax .gt. y1) then
            call pushreal8(min1)
            min1 = y1
            call pushcontrol1b(0)
          else
            call pushreal8(min1)
            min1 = dssmax
            call pushcontrol1b(1)
          end if
! modification for fd preconditioner note: this lumping
! actually still results in a greater than 3 cell stencil
! in any direction. since this seems to work slightly
! better than the dis2=sigma*fis4*rrad, we will just use
! a 5-cell stencil for doing the pc
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dss1 to dss2 for the next face.
          dss1 = dss2
        end do
      end do
    end do
!
!       dissipative fluxes in the j-direction.                         
!
    do k=2,kl
      do i=2,il
        x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+shocksensor(&
&         i, 0, k))/(shocksensor(i, 2, k)+two*shocksensor(i, 1, k)+&
&         shocksensor(i, 0, k)+sslim)
        if (x3 .ge. 0.) then
          dss1 = x3
          call pushcontrol1b(0)
        else
          dss1 = -x3
          call pushcontrol1b(1)
        end if
! loop in j-direction.
        do j=1,jl
          x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&           shocksensor(i, j, k))/(shocksensor(i, j+2, k)+two*&
&           shocksensor(i, j+1, k)+shocksensor(i, j, k)+sslim)
          if (x4 .ge. 0.) then
            dss2 = x4
            call pushcontrol1b(0)
          else
            dss2 = -x4
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (porj(i, j, k) .eq. normalflux) ppor = half
          if (dss1 .lt. dss2) then
            y2 = dss2
            call pushcontrol1b(0)
          else
            y2 = dss1
            call pushcontrol1b(1)
          end if
          if (dssmax .gt. y2) then
            call pushreal8(min2)
            min2 = y2
            call pushcontrol1b(0)
          else
            call pushreal8(min2)
            min2 = dssmax
            call pushcontrol1b(1)
          end if
! modification for fd preconditioner
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dss1 to dss2 for the next face.
          dss1 = dss2
        end do
      end do
    end do
!
!       dissipative fluxes in the k-direction.                         
!
    do j=2,jl
      do i=2,il
        x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+shocksensor(&
&         i, j, 0))/(shocksensor(i, j, 2)+two*shocksensor(i, j, 1)+&
&         shocksensor(i, j, 0)+sslim)
        if (x5 .ge. 0.) then
          dss1 = x5
          call pushcontrol1b(0)
        else
          dss1 = -x5
          call pushcontrol1b(1)
        end if
! loop in k-direction.
        do k=1,kl
          x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&           shocksensor(i, j, k))/(shocksensor(i, j, k+2)+two*&
&           shocksensor(i, j, k+1)+shocksensor(i, j, k)+sslim)
          if (x6 .ge. 0.) then
            dss2 = x6
            call pushcontrol1b(0)
          else
            dss2 = -x6
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (pork(i, j, k) .eq. normalflux) ppor = half
          if (dss1 .lt. dss2) then
            y3 = dss2
            call pushcontrol1b(0)
          else
            y3 = dss1
            call pushcontrol1b(1)
          end if
          if (dssmax .gt. y3) then
            call pushreal8(min3)
            min3 = y3
            call pushcontrol1b(0)
          else
            call pushreal8(min3)
            min3 = dssmax
            call pushcontrol1b(1)
          end if
! modification for fd preconditioner
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dss1 to dss2 for the next face.
          dss1 = dss2
        end do
      end do
    end do
! replace rho times the total enthalpy by the total energy and
! store the velocities again instead of the momentum. only for
! those entries that have been altered, i.e. ignore the
! corner halo's.
    do k=0,kb
      do j=2,jl
        do i=2,il
          call pushreal8(rhoi)
          rhoi = one/w(i, j, k, irho)
          call pushreal8(w(i, j, k, ivx))
          w(i, j, k, ivx) = w(i, j, k, ivx)*rhoi
          call pushreal8(w(i, j, k, ivy))
          w(i, j, k, ivy) = w(i, j, k, ivy)*rhoi
          call pushreal8(w(i, j, k, ivz))
          w(i, j, k, ivz) = w(i, j, k, ivz)*rhoi
          call pushreal8(w(i, j, k, irhoe))
          w(i, j, k, irhoe) = w(i, j, k, irhoe) - p(i, j, k)
        end do
      end do
    end do
    do k=2,kl
      do j=2,jl
        call pushreal8(rhoi)
        rhoi = one/w(0, j, k, irho)
        call pushreal8(w(0, j, k, ivx))
        w(0, j, k, ivx) = w(0, j, k, ivx)*rhoi
        call pushreal8(w(0, j, k, ivy))
        w(0, j, k, ivy) = w(0, j, k, ivy)*rhoi
        call pushreal8(w(0, j, k, ivz))
        w(0, j, k, ivz) = w(0, j, k, ivz)*rhoi
        call pushreal8(w(0, j, k, irhoe))
        w(0, j, k, irhoe) = w(0, j, k, irhoe) - p(0, j, k)
        call pushreal8(rhoi)
        rhoi = one/w(1, j, k, irho)
        call pushreal8(w(1, j, k, ivx))
        w(1, j, k, ivx) = w(1, j, k, ivx)*rhoi
        call pushreal8(w(1, j, k, ivy))
        w(1, j, k, ivy) = w(1, j, k, ivy)*rhoi
        call pushreal8(w(1, j, k, ivz))
        w(1, j, k, ivz) = w(1, j, k, ivz)*rhoi
        call pushreal8(w(1, j, k, irhoe))
        w(1, j, k, irhoe) = w(1, j, k, irhoe) - p(1, j, k)
        call pushreal8(rhoi)
        rhoi = one/w(ie, j, k, irho)
        call pushreal8(w(ie, j, k, ivx))
        w(ie, j, k, ivx) = w(ie, j, k, ivx)*rhoi
        call pushreal8(w(ie, j, k, ivy))
        w(ie, j, k, ivy) = w(ie, j, k, ivy)*rhoi
        call pushreal8(w(ie, j, k, ivz))
        w(ie, j, k, ivz) = w(ie, j, k, ivz)*rhoi
        call pushreal8(w(ie, j, k, irhoe))
        w(ie, j, k, irhoe) = w(ie, j, k, irhoe) - p(ie, j, k)
        call pushreal8(rhoi)
        rhoi = one/w(ib, j, k, irho)
        call pushreal8(w(ib, j, k, ivx))
        w(ib, j, k, ivx) = w(ib, j, k, ivx)*rhoi
        call pushreal8(w(ib, j, k, ivy))
        w(ib, j, k, ivy) = w(ib, j, k, ivy)*rhoi
        call pushreal8(w(ib, j, k, ivz))
        w(ib, j, k, ivz) = w(ib, j, k, ivz)*rhoi
        call pushreal8(w(ib, j, k, irhoe))
        w(ib, j, k, irhoe) = w(ib, j, k, irhoe) - p(ib, j, k)
      end do
    end do
    do k=2,kl
      do i=2,il
        call pushreal8(rhoi)
        rhoi = one/w(i, 0, k, irho)
        call pushreal8(w(i, 0, k, ivx))
        w(i, 0, k, ivx) = w(i, 0, k, ivx)*rhoi
        call pushreal8(w(i, 0, k, ivy))
        w(i, 0, k, ivy) = w(i, 0, k, ivy)*rhoi
        call pushreal8(w(i, 0, k, ivz))
        w(i, 0, k, ivz) = w(i, 0, k, ivz)*rhoi
        call pushreal8(w(i, 0, k, irhoe))
        w(i, 0, k, irhoe) = w(i, 0, k, irhoe) - p(i, 0, k)
        call pushreal8(rhoi)
        rhoi = one/w(i, 1, k, irho)
        call pushreal8(w(i, 1, k, ivx))
        w(i, 1, k, ivx) = w(i, 1, k, ivx)*rhoi
        call pushreal8(w(i, 1, k, ivy))
        w(i, 1, k, ivy) = w(i, 1, k, ivy)*rhoi
        call pushreal8(w(i, 1, k, ivz))
        w(i, 1, k, ivz) = w(i, 1, k, ivz)*rhoi
        call pushreal8(w(i, 1, k, irhoe))
        w(i, 1, k, irhoe) = w(i, 1, k, irhoe) - p(i, 1, k)
        call pushreal8(rhoi)
        rhoi = one/w(i, je, k, irho)
        call pushreal8(w(i, je, k, ivx))
        w(i, je, k, ivx) = w(i, je, k, ivx)*rhoi
        call pushreal8(w(i, je, k, ivy))
        w(i, je, k, ivy) = w(i, je, k, ivy)*rhoi
        call pushreal8(w(i, je, k, ivz))
        w(i, je, k, ivz) = w(i, je, k, ivz)*rhoi
        call pushreal8(w(i, je, k, irhoe))
        w(i, je, k, irhoe) = w(i, je, k, irhoe) - p(i, je, k)
        call pushreal8(rhoi)
        rhoi = one/w(i, jb, k, irho)
        call pushreal8(w(i, jb, k, ivx))
        w(i, jb, k, ivx) = w(i, jb, k, ivx)*rhoi
        call pushreal8(w(i, jb, k, ivy))
        w(i, jb, k, ivy) = w(i, jb, k, ivy)*rhoi
        call pushreal8(w(i, jb, k, ivz))
        w(i, jb, k, ivz) = w(i, jb, k, ivz)*rhoi
        call pushreal8(w(i, jb, k, irhoe))
        w(i, jb, k, irhoe) = w(i, jb, k, irhoe) - p(i, jb, k)
      end do
    end do
    do k=kl,2,-1
      do i=il,2,-1
        call popreal8(w(i, jb, k, irhoe))
        pd(i, jb, k) = pd(i, jb, k) - wd(i, jb, k, irhoe)
        call popreal8(w(i, jb, k, ivz))
        rhoid = w(i, jb, k, ivz)*wd(i, jb, k, ivz)
        wd(i, jb, k, ivz) = rhoi*wd(i, jb, k, ivz)
        call popreal8(w(i, jb, k, ivy))
        rhoid = rhoid + w(i, jb, k, ivy)*wd(i, jb, k, ivy)
        wd(i, jb, k, ivy) = rhoi*wd(i, jb, k, ivy)
        call popreal8(w(i, jb, k, ivx))
        rhoid = rhoid + w(i, jb, k, ivx)*wd(i, jb, k, ivx)
        wd(i, jb, k, ivx) = rhoi*wd(i, jb, k, ivx)
        call popreal8(rhoi)
        temp14 = w(i, jb, k, irho)
        wd(i, jb, k, irho) = wd(i, jb, k, irho) - one*rhoid/temp14**2
        call popreal8(w(i, je, k, irhoe))
        pd(i, je, k) = pd(i, je, k) - wd(i, je, k, irhoe)
        call popreal8(w(i, je, k, ivz))
        rhoid = w(i, je, k, ivz)*wd(i, je, k, ivz)
        wd(i, je, k, ivz) = rhoi*wd(i, je, k, ivz)
        call popreal8(w(i, je, k, ivy))
        rhoid = rhoid + w(i, je, k, ivy)*wd(i, je, k, ivy)
        wd(i, je, k, ivy) = rhoi*wd(i, je, k, ivy)
        call popreal8(w(i, je, k, ivx))
        rhoid = rhoid + w(i, je, k, ivx)*wd(i, je, k, ivx)
        wd(i, je, k, ivx) = rhoi*wd(i, je, k, ivx)
        call popreal8(rhoi)
        temp13 = w(i, je, k, irho)
        wd(i, je, k, irho) = wd(i, je, k, irho) - one*rhoid/temp13**2
        call popreal8(w(i, 1, k, irhoe))
        pd(i, 1, k) = pd(i, 1, k) - wd(i, 1, k, irhoe)
        call popreal8(w(i, 1, k, ivz))
        rhoid = w(i, 1, k, ivz)*wd(i, 1, k, ivz)
        wd(i, 1, k, ivz) = rhoi*wd(i, 1, k, ivz)
        call popreal8(w(i, 1, k, ivy))
        rhoid = rhoid + w(i, 1, k, ivy)*wd(i, 1, k, ivy)
        wd(i, 1, k, ivy) = rhoi*wd(i, 1, k, ivy)
        call popreal8(w(i, 1, k, ivx))
        rhoid = rhoid + w(i, 1, k, ivx)*wd(i, 1, k, ivx)
        wd(i, 1, k, ivx) = rhoi*wd(i, 1, k, ivx)
        call popreal8(rhoi)
        temp12 = w(i, 1, k, irho)
        wd(i, 1, k, irho) = wd(i, 1, k, irho) - one*rhoid/temp12**2
        call popreal8(w(i, 0, k, irhoe))
        pd(i, 0, k) = pd(i, 0, k) - wd(i, 0, k, irhoe)
        call popreal8(w(i, 0, k, ivz))
        rhoid = w(i, 0, k, ivz)*wd(i, 0, k, ivz)
        wd(i, 0, k, ivz) = rhoi*wd(i, 0, k, ivz)
        call popreal8(w(i, 0, k, ivy))
        rhoid = rhoid + w(i, 0, k, ivy)*wd(i, 0, k, ivy)
        wd(i, 0, k, ivy) = rhoi*wd(i, 0, k, ivy)
        call popreal8(w(i, 0, k, ivx))
        rhoid = rhoid + w(i, 0, k, ivx)*wd(i, 0, k, ivx)
        wd(i, 0, k, ivx) = rhoi*wd(i, 0, k, ivx)
        call popreal8(rhoi)
        temp11 = w(i, 0, k, irho)
        wd(i, 0, k, irho) = wd(i, 0, k, irho) - one*rhoid/temp11**2
      end do
    end do
    do k=kl,2,-1
      do j=jl,2,-1
        call popreal8(w(ib, j, k, irhoe))
        pd(ib, j, k) = pd(ib, j, k) - wd(ib, j, k, irhoe)
        call popreal8(w(ib, j, k, ivz))
        rhoid = w(ib, j, k, ivz)*wd(ib, j, k, ivz)
        wd(ib, j, k, ivz) = rhoi*wd(ib, j, k, ivz)
        call popreal8(w(ib, j, k, ivy))
        rhoid = rhoid + w(ib, j, k, ivy)*wd(ib, j, k, ivy)
        wd(ib, j, k, ivy) = rhoi*wd(ib, j, k, ivy)
        call popreal8(w(ib, j, k, ivx))
        rhoid = rhoid + w(ib, j, k, ivx)*wd(ib, j, k, ivx)
        wd(ib, j, k, ivx) = rhoi*wd(ib, j, k, ivx)
        call popreal8(rhoi)
        temp10 = w(ib, j, k, irho)
        wd(ib, j, k, irho) = wd(ib, j, k, irho) - one*rhoid/temp10**2
        call popreal8(w(ie, j, k, irhoe))
        pd(ie, j, k) = pd(ie, j, k) - wd(ie, j, k, irhoe)
        call popreal8(w(ie, j, k, ivz))
        rhoid = w(ie, j, k, ivz)*wd(ie, j, k, ivz)
        wd(ie, j, k, ivz) = rhoi*wd(ie, j, k, ivz)
        call popreal8(w(ie, j, k, ivy))
        rhoid = rhoid + w(ie, j, k, ivy)*wd(ie, j, k, ivy)
        wd(ie, j, k, ivy) = rhoi*wd(ie, j, k, ivy)
        call popreal8(w(ie, j, k, ivx))
        rhoid = rhoid + w(ie, j, k, ivx)*wd(ie, j, k, ivx)
        wd(ie, j, k, ivx) = rhoi*wd(ie, j, k, ivx)
        call popreal8(rhoi)
        temp9 = w(ie, j, k, irho)
        wd(ie, j, k, irho) = wd(ie, j, k, irho) - one*rhoid/temp9**2
        call popreal8(w(1, j, k, irhoe))
        pd(1, j, k) = pd(1, j, k) - wd(1, j, k, irhoe)
        call popreal8(w(1, j, k, ivz))
        rhoid = w(1, j, k, ivz)*wd(1, j, k, ivz)
        wd(1, j, k, ivz) = rhoi*wd(1, j, k, ivz)
        call popreal8(w(1, j, k, ivy))
        rhoid = rhoid + w(1, j, k, ivy)*wd(1, j, k, ivy)
        wd(1, j, k, ivy) = rhoi*wd(1, j, k, ivy)
        call popreal8(w(1, j, k, ivx))
        rhoid = rhoid + w(1, j, k, ivx)*wd(1, j, k, ivx)
        wd(1, j, k, ivx) = rhoi*wd(1, j, k, ivx)
        call popreal8(rhoi)
        temp8 = w(1, j, k, irho)
        wd(1, j, k, irho) = wd(1, j, k, irho) - one*rhoid/temp8**2
        call popreal8(w(0, j, k, irhoe))
        pd(0, j, k) = pd(0, j, k) - wd(0, j, k, irhoe)
        call popreal8(w(0, j, k, ivz))
        rhoid = w(0, j, k, ivz)*wd(0, j, k, ivz)
        wd(0, j, k, ivz) = rhoi*wd(0, j, k, ivz)
        call popreal8(w(0, j, k, ivy))
        rhoid = rhoid + w(0, j, k, ivy)*wd(0, j, k, ivy)
        wd(0, j, k, ivy) = rhoi*wd(0, j, k, ivy)
        call popreal8(w(0, j, k, ivx))
        rhoid = rhoid + w(0, j, k, ivx)*wd(0, j, k, ivx)
        wd(0, j, k, ivx) = rhoi*wd(0, j, k, ivx)
        call popreal8(rhoi)
        temp7 = w(0, j, k, irho)
        wd(0, j, k, irho) = wd(0, j, k, irho) - one*rhoid/temp7**2
      end do
    end do
    do k=kb,0,-1
      do j=jl,2,-1
        do i=il,2,-1
          call popreal8(w(i, j, k, irhoe))
          pd(i, j, k) = pd(i, j, k) - wd(i, j, k, irhoe)
          call popreal8(w(i, j, k, ivz))
          rhoid = w(i, j, k, ivz)*wd(i, j, k, ivz)
          wd(i, j, k, ivz) = rhoi*wd(i, j, k, ivz)
          call popreal8(w(i, j, k, ivy))
          rhoid = rhoid + w(i, j, k, ivy)*wd(i, j, k, ivy)
          wd(i, j, k, ivy) = rhoi*wd(i, j, k, ivy)
          call popreal8(w(i, j, k, ivx))
          rhoid = rhoid + w(i, j, k, ivx)*wd(i, j, k, ivx)
          wd(i, j, k, ivx) = rhoi*wd(i, j, k, ivx)
          call popreal8(rhoi)
          temp6 = w(i, j, k, irho)
          wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp6**2
        end do
      end do
    end do
    radkd = 0.0_8
    sslimd = 0.0_8
    do j=jl,2,-1
      do i=il,2,-1
        dss1d = 0.0_8
        do k=kl,1,-1
          dss2d = dss1d
          fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
          ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
          dis2 = fis2*rrad*min3 + sigma*fis4*rrad
          dis2d = ddw*fsd
          ddwd = dis2*fsd
          wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
          ddw = w(i, j, k+1, ivz) - w(i, j, k, ivz)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddwd
          fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
          ddw = w(i, j, k+1, ivy) - w(i, j, k, ivy)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddwd
          fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
          ddw = w(i, j, k+1, ivx) - w(i, j, k, ivx)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddwd
          fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          rradd = (sigma*fis4+fis2*min3)*dis2d
          min3d = fis2*rrad*dis2d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(min3)
            y3d = min3d
          else
            call popreal8(min3)
            y3d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dss2d = dss2d + y3d
            dss1d = 0.0_8
          else
            dss1d = y3d
          end if
          radkd(i, j, k) = radkd(i, j, k) + ppor*rradd
          radkd(i, j, k+1) = radkd(i, j, k+1) + ppor*rradd
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x6d = dss2d
          else
            x6d = -dss2d
          end if
          temp5 = shocksensor(i, j, k+2) + two*shocksensor(i, j, k+1) + &
&           shocksensor(i, j, k) + sslim
          sslimd = sslimd - (shocksensor(i, j, k+2)-two*shocksensor(i, j&
&           , k+1)+shocksensor(i, j, k))*x6d/temp5**2
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x5d = dss1d
        else
          x5d = -dss1d
        end if
        temp4 = shocksensor(i, j, 2) + two*shocksensor(i, j, 1) + &
&         shocksensor(i, j, 0) + sslim
        sslimd = sslimd - (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)&
&         +shocksensor(i, j, 0))*x5d/temp4**2
      end do
    end do
    radjd = 0.0_8
    do k=kl,2,-1
      do i=il,2,-1
        dss1d = 0.0_8
        do j=jl,1,-1
          dss2d = dss1d
          fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
          ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
          dis2 = fis2*rrad*min2 + sigma*fis4*rrad
          dis2d = ddw*fsd
          ddwd = dis2*fsd
          wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
          ddw = w(i, j+1, k, ivz) - w(i, j, k, ivz)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddwd
          fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
          ddw = w(i, j+1, k, ivy) - w(i, j, k, ivy)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddwd
          fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
          ddw = w(i, j+1, k, ivx) - w(i, j, k, ivx)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddwd
          fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          rradd = (sigma*fis4+fis2*min2)*dis2d
          min2d = fis2*rrad*dis2d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(min2)
            y2d = min2d
          else
            call popreal8(min2)
            y2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dss2d = dss2d + y2d
            dss1d = 0.0_8
          else
            dss1d = y2d
          end if
          radjd(i, j, k) = radjd(i, j, k) + ppor*rradd
          radjd(i, j+1, k) = radjd(i, j+1, k) + ppor*rradd
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x4d = dss2d
          else
            x4d = -dss2d
          end if
          temp3 = shocksensor(i, j+2, k) + two*shocksensor(i, j+1, k) + &
&           shocksensor(i, j, k) + sslim
          sslimd = sslimd - (shocksensor(i, j+2, k)-two*shocksensor(i, j&
&           +1, k)+shocksensor(i, j, k))*x4d/temp3**2
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x3d = dss1d
        else
          x3d = -dss1d
        end if
        temp2 = shocksensor(i, 2, k) + two*shocksensor(i, 1, k) + &
&         shocksensor(i, 0, k) + sslim
        sslimd = sslimd - (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)&
&         +shocksensor(i, 0, k))*x3d/temp2**2
      end do
    end do
    radid = 0.0_8
    do k=kl,2,-1
      do j=jl,2,-1
        dss1d = 0.0_8
        do i=il,1,-1
          dss2d = dss1d
          fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
          ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
          dis2 = fis2*rrad*min1 + sigma*fis4*rrad
          dis2d = ddw*fsd
          ddwd = dis2*fsd
          wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
          ddw = w(i+1, j, k, ivz) - w(i, j, k, ivz)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddwd
          fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
          ddw = w(i+1, j, k, ivy) - w(i, j, k, ivy)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddwd
          fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
          ddw = w(i+1, j, k, ivx) - w(i, j, k, ivx)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddwd
          fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          dis2d = dis2d + ddw*fsd
          ddwd = dis2*fsd
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          rradd = (sigma*fis4+fis2*min1)*dis2d
          min1d = fis2*rrad*dis2d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(min1)
            y1d = min1d
          else
            call popreal8(min1)
            y1d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dss2d = dss2d + y1d
            dss1d = 0.0_8
          else
            dss1d = y1d
          end if
          radid(i, j, k) = radid(i, j, k) + ppor*rradd
          radid(i+1, j, k) = radid(i+1, j, k) + ppor*rradd
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x2d = dss2d
          else
            x2d = -dss2d
          end if
          temp1 = shocksensor(i+2, j, k) + two*shocksensor(i+1, j, k) + &
&           shocksensor(i, j, k) + sslim
          sslimd = sslimd - (shocksensor(i+2, j, k)-two*shocksensor(i+1&
&           , j, k)+shocksensor(i, j, k))*x2d/temp1**2
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x1d = dss1d
        else
          x1d = -dss1d
        end if
        temp0 = shocksensor(2, j, k) + two*shocksensor(1, j, k) + &
&         shocksensor(0, j, k) + sslim
        sslimd = sslimd - (shocksensor(2, j, k)-two*shocksensor(1, j, k)&
&         +shocksensor(0, j, k))*x1d/temp0**2
      end do
    end do
    do k=kl,2,-1
      do i=il,2,-1
        call popreal8(w(i, jb, k, irhoe))
        pd(i, jb, k) = pd(i, jb, k) + wd(i, jb, k, irhoe)
        call popreal8(w(i, jb, k, ivz))
        tmpd14 = wd(i, jb, k, ivz)
        wd(i, jb, k, ivz) = 0.0_8
        wd(i, jb, k, irho) = wd(i, jb, k, irho) + w(i, jb, k, ivz)*&
&         tmpd14
        wd(i, jb, k, ivz) = wd(i, jb, k, ivz) + w(i, jb, k, irho)*tmpd14
        call popreal8(w(i, jb, k, ivy))
        tmpd15 = wd(i, jb, k, ivy)
        wd(i, jb, k, ivy) = 0.0_8
        wd(i, jb, k, irho) = wd(i, jb, k, irho) + w(i, jb, k, ivy)*&
&         tmpd15
        wd(i, jb, k, ivy) = wd(i, jb, k, ivy) + w(i, jb, k, irho)*tmpd15
        call popreal8(w(i, jb, k, ivx))
        tmpd16 = wd(i, jb, k, ivx)
        wd(i, jb, k, ivx) = 0.0_8
        wd(i, jb, k, irho) = wd(i, jb, k, irho) + w(i, jb, k, ivx)*&
&         tmpd16
        wd(i, jb, k, ivx) = wd(i, jb, k, ivx) + w(i, jb, k, irho)*tmpd16
        call popreal8(w(i, je, k, irhoe))
        pd(i, je, k) = pd(i, je, k) + wd(i, je, k, irhoe)
        call popreal8(w(i, je, k, ivz))
        tmpd17 = wd(i, je, k, ivz)
        wd(i, je, k, ivz) = 0.0_8
        wd(i, je, k, irho) = wd(i, je, k, irho) + w(i, je, k, ivz)*&
&         tmpd17
        wd(i, je, k, ivz) = wd(i, je, k, ivz) + w(i, je, k, irho)*tmpd17
        call popreal8(w(i, je, k, ivy))
        tmpd18 = wd(i, je, k, ivy)
        wd(i, je, k, ivy) = 0.0_8
        wd(i, je, k, irho) = wd(i, je, k, irho) + w(i, je, k, ivy)*&
&         tmpd18
        wd(i, je, k, ivy) = wd(i, je, k, ivy) + w(i, je, k, irho)*tmpd18
        call popreal8(w(i, je, k, ivx))
        tmpd19 = wd(i, je, k, ivx)
        wd(i, je, k, ivx) = 0.0_8
        wd(i, je, k, irho) = wd(i, je, k, irho) + w(i, je, k, ivx)*&
&         tmpd19
        wd(i, je, k, ivx) = wd(i, je, k, ivx) + w(i, je, k, irho)*tmpd19
        call popreal8(w(i, 1, k, irhoe))
        pd(i, 1, k) = pd(i, 1, k) + wd(i, 1, k, irhoe)
        call popreal8(w(i, 1, k, ivz))
        tmpd20 = wd(i, 1, k, ivz)
        wd(i, 1, k, ivz) = 0.0_8
        wd(i, 1, k, irho) = wd(i, 1, k, irho) + w(i, 1, k, ivz)*tmpd20
        wd(i, 1, k, ivz) = wd(i, 1, k, ivz) + w(i, 1, k, irho)*tmpd20
        call popreal8(w(i, 1, k, ivy))
        tmpd21 = wd(i, 1, k, ivy)
        wd(i, 1, k, ivy) = 0.0_8
        wd(i, 1, k, irho) = wd(i, 1, k, irho) + w(i, 1, k, ivy)*tmpd21
        wd(i, 1, k, ivy) = wd(i, 1, k, ivy) + w(i, 1, k, irho)*tmpd21
        call popreal8(w(i, 1, k, ivx))
        tmpd22 = wd(i, 1, k, ivx)
        wd(i, 1, k, ivx) = 0.0_8
        wd(i, 1, k, irho) = wd(i, 1, k, irho) + w(i, 1, k, ivx)*tmpd22
        wd(i, 1, k, ivx) = wd(i, 1, k, ivx) + w(i, 1, k, irho)*tmpd22
        call popreal8(w(i, 0, k, irhoe))
        pd(i, 0, k) = pd(i, 0, k) + wd(i, 0, k, irhoe)
        call popreal8(w(i, 0, k, ivz))
        tmpd23 = wd(i, 0, k, ivz)
        wd(i, 0, k, ivz) = 0.0_8
        wd(i, 0, k, irho) = wd(i, 0, k, irho) + w(i, 0, k, ivz)*tmpd23
        wd(i, 0, k, ivz) = wd(i, 0, k, ivz) + w(i, 0, k, irho)*tmpd23
        call popreal8(w(i, 0, k, ivy))
        tmpd24 = wd(i, 0, k, ivy)
        wd(i, 0, k, ivy) = 0.0_8
        wd(i, 0, k, irho) = wd(i, 0, k, irho) + w(i, 0, k, ivy)*tmpd24
        wd(i, 0, k, ivy) = wd(i, 0, k, ivy) + w(i, 0, k, irho)*tmpd24
        call popreal8(w(i, 0, k, ivx))
        tmpd25 = wd(i, 0, k, ivx)
        wd(i, 0, k, ivx) = 0.0_8
        wd(i, 0, k, irho) = wd(i, 0, k, irho) + w(i, 0, k, ivx)*tmpd25
        wd(i, 0, k, ivx) = wd(i, 0, k, ivx) + w(i, 0, k, irho)*tmpd25
      end do
    end do
    do k=kl,2,-1
      do j=jl,2,-1
        call popreal8(w(ib, j, k, irhoe))
        pd(ib, j, k) = pd(ib, j, k) + wd(ib, j, k, irhoe)
        call popreal8(w(ib, j, k, ivz))
        tmpd2 = wd(ib, j, k, ivz)
        wd(ib, j, k, ivz) = 0.0_8
        wd(ib, j, k, irho) = wd(ib, j, k, irho) + w(ib, j, k, ivz)*tmpd2
        wd(ib, j, k, ivz) = wd(ib, j, k, ivz) + w(ib, j, k, irho)*tmpd2
        call popreal8(w(ib, j, k, ivy))
        tmpd3 = wd(ib, j, k, ivy)
        wd(ib, j, k, ivy) = 0.0_8
        wd(ib, j, k, irho) = wd(ib, j, k, irho) + w(ib, j, k, ivy)*tmpd3
        wd(ib, j, k, ivy) = wd(ib, j, k, ivy) + w(ib, j, k, irho)*tmpd3
        call popreal8(w(ib, j, k, ivx))
        tmpd4 = wd(ib, j, k, ivx)
        wd(ib, j, k, ivx) = 0.0_8
        wd(ib, j, k, irho) = wd(ib, j, k, irho) + w(ib, j, k, ivx)*tmpd4
        wd(ib, j, k, ivx) = wd(ib, j, k, ivx) + w(ib, j, k, irho)*tmpd4
        call popreal8(w(ie, j, k, irhoe))
        pd(ie, j, k) = pd(ie, j, k) + wd(ie, j, k, irhoe)
        call popreal8(w(ie, j, k, ivz))
        tmpd5 = wd(ie, j, k, ivz)
        wd(ie, j, k, ivz) = 0.0_8
        wd(ie, j, k, irho) = wd(ie, j, k, irho) + w(ie, j, k, ivz)*tmpd5
        wd(ie, j, k, ivz) = wd(ie, j, k, ivz) + w(ie, j, k, irho)*tmpd5
        call popreal8(w(ie, j, k, ivy))
        tmpd6 = wd(ie, j, k, ivy)
        wd(ie, j, k, ivy) = 0.0_8
        wd(ie, j, k, irho) = wd(ie, j, k, irho) + w(ie, j, k, ivy)*tmpd6
        wd(ie, j, k, ivy) = wd(ie, j, k, ivy) + w(ie, j, k, irho)*tmpd6
        call popreal8(w(ie, j, k, ivx))
        tmpd7 = wd(ie, j, k, ivx)
        wd(ie, j, k, ivx) = 0.0_8
        wd(ie, j, k, irho) = wd(ie, j, k, irho) + w(ie, j, k, ivx)*tmpd7
        wd(ie, j, k, ivx) = wd(ie, j, k, ivx) + w(ie, j, k, irho)*tmpd7
        call popreal8(w(1, j, k, irhoe))
        pd(1, j, k) = pd(1, j, k) + wd(1, j, k, irhoe)
        call popreal8(w(1, j, k, ivz))
        tmpd8 = wd(1, j, k, ivz)
        wd(1, j, k, ivz) = 0.0_8
        wd(1, j, k, irho) = wd(1, j, k, irho) + w(1, j, k, ivz)*tmpd8
        wd(1, j, k, ivz) = wd(1, j, k, ivz) + w(1, j, k, irho)*tmpd8
        call popreal8(w(1, j, k, ivy))
        tmpd9 = wd(1, j, k, ivy)
        wd(1, j, k, ivy) = 0.0_8
        wd(1, j, k, irho) = wd(1, j, k, irho) + w(1, j, k, ivy)*tmpd9
        wd(1, j, k, ivy) = wd(1, j, k, ivy) + w(1, j, k, irho)*tmpd9
        call popreal8(w(1, j, k, ivx))
        tmpd10 = wd(1, j, k, ivx)
        wd(1, j, k, ivx) = 0.0_8
        wd(1, j, k, irho) = wd(1, j, k, irho) + w(1, j, k, ivx)*tmpd10
        wd(1, j, k, ivx) = wd(1, j, k, ivx) + w(1, j, k, irho)*tmpd10
        call popreal8(w(0, j, k, irhoe))
        pd(0, j, k) = pd(0, j, k) + wd(0, j, k, irhoe)
        call popreal8(w(0, j, k, ivz))
        tmpd11 = wd(0, j, k, ivz)
        wd(0, j, k, ivz) = 0.0_8
        wd(0, j, k, irho) = wd(0, j, k, irho) + w(0, j, k, ivz)*tmpd11
        wd(0, j, k, ivz) = wd(0, j, k, ivz) + w(0, j, k, irho)*tmpd11
        call popreal8(w(0, j, k, ivy))
        tmpd12 = wd(0, j, k, ivy)
        wd(0, j, k, ivy) = 0.0_8
        wd(0, j, k, irho) = wd(0, j, k, irho) + w(0, j, k, ivy)*tmpd12
        wd(0, j, k, ivy) = wd(0, j, k, ivy) + w(0, j, k, irho)*tmpd12
        call popreal8(w(0, j, k, ivx))
        tmpd13 = wd(0, j, k, ivx)
        wd(0, j, k, ivx) = 0.0_8
        wd(0, j, k, irho) = wd(0, j, k, irho) + w(0, j, k, ivx)*tmpd13
        wd(0, j, k, ivx) = wd(0, j, k, ivx) + w(0, j, k, irho)*tmpd13
      end do
    end do
    do k=kb,0,-1
      do j=jl,2,-1
        do i=il,2,-1
          call popreal8(w(i, j, k, irhoe))
          pd(i, j, k) = pd(i, j, k) + wd(i, j, k, irhoe)
          call popreal8(w(i, j, k, ivz))
          tmpd = wd(i, j, k, ivz)
          wd(i, j, k, ivz) = 0.0_8
          wd(i, j, k, irho) = wd(i, j, k, irho) + w(i, j, k, ivz)*tmpd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + w(i, j, k, irho)*tmpd
          call popreal8(w(i, j, k, ivy))
          tmpd0 = wd(i, j, k, ivy)
          wd(i, j, k, ivy) = 0.0_8
          wd(i, j, k, irho) = wd(i, j, k, irho) + w(i, j, k, ivy)*tmpd0
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + w(i, j, k, irho)*tmpd0
          call popreal8(w(i, j, k, ivx))
          tmpd1 = wd(i, j, k, ivx)
          wd(i, j, k, ivx) = 0.0_8
          wd(i, j, k, irho) = wd(i, j, k, irho) + w(i, j, k, ivx)*tmpd1
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + w(i, j, k, irho)*tmpd1
        end do
      end do
    end do
    call popcontrol2b(branch)
    if (branch .eq. 0) then
      rhoinfd = 0.0_8
      pinfcorrd = 0.0_8
    else if (branch .eq. 1) then
      pinfcorrd = 0.001_realtype*sslimd
      rhoinfd = 0.0_8
    else
      temp = rhoinf**gammainf
      tempd = 0.001_realtype*sslimd/temp
      tempd0 = -(pinfcorr*tempd/temp)
      pinfcorrd = tempd
      if (rhoinf .le. 0.0_8 .and. (gammainf .eq. 0.0_8 .or. gammainf &
&         .ne. int(gammainf))) then
        rhoinfd = 0.0
      else
        rhoinfd = gammainf*rhoinf**(gammainf-1)*tempd0
      end if
      if (.not.rhoinf .le. 0.0_8) gammainfd = gammainfd + temp*log(&
&         rhoinf)*tempd0
    end if
  end if
end subroutine invisciddissfluxscalarapprox_b

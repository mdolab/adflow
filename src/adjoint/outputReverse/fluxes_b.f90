!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module fluxes_b
  implicit none
! ----------------------------------------------------------------------
!                                                                      |
!                    no tapenade routine below this line               |
!                                                                      |
! ----------------------------------------------------------------------

contains
!  differentiation of inviscidcentralflux in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: timeref *p *dw *w *vol *si
!                *sj *sk
!   with respect to varying inputs: timeref *p *dw *w *vol *si
!                *sj *sk
!   rw status of diff variables: timeref:incr *p:incr *dw:in-out
!                *w:incr *vol:incr *si:incr *sj:incr *sk:incr
!   plus diff mem management of: p:in dw:in w:in vol:in si:in sj:in
!                sk:in
  subroutine inviscidcentralflux_b()
!
!       inviscidcentralflux computes the euler fluxes using a central
!       discretization for a given block. therefore it is assumed that
!       the pointers in block pointer already point to the correct
!       block on the correct multigrid level.
!
    use constants
    use blockpointers, only : nx, il, ie, ny, jl, je, nz, kl, ke, &
&   spectralsol, w, wd, si, sid, sj, sjd, sk, skd, dw, dwd, pori, porj, &
&   pork, indfamilyi, indfamilyj, indfamilyk, p, pd, sfacei, sfacej, &
&   sfacek, nbkglobal, addgridvelocities, blockismoving, vol, vold, &
&   factfamilyi, factfamilyj, factfamilyk
    use cgnsgrid, only : cgnsdoms, massflowfamilyinv
    use flowvarrefstate, only : timeref, timerefd
    use inputphysics, only : equationmode
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: qsp, qsm, rqsp, rqsm, porvel, porflux
    real(kind=realtype) :: qspd, qsmd, rqspd, rqsmd
    real(kind=realtype) :: pa, fs, sface, vnp, vnm
    real(kind=realtype) :: pad, fsd, vnpd, vnmd
    real(kind=realtype) :: wwx, wwy, wwz, rvol
    real(kind=realtype) :: wwxd, wwyd, wwzd, rvold
    intrinsic mod
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp4
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8(vnm)
    call pushreal8(vnp)
    call pushreal8(porflux)
    call pushreal8(porvel)
    call pushreal8(qsm)
    call pushreal8(qsp)
    call pushinteger4(i)
    call pushinteger4(j)
    call pushreal8(vnm)
    call pushreal8(vnp)
    call pushreal8(porflux)
    call pushreal8(porvel)
    call pushreal8(qsm)
    call pushreal8(qsp)
    call pushinteger4(i)
    call pushinteger4(j)
    if (blockismoving .and. equationmode .eq. steady) then
! compute the three nondimensional angular velocities.
      wwx = timeref*cgnsdoms(nbkglobal)%rotrate(1)
      wwy = timeref*cgnsdoms(nbkglobal)%rotrate(2)
      wwz = timeref*cgnsdoms(nbkglobal)%rotrate(3)
      wwxd = 0.0_8
      wwyd = 0.0_8
      wwzd = 0.0_8
      do ii=0,nx*ny*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 2
        rvol = w(i, j, k, irho)*vol(i, j, k)
        temp4 = w(i, j, k, ivx)
        temp3 = w(i, j, k, ivy)
        tempd2 = rvol*dwd(i, j, k, imz)
        rvold = (wwx*temp3-wwy*temp4)*dwd(i, j, k, imz)
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + wwx*tempd2
        wd(i, j, k, ivx) = wd(i, j, k, ivx) - wwy*tempd2
        temp2 = w(i, j, k, ivz)
        temp1 = w(i, j, k, ivx)
        tempd3 = rvol*dwd(i, j, k, imy)
        wwxd = wwxd + temp3*tempd2 - temp2*tempd3
        rvold = rvold + (wwz*temp1-wwx*temp2)*dwd(i, j, k, imy)
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + wwz*tempd3
        wd(i, j, k, ivz) = wd(i, j, k, ivz) - wwx*tempd3
        temp0 = w(i, j, k, ivy)
        temp = w(i, j, k, ivz)
        tempd4 = rvol*dwd(i, j, k, imx)
        wwyd = wwyd + temp*tempd4 - temp4*tempd2
        wwzd = wwzd + temp1*tempd3 - temp0*tempd4
        rvold = rvold + (wwy*temp-wwz*temp0)*dwd(i, j, k, imx)
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + wwy*tempd4
        wd(i, j, k, ivy) = wd(i, j, k, ivy) - wwz*tempd4
        wd(i, j, k, irho) = wd(i, j, k, irho) + vol(i, j, k)*rvold
        vold(i, j, k) = vold(i, j, k) + w(i, j, k, irho)*rvold
      end do
      timerefd = timerefd + cgnsdoms(nbkglobal)%rotrate(2)*wwyd + &
&       cgnsdoms(nbkglobal)%rotrate(1)*wwxd + cgnsdoms(nbkglobal)%&
&       rotrate(3)*wwzd
    end if
    call popinteger4(j)
    call popinteger4(i)
    sface = zero
    do ii=0,nx*ny*kl-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 1
! set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
      if (addgridvelocities) sface = sfacek(i, j, k)
! compute the normal velocities of the left and right state.
      vnp = w(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivy)*sk(i, j&
&       , k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 3)
      vnm = w(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivy)*sk(i, j, k&
&       , 2) + w(i, j, k, ivz)*sk(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! block boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
      porvel = one
      porflux = half
      if (pork(i, j, k) .eq. noflux) porflux = zero
      if (pork(i, j, k) .eq. boundflux) then
        porvel = zero
        vnp = sface
        vnm = sface
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! incorporate porflux in porvel.
      porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
      qsp = (vnp-sface)*porvel
      qsm = (vnm-sface)*porvel
      rqsp = qsp*w(i, j, k+1, irho)
      rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
      pa = porflux*(p(i, j, k+1)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j,k+1. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
      fsd = dwd(i, j, k, irhoe) - dwd(i, j, k+1, irhoe)
      tempd1 = porflux*fsd
      qspd = w(i, j, k+1, irhoe)*fsd
      wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + qsp*fsd
      qsmd = w(i, j, k, irhoe)*fsd
      wd(i, j, k, irhoe) = wd(i, j, k, irhoe) + qsm*fsd
      pd(i, j, k+1) = pd(i, j, k+1) + vnp*tempd1
      pd(i, j, k) = pd(i, j, k) + vnm*tempd1
      fsd = dwd(i, j, k, imz) - dwd(i, j, k+1, imz)
      rqspd = w(i, j, k+1, ivz)*fsd
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + rqsp*fsd
      rqsmd = w(i, j, k, ivz)*fsd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + rqsm*fsd
      pad = sk(i, j, k, 3)*fsd
      skd(i, j, k, 3) = skd(i, j, k, 3) + pa*fsd
      fsd = dwd(i, j, k, imy) - dwd(i, j, k+1, imy)
      rqspd = rqspd + w(i, j, k+1, ivy)*fsd
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + rqsp*fsd
      rqsmd = rqsmd + w(i, j, k, ivy)*fsd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + rqsm*fsd
      pad = pad + sk(i, j, k, 2)*fsd
      skd(i, j, k, 2) = skd(i, j, k, 2) + pa*fsd
      fsd = dwd(i, j, k, imx) - dwd(i, j, k+1, imx)
      rqspd = rqspd + w(i, j, k+1, ivx)*fsd
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + rqsp*fsd
      rqsmd = rqsmd + w(i, j, k, ivx)*fsd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + rqsm*fsd
      pad = pad + sk(i, j, k, 1)*fsd
      skd(i, j, k, 1) = skd(i, j, k, 1) + pa*fsd
      fsd = dwd(i, j, k, irho) - dwd(i, j, k+1, irho)
      rqspd = rqspd + fsd
      rqsmd = rqsmd + fsd
      pd(i, j, k+1) = pd(i, j, k+1) + porflux*pad
      pd(i, j, k) = pd(i, j, k) + porflux*pad
      qsmd = qsmd + w(i, j, k, irho)*rqsmd
      vnmd = porvel*qsmd + p(i, j, k)*tempd1
      wd(i, j, k, irho) = wd(i, j, k, irho) + qsm*rqsmd
      qspd = qspd + w(i, j, k+1, irho)*rqspd
      vnpd = porvel*qspd + p(i, j, k+1)*tempd1
      wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + qsp*rqspd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        vnmd = 0.0_8
        vnpd = 0.0_8
      end if
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + sk(i, j, k, 1)*vnmd
      skd(i, j, k, 1) = skd(i, j, k, 1) + w(i, j, k, ivx)*vnmd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + sk(i, j, k, 2)*vnmd
      skd(i, j, k, 2) = skd(i, j, k, 2) + w(i, j, k, ivy)*vnmd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + sk(i, j, k, 3)*vnmd
      skd(i, j, k, 3) = skd(i, j, k, 3) + w(i, j, k, ivz)*vnmd
      wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + sk(i, j, k, 1)*vnpd
      skd(i, j, k, 1) = skd(i, j, k, 1) + w(i, j, k+1, ivx)*vnpd
      wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + sk(i, j, k, 2)*vnpd
      skd(i, j, k, 2) = skd(i, j, k, 2) + w(i, j, k+1, ivy)*vnpd
      wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + sk(i, j, k, 3)*vnpd
      skd(i, j, k, 3) = skd(i, j, k, 3) + w(i, j, k+1, ivz)*vnpd
    end do
    call popreal8(qsp)
    call popreal8(qsm)
    call popreal8(porvel)
    call popreal8(porflux)
    call popreal8(vnp)
    call popreal8(vnm)
    call popinteger4(j)
    call popinteger4(i)
    sface = zero
    do ii=0,nx*jl*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, jl) + 1
      k = ii/(nx*jl) + 2
! set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
      if (addgridvelocities) sface = sfacej(i, j, k)
! compute the normal velocities of the left and right state.
      vnp = w(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivy)*sj(i, j&
&       , k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 3)
      vnm = w(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivy)*sj(i, j, k&
&       , 2) + w(i, j, k, ivz)*sj(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
      porvel = one
      porflux = half
      if (porj(i, j, k) .eq. noflux) porflux = zero
      if (porj(i, j, k) .eq. boundflux) then
        porvel = zero
        vnp = sface
        vnm = sface
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! incorporate porflux in porvel.
      porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
      qsp = (vnp-sface)*porvel
      qsm = (vnm-sface)*porvel
      rqsp = qsp*w(i, j+1, k, irho)
      rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
      pa = porflux*(p(i, j+1, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j+1,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
      fsd = dwd(i, j, k, irhoe) - dwd(i, j+1, k, irhoe)
      tempd0 = porflux*fsd
      qspd = w(i, j+1, k, irhoe)*fsd
      wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + qsp*fsd
      qsmd = w(i, j, k, irhoe)*fsd
      wd(i, j, k, irhoe) = wd(i, j, k, irhoe) + qsm*fsd
      pd(i, j+1, k) = pd(i, j+1, k) + vnp*tempd0
      pd(i, j, k) = pd(i, j, k) + vnm*tempd0
      fsd = dwd(i, j, k, imz) - dwd(i, j+1, k, imz)
      rqspd = w(i, j+1, k, ivz)*fsd
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + rqsp*fsd
      rqsmd = w(i, j, k, ivz)*fsd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + rqsm*fsd
      pad = sj(i, j, k, 3)*fsd
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + pa*fsd
      fsd = dwd(i, j, k, imy) - dwd(i, j+1, k, imy)
      rqspd = rqspd + w(i, j+1, k, ivy)*fsd
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + rqsp*fsd
      rqsmd = rqsmd + w(i, j, k, ivy)*fsd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + rqsm*fsd
      pad = pad + sj(i, j, k, 2)*fsd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + pa*fsd
      fsd = dwd(i, j, k, imx) - dwd(i, j+1, k, imx)
      rqspd = rqspd + w(i, j+1, k, ivx)*fsd
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + rqsp*fsd
      rqsmd = rqsmd + w(i, j, k, ivx)*fsd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + rqsm*fsd
      pad = pad + sj(i, j, k, 1)*fsd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + pa*fsd
      fsd = dwd(i, j, k, irho) - dwd(i, j+1, k, irho)
      rqspd = rqspd + fsd
      rqsmd = rqsmd + fsd
      pd(i, j+1, k) = pd(i, j+1, k) + porflux*pad
      pd(i, j, k) = pd(i, j, k) + porflux*pad
      qsmd = qsmd + w(i, j, k, irho)*rqsmd
      vnmd = porvel*qsmd + p(i, j, k)*tempd0
      wd(i, j, k, irho) = wd(i, j, k, irho) + qsm*rqsmd
      qspd = qspd + w(i, j+1, k, irho)*rqspd
      vnpd = porvel*qspd + p(i, j+1, k)*tempd0
      wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + qsp*rqspd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        vnmd = 0.0_8
        vnpd = 0.0_8
      end if
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + sj(i, j, k, 1)*vnmd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + w(i, j, k, ivx)*vnmd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + sj(i, j, k, 2)*vnmd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + w(i, j, k, ivy)*vnmd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + sj(i, j, k, 3)*vnmd
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + w(i, j, k, ivz)*vnmd
      wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + sj(i, j, k, 1)*vnpd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + w(i, j+1, k, ivx)*vnpd
      wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + sj(i, j, k, 2)*vnpd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + w(i, j+1, k, ivy)*vnpd
      wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + sj(i, j, k, 3)*vnpd
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + w(i, j+1, k, ivz)*vnpd
    end do
    call popreal8(qsp)
    call popreal8(qsm)
    call popreal8(porvel)
    call popreal8(porflux)
    call popreal8(vnp)
    call popreal8(vnm)
    call popinteger4(j)
    call popinteger4(i)
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
    do ii=0,il*ny*nz-1
      i = mod(ii, il) + 1
      j = mod(ii/il, ny) + 2
      k = ii/(il*ny) + 2
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
      if (addgridvelocities) sface = sfacei(i, j, k)
! compute the normal velocities of the left and right state.
      vnp = w(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivy)*si(i, j&
&       , k, 2) + w(i+1, j, k, ivz)*si(i, j, k, 3)
      vnm = w(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivy)*si(i, j, k&
&       , 2) + w(i, j, k, ivz)*si(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
      porvel = one
      porflux = half
      if (pori(i, j, k) .eq. noflux) porflux = zero
      if (pori(i, j, k) .eq. boundflux) then
        porvel = zero
        vnp = sface
        vnm = sface
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! incorporate porflux in porvel.
      porvel = porvel*porflux
! compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
      qsp = (vnp-sface)*porvel
      qsm = (vnm-sface)*porvel
      rqsp = qsp*w(i+1, j, k, irho)
      rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
      pa = porflux*(p(i+1, j, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i+1,j,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
      fsd = dwd(i, j, k, irhoe) - dwd(i+1, j, k, irhoe)
      tempd = porflux*fsd
      qspd = w(i+1, j, k, irhoe)*fsd
      wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + qsp*fsd
      qsmd = w(i, j, k, irhoe)*fsd
      wd(i, j, k, irhoe) = wd(i, j, k, irhoe) + qsm*fsd
      pd(i+1, j, k) = pd(i+1, j, k) + vnp*tempd
      pd(i, j, k) = pd(i, j, k) + vnm*tempd
      fsd = dwd(i, j, k, imz) - dwd(i+1, j, k, imz)
      rqspd = w(i+1, j, k, ivz)*fsd
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + rqsp*fsd
      rqsmd = w(i, j, k, ivz)*fsd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + rqsm*fsd
      pad = si(i, j, k, 3)*fsd
      sid(i, j, k, 3) = sid(i, j, k, 3) + pa*fsd
      fsd = dwd(i, j, k, imy) - dwd(i+1, j, k, imy)
      rqspd = rqspd + w(i+1, j, k, ivy)*fsd
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + rqsp*fsd
      rqsmd = rqsmd + w(i, j, k, ivy)*fsd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + rqsm*fsd
      pad = pad + si(i, j, k, 2)*fsd
      sid(i, j, k, 2) = sid(i, j, k, 2) + pa*fsd
      fsd = dwd(i, j, k, imx) - dwd(i+1, j, k, imx)
      rqspd = rqspd + w(i+1, j, k, ivx)*fsd
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + rqsp*fsd
      rqsmd = rqsmd + w(i, j, k, ivx)*fsd
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + rqsm*fsd
      pad = pad + si(i, j, k, 1)*fsd
      sid(i, j, k, 1) = sid(i, j, k, 1) + pa*fsd
      fsd = dwd(i, j, k, irho) - dwd(i+1, j, k, irho)
      rqspd = rqspd + fsd
      rqsmd = rqsmd + fsd
      pd(i+1, j, k) = pd(i+1, j, k) + porflux*pad
      pd(i, j, k) = pd(i, j, k) + porflux*pad
      qsmd = qsmd + w(i, j, k, irho)*rqsmd
      vnmd = porvel*qsmd + p(i, j, k)*tempd
      wd(i, j, k, irho) = wd(i, j, k, irho) + qsm*rqsmd
      qspd = qspd + w(i+1, j, k, irho)*rqspd
      vnpd = porvel*qspd + p(i+1, j, k)*tempd
      wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + qsp*rqspd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        vnmd = 0.0_8
        vnpd = 0.0_8
      end if
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + si(i, j, k, 1)*vnmd
      sid(i, j, k, 1) = sid(i, j, k, 1) + w(i, j, k, ivx)*vnmd
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + si(i, j, k, 2)*vnmd
      sid(i, j, k, 2) = sid(i, j, k, 2) + w(i, j, k, ivy)*vnmd
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + si(i, j, k, 3)*vnmd
      sid(i, j, k, 3) = sid(i, j, k, 3) + w(i, j, k, ivz)*vnmd
      wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + si(i, j, k, 1)*vnpd
      sid(i, j, k, 1) = sid(i, j, k, 1) + w(i+1, j, k, ivx)*vnpd
      wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + si(i, j, k, 2)*vnpd
      sid(i, j, k, 2) = sid(i, j, k, 2) + w(i+1, j, k, ivy)*vnpd
      wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + si(i, j, k, 3)*vnpd
      sid(i, j, k, 3) = sid(i, j, k, 3) + w(i+1, j, k, ivz)*vnpd
    end do
  end subroutine inviscidcentralflux_b
  subroutine inviscidcentralflux()
!
!       inviscidcentralflux computes the euler fluxes using a central
!       discretization for a given block. therefore it is assumed that
!       the pointers in block pointer already point to the correct
!       block on the correct multigrid level.
!
    use constants
    use blockpointers, only : nx, il, ie, ny, jl, je, nz, kl, ke, &
&   spectralsol, w, si, sj, sk, dw, pori, porj, pork, indfamilyi, &
&   indfamilyj, indfamilyk, p, sfacei, sfacej, sfacek, nbkglobal, &
&   addgridvelocities, blockismoving, vol, factfamilyi, factfamilyj, &
&   factfamilyk
    use cgnsgrid, only : cgnsdoms, massflowfamilyinv
    use flowvarrefstate, only : timeref
    use inputphysics, only : equationmode
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: qsp, qsm, rqsp, rqsm, porvel, porflux
    real(kind=realtype) :: pa, fs, sface, vnp, vnm
    real(kind=realtype) :: wwx, wwy, wwz, rvol
    intrinsic mod
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
!
!       advective fluxes in the i-direction.
!
    do ii=0,il*ny*nz-1
      i = mod(ii, il) + 1
      j = mod(ii/il, ny) + 2
      k = ii/(il*ny) + 2
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
      if (addgridvelocities) sface = sfacei(i, j, k)
! compute the normal velocities of the left and right state.
      vnp = w(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivy)*si(i, j&
&       , k, 2) + w(i+1, j, k, ivz)*si(i, j, k, 3)
      vnm = w(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivy)*si(i, j, k&
&       , 2) + w(i, j, k, ivz)*si(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
      porvel = one
      porflux = half
      if (pori(i, j, k) .eq. noflux) porflux = zero
      if (pori(i, j, k) .eq. boundflux) then
        porvel = zero
        vnp = sface
        vnm = sface
      end if
! incorporate porflux in porvel.
      porvel = porvel*porflux
! compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
      qsp = (vnp-sface)*porvel
      qsm = (vnm-sface)*porvel
      rqsp = qsp*w(i+1, j, k, irho)
      rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
      pa = porflux*(p(i+1, j, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i+1,j,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
      fs = rqsp + rqsm
      dw(i+1, j, k, irho) = dw(i+1, j, k, irho) - fs
      dw(i, j, k, irho) = dw(i, j, k, irho) + fs
      fs = rqsp*w(i+1, j, k, ivx) + rqsm*w(i, j, k, ivx) + pa*si(i, j, k&
&       , 1)
      dw(i+1, j, k, imx) = dw(i+1, j, k, imx) - fs
      dw(i, j, k, imx) = dw(i, j, k, imx) + fs
      fs = rqsp*w(i+1, j, k, ivy) + rqsm*w(i, j, k, ivy) + pa*si(i, j, k&
&       , 2)
      dw(i+1, j, k, imy) = dw(i+1, j, k, imy) - fs
      dw(i, j, k, imy) = dw(i, j, k, imy) + fs
      fs = rqsp*w(i+1, j, k, ivz) + rqsm*w(i, j, k, ivz) + pa*si(i, j, k&
&       , 3)
      dw(i+1, j, k, imz) = dw(i+1, j, k, imz) - fs
      dw(i, j, k, imz) = dw(i, j, k, imz) + fs
      fs = qsp*w(i+1, j, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&       vnp*p(i+1, j, k)+vnm*p(i, j, k))
      dw(i+1, j, k, irhoe) = dw(i+1, j, k, irhoe) - fs
      dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
    end do
!
!       advective fluxes in the j-direction.
!
    continue
    sface = zero
    do ii=0,nx*jl*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, jl) + 1
      k = ii/(nx*jl) + 2
! set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
      if (addgridvelocities) sface = sfacej(i, j, k)
! compute the normal velocities of the left and right state.
      vnp = w(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivy)*sj(i, j&
&       , k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 3)
      vnm = w(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivy)*sj(i, j, k&
&       , 2) + w(i, j, k, ivz)*sj(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
      porvel = one
      porflux = half
      if (porj(i, j, k) .eq. noflux) porflux = zero
      if (porj(i, j, k) .eq. boundflux) then
        porvel = zero
        vnp = sface
        vnm = sface
      end if
! incorporate porflux in porvel.
      porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
      qsp = (vnp-sface)*porvel
      qsm = (vnm-sface)*porvel
      rqsp = qsp*w(i, j+1, k, irho)
      rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
      pa = porflux*(p(i, j+1, k)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j+1,k. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
      fs = rqsp + rqsm
      dw(i, j+1, k, irho) = dw(i, j+1, k, irho) - fs
      dw(i, j, k, irho) = dw(i, j, k, irho) + fs
      fs = rqsp*w(i, j+1, k, ivx) + rqsm*w(i, j, k, ivx) + pa*sj(i, j, k&
&       , 1)
      dw(i, j+1, k, imx) = dw(i, j+1, k, imx) - fs
      dw(i, j, k, imx) = dw(i, j, k, imx) + fs
      fs = rqsp*w(i, j+1, k, ivy) + rqsm*w(i, j, k, ivy) + pa*sj(i, j, k&
&       , 2)
      dw(i, j+1, k, imy) = dw(i, j+1, k, imy) - fs
      dw(i, j, k, imy) = dw(i, j, k, imy) + fs
      fs = rqsp*w(i, j+1, k, ivz) + rqsm*w(i, j, k, ivz) + pa*sj(i, j, k&
&       , 3)
      dw(i, j+1, k, imz) = dw(i, j+1, k, imz) - fs
      dw(i, j, k, imz) = dw(i, j, k, imz) + fs
      fs = qsp*w(i, j+1, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&       vnp*p(i, j+1, k)+vnm*p(i, j, k))
      dw(i, j+1, k, irhoe) = dw(i, j+1, k, irhoe) - fs
      dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
    end do
!
!       advective fluxes in the k-direction.
    continue
    sface = zero
    do ii=0,nx*ny*kl-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 1
! set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
      if (addgridvelocities) sface = sfacek(i, j, k)
! compute the normal velocities of the left and right state.
      vnp = w(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivy)*sk(i, j&
&       , k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 3)
      vnm = w(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivy)*sk(i, j, k&
&       , 2) + w(i, j, k, ivz)*sk(i, j, k, 3)
! set the values of the porosities for this face.
! porvel defines the porosity w.r.t. velocity;
! porflux defines the porosity w.r.t. the entire flux.
! the latter is only zero for a discontinuous block
! block boundary that must be treated conservatively.
! the default value of porflux is 0.5, such that the
! correct central flux is scattered to both cells.
! in case of a boundflux the normal velocity is set
! to sface.
      porvel = one
      porflux = half
      if (pork(i, j, k) .eq. noflux) porflux = zero
      if (pork(i, j, k) .eq. boundflux) then
        porvel = zero
        vnp = sface
        vnm = sface
      end if
! incorporate porflux in porvel.
      porvel = porvel*porflux
! compute the normal velocities for the face as well as the
! mass fluxes.
      qsp = (vnp-sface)*porvel
      qsm = (vnm-sface)*porvel
      rqsp = qsp*w(i, j, k+1, irho)
      rqsm = qsm*w(i, j, k, irho)
! compute the sum of the pressure multiplied by porflux.
! for the default value of porflux, 0.5, this leads to
! the average pressure.
      pa = porflux*(p(i, j, k+1)+p(i, j, k))
! compute the fluxes and scatter them to the cells
! i,j,k and i,j,k+1. store the density flux in the
! mass flow of the appropriate sliding mesh interface.
      fs = rqsp + rqsm
      dw(i, j, k+1, irho) = dw(i, j, k+1, irho) - fs
      dw(i, j, k, irho) = dw(i, j, k, irho) + fs
      fs = rqsp*w(i, j, k+1, ivx) + rqsm*w(i, j, k, ivx) + pa*sk(i, j, k&
&       , 1)
      dw(i, j, k+1, imx) = dw(i, j, k+1, imx) - fs
      dw(i, j, k, imx) = dw(i, j, k, imx) + fs
      fs = rqsp*w(i, j, k+1, ivy) + rqsm*w(i, j, k, ivy) + pa*sk(i, j, k&
&       , 2)
      dw(i, j, k+1, imy) = dw(i, j, k+1, imy) - fs
      dw(i, j, k, imy) = dw(i, j, k, imy) + fs
      fs = rqsp*w(i, j, k+1, ivz) + rqsm*w(i, j, k, ivz) + pa*sk(i, j, k&
&       , 3)
      dw(i, j, k+1, imz) = dw(i, j, k+1, imz) - fs
      dw(i, j, k, imz) = dw(i, j, k, imz) + fs
      fs = qsp*w(i, j, k+1, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&       vnp*p(i, j, k+1)+vnm*p(i, j, k))
      dw(i, j, k+1, irhoe) = dw(i, j, k+1, irhoe) - fs
      dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
    end do
! add the rotational source terms for a moving block in a
! steady state computation. these source terms account for the
! centrifugal acceleration and the coriolis term. however, as
! the the equations are solved in the inertial frame and not
! in the moving frame, the form is different than what you
! normally find in a text book.
    continue
    if (blockismoving .and. equationmode .eq. steady) then
! compute the three nondimensional angular velocities.
      wwx = timeref*cgnsdoms(nbkglobal)%rotrate(1)
      wwy = timeref*cgnsdoms(nbkglobal)%rotrate(2)
      wwz = timeref*cgnsdoms(nbkglobal)%rotrate(3)
! loop over the internal cells of this block to compute the
! rotational terms for the momentum equations.
      do ii=0,nx*ny*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 2
        rvol = w(i, j, k, irho)*vol(i, j, k)
        dw(i, j, k, imx) = dw(i, j, k, imx) + rvol*(wwy*w(i, j, k, ivz)-&
&         wwz*w(i, j, k, ivy))
        dw(i, j, k, imy) = dw(i, j, k, imy) + rvol*(wwz*w(i, j, k, ivx)-&
&         wwx*w(i, j, k, ivz))
        dw(i, j, k, imz) = dw(i, j, k, imz) + rvol*(wwx*w(i, j, k, ivy)-&
&         wwy*w(i, j, k, ivx))
      end do
    end if
  end subroutine inviscidcentralflux
!  differentiation of invisciddissfluxmatrix in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: pinfcorr *p *w *si *sj *sk
!                *fw
!   with respect to varying inputs: pinfcorr *p *w *si *sj *sk
!                *fw
!   rw status of diff variables: pinfcorr:incr *p:incr *w:incr
!                *si:incr *sj:incr *sk:incr *fw:in-out
!   plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
  subroutine invisciddissfluxmatrix_b()
!
!       invisciddissfluxmatrix computes the matrix artificial
!       dissipation term. instead of the spectral radius, as used in
!       the scalar dissipation scheme, the absolute value of the flux
!       jacobian is used. this leads to a less diffusive and
!       consequently more accurate scheme. it is assumed that the
!       pointers in blockpointers already point to the correct block.
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, wd, p, pd, pori, porj, pork, fw, fwd, gamma, si, sid, sj,&
&   sjd, sk, skd, indfamilyi, indfamilyj, indfamilyk, spectralsol, &
&   addgridvelocities, sfacei, sfacej, sfacek, factfamilyi, factfamilyj,&
&   factfamilyk
    use flowvarrefstate, only : pinfcorr, pinfcorrd
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use cgnsgrid, only : massflowfamilydiss
    use utils_b, only : getcorrectfork, mydim, mydim_b
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: plimd, sfaced
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: rradd, dis2d, dis4d
    real(kind=realtype) :: dp1, dp2, tmp, fs
    real(kind=realtype) :: tmpd, fsd
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, ddw6
    real(kind=realtype) :: ddw1d, ddw2d, ddw3d, ddw4d, ddw5d, ddw6d
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd, sxd, syd, &
&   szd
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d, aread
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
&   abv7d
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    real(kind=realtype), dimension(ie, je, ke, 3) :: dssd
    logical :: correctfork
    intrinsic abs
    intrinsic mod
    intrinsic max
    intrinsic min
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp29
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp28
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp27
    real(kind=realtype) :: max10d
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: temp26
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: temp25
    real(kind=realtype) :: temp24
    real(kind=realtype) :: temp23
    real(kind=realtype) :: temp22
    real(kind=realtype) :: temp59
    real(kind=realtype) :: temp21
    real(kind=realtype) :: temp58
    real(kind=realtype) :: temp20
    real(kind=realtype) :: temp57
    real(kind=realtype) :: abs1d
    real(kind=realtype) :: temp56
    real(kind=realtype) :: temp55
    real(kind=realtype) :: tempd40
    real(kind=realtype) :: temp54
    real(kind=realtype) :: max2d
    real(kind=realtype) :: temp53
    real(kind=realtype) :: min3
    real(kind=realtype) :: temp52
    real(kind=realtype) :: min2
    real(kind=realtype) :: temp51
    real(kind=realtype) :: min1
    real(kind=realtype) :: temp50
    real(kind=realtype) :: abs4d
    real(kind=realtype) :: max5d
    real(kind=realtype) :: min1d
    real(kind=realtype) :: max8d
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x1
    real(kind=realtype) :: temp19
    real(kind=realtype) :: temp18
    real(kind=realtype) :: temp17
    real(kind=realtype) :: tempd39
    real(kind=realtype) :: temp16
    real(kind=realtype) :: tempd38
    real(kind=realtype) :: temp15
    real(kind=realtype) :: tempd37
    real(kind=realtype) :: temp14
    real(kind=realtype) :: tempd36
    real(kind=realtype) :: temp13
    real(kind=realtype) :: y3d
    real(kind=realtype) :: tempd35
    real(kind=realtype) :: temp12
    real(kind=realtype) :: temp49
    real(kind=realtype) :: tempd34
    real(kind=realtype) :: temp11
    real(kind=realtype) :: temp48
    real(kind=realtype) :: tempd33
    real(kind=realtype) :: temp10
    real(kind=realtype) :: temp47
    real(kind=realtype) :: tempd32
    real(kind=realtype) :: max12d
    real(kind=realtype) :: temp46
    real(kind=realtype) :: tempd31
    real(kind=realtype) :: temp45
    real(kind=realtype) :: tempd30
    real(kind=realtype) :: temp44
    real(kind=realtype) :: max1d
    real(kind=realtype) :: temp43
    real(kind=realtype) :: temp42
    real(kind=realtype) :: temp41
    real(kind=realtype) :: temp40
    real(kind=realtype) :: abs3d
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: max4d
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: abs6d
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: max7d
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: x1d
    real(kind=realtype) :: tempd29
    real(kind=realtype) :: min3d
    real(kind=realtype) :: tempd28
    real(kind=realtype) :: tempd27
    real(kind=realtype) :: tempd26
    real(kind=realtype) :: y2d
    real(kind=realtype) :: tempd25
    real(kind=realtype) :: tempd24
    real(kind=realtype) :: temp39
    real(kind=realtype) :: tempd23
    real(kind=realtype) :: temp38
    real(kind=realtype) :: tempd22
    real(kind=realtype) :: temp37
    real(kind=realtype) :: max11d
    real(kind=realtype) :: tempd21
    real(kind=realtype) :: temp36
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: temp35
    real(kind=realtype) :: temp34
    real(kind=realtype) :: abs6
    real(kind=realtype) :: temp33
    real(kind=realtype) :: abs5
    real(kind=realtype) :: temp32
    real(kind=realtype) :: abs4
    real(kind=realtype) :: temp31
    real(kind=realtype) :: abs3
    real(kind=realtype) :: temp30
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs2d
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: temp64
    real(kind=realtype) :: max3d
    real(kind=realtype) :: temp63
    real(kind=realtype) :: temp62
    real(kind=realtype) :: temp61
    real(kind=realtype) :: temp60
    real(kind=realtype) :: max9
    real(kind=realtype) :: abs5d
    real(kind=realtype) :: max8
    real(kind=realtype) :: max7
    real(kind=realtype) :: max6
    real(kind=realtype) :: max6d
    real(kind=realtype) :: max5
    real(kind=realtype) :: max4
    real(kind=realtype) :: temp
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: max12
    real(kind=realtype) :: temp9
    real(kind=realtype) :: max11
    real(kind=realtype) :: temp8
    real(kind=realtype) :: min2d
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: max10
    real(kind=realtype) :: temp7
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: max9d
    real(kind=realtype) :: y3
    real(kind=realtype) :: temp6
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: y2
    real(kind=realtype) :: x3d
    real(kind=realtype) :: temp5
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: y1
    real(kind=realtype) :: y1d
    real(kind=realtype) :: temp4
    real(kind=realtype) :: tempd15
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .ge. thresholdreal) then
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value.
! compute the pressure sensor for each cell, in each direction:
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
        if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
          abs1 = p(i+1, j, k) - p(i, j, k)
        else
          abs1 = -(p(i+1, j, k)-p(i, j, k))
        end if
        if (p(i, j, k) - p(i-1, j, k) .ge. 0.) then
          abs4 = p(i, j, k) - p(i-1, j, k)
        else
          abs4 = -(p(i, j, k)-p(i-1, j, k))
        end if
        x1 = (p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))/(omega*(p(i+1, j&
&         , k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+abs4)+plim&
&         )
        if (x1 .ge. 0.) then
          dss(i, j, k, 1) = x1
        else
          dss(i, j, k, 1) = -x1
        end if
        if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
          abs2 = p(i, j+1, k) - p(i, j, k)
        else
          abs2 = -(p(i, j+1, k)-p(i, j, k))
        end if
        if (p(i, j, k) - p(i, j-1, k) .ge. 0.) then
          abs5 = p(i, j, k) - p(i, j-1, k)
        else
          abs5 = -(p(i, j, k)-p(i, j-1, k))
        end if
        x2 = (p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))/(omega*(p(i, j+1&
&         , k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+abs5)+plim&
&         )
        if (x2 .ge. 0.) then
          dss(i, j, k, 2) = x2
        else
          dss(i, j, k, 2) = -x2
        end if
        if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
          abs3 = p(i, j, k+1) - p(i, j, k)
        else
          abs3 = -(p(i, j, k+1)-p(i, j, k))
        end if
        if (p(i, j, k) - p(i, j, k-1) .ge. 0.) then
          abs6 = p(i, j, k) - p(i, j, k-1)
        else
          abs6 = -(p(i, j, k)-p(i, j, k-1))
        end if
        x3 = (p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))/(omega*(p(i, j, &
&         k+1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+abs6)+plim&
&         )
        if (x3 .ge. 0.) then
          dss(i, j, k, 3) = x3
        else
          dss(i, j, k, 3) = -x3
        end if
      end do
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(sface)
!
!       dissipative fluxes in the i-direction.
!
      do ii=0,il*ny*nz-1
        i = mod(ii, il) + 1
        j = mod(ii/il, ny) + 2
        k = ii/(il*ny) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pori(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
          y1 = dss(i+1, j, k, 1)
        else
          y1 = dss(i, j, k, 1)
        end if
        if (dpmax .gt. y1) then
          min1 = y1
        else
          min1 = dpmax
        end if
        dis2 = ppor*fis2*min1
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-&
&         three*ddw1)
        ddw2 = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw2)
        ddw3 = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw3)
        ddw4 = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw4)
        ddw5 = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)-&
&           w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw6)
          kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
        else
          drk = zero
          kavg = zero
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(si(i, j, k, 1)**2 + si(i, j, k, 2)**2 + si(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max1 = area
        else
          max1 = 1.e-25_realtype
        end if
        tmp = one/max1
        sx = si(i, j, k, 1)*tmp
        sy = si(i, j, k, 2)*tmp
        sz = si(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) sface = sfacei(i, j, k)*tmp
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
        else
          lam1 = -(unavg-sface+aavg)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
        else
          lam2 = -(unavg-sface-aavg)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
        else
          lam3 = -(unavg-sface)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max2 = epsacoustic*rrad
        else
          max2 = lam1
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max2*area
        if (lam2 .lt. epsacoustic*rrad) then
          max3 = epsacoustic*rrad
        else
          max3 = lam2
        end if
        lam2 = max3*area
        if (lam3 .lt. epsshear*rrad) then
          max4 = epsshear*rrad
        else
          max4 = lam3
        end if
        lam3 = max4*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
        fs = lam3*dr + abv6
        fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        fs = lam3*dru + uavg*abv6 + sx*abv7
        fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        fs = lam3*drv + vavg*abv6 + sy*abv7
        fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        fs = lam3*drw + wavg*abv6 + sz*abv7
        fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        fs = lam3*dre + havg*abv6 + unavg*abv7
        fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
      call pushreal8(aavg)
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(area)
      call pushreal8(dr)
      call pushreal8(abv4)
      call pushreal8(dis2)
      call pushreal8(dis4)
      call pushreal8(dre)
      call pushreal8(ddw2)
      call pushreal8(ddw3)
      call pushreal8(ddw4)
      call pushreal8(havg)
      call pushreal8(ddw6)
      call pushreal8(dru)
      call pushreal8(drv)
      call pushreal8(drw)
      call pushreal8(a2avg)
      call pushreal8(ppor)
      call pushreal8(sface)
!
!       dissipative fluxes in the j-direction.
!
      do ii=0,nx*jl*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, jl) + 1
        k = ii/(nx*jl) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (porj(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
          y2 = dss(i, j+1, k, 2)
        else
          y2 = dss(i, j, k, 2)
        end if
        if (dpmax .gt. y2) then
          min2 = y2
        else
          min2 = dpmax
        end if
        dis2 = ppor*fis2*min2
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-&
&         three*ddw1)
        ddw2 = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw2)
        ddw3 = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw3)
        ddw4 = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw4)
        ddw5 = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)-&
&           w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw6)
          kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
        else
          drk = zero
          kavg = zero
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(sj(i, j, k, 1)**2 + sj(i, j, k, 2)**2 + sj(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max5 = area
        else
          max5 = 1.e-25_realtype
        end if
        tmp = one/max5
        sx = sj(i, j, k, 1)*tmp
        sy = sj(i, j, k, 2)*tmp
        sz = sj(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) sface = sfacej(i, j, k)*tmp
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
        else
          lam1 = -(unavg-sface+aavg)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
        else
          lam2 = -(unavg-sface-aavg)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
        else
          lam3 = -(unavg-sface)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max6 = epsacoustic*rrad
        else
          max6 = lam1
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max6*area
        if (lam2 .lt. epsacoustic*rrad) then
          max7 = epsacoustic*rrad
        else
          max7 = lam2
        end if
        lam2 = max7*area
        if (lam3 .lt. epsshear*rrad) then
          max8 = epsshear*rrad
        else
          max8 = lam3
        end if
        lam3 = max8*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
        fs = lam3*dr + abv6
        fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        fs = lam3*dru + uavg*abv6 + sx*abv7
        fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        fs = lam3*drv + vavg*abv6 + sy*abv7
        fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        fs = lam3*drw + wavg*abv6 + sz*abv7
        fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        fs = lam3*dre + havg*abv6 + unavg*abv7
        fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
      call pushreal8(aavg)
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(area)
      call pushreal8(dr)
      call pushreal8(abv4)
      call pushreal8(dis2)
      call pushreal8(dis4)
      call pushreal8(dre)
      call pushreal8(ddw2)
      call pushreal8(ddw3)
      call pushreal8(ddw4)
      call pushreal8(havg)
      call pushreal8(ddw6)
      call pushreal8(dru)
      call pushreal8(drv)
      call pushreal8(drw)
      call pushreal8(a2avg)
      call pushreal8(ppor)
      dssd = 0.0_8
      sfaced = 0.0_8
      do ii=0,nx*ny*kl-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 1
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pork(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
          y3 = dss(i, j, k+1, 3)
          call pushcontrol1b(0)
        else
          y3 = dss(i, j, k, 3)
          call pushcontrol1b(1)
        end if
        if (dpmax .gt. y3) then
          min3 = y3
          call pushcontrol1b(0)
        else
          min3 = dpmax
          call pushcontrol1b(1)
        end if
        dis2 = ppor*fis2*min3
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)-&
&         three*ddw1)
        ddw2 = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)-w(i&
&         , j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw2)
        ddw3 = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)-w(i&
&         , j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw3)
        ddw4 = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)-w(i&
&         , j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw4)
        ddw5 = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, itu1)-&
&           w(i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw6)
          kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
          call pushcontrol1b(1)
        else
          drk = zero
          kavg = zero
          call pushcontrol1b(0)
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(sk(i, j, k, 1)**2 + sk(i, j, k, 2)**2 + sk(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max9 = area
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          max9 = 1.e-25_realtype
        end if
        tmp = one/max9
        sx = sk(i, j, k, 1)*tmp
        sy = sk(i, j, k, 2)*tmp
        sz = sk(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) then
          sface = sfacek(i, j, k)*tmp
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
          call pushcontrol1b(0)
        else
          lam1 = -(unavg-sface+aavg)
          call pushcontrol1b(1)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
          call pushcontrol1b(0)
        else
          lam2 = -(unavg-sface-aavg)
          call pushcontrol1b(1)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
          call pushcontrol1b(0)
        else
          lam3 = -(unavg-sface)
          call pushcontrol1b(1)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max10 = epsacoustic*rrad
          call pushcontrol1b(0)
        else
          max10 = lam1
          call pushcontrol1b(1)
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max10*area
        if (lam2 .lt. epsacoustic*rrad) then
          max11 = epsacoustic*rrad
          call pushcontrol1b(0)
        else
          max11 = lam2
          call pushcontrol1b(1)
        end if
        lam2 = max11*area
        if (lam3 .lt. epsshear*rrad) then
          max12 = epsshear*rrad
          call pushcontrol1b(0)
        else
          max12 = lam3
          call pushcontrol1b(1)
        end if
        lam3 = max12*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
        fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
        lam3d = dre*fsd
        dred = lam3*fsd
        havgd = abv6*fsd
        abv6d = havg*fsd
        unavgd = abv7*fsd
        abv7d = unavg*fsd
        fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
        lam3d = lam3d + drw*fsd
        drwd = lam3*fsd
        wavgd = abv6*fsd
        abv6d = abv6d + wavg*fsd
        szd = abv7*fsd
        abv7d = abv7d + sz*fsd
        fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
        lam3d = lam3d + drv*fsd
        drvd = lam3*fsd
        vavgd = abv6*fsd
        abv6d = abv6d + vavg*fsd
        syd = abv7*fsd
        abv7d = abv7d + sy*fsd
        fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
        lam3d = lam3d + dru*fsd
        drud = lam3*fsd
        uavgd = abv6*fsd
        abv6d = abv6d + uavg*fsd
        sxd = abv7*fsd
        abv7d = abv7d + sx*fsd
        fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
        abv6d = abv6d + fsd
        abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
        abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
        ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
        abv3d = ova2avg*abv4*abv6d + abv5*abv7d
        lam3d = lam3d + dr*fsd - abv3d
        abv5d = ovaavg*abv2*abv6d + abv3*abv7d
        ova2avgd = abv3*abv4*abv6d
        sxd = sxd + dru*abv5d
        syd = syd + drv*abv5d
        szd = szd + drw*abv5d
        unavgd = unavgd - dr*abv5d
        tempd40 = gm1*abv4d
        drd = alphaavg*tempd40 - unavg*abv5d + lam3*fsd
        drud = drud + sx*abv5d - uavg*tempd40
        drvd = drvd + sy*abv5d - vavg*tempd40
        drwd = drwd + sz*abv5d - wavg*tempd40
        alphaavgd = dr*tempd40
        uavgd = uavgd - dru*tempd40
        vavgd = vavgd - drv*tempd40
        dred = dred + tempd40
        wavgd = wavgd - drw*tempd40
        drkd = -(gm53*abv4d)
        abv1d = abv3d
        lam1d = half*abv1d + half*abv2d
        lam2d = half*abv1d - half*abv2d
        max12d = area*lam3d
        aread = max12*lam3d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = epsshear*max12d
          lam3d = 0.0_8
        else
          lam3d = max12d
          rradd = 0.0_8
        end if
        max11d = area*lam2d
        aread = aread + max11*lam2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = rradd + epsacoustic*max11d
          lam2d = 0.0_8
        else
          lam2d = max11d
        end if
        max10d = area*lam1d
        aread = aread + max10*lam1d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = rradd + epsacoustic*max10d
          lam1d = 0.0_8
        else
          lam1d = max10d
        end if
        lam3d = lam3d + rradd
        aavgd = rradd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam3d
          sfaced = sfaced - lam3d
        else
          sfaced = sfaced + lam3d
          unavgd = unavgd - lam3d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam2d
          sfaced = sfaced - lam2d
          aavgd = aavgd - lam2d
        else
          sfaced = sfaced + lam2d
          unavgd = unavgd - lam2d
          aavgd = aavgd + lam2d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam1d
          sfaced = sfaced - lam1d
          aavgd = aavgd + lam1d
        else
          sfaced = sfaced + lam1d
          unavgd = unavgd - lam1d
          aavgd = aavgd - lam1d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          tmpd = 0.0_8
        else
          tmpd = sfacek(i, j, k)*sfaced
          sfaced = 0.0_8
        end if
        alphaavgd = alphaavgd + havgd
        tempd39 = half*alphaavgd
        aavgd = aavgd - one*ovaavgd/aavg**2
        if (a2avg .eq. 0.0_8) then
          a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
        else
          a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*ova2avgd/&
&           a2avg**2
        end if
        uavgd = uavgd + 2*uavg*tempd39 + sx*unavgd
        sxd = sxd + uavg*unavgd
        vavgd = vavgd + 2*vavg*tempd39 + sy*unavgd
        syd = syd + vavg*unavgd
        wavgd = wavgd + 2*wavg*tempd39 + sz*unavgd
        szd = szd + wavg*unavgd
        kavgd = -(ovgm1*gm53*havgd)
        skd(i, j, k, 3) = skd(i, j, k, 3) + tmp*szd
        tmpd = tmpd + sk(i, j, k, 2)*syd + sk(i, j, k, 1)*sxd + sk(i, j&
&         , k, 3)*szd
        skd(i, j, k, 2) = skd(i, j, k, 2) + tmp*syd
        skd(i, j, k, 1) = skd(i, j, k, 1) + tmp*sxd
        max9d = -(one*tmpd/max9**2)
        call popcontrol1b(branch)
        if (branch .eq. 0) aread = aread + max9d
        temp64 = sk(i, j, k, 3)
        temp63 = sk(i, j, k, 2)
        temp62 = sk(i, j, k, 1)
        if (temp62**2 + temp63**2 + temp64**2 .eq. 0.0_8) then
          tempd36 = 0.0
        else
          tempd36 = aread/(2.0*sqrt(temp62**2+temp63**2+temp64**2))
        end if
        skd(i, j, k, 1) = skd(i, j, k, 1) + 2*temp62*tempd36
        skd(i, j, k, 2) = skd(i, j, k, 2) + 2*temp63*tempd36
        skd(i, j, k, 3) = skd(i, j, k, 3) + 2*temp64*tempd36
        temp61 = w(i, j, k, irho)
        temp60 = w(i, j, k+1, irho)
        tempd37 = gamma(i, j, k+1)*half*a2avgd/temp60
        tempd38 = gamma(i, j, k)*half*a2avgd/temp61
        pd(i, j, k+1) = pd(i, j, k+1) + tempd37
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - p(i, j, k+1)*tempd37&
&         /temp60
        pd(i, j, k) = pd(i, j, k) + tempd38
        wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd38/&
&         temp61
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wavgd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vavgd
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*uavgd
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dis2d = 0.0_8
          dis4d = 0.0_8
        else
          wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*kavgd
          wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
          temp59 = w(i, j, k-1, itu1)
          temp58 = w(i, j, k-1, irho)
          temp57 = w(i, j, k+2, itu1)
          temp56 = w(i, j, k+2, irho)
          tempd35 = -(dis4*drkd)
          dis2d = ddw6*drkd
          ddw6d = dis2*drkd - three*tempd35
          dis4d = -((temp56*temp57-temp58*temp59-three*ddw6)*drkd)
          wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp57*tempd35
          wd(i, j, k+2, itu1) = wd(i, j, k+2, itu1) + temp56*tempd35
          wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp59*tempd35
          wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) - temp58*tempd35
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, itu1)&
&           *ddw6d
          wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + w(i, j, k+1, irho)&
&           *ddw6d
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*ddw6d
          wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*ddw6d
        end if
        temp44 = w(i, j, k+2, irho)
        temp45 = w(i, j, k+2, ivx)
        temp46 = w(i, j, k-1, irho)
        temp47 = w(i, j, k-1, ivx)
        temp48 = w(i, j, k+2, irho)
        temp49 = w(i, j, k+2, ivy)
        temp50 = w(i, j, k-1, irho)
        temp51 = w(i, j, k-1, ivy)
        temp52 = w(i, j, k+2, irho)
        temp53 = w(i, j, k+2, ivz)
        temp54 = w(i, j, k-1, irho)
        temp55 = w(i, j, k-1, ivz)
        tempd30 = -(dis4*dred)
        dis2d = dis2d + ddw4*drwd + ddw2*drud + ddw1*drd + ddw3*drvd + &
&         ddw5*dred
        ddw5d = dis2*dred - three*tempd30
        dis4d = dis4d - (temp52*temp53-temp54*temp55-three*ddw4)*drwd - &
&         (temp44*temp45-temp46*temp47-three*ddw2)*drud - (w(i, j, k+2, &
&         irho)-w(i, j, k-1, irho)-three*ddw1)*drd - (temp48*temp49-&
&         temp50*temp51-three*ddw3)*drvd - (w(i, j, k+2, irhoe)-w(i, j, &
&         k-1, irhoe)-three*ddw5)*dred
        wd(i, j, k+2, irhoe) = wd(i, j, k+2, irhoe) + tempd30
        wd(i, j, k-1, irhoe) = wd(i, j, k-1, irhoe) - tempd30
        wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddw5d
        wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
        tempd31 = -(dis4*drwd)
        ddw4d = dis2*drwd - three*tempd31
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp53*tempd31
        wd(i, j, k+2, ivz) = wd(i, j, k+2, ivz) + temp52*tempd31
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp55*tempd31
        wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - temp54*tempd31
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
&         ddw4d
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)*&
&         ddw4d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
        wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
        tempd32 = -(dis4*drvd)
        ddw3d = dis2*drvd - three*tempd32
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp49*tempd32
        wd(i, j, k+2, ivy) = wd(i, j, k+2, ivy) + temp48*tempd32
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp51*tempd32
        wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - temp50*tempd32
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
&         ddw3d
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)*&
&         ddw3d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
        wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
        tempd33 = -(dis4*drud)
        ddw2d = dis2*drud - three*tempd33
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp45*tempd33
        wd(i, j, k+2, ivx) = wd(i, j, k+2, ivx) + temp44*tempd33
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp47*tempd33
        wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - temp46*tempd33
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
&         ddw2d
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)*&
&         ddw2d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
        wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
        tempd34 = -(dis4*drd)
        ddw1d = dis2*drd - three*tempd34
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + tempd34
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - tempd34
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddw1d
        wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
        arg1d = 0.0_8
        call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
        min3d = ppor*fis2*dis2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          y3d = min3d
        else
          y3d = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dssd(i, j, k+1, 3) = dssd(i, j, k+1, 3) + y3d
        else
          dssd(i, j, k, 3) = dssd(i, j, k, 3) + y3d
        end if
      end do
      call popreal8(ppor)
      call popreal8(a2avg)
      call popreal8(drw)
      call popreal8(drv)
      call popreal8(dru)
      call popreal8(ddw6)
      call popreal8(havg)
      call popreal8(ddw4)
      call popreal8(ddw3)
      call popreal8(ddw2)
      call popreal8(dre)
      call popreal8(dis4)
      call popreal8(dis2)
      call popreal8(abv4)
      call popreal8(dr)
      call popreal8(area)
      call popinteger4(j)
      call popinteger4(i)
      call popreal8(aavg)
      call popreal8(sface)
      do ii=0,nx*jl*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, jl) + 1
        k = ii/(nx*jl) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (porj(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
          y2 = dss(i, j+1, k, 2)
          call pushcontrol1b(0)
        else
          y2 = dss(i, j, k, 2)
          call pushcontrol1b(1)
        end if
        if (dpmax .gt. y2) then
          min2 = y2
          call pushcontrol1b(0)
        else
          min2 = dpmax
          call pushcontrol1b(1)
        end if
        dis2 = ppor*fis2*min2
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-&
&         three*ddw1)
        ddw2 = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw2)
        ddw3 = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw3)
        ddw4 = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw4)
        ddw5 = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)-&
&           w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw6)
          kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
          call pushcontrol1b(1)
        else
          drk = zero
          kavg = zero
          call pushcontrol1b(0)
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(sj(i, j, k, 1)**2 + sj(i, j, k, 2)**2 + sj(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max5 = area
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          max5 = 1.e-25_realtype
        end if
        tmp = one/max5
        sx = sj(i, j, k, 1)*tmp
        sy = sj(i, j, k, 2)*tmp
        sz = sj(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) then
          sface = sfacej(i, j, k)*tmp
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
          call pushcontrol1b(0)
        else
          lam1 = -(unavg-sface+aavg)
          call pushcontrol1b(1)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
          call pushcontrol1b(0)
        else
          lam2 = -(unavg-sface-aavg)
          call pushcontrol1b(1)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
          call pushcontrol1b(0)
        else
          lam3 = -(unavg-sface)
          call pushcontrol1b(1)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max6 = epsacoustic*rrad
          call pushcontrol1b(0)
        else
          max6 = lam1
          call pushcontrol1b(1)
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max6*area
        if (lam2 .lt. epsacoustic*rrad) then
          max7 = epsacoustic*rrad
          call pushcontrol1b(0)
        else
          max7 = lam2
          call pushcontrol1b(1)
        end if
        lam2 = max7*area
        if (lam3 .lt. epsshear*rrad) then
          max8 = epsshear*rrad
          call pushcontrol1b(0)
        else
          max8 = lam3
          call pushcontrol1b(1)
        end if
        lam3 = max8*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
        fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
        lam3d = dre*fsd
        dred = lam3*fsd
        havgd = abv6*fsd
        abv6d = havg*fsd
        unavgd = abv7*fsd
        abv7d = unavg*fsd
        fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
        lam3d = lam3d + drw*fsd
        drwd = lam3*fsd
        wavgd = abv6*fsd
        abv6d = abv6d + wavg*fsd
        szd = abv7*fsd
        abv7d = abv7d + sz*fsd
        fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
        lam3d = lam3d + drv*fsd
        drvd = lam3*fsd
        vavgd = abv6*fsd
        abv6d = abv6d + vavg*fsd
        syd = abv7*fsd
        abv7d = abv7d + sy*fsd
        fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
        lam3d = lam3d + dru*fsd
        drud = lam3*fsd
        uavgd = abv6*fsd
        abv6d = abv6d + uavg*fsd
        sxd = abv7*fsd
        abv7d = abv7d + sx*fsd
        fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
        abv6d = abv6d + fsd
        abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
        abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
        ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
        abv3d = ova2avg*abv4*abv6d + abv5*abv7d
        lam3d = lam3d + dr*fsd - abv3d
        abv5d = ovaavg*abv2*abv6d + abv3*abv7d
        ova2avgd = abv3*abv4*abv6d
        sxd = sxd + dru*abv5d
        syd = syd + drv*abv5d
        szd = szd + drw*abv5d
        unavgd = unavgd - dr*abv5d
        tempd29 = gm1*abv4d
        drd = alphaavg*tempd29 - unavg*abv5d + lam3*fsd
        drud = drud + sx*abv5d - uavg*tempd29
        drvd = drvd + sy*abv5d - vavg*tempd29
        drwd = drwd + sz*abv5d - wavg*tempd29
        alphaavgd = dr*tempd29
        uavgd = uavgd - dru*tempd29
        vavgd = vavgd - drv*tempd29
        dred = dred + tempd29
        wavgd = wavgd - drw*tempd29
        drkd = -(gm53*abv4d)
        abv1d = abv3d
        lam1d = half*abv1d + half*abv2d
        lam2d = half*abv1d - half*abv2d
        max8d = area*lam3d
        aread = max8*lam3d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = epsshear*max8d
          lam3d = 0.0_8
        else
          lam3d = max8d
          rradd = 0.0_8
        end if
        max7d = area*lam2d
        aread = aread + max7*lam2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = rradd + epsacoustic*max7d
          lam2d = 0.0_8
        else
          lam2d = max7d
        end if
        max6d = area*lam1d
        aread = aread + max6*lam1d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = rradd + epsacoustic*max6d
          lam1d = 0.0_8
        else
          lam1d = max6d
        end if
        lam3d = lam3d + rradd
        aavgd = rradd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam3d
          sfaced = sfaced - lam3d
        else
          sfaced = sfaced + lam3d
          unavgd = unavgd - lam3d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam2d
          sfaced = sfaced - lam2d
          aavgd = aavgd - lam2d
        else
          sfaced = sfaced + lam2d
          unavgd = unavgd - lam2d
          aavgd = aavgd + lam2d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam1d
          sfaced = sfaced - lam1d
          aavgd = aavgd + lam1d
        else
          sfaced = sfaced + lam1d
          unavgd = unavgd - lam1d
          aavgd = aavgd - lam1d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          tmpd = 0.0_8
        else
          tmpd = sfacej(i, j, k)*sfaced
          sfaced = 0.0_8
        end if
        alphaavgd = alphaavgd + havgd
        tempd28 = half*alphaavgd
        aavgd = aavgd - one*ovaavgd/aavg**2
        if (a2avg .eq. 0.0_8) then
          a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
        else
          a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*ova2avgd/&
&           a2avg**2
        end if
        uavgd = uavgd + 2*uavg*tempd28 + sx*unavgd
        sxd = sxd + uavg*unavgd
        vavgd = vavgd + 2*vavg*tempd28 + sy*unavgd
        syd = syd + vavg*unavgd
        wavgd = wavgd + 2*wavg*tempd28 + sz*unavgd
        szd = szd + wavg*unavgd
        kavgd = -(ovgm1*gm53*havgd)
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + tmp*szd
        tmpd = tmpd + sj(i, j, k, 2)*syd + sj(i, j, k, 1)*sxd + sj(i, j&
&         , k, 3)*szd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + tmp*syd
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + tmp*sxd
        max5d = -(one*tmpd/max5**2)
        call popcontrol1b(branch)
        if (branch .eq. 0) aread = aread + max5d
        temp43 = sj(i, j, k, 3)
        temp42 = sj(i, j, k, 2)
        temp41 = sj(i, j, k, 1)
        if (temp41**2 + temp42**2 + temp43**2 .eq. 0.0_8) then
          tempd25 = 0.0
        else
          tempd25 = aread/(2.0*sqrt(temp41**2+temp42**2+temp43**2))
        end if
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + 2*temp41*tempd25
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + 2*temp42*tempd25
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + 2*temp43*tempd25
        temp40 = w(i, j, k, irho)
        temp39 = w(i, j+1, k, irho)
        tempd26 = gamma(i, j+1, k)*half*a2avgd/temp39
        tempd27 = gamma(i, j, k)*half*a2avgd/temp40
        pd(i, j+1, k) = pd(i, j+1, k) + tempd26
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - p(i, j+1, k)*tempd26&
&         /temp39
        pd(i, j, k) = pd(i, j, k) + tempd27
        wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd27/&
&         temp40
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wavgd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vavgd
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*uavgd
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dis2d = 0.0_8
          dis4d = 0.0_8
        else
          wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
          wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*kavgd
          temp38 = w(i, j-1, k, itu1)
          temp37 = w(i, j-1, k, irho)
          temp36 = w(i, j+2, k, itu1)
          temp35 = w(i, j+2, k, irho)
          tempd24 = -(dis4*drkd)
          dis2d = ddw6*drkd
          ddw6d = dis2*drkd - three*tempd24
          dis4d = -((temp35*temp36-temp37*temp38-three*ddw6)*drkd)
          wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp36*tempd24
          wd(i, j+2, k, itu1) = wd(i, j+2, k, itu1) + temp35*tempd24
          wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp38*tempd24
          wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) - temp37*tempd24
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, itu1)&
&           *ddw6d
          wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + w(i, j+1, k, irho)&
&           *ddw6d
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*ddw6d
          wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*ddw6d
        end if
        temp23 = w(i, j+2, k, irho)
        temp24 = w(i, j+2, k, ivx)
        temp25 = w(i, j-1, k, irho)
        temp26 = w(i, j-1, k, ivx)
        temp27 = w(i, j+2, k, irho)
        temp28 = w(i, j+2, k, ivy)
        temp29 = w(i, j-1, k, irho)
        temp30 = w(i, j-1, k, ivy)
        temp31 = w(i, j+2, k, irho)
        temp32 = w(i, j+2, k, ivz)
        temp33 = w(i, j-1, k, irho)
        temp34 = w(i, j-1, k, ivz)
        tempd19 = -(dis4*dred)
        dis2d = dis2d + ddw4*drwd + ddw2*drud + ddw1*drd + ddw3*drvd + &
&         ddw5*dred
        ddw5d = dis2*dred - three*tempd19
        dis4d = dis4d - (temp31*temp32-temp33*temp34-three*ddw4)*drwd - &
&         (temp23*temp24-temp25*temp26-three*ddw2)*drud - (w(i, j+2, k, &
&         irho)-w(i, j-1, k, irho)-three*ddw1)*drd - (temp27*temp28-&
&         temp29*temp30-three*ddw3)*drvd - (w(i, j+2, k, irhoe)-w(i, j-1&
&         , k, irhoe)-three*ddw5)*dred
        wd(i, j+2, k, irhoe) = wd(i, j+2, k, irhoe) + tempd19
        wd(i, j-1, k, irhoe) = wd(i, j-1, k, irhoe) - tempd19
        wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddw5d
        wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
        tempd20 = -(dis4*drwd)
        ddw4d = dis2*drwd - three*tempd20
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp32*tempd20
        wd(i, j+2, k, ivz) = wd(i, j+2, k, ivz) + temp31*tempd20
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp34*tempd20
        wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - temp33*tempd20
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
&         ddw4d
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)*&
&         ddw4d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
        wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
        tempd21 = -(dis4*drvd)
        ddw3d = dis2*drvd - three*tempd21
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp28*tempd21
        wd(i, j+2, k, ivy) = wd(i, j+2, k, ivy) + temp27*tempd21
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp30*tempd21
        wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - temp29*tempd21
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
&         ddw3d
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)*&
&         ddw3d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
        wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
        tempd22 = -(dis4*drud)
        ddw2d = dis2*drud - three*tempd22
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp24*tempd22
        wd(i, j+2, k, ivx) = wd(i, j+2, k, ivx) + temp23*tempd22
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp26*tempd22
        wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - temp25*tempd22
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
&         ddw2d
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)*&
&         ddw2d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
        wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
        tempd23 = -(dis4*drd)
        ddw1d = dis2*drd - three*tempd23
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + tempd23
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - tempd23
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddw1d
        wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
        arg1d = 0.0_8
        call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
        min2d = ppor*fis2*dis2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          y2d = min2d
        else
          y2d = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dssd(i, j+1, k, 2) = dssd(i, j+1, k, 2) + y2d
        else
          dssd(i, j, k, 2) = dssd(i, j, k, 2) + y2d
        end if
      end do
      call popreal8(ppor)
      call popreal8(a2avg)
      call popreal8(drw)
      call popreal8(drv)
      call popreal8(dru)
      call popreal8(ddw6)
      call popreal8(havg)
      call popreal8(ddw4)
      call popreal8(ddw3)
      call popreal8(ddw2)
      call popreal8(dre)
      call popreal8(dis4)
      call popreal8(dis2)
      call popreal8(abv4)
      call popreal8(dr)
      call popreal8(area)
      call popinteger4(j)
      call popinteger4(i)
      call popreal8(aavg)
      call popreal8(sface)
      do ii=0,il*ny*nz-1
        i = mod(ii, il) + 1
        j = mod(ii/il, ny) + 2
        k = ii/(il*ny) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pori(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
          y1 = dss(i+1, j, k, 1)
          call pushcontrol1b(0)
        else
          y1 = dss(i, j, k, 1)
          call pushcontrol1b(1)
        end if
        if (dpmax .gt. y1) then
          min1 = y1
          call pushcontrol1b(0)
        else
          min1 = dpmax
          call pushcontrol1b(1)
        end if
        dis2 = ppor*fis2*min1
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-&
&         three*ddw1)
        ddw2 = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw2)
        ddw3 = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw3)
        ddw4 = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw4)
        ddw5 = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)-&
&           w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw6)
          kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
          call pushcontrol1b(1)
        else
          drk = zero
          kavg = zero
          call pushcontrol1b(0)
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(si(i, j, k, 1)**2 + si(i, j, k, 2)**2 + si(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max1 = area
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          max1 = 1.e-25_realtype
        end if
        tmp = one/max1
        sx = si(i, j, k, 1)*tmp
        sy = si(i, j, k, 2)*tmp
        sz = si(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) then
          sface = sfacei(i, j, k)*tmp
          call pushcontrol1b(1)
        else
          call pushcontrol1b(0)
        end if
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
          call pushcontrol1b(0)
        else
          lam1 = -(unavg-sface+aavg)
          call pushcontrol1b(1)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
          call pushcontrol1b(0)
        else
          lam2 = -(unavg-sface-aavg)
          call pushcontrol1b(1)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
          call pushcontrol1b(0)
        else
          lam3 = -(unavg-sface)
          call pushcontrol1b(1)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max2 = epsacoustic*rrad
          call pushcontrol1b(0)
        else
          max2 = lam1
          call pushcontrol1b(1)
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max2*area
        if (lam2 .lt. epsacoustic*rrad) then
          max3 = epsacoustic*rrad
          call pushcontrol1b(0)
        else
          max3 = lam2
          call pushcontrol1b(1)
        end if
        lam2 = max3*area
        if (lam3 .lt. epsshear*rrad) then
          max4 = epsshear*rrad
          call pushcontrol1b(0)
        else
          max4 = lam3
          call pushcontrol1b(1)
        end if
        lam3 = max4*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
        fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
        lam3d = dre*fsd
        dred = lam3*fsd
        havgd = abv6*fsd
        abv6d = havg*fsd
        unavgd = abv7*fsd
        abv7d = unavg*fsd
        fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
        lam3d = lam3d + drw*fsd
        drwd = lam3*fsd
        wavgd = abv6*fsd
        abv6d = abv6d + wavg*fsd
        szd = abv7*fsd
        abv7d = abv7d + sz*fsd
        fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
        lam3d = lam3d + drv*fsd
        drvd = lam3*fsd
        vavgd = abv6*fsd
        abv6d = abv6d + vavg*fsd
        syd = abv7*fsd
        abv7d = abv7d + sy*fsd
        fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
        lam3d = lam3d + dru*fsd
        drud = lam3*fsd
        uavgd = abv6*fsd
        abv6d = abv6d + uavg*fsd
        sxd = abv7*fsd
        abv7d = abv7d + sx*fsd
        fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
        abv6d = abv6d + fsd
        abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
        abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
        ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
        abv3d = ova2avg*abv4*abv6d + abv5*abv7d
        lam3d = lam3d + dr*fsd - abv3d
        abv5d = ovaavg*abv2*abv6d + abv3*abv7d
        ova2avgd = abv3*abv4*abv6d
        sxd = sxd + dru*abv5d
        syd = syd + drv*abv5d
        szd = szd + drw*abv5d
        unavgd = unavgd - dr*abv5d
        tempd18 = gm1*abv4d
        drd = alphaavg*tempd18 - unavg*abv5d + lam3*fsd
        drud = drud + sx*abv5d - uavg*tempd18
        drvd = drvd + sy*abv5d - vavg*tempd18
        drwd = drwd + sz*abv5d - wavg*tempd18
        alphaavgd = dr*tempd18
        uavgd = uavgd - dru*tempd18
        vavgd = vavgd - drv*tempd18
        dred = dred + tempd18
        wavgd = wavgd - drw*tempd18
        drkd = -(gm53*abv4d)
        abv1d = abv3d
        lam1d = half*abv1d + half*abv2d
        lam2d = half*abv1d - half*abv2d
        max4d = area*lam3d
        aread = max4*lam3d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = epsshear*max4d
          lam3d = 0.0_8
        else
          lam3d = max4d
          rradd = 0.0_8
        end if
        max3d = area*lam2d
        aread = aread + max3*lam2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = rradd + epsacoustic*max3d
          lam2d = 0.0_8
        else
          lam2d = max3d
        end if
        max2d = area*lam1d
        aread = aread + max2*lam1d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          rradd = rradd + epsacoustic*max2d
          lam1d = 0.0_8
        else
          lam1d = max2d
        end if
        lam3d = lam3d + rradd
        aavgd = rradd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam3d
          sfaced = sfaced - lam3d
        else
          sfaced = sfaced + lam3d
          unavgd = unavgd - lam3d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam2d
          sfaced = sfaced - lam2d
          aavgd = aavgd - lam2d
        else
          sfaced = sfaced + lam2d
          unavgd = unavgd - lam2d
          aavgd = aavgd + lam2d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          unavgd = unavgd + lam1d
          sfaced = sfaced - lam1d
          aavgd = aavgd + lam1d
        else
          sfaced = sfaced + lam1d
          unavgd = unavgd - lam1d
          aavgd = aavgd - lam1d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          tmpd = 0.0_8
        else
          tmpd = sfacei(i, j, k)*sfaced
          sfaced = 0.0_8
        end if
        alphaavgd = alphaavgd + havgd
        tempd17 = half*alphaavgd
        aavgd = aavgd - one*ovaavgd/aavg**2
        if (a2avg .eq. 0.0_8) then
          a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
        else
          a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*ova2avgd/&
&           a2avg**2
        end if
        uavgd = uavgd + 2*uavg*tempd17 + sx*unavgd
        sxd = sxd + uavg*unavgd
        vavgd = vavgd + 2*vavg*tempd17 + sy*unavgd
        syd = syd + vavg*unavgd
        wavgd = wavgd + 2*wavg*tempd17 + sz*unavgd
        szd = szd + wavg*unavgd
        kavgd = -(ovgm1*gm53*havgd)
        sid(i, j, k, 3) = sid(i, j, k, 3) + tmp*szd
        tmpd = tmpd + si(i, j, k, 2)*syd + si(i, j, k, 1)*sxd + si(i, j&
&         , k, 3)*szd
        sid(i, j, k, 2) = sid(i, j, k, 2) + tmp*syd
        sid(i, j, k, 1) = sid(i, j, k, 1) + tmp*sxd
        max1d = -(one*tmpd/max1**2)
        call popcontrol1b(branch)
        if (branch .eq. 0) aread = aread + max1d
        temp22 = si(i, j, k, 3)
        temp21 = si(i, j, k, 2)
        temp20 = si(i, j, k, 1)
        if (temp20**2 + temp21**2 + temp22**2 .eq. 0.0_8) then
          tempd14 = 0.0
        else
          tempd14 = aread/(2.0*sqrt(temp20**2+temp21**2+temp22**2))
        end if
        sid(i, j, k, 1) = sid(i, j, k, 1) + 2*temp20*tempd14
        sid(i, j, k, 2) = sid(i, j, k, 2) + 2*temp21*tempd14
        sid(i, j, k, 3) = sid(i, j, k, 3) + 2*temp22*tempd14
        temp19 = w(i, j, k, irho)
        temp18 = w(i+1, j, k, irho)
        tempd15 = gamma(i+1, j, k)*half*a2avgd/temp18
        tempd16 = gamma(i, j, k)*half*a2avgd/temp19
        pd(i+1, j, k) = pd(i+1, j, k) + tempd15
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - p(i+1, j, k)*tempd15&
&         /temp18
        pd(i, j, k) = pd(i, j, k) + tempd16
        wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd16/&
&         temp19
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wavgd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vavgd
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*uavgd
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dis2d = 0.0_8
          dis4d = 0.0_8
        else
          wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
          wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*kavgd
          temp17 = w(i-1, j, k, itu1)
          temp16 = w(i-1, j, k, irho)
          temp15 = w(i+2, j, k, itu1)
          temp14 = w(i+2, j, k, irho)
          tempd13 = -(dis4*drkd)
          dis2d = ddw6*drkd
          ddw6d = dis2*drkd - three*tempd13
          dis4d = -((temp14*temp15-temp16*temp17-three*ddw6)*drkd)
          wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp15*tempd13
          wd(i+2, j, k, itu1) = wd(i+2, j, k, itu1) + temp14*tempd13
          wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp17*tempd13
          wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) - temp16*tempd13
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, itu1)&
&           *ddw6d
          wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + w(i+1, j, k, irho)&
&           *ddw6d
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*ddw6d
          wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*ddw6d
        end if
        temp2 = w(i+2, j, k, irho)
        temp3 = w(i+2, j, k, ivx)
        temp4 = w(i-1, j, k, irho)
        temp5 = w(i-1, j, k, ivx)
        temp6 = w(i+2, j, k, irho)
        temp7 = w(i+2, j, k, ivy)
        temp8 = w(i-1, j, k, irho)
        temp9 = w(i-1, j, k, ivy)
        temp10 = w(i+2, j, k, irho)
        temp11 = w(i+2, j, k, ivz)
        temp12 = w(i-1, j, k, irho)
        temp13 = w(i-1, j, k, ivz)
        tempd8 = -(dis4*dred)
        dis2d = dis2d + ddw4*drwd + ddw2*drud + ddw1*drd + ddw3*drvd + &
&         ddw5*dred
        ddw5d = dis2*dred - three*tempd8
        dis4d = dis4d - (temp10*temp11-temp12*temp13-three*ddw4)*drwd - &
&         (temp2*temp3-temp4*temp5-three*ddw2)*drud - (w(i+2, j, k, irho&
&         )-w(i-1, j, k, irho)-three*ddw1)*drd - (temp6*temp7-temp8*&
&         temp9-three*ddw3)*drvd - (w(i+2, j, k, irhoe)-w(i-1, j, k, &
&         irhoe)-three*ddw5)*dred
        wd(i+2, j, k, irhoe) = wd(i+2, j, k, irhoe) + tempd8
        wd(i-1, j, k, irhoe) = wd(i-1, j, k, irhoe) - tempd8
        wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddw5d
        wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
        tempd9 = -(dis4*drwd)
        ddw4d = dis2*drwd - three*tempd9
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp11*tempd9
        wd(i+2, j, k, ivz) = wd(i+2, j, k, ivz) + temp10*tempd9
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp13*tempd9
        wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - temp12*tempd9
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
&         ddw4d
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)*&
&         ddw4d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
        wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
        tempd10 = -(dis4*drvd)
        ddw3d = dis2*drvd - three*tempd10
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp7*tempd10
        wd(i+2, j, k, ivy) = wd(i+2, j, k, ivy) + temp6*tempd10
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp9*tempd10
        wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - temp8*tempd10
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
&         ddw3d
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)*&
&         ddw3d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
        wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
        tempd11 = -(dis4*drud)
        ddw2d = dis2*drud - three*tempd11
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp3*tempd11
        wd(i+2, j, k, ivx) = wd(i+2, j, k, ivx) + temp2*tempd11
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp5*tempd11
        wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - temp4*tempd11
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
&         ddw2d
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)*&
&         ddw2d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
        wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
        tempd12 = -(dis4*drd)
        ddw1d = dis2*drd - three*tempd12
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + tempd12
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - tempd12
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddw1d
        wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
        arg1d = 0.0_8
        call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
        min1d = ppor*fis2*dis2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          y1d = min1d
        else
          y1d = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dssd(i+1, j, k, 1) = dssd(i+1, j, k, 1) + y1d
        else
          dssd(i, j, k, 1) = dssd(i, j, k, 1) + y1d
        end if
      end do
      call popinteger4(j)
      call popinteger4(i)
      plimd = 0.0_8
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
        if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
          abs1 = p(i+1, j, k) - p(i, j, k)
          call pushcontrol1b(1)
        else
          abs1 = -(p(i+1, j, k)-p(i, j, k))
          call pushcontrol1b(0)
        end if
        if (p(i, j, k) - p(i-1, j, k) .ge. 0.) then
          abs4 = p(i, j, k) - p(i-1, j, k)
          call pushcontrol1b(0)
        else
          abs4 = -(p(i, j, k)-p(i-1, j, k))
          call pushcontrol1b(1)
        end if
        x1 = (p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))/(omega*(p(i+1, j&
&         , k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+abs4)+plim&
&         )
        if (x1 .ge. 0.) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
          abs2 = p(i, j+1, k) - p(i, j, k)
          call pushcontrol1b(1)
        else
          abs2 = -(p(i, j+1, k)-p(i, j, k))
          call pushcontrol1b(0)
        end if
        if (p(i, j, k) - p(i, j-1, k) .ge. 0.) then
          abs5 = p(i, j, k) - p(i, j-1, k)
          call pushcontrol1b(0)
        else
          abs5 = -(p(i, j, k)-p(i, j-1, k))
          call pushcontrol1b(1)
        end if
        x2 = (p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))/(omega*(p(i, j+1&
&         , k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+abs5)+plim&
&         )
        if (x2 .ge. 0.) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
          abs3 = p(i, j, k+1) - p(i, j, k)
          call pushcontrol1b(1)
        else
          abs3 = -(p(i, j, k+1)-p(i, j, k))
          call pushcontrol1b(0)
        end if
        if (p(i, j, k) - p(i, j, k-1) .ge. 0.) then
          abs6 = p(i, j, k) - p(i, j, k-1)
          call pushcontrol1b(0)
        else
          abs6 = -(p(i, j, k)-p(i, j, k-1))
          call pushcontrol1b(1)
        end if
        x3 = (p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))/(omega*(p(i, j, &
&         k+1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+abs6)+plim&
&         )
        if (x3 .ge. 0.) then
          x3d = dssd(i, j, k, 3)
          dssd(i, j, k, 3) = 0.0_8
        else
          x3d = -dssd(i, j, k, 3)
          dssd(i, j, k, 3) = 0.0_8
        end if
        temp1 = omega*(p(i, j, k+1)+two*p(i, j, k)+p(i, j, k-1)) + &
&         oneminomega*(abs3+abs6) + plim
        tempd5 = x3d/temp1
        tempd6 = -((p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))*tempd5/&
&         temp1)
        tempd7 = omega*tempd6
        pd(i, j, k+1) = pd(i, j, k+1) + tempd7 + tempd5
        pd(i, j, k) = pd(i, j, k) + two*tempd7 - two*tempd5
        pd(i, j, k-1) = pd(i, j, k-1) + tempd7 + tempd5
        abs3d = oneminomega*tempd6
        abs6d = oneminomega*tempd6
        plimd = plimd + tempd6
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          pd(i, j, k) = pd(i, j, k) + abs6d
          pd(i, j, k-1) = pd(i, j, k-1) - abs6d
        else
          pd(i, j, k-1) = pd(i, j, k-1) + abs6d
          pd(i, j, k) = pd(i, j, k) - abs6d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          pd(i, j, k) = pd(i, j, k) + abs3d
          pd(i, j, k+1) = pd(i, j, k+1) - abs3d
        else
          pd(i, j, k+1) = pd(i, j, k+1) + abs3d
          pd(i, j, k) = pd(i, j, k) - abs3d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x2d = dssd(i, j, k, 2)
          dssd(i, j, k, 2) = 0.0_8
        else
          x2d = -dssd(i, j, k, 2)
          dssd(i, j, k, 2) = 0.0_8
        end if
        temp0 = omega*(p(i, j+1, k)+two*p(i, j, k)+p(i, j-1, k)) + &
&         oneminomega*(abs2+abs5) + plim
        tempd2 = x2d/temp0
        tempd3 = -((p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))*tempd2/&
&         temp0)
        tempd4 = omega*tempd3
        pd(i, j+1, k) = pd(i, j+1, k) + tempd4 + tempd2
        pd(i, j, k) = pd(i, j, k) + two*tempd4 - two*tempd2
        pd(i, j-1, k) = pd(i, j-1, k) + tempd4 + tempd2
        abs2d = oneminomega*tempd3
        abs5d = oneminomega*tempd3
        plimd = plimd + tempd3
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          pd(i, j, k) = pd(i, j, k) + abs5d
          pd(i, j-1, k) = pd(i, j-1, k) - abs5d
        else
          pd(i, j-1, k) = pd(i, j-1, k) + abs5d
          pd(i, j, k) = pd(i, j, k) - abs5d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          pd(i, j, k) = pd(i, j, k) + abs2d
          pd(i, j+1, k) = pd(i, j+1, k) - abs2d
        else
          pd(i, j+1, k) = pd(i, j+1, k) + abs2d
          pd(i, j, k) = pd(i, j, k) - abs2d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x1d = dssd(i, j, k, 1)
          dssd(i, j, k, 1) = 0.0_8
        else
          x1d = -dssd(i, j, k, 1)
          dssd(i, j, k, 1) = 0.0_8
        end if
        temp = omega*(p(i+1, j, k)+two*p(i, j, k)+p(i-1, j, k)) + &
&         oneminomega*(abs1+abs4) + plim
        tempd = x1d/temp
        tempd0 = -((p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))*tempd/temp&
&         )
        tempd1 = omega*tempd0
        pd(i+1, j, k) = pd(i+1, j, k) + tempd1 + tempd
        pd(i, j, k) = pd(i, j, k) + two*tempd1 - two*tempd
        pd(i-1, j, k) = pd(i-1, j, k) + tempd1 + tempd
        abs1d = oneminomega*tempd0
        abs4d = oneminomega*tempd0
        plimd = plimd + tempd0
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          pd(i, j, k) = pd(i, j, k) + abs4d
          pd(i-1, j, k) = pd(i-1, j, k) - abs4d
        else
          pd(i-1, j, k) = pd(i-1, j, k) + abs4d
          pd(i, j, k) = pd(i, j, k) - abs4d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          pd(i, j, k) = pd(i, j, k) + abs1d
          pd(i+1, j, k) = pd(i+1, j, k) - abs1d
        else
          pd(i+1, j, k) = pd(i+1, j, k) + abs1d
          pd(i, j, k) = pd(i, j, k) - abs1d
        end if
      end do
      fwd = sfil*fwd
      pinfcorrd = pinfcorrd + 0.001_realtype*plimd
    end if
  end subroutine invisciddissfluxmatrix_b
  subroutine invisciddissfluxmatrix()
!
!       invisciddissfluxmatrix computes the matrix artificial
!       dissipation term. instead of the spectral radius, as used in
!       the scalar dissipation scheme, the absolute value of the flux
!       jacobian is used. this leads to a less diffusive and
!       consequently more accurate scheme. it is assumed that the
!       pointers in blockpointers already point to the correct block.
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, p, pori, porj, pork, fw, gamma, si, sj, sk, indfamilyi, &
&   indfamilyj, indfamilyk, spectralsol, addgridvelocities, sfacei, &
&   sfacej, sfacek, factfamilyi, factfamilyj, factfamilyk
    use flowvarrefstate, only : pinfcorr
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use cgnsgrid, only : massflowfamilydiss
    use utils_b, only : getcorrectfork, mydim
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: dp1, dp2, tmp, fs
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, ddw6
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    logical :: correctfork
    intrinsic abs
    intrinsic mod
    intrinsic max
    intrinsic min
    intrinsic sqrt
    real(kind=realtype) :: arg1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max9
    real(kind=realtype) :: max8
    real(kind=realtype) :: max7
    real(kind=realtype) :: max6
    real(kind=realtype) :: max5
    real(kind=realtype) :: max4
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: max12
    real(kind=realtype) :: max11
    real(kind=realtype) :: max10
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value.
      fw = sfil*fw
! compute the pressure sensor for each cell, in each direction:
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
        if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
          abs1 = p(i+1, j, k) - p(i, j, k)
        else
          abs1 = -(p(i+1, j, k)-p(i, j, k))
        end if
        if (p(i, j, k) - p(i-1, j, k) .ge. 0.) then
          abs4 = p(i, j, k) - p(i-1, j, k)
        else
          abs4 = -(p(i, j, k)-p(i-1, j, k))
        end if
        x1 = (p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))/(omega*(p(i+1, j&
&         , k)+two*p(i, j, k)+p(i-1, j, k))+oneminomega*(abs1+abs4)+plim&
&         )
        if (x1 .ge. 0.) then
          dss(i, j, k, 1) = x1
        else
          dss(i, j, k, 1) = -x1
        end if
        if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
          abs2 = p(i, j+1, k) - p(i, j, k)
        else
          abs2 = -(p(i, j+1, k)-p(i, j, k))
        end if
        if (p(i, j, k) - p(i, j-1, k) .ge. 0.) then
          abs5 = p(i, j, k) - p(i, j-1, k)
        else
          abs5 = -(p(i, j, k)-p(i, j-1, k))
        end if
        x2 = (p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))/(omega*(p(i, j+1&
&         , k)+two*p(i, j, k)+p(i, j-1, k))+oneminomega*(abs2+abs5)+plim&
&         )
        if (x2 .ge. 0.) then
          dss(i, j, k, 2) = x2
        else
          dss(i, j, k, 2) = -x2
        end if
        if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
          abs3 = p(i, j, k+1) - p(i, j, k)
        else
          abs3 = -(p(i, j, k+1)-p(i, j, k))
        end if
        if (p(i, j, k) - p(i, j, k-1) .ge. 0.) then
          abs6 = p(i, j, k) - p(i, j, k-1)
        else
          abs6 = -(p(i, j, k)-p(i, j, k-1))
        end if
        x3 = (p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))/(omega*(p(i, j, &
&         k+1)+two*p(i, j, k)+p(i, j, k-1))+oneminomega*(abs3+abs6)+plim&
&         )
        if (x3 .ge. 0.) then
          dss(i, j, k, 3) = x3
        else
          dss(i, j, k, 3) = -x3
        end if
      end do
!
!       dissipative fluxes in the i-direction.
!
      do ii=0,il*ny*nz-1
        i = mod(ii, il) + 1
        j = mod(ii/il, ny) + 2
        k = ii/(il*ny) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pori(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
          y1 = dss(i+1, j, k, 1)
        else
          y1 = dss(i, j, k, 1)
        end if
        if (dpmax .gt. y1) then
          min1 = y1
        else
          min1 = dpmax
        end if
        dis2 = ppor*fis2*min1
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-&
&         three*ddw1)
        ddw2 = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw2)
        ddw3 = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw3)
        ddw4 = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(i&
&         -1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw4)
        ddw5 = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)-&
&           w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw6)
          kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
        else
          drk = zero
          kavg = zero
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(si(i, j, k, 1)**2 + si(i, j, k, 2)**2 + si(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max1 = area
        else
          max1 = 1.e-25_realtype
        end if
        tmp = one/max1
        sx = si(i, j, k, 1)*tmp
        sy = si(i, j, k, 2)*tmp
        sz = si(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) sface = sfacei(i, j, k)*tmp
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
        else
          lam1 = -(unavg-sface+aavg)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
        else
          lam2 = -(unavg-sface-aavg)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
        else
          lam3 = -(unavg-sface)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max2 = epsacoustic*rrad
        else
          max2 = lam1
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max2*area
        if (lam2 .lt. epsacoustic*rrad) then
          max3 = epsacoustic*rrad
        else
          max3 = lam2
        end if
        lam2 = max3*area
        if (lam3 .lt. epsshear*rrad) then
          max4 = epsshear*rrad
        else
          max4 = lam3
        end if
        lam3 = max4*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
        fs = lam3*dr + abv6
        fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        fs = lam3*dru + uavg*abv6 + sx*abv7
        fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        fs = lam3*drv + vavg*abv6 + sy*abv7
        fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        fs = lam3*drw + wavg*abv6 + sz*abv7
        fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        fs = lam3*dre + havg*abv6 + unavg*abv7
        fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
!
!       dissipative fluxes in the j-direction.
!
      do ii=0,nx*jl*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, jl) + 1
        k = ii/(nx*jl) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (porj(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
          y2 = dss(i, j+1, k, 2)
        else
          y2 = dss(i, j, k, 2)
        end if
        if (dpmax .gt. y2) then
          min2 = y2
        else
          min2 = dpmax
        end if
        dis2 = ppor*fis2*min2
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-&
&         three*ddw1)
        ddw2 = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw2)
        ddw3 = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw3)
        ddw4 = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(i&
&         , j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw4)
        ddw5 = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)-&
&           w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw6)
          kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
        else
          drk = zero
          kavg = zero
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(sj(i, j, k, 1)**2 + sj(i, j, k, 2)**2 + sj(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max5 = area
        else
          max5 = 1.e-25_realtype
        end if
        tmp = one/max5
        sx = sj(i, j, k, 1)*tmp
        sy = sj(i, j, k, 2)*tmp
        sz = sj(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) sface = sfacej(i, j, k)*tmp
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
        else
          lam1 = -(unavg-sface+aavg)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
        else
          lam2 = -(unavg-sface-aavg)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
        else
          lam3 = -(unavg-sface)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max6 = epsacoustic*rrad
        else
          max6 = lam1
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max6*area
        if (lam2 .lt. epsacoustic*rrad) then
          max7 = epsacoustic*rrad
        else
          max7 = lam2
        end if
        lam2 = max7*area
        if (lam3 .lt. epsshear*rrad) then
          max8 = epsshear*rrad
        else
          max8 = lam3
        end if
        lam3 = max8*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
        fs = lam3*dr + abv6
        fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        fs = lam3*dru + uavg*abv6 + sx*abv7
        fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        fs = lam3*drv + vavg*abv6 + sy*abv7
        fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        fs = lam3*drw + wavg*abv6 + sz*abv7
        fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        fs = lam3*dre + havg*abv6 + unavg*abv7
        fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
!
!       dissipative fluxes in the k-direction.
!
      do ii=0,nx*ny*kl-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 1
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pork(i, j, k) .eq. normalflux) ppor = one
        if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
          y3 = dss(i, j, k+1, 3)
        else
          y3 = dss(i, j, k, 3)
        end if
        if (dpmax .gt. y3) then
          min3 = y3
        else
          min3 = dpmax
        end if
        dis2 = ppor*fis2*min3
        arg1 = ppor*fis4
        dis4 = mydim(arg1, dis2)
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
        ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
        dr = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)-&
&         three*ddw1)
        ddw2 = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*w&
&         (i, j, k, ivx)
        dru = dis2*ddw2 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)-w(i&
&         , j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw2)
        ddw3 = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*w&
&         (i, j, k, ivy)
        drv = dis2*ddw3 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)-w(i&
&         , j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw3)
        ddw4 = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*w&
&         (i, j, k, ivz)
        drw = dis2*ddw4 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)-w(i&
&         , j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw4)
        ddw5 = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
        dre = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, irhoe)-&
&         three*ddw5)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
        if (correctfork) then
          ddw6 = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, irho&
&           )*w(i, j, k, itu1)
          drk = dis2*ddw6 - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, itu1)-&
&           w(i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw6)
          kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
        else
          drk = zero
          kavg = zero
        end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
        gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
        gm1 = gammaavg - one
        ovgm1 = one/gm1
        gm53 = gammaavg - five*third
! compute the average state at the interface.
        uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
        vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
        wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
        a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)+&
&         gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
        area = sqrt(sk(i, j, k, 1)**2 + sk(i, j, k, 2)**2 + sk(i, j, k, &
&         3)**2)
        if (1.e-25_realtype .lt. area) then
          max9 = area
        else
          max9 = 1.e-25_realtype
        end if
        tmp = one/max9
        sx = sk(i, j, k, 1)*tmp
        sy = sk(i, j, k, 2)*tmp
        sz = sk(i, j, k, 3)*tmp
        alphaavg = half*(uavg**2+vavg**2+wavg**2)
        havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
        aavg = sqrt(a2avg)
        unavg = uavg*sx + vavg*sy + wavg*sz
        ovaavg = one/aavg
        ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
        if (addgridvelocities) sface = sfacek(i, j, k)*tmp
        if (unavg - sface + aavg .ge. 0.) then
          lam1 = unavg - sface + aavg
        else
          lam1 = -(unavg-sface+aavg)
        end if
        if (unavg - sface - aavg .ge. 0.) then
          lam2 = unavg - sface - aavg
        else
          lam2 = -(unavg-sface-aavg)
        end if
        if (unavg - sface .ge. 0.) then
          lam3 = unavg - sface
        else
          lam3 = -(unavg-sface)
        end if
        rrad = lam3 + aavg
        if (lam1 .lt. epsacoustic*rrad) then
          max10 = epsacoustic*rrad
        else
          max10 = lam1
        end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
        lam1 = max10*area
        if (lam2 .lt. epsacoustic*rrad) then
          max11 = epsacoustic*rrad
        else
          max11 = lam2
        end if
        lam2 = max11*area
        if (lam3 .lt. epsshear*rrad) then
          max12 = epsshear*rrad
        else
          max12 = lam3
        end if
        lam3 = max12*area
! some abbreviations, which occur quite often in the
! dissipation terms.
        abv1 = half*(lam1+lam2)
        abv2 = half*(lam1-lam2)
        abv3 = abv1 - lam3
        abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
&         drk
        abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
        abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
        abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
        fs = lam3*dr + abv6
        fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        fs = lam3*dru + uavg*abv6 + sx*abv7
        fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        fs = lam3*drv + vavg*abv6 + sy*abv7
        fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        fs = lam3*drw + wavg*abv6 + sz*abv7
        fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        fs = lam3*dre + havg*abv6 + unavg*abv7
        fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
    end if
  end subroutine invisciddissfluxmatrix
!  differentiation of invisciddissfluxscalar in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: rhoinf pinfcorr *p *w *fw
!   with respect to varying inputs: rhoinf pinfcorr *p *w *fw *radi
!                *radj *radk
!   rw status of diff variables: rhoinf:incr pinfcorr:incr *p:incr
!                *w:incr *fw:in-out *radi:out *radj:out *radk:out
!   plus diff mem management of: p:in w:in fw:in radi:in radj:in
!                radk:in
  subroutine invisciddissfluxscalar_b()
!
!       invisciddissfluxscalar computes the scalar artificial
!       dissipation, see aiaa paper 81-1259, for a given block.
!       therefore it is assumed that the pointers in  blockpointers
!       already point to the correct block.
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, wd, p, pd, pori, porj, pork, fw, fwd, radi, radid, radj, &
&   radjd, radk, radkd, gamma
    use flowvarrefstate, only : gammainf, pinfcorr, pinfcorrd, rhoinf,&
&   rhoinfd
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use utils_b, only : mydim, mydim_b
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: sslimd
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: rradd, dis2d, dis4d
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, fs
    real(kind=realtype) :: ddw1d, ddw2d, ddw3d, ddw4d, ddw5d, fsd
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    real(kind=realtype), dimension(ie, je, ke, 3) :: dssd
    real(kind=realtype), dimension(0:ib, 0:jb, 0:kb) :: ss
    real(kind=realtype), dimension(0:ib, 0:jb, 0:kb) :: ssd
    intrinsic abs
    intrinsic mod
    intrinsic max
    intrinsic min
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp29
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp28
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp27
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp26
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: temp25
    real(kind=realtype) :: temp24
    real(kind=realtype) :: temp23
    real(kind=realtype) :: temp22
    real(kind=realtype) :: temp21
    real(kind=realtype) :: temp20
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: min1d
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x1
    real(kind=realtype) :: temp19
    real(kind=realtype) :: temp18
    real(kind=realtype) :: temp17
    real(kind=realtype) :: temp16
    real(kind=realtype) :: temp15
    real(kind=realtype) :: temp14
    real(kind=realtype) :: temp13
    real(kind=realtype) :: y3d
    real(kind=realtype) :: temp12
    real(kind=realtype) :: temp11
    real(kind=realtype) :: temp10
    real(kind=realtype) :: temp41
    real(kind=realtype) :: temp40
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: x1d
    real(kind=realtype) :: min3d
    real(kind=realtype) :: y2d
    real(kind=realtype) :: temp39
    real(kind=realtype) :: temp38
    real(kind=realtype) :: temp37
    real(kind=realtype) :: temp36
    real(kind=realtype) :: temp35
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: temp34
    real(kind=realtype) :: temp33
    real(kind=realtype) :: temp32
    real(kind=realtype) :: temp31
    real(kind=realtype) :: temp30
    real(kind=realtype) :: abs0
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp9
    real(kind=realtype) :: temp8
    real(kind=realtype) :: min2d
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: temp7
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: y3
    real(kind=realtype) :: temp6
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: y2
    real(kind=realtype) :: temp5
    real(kind=realtype) :: x3d
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: y1
    real(kind=realtype) :: temp4
    real(kind=realtype) :: y1d
    real(kind=realtype) :: tempd15
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      radid = 0.0_8
      radjd = 0.0_8
      radkd = 0.0_8
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations)
      case (eulerequations)
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr
! copy the pressure in ss. only need the entries used in the
! discretization, i.e. not including the corner halo's, but we'll
! just copy all anyway.
        ss = p
        call pushcontrol2b(1)
      case (nsequations, ransequations)
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr/rhoinf**gammainf
! store the entropy in ss. see above.
        do ii=0,(ib+1)*(jb+1)*(kb+1)-1
          i = mod(ii, ib + 1)
          j = mod(ii/(ib+1), jb + 1)
          k = ii/((ib+1)*(jb+1))
          ss(i, j, k) = p(i, j, k)/w(i, j, k, irho)**gamma(i, j, k)
        end do
        call pushcontrol2b(0)
      case default
        call pushcontrol2b(2)
      end select
      call pushinteger4(i)
      call pushinteger4(j)
! compute the pressure sensor for each cell, in each direction:
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
        x1 = (ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))/(ss(i+1, j, k&
&         )+two*ss(i, j, k)+ss(i-1, j, k)+sslim)
        if (x1 .ge. 0.) then
          dss(i, j, k, 1) = x1
        else
          dss(i, j, k, 1) = -x1
        end if
        x2 = (ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))/(ss(i, j+1, k&
&         )+two*ss(i, j, k)+ss(i, j-1, k)+sslim)
        if (x2 .ge. 0.) then
          dss(i, j, k, 2) = x2
        else
          dss(i, j, k, 2) = -x2
        end if
        x3 = (ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))/(ss(i, j, k+1&
&         )+two*ss(i, j, k)+ss(i, j, k-1)+sslim)
        if (x3 .ge. 0.) then
          dss(i, j, k, 3) = x3
        else
          dss(i, j, k, 3) = -x3
        end if
      end do
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      call pushinteger4(i)
      call pushinteger4(j)
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(dis4)
      call pushreal8(ddw2)
      call pushreal8(ddw3)
      call pushreal8(ddw4)
      call pushreal8(ddw5)
      call pushreal8(ppor)
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(dis4)
      call pushreal8(ddw2)
      call pushreal8(ddw3)
      call pushreal8(ddw4)
      call pushreal8(ddw5)
      call pushreal8(ppor)
      radkd = 0.0_8
      dssd = 0.0_8
      do ii=0,nx*ny*kl-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 1
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pork(i, j, k) .eq. normalflux) ppor = half
        rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
        if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
          y3 = dss(i, j, k+1, 3)
          call pushcontrol1b(0)
        else
          y3 = dss(i, j, k, 3)
          call pushcontrol1b(1)
        end if
        if (dssmax .gt. y3) then
          min3 = y3
          call pushcontrol1b(0)
        else
          min3 = dssmax
          call pushcontrol1b(1)
        end if
        dis2 = fis2*rrad*min3
        arg1 = fis4*rrad
        dis4 = mydim(arg1, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
        ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
! x-momentum.
        ddw2 = w(i, j, k+1, ivx)*w(i, j, k+1, irho) - w(i, j, k, ivx)*w(&
&         i, j, k, irho)
! y-momentum.
        ddw3 = w(i, j, k+1, ivy)*w(i, j, k+1, irho) - w(i, j, k, ivy)*w(&
&         i, j, k, irho)
! z-momentum.
        ddw4 = w(i, j, k+1, ivz)*w(i, j, k+1, irho) - w(i, j, k, ivz)*w(&
&         i, j, k, irho)
! energy.
        ddw5 = w(i, j, k+1, irhoe) + p(i, j, k+1) - (w(i, j, k, irhoe)+p&
&         (i, j, k))
        fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
        tempd16 = -(dis4*fsd)
        dis2d = ddw5*fsd
        ddw5d = dis2*fsd - three*tempd16
        dis4d = -((w(i, j, k+2, irhoe)+p(i, j, k+2)-w(i, j, k-1, irhoe)-&
&         p(i, j, k-1)-three*ddw5)*fsd)
        wd(i, j, k+2, irhoe) = wd(i, j, k+2, irhoe) + tempd16
        pd(i, j, k+2) = pd(i, j, k+2) + tempd16
        wd(i, j, k-1, irhoe) = wd(i, j, k-1, irhoe) - tempd16
        pd(i, j, k-1) = pd(i, j, k-1) - tempd16
        wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddw5d
        pd(i, j, k+1) = pd(i, j, k+1) + ddw5d
        wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
        pd(i, j, k) = pd(i, j, k) - ddw5d
        fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
        temp41 = w(i, j, k-1, irho)
        temp40 = w(i, j, k-1, ivz)
        temp39 = w(i, j, k+2, irho)
        temp38 = w(i, j, k+2, ivz)
        tempd17 = -(dis4*fsd)
        dis2d = dis2d + ddw4*fsd
        ddw4d = dis2*fsd - three*tempd17
        dis4d = dis4d - (temp38*temp39-temp40*temp41-three*ddw4)*fsd
        wd(i, j, k+2, ivz) = wd(i, j, k+2, ivz) + temp39*tempd17
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp38*tempd17
        wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - temp41*tempd17
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp40*tempd17
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)*&
&         ddw4d
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
&         ddw4d
        wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
        fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
        temp37 = w(i, j, k-1, irho)
        temp36 = w(i, j, k-1, ivy)
        temp35 = w(i, j, k+2, irho)
        temp34 = w(i, j, k+2, ivy)
        tempd18 = -(dis4*fsd)
        dis2d = dis2d + ddw3*fsd
        ddw3d = dis2*fsd - three*tempd18
        dis4d = dis4d - (temp34*temp35-temp36*temp37-three*ddw3)*fsd
        wd(i, j, k+2, ivy) = wd(i, j, k+2, ivy) + temp35*tempd18
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp34*tempd18
        wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - temp37*tempd18
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp36*tempd18
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)*&
&         ddw3d
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
&         ddw3d
        wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
        fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
        temp33 = w(i, j, k-1, irho)
        temp32 = w(i, j, k-1, ivx)
        temp31 = w(i, j, k+2, irho)
        temp30 = w(i, j, k+2, ivx)
        tempd19 = -(dis4*fsd)
        dis2d = dis2d + ddw2*fsd
        ddw2d = dis2*fsd - three*tempd19
        dis4d = dis4d - (temp30*temp31-temp32*temp33-three*ddw2)*fsd
        wd(i, j, k+2, ivx) = wd(i, j, k+2, ivx) + temp31*tempd19
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp30*tempd19
        wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - temp33*tempd19
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp32*tempd19
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)*&
&         ddw2d
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
&         ddw2d
        wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
        fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
        tempd20 = -(dis4*fsd)
        dis2d = dis2d + ddw1*fsd
        ddw1d = dis2*fsd - three*tempd20
        dis4d = dis4d - (w(i, j, k+2, irho)-w(i, j, k-1, irho)-three*&
&         ddw1)*fsd
        wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + tempd20
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - tempd20
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddw1d
        wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
        arg1d = 0.0_8
        call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
        rradd = fis2*min3*dis2d + fis4*arg1d
        min3d = fis2*rrad*dis2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          y3d = min3d
        else
          y3d = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dssd(i, j, k+1, 3) = dssd(i, j, k+1, 3) + y3d
        else
          dssd(i, j, k, 3) = dssd(i, j, k, 3) + y3d
        end if
        radkd(i, j, k) = radkd(i, j, k) + ppor*rradd
        radkd(i, j, k+1) = radkd(i, j, k+1) + ppor*rradd
      end do
      call popreal8(ppor)
      call popreal8(ddw5)
      call popreal8(ddw4)
      call popreal8(ddw3)
      call popreal8(ddw2)
      call popreal8(dis4)
      call popinteger4(j)
      call popinteger4(i)
      radjd = 0.0_8
      do ii=0,nx*jl*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, jl) + 1
        k = ii/(nx*jl) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (porj(i, j, k) .eq. normalflux) ppor = half
        rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
        if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
          y2 = dss(i, j+1, k, 2)
          call pushcontrol1b(0)
        else
          y2 = dss(i, j, k, 2)
          call pushcontrol1b(1)
        end if
        if (dssmax .gt. y2) then
          min2 = y2
          call pushcontrol1b(0)
        else
          min2 = dssmax
          call pushcontrol1b(1)
        end if
        dis2 = fis2*rrad*min2
        arg1 = fis4*rrad
        dis4 = mydim(arg1, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
        ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
! x-momentum.
        ddw2 = w(i, j+1, k, ivx)*w(i, j+1, k, irho) - w(i, j, k, ivx)*w(&
&         i, j, k, irho)
! y-momentum.
        ddw3 = w(i, j+1, k, ivy)*w(i, j+1, k, irho) - w(i, j, k, ivy)*w(&
&         i, j, k, irho)
! z-momentum.
        ddw4 = w(i, j+1, k, ivz)*w(i, j+1, k, irho) - w(i, j, k, ivz)*w(&
&         i, j, k, irho)
! energy.
        ddw5 = w(i, j+1, k, irhoe) + p(i, j+1, k) - (w(i, j, k, irhoe)+p&
&         (i, j, k))
        fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
        tempd11 = -(dis4*fsd)
        dis2d = ddw5*fsd
        ddw5d = dis2*fsd - three*tempd11
        dis4d = -((w(i, j+2, k, irhoe)+p(i, j+2, k)-w(i, j-1, k, irhoe)-&
&         p(i, j-1, k)-three*ddw5)*fsd)
        wd(i, j+2, k, irhoe) = wd(i, j+2, k, irhoe) + tempd11
        pd(i, j+2, k) = pd(i, j+2, k) + tempd11
        wd(i, j-1, k, irhoe) = wd(i, j-1, k, irhoe) - tempd11
        pd(i, j-1, k) = pd(i, j-1, k) - tempd11
        wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddw5d
        pd(i, j+1, k) = pd(i, j+1, k) + ddw5d
        wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
        pd(i, j, k) = pd(i, j, k) - ddw5d
        fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
        temp29 = w(i, j-1, k, irho)
        temp28 = w(i, j-1, k, ivz)
        temp27 = w(i, j+2, k, irho)
        temp26 = w(i, j+2, k, ivz)
        tempd12 = -(dis4*fsd)
        dis2d = dis2d + ddw4*fsd
        ddw4d = dis2*fsd - three*tempd12
        dis4d = dis4d - (temp26*temp27-temp28*temp29-three*ddw4)*fsd
        wd(i, j+2, k, ivz) = wd(i, j+2, k, ivz) + temp27*tempd12
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp26*tempd12
        wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - temp29*tempd12
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp28*tempd12
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)*&
&         ddw4d
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
&         ddw4d
        wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
        fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
        temp25 = w(i, j-1, k, irho)
        temp24 = w(i, j-1, k, ivy)
        temp23 = w(i, j+2, k, irho)
        temp22 = w(i, j+2, k, ivy)
        tempd13 = -(dis4*fsd)
        dis2d = dis2d + ddw3*fsd
        ddw3d = dis2*fsd - three*tempd13
        dis4d = dis4d - (temp22*temp23-temp24*temp25-three*ddw3)*fsd
        wd(i, j+2, k, ivy) = wd(i, j+2, k, ivy) + temp23*tempd13
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp22*tempd13
        wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - temp25*tempd13
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp24*tempd13
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)*&
&         ddw3d
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
&         ddw3d
        wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
        fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
        temp21 = w(i, j-1, k, irho)
        temp20 = w(i, j-1, k, ivx)
        temp19 = w(i, j+2, k, irho)
        temp18 = w(i, j+2, k, ivx)
        tempd14 = -(dis4*fsd)
        dis2d = dis2d + ddw2*fsd
        ddw2d = dis2*fsd - three*tempd14
        dis4d = dis4d - (temp18*temp19-temp20*temp21-three*ddw2)*fsd
        wd(i, j+2, k, ivx) = wd(i, j+2, k, ivx) + temp19*tempd14
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp18*tempd14
        wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - temp21*tempd14
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp20*tempd14
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)*&
&         ddw2d
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
&         ddw2d
        wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
        fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
        tempd15 = -(dis4*fsd)
        dis2d = dis2d + ddw1*fsd
        ddw1d = dis2*fsd - three*tempd15
        dis4d = dis4d - (w(i, j+2, k, irho)-w(i, j-1, k, irho)-three*&
&         ddw1)*fsd
        wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + tempd15
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - tempd15
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddw1d
        wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
        arg1d = 0.0_8
        call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
        rradd = fis2*min2*dis2d + fis4*arg1d
        min2d = fis2*rrad*dis2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          y2d = min2d
        else
          y2d = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dssd(i, j+1, k, 2) = dssd(i, j+1, k, 2) + y2d
        else
          dssd(i, j, k, 2) = dssd(i, j, k, 2) + y2d
        end if
        radjd(i, j, k) = radjd(i, j, k) + ppor*rradd
        radjd(i, j+1, k) = radjd(i, j+1, k) + ppor*rradd
      end do
      call popreal8(ppor)
      call popreal8(ddw5)
      call popreal8(ddw4)
      call popreal8(ddw3)
      call popreal8(ddw2)
      call popreal8(dis4)
      call popinteger4(j)
      call popinteger4(i)
      radid = 0.0_8
      do ii=0,il*ny*nz-1
        i = mod(ii, il) + 1
        j = mod(ii/il, ny) + 2
        k = ii/(il*ny) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pori(i, j, k) .eq. normalflux) ppor = half
        rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
        if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
          y1 = dss(i+1, j, k, 1)
          call pushcontrol1b(0)
        else
          y1 = dss(i, j, k, 1)
          call pushcontrol1b(1)
        end if
        if (dssmax .gt. y1) then
          min1 = y1
          call pushcontrol1b(0)
        else
          min1 = dssmax
          call pushcontrol1b(1)
        end if
        dis2 = fis2*rrad*min1
        arg1 = fis4*rrad
        dis4 = mydim(arg1, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
        ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
! x-momentum.
        ddw2 = w(i+1, j, k, ivx)*w(i+1, j, k, irho) - w(i, j, k, ivx)*w(&
&         i, j, k, irho)
! y-momentum.
        ddw3 = w(i+1, j, k, ivy)*w(i+1, j, k, irho) - w(i, j, k, ivy)*w(&
&         i, j, k, irho)
! z-momentum.
        ddw4 = w(i+1, j, k, ivz)*w(i+1, j, k, irho) - w(i, j, k, ivz)*w(&
&         i, j, k, irho)
! energy.
        ddw5 = w(i+1, j, k, irhoe) + p(i+1, j, k) - (w(i, j, k, irhoe)+p&
&         (i, j, k))
        fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
        tempd6 = -(dis4*fsd)
        dis2d = ddw5*fsd
        ddw5d = dis2*fsd - three*tempd6
        dis4d = -((w(i+2, j, k, irhoe)+p(i+2, j, k)-w(i-1, j, k, irhoe)-&
&         p(i-1, j, k)-three*ddw5)*fsd)
        wd(i+2, j, k, irhoe) = wd(i+2, j, k, irhoe) + tempd6
        pd(i+2, j, k) = pd(i+2, j, k) + tempd6
        wd(i-1, j, k, irhoe) = wd(i-1, j, k, irhoe) - tempd6
        pd(i-1, j, k) = pd(i-1, j, k) - tempd6
        wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddw5d
        pd(i+1, j, k) = pd(i+1, j, k) + ddw5d
        wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
        pd(i, j, k) = pd(i, j, k) - ddw5d
        fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
        temp17 = w(i-1, j, k, irho)
        temp16 = w(i-1, j, k, ivz)
        temp15 = w(i+2, j, k, irho)
        temp14 = w(i+2, j, k, ivz)
        tempd7 = -(dis4*fsd)
        dis2d = dis2d + ddw4*fsd
        ddw4d = dis2*fsd - three*tempd7
        dis4d = dis4d - (temp14*temp15-temp16*temp17-three*ddw4)*fsd
        wd(i+2, j, k, ivz) = wd(i+2, j, k, ivz) + temp15*tempd7
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp14*tempd7
        wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - temp17*tempd7
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp16*tempd7
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)*&
&         ddw4d
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
&         ddw4d
        wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
        fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
        temp13 = w(i-1, j, k, irho)
        temp12 = w(i-1, j, k, ivy)
        temp11 = w(i+2, j, k, irho)
        temp10 = w(i+2, j, k, ivy)
        tempd8 = -(dis4*fsd)
        dis2d = dis2d + ddw3*fsd
        ddw3d = dis2*fsd - three*tempd8
        dis4d = dis4d - (temp10*temp11-temp12*temp13-three*ddw3)*fsd
        wd(i+2, j, k, ivy) = wd(i+2, j, k, ivy) + temp11*tempd8
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp10*tempd8
        wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - temp13*tempd8
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp12*tempd8
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)*&
&         ddw3d
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
&         ddw3d
        wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
        fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
        temp9 = w(i-1, j, k, irho)
        temp8 = w(i-1, j, k, ivx)
        temp7 = w(i+2, j, k, irho)
        temp6 = w(i+2, j, k, ivx)
        tempd9 = -(dis4*fsd)
        dis2d = dis2d + ddw2*fsd
        ddw2d = dis2*fsd - three*tempd9
        dis4d = dis4d - (temp6*temp7-temp8*temp9-three*ddw2)*fsd
        wd(i+2, j, k, ivx) = wd(i+2, j, k, ivx) + temp7*tempd9
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp6*tempd9
        wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - temp9*tempd9
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp8*tempd9
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)*&
&         ddw2d
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
&         ddw2d
        wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
        wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
        fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
        tempd10 = -(dis4*fsd)
        dis2d = dis2d + ddw1*fsd
        ddw1d = dis2*fsd - three*tempd10
        dis4d = dis4d - (w(i+2, j, k, irho)-w(i-1, j, k, irho)-three*&
&         ddw1)*fsd
        wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + tempd10
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - tempd10
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddw1d
        wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
        arg1d = 0.0_8
        call mydim_b(arg1, arg1d, dis2, dis2d, dis4d)
        rradd = fis2*min1*dis2d + fis4*arg1d
        min1d = fis2*rrad*dis2d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          y1d = min1d
        else
          y1d = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          dssd(i+1, j, k, 1) = dssd(i+1, j, k, 1) + y1d
        else
          dssd(i, j, k, 1) = dssd(i, j, k, 1) + y1d
        end if
        radid(i, j, k) = radid(i, j, k) + ppor*rradd
        radid(i+1, j, k) = radid(i+1, j, k) + ppor*rradd
      end do
      call popinteger4(j)
      call popinteger4(i)
      fwd = sfil*fwd
      sslimd = 0.0_8
      ssd = 0.0_8
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
        x1 = (ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))/(ss(i+1, j, k&
&         )+two*ss(i, j, k)+ss(i-1, j, k)+sslim)
        if (x1 .ge. 0.) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        x2 = (ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))/(ss(i, j+1, k&
&         )+two*ss(i, j, k)+ss(i, j-1, k)+sslim)
        if (x2 .ge. 0.) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        x3 = (ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))/(ss(i, j, k+1&
&         )+two*ss(i, j, k)+ss(i, j, k-1)+sslim)
        if (x3 .ge. 0.) then
          x3d = dssd(i, j, k, 3)
          dssd(i, j, k, 3) = 0.0_8
        else
          x3d = -dssd(i, j, k, 3)
          dssd(i, j, k, 3) = 0.0_8
        end if
        temp5 = ss(i, j, k+1) + two*ss(i, j, k) + ss(i, j, k-1) + sslim
        tempd4 = x3d/temp5
        tempd5 = -((ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))*tempd4/&
&         temp5)
        ssd(i, j, k+1) = ssd(i, j, k+1) + tempd5 + tempd4
        ssd(i, j, k) = ssd(i, j, k) + two*tempd5 - two*tempd4
        ssd(i, j, k-1) = ssd(i, j, k-1) + tempd5 + tempd4
        sslimd = sslimd + tempd5
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x2d = dssd(i, j, k, 2)
          dssd(i, j, k, 2) = 0.0_8
        else
          x2d = -dssd(i, j, k, 2)
          dssd(i, j, k, 2) = 0.0_8
        end if
        temp4 = ss(i, j+1, k) + two*ss(i, j, k) + ss(i, j-1, k) + sslim
        tempd2 = x2d/temp4
        tempd3 = -((ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))*tempd2/&
&         temp4)
        ssd(i, j+1, k) = ssd(i, j+1, k) + tempd3 + tempd2
        ssd(i, j, k) = ssd(i, j, k) + two*tempd3 - two*tempd2
        ssd(i, j-1, k) = ssd(i, j-1, k) + tempd3 + tempd2
        sslimd = sslimd + tempd3
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x1d = dssd(i, j, k, 1)
          dssd(i, j, k, 1) = 0.0_8
        else
          x1d = -dssd(i, j, k, 1)
          dssd(i, j, k, 1) = 0.0_8
        end if
        temp3 = ss(i+1, j, k) + two*ss(i, j, k) + ss(i-1, j, k) + sslim
        tempd0 = x1d/temp3
        tempd1 = -((ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))*tempd0/&
&         temp3)
        ssd(i+1, j, k) = ssd(i+1, j, k) + tempd1 + tempd0
        ssd(i, j, k) = ssd(i, j, k) + two*tempd1 - two*tempd0
        ssd(i-1, j, k) = ssd(i-1, j, k) + tempd1 + tempd0
        sslimd = sslimd + tempd1
      end do
      call popinteger4(j)
      call popinteger4(i)
      call popcontrol2b(branch)
      if (branch .eq. 0) then
        do ii=0,(ib+1)*(jb+1)*(kb+1)-1
          i = mod(ii, ib + 1)
          j = mod(ii/(ib+1), jb + 1)
          k = ii/((ib+1)*(jb+1))
          temp2 = gamma(i, j, k)
          temp1 = w(i, j, k, irho)
          temp0 = temp1**temp2
          pd(i, j, k) = pd(i, j, k) + ssd(i, j, k)/temp0
          if (.not.(temp1 .le. 0.0_8 .and. (temp2 .eq. 0.0_8 .or. temp2 &
&             .ne. int(temp2)))) wd(i, j, k, irho) = wd(i, j, k, irho) -&
&             p(i, j, k)*temp2*temp1**(temp2-1)*ssd(i, j, k)/temp0**2
          ssd(i, j, k) = 0.0_8
        end do
        temp = rhoinf**gammainf
        tempd = 0.001_realtype*sslimd/temp
        pinfcorrd = pinfcorrd + tempd
        if (.not.(rhoinf .le. 0.0_8 .and. (gammainf .eq. 0.0_8 .or. &
&           gammainf .ne. int(gammainf)))) rhoinfd = rhoinfd - pinfcorr*&
&           gammainf*rhoinf**(gammainf-1)*tempd/temp
      else if (branch .eq. 1) then
        pd = pd + ssd
        pinfcorrd = pinfcorrd + 0.001_realtype*sslimd
      end if
    end if
  end subroutine invisciddissfluxscalar_b
  subroutine invisciddissfluxscalar()
!
!       invisciddissfluxscalar computes the scalar artificial
!       dissipation, see aiaa paper 81-1259, for a given block.
!       therefore it is assumed that the pointers in  blockpointers
!       already point to the correct block.
!
    use constants
    use blockpointers, only : nx, ny, nz, il, jl, kl, ie, je, ke, ib, &
&   jb, kb, w, p, pori, porj, pork, fw, radi, radj, radk, gamma
    use flowvarrefstate, only : gammainf, pinfcorr, rhoinf
    use inputdiscretization, only : vis2, vis4
    use inputphysics, only : equations
    use iteration, only : rfil
    use utils_b, only : mydim
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind, ii
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2, dis4
    real(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, fs
    real(kind=realtype), dimension(ie, je, ke, 3) :: dss
    real(kind=realtype), dimension(0:ib, 0:jb, 0:kb) :: ss
    intrinsic abs
    intrinsic mod
    intrinsic max
    intrinsic min
    real(kind=realtype) :: arg1
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations)
      case (eulerequations)
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr
! copy the pressure in ss. only need the entries used in the
! discretization, i.e. not including the corner halo's, but we'll
! just copy all anyway.
        ss = p
      case (nsequations, ransequations)
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr/rhoinf**gammainf
! store the entropy in ss. see above.
        do ii=0,(ib+1)*(jb+1)*(kb+1)-1
          i = mod(ii, ib + 1)
          j = mod(ii/(ib+1), jb + 1)
          k = ii/((ib+1)*(jb+1))
          ss(i, j, k) = p(i, j, k)/w(i, j, k, irho)**gamma(i, j, k)
        end do
      end select
! compute the pressure sensor for each cell, in each direction:
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
        x1 = (ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))/(ss(i+1, j, k&
&         )+two*ss(i, j, k)+ss(i-1, j, k)+sslim)
        if (x1 .ge. 0.) then
          dss(i, j, k, 1) = x1
        else
          dss(i, j, k, 1) = -x1
        end if
        x2 = (ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))/(ss(i, j+1, k&
&         )+two*ss(i, j, k)+ss(i, j-1, k)+sslim)
        if (x2 .ge. 0.) then
          dss(i, j, k, 2) = x2
        else
          dss(i, j, k, 2) = -x2
        end if
        x3 = (ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))/(ss(i, j, k+1&
&         )+two*ss(i, j, k)+ss(i, j, k-1)+sslim)
        if (x3 .ge. 0.) then
          dss(i, j, k, 3) = x3
        else
          dss(i, j, k, 3) = -x3
        end if
      end do
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      fw = sfil*fw
!
!       dissipative fluxes in the i-direction.
!
      do ii=0,il*ny*nz-1
        i = mod(ii, il) + 1
        j = mod(ii/il, ny) + 2
        k = ii/(il*ny) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pori(i, j, k) .eq. normalflux) ppor = half
        rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
        if (dss(i, j, k, 1) .lt. dss(i+1, j, k, 1)) then
          y1 = dss(i+1, j, k, 1)
        else
          y1 = dss(i, j, k, 1)
        end if
        if (dssmax .gt. y1) then
          min1 = y1
        else
          min1 = dssmax
        end if
        dis2 = fis2*rrad*min1
        arg1 = fis4*rrad
        dis4 = mydim(arg1, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
        ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
        fs = dis2*ddw1 - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-&
&         three*ddw1)
        fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        ddw2 = w(i+1, j, k, ivx)*w(i+1, j, k, irho) - w(i, j, k, ivx)*w(&
&         i, j, k, irho)
        fs = dis2*ddw2 - dis4*(w(i+2, j, k, ivx)*w(i+2, j, k, irho)-w(i-&
&         1, j, k, ivx)*w(i-1, j, k, irho)-three*ddw2)
        fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        ddw3 = w(i+1, j, k, ivy)*w(i+1, j, k, irho) - w(i, j, k, ivy)*w(&
&         i, j, k, irho)
        fs = dis2*ddw3 - dis4*(w(i+2, j, k, ivy)*w(i+2, j, k, irho)-w(i-&
&         1, j, k, ivy)*w(i-1, j, k, irho)-three*ddw3)
        fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        ddw4 = w(i+1, j, k, ivz)*w(i+1, j, k, irho) - w(i, j, k, ivz)*w(&
&         i, j, k, irho)
        fs = dis2*ddw4 - dis4*(w(i+2, j, k, ivz)*w(i+2, j, k, irho)-w(i-&
&         1, j, k, ivz)*w(i-1, j, k, irho)-three*ddw4)
        fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        ddw5 = w(i+1, j, k, irhoe) + p(i+1, j, k) - (w(i, j, k, irhoe)+p&
&         (i, j, k))
        fs = dis2*ddw5 - dis4*(w(i+2, j, k, irhoe)+p(i+2, j, k)-(w(i-1, &
&         j, k, irhoe)+p(i-1, j, k))-three*ddw5)
        fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
!
!       dissipative fluxes in the j-direction.
!
      do ii=0,nx*jl*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, jl) + 1
        k = ii/(nx*jl) + 2
! compute the dissipation coefficients for this face.
        ppor = zero
        if (porj(i, j, k) .eq. normalflux) ppor = half
        rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
        if (dss(i, j, k, 2) .lt. dss(i, j+1, k, 2)) then
          y2 = dss(i, j+1, k, 2)
        else
          y2 = dss(i, j, k, 2)
        end if
        if (dssmax .gt. y2) then
          min2 = y2
        else
          min2 = dssmax
        end if
        dis2 = fis2*rrad*min2
        arg1 = fis4*rrad
        dis4 = mydim(arg1, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
        ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
        fs = dis2*ddw1 - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-&
&         three*ddw1)
        fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        ddw2 = w(i, j+1, k, ivx)*w(i, j+1, k, irho) - w(i, j, k, ivx)*w(&
&         i, j, k, irho)
        fs = dis2*ddw2 - dis4*(w(i, j+2, k, ivx)*w(i, j+2, k, irho)-w(i&
&         , j-1, k, ivx)*w(i, j-1, k, irho)-three*ddw2)
        fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        ddw3 = w(i, j+1, k, ivy)*w(i, j+1, k, irho) - w(i, j, k, ivy)*w(&
&         i, j, k, irho)
        fs = dis2*ddw3 - dis4*(w(i, j+2, k, ivy)*w(i, j+2, k, irho)-w(i&
&         , j-1, k, ivy)*w(i, j-1, k, irho)-three*ddw3)
        fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        ddw4 = w(i, j+1, k, ivz)*w(i, j+1, k, irho) - w(i, j, k, ivz)*w(&
&         i, j, k, irho)
        fs = dis2*ddw4 - dis4*(w(i, j+2, k, ivz)*w(i, j+2, k, irho)-w(i&
&         , j-1, k, ivz)*w(i, j-1, k, irho)-three*ddw4)
        fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        ddw5 = w(i, j+1, k, irhoe) + p(i, j+1, k) - (w(i, j, k, irhoe)+p&
&         (i, j, k))
        fs = dis2*ddw5 - dis4*(w(i, j+2, k, irhoe)+p(i, j+2, k)-(w(i, j-&
&         1, k, irhoe)+p(i, j-1, k))-three*ddw5)
        fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
!
!       dissipative fluxes in the k-direction.
!
      do ii=0,nx*ny*kl-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 1
! compute the dissipation coefficients for this face.
        ppor = zero
        if (pork(i, j, k) .eq. normalflux) ppor = half
        rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
        if (dss(i, j, k, 3) .lt. dss(i, j, k+1, 3)) then
          y3 = dss(i, j, k+1, 3)
        else
          y3 = dss(i, j, k, 3)
        end if
        if (dssmax .gt. y3) then
          min3 = y3
        else
          min3 = dssmax
        end if
        dis2 = fis2*rrad*min3
        arg1 = fis4*rrad
        dis4 = mydim(arg1, dis2)
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
        ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
        fs = dis2*ddw1 - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)-&
&         three*ddw1)
        fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
        fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
        ddw2 = w(i, j, k+1, ivx)*w(i, j, k+1, irho) - w(i, j, k, ivx)*w(&
&         i, j, k, irho)
        fs = dis2*ddw2 - dis4*(w(i, j, k+2, ivx)*w(i, j, k+2, irho)-w(i&
&         , j, k-1, ivx)*w(i, j, k-1, irho)-three*ddw2)
        fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
        fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
        ddw3 = w(i, j, k+1, ivy)*w(i, j, k+1, irho) - w(i, j, k, ivy)*w(&
&         i, j, k, irho)
        fs = dis2*ddw3 - dis4*(w(i, j, k+2, ivy)*w(i, j, k+2, irho)-w(i&
&         , j, k-1, ivy)*w(i, j, k-1, irho)-three*ddw3)
        fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
        fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
        ddw4 = w(i, j, k+1, ivz)*w(i, j, k+1, irho) - w(i, j, k, ivz)*w(&
&         i, j, k, irho)
        fs = dis2*ddw4 - dis4*(w(i, j, k+2, ivz)*w(i, j, k+2, irho)-w(i&
&         , j, k-1, ivz)*w(i, j, k-1, irho)-three*ddw4)
        fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
        fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
        ddw5 = w(i, j, k+1, irhoe) + p(i, j, k+1) - (w(i, j, k, irhoe)+p&
&         (i, j, k))
        fs = dis2*ddw5 - dis4*(w(i, j, k+2, irhoe)+p(i, j, k+2)-(w(i, j&
&         , k-1, irhoe)+p(i, j, k-1))-three*ddw5)
        fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
      end do
    end if
  end subroutine invisciddissfluxscalar
  subroutine inviscidupwindflux(finegrid)
!
!       inviscidupwindflux computes the artificial dissipation part of
!       the euler fluxes by means of an approximate solution of the 1d
!       riemann problem on the face. for first order schemes,
!       finegrid == .false., the states in the cells are assumed to
!       be constant; for the second order schemes on the fine grid a
!       nonlinear reconstruction of the left and right state is done
!       for which several options exist.
!       it is assumed that the pointers in blockpointers already
!       point to the correct block.
!
    use constants
    use blockpointers, only : il, jl, kl, ie, je, ke, ib, jb, kb, w, p&
&   , pori, porj, pork, fw, gamma, si, sj, sk, indfamilyi, indfamilyj, &
&   indfamilyk, spectralsol, addgridvelocities, sfacei, sfacej, sfacek, &
&   rotmatrixi, rotmatrixj, rotmatrixk, factfamilyi, factfamilyj, &
&   factfamilyk
    use flowvarrefstate, only : kpresent, nw, nwf, rgas, tref
    use inputdiscretization, only : limiter, lumpeddiss, precond, &
&   riemann, riemanncoarse, orderturb, kappacoef
    use inputphysics, only : equations
    use iteration, only : rfil, currentlevel, groundlevel
    use cgnsgrid, only : massflowfamilydiss
    use utils_b, only : getcorrectfork, terminate
    use flowutils_b, only : etot
    implicit none
!
!      subroutine arguments.
!
    logical, intent(in) :: finegrid
!
!      local variables.
!
    integer(kind=portype) :: por
    integer(kind=inttype) :: nwint
    integer(kind=inttype) :: i, j, k, ind
    integer(kind=inttype) :: limused, riemannused
    real(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
    real(kind=realtype) :: factminmod, sface
    real(kind=realtype), dimension(nw) :: left, right
    real(kind=realtype), dimension(nw) :: du1, du2, du3
    real(kind=realtype), dimension(nwf) :: flux
    logical :: firstorderk, correctfork, rotationalperiodic
    intrinsic abs
    intrinsic associated
    intrinsic max
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! check if the formulation for rotational periodic problems
! must be used.
      if (associated(rotmatrixi)) then
        rotationalperiodic = .true.
      else
        rotationalperiodic = .false.
      end if
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      sfil = one - rfil
      do k=2,kl
        do j=2,jl
          do i=2,il
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
      if (1.e-10_realtype .lt. one - kappacoef) then
        max1 = one - kappacoef
      else
        max1 = 1.e-10_realtype
      end if
! compute the factor used in the minmod limiter.
      factminmod = (three-kappacoef)/max1
! determine the limiter scheme to be used. on the fine grid the
! user specified scheme is used; on the coarse grid a first order
! scheme is computed.
      limused = firstorder
      if (finegrid) limused = limiter
! lumped diss is true for doing approx pc
      if (lumpeddiss) limused = firstorder
! determine the riemann solver which must be used.
      riemannused = riemanncoarse
      if (finegrid) riemannused = riemann
! store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
      omk = fourth*(one-kappacoef)
      opk = fourth*(one+kappacoef)
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set the number of variables to be interpolated depending
! whether or not a k-equation is present. if a k-equation is
! present also set the logical firstorderk. this indicates
! whether or not only a first order approximation is to be used
! for the turbulent kinetic energy.
      if (correctfork) then
        if (orderturb .eq. firstorder) then
          nwint = nwf
          firstorderk = .true.
        else
          nwint = itu1
          firstorderk = .false.
        end if
      else
        nwint = nwf
        firstorderk = .false.
      end if
!
!       flux computation. a distinction is made between first and
!       second order schemes to avoid the overhead for the first order
!       scheme.
!
      if (limused .eq. firstorder) then
!
!         first order reconstruction. the states in the cells are
!         constant. the left and right states are constructed easily.
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = si(i, j, k, 1)
              sy = si(i, j, k, 2)
              sz = si(i, j, k, 3)
              por = pori(i, j, k)
              if (addgridvelocities) sface = sfacei(i, j, k)
! determine the left and right state.
              left(irho) = w(i, j, k, irho)
              left(ivx) = w(i, j, k, ivx)
              left(ivy) = w(i, j, k, ivy)
              left(ivz) = w(i, j, k, ivz)
              left(irhoe) = p(i, j, k)
              if (correctfork) left(itu1) = w(i, j, k, itu1)
              right(irho) = w(i+1, j, k, irho)
              right(ivx) = w(i+1, j, k, ivx)
              right(ivy) = w(i+1, j, k, ivy)
              right(ivz) = w(i+1, j, k, ivz)
              right(irhoe) = p(i+1, j, k)
              if (correctfork) right(itu1) = w(i+1, j, k, itu1)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
              fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
              fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
              fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
              fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sj(i, j, k, 1)
              sy = sj(i, j, k, 2)
              sz = sj(i, j, k, 3)
              por = porj(i, j, k)
              if (addgridvelocities) sface = sfacej(i, j, k)
! determine the left and right state.
              left(irho) = w(i, j, k, irho)
              left(ivx) = w(i, j, k, ivx)
              left(ivy) = w(i, j, k, ivy)
              left(ivz) = w(i, j, k, ivz)
              left(irhoe) = p(i, j, k)
              if (correctfork) left(itu1) = w(i, j, k, itu1)
              right(irho) = w(i, j+1, k, irho)
              right(ivx) = w(i, j+1, k, ivx)
              right(ivy) = w(i, j+1, k, ivy)
              right(ivz) = w(i, j+1, k, ivz)
              right(irhoe) = p(i, j+1, k)
              if (correctfork) right(itu1) = w(i, j+1, k, itu1)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
              fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
              fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
              fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
              fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sk(i, j, k, 1)
              sy = sk(i, j, k, 2)
              sz = sk(i, j, k, 3)
              por = pork(i, j, k)
              if (addgridvelocities) sface = sfacek(i, j, k)
! determine the left and right state.
              left(irho) = w(i, j, k, irho)
              left(ivx) = w(i, j, k, ivx)
              left(ivy) = w(i, j, k, ivy)
              left(ivz) = w(i, j, k, ivz)
              left(irhoe) = p(i, j, k)
              if (correctfork) left(itu1) = w(i, j, k, itu1)
              right(irho) = w(i, j, k+1, irho)
              right(ivx) = w(i, j, k+1, ivx)
              right(ivy) = w(i, j, k+1, ivy)
              right(ivz) = w(i, j, k+1, ivz)
              right(irhoe) = p(i, j, k+1)
              if (correctfork) right(itu1) = w(i, j, k+1, itu1)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
              fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
              fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
              fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
              fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
            end do
          end do
        end do
      else
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
!      ==================================================================
!
!         second order reconstruction of the left and right state.
!         the three differences used in the, possibly nonlinear,
!         interpolation are constructed here; the actual left and
!         right states, or at least the differences from the first
!         order interpolation, are computed in the subroutine
!         leftrightstate.
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
              du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
              du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
              du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
              du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
              du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
              du1(irhoe) = p(i, j, k) - p(i-1, j, k)
              du2(irhoe) = p(i+1, j, k) - p(i, j, k)
              du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
                du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate(du1, du2, du3, rotmatrixi, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i+1, j, k, irho)
              right(ivx) = right(ivx) + w(i+1, j, k, ivx)
              right(ivy) = right(ivy) + w(i+1, j, k, ivy)
              right(ivz) = right(ivz) + w(i+1, j, k, ivz)
              right(irhoe) = right(irhoe) + p(i+1, j, k)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i+1, j, k, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = si(i, j, k, 1)
              sy = si(i, j, k, 2)
              sz = si(i, j, k, 3)
              por = pori(i, j, k)
              if (addgridvelocities) sface = sfacei(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
              fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
              fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
              fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
              fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
              du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
              du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
              du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
              du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
              du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
              du1(irhoe) = p(i, j, k) - p(i, j-1, k)
              du2(irhoe) = p(i, j+1, k) - p(i, j, k)
              du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
                du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate(du1, du2, du3, rotmatrixj, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i, j+1, k, irho)
              right(ivx) = right(ivx) + w(i, j+1, k, ivx)
              right(ivy) = right(ivy) + w(i, j+1, k, ivy)
              right(ivz) = right(ivz) + w(i, j+1, k, ivz)
              right(irhoe) = right(irhoe) + p(i, j+1, k)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i, j+1, k, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sj(i, j, k, 1)
              sy = sj(i, j, k, 2)
              sz = sj(i, j, k, 3)
              por = porj(i, j, k)
              if (addgridvelocities) sface = sfacej(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
              fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
              fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
              fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
              fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
              du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
              du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
              du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
              du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
              du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
              du1(irhoe) = p(i, j, k) - p(i, j, k-1)
              du2(irhoe) = p(i, j, k+1) - p(i, j, k)
              du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
                du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
              end if
! compute the differences from the first order scheme.
              call leftrightstate(du1, du2, du3, rotmatrixk, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i, j, k+1, irho)
              right(ivx) = right(ivx) + w(i, j, k+1, ivx)
              right(ivy) = right(ivy) + w(i, j, k+1, ivy)
              right(ivz) = right(ivz) + w(i, j, k+1, ivz)
              right(irhoe) = right(irhoe) + p(i, j, k+1)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i, j, k+1, itu1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              sx = sk(i, j, k, 1)
              sy = sk(i, j, k, 2)
              sz = sk(i, j, k, 3)
              por = pork(i, j, k)
              if (addgridvelocities) sface = sfacek(i, j, k)
! compute the value of gamma on the face. take an
! arithmetic average of the two states.
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
! compute the dissipative flux across the interface.
              call riemannflux(left, right, flux)
! and scatter it to the left and right.
              fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
              fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
              fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
              fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
              fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
              fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
              fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
              fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
              fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
              fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
            end do
          end do
        end do
      end if
    end if

  contains
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
    subroutine leftrightstate(du1, du2, du3, rotmatrix, left, right)
      implicit none
!
!        local parameter.
!
      real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
      real(kind=realtype), dimension(:), intent(out) :: left, right
      real(kind=realtype), dimension(:, :, :, :, :), pointer :: &
&     rotmatrix
!
!        local variables.
!
      integer(kind=inttype) :: l
      real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
      real(kind=realtype), dimension(3, 3) :: rot
      intrinsic abs
      intrinsic max
      intrinsic sign
      intrinsic min
      real(kind=realtype) :: x6
      real(kind=realtype) :: x5
      real(kind=realtype) :: x4
      real(kind=realtype) :: x3
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: max7
      real(kind=realtype) :: max6
      real(kind=realtype) :: max5
      real(kind=realtype) :: max4
      real(kind=realtype) :: max3
      real(kind=realtype) :: max2
      real(kind=realtype) :: y4
      real(kind=realtype) :: y3
      real(kind=realtype) :: y2
      real(kind=realtype) :: y1
! check if the velocity components should be transformed to
! the cylindrical frame.
      if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
        rot(1, 1) = rotmatrix(i, j, k, 1, 1)
        rot(1, 2) = rotmatrix(i, j, k, 1, 2)
        rot(1, 3) = rotmatrix(i, j, k, 1, 3)
        rot(2, 1) = rotmatrix(i, j, k, 2, 1)
        rot(2, 2) = rotmatrix(i, j, k, 2, 2)
        rot(2, 3) = rotmatrix(i, j, k, 2, 3)
        rot(3, 1) = rotmatrix(i, j, k, 3, 1)
        rot(3, 2) = rotmatrix(i, j, k, 3, 2)
        rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
        dvx = du1(ivx)
        dvy = du1(ivy)
        dvz = du1(ivz)
        du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du2(ivx)
        dvy = du2(ivy)
        dvz = du2(ivz)
        du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du3(ivx)
        dvy = du3(ivy)
        dvz = du3(ivz)
        du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      end if
! determine the limiter used.
      select case  (limused)
      case (nolimiter)
! linear interpolation; no limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          left(l) = omk*du1(l) + opk*du2(l)
          right(l) = -(omk*du3(l)) - opk*du2(l)
        end do
      case (vanalbeda)
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x1 = du2(l)
          else
            x1 = -du2(l)
          end if
          if (x1 .lt. epslim) then
            max2 = epslim
          else
            max2 = x1
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max2, du2(l))
          if (du1(l) .ge. 0.) then
            x3 = du1(l)
          else
            x3 = -du1(l)
          end if
          if (x3 .lt. epslim) then
            max4 = epslim
          else
            max4 = x3
          end if
          y1 = du2(l)/sign(max4, du1(l))
          if (zero .lt. y1) then
            rl1 = y1
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x4 = du3(l)
          else
            x4 = -du3(l)
          end if
          if (x4 .lt. epslim) then
            max5 = epslim
          else
            max5 = x4
          end if
          y2 = du2(l)/sign(max5, du3(l))
          if (zero .lt. y2) then
            rr2 = y2
          else
            rr2 = zero
          end if
! compute the corresponding limiter values.
          rl1 = rl1*(rl1+one)/(rl1*rl1+one)
          rl2 = rl2*(rl2+one)/(rl2*rl2+one)
          rr1 = rr1*(rr1+one)/(rr1*rr1+one)
          rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      case (minmod)
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x2 = du2(l)
          else
            x2 = -du2(l)
          end if
          if (x2 .lt. epslim) then
            max3 = epslim
          else
            max3 = x2
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max3, du2(l))
          if (du1(l) .ge. 0.) then
            x5 = du1(l)
          else
            x5 = -du1(l)
          end if
          if (x5 .lt. epslim) then
            max6 = epslim
          else
            max6 = x5
          end if
          y3 = du2(l)/sign(max6, du1(l))
          if (zero .lt. y3) then
            rl1 = y3
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x6 = du3(l)
          else
            x6 = -du3(l)
          end if
          if (x6 .lt. epslim) then
            max7 = epslim
          else
            max7 = x6
          end if
          y4 = du2(l)/sign(max7, du3(l))
          if (zero .lt. y4) then
            rr2 = y4
          else
            rr2 = zero
          end if
          if (one .gt. factminmod*rl1) then
            rl1 = factminmod*rl1
          else
            rl1 = one
          end if
          if (one .gt. factminmod*rl2) then
            rl2 = factminmod*rl2
          else
            rl2 = one
          end if
          if (one .gt. factminmod*rr1) then
            rr1 = factminmod*rr1
          else
            rr1 = one
          end if
          if (one .gt. factminmod*rr2) then
            rr2 = factminmod*rr2
          else
            rr2 = one
          end if
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
      if (firstorderk) then
        left(itu1) = zero
        right(itu1) = zero
      end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
      if (rotationalperiodic) then
! left state.
        dvx = left(ivx)
        dvy = left(ivy)
        dvz = left(ivz)
        left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
! right state.
        dvx = right(ivx)
        dvy = right(ivy)
        dvz = right(ivz)
        right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
      end if
    end subroutine leftrightstate
!        ================================================================
    subroutine riemannflux(left, right, flux)
      implicit none
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(*), intent(in) :: left, right
      real(kind=realtype), dimension(*), intent(out) :: flux
!
!        local variables.
!
      real(kind=realtype) :: porflux, rface
      real(kind=realtype) :: etl, etr, z1l, z1r, tmp
      real(kind=realtype) :: dr, dru, drv, drw, dre, drk
      real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
      real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
      real(kind=realtype) :: ovaavg, ova2avg, area, eta
      real(kind=realtype) :: gm1, gm53
      real(kind=realtype) :: lam1, lam2, lam3
      real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
      real(kind=realtype), dimension(2) :: ktmp
      intrinsic sqrt
      intrinsic max
      intrinsic abs
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: abs2
      real(kind=realtype) :: abs1
      real(kind=realtype) :: max2
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
      porflux = half*rfil
      if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
      gm1 = gammaface - one
      gm53 = gammaface - five*third
! determine which riemann solver must be solved.
      select case  (riemannused)
      case (roe)
! determine the preconditioner used.
        select case  (precond)
        case (noprecond)
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
          z1l = sqrt(left(irho))
          z1r = sqrt(right(irho))
          tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
          if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
            ktmp(1) = left(itu1)
            ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
            drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
            kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
          else
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
            drk = 0.0
            kavg = 0.0
          end if
! compute the total energy of the left and right state.
          call etot(left(irho), left(ivx), left(ivy), left(ivz), left(&
&             irhoe), ktmp(1), etl, correctfork)
          call etot(right(irho), right(ivx), right(ivy), right(ivz), &
&             right(irhoe), ktmp(2), etr, correctfork)
! compute the difference of the conservative mean
! flow variables.
          dr = right(irho) - left(irho)
          dru = right(irho)*right(ivx) - left(irho)*left(ivx)
          drv = right(irho)*right(ivy) - left(irho)*left(ivy)
          drw = right(irho)*right(ivz) - left(irho)*left(ivz)
          dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
          ravg = fourth*(z1r+z1l)**2
          uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
          vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
          wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
          havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            max2 = area
          else
            max2 = 1.e-25_realtype
          end if
          tmp = one/max2
          sx = sx*tmp
          sy = sy*tmp
          sz = sz*tmp
          rface = sface*tmp
! compute some dependent variables at the roe
! average state.
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
            a2avg = gm1*(havg-alphaavg) - gm53*kavg
          else
            a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
          end if
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
          if (por .eq. boundflux) unavg = rface
          x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&           left(ivz)-right(ivz))*sz
          if (x1 .ge. 0.) then
            abs1 = x1
          else
            abs1 = -x1
          end if
          x2 = sqrt(gammaface*left(irhoe)/left(irho)) - sqrt(gammaface*&
&           right(irhoe)/right(irho))
          if (x2 .ge. 0.) then
            abs2 = x2
          else
            abs2 = -x2
          end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
          eta = half*(abs1+abs2)
          if (unavg - rface + aavg .ge. 0.) then
            lam1 = unavg - rface + aavg
          else
            lam1 = -(unavg-rface+aavg)
          end if
          if (unavg - rface - aavg .ge. 0.) then
            lam2 = unavg - rface - aavg
          else
            lam2 = -(unavg-rface-aavg)
          end if
          if (unavg - rface .ge. 0.) then
            lam3 = unavg - rface
          else
            lam3 = -(unavg-rface)
          end if
! apply the entropy correction to the eigenvalues.
          tmp = two*eta
          if (lam1 .lt. tmp) lam1 = eta + fourth*lam1*lam1/eta
          if (lam2 .lt. tmp) lam2 = eta + fourth*lam2*lam2/eta
          if (lam3 .lt. tmp) lam3 = eta + fourth*lam3*lam3/eta
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1 = lam1*area
          lam2 = lam2*area
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
          flux(irho) = -(porflux*(lam3*dr+abv6))
          flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
          flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
          flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
          flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
        case (turkel)
!          tmp = max(lam1,lam2,lam3)
!          flux(irho)  = -porflux*(tmp*dr)
!          flux(imx)   = -porflux*(tmp*dru)
!          flux(imy)   = -porflux*(tmp*drv)
!          flux(imz)   = -porflux*(tmp*drw)
!          flux(irhoe) = -porflux*(tmp*dre)
          call terminate('riemannflux', &
&                  'turkel preconditioner not implemented yet')
        case (choimerkle)
          call terminate('riemannflux', &
&                  'choi merkle preconditioner not implemented yet')
        end select
      case (vanleer)
        call terminate('riemannflux', 'van leer fvs not implemented yet'&
&               )
      case (ausmdv)
        call terminate('riemannflux', 'ausmdv fvs not implemented yet')
      end select
    end subroutine riemannflux
  end subroutine inviscidupwindflux
!  differentiation of inviscidupwindflux in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *p *w *si *sj *sk *fw
!   with respect to varying inputs: *p *w *si *sj *sk *fw
!   rw status of diff variables: *p:incr *w:incr *si:incr *sj:incr
!                *sk:incr *fw:in-out
!   plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
  subroutine inviscidupwindflux_b(finegrid)
!
!       inviscidupwindflux computes the artificial dissipation part of
!       the euler fluxes by means of an approximate solution of the 1d
!       riemann problem on the face. for first order schemes,
!       finegrid == .false., the states in the cells are assumed to
!       be constant; for the second order schemes on the fine grid a
!       nonlinear reconstruction of the left and right state is done
!       for which several options exist.
!       it is assumed that the pointers in blockpointers already
!       point to the correct block.
!
    use constants
    use blockpointers, only : il, jl, kl, ie, je, ke, ib, jb, kb, w, &
&   wd, p, pd, pori, porj, pork, fw, fwd, gamma, si, sid, sj, sjd, sk, &
&   skd, indfamilyi, indfamilyj, indfamilyk, spectralsol, &
&   addgridvelocities, sfacei, sfacej, sfacek, rotmatrixi, rotmatrixj, &
&   rotmatrixk, factfamilyi, factfamilyj, factfamilyk
    use flowvarrefstate, only : kpresent, nw, nwf, rgas, rgasd, tref, &
&   trefd
    use inputdiscretization, only : limiter, lumpeddiss, precond, &
&   riemann, riemanncoarse, orderturb, kappacoef
    use inputphysics, only : equations
    use iteration, only : rfil, currentlevel, groundlevel
    use cgnsgrid, only : massflowfamilydiss
    use utils_b, only : getcorrectfork, terminate
    use flowutils_b, only : etot, etot_b
    implicit none
!
!      subroutine arguments.
!
    logical, intent(in) :: finegrid
!
!      local variables.
!
    integer(kind=portype) :: por
    integer(kind=inttype) :: nwint
    integer(kind=inttype) :: i, j, k, ind
    integer(kind=inttype) :: limused, riemannused
    real(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
    real(kind=realtype) :: sxd, syd, szd
    real(kind=realtype) :: factminmod, sface
    real(kind=realtype), dimension(nw) :: left, right
    real(kind=realtype), dimension(nw) :: leftd, rightd
    real(kind=realtype), dimension(nw) :: du1, du2, du3
    real(kind=realtype), dimension(nw) :: du1d, du2d, du3d
    real(kind=realtype), dimension(nwf) :: flux
    real(kind=realtype), dimension(nwf) :: fluxd
    logical :: firstorderk, correctfork, rotationalperiodic
    intrinsic abs
    intrinsic associated
    intrinsic max
    integer :: branch
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .ge. thresholdreal) then
! check if the formulation for rotational periodic problems
! must be used.
      if (associated(rotmatrixi)) then
        rotationalperiodic = .true.
      else
        rotationalperiodic = .false.
      end if
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      sfil = one - rfil
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
      if (1.e-10_realtype .lt. one - kappacoef) then
        max1 = one - kappacoef
      else
        max1 = 1.e-10_realtype
      end if
! compute the factor used in the minmod limiter.
      factminmod = (three-kappacoef)/max1
! determine the limiter scheme to be used. on the fine grid the
! user specified scheme is used; on the coarse grid a first order
! scheme is computed.
      limused = firstorder
      if (finegrid) limused = limiter
! lumped diss is true for doing approx pc
      if (lumpeddiss) limused = firstorder
! determine the riemann solver which must be used.
      riemannused = riemanncoarse
      if (finegrid) riemannused = riemann
! store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
      omk = fourth*(one-kappacoef)
      opk = fourth*(one+kappacoef)
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set the number of variables to be interpolated depending
! whether or not a k-equation is present. if a k-equation is
! present also set the logical firstorderk. this indicates
! whether or not only a first order approximation is to be used
! for the turbulent kinetic energy.
      if (correctfork) then
        if (orderturb .eq. firstorder) then
          nwint = nwf
          firstorderk = .true.
        else
          nwint = itu1
          firstorderk = .false.
        end if
      else
        nwint = nwf
        firstorderk = .false.
      end if
!
!       flux computation. a distinction is made between first and
!       second order schemes to avoid the overhead for the first order
!       scheme.
!
      if (limused .eq. firstorder) then
!
!         first order reconstruction. the states in the cells are
!         constant. the left and right states are constructed easily.
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              call pushreal8(sx)
              sx = si(i, j, k, 1)
              call pushreal8(sy)
              sy = si(i, j, k, 2)
              call pushreal8(sz)
              sz = si(i, j, k, 3)
              if (addgridvelocities) then
                call pushreal8(sface)
                sface = sfacei(i, j, k)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! determine the left and right state.
              call pushreal8(left(irho))
              left(irho) = w(i, j, k, irho)
              call pushreal8(left(ivx))
              left(ivx) = w(i, j, k, ivx)
              call pushreal8(left(ivy))
              left(ivy) = w(i, j, k, ivy)
              call pushreal8(left(ivz))
              left(ivz) = w(i, j, k, ivz)
              call pushreal8(left(irhoe))
              left(irhoe) = p(i, j, k)
              if (correctfork) then
                call pushreal8(left(itu1))
                left(itu1) = w(i, j, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              call pushreal8(right(irho))
              right(irho) = w(i+1, j, k, irho)
              call pushreal8(right(ivx))
              right(ivx) = w(i+1, j, k, ivx)
              call pushreal8(right(ivy))
              right(ivy) = w(i+1, j, k, ivy)
              call pushreal8(right(ivz))
              right(ivz) = w(i+1, j, k, ivz)
              call pushreal8(right(irhoe))
              right(irhoe) = p(i+1, j, k)
              if (correctfork) then
                call pushreal8(right(itu1))
                right(itu1) = w(i+1, j, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              call pushreal8(sx)
              sx = sj(i, j, k, 1)
              call pushreal8(sy)
              sy = sj(i, j, k, 2)
              call pushreal8(sz)
              sz = sj(i, j, k, 3)
              if (addgridvelocities) then
                call pushreal8(sface)
                sface = sfacej(i, j, k)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! determine the left and right state.
              call pushreal8(left(irho))
              left(irho) = w(i, j, k, irho)
              call pushreal8(left(ivx))
              left(ivx) = w(i, j, k, ivx)
              call pushreal8(left(ivy))
              left(ivy) = w(i, j, k, ivy)
              call pushreal8(left(ivz))
              left(ivz) = w(i, j, k, ivz)
              call pushreal8(left(irhoe))
              left(irhoe) = p(i, j, k)
              if (correctfork) then
                call pushreal8(left(itu1))
                left(itu1) = w(i, j, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              call pushreal8(right(irho))
              right(irho) = w(i, j+1, k, irho)
              call pushreal8(right(ivx))
              right(ivx) = w(i, j+1, k, ivx)
              call pushreal8(right(ivy))
              right(ivy) = w(i, j+1, k, ivy)
              call pushreal8(right(ivz))
              right(ivz) = w(i, j+1, k, ivz)
              call pushreal8(right(irhoe))
              right(irhoe) = p(i, j+1, k)
              if (correctfork) then
                call pushreal8(right(itu1))
                right(itu1) = w(i, j+1, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the normal vector, the porosity and the
! mesh velocity if present.
              call pushreal8(sx)
              sx = sk(i, j, k, 1)
              call pushreal8(sy)
              sy = sk(i, j, k, 2)
              call pushreal8(sz)
              sz = sk(i, j, k, 3)
              if (addgridvelocities) then
                call pushreal8(sface)
                sface = sfacek(i, j, k)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! determine the left and right state.
              call pushreal8(left(irho))
              left(irho) = w(i, j, k, irho)
              call pushreal8(left(ivx))
              left(ivx) = w(i, j, k, ivx)
              call pushreal8(left(ivy))
              left(ivy) = w(i, j, k, ivy)
              call pushreal8(left(ivz))
              left(ivz) = w(i, j, k, ivz)
              call pushreal8(left(irhoe))
              left(irhoe) = p(i, j, k)
              if (correctfork) then
                call pushreal8(left(itu1))
                left(itu1) = w(i, j, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
              call pushreal8(right(irho))
              right(irho) = w(i, j, k+1, irho)
              call pushreal8(right(ivx))
              right(ivx) = w(i, j, k+1, ivx)
              call pushreal8(right(ivy))
              right(ivy) = w(i, j, k+1, ivy)
              call pushreal8(right(ivz))
              right(ivz) = w(i, j, k+1, ivz)
              call pushreal8(right(irhoe))
              right(irhoe) = p(i, j, k+1)
              if (correctfork) then
                call pushreal8(right(itu1))
                right(itu1) = w(i, j, k+1, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
            end do
          end do
        end do
        fluxd = 0.0_8
        leftd = 0.0_8
        rightd = 0.0_8
        do k=kl,1,-1
          do j=jl,2,-1
            do i=il,2,-1
              fluxd(irhoe) = fluxd(irhoe) - fwd(i, j, k+1, irhoe)
              fluxd(imz) = fluxd(imz) - fwd(i, j, k+1, imz)
              fluxd(imy) = fluxd(imy) - fwd(i, j, k+1, imy)
              fluxd(imx) = fluxd(imx) - fwd(i, j, k+1, imx)
              fluxd(irho) = fluxd(irho) - fwd(i, j, k+1, irho)
              fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
              fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
              fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
              fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
              fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
              por = pork(i, j, k)
              call riemannflux_b(left, leftd, right, rightd, flux, fluxd&
&                         )
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                call popreal8(right(itu1))
                wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + rightd(itu1)
                rightd(itu1) = 0.0_8
              end if
              call popreal8(right(irhoe))
              pd(i, j, k+1) = pd(i, j, k+1) + rightd(irhoe)
              rightd(irhoe) = 0.0_8
              call popreal8(right(ivz))
              wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + rightd(ivz)
              rightd(ivz) = 0.0_8
              call popreal8(right(ivy))
              wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + rightd(ivy)
              rightd(ivy) = 0.0_8
              call popreal8(right(ivx))
              wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + rightd(ivx)
              rightd(ivx) = 0.0_8
              call popreal8(right(irho))
              wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + rightd(irho)
              rightd(irho) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                call popreal8(left(itu1))
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
                leftd(itu1) = 0.0_8
              end if
              call popreal8(left(irhoe))
              pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
              leftd(irhoe) = 0.0_8
              call popreal8(left(ivz))
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
              leftd(ivz) = 0.0_8
              call popreal8(left(ivy))
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
              leftd(ivy) = 0.0_8
              call popreal8(left(ivx))
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
              leftd(ivx) = 0.0_8
              call popreal8(left(irho))
              wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
              leftd(irho) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) call popreal8(sface)
              call popreal8(sz)
              skd(i, j, k, 3) = skd(i, j, k, 3) + szd
              call popreal8(sy)
              skd(i, j, k, 2) = skd(i, j, k, 2) + syd
              call popreal8(sx)
              skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
            end do
          end do
        end do
        do k=kl,2,-1
          do j=jl,1,-1
            do i=il,2,-1
              fluxd(irhoe) = fluxd(irhoe) - fwd(i, j+1, k, irhoe)
              fluxd(imz) = fluxd(imz) - fwd(i, j+1, k, imz)
              fluxd(imy) = fluxd(imy) - fwd(i, j+1, k, imy)
              fluxd(imx) = fluxd(imx) - fwd(i, j+1, k, imx)
              fluxd(irho) = fluxd(irho) - fwd(i, j+1, k, irho)
              fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
              fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
              fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
              fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
              fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
              por = porj(i, j, k)
              call riemannflux_b(left, leftd, right, rightd, flux, fluxd&
&                         )
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                call popreal8(right(itu1))
                wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + rightd(itu1)
                rightd(itu1) = 0.0_8
              end if
              call popreal8(right(irhoe))
              pd(i, j+1, k) = pd(i, j+1, k) + rightd(irhoe)
              rightd(irhoe) = 0.0_8
              call popreal8(right(ivz))
              wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + rightd(ivz)
              rightd(ivz) = 0.0_8
              call popreal8(right(ivy))
              wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + rightd(ivy)
              rightd(ivy) = 0.0_8
              call popreal8(right(ivx))
              wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + rightd(ivx)
              rightd(ivx) = 0.0_8
              call popreal8(right(irho))
              wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + rightd(irho)
              rightd(irho) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                call popreal8(left(itu1))
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
                leftd(itu1) = 0.0_8
              end if
              call popreal8(left(irhoe))
              pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
              leftd(irhoe) = 0.0_8
              call popreal8(left(ivz))
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
              leftd(ivz) = 0.0_8
              call popreal8(left(ivy))
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
              leftd(ivy) = 0.0_8
              call popreal8(left(ivx))
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
              leftd(ivx) = 0.0_8
              call popreal8(left(irho))
              wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
              leftd(irho) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) call popreal8(sface)
              call popreal8(sz)
              sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
              call popreal8(sy)
              sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
              call popreal8(sx)
              sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
            end do
          end do
        end do
        do k=kl,2,-1
          do j=jl,2,-1
            do i=il,1,-1
              fluxd(irhoe) = fluxd(irhoe) - fwd(i+1, j, k, irhoe)
              fluxd(imz) = fluxd(imz) - fwd(i+1, j, k, imz)
              fluxd(imy) = fluxd(imy) - fwd(i+1, j, k, imy)
              fluxd(imx) = fluxd(imx) - fwd(i+1, j, k, imx)
              fluxd(irho) = fluxd(irho) - fwd(i+1, j, k, irho)
              fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
              fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
              fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
              fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
              fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
              por = pori(i, j, k)
              call riemannflux_b(left, leftd, right, rightd, flux, fluxd&
&                         )
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                call popreal8(right(itu1))
                wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + rightd(itu1)
                rightd(itu1) = 0.0_8
              end if
              call popreal8(right(irhoe))
              pd(i+1, j, k) = pd(i+1, j, k) + rightd(irhoe)
              rightd(irhoe) = 0.0_8
              call popreal8(right(ivz))
              wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + rightd(ivz)
              rightd(ivz) = 0.0_8
              call popreal8(right(ivy))
              wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + rightd(ivy)
              rightd(ivy) = 0.0_8
              call popreal8(right(ivx))
              wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + rightd(ivx)
              rightd(ivx) = 0.0_8
              call popreal8(right(irho))
              wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + rightd(irho)
              rightd(irho) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                call popreal8(left(itu1))
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
                leftd(itu1) = 0.0_8
              end if
              call popreal8(left(irhoe))
              pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
              leftd(irhoe) = 0.0_8
              call popreal8(left(ivz))
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
              leftd(ivz) = 0.0_8
              call popreal8(left(ivy))
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
              leftd(ivy) = 0.0_8
              call popreal8(left(ivx))
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
              leftd(ivx) = 0.0_8
              call popreal8(left(irho))
              wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
              leftd(irho) = 0.0_8
              call popcontrol1b(branch)
              if (branch .eq. 0) call popreal8(sface)
              call popreal8(sz)
              sid(i, j, k, 3) = sid(i, j, k, 3) + szd
              call popreal8(sy)
              sid(i, j, k, 2) = sid(i, j, k, 2) + syd
              call popreal8(sx)
              sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
            end do
          end do
        end do
      else
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
!      ==================================================================
!
!         second order reconstruction of the left and right state.
!         the three differences used in the, possibly nonlinear,
!         interpolation are constructed here; the actual left and
!         right states, or at least the differences from the first
!         order interpolation, are computed in the subroutine
!         leftrightstate.
!
! fluxes in the i-direction.
        do k=2,kl
          do j=2,jl
            do i=1,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
              du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
              du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
              du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
              du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
              du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
              du1(irhoe) = p(i, j, k) - p(i-1, j, k)
              du2(irhoe) = p(i+1, j, k) - p(i, j, k)
              du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
                du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! compute the differences from the first order scheme.
              call pushreal8array(right, nw)
              call pushreal8array(left, nw)
              call pushreal8array(du3, nw)
              call pushreal8array(du2, nw)
              call pushreal8array(du1, nw)
              call leftrightstate(du1, du2, du3, rotmatrixi, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i+1, j, k, irho)
              right(ivx) = right(ivx) + w(i+1, j, k, ivx)
              right(ivy) = right(ivy) + w(i+1, j, k, ivy)
              right(ivz) = right(ivz) + w(i+1, j, k, ivz)
              right(irhoe) = right(irhoe) + p(i+1, j, k)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i+1, j, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              call pushreal8(sx)
              sx = si(i, j, k, 1)
              call pushreal8(sy)
              sy = si(i, j, k, 2)
              call pushreal8(sz)
              sz = si(i, j, k, 3)
              if (addgridvelocities) then
                call pushreal8(sface)
                sface = sfacei(i, j, k)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the j-direction.
        do k=2,kl
          do j=1,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
              du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
              du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
              du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
              du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
              du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
              du1(irhoe) = p(i, j, k) - p(i, j-1, k)
              du2(irhoe) = p(i, j+1, k) - p(i, j, k)
              du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
                du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! compute the differences from the first order scheme.
              call pushreal8array(right, nw)
              call pushreal8array(left, nw)
              call pushreal8array(du3, nw)
              call pushreal8array(du2, nw)
              call pushreal8array(du1, nw)
              call leftrightstate(du1, du2, du3, rotmatrixj, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i, j+1, k, irho)
              right(ivx) = right(ivx) + w(i, j+1, k, ivx)
              right(ivy) = right(ivy) + w(i, j+1, k, ivy)
              right(ivz) = right(ivz) + w(i, j+1, k, ivz)
              right(irhoe) = right(irhoe) + p(i, j+1, k)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i, j+1, k, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              call pushreal8(sx)
              sx = sj(i, j, k, 1)
              call pushreal8(sy)
              sy = sj(i, j, k, 2)
              call pushreal8(sz)
              sz = sj(i, j, k, 3)
              if (addgridvelocities) then
                call pushreal8(sface)
                sface = sfacej(i, j, k)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
            end do
          end do
        end do
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
! fluxes in the k-direction.
        do k=1,kl
          do j=2,jl
            do i=2,il
! store the three differences used in the interpolation
! in du1, du2, du3.
              du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
              du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
              du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
              du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
              du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
              du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
              du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
              du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
              du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
              du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
              du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
              du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
              du1(irhoe) = p(i, j, k) - p(i, j, k-1)
              du2(irhoe) = p(i, j, k+1) - p(i, j, k)
              du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
              if (correctfork) then
                du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
                du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
                du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! compute the differences from the first order scheme.
              call pushreal8array(right, nw)
              call pushreal8array(left, nw)
              call pushreal8array(du3, nw)
              call pushreal8array(du2, nw)
              call pushreal8array(du1, nw)
              call leftrightstate(du1, du2, du3, rotmatrixk, left, right&
&                          )
! add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
              left(irho) = left(irho) + w(i, j, k, irho)
              left(ivx) = left(ivx) + w(i, j, k, ivx)
              left(ivy) = left(ivy) + w(i, j, k, ivy)
              left(ivz) = left(ivz) + w(i, j, k, ivz)
              left(irhoe) = left(irhoe) + p(i, j, k)
              right(irho) = right(irho) + w(i, j, k+1, irho)
              right(ivx) = right(ivx) + w(i, j, k+1, ivx)
              right(ivy) = right(ivy) + w(i, j, k+1, ivy)
              right(ivz) = right(ivz) + w(i, j, k+1, ivz)
              right(irhoe) = right(irhoe) + p(i, j, k+1)
              if (correctfork) then
                left(itu1) = left(itu1) + w(i, j, k, itu1)
                right(itu1) = right(itu1) + w(i, j, k+1, itu1)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
! store the normal vector, the porosity and the
! mesh velocity if present.
              call pushreal8(sx)
              sx = sk(i, j, k, 1)
              call pushreal8(sy)
              sy = sk(i, j, k, 2)
              call pushreal8(sz)
              sz = sk(i, j, k, 3)
              if (addgridvelocities) then
                call pushreal8(sface)
                sface = sfacek(i, j, k)
                call pushcontrol1b(0)
              else
                call pushcontrol1b(1)
              end if
            end do
          end do
        end do
        fluxd = 0.0_8
        leftd = 0.0_8
        rightd = 0.0_8
        du1d = 0.0_8
        du2d = 0.0_8
        du3d = 0.0_8
        do k=kl,1,-1
          do j=jl,2,-1
            do i=il,2,-1
              fluxd(irhoe) = fluxd(irhoe) - fwd(i, j, k+1, irhoe)
              fluxd(imz) = fluxd(imz) - fwd(i, j, k+1, imz)
              fluxd(imy) = fluxd(imy) - fwd(i, j, k+1, imy)
              fluxd(imx) = fluxd(imx) - fwd(i, j, k+1, imx)
              fluxd(irho) = fluxd(irho) - fwd(i, j, k+1, irho)
              fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
              fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
              fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
              fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
              fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
              gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
              por = pork(i, j, k)
              call riemannflux_b(left, leftd, right, rightd, flux, fluxd&
&                         )
              call popcontrol1b(branch)
              if (branch .eq. 0) call popreal8(sface)
              call popreal8(sz)
              skd(i, j, k, 3) = skd(i, j, k, 3) + szd
              call popreal8(sy)
              skd(i, j, k, 2) = skd(i, j, k, 2) + syd
              call popreal8(sx)
              skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + rightd(itu1)
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
              end if
              pd(i, j, k+1) = pd(i, j, k+1) + rightd(irhoe)
              wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + rightd(ivz)
              wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + rightd(ivy)
              wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + rightd(ivx)
              wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + rightd(irho)
              pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
              wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
              call popreal8array(du1, nw)
              call popreal8array(du2, nw)
              call popreal8array(du3, nw)
              call popreal8array(left, nw)
              call popreal8array(right, nw)
              call leftrightstate_b(du1, du1d, du2, du2d, du3, du3d, &
&                             rotmatrixk, left, leftd, right, rightd)
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                wd(i, j, k+2, itu1) = wd(i, j, k+2, itu1) + du3d(itu1)
                wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) - du3d(itu1)
                du3d(itu1) = 0.0_8
                wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + du2d(itu1)
                wd(i, j, k, itu1) = wd(i, j, k, itu1) - du2d(itu1)
                du2d(itu1) = 0.0_8
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + du1d(itu1)
                wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) - du1d(itu1)
                du1d(itu1) = 0.0_8
              end if
              pd(i, j, k+2) = pd(i, j, k+2) + du3d(irhoe)
              pd(i, j, k+1) = pd(i, j, k+1) - du3d(irhoe)
              du3d(irhoe) = 0.0_8
              pd(i, j, k+1) = pd(i, j, k+1) + du2d(irhoe)
              pd(i, j, k) = pd(i, j, k) - du2d(irhoe)
              du2d(irhoe) = 0.0_8
              pd(i, j, k) = pd(i, j, k) + du1d(irhoe)
              pd(i, j, k-1) = pd(i, j, k-1) - du1d(irhoe)
              du1d(irhoe) = 0.0_8
              wd(i, j, k+2, ivz) = wd(i, j, k+2, ivz) + du3d(ivz)
              wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) - du3d(ivz)
              du3d(ivz) = 0.0_8
              wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + du2d(ivz)
              wd(i, j, k, ivz) = wd(i, j, k, ivz) - du2d(ivz)
              du2d(ivz) = 0.0_8
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + du1d(ivz)
              wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - du1d(ivz)
              du1d(ivz) = 0.0_8
              wd(i, j, k+2, ivy) = wd(i, j, k+2, ivy) + du3d(ivy)
              wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) - du3d(ivy)
              du3d(ivy) = 0.0_8
              wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + du2d(ivy)
              wd(i, j, k, ivy) = wd(i, j, k, ivy) - du2d(ivy)
              du2d(ivy) = 0.0_8
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + du1d(ivy)
              wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - du1d(ivy)
              du1d(ivy) = 0.0_8
              wd(i, j, k+2, ivx) = wd(i, j, k+2, ivx) + du3d(ivx)
              wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) - du3d(ivx)
              du3d(ivx) = 0.0_8
              wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + du2d(ivx)
              wd(i, j, k, ivx) = wd(i, j, k, ivx) - du2d(ivx)
              du2d(ivx) = 0.0_8
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + du1d(ivx)
              wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - du1d(ivx)
              du1d(ivx) = 0.0_8
              wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + du3d(irho)
              wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - du3d(irho)
              du3d(irho) = 0.0_8
              wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + du2d(irho)
              wd(i, j, k, irho) = wd(i, j, k, irho) - du2d(irho)
              du2d(irho) = 0.0_8
              wd(i, j, k, irho) = wd(i, j, k, irho) + du1d(irho)
              wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - du1d(irho)
              du1d(irho) = 0.0_8
            end do
          end do
        end do
        do k=kl,2,-1
          do j=jl,1,-1
            do i=il,2,-1
              fluxd(irhoe) = fluxd(irhoe) - fwd(i, j+1, k, irhoe)
              fluxd(imz) = fluxd(imz) - fwd(i, j+1, k, imz)
              fluxd(imy) = fluxd(imy) - fwd(i, j+1, k, imy)
              fluxd(imx) = fluxd(imx) - fwd(i, j+1, k, imx)
              fluxd(irho) = fluxd(irho) - fwd(i, j+1, k, irho)
              fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
              fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
              fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
              fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
              fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
              gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
              por = porj(i, j, k)
              call riemannflux_b(left, leftd, right, rightd, flux, fluxd&
&                         )
              call popcontrol1b(branch)
              if (branch .eq. 0) call popreal8(sface)
              call popreal8(sz)
              sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
              call popreal8(sy)
              sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
              call popreal8(sx)
              sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + rightd(itu1)
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
              end if
              pd(i, j+1, k) = pd(i, j+1, k) + rightd(irhoe)
              wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + rightd(ivz)
              wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + rightd(ivy)
              wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + rightd(ivx)
              wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + rightd(irho)
              pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
              wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
              call popreal8array(du1, nw)
              call popreal8array(du2, nw)
              call popreal8array(du3, nw)
              call popreal8array(left, nw)
              call popreal8array(right, nw)
              call leftrightstate_b(du1, du1d, du2, du2d, du3, du3d, &
&                             rotmatrixj, left, leftd, right, rightd)
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                wd(i, j+2, k, itu1) = wd(i, j+2, k, itu1) + du3d(itu1)
                wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) - du3d(itu1)
                du3d(itu1) = 0.0_8
                wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + du2d(itu1)
                wd(i, j, k, itu1) = wd(i, j, k, itu1) - du2d(itu1)
                du2d(itu1) = 0.0_8
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + du1d(itu1)
                wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) - du1d(itu1)
                du1d(itu1) = 0.0_8
              end if
              pd(i, j+2, k) = pd(i, j+2, k) + du3d(irhoe)
              pd(i, j+1, k) = pd(i, j+1, k) - du3d(irhoe)
              du3d(irhoe) = 0.0_8
              pd(i, j+1, k) = pd(i, j+1, k) + du2d(irhoe)
              pd(i, j, k) = pd(i, j, k) - du2d(irhoe)
              du2d(irhoe) = 0.0_8
              pd(i, j, k) = pd(i, j, k) + du1d(irhoe)
              pd(i, j-1, k) = pd(i, j-1, k) - du1d(irhoe)
              du1d(irhoe) = 0.0_8
              wd(i, j+2, k, ivz) = wd(i, j+2, k, ivz) + du3d(ivz)
              wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) - du3d(ivz)
              du3d(ivz) = 0.0_8
              wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + du2d(ivz)
              wd(i, j, k, ivz) = wd(i, j, k, ivz) - du2d(ivz)
              du2d(ivz) = 0.0_8
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + du1d(ivz)
              wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - du1d(ivz)
              du1d(ivz) = 0.0_8
              wd(i, j+2, k, ivy) = wd(i, j+2, k, ivy) + du3d(ivy)
              wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) - du3d(ivy)
              du3d(ivy) = 0.0_8
              wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + du2d(ivy)
              wd(i, j, k, ivy) = wd(i, j, k, ivy) - du2d(ivy)
              du2d(ivy) = 0.0_8
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + du1d(ivy)
              wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - du1d(ivy)
              du1d(ivy) = 0.0_8
              wd(i, j+2, k, ivx) = wd(i, j+2, k, ivx) + du3d(ivx)
              wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) - du3d(ivx)
              du3d(ivx) = 0.0_8
              wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + du2d(ivx)
              wd(i, j, k, ivx) = wd(i, j, k, ivx) - du2d(ivx)
              du2d(ivx) = 0.0_8
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + du1d(ivx)
              wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - du1d(ivx)
              du1d(ivx) = 0.0_8
              wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + du3d(irho)
              wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - du3d(irho)
              du3d(irho) = 0.0_8
              wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + du2d(irho)
              wd(i, j, k, irho) = wd(i, j, k, irho) - du2d(irho)
              du2d(irho) = 0.0_8
              wd(i, j, k, irho) = wd(i, j, k, irho) + du1d(irho)
              wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - du1d(irho)
              du1d(irho) = 0.0_8
            end do
          end do
        end do
        do k=kl,2,-1
          do j=jl,2,-1
            do i=il,1,-1
              fluxd(irhoe) = fluxd(irhoe) - fwd(i+1, j, k, irhoe)
              fluxd(imz) = fluxd(imz) - fwd(i+1, j, k, imz)
              fluxd(imy) = fluxd(imy) - fwd(i+1, j, k, imy)
              fluxd(imx) = fluxd(imx) - fwd(i+1, j, k, imx)
              fluxd(irho) = fluxd(irho) - fwd(i+1, j, k, irho)
              fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
              fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
              fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
              fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
              fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
              gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
              por = pori(i, j, k)
              call riemannflux_b(left, leftd, right, rightd, flux, fluxd&
&                         )
              call popcontrol1b(branch)
              if (branch .eq. 0) call popreal8(sface)
              call popreal8(sz)
              sid(i, j, k, 3) = sid(i, j, k, 3) + szd
              call popreal8(sy)
              sid(i, j, k, 2) = sid(i, j, k, 2) + syd
              call popreal8(sx)
              sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + rightd(itu1)
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
              end if
              pd(i+1, j, k) = pd(i+1, j, k) + rightd(irhoe)
              wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + rightd(ivz)
              wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + rightd(ivy)
              wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + rightd(ivx)
              wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + rightd(irho)
              pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
              wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
              call popreal8array(du1, nw)
              call popreal8array(du2, nw)
              call popreal8array(du3, nw)
              call popreal8array(left, nw)
              call popreal8array(right, nw)
              call leftrightstate_b(du1, du1d, du2, du2d, du3, du3d, &
&                             rotmatrixi, left, leftd, right, rightd)
              call popcontrol1b(branch)
              if (branch .eq. 0) then
                wd(i+2, j, k, itu1) = wd(i+2, j, k, itu1) + du3d(itu1)
                wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) - du3d(itu1)
                du3d(itu1) = 0.0_8
                wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + du2d(itu1)
                wd(i, j, k, itu1) = wd(i, j, k, itu1) - du2d(itu1)
                du2d(itu1) = 0.0_8
                wd(i, j, k, itu1) = wd(i, j, k, itu1) + du1d(itu1)
                wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) - du1d(itu1)
                du1d(itu1) = 0.0_8
              end if
              pd(i+2, j, k) = pd(i+2, j, k) + du3d(irhoe)
              pd(i+1, j, k) = pd(i+1, j, k) - du3d(irhoe)
              du3d(irhoe) = 0.0_8
              pd(i+1, j, k) = pd(i+1, j, k) + du2d(irhoe)
              pd(i, j, k) = pd(i, j, k) - du2d(irhoe)
              du2d(irhoe) = 0.0_8
              pd(i, j, k) = pd(i, j, k) + du1d(irhoe)
              pd(i-1, j, k) = pd(i-1, j, k) - du1d(irhoe)
              du1d(irhoe) = 0.0_8
              wd(i+2, j, k, ivz) = wd(i+2, j, k, ivz) + du3d(ivz)
              wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) - du3d(ivz)
              du3d(ivz) = 0.0_8
              wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + du2d(ivz)
              wd(i, j, k, ivz) = wd(i, j, k, ivz) - du2d(ivz)
              du2d(ivz) = 0.0_8
              wd(i, j, k, ivz) = wd(i, j, k, ivz) + du1d(ivz)
              wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - du1d(ivz)
              du1d(ivz) = 0.0_8
              wd(i+2, j, k, ivy) = wd(i+2, j, k, ivy) + du3d(ivy)
              wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) - du3d(ivy)
              du3d(ivy) = 0.0_8
              wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + du2d(ivy)
              wd(i, j, k, ivy) = wd(i, j, k, ivy) - du2d(ivy)
              du2d(ivy) = 0.0_8
              wd(i, j, k, ivy) = wd(i, j, k, ivy) + du1d(ivy)
              wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - du1d(ivy)
              du1d(ivy) = 0.0_8
              wd(i+2, j, k, ivx) = wd(i+2, j, k, ivx) + du3d(ivx)
              wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) - du3d(ivx)
              du3d(ivx) = 0.0_8
              wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + du2d(ivx)
              wd(i, j, k, ivx) = wd(i, j, k, ivx) - du2d(ivx)
              du2d(ivx) = 0.0_8
              wd(i, j, k, ivx) = wd(i, j, k, ivx) + du1d(ivx)
              wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - du1d(ivx)
              du1d(ivx) = 0.0_8
              wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + du3d(irho)
              wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - du3d(irho)
              du3d(irho) = 0.0_8
              wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + du2d(irho)
              wd(i, j, k, irho) = wd(i, j, k, irho) - du2d(irho)
              du2d(irho) = 0.0_8
              wd(i, j, k, irho) = wd(i, j, k, irho) + du1d(irho)
              wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - du1d(irho)
              du1d(irho) = 0.0_8
            end do
          end do
        end do
      end if
      do k=kl,2,-1
        do j=jl,2,-1
          do i=il,2,-1
            fwd(i, j, k, irhoe) = sfil*fwd(i, j, k, irhoe)
            fwd(i, j, k, imz) = sfil*fwd(i, j, k, imz)
            fwd(i, j, k, imy) = sfil*fwd(i, j, k, imy)
            fwd(i, j, k, imx) = sfil*fwd(i, j, k, imx)
            fwd(i, j, k, irho) = sfil*fwd(i, j, k, irho)
          end do
        end do
      end do
    end if

  contains
!  differentiation of leftrightstate in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: left right du1 du2 du3
!   with respect to varying inputs: left right du1 du2 du3
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
    subroutine leftrightstate_b(du1, du1d, du2, du2d, du3, du3d, &
&     rotmatrix, left, leftd, right, rightd)
      implicit none
!
!        local parameter.
!
      real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
      real(kind=realtype), dimension(:), intent(inout) :: du1d
      real(kind=realtype), dimension(:) :: left, right
      real(kind=realtype), dimension(:) :: leftd, rightd
      real(kind=realtype), dimension(:, :, :, :, :), pointer :: &
&     rotmatrix
!
!        local variables.
!
      integer(kind=inttype) :: l
      real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
      real(kind=realtype) :: rl1d, rl2d, rr1d, rr2d, tmpd, dvxd, dvyd, &
&     dvzd
      real(kind=realtype), dimension(3, 3) :: rot
      intrinsic abs
      intrinsic max
      intrinsic sign
      intrinsic min
      integer :: branch
      real(kind=realtype), dimension(:), intent(inout) :: du3d
      real(kind=realtype), dimension(:), intent(inout) :: du2d
      real(kind=realtype) :: temp3
      real(kind=realtype) :: temp2
      real(kind=realtype) :: temp1
      real(kind=realtype) :: temp0
      real(kind=realtype) :: x6d
      real(kind=realtype) :: y4d
      real(kind=realtype) :: max2d
      real(kind=realtype) :: max5d
      real(kind=realtype) :: x6
      real(kind=realtype) :: x5
      real(kind=realtype) :: x4
      real(kind=realtype) :: x3
      real(kind=realtype) :: x2
      real(kind=realtype) :: x2d
      real(kind=realtype) :: x1
      real(kind=realtype) :: x5d
      real(kind=realtype) :: y3d
      real(kind=realtype) :: tempd
      real(kind=realtype) :: max4d
      real(kind=realtype) :: tempd8
      real(kind=realtype) :: tempd7
      real(kind=realtype) :: tempd6
      real(kind=realtype) :: tempd5
      real(kind=realtype) :: tempd4
      real(kind=realtype) :: tempd3
      real(kind=realtype) :: tempd2
      real(kind=realtype) :: tempd1
      real(kind=realtype) :: max7d
      real(kind=realtype) :: tempd0
      real(kind=realtype) :: x1d
      real(kind=realtype) :: x4d
      real(kind=realtype) :: y2d
      real(kind=realtype) :: max3d
      real(kind=realtype) :: max7
      real(kind=realtype) :: max6
      real(kind=realtype) :: max6d
      real(kind=realtype) :: max5
      real(kind=realtype) :: max4
      real(kind=realtype) :: temp
      real(kind=realtype) :: max3
      real(kind=realtype) :: max2
      real(kind=realtype) :: y4
      real(kind=realtype) :: y3
      real(kind=realtype) :: y2
      real(kind=realtype) :: x3d
      real(kind=realtype) :: y1
      real(kind=realtype) :: y1d
      real(kind=realtype) :: temp4
! check if the velocity components should be transformed to
! the cylindrical frame.
      if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
        rot(1, 1) = rotmatrix(i, j, k, 1, 1)
        rot(1, 2) = rotmatrix(i, j, k, 1, 2)
        rot(1, 3) = rotmatrix(i, j, k, 1, 3)
        rot(2, 1) = rotmatrix(i, j, k, 2, 1)
        rot(2, 2) = rotmatrix(i, j, k, 2, 2)
        rot(2, 3) = rotmatrix(i, j, k, 2, 3)
        rot(3, 1) = rotmatrix(i, j, k, 3, 1)
        rot(3, 2) = rotmatrix(i, j, k, 3, 2)
        rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
        dvx = du1(ivx)
        dvy = du1(ivy)
        dvz = du1(ivz)
        du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du2(ivx)
        dvy = du2(ivy)
        dvz = du2(ivz)
        du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du3(ivx)
        dvy = du3(ivy)
        dvz = du3(ivz)
        du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! determine the limiter used.
      select case  (limused)
      case (nolimiter)
        call pushcontrol2b(1)
      case (vanalbeda)
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x1 = du2(l)
            call pushcontrol1b(0)
          else
            x1 = -du2(l)
            call pushcontrol1b(1)
          end if
          if (x1 .lt. epslim) then
            call pushreal8(max2)
            max2 = epslim
            call pushcontrol1b(0)
          else
            call pushreal8(max2)
            max2 = x1
            call pushcontrol1b(1)
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          call pushreal8(tmp)
          tmp = one/sign(max2, du2(l))
          if (du1(l) .ge. 0.) then
            x3 = du1(l)
            call pushcontrol1b(0)
          else
            x3 = -du1(l)
            call pushcontrol1b(1)
          end if
          if (x3 .lt. epslim) then
            call pushreal8(max4)
            max4 = epslim
            call pushcontrol1b(0)
          else
            call pushreal8(max4)
            max4 = x3
            call pushcontrol1b(1)
          end if
          y1 = du2(l)/sign(max4, du1(l))
          if (zero .lt. y1) then
            call pushreal8(rl1)
            rl1 = y1
            call pushcontrol1b(0)
          else
            call pushreal8(rl1)
            rl1 = zero
            call pushcontrol1b(1)
          end if
          if (zero .lt. du1(l)*tmp) then
            call pushreal8(rl2)
            rl2 = du1(l)*tmp
            call pushcontrol1b(0)
          else
            call pushreal8(rl2)
            rl2 = zero
            call pushcontrol1b(1)
          end if
          if (zero .lt. du3(l)*tmp) then
            call pushreal8(rr1)
            rr1 = du3(l)*tmp
            call pushcontrol1b(0)
          else
            call pushreal8(rr1)
            rr1 = zero
            call pushcontrol1b(1)
          end if
          if (du3(l) .ge. 0.) then
            x4 = du3(l)
            call pushcontrol1b(0)
          else
            x4 = -du3(l)
            call pushcontrol1b(1)
          end if
          if (x4 .lt. epslim) then
            call pushreal8(max5)
            max5 = epslim
            call pushcontrol1b(0)
          else
            call pushreal8(max5)
            max5 = x4
            call pushcontrol1b(1)
          end if
          y2 = du2(l)/sign(max5, du3(l))
          if (zero .lt. y2) then
            call pushreal8(rr2)
            rr2 = y2
            call pushcontrol1b(0)
          else
            call pushreal8(rr2)
            rr2 = zero
            call pushcontrol1b(1)
          end if
! compute the corresponding limiter values.
          call pushreal8(rl1)
          rl1 = rl1*(rl1+one)/(rl1*rl1+one)
          call pushreal8(rl2)
          rl2 = rl2*(rl2+one)/(rl2*rl2+one)
          call pushreal8(rr1)
          rr1 = rr1*(rr1+one)/(rr1*rr1+one)
          call pushreal8(rr2)
          rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
        end do
        call pushcontrol2b(2)
      case (minmod)
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x2 = du2(l)
            call pushcontrol1b(0)
          else
            x2 = -du2(l)
            call pushcontrol1b(1)
          end if
          if (x2 .lt. epslim) then
            call pushreal8(max3)
            max3 = epslim
            call pushcontrol1b(0)
          else
            call pushreal8(max3)
            max3 = x2
            call pushcontrol1b(1)
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          call pushreal8(tmp)
          tmp = one/sign(max3, du2(l))
          if (du1(l) .ge. 0.) then
            x5 = du1(l)
            call pushcontrol1b(0)
          else
            x5 = -du1(l)
            call pushcontrol1b(1)
          end if
          if (x5 .lt. epslim) then
            call pushreal8(max6)
            max6 = epslim
            call pushcontrol1b(0)
          else
            call pushreal8(max6)
            max6 = x5
            call pushcontrol1b(1)
          end if
          y3 = du2(l)/sign(max6, du1(l))
          if (zero .lt. y3) then
            call pushreal8(rl1)
            rl1 = y3
            call pushcontrol1b(0)
          else
            call pushreal8(rl1)
            rl1 = zero
            call pushcontrol1b(1)
          end if
          if (zero .lt. du1(l)*tmp) then
            call pushreal8(rl2)
            rl2 = du1(l)*tmp
            call pushcontrol1b(0)
          else
            call pushreal8(rl2)
            rl2 = zero
            call pushcontrol1b(1)
          end if
          if (zero .lt. du3(l)*tmp) then
            call pushreal8(rr1)
            rr1 = du3(l)*tmp
            call pushcontrol1b(0)
          else
            call pushreal8(rr1)
            rr1 = zero
            call pushcontrol1b(1)
          end if
          if (du3(l) .ge. 0.) then
            x6 = du3(l)
            call pushcontrol1b(0)
          else
            x6 = -du3(l)
            call pushcontrol1b(1)
          end if
          if (x6 .lt. epslim) then
            call pushreal8(max7)
            max7 = epslim
            call pushcontrol1b(0)
          else
            call pushreal8(max7)
            max7 = x6
            call pushcontrol1b(1)
          end if
          y4 = du2(l)/sign(max7, du3(l))
          if (zero .lt. y4) then
            call pushreal8(rr2)
            rr2 = y4
            call pushcontrol1b(0)
          else
            call pushreal8(rr2)
            rr2 = zero
            call pushcontrol1b(1)
          end if
          if (one .gt. factminmod*rl1) then
            rl1 = factminmod*rl1
            call pushcontrol1b(0)
          else
            rl1 = one
            call pushcontrol1b(1)
          end if
          if (one .gt. factminmod*rl2) then
            rl2 = factminmod*rl2
            call pushcontrol1b(0)
          else
            rl2 = one
            call pushcontrol1b(1)
          end if
          if (one .gt. factminmod*rr1) then
            rr1 = factminmod*rr1
            call pushcontrol1b(0)
          else
            rr1 = one
            call pushcontrol1b(1)
          end if
          if (one .gt. factminmod*rr2) then
            rr2 = factminmod*rr2
            call pushcontrol1b(0)
          else
            rr2 = one
            call pushcontrol1b(1)
          end if
        end do
        call pushcontrol2b(3)
      case default
        call pushcontrol2b(0)
      end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
      if (firstorderk) then
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
      if (rotationalperiodic) then
        dvxd = rot(1, 3)*rightd(ivz)
        dvyd = rot(2, 3)*rightd(ivz)
        dvzd = rot(3, 3)*rightd(ivz)
        rightd(ivz) = 0.0_8
        dvxd = dvxd + rot(1, 2)*rightd(ivy)
        dvyd = dvyd + rot(2, 2)*rightd(ivy)
        dvzd = dvzd + rot(3, 2)*rightd(ivy)
        rightd(ivy) = 0.0_8
        dvxd = dvxd + rot(1, 1)*rightd(ivx)
        dvyd = dvyd + rot(2, 1)*rightd(ivx)
        dvzd = dvzd + rot(3, 1)*rightd(ivx)
        rightd(ivx) = 0.0_8
        rightd(ivz) = rightd(ivz) + dvzd
        rightd(ivy) = rightd(ivy) + dvyd
        rightd(ivx) = rightd(ivx) + dvxd
        dvxd = rot(1, 3)*leftd(ivz)
        dvyd = rot(2, 3)*leftd(ivz)
        dvzd = rot(3, 3)*leftd(ivz)
        leftd(ivz) = 0.0_8
        dvxd = dvxd + rot(1, 2)*leftd(ivy)
        dvyd = dvyd + rot(2, 2)*leftd(ivy)
        dvzd = dvzd + rot(3, 2)*leftd(ivy)
        leftd(ivy) = 0.0_8
        dvxd = dvxd + rot(1, 1)*leftd(ivx)
        dvyd = dvyd + rot(2, 1)*leftd(ivx)
        dvzd = dvzd + rot(3, 1)*leftd(ivx)
        leftd(ivx) = 0.0_8
        leftd(ivz) = leftd(ivz) + dvzd
        leftd(ivy) = leftd(ivy) + dvyd
        leftd(ivx) = leftd(ivx) + dvxd
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rightd(itu1) = 0.0_8
        leftd(itu1) = 0.0_8
      end if
      call popcontrol2b(branch)
      if (branch .lt. 2) then
        if (branch .ne. 0) then
          do l=nwint,1,-1
            du3d(l) = du3d(l) - omk*rightd(l)
            du2d(l) = du2d(l) + opk*leftd(l) - opk*rightd(l)
            rightd(l) = 0.0_8
            du1d(l) = du1d(l) + omk*leftd(l)
            leftd(l) = 0.0_8
          end do
        end if
      else if (branch .eq. 2) then
        do l=nwint,1,-1
          rr1d = -(opk*du2(l)*rightd(l))
          du2d(l) = du2d(l) + opk*rl2*leftd(l) - opk*rr1*rightd(l)
          rr2d = -(omk*du3(l)*rightd(l))
          du3d(l) = du3d(l) - omk*rr2*rightd(l)
          rightd(l) = 0.0_8
          rl1d = omk*du1(l)*leftd(l)
          du1d(l) = du1d(l) + omk*rl1*leftd(l)
          rl2d = opk*du2(l)*leftd(l)
          leftd(l) = 0.0_8
          call popreal8(rr2)
          tempd2 = rr2d/(one+rr2**2)
          rr2d = (2*rr2-rr2**2*(one+rr2)*2/(one+rr2**2)+one)*tempd2
          call popreal8(rr1)
          tempd3 = rr1d/(one+rr1**2)
          rr1d = (2*rr1-rr1**2*(one+rr1)*2/(one+rr1**2)+one)*tempd3
          call popreal8(rl2)
          tempd4 = rl2d/(one+rl2**2)
          rl2d = (2*rl2-rl2**2*(one+rl2)*2/(one+rl2**2)+one)*tempd4
          call popreal8(rl1)
          tempd5 = rl1d/(one+rl1**2)
          rl1d = (2*rl1-rl1**2*(one+rl1)*2/(one+rl1**2)+one)*tempd5
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rr2)
            y2d = rr2d
          else
            call popreal8(rr2)
            y2d = 0.0_8
          end if
          temp1 = sign(max5, du3(l))
          tempd1 = -(du2(l)*y2d/temp1**2)
          du2d(l) = du2d(l) + y2d/temp1
          max5d = sign(1.d0, max5*du3(l))*tempd1
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max5)
            x4d = 0.0_8
          else
            call popreal8(max5)
            x4d = max5d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            du3d(l) = du3d(l) + x4d
          else
            du3d(l) = du3d(l) - x4d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rr1)
            du3d(l) = du3d(l) + tmp*rr1d
            tmpd = du3(l)*rr1d
          else
            call popreal8(rr1)
            tmpd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rl2)
            du1d(l) = du1d(l) + tmp*rl2d
            tmpd = tmpd + du1(l)*rl2d
          else
            call popreal8(rl2)
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rl1)
            y1d = rl1d
          else
            call popreal8(rl1)
            y1d = 0.0_8
          end if
          temp0 = sign(max4, du1(l))
          tempd0 = -(du2(l)*y1d/temp0**2)
          du2d(l) = du2d(l) + y1d/temp0
          max4d = sign(1.d0, max4*du1(l))*tempd0
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max4)
            x3d = 0.0_8
          else
            call popreal8(max4)
            x3d = max4d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            du1d(l) = du1d(l) + x3d
          else
            du1d(l) = du1d(l) - x3d
          end if
          call popreal8(tmp)
          temp = sign(max2, du2(l))
          tempd = -(one*tmpd/temp**2)
          max2d = sign(1.d0, max2*du2(l))*tempd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max2)
            x1d = 0.0_8
          else
            call popreal8(max2)
            x1d = max2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            du2d(l) = du2d(l) + x1d
          else
            du2d(l) = du2d(l) - x1d
          end if
        end do
      else
        do l=nwint,1,-1
          rr1d = -(opk*du2(l)*rightd(l))
          du2d(l) = du2d(l) + opk*rl2*leftd(l) - opk*rr1*rightd(l)
          rr2d = -(omk*du3(l)*rightd(l))
          du3d(l) = du3d(l) - omk*rr2*rightd(l)
          rightd(l) = 0.0_8
          rl1d = omk*du1(l)*leftd(l)
          du1d(l) = du1d(l) + omk*rl1*leftd(l)
          rl2d = opk*du2(l)*leftd(l)
          leftd(l) = 0.0_8
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rr2d = factminmod*rr2d
          else
            rr2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rr1d = factminmod*rr1d
          else
            rr1d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rl2d = factminmod*rl2d
          else
            rl2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rl1d = factminmod*rl1d
          else
            rl1d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rr2)
            y4d = rr2d
          else
            call popreal8(rr2)
            y4d = 0.0_8
          end if
          temp4 = sign(max7, du3(l))
          tempd8 = -(du2(l)*y4d/temp4**2)
          du2d(l) = du2d(l) + y4d/temp4
          max7d = sign(1.d0, max7*du3(l))*tempd8
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max7)
            x6d = 0.0_8
          else
            call popreal8(max7)
            x6d = max7d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            du3d(l) = du3d(l) + x6d
          else
            du3d(l) = du3d(l) - x6d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rr1)
            du3d(l) = du3d(l) + tmp*rr1d
            tmpd = du3(l)*rr1d
          else
            call popreal8(rr1)
            tmpd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rl2)
            du1d(l) = du1d(l) + tmp*rl2d
            tmpd = tmpd + du1(l)*rl2d
          else
            call popreal8(rl2)
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(rl1)
            y3d = rl1d
          else
            call popreal8(rl1)
            y3d = 0.0_8
          end if
          temp3 = sign(max6, du1(l))
          tempd7 = -(du2(l)*y3d/temp3**2)
          du2d(l) = du2d(l) + y3d/temp3
          max6d = sign(1.d0, max6*du1(l))*tempd7
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max6)
            x5d = 0.0_8
          else
            call popreal8(max6)
            x5d = max6d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            du1d(l) = du1d(l) + x5d
          else
            du1d(l) = du1d(l) - x5d
          end if
          call popreal8(tmp)
          temp2 = sign(max3, du2(l))
          tempd6 = -(one*tmpd/temp2**2)
          max3d = sign(1.d0, max3*du2(l))*tempd6
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max3)
            x2d = 0.0_8
          else
            call popreal8(max3)
            x2d = max3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            du2d(l) = du2d(l) + x2d
          else
            du2d(l) = du2d(l) - x2d
          end if
        end do
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        dvxd = rot(3, 1)*du3d(ivz)
        dvyd = rot(3, 2)*du3d(ivz)
        dvzd = rot(3, 3)*du3d(ivz)
        du3d(ivz) = 0.0_8
        dvxd = dvxd + rot(2, 1)*du3d(ivy)
        dvyd = dvyd + rot(2, 2)*du3d(ivy)
        dvzd = dvzd + rot(2, 3)*du3d(ivy)
        du3d(ivy) = 0.0_8
        dvxd = dvxd + rot(1, 1)*du3d(ivx)
        dvyd = dvyd + rot(1, 2)*du3d(ivx)
        dvzd = dvzd + rot(1, 3)*du3d(ivx)
        du3d(ivx) = 0.0_8
        du3d(ivz) = du3d(ivz) + dvzd
        du3d(ivy) = du3d(ivy) + dvyd
        du3d(ivx) = du3d(ivx) + dvxd
        dvxd = rot(3, 1)*du2d(ivz)
        dvyd = rot(3, 2)*du2d(ivz)
        dvzd = rot(3, 3)*du2d(ivz)
        du2d(ivz) = 0.0_8
        dvxd = dvxd + rot(2, 1)*du2d(ivy)
        dvyd = dvyd + rot(2, 2)*du2d(ivy)
        dvzd = dvzd + rot(2, 3)*du2d(ivy)
        du2d(ivy) = 0.0_8
        dvxd = dvxd + rot(1, 1)*du2d(ivx)
        dvyd = dvyd + rot(1, 2)*du2d(ivx)
        dvzd = dvzd + rot(1, 3)*du2d(ivx)
        du2d(ivx) = 0.0_8
        du2d(ivz) = du2d(ivz) + dvzd
        du2d(ivy) = du2d(ivy) + dvyd
        du2d(ivx) = du2d(ivx) + dvxd
        dvxd = rot(3, 1)*du1d(ivz)
        dvyd = rot(3, 2)*du1d(ivz)
        dvzd = rot(3, 3)*du1d(ivz)
        du1d(ivz) = 0.0_8
        dvxd = dvxd + rot(2, 1)*du1d(ivy)
        dvyd = dvyd + rot(2, 2)*du1d(ivy)
        dvzd = dvzd + rot(2, 3)*du1d(ivy)
        du1d(ivy) = 0.0_8
        dvxd = dvxd + rot(1, 1)*du1d(ivx)
        dvyd = dvyd + rot(1, 2)*du1d(ivx)
        dvzd = dvzd + rot(1, 3)*du1d(ivx)
        du1d(ivx) = 0.0_8
        du1d(ivz) = du1d(ivz) + dvzd
        du1d(ivy) = du1d(ivy) + dvyd
        du1d(ivx) = du1d(ivx) + dvxd
      end if
    end subroutine leftrightstate_b
! store the density flux in the mass flow of the
! appropriate sliding mesh interface.
!      ==================================================================
    subroutine leftrightstate(du1, du2, du3, rotmatrix, left, right)
      implicit none
!
!        local parameter.
!
      real(kind=realtype), parameter :: epslim=1.e-10_realtype
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(:), intent(inout) :: du1, du2, du3
      real(kind=realtype), dimension(:), intent(out) :: left, right
      real(kind=realtype), dimension(:, :, :, :, :), pointer :: &
&     rotmatrix
!
!        local variables.
!
      integer(kind=inttype) :: l
      real(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
      real(kind=realtype), dimension(3, 3) :: rot
      intrinsic abs
      intrinsic max
      intrinsic sign
      intrinsic min
      real(kind=realtype) :: x6
      real(kind=realtype) :: x5
      real(kind=realtype) :: x4
      real(kind=realtype) :: x3
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: max7
      real(kind=realtype) :: max6
      real(kind=realtype) :: max5
      real(kind=realtype) :: max4
      real(kind=realtype) :: max3
      real(kind=realtype) :: max2
      real(kind=realtype) :: y4
      real(kind=realtype) :: y3
      real(kind=realtype) :: y2
      real(kind=realtype) :: y1
! check if the velocity components should be transformed to
! the cylindrical frame.
      if (rotationalperiodic) then
! store the rotation matrix a bit easier. note that the i,j,k
! come from the main subroutine.
        rot(1, 1) = rotmatrix(i, j, k, 1, 1)
        rot(1, 2) = rotmatrix(i, j, k, 1, 2)
        rot(1, 3) = rotmatrix(i, j, k, 1, 3)
        rot(2, 1) = rotmatrix(i, j, k, 2, 1)
        rot(2, 2) = rotmatrix(i, j, k, 2, 2)
        rot(2, 3) = rotmatrix(i, j, k, 2, 3)
        rot(3, 1) = rotmatrix(i, j, k, 3, 1)
        rot(3, 2) = rotmatrix(i, j, k, 3, 2)
        rot(3, 3) = rotmatrix(i, j, k, 3, 3)
! apply the transformation to the velocity components
! of du1, du2 and du3.
        dvx = du1(ivx)
        dvy = du1(ivy)
        dvz = du1(ivz)
        du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du2(ivx)
        dvy = du2(ivy)
        dvz = du2(ivz)
        du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
        dvx = du3(ivx)
        dvy = du3(ivy)
        dvz = du3(ivz)
        du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
        du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
        du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
      end if
! determine the limiter used.
      select case  (limused)
      case (nolimiter)
! linear interpolation; no limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          left(l) = omk*du1(l) + opk*du2(l)
          right(l) = -(omk*du3(l)) - opk*du2(l)
        end do
      case (vanalbeda)
!          ==============================================================
! nonlinear interpolation using the van albeda limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x1 = du2(l)
          else
            x1 = -du2(l)
          end if
          if (x1 .lt. epslim) then
            max2 = epslim
          else
            max2 = x1
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max2, du2(l))
          if (du1(l) .ge. 0.) then
            x3 = du1(l)
          else
            x3 = -du1(l)
          end if
          if (x3 .lt. epslim) then
            max4 = epslim
          else
            max4 = x3
          end if
          y1 = du2(l)/sign(max4, du1(l))
          if (zero .lt. y1) then
            rl1 = y1
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x4 = du3(l)
          else
            x4 = -du3(l)
          end if
          if (x4 .lt. epslim) then
            max5 = epslim
          else
            max5 = x4
          end if
          y2 = du2(l)/sign(max5, du3(l))
          if (zero .lt. y2) then
            rr2 = y2
          else
            rr2 = zero
          end if
! compute the corresponding limiter values.
          rl1 = rl1*(rl1+one)/(rl1*rl1+one)
          rl2 = rl2*(rl2+one)/(rl2*rl2+one)
          rr1 = rr1*(rr1+one)/(rr1*rr1+one)
          rr2 = rr2*(rr2+one)/(rr2*rr2+one)
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      case (minmod)
!          ==============================================================
! nonlinear interpolation using the minmod limiter.
! loop over the number of variables to be interpolated.
        do l=1,nwint
          if (du2(l) .ge. 0.) then
            x2 = du2(l)
          else
            x2 = -du2(l)
          end if
          if (x2 .lt. epslim) then
            max3 = epslim
          else
            max3 = x2
          end if
! compute the limiter argument rl1, rl2, rr1 and rr2.
! note the cut off to 0.0.
          tmp = one/sign(max3, du2(l))
          if (du1(l) .ge. 0.) then
            x5 = du1(l)
          else
            x5 = -du1(l)
          end if
          if (x5 .lt. epslim) then
            max6 = epslim
          else
            max6 = x5
          end if
          y3 = du2(l)/sign(max6, du1(l))
          if (zero .lt. y3) then
            rl1 = y3
          else
            rl1 = zero
          end if
          if (zero .lt. du1(l)*tmp) then
            rl2 = du1(l)*tmp
          else
            rl2 = zero
          end if
          if (zero .lt. du3(l)*tmp) then
            rr1 = du3(l)*tmp
          else
            rr1 = zero
          end if
          if (du3(l) .ge. 0.) then
            x6 = du3(l)
          else
            x6 = -du3(l)
          end if
          if (x6 .lt. epslim) then
            max7 = epslim
          else
            max7 = x6
          end if
          y4 = du2(l)/sign(max7, du3(l))
          if (zero .lt. y4) then
            rr2 = y4
          else
            rr2 = zero
          end if
          if (one .gt. factminmod*rl1) then
            rl1 = factminmod*rl1
          else
            rl1 = one
          end if
          if (one .gt. factminmod*rl2) then
            rl2 = factminmod*rl2
          else
            rl2 = one
          end if
          if (one .gt. factminmod*rr1) then
            rr1 = factminmod*rr1
          else
            rr1 = one
          end if
          if (one .gt. factminmod*rr2) then
            rr2 = factminmod*rr2
          else
            rr2 = one
          end if
! compute the nonlinear corrections to the first order
! scheme.
          left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
          right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
        end do
      end select
! in case only a first order scheme must be used for the
! turbulent transport equations, set the correction for the
! turbulent kinetic energy to 0.
      if (firstorderk) then
        left(itu1) = zero
        right(itu1) = zero
      end if
! for rotational periodic problems transform the velocity
! differences back to cartesian again. note that now the
! transpose of the rotation matrix must be used.
      if (rotationalperiodic) then
! left state.
        dvx = left(ivx)
        dvy = left(ivy)
        dvz = left(ivz)
        left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
! right state.
        dvx = right(ivx)
        dvy = right(ivy)
        dvz = right(ivz)
        right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
        right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
        right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
      end if
    end subroutine leftrightstate
!  differentiation of riemannflux in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: flux left right
!   with respect to varying inputs: sx sy sz flux left right
!        ================================================================
    subroutine riemannflux_b(left, leftd, right, rightd, flux, fluxd)
      implicit none
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(*), intent(in) :: left, right
      real(kind=realtype), dimension(*) :: leftd, rightd
      real(kind=realtype), dimension(*) :: flux
      real(kind=realtype), dimension(*) :: fluxd
!
!        local variables.
!
      real(kind=realtype) :: porflux, rface
      real(kind=realtype) :: rfaced
      real(kind=realtype) :: etl, etr, z1l, z1r, tmp
      real(kind=realtype) :: etld, etrd, z1ld, z1rd, tmpd
      real(kind=realtype) :: dr, dru, drv, drw, dre, drk
      real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
      real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
      real(kind=realtype) :: uavgd, vavgd, wavgd, havgd, kavgd
      real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
      real(kind=realtype) :: alphaavgd, a2avgd, aavgd, unavgd
      real(kind=realtype) :: ovaavg, ova2avg, area, eta
      real(kind=realtype) :: ovaavgd, ova2avgd, aread, etad
      real(kind=realtype) :: gm1, gm53
      real(kind=realtype) :: lam1, lam2, lam3
      real(kind=realtype) :: lam1d, lam2d, lam3d
      real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
      real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
&     abv7d
      real(kind=realtype), dimension(2) :: ktmp
      real(kind=realtype), dimension(2) :: ktmpd
      intrinsic sqrt
      intrinsic max
      intrinsic abs
      integer :: branch
      real(kind=realtype) :: tempd14
      real(kind=realtype) :: temp2
      real(kind=realtype) :: tempd13
      real(kind=realtype) :: temp1
      real(kind=realtype) :: tempd12
      real(kind=realtype) :: temp0
      real(kind=realtype) :: tempd11
      real(kind=realtype) :: tempd10
      real(kind=realtype) :: abs1d
      real(kind=realtype) :: max2d
      real(kind=realtype) :: x2
      real(kind=realtype) :: x2d
      real(kind=realtype) :: x1
      real(kind=realtype) :: tempd9
      real(kind=realtype) :: tempd
      real(kind=realtype) :: tempd8
      real(kind=realtype) :: tempd7
      real(kind=realtype) :: tempd6
      real(kind=realtype) :: tempd5
      real(kind=realtype) :: tempd4
      real(kind=realtype) :: tempd3
      real(kind=realtype) :: tempd2
      real(kind=realtype) :: tempd1
      real(kind=realtype) :: tempd0
      real(kind=realtype) :: x1d
      real(kind=realtype) :: abs2
      real(kind=realtype) :: abs2d
      real(kind=realtype) :: abs1
      real(kind=realtype) :: temp
      real(kind=realtype) :: max2
      real(kind=realtype) :: tempd19
      real(kind=realtype) :: tempd18
      real(kind=realtype) :: tempd17
      real(kind=realtype) :: tempd16
      real(kind=realtype) :: tempd15
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
      porflux = half*rfil
      if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
      gm1 = gammaface - one
      gm53 = gammaface - five*third
! determine which riemann solver must be solved.
      select case  (riemannused)
      case (roe)
! determine the preconditioner used.
        select case  (precond)
        case (noprecond)
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
          z1l = sqrt(left(irho))
          z1r = sqrt(right(irho))
          tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
          if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
            ktmp(1) = left(itu1)
            ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
            drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
            kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
            drk = 0.0
            kavg = 0.0
          end if
! compute the total energy of the left and right state.
          call pushreal8(etl)
          call etot(left(irho), left(ivx), left(ivy), left(ivz), left(&
&             irhoe), ktmp(1), etl, correctfork)
          call pushreal8(etr)
          call etot(right(irho), right(ivx), right(ivy), right(ivz), &
&             right(irhoe), ktmp(2), etr, correctfork)
! compute the difference of the conservative mean
! flow variables.
          dr = right(irho) - left(irho)
          dru = right(irho)*right(ivx) - left(irho)*left(ivx)
          drv = right(irho)*right(ivy) - left(irho)*left(ivy)
          drw = right(irho)*right(ivz) - left(irho)*left(ivz)
          dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
          uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
          vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
          wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
          havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            max2 = area
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            max2 = 1.e-25_realtype
          end if
          tmp = one/max2
          call pushreal8(sx)
          sx = sx*tmp
          call pushreal8(sy)
          sy = sy*tmp
          call pushreal8(sz)
          sz = sz*tmp
          rface = sface*tmp
! compute some dependent variables at the roe
! average state.
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
            a2avg = gm1*(havg-alphaavg) - gm53*kavg
            call pushcontrol1b(0)
          else
            a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
            call pushcontrol1b(1)
          end if
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
          if (por .eq. boundflux) then
            unavg = rface
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
          x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&           left(ivz)-right(ivz))*sz
          if (x1 .ge. 0.) then
            abs1 = x1
            call pushcontrol1b(1)
          else
            abs1 = -x1
            call pushcontrol1b(0)
          end if
          x2 = sqrt(gammaface*left(irhoe)/left(irho)) - sqrt(gammaface*&
&           right(irhoe)/right(irho))
          if (x2 .ge. 0.) then
            abs2 = x2
            call pushcontrol1b(0)
          else
            abs2 = -x2
            call pushcontrol1b(1)
          end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
          eta = half*(abs1+abs2)
          if (unavg - rface + aavg .ge. 0.) then
            lam1 = unavg - rface + aavg
            call pushcontrol1b(0)
          else
            lam1 = -(unavg-rface+aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - rface - aavg .ge. 0.) then
            lam2 = unavg - rface - aavg
            call pushcontrol1b(0)
          else
            lam2 = -(unavg-rface-aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - rface .ge. 0.) then
            lam3 = unavg - rface
            call pushcontrol1b(0)
          else
            lam3 = -(unavg-rface)
            call pushcontrol1b(1)
          end if
! apply the entropy correction to the eigenvalues.
          tmp = two*eta
          if (lam1 .lt. tmp) then
            call pushreal8(lam1)
            lam1 = eta + fourth*lam1*lam1/eta
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
          end if
          if (lam2 .lt. tmp) then
            call pushreal8(lam2)
            lam2 = eta + fourth*lam2*lam2/eta
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
          end if
          if (lam3 .lt. tmp) then
            call pushreal8(lam3)
            lam3 = eta + fourth*lam3*lam3/eta
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          call pushreal8(lam1)
          lam1 = lam1*area
          call pushreal8(lam2)
          lam2 = lam2*area
          call pushreal8(lam3)
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
          tempd14 = -(porflux*fluxd(irhoe))
          havgd = abv6*tempd14
          fluxd(irhoe) = 0.0_8
          tempd15 = -(porflux*fluxd(imz))
          fluxd(imz) = 0.0_8
          tempd18 = -(porflux*fluxd(imy))
          fluxd(imy) = 0.0_8
          tempd16 = -(porflux*fluxd(imx))
          abv7d = sz*tempd15 + sx*tempd16 + sy*tempd18 + unavg*tempd14
          fluxd(imx) = 0.0_8
          tempd17 = -(porflux*fluxd(irho))
          abv6d = wavg*tempd15 + uavg*tempd16 + tempd17 + vavg*tempd18 +&
&           havg*tempd14
          fluxd(irho) = 0.0_8
          abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
          abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
          ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
          abv3d = ova2avg*abv4*abv6d + abv5*abv7d
          lam3d = drw*tempd15 + dru*tempd16 - abv3d + dr*tempd17 + drv*&
&           tempd18 + dre*tempd14
          abv5d = ovaavg*abv2*abv6d + abv3*abv7d
          unavgd = abv7*tempd14 - dr*abv5d
          szd = drw*abv5d + abv7*tempd15
          syd = drv*abv5d + abv7*tempd18
          sxd = dru*abv5d + abv7*tempd16
          ova2avgd = abv3*abv4*abv6d
          tempd19 = gm1*abv4d
          dred = tempd19 + lam3*tempd14
          drwd = sz*abv5d - wavg*tempd19 + lam3*tempd15
          wavgd = abv6*tempd15 - drw*tempd19
          drvd = sy*abv5d - vavg*tempd19 + lam3*tempd18
          vavgd = abv6*tempd18 - drv*tempd19
          drud = sx*abv5d - uavg*tempd19 + lam3*tempd16
          uavgd = abv6*tempd16 - dru*tempd19
          drd = alphaavg*tempd19 - unavg*abv5d + lam3*tempd17
          alphaavgd = dr*tempd19
          drkd = -(gm53*abv4d)
          abv1d = abv3d
          lam1d = half*abv1d + half*abv2d
          lam2d = half*abv1d - half*abv2d
          call popreal8(lam3)
          call popreal8(lam2)
          call popreal8(lam1)
          aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
          lam3d = area*lam3d
          lam2d = area*lam2d
          lam1d = area*lam1d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam3)
            tempd13 = fourth*lam3d/eta
            etad = lam3d - lam3**2*tempd13/eta
            lam3d = 2*lam3*tempd13
          else
            etad = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam2)
            tempd12 = fourth*lam2d/eta
            etad = etad + lam2d - lam2**2*tempd12/eta
            lam2d = 2*lam2*tempd12
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam1)
            tempd11 = fourth*lam1d/eta
            etad = etad + lam1d - lam1**2*tempd11/eta
            lam1d = 2*lam1*tempd11
          end if
          tmp = one/max2
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam3d
            rfaced = -lam3d
          else
            rfaced = lam3d
            unavgd = unavgd - lam3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam2d
            rfaced = rfaced - lam2d
            aavgd = -lam2d
          else
            rfaced = rfaced + lam2d
            unavgd = unavgd - lam2d
            aavgd = lam2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam1d
            rfaced = rfaced - lam1d
            aavgd = aavgd + lam1d
          else
            rfaced = rfaced + lam1d
            unavgd = unavgd - lam1d
            aavgd = aavgd - lam1d
          end if
          abs1d = half*etad
          abs2d = half*etad
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x2d = abs2d
          else
            x2d = -abs2d
          end if
          temp1 = left(irhoe)/left(irho)
          if (gammaface*temp1 .eq. 0.0_8) then
            tempd9 = 0.0
          else
            tempd9 = gammaface*x2d/(2.0*sqrt(gammaface*temp1)*left(irho)&
&             )
          end if
          temp2 = right(irhoe)/right(irho)
          if (gammaface*temp2 .eq. 0.0_8) then
            tempd10 = 0.0
          else
            tempd10 = -(gammaface*x2d/(2.0*sqrt(gammaface*temp2)*right(&
&             irho)))
          end if
          leftd(irhoe) = leftd(irhoe) + tempd9
          leftd(irho) = leftd(irho) - temp1*tempd9
          rightd(irhoe) = rightd(irhoe) + tempd10
          rightd(irho) = rightd(irho) - temp2*tempd10
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x1d = -abs1d
          else
            x1d = abs1d
          end if
          leftd(ivx) = leftd(ivx) + sx*x1d
          rightd(ivx) = rightd(ivx) - sx*x1d
          sxd = sxd + (left(ivx)-right(ivx))*x1d
          leftd(ivy) = leftd(ivy) + sy*x1d
          rightd(ivy) = rightd(ivy) - sy*x1d
          syd = syd + (left(ivy)-right(ivy))*x1d
          leftd(ivz) = leftd(ivz) + sz*x1d
          rightd(ivz) = rightd(ivz) - sz*x1d
          szd = szd + (left(ivz)-right(ivz))*x1d
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            rfaced = rfaced + unavgd
            unavgd = 0.0_8
          end if
          aavgd = aavgd - one*ovaavgd/aavg**2
          if (a2avg .eq. 0.0_8) then
            a2avgd = -(one*ova2avgd/a2avg**2)
          else
            a2avgd = aavgd/(2.0*sqrt(a2avg)) - one*ova2avgd/a2avg**2
          end if
          uavgd = uavgd + sx*unavgd
          sxd = sxd + uavg*unavgd
          vavgd = vavgd + sy*unavgd
          syd = syd + vavg*unavgd
          wavgd = wavgd + sz*unavgd
          szd = szd + wavg*unavgd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            havgd = havgd + gm1*a2avgd
            alphaavgd = alphaavgd - gm1*a2avgd
            kavgd = -(gm53*a2avgd)
          else
            kavgd = gm53*a2avgd
            havgd = havgd - gm1*a2avgd
            alphaavgd = alphaavgd + gm1*a2avgd
          end if
          call popreal8(sz)
          call popreal8(sy)
          call popreal8(sx)
          tempd8 = half*alphaavgd
          uavgd = uavgd + 2*uavg*tempd8
          vavgd = vavgd + 2*vavg*tempd8
          wavgd = wavgd + 2*wavg*tempd8
          tmpd = sz*szd + sx*sxd + sy*syd + sface*rfaced
          szd = tmp*szd
          syd = tmp*syd
          sxd = tmp*sxd
          max2d = -(one*tmpd/max2**2)
          tmp = one/(z1l+z1r)
          call popcontrol1b(branch)
          if (branch .eq. 0) aread = aread + max2d
          tempd6 = tmp*uavgd
          tempd7 = tmp*vavgd
          tempd5 = tmp*wavgd
          if (sx**2 + sy**2 + sz**2 .eq. 0.0_8) then
            tempd1 = 0.0
          else
            tempd1 = aread/(2.0*sqrt(sx**2+sy**2+sz**2))
          end if
          sxd = sxd + 2*sx*tempd1
          syd = syd + 2*sy*tempd1
          szd = szd + 2*sz*tempd1
          temp0 = (etr+right(irhoe))/z1r
          temp = (etl+left(irhoe))/z1l
          tempd2 = tmp*havgd
          tempd3 = tempd2/z1l
          tempd4 = tempd2/z1r
          tmpd = (z1l*left(ivz)+z1r*right(ivz))*wavgd + (z1l*left(ivx)+&
&           z1r*right(ivx))*uavgd + (z1l*left(ivy)+z1r*right(ivy))*vavgd&
&           + (temp+temp0)*havgd
          etld = tempd3 - dred
          leftd(irhoe) = leftd(irhoe) + tempd3
          z1ld = left(ivz)*tempd5 + left(ivx)*tempd6 + left(ivy)*tempd7 &
&           - temp*tempd3
          etrd = dred + tempd4
          rightd(irhoe) = rightd(irhoe) + tempd4
          z1rd = right(ivz)*tempd5 + right(ivx)*tempd6 + right(ivy)*&
&           tempd7 - temp0*tempd4
          leftd(ivz) = leftd(ivz) + z1l*tempd5
          rightd(ivz) = rightd(ivz) + z1r*tempd5
          leftd(ivy) = leftd(ivy) + z1l*tempd7
          rightd(ivy) = rightd(ivy) + z1r*tempd7
          leftd(ivx) = leftd(ivx) + z1l*tempd6
          rightd(ivx) = rightd(ivx) + z1r*tempd6
          rightd(irho) = rightd(irho) + right(ivz)*drwd
          rightd(ivz) = rightd(ivz) + right(irho)*drwd
          leftd(irho) = leftd(irho) - left(ivz)*drwd
          leftd(ivz) = leftd(ivz) - left(irho)*drwd
          rightd(irho) = rightd(irho) + right(ivy)*drvd
          rightd(ivy) = rightd(ivy) + right(irho)*drvd
          leftd(irho) = leftd(irho) - left(ivy)*drvd
          leftd(ivy) = leftd(ivy) - left(irho)*drvd
          rightd(irho) = rightd(irho) + right(ivx)*drud
          rightd(ivx) = rightd(ivx) + right(irho)*drud
          leftd(irho) = leftd(irho) - left(ivx)*drud
          leftd(ivx) = leftd(ivx) - left(irho)*drud
          rightd(irho) = rightd(irho) + drd
          leftd(irho) = leftd(irho) - drd
          call popreal8(etr)
          ktmpd = 0.0_8
          call etot_b(right(irho), rightd(irho), right(ivx), rightd(ivx)&
&               , right(ivy), rightd(ivy), right(ivz), rightd(ivz), &
&               right(irhoe), rightd(irhoe), ktmp(2), ktmpd(2), etr, &
&               etrd, correctfork)
          call popreal8(etl)
          call etot_b(left(irho), leftd(irho), left(ivx), leftd(ivx), &
&               left(ivy), leftd(ivy), left(ivz), leftd(ivz), left(irhoe&
&               ), leftd(irhoe), ktmp(1), ktmpd(1), etl, etld, &
&               correctfork)
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            tempd0 = tmp*kavgd
            tmpd = tmpd + (z1l*left(itu1)+z1r*right(itu1))*kavgd
            z1ld = z1ld + left(itu1)*tempd0
            leftd(itu1) = leftd(itu1) + z1l*tempd0
            z1rd = z1rd + right(itu1)*tempd0
            rightd(itu1) = rightd(itu1) + z1r*tempd0
            rightd(irho) = rightd(irho) + right(itu1)*drkd
            rightd(itu1) = rightd(itu1) + ktmpd(2) + right(irho)*drkd
            leftd(irho) = leftd(irho) - left(itu1)*drkd
            ktmpd(2) = 0.0_8
            leftd(itu1) = leftd(itu1) + ktmpd(1) - left(irho)*drkd
          end if
          tempd = -(one*tmpd/(z1l+z1r)**2)
          z1ld = z1ld + tempd
          z1rd = z1rd + tempd
          if (.not.right(irho) .eq. 0.0_8) rightd(irho) = rightd(irho) +&
&             z1rd/(2.0*sqrt(right(irho)))
          if (.not.left(irho) .eq. 0.0_8) leftd(irho) = leftd(irho) + &
&             z1ld/(2.0*sqrt(left(irho)))
        case (turkel)
          sxd = 0.0_8
          syd = 0.0_8
          szd = 0.0_8
        case (choimerkle)
          sxd = 0.0_8
          syd = 0.0_8
          szd = 0.0_8
        case default
          sxd = 0.0_8
          syd = 0.0_8
          szd = 0.0_8
        end select
      case (vanleer)
        sxd = 0.0_8
        syd = 0.0_8
        szd = 0.0_8
      case (ausmdv)
        sxd = 0.0_8
        syd = 0.0_8
        szd = 0.0_8
      case default
        sxd = 0.0_8
        syd = 0.0_8
        szd = 0.0_8
      end select
    end subroutine riemannflux_b
!        ================================================================
    subroutine riemannflux(left, right, flux)
      implicit none
!
!        subroutine arguments.
!
      real(kind=realtype), dimension(*), intent(in) :: left, right
      real(kind=realtype), dimension(*), intent(out) :: flux
!
!        local variables.
!
      real(kind=realtype) :: porflux, rface
      real(kind=realtype) :: etl, etr, z1l, z1r, tmp
      real(kind=realtype) :: dr, dru, drv, drw, dre, drk
      real(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
      real(kind=realtype) :: alphaavg, a2avg, aavg, unavg
      real(kind=realtype) :: ovaavg, ova2avg, area, eta
      real(kind=realtype) :: gm1, gm53
      real(kind=realtype) :: lam1, lam2, lam3
      real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
      real(kind=realtype), dimension(2) :: ktmp
      intrinsic sqrt
      intrinsic max
      intrinsic abs
      real(kind=realtype) :: x2
      real(kind=realtype) :: x1
      real(kind=realtype) :: abs2
      real(kind=realtype) :: abs1
      real(kind=realtype) :: max2
! set the porosity for the flux. the default value, 0.5*rfil, is
! a scaling factor where an rfil != 1 is taken into account.
      porflux = half*rfil
      if (por .eq. noflux .or. por .eq. boundflux) porflux = zero
! abbreviate some expressions in which gamma occurs.
      gm1 = gammaface - one
      gm53 = gammaface - five*third
! determine which riemann solver must be solved.
      select case  (riemannused)
      case (roe)
! determine the preconditioner used.
        select case  (precond)
        case (noprecond)
! no preconditioner used. use the roe scheme of the
! standard equations.
! compute the square root of the left and right densities
! and the inverse of the sum.
          z1l = sqrt(left(irho))
          z1r = sqrt(right(irho))
          tmp = one/(z1l+z1r)
! compute some variables depending whether or not a
! k-equation is present.
          if (correctfork) then
! store the left and right kinetic energy in ktmp,
! which is needed to compute the total energy.
            ktmp(1) = left(itu1)
            ktmp(2) = right(itu1)
! store the difference of the turbulent kinetic energy
! per unit volume, i.e. the conserved variable.
            drk = right(irho)*right(itu1) - left(irho)*left(itu1)
! compute the average turbulent energy per unit mass
! using roe averages.
            kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
          else
! set the difference of the turbulent kinetic energy
! per unit volume and the averaged kinetic energy per
! unit mass to zero.
            drk = 0.0
            kavg = 0.0
          end if
! compute the total energy of the left and right state.
          call etot(left(irho), left(ivx), left(ivy), left(ivz), left(&
&             irhoe), ktmp(1), etl, correctfork)
          call etot(right(irho), right(ivx), right(ivy), right(ivz), &
&             right(irhoe), ktmp(2), etr, correctfork)
! compute the difference of the conservative mean
! flow variables.
          dr = right(irho) - left(irho)
          dru = right(irho)*right(ivx) - left(irho)*left(ivx)
          drv = right(irho)*right(ivy) - left(irho)*left(ivy)
          drw = right(irho)*right(ivz) - left(irho)*left(ivz)
          dre = etr - etl
! compute the roe average variables, which can be
! computed directly from the average roe vector.
          ravg = fourth*(z1r+z1l)**2
          uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
          vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
          wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
          havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
! compute the unit vector and store the area of the
! normal. also compute the unit normal velocity of the face.
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            max2 = area
          else
            max2 = 1.e-25_realtype
          end if
          tmp = one/max2
          sx = sx*tmp
          sy = sy*tmp
          sz = sz*tmp
          rface = sface*tmp
! compute some dependent variables at the roe
! average state.
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          if (gm1*(havg-alphaavg) - gm53*kavg .ge. 0.) then
            a2avg = gm1*(havg-alphaavg) - gm53*kavg
          else
            a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
          end if
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! set for a boundary the normal velocity to rface, the
! normal velocity of the boundary.
          if (por .eq. boundflux) unavg = rface
          x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
&           left(ivz)-right(ivz))*sz
          if (x1 .ge. 0.) then
            abs1 = x1
          else
            abs1 = -x1
          end if
          x2 = sqrt(gammaface*left(irhoe)/left(irho)) - sqrt(gammaface*&
&           right(irhoe)/right(irho))
          if (x2 .ge. 0.) then
            abs2 = x2
          else
            abs2 = -x2
          end if
! compute the coefficient eta for the entropy correction.
! at the moment a 1d entropy correction is used, which
! removes expansion shocks. although it also reduces the
! carbuncle phenomenon, it does not remove it completely.
! in other to do that a multi-dimensional entropy fix is
! needed, see sanders et. al, jcp, vol. 145, 1998,
! pp. 511 - 537. although relatively easy to implement,
! an efficient implementation requires the storage of
! all the left and right states, which is rather
! expensive in terms of memory.
          eta = half*(abs1+abs2)
          if (unavg - rface + aavg .ge. 0.) then
            lam1 = unavg - rface + aavg
          else
            lam1 = -(unavg-rface+aavg)
          end if
          if (unavg - rface - aavg .ge. 0.) then
            lam2 = unavg - rface - aavg
          else
            lam2 = -(unavg-rface-aavg)
          end if
          if (unavg - rface .ge. 0.) then
            lam3 = unavg - rface
          else
            lam3 = -(unavg-rface)
          end if
! apply the entropy correction to the eigenvalues.
          tmp = two*eta
          if (lam1 .lt. tmp) lam1 = eta + fourth*lam1*lam1/eta
          if (lam2 .lt. tmp) lam2 = eta + fourth*lam2*lam2/eta
          if (lam3 .lt. tmp) lam3 = eta + fourth*lam3*lam3/eta
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1 = lam1*area
          lam2 = lam2*area
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute the dissipation term, -|a| (wr - wl), which is
! multiplied by porflux. note that porflux is either
! 0.0 or 0.5*rfil.
          flux(irho) = -(porflux*(lam3*dr+abv6))
          flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
          flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
          flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
          flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
        case (turkel)
!          tmp = max(lam1,lam2,lam3)
!          flux(irho)  = -porflux*(tmp*dr)
!          flux(imx)   = -porflux*(tmp*dru)
!          flux(imy)   = -porflux*(tmp*drv)
!          flux(imz)   = -porflux*(tmp*drw)
!          flux(irhoe) = -porflux*(tmp*dre)
          call terminate('riemannflux', &
&                  'turkel preconditioner not implemented yet')
        case (choimerkle)
          call terminate('riemannflux', &
&                  'choi merkle preconditioner not implemented yet')
        end select
      case (vanleer)
        call terminate('riemannflux', 'van leer fvs not implemented yet'&
&               )
      case (ausmdv)
        call terminate('riemannflux', 'ausmdv fvs not implemented yet')
      end select
    end subroutine riemannflux
  end subroutine inviscidupwindflux_b
!  differentiation of viscousflux in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *x *si *sj *sk *fw *(*viscsubface.tau)
!   with respect to varying inputs: *rev *aa *wx *wy *wz *w *rlv
!                *x *qx *qy *qz *ux *uy *uz *si *sj *sk *vx *vy
!                *vz *fw *(*viscsubface.tau)
!   rw status of diff variables: *rev:out *aa:out *wx:out *wy:out
!                *wz:out *w:incr *rlv:out *x:incr *qx:out *qy:out
!                *qz:out *ux:out *uy:out *uz:out *si:incr *sj:incr
!                *sk:incr *vx:out *vy:out *vz:out *fw:in-out *(*viscsubface.tau):in-out
!   plus diff mem management of: rev:in aa:in wx:in wy:in wz:in
!                w:in rlv:in x:in qx:in qy:in qz:in ux:in uy:in
!                uz:in si:in sj:in sk:in vx:in vy:in vz:in fw:in
!                viscsubface:in *viscsubface.tau:in
  subroutine viscousflux_b()
!
!       viscousflux computes the viscous fluxes using a central
!       difference scheme for a block.
!       it is assumed that the pointers in block pointer already point
!       to the correct block.
!
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! possibly correct the wall shear stress.
! wall function is not aded
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype), parameter :: xminn=1.e-14_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: muld, mued, mutd, heatcoefd
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, &
&   w_yd, w_zd
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: corrd, ssxd, ssyd, sszd, ssd, fracdivd
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxxd, tauyyd, tauzzd
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxyd, tauxzd, tauyzd
    real(kind=realtype) :: tauxxs, tauyys, tauzzs
    real(kind=realtype) :: tauxxsd, tauyysd, tauzzsd
    real(kind=realtype) :: tauxys, tauxzs, tauyzs
    real(kind=realtype) :: tauxysd, tauxzsd, tauyzsd
    real(kind=realtype) :: exx, eyy, ezz
    real(kind=realtype) :: exxd, eyyd, ezzd
    real(kind=realtype) :: exy, exz, eyz
    real(kind=realtype) :: exyd, exzd, eyzd
    real(kind=realtype) :: wxy, wxz, wyz, wyx, wzx, wzy
    real(kind=realtype) :: wxyd, wxzd, wyzd, wyxd, wzxd, wzyd
    real(kind=realtype) :: den, ccr1, fact
    real(kind=realtype) :: dend, factd
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    real(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
    logical :: correctfork, storewalltensor
    intrinsic abs
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    integer :: branch
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp1
    real(kind=realtype) :: tempd49
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd48
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd47
    real(kind=realtype) :: tempd46
    real(kind=realtype) :: tempd45
    real(kind=realtype) :: tempd44
    real(kind=realtype) :: tempd43
    real(kind=realtype) :: tempd42
    real(kind=realtype) :: tempd79
    real(kind=realtype) :: tempd41
    real(kind=realtype) :: tempd78
    real(kind=realtype) :: tempd40
    real(kind=realtype) :: tempd77
    real(kind=realtype) :: tempd76
    real(kind=realtype) :: tempd75
    real(kind=realtype) :: tempd74
    real(kind=realtype) :: tempd73
    real(kind=realtype) :: tempd72
    real(kind=realtype) :: tempd71
    real(kind=realtype) :: tempd70
    real(kind=realtype) :: tempd39
    real(kind=realtype) :: tempd38
    real(kind=realtype) :: tempd37
    real(kind=realtype) :: tempd36
    real(kind=realtype) :: tempd35
    real(kind=realtype) :: tempd34
    real(kind=realtype) :: tempd33
    real(kind=realtype) :: tempd32
    real(kind=realtype) :: tempd69
    real(kind=realtype) :: tempd31
    real(kind=realtype) :: tempd68
    real(kind=realtype) :: tempd30
    real(kind=realtype) :: tempd67
    real(kind=realtype) :: tempd66
    real(kind=realtype) :: tempd65
    real(kind=realtype) :: tempd64
    real(kind=realtype) :: tempd63
    real(kind=realtype) :: tempd62
    real(kind=realtype) :: tempd61
    real(kind=realtype) :: tempd60
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd29
    real(kind=realtype) :: tempd28
    real(kind=realtype) :: tempd27
    real(kind=realtype) :: tempd26
    real(kind=realtype) :: tempd25
    real(kind=realtype) :: tempd24
    real(kind=realtype) :: tempd23
    real(kind=realtype) :: tempd22
    real(kind=realtype) :: tempd59
    real(kind=realtype) :: tempd21
    real(kind=realtype) :: tempd58
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: tempd57
    real(kind=realtype) :: tempd56
    real(kind=realtype) :: tempd55
    real(kind=realtype) :: tempd54
    real(kind=realtype) :: tempd53
    real(kind=realtype) :: tempd52
    real(kind=realtype) :: tempd51
    real(kind=realtype) :: tempd50
    real(kind=realtype) :: abs0
    real(kind=realtype) :: tempd82
    real(kind=realtype) :: tempd81
    real(kind=realtype) :: tempd80
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: tempd15
    real(kind=realtype) :: temp4
! set qcr parameters
    ccr1 = 0.3_realtype
! set rfilv to rfil to indicate that this is the viscous part.
! if rfilv == 0 the viscous residuals need not to be computed
! and a return can be made.
    rfilv = rfil
    if (rfilv .ge. 0.) then
      abs0 = rfilv
    else
      abs0 = -rfilv
    end if
    if (abs0 .lt. thresholdreal) then
      revd = 0.0_8
      aad = 0.0_8
      wxd = 0.0_8
      wyd = 0.0_8
      wzd = 0.0_8
      rlvd = 0.0_8
      qxd = 0.0_8
      qyd = 0.0_8
      qzd = 0.0_8
      uxd = 0.0_8
      uyd = 0.0_8
      uzd = 0.0_8
      vxd = 0.0_8
      vyd = 0.0_8
      vzd = 0.0_8
    else
! determine whether or not the wall stress tensor and wall heat
! flux must be stored for viscous walls.
      storewalltensor = .false.
      if (wallfunctions) then
        storewalltensor = .true.
      else if (rkstage .eq. 0 .and. currentlevel .eq. groundlevel) then
        storewalltensor = .true.
      end if
      call pushreal8(wxy)
      call pushreal8(ssx)
      call pushreal8(wxz)
      call pushreal8(ssy)
      call pushreal8(ssz)
      call pushreal8(u_x)
      call pushreal8(u_y)
      call pushreal8(tauzz)
      call pushreal8(u_z)
      call pushinteger4(i)
      call pushinteger4(j)
      call pushreal8(tauxzs)
      call pushreal8(w_x)
      call pushreal8(w_y)
      call pushreal8(w_z)
      call pushreal8(corr)
      call pushreal8(wyx)
      call pushreal8(wyz)
      call pushreal8(tauxx)
      call pushreal8(den)
      call pushreal8(tauxy)
      call pushreal8(tauxz)
      call pushreal8(tauzzs)
      call pushreal8(tauyys)
      call pushreal8(q_x)
      call pushreal8(tauxxs)
      call pushreal8(q_y)
      call pushreal8(q_z)
      call pushreal8(wzx)
      call pushreal8(wzy)
      call pushreal8(v_x)
      call pushreal8(v_y)
      call pushreal8(v_z)
      call pushreal8(tauyy)
      call pushreal8(tauyz)
      call pushreal8(mue)
      call pushreal8(ss)
      call pushreal8(tauyzs)
      call pushreal8(fact)
      call pushreal8(por)
      call pushreal8(tauxys)
      call pushreal8(wxy)
      call pushreal8(ssx)
      call pushreal8(wxz)
      call pushreal8(ssy)
      call pushreal8(ssz)
      call pushreal8(u_x)
      call pushreal8(u_y)
      call pushreal8(tauzz)
      call pushreal8(u_z)
      call pushinteger4(i)
      call pushinteger4(j)
      call pushinteger4(k)
      call pushreal8(tauxzs)
      call pushreal8(w_x)
      call pushreal8(w_y)
      call pushreal8(w_z)
      call pushreal8(corr)
      call pushreal8(wyx)
      call pushreal8(wyz)
      call pushreal8(tauxx)
      call pushreal8(den)
      call pushreal8(tauxy)
      call pushreal8(tauxz)
      call pushreal8(tauzzs)
      call pushreal8(tauyys)
      call pushreal8(q_x)
      call pushreal8(tauxxs)
      call pushreal8(q_y)
      call pushreal8(q_z)
      call pushreal8(wzx)
      call pushreal8(wzy)
      call pushreal8(v_x)
      call pushreal8(v_y)
      call pushreal8(v_z)
      call pushreal8(tauyy)
      call pushreal8(tauyz)
      call pushreal8(mue)
      call pushreal8(ss)
      call pushreal8(tauyzs)
      call pushreal8(fact)
      call pushreal8(por)
      call pushreal8(tauxys)
      revd = 0.0_8
      aad = 0.0_8
      wxd = 0.0_8
      wyd = 0.0_8
      wzd = 0.0_8
      rlvd = 0.0_8
      qxd = 0.0_8
      qyd = 0.0_8
      qzd = 0.0_8
      uxd = 0.0_8
      uyd = 0.0_8
      uzd = 0.0_8
      vxd = 0.0_8
      vyd = 0.0_8
      vzd = 0.0_8
      mued = 0.0_8
      mue = zero
      revd = 0.0_8
      aad = 0.0_8
      wxd = 0.0_8
      wyd = 0.0_8
      wzd = 0.0_8
      rlvd = 0.0_8
      qxd = 0.0_8
      qyd = 0.0_8
      qzd = 0.0_8
      uxd = 0.0_8
      uyd = 0.0_8
      uzd = 0.0_8
      vxd = 0.0_8
      vyd = 0.0_8
      vzd = 0.0_8
      mued = 0.0_8
      do ii=0,il*ny*nz-1
        i = mod(ii, il) + 1
        j = mod(ii/il, ny) + 2
        k = ii/(il*ny) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
        por = half*rfilv
        if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
        mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
        if (eddymodel) then
          mue = por*(rev(i, j, k)+rev(i+1, j, k))
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        mut = mul + mue
        gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
        factlamheat = one/(prandtl*gm1)
        factturbheat = one/(prandtlturb*gm1)
        heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
        u_x = fourth*(ux(i, j-1, k-1)+ux(i, j, k-1)+ux(i, j-1, k)+ux(i, &
&         j, k))
        u_y = fourth*(uy(i, j-1, k-1)+uy(i, j, k-1)+uy(i, j-1, k)+uy(i, &
&         j, k))
        u_z = fourth*(uz(i, j-1, k-1)+uz(i, j, k-1)+uz(i, j-1, k)+uz(i, &
&         j, k))
        v_x = fourth*(vx(i, j-1, k-1)+vx(i, j, k-1)+vx(i, j-1, k)+vx(i, &
&         j, k))
        v_y = fourth*(vy(i, j-1, k-1)+vy(i, j, k-1)+vy(i, j-1, k)+vy(i, &
&         j, k))
        v_z = fourth*(vz(i, j-1, k-1)+vz(i, j, k-1)+vz(i, j-1, k)+vz(i, &
&         j, k))
        w_x = fourth*(wx(i, j-1, k-1)+wx(i, j, k-1)+wx(i, j-1, k)+wx(i, &
&         j, k))
        w_y = fourth*(wy(i, j-1, k-1)+wy(i, j, k-1)+wy(i, j-1, k)+wy(i, &
&         j, k))
        w_z = fourth*(wz(i, j-1, k-1)+wz(i, j, k-1)+wz(i, j-1, k)+wz(i, &
&         j, k))
        q_x = fourth*(qx(i, j-1, k-1)+qx(i, j, k-1)+qx(i, j-1, k)+qx(i, &
&         j, k))
        q_y = fourth*(qy(i, j-1, k-1)+qy(i, j, k-1)+qy(i, j-1, k)+qy(i, &
&         j, k))
        q_z = fourth*(qz(i, j-1, k-1)+qz(i, j, k-1)+qz(i, j-1, k)+qz(i, &
&         j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center i to cell center i+1.
        ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j-1&
&         , k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1, 1)+&
&         x(i+1, j, k, 1)-x(i-1, j, k, 1))
        ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j-1&
&         , k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1, 2)+&
&         x(i+1, j, k, 2)-x(i-1, j, k, 2))
        ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j-1&
&         , k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1, 3)+&
&         x(i+1, j, k, 3)-x(i-1, j, k, 3))
! determine the length of this vector and create the
! unit normal.
        ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
        call pushreal8(ssx)
        ssx = ss*ssx
        call pushreal8(ssy)
        ssy = ss*ssy
        call pushreal8(ssz)
        ssz = ss*ssz
! correct the gradients.
        corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j, &
&         k, ivx))*ss
        call pushreal8(u_x)
        u_x = u_x - corr*ssx
        call pushreal8(u_y)
        u_y = u_y - corr*ssy
        call pushreal8(u_z)
        u_z = u_z - corr*ssz
        call pushreal8(corr)
        corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j, &
&         k, ivy))*ss
        call pushreal8(v_x)
        v_x = v_x - corr*ssx
        call pushreal8(v_y)
        v_y = v_y - corr*ssy
        call pushreal8(v_z)
        v_z = v_z - corr*ssz
        call pushreal8(corr)
        corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j, &
&         k, ivz))*ss
        call pushreal8(w_x)
        w_x = w_x - corr*ssx
        call pushreal8(w_y)
        w_y = w_y - corr*ssy
        call pushreal8(w_z)
        w_z = w_z - corr*ssz
        call pushreal8(corr)
        corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i+1, j, k)-aa(i, j, k))&
&         *ss
        call pushreal8(q_x)
        q_x = q_x - corr*ssx
        call pushreal8(q_y)
        q_y = q_y - corr*ssy
        call pushreal8(q_z)
        q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
! we remove the viscosity from the stress tensor (tau)
! to define taus since we still need to separate between
! laminar and turbulent stress for qcr.
! therefore, laminar tau = mue*taus, turbulent
! tau = mue*taus, and total tau = mut*taus.
        fracdiv = twothird*(u_x+v_y+w_z)
        tauxxs = two*u_x - fracdiv
        tauyys = two*v_y - fracdiv
        tauzzs = two*w_z - fracdiv
        tauxys = u_y + v_x
        tauxzs = u_z + w_x
        tauyzs = v_z + w_y
        call pushreal8(q_x)
        q_x = heatcoef*q_x
        call pushreal8(q_y)
        q_y = heatcoef*q_y
        call pushreal8(q_z)
        q_z = heatcoef*q_z
! add qcr corrections if necessary
        if (useqcr) then
! in the qcr formulation, we add an extra term to the turbulent stress tensor:
!
! tau_ij,qcr = tau_ij - e_ij
!
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
!
! remember that the tau_ij in e_ij should use only the eddy viscosity!
! compute denominator
          den = sqrt(u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&           v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z)
          if (den .lt. xminn) then
            den = xminn
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            den = den
          end if
! compute factor that will multiply all tensor components.
! here we add the eddy viscosity that should multiply the stress tensor (tau)
! components as well.
          fact = mue*ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
! the diagonals of the vorticity tensor components are always zero
          wxy = u_y - v_x
          wxz = u_z - w_x
          wyz = v_z - w_y
          wyx = -wxy
          wzx = -wxz
          wzy = -wyz
! compute the extra terms of the boussinesq relation
          exx = fact*(wxy*tauxys+wxz*tauxzs)*two
          eyy = fact*(wyx*tauxys+wyz*tauyzs)*two
          ezz = fact*(wzx*tauxzs+wzy*tauyzs)*two
          exy = fact*(wxy*tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)
          exz = fact*(wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)
          eyz = fact*(wyx*tauxzs+wyz*tauzzs+wzx*tauxys+wzy*tauyys)
! apply the total viscosity to the stress tensor and add extra terms
          tauxx = mut*tauxxs - exx
          tauyy = mut*tauyys - eyy
          tauzz = mut*tauzzs - ezz
          tauxy = mut*tauxys - exy
          tauxz = mut*tauxzs - exz
          tauyz = mut*tauyzs - eyz
          call pushcontrol1b(0)
        else
! just apply the total viscosity to the stress tensor
          tauxx = mut*tauxxs
          tauyy = mut*tauyys
          tauzz = mut*tauzzs
          tauxy = mut*tauxys
          tauxz = mut*tauxzs
          tauyz = mut*tauyzs
          call pushcontrol1b(1)
        end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
        ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
        vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
        wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
! update the residuals of cell i and i+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases i == 1
! and i == il must be tested.
        if (i .eq. 1 .and. storewalltensor .and. visciminpointer(j, k) &
&           .gt. 0) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
! and the i == il case.
        if (i .eq. il .and. storewalltensor .and. viscimaxpointer(j, k) &
&           .gt. 0) then
          tauyzd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 6)
          viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 6) = 0.0_8
          tauxzd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 5)
          viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 5) = 0.0_8
          tauxyd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 4)
          viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 4) = 0.0_8
          tauzzd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 3)
          viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 3) = 0.0_8
          tauyyd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 2)
          viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 2) = 0.0_8
          tauxxd = viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 1)
          viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 1) = 0.0_8
        else
          tauzzd = 0.0_8
          tauxxd = 0.0_8
          tauxyd = 0.0_8
          tauxzd = 0.0_8
          tauyyd = 0.0_8
          tauyzd = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          tauyzd = tauyzd + viscsubfaced(visciminpointer(j, k))%tau(j, k&
&           , 6)
          viscsubfaced(visciminpointer(j, k))%tau(j, k, 6) = 0.0_8
          tauxzd = tauxzd + viscsubfaced(visciminpointer(j, k))%tau(j, k&
&           , 5)
          viscsubfaced(visciminpointer(j, k))%tau(j, k, 5) = 0.0_8
          tauxyd = tauxyd + viscsubfaced(visciminpointer(j, k))%tau(j, k&
&           , 4)
          viscsubfaced(visciminpointer(j, k))%tau(j, k, 4) = 0.0_8
          tauzzd = tauzzd + viscsubfaced(visciminpointer(j, k))%tau(j, k&
&           , 3)
          viscsubfaced(visciminpointer(j, k))%tau(j, k, 3) = 0.0_8
          tauyyd = tauyyd + viscsubfaced(visciminpointer(j, k))%tau(j, k&
&           , 2)
          viscsubfaced(visciminpointer(j, k))%tau(j, k, 2) = 0.0_8
          tauxxd = tauxxd + viscsubfaced(visciminpointer(j, k))%tau(j, k&
&           , 1)
          viscsubfaced(visciminpointer(j, k))%tau(j, k, 1) = 0.0_8
        end if
        frhoed = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
        fmzd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
        fmyd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
        fmxd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
        tempd80 = si(i, j, k, 1)*frhoed
        tempd81 = si(i, j, k, 2)*frhoed
        tempd82 = si(i, j, k, 3)*frhoed
        ubard = tauxz*tempd82 + tauxy*tempd81 + tauxx*tempd80
        tauxxd = tauxxd + si(i, j, k, 1)*fmxd + ubar*tempd80
        vbard = tauyz*tempd82 + tauyy*tempd81 + tauxy*tempd80
        tauxyd = tauxyd + si(i, j, k, 1)*fmyd + si(i, j, k, 2)*fmxd + &
&         ubar*tempd81 + vbar*tempd80
        wbard = tauzz*tempd82 + tauyz*tempd81 + tauxz*tempd80
        tauxzd = tauxzd + si(i, j, k, 1)*fmzd + si(i, j, k, 3)*fmxd + &
&         ubar*tempd82 + wbar*tempd80
        sid(i, j, k, 1) = sid(i, j, k, 1) + (ubar*tauxx-q_x+vbar*tauxy+&
&         wbar*tauxz)*frhoed
        tauyyd = tauyyd + si(i, j, k, 2)*fmyd + vbar*tempd81
        tauyzd = tauyzd + si(i, j, k, 2)*fmzd + si(i, j, k, 3)*fmyd + &
&         vbar*tempd82 + wbar*tempd81
        sid(i, j, k, 2) = sid(i, j, k, 2) + (ubar*tauxy-q_y+vbar*tauyy+&
&         wbar*tauyz)*frhoed
        tauzzd = tauzzd + si(i, j, k, 3)*fmzd + wbar*tempd82
        sid(i, j, k, 3) = sid(i, j, k, 3) + (ubar*tauxz-q_z+vbar*tauyz+&
&         wbar*tauzz)*frhoed
        q_xd = -(si(i, j, k, 1)*frhoed)
        q_yd = -(si(i, j, k, 2)*frhoed)
        q_zd = -(si(i, j, k, 3)*frhoed)
        sid(i, j, k, 1) = sid(i, j, k, 1) + tauxz*fmzd
        sid(i, j, k, 2) = sid(i, j, k, 2) + tauyz*fmzd
        sid(i, j, k, 3) = sid(i, j, k, 3) + tauzz*fmzd
        sid(i, j, k, 1) = sid(i, j, k, 1) + tauxy*fmyd
        sid(i, j, k, 2) = sid(i, j, k, 2) + tauyy*fmyd
        sid(i, j, k, 3) = sid(i, j, k, 3) + tauyz*fmyd
        sid(i, j, k, 1) = sid(i, j, k, 1) + tauxx*fmxd
        sid(i, j, k, 2) = sid(i, j, k, 2) + tauxy*fmxd
        sid(i, j, k, 3) = sid(i, j, k, 3) + tauxz*fmxd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wbard
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vbard
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*ubard
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          exzd = -tauxzd
          exyd = -tauxyd
          ezzd = -tauzzd
          eyyd = -tauyyd
          tempd73 = fact*exzd
          tempd76 = fact*exyd
          tempd74 = two*fact*ezzd
          tempd75 = two*fact*eyyd
          mutd = tauxzs*tauxzd + tauzzs*tauzzd + tauxxs*tauxxd + tauyys*&
&           tauyyd + tauxys*tauxyd + tauyzs*tauyzd
          tauyzsd = wxy*tempd73 + wzy*tempd74 + wyz*tempd75 + wxz*&
&           tempd76 + mut*tauyzd
          eyzd = -tauyzd
          tauxxsd = wzx*tempd73 + wyx*tempd76 + mut*tauxxd
          exxd = -tauxxd
          tempd77 = fact*eyzd
          tauzzsd = wyz*tempd77 + wxz*tempd73 + mut*tauzzd
          tauyysd = wzy*tempd77 + wxy*tempd76 + mut*tauyyd
          factd = (wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)*exzd + &
&           two*(wzx*tauxzs+wzy*tauyzs)*ezzd + two*(wxy*tauxys+wxz*&
&           tauxzs)*exxd + two*(wyx*tauxys+wyz*tauyzs)*eyyd + (wxy*&
&           tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)*exyd + (wyx*tauxzs+&
&           wyz*tauzzs+wzx*tauxys+wzy*tauyys)*eyzd
          wyxd = tauxxs*tempd76 + tauxys*tempd75 + tauxzs*tempd77
          wzxd = tauxxs*tempd73 + tauxzs*tempd74 + tauxys*tempd77
          wzyd = tauxys*tempd73 + tauyzs*tempd74 + tauyys*tempd77
          wyzd = tauxzs*tempd76 - wzyd + tauyzs*tempd75 + tauzzs*tempd77
          tempd78 = two*fact*exxd
          tauxzsd = wyx*tempd77 + wzx*tempd74 + wxz*tempd78 + wyz*&
&           tempd76 + mut*tauxzd
          tauxysd = wzx*tempd77 + wyx*tempd75 + wxy*tempd78 + wzy*&
&           tempd73 + mut*tauxyd
          wxyd = tauyys*tempd76 - wyxd + tauxys*tempd78 + tauyzs*tempd73
          wxzd = tauyzs*tempd76 - wzxd + tauxzs*tempd78 + tauzzs*tempd73
          v_zd = wyzd
          w_yd = -wyzd
          u_zd = wxzd
          w_xd = -wxzd
          u_yd = wxyd
          v_xd = -wxyd
          tempd79 = ccr1*factd/den
          mued = mued + tempd79
          dend = -(mue*tempd79/den)
          call popcontrol1b(branch)
          if (branch .eq. 0) dend = 0.0_8
          if (u_x**2 + u_y**2 + u_z**2 + v_x**2 + v_y**2 + v_z**2 + w_x&
&             **2 + w_y**2 + w_z**2 .eq. 0.0_8) then
            tempd72 = 0.0
          else
            tempd72 = dend/(2.0*sqrt(u_x**2+u_y**2+u_z**2+v_x**2+v_y**2+&
&             v_z**2+w_x**2+w_y**2+w_z**2))
          end if
          u_xd = 2*u_x*tempd72
          u_yd = u_yd + 2*u_y*tempd72
          u_zd = u_zd + 2*u_z*tempd72
          v_xd = v_xd + 2*v_x*tempd72
          v_yd = 2*v_y*tempd72
          v_zd = v_zd + 2*v_z*tempd72
          w_xd = w_xd + 2*w_x*tempd72
          w_yd = w_yd + 2*w_y*tempd72
          w_zd = 2*w_z*tempd72
        else
          mutd = tauxzs*tauxzd + tauzzs*tauzzd + tauxxs*tauxxd + tauyys*&
&           tauyyd + tauxys*tauxyd + tauyzs*tauyzd
          tauyzsd = mut*tauyzd
          tauxzsd = mut*tauxzd
          tauxysd = mut*tauxyd
          tauzzsd = mut*tauzzd
          tauyysd = mut*tauyyd
          tauxxsd = mut*tauxxd
          u_xd = 0.0_8
          u_yd = 0.0_8
          u_zd = 0.0_8
          w_xd = 0.0_8
          w_yd = 0.0_8
          w_zd = 0.0_8
          v_xd = 0.0_8
          v_yd = 0.0_8
          v_zd = 0.0_8
        end if
        fracdivd = -tauyysd - tauxxsd - tauzzsd
        tempd55 = twothird*fracdivd
        call popreal8(q_z)
        call popreal8(q_y)
        call popreal8(q_x)
        heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
        q_zd = heatcoef*q_zd
        q_yd = heatcoef*q_yd
        q_xd = heatcoef*q_xd
        v_zd = v_zd + tauyzsd
        w_yd = w_yd + tauyzsd
        u_zd = u_zd + tauxzsd
        w_xd = w_xd + tauxzsd
        u_yd = u_yd + tauxysd
        v_xd = v_xd + tauxysd
        w_zd = w_zd + tempd55 + two*tauzzsd
        v_yd = v_yd + tempd55 + two*tauyysd
        u_xd = u_xd + tempd55 + two*tauxxsd
        call popreal8(q_z)
        corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
        sszd = q_z*corrd - corr*q_zd
        call popreal8(q_y)
        ssyd = q_y*corrd - corr*q_yd
        call popreal8(q_x)
        ssxd = q_x*corrd - corr*q_xd
        call popreal8(corr)
        q_xd = q_xd + ssx*corrd
        q_yd = q_yd + ssy*corrd
        q_zd = q_zd + ssz*corrd
        aad(i+1, j, k) = aad(i+1, j, k) + ss*corrd
        aad(i, j, k) = aad(i, j, k) - ss*corrd
        ssd = (aa(i+1, j, k)-aa(i, j, k))*corrd
        call popreal8(w_z)
        corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
        sszd = sszd + w_z*corrd - corr*w_zd
        call popreal8(w_y)
        ssyd = ssyd + w_y*corrd - corr*w_yd
        call popreal8(w_x)
        ssxd = ssxd + w_x*corrd - corr*w_xd
        call popreal8(corr)
        w_xd = w_xd + ssx*corrd
        w_yd = w_yd + ssy*corrd
        w_zd = w_zd + ssz*corrd
        wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) - ss*corrd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
        ssd = ssd - (w(i+1, j, k, ivz)-w(i, j, k, ivz))*corrd
        call popreal8(v_z)
        corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
        sszd = sszd + v_z*corrd - corr*v_zd
        call popreal8(v_y)
        ssyd = ssyd + v_y*corrd - corr*v_yd
        call popreal8(v_x)
        ssxd = ssxd + v_x*corrd - corr*v_xd
        call popreal8(corr)
        v_xd = v_xd + ssx*corrd
        v_yd = v_yd + ssy*corrd
        v_zd = v_zd + ssz*corrd
        wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) - ss*corrd
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
        ssd = ssd - (w(i+1, j, k, ivy)-w(i, j, k, ivy))*corrd
        call popreal8(u_z)
        corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
        sszd = sszd + u_z*corrd - corr*u_zd
        call popreal8(u_y)
        ssyd = ssyd + u_y*corrd - corr*u_yd
        call popreal8(u_x)
        ssxd = ssxd + u_x*corrd - corr*u_xd
        u_xd = u_xd + ssx*corrd
        u_yd = u_yd + ssy*corrd
        u_zd = u_zd + ssz*corrd
        wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) - ss*corrd
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
        call popreal8(ssz)
        call popreal8(ssy)
        call popreal8(ssx)
        ssd = ssd + ssz*sszd + ssx*ssxd + ssy*ssyd - (w(i+1, j, k, ivx)-&
&         w(i, j, k, ivx))*corrd
        temp3 = ssx**2 + ssy**2 + ssz**2
        temp4 = sqrt(temp3)
        if (temp3 .eq. 0.0_8) then
          tempd56 = 0.0
        else
          tempd56 = -(one*ssd/(temp4**3*2.0))
        end if
        sszd = 2*ssz*tempd56 + ss*sszd
        ssyd = 2*ssy*tempd56 + ss*ssyd
        ssxd = 2*ssx*tempd56 + ss*ssxd
        tempd57 = eighth*sszd
        xd(i+1, j-1, k-1, 3) = xd(i+1, j-1, k-1, 3) + tempd57
        xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd57
        xd(i+1, j-1, k, 3) = xd(i+1, j-1, k, 3) + tempd57
        xd(i-1, j-1, k, 3) = xd(i-1, j-1, k, 3) - tempd57
        xd(i+1, j, k-1, 3) = xd(i+1, j, k-1, 3) + tempd57
        xd(i-1, j, k-1, 3) = xd(i-1, j, k-1, 3) - tempd57
        xd(i+1, j, k, 3) = xd(i+1, j, k, 3) + tempd57
        xd(i-1, j, k, 3) = xd(i-1, j, k, 3) - tempd57
        tempd58 = eighth*ssyd
        xd(i+1, j-1, k-1, 2) = xd(i+1, j-1, k-1, 2) + tempd58
        xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd58
        xd(i+1, j-1, k, 2) = xd(i+1, j-1, k, 2) + tempd58
        xd(i-1, j-1, k, 2) = xd(i-1, j-1, k, 2) - tempd58
        xd(i+1, j, k-1, 2) = xd(i+1, j, k-1, 2) + tempd58
        xd(i-1, j, k-1, 2) = xd(i-1, j, k-1, 2) - tempd58
        xd(i+1, j, k, 2) = xd(i+1, j, k, 2) + tempd58
        xd(i-1, j, k, 2) = xd(i-1, j, k, 2) - tempd58
        tempd59 = eighth*ssxd
        xd(i+1, j-1, k-1, 1) = xd(i+1, j-1, k-1, 1) + tempd59
        xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd59
        xd(i+1, j-1, k, 1) = xd(i+1, j-1, k, 1) + tempd59
        xd(i-1, j-1, k, 1) = xd(i-1, j-1, k, 1) - tempd59
        xd(i+1, j, k-1, 1) = xd(i+1, j, k-1, 1) + tempd59
        xd(i-1, j, k-1, 1) = xd(i-1, j, k-1, 1) - tempd59
        xd(i+1, j, k, 1) = xd(i+1, j, k, 1) + tempd59
        xd(i-1, j, k, 1) = xd(i-1, j, k, 1) - tempd59
        tempd60 = fourth*q_zd
        qzd(i, j-1, k-1) = qzd(i, j-1, k-1) + tempd60
        qzd(i, j, k-1) = qzd(i, j, k-1) + tempd60
        qzd(i, j-1, k) = qzd(i, j-1, k) + tempd60
        qzd(i, j, k) = qzd(i, j, k) + tempd60
        tempd61 = fourth*q_yd
        qyd(i, j-1, k-1) = qyd(i, j-1, k-1) + tempd61
        qyd(i, j, k-1) = qyd(i, j, k-1) + tempd61
        qyd(i, j-1, k) = qyd(i, j-1, k) + tempd61
        qyd(i, j, k) = qyd(i, j, k) + tempd61
        tempd62 = fourth*q_xd
        qxd(i, j-1, k-1) = qxd(i, j-1, k-1) + tempd62
        qxd(i, j, k-1) = qxd(i, j, k-1) + tempd62
        qxd(i, j-1, k) = qxd(i, j-1, k) + tempd62
        qxd(i, j, k) = qxd(i, j, k) + tempd62
        tempd63 = fourth*w_zd
        wzd(i, j-1, k-1) = wzd(i, j-1, k-1) + tempd63
        wzd(i, j, k-1) = wzd(i, j, k-1) + tempd63
        wzd(i, j-1, k) = wzd(i, j-1, k) + tempd63
        wzd(i, j, k) = wzd(i, j, k) + tempd63
        tempd64 = fourth*w_yd
        wyd(i, j-1, k-1) = wyd(i, j-1, k-1) + tempd64
        wyd(i, j, k-1) = wyd(i, j, k-1) + tempd64
        wyd(i, j-1, k) = wyd(i, j-1, k) + tempd64
        wyd(i, j, k) = wyd(i, j, k) + tempd64
        tempd65 = fourth*w_xd
        wxd(i, j-1, k-1) = wxd(i, j-1, k-1) + tempd65
        wxd(i, j, k-1) = wxd(i, j, k-1) + tempd65
        wxd(i, j-1, k) = wxd(i, j-1, k) + tempd65
        wxd(i, j, k) = wxd(i, j, k) + tempd65
        tempd66 = fourth*v_zd
        vzd(i, j-1, k-1) = vzd(i, j-1, k-1) + tempd66
        vzd(i, j, k-1) = vzd(i, j, k-1) + tempd66
        vzd(i, j-1, k) = vzd(i, j-1, k) + tempd66
        vzd(i, j, k) = vzd(i, j, k) + tempd66
        tempd67 = fourth*v_yd
        vyd(i, j-1, k-1) = vyd(i, j-1, k-1) + tempd67
        vyd(i, j, k-1) = vyd(i, j, k-1) + tempd67
        vyd(i, j-1, k) = vyd(i, j-1, k) + tempd67
        vyd(i, j, k) = vyd(i, j, k) + tempd67
        tempd68 = fourth*v_xd
        vxd(i, j-1, k-1) = vxd(i, j-1, k-1) + tempd68
        vxd(i, j, k-1) = vxd(i, j, k-1) + tempd68
        vxd(i, j-1, k) = vxd(i, j-1, k) + tempd68
        vxd(i, j, k) = vxd(i, j, k) + tempd68
        tempd69 = fourth*u_zd
        uzd(i, j-1, k-1) = uzd(i, j-1, k-1) + tempd69
        uzd(i, j, k-1) = uzd(i, j, k-1) + tempd69
        uzd(i, j-1, k) = uzd(i, j-1, k) + tempd69
        uzd(i, j, k) = uzd(i, j, k) + tempd69
        tempd70 = fourth*u_yd
        uyd(i, j-1, k-1) = uyd(i, j-1, k-1) + tempd70
        uyd(i, j, k-1) = uyd(i, j, k-1) + tempd70
        uyd(i, j-1, k) = uyd(i, j-1, k) + tempd70
        uyd(i, j, k) = uyd(i, j, k) + tempd70
        tempd71 = fourth*u_xd
        uxd(i, j-1, k-1) = uxd(i, j-1, k-1) + tempd71
        uxd(i, j, k-1) = uxd(i, j, k-1) + tempd71
        uxd(i, j-1, k) = uxd(i, j-1, k) + tempd71
        uxd(i, j, k) = uxd(i, j, k) + tempd71
        muld = mutd + factlamheat*heatcoefd
        mued = mued + mutd + factturbheat*heatcoefd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          revd(i, j, k) = revd(i, j, k) + por*mued
          revd(i+1, j, k) = revd(i+1, j, k) + por*mued
          mued = 0.0_8
        end if
        rlvd(i, j, k) = rlvd(i, j, k) + por*muld
        rlvd(i+1, j, k) = rlvd(i+1, j, k) + por*muld
      end do
      call popreal8(tauxys)
      call popreal8(por)
      call popreal8(fact)
      call popreal8(tauyzs)
      call popreal8(ss)
      call popreal8(mue)
      call popreal8(tauyz)
      call popreal8(tauyy)
      call popreal8(v_z)
      call popreal8(v_y)
      call popreal8(v_x)
      call popreal8(wzy)
      call popreal8(wzx)
      call popreal8(q_z)
      call popreal8(q_y)
      call popreal8(tauxxs)
      call popreal8(q_x)
      call popreal8(tauyys)
      call popreal8(tauzzs)
      call popreal8(tauxz)
      call popreal8(tauxy)
      call popreal8(den)
      call popreal8(tauxx)
      call popreal8(wyz)
      call popreal8(wyx)
      call popreal8(corr)
      call popreal8(w_z)
      call popreal8(w_y)
      call popreal8(w_x)
      call popreal8(tauxzs)
      call popinteger4(k)
      call popinteger4(j)
      call popinteger4(i)
      call popreal8(u_z)
      call popreal8(tauzz)
      call popreal8(u_y)
      call popreal8(u_x)
      call popreal8(ssz)
      call popreal8(ssy)
      call popreal8(wxz)
      call popreal8(ssx)
      call popreal8(wxy)
      mued = 0.0_8
      mue = zero
      mued = 0.0_8
      do ii=0,nx*jl*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, jl) + 1
        k = ii/(nx*jl) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
        por = half*rfilv
        if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
        mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
        if (eddymodel) then
          mue = por*(rev(i, j, k)+rev(i, j+1, k))
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        mut = mul + mue
        gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
        factlamheat = one/(prandtl*gm1)
        factturbheat = one/(prandtlturb*gm1)
        heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
        u_x = fourth*(ux(i-1, j, k-1)+ux(i, j, k-1)+ux(i-1, j, k)+ux(i, &
&         j, k))
        u_y = fourth*(uy(i-1, j, k-1)+uy(i, j, k-1)+uy(i-1, j, k)+uy(i, &
&         j, k))
        u_z = fourth*(uz(i-1, j, k-1)+uz(i, j, k-1)+uz(i-1, j, k)+uz(i, &
&         j, k))
        v_x = fourth*(vx(i-1, j, k-1)+vx(i, j, k-1)+vx(i-1, j, k)+vx(i, &
&         j, k))
        v_y = fourth*(vy(i-1, j, k-1)+vy(i, j, k-1)+vy(i-1, j, k)+vy(i, &
&         j, k))
        v_z = fourth*(vz(i-1, j, k-1)+vz(i, j, k-1)+vz(i-1, j, k)+vz(i, &
&         j, k))
        w_x = fourth*(wx(i-1, j, k-1)+wx(i, j, k-1)+wx(i-1, j, k)+wx(i, &
&         j, k))
        w_y = fourth*(wy(i-1, j, k-1)+wy(i, j, k-1)+wy(i-1, j, k)+wy(i, &
&         j, k))
        w_z = fourth*(wz(i-1, j, k-1)+wz(i, j, k-1)+wz(i-1, j, k)+wz(i, &
&         j, k))
        q_x = fourth*(qx(i-1, j, k-1)+qx(i, j, k-1)+qx(i-1, j, k)+qx(i, &
&         j, k))
        q_y = fourth*(qy(i-1, j, k-1)+qy(i, j, k-1)+qy(i-1, j, k)+qy(i, &
&         j, k))
        q_z = fourth*(qz(i-1, j, k-1)+qz(i, j, k-1)+qz(i-1, j, k)+qz(i, &
&         j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center j to cell center j+1.
        ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j+1&
&         , k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1, 1)+&
&         x(i, j+1, k, 1)-x(i, j-1, k, 1))
        ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j+1&
&         , k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1, 2)+&
&         x(i, j+1, k, 2)-x(i, j-1, k, 2))
        ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j+1&
&         , k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1, 3)+&
&         x(i, j+1, k, 3)-x(i, j-1, k, 3))
! determine the length of this vector and create the
! unit normal.
        ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
        call pushreal8(ssx)
        ssx = ss*ssx
        call pushreal8(ssy)
        ssy = ss*ssy
        call pushreal8(ssz)
        ssz = ss*ssz
! correct the gradients.
        corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j, &
&         k, ivx))*ss
        call pushreal8(u_x)
        u_x = u_x - corr*ssx
        call pushreal8(u_y)
        u_y = u_y - corr*ssy
        call pushreal8(u_z)
        u_z = u_z - corr*ssz
        call pushreal8(corr)
        corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j, &
&         k, ivy))*ss
        call pushreal8(v_x)
        v_x = v_x - corr*ssx
        call pushreal8(v_y)
        v_y = v_y - corr*ssy
        call pushreal8(v_z)
        v_z = v_z - corr*ssz
        call pushreal8(corr)
        corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j, &
&         k, ivz))*ss
        call pushreal8(w_x)
        w_x = w_x - corr*ssx
        call pushreal8(w_y)
        w_y = w_y - corr*ssy
        call pushreal8(w_z)
        w_z = w_z - corr*ssz
        call pushreal8(corr)
        corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j+1, k)-aa(i, j, k))&
&         *ss
        call pushreal8(q_x)
        q_x = q_x - corr*ssx
        call pushreal8(q_y)
        q_y = q_y - corr*ssy
        call pushreal8(q_z)
        q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
! we remove the viscosity from the stress tensor (tau)
! to define taus since we still need to separate between
! laminar and turbulent stress for qcr.
! therefore, laminar tau = mue*taus, turbulent
! tau = mue*taus, and total tau = mut*taus.
        fracdiv = twothird*(u_x+v_y+w_z)
        tauxxs = two*u_x - fracdiv
        tauyys = two*v_y - fracdiv
        tauzzs = two*w_z - fracdiv
        tauxys = u_y + v_x
        tauxzs = u_z + w_x
        tauyzs = v_z + w_y
        call pushreal8(q_x)
        q_x = heatcoef*q_x
        call pushreal8(q_y)
        q_y = heatcoef*q_y
        call pushreal8(q_z)
        q_z = heatcoef*q_z
! add qcr corrections if necessary
        if (useqcr) then
! in the qcr formulation, we add an extra term to the turbulent stress tensor:
!
! tau_ij,qcr = tau_ij - e_ij
!
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
!
! remember that the tau_ij in e_ij should use only the eddy viscosity!
! compute denominator
          den = sqrt(u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&           v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z)
          if (den .lt. xminn) then
            den = xminn
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            den = den
          end if
! compute factor that will multiply all tensor components.
! here we add the eddy viscosity that should multiply the stress tensor (tau)
! components as well.
          fact = mue*ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
! the diagonals of the vorticity tensor components are always zero
          wxy = u_y - v_x
          wxz = u_z - w_x
          wyz = v_z - w_y
          wyx = -wxy
          wzx = -wxz
          wzy = -wyz
! compute the extra terms of the boussinesq relation
          exx = fact*(wxy*tauxys+wxz*tauxzs)*two
          eyy = fact*(wyx*tauxys+wyz*tauyzs)*two
          ezz = fact*(wzx*tauxzs+wzy*tauyzs)*two
          exy = fact*(wxy*tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)
          exz = fact*(wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)
          eyz = fact*(wyx*tauxzs+wyz*tauzzs+wzx*tauxys+wzy*tauyys)
! apply the total viscosity to the stress tensor and add extra terms
          tauxx = mut*tauxxs - exx
          tauyy = mut*tauyys - eyy
          tauzz = mut*tauzzs - ezz
          tauxy = mut*tauxys - exy
          tauxz = mut*tauxzs - exz
          tauyz = mut*tauyzs - eyz
          call pushcontrol1b(0)
        else
! just apply the total viscosity to the stress tensor
          tauxx = mut*tauxxs
          tauyy = mut*tauyys
          tauzz = mut*tauzzs
          tauxy = mut*tauxys
          tauxz = mut*tauxzs
          tauyz = mut*tauyzs
          call pushcontrol1b(1)
        end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
        ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
        vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
        wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
! update the residuals of cell j and j+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases j == 1
! and j == jl must be tested.
        if (j .eq. 1 .and. storewalltensor .and. viscjminpointer(i, k) &
&           .gt. 0) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
! and the j == jl case.
        if (j .eq. jl .and. storewalltensor .and. viscjmaxpointer(i, k) &
&           .gt. 0) then
          tauyzd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 6)
          viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 6) = 0.0_8
          tauxzd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 5)
          viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 5) = 0.0_8
          tauxyd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 4)
          viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 4) = 0.0_8
          tauzzd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 3)
          viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 3) = 0.0_8
          tauyyd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 2)
          viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 2) = 0.0_8
          tauxxd = viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 1)
          viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 1) = 0.0_8
        else
          tauzzd = 0.0_8
          tauxxd = 0.0_8
          tauxyd = 0.0_8
          tauxzd = 0.0_8
          tauyyd = 0.0_8
          tauyzd = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          tauyzd = tauyzd + viscsubfaced(viscjminpointer(i, k))%tau(i, k&
&           , 6)
          viscsubfaced(viscjminpointer(i, k))%tau(i, k, 6) = 0.0_8
          tauxzd = tauxzd + viscsubfaced(viscjminpointer(i, k))%tau(i, k&
&           , 5)
          viscsubfaced(viscjminpointer(i, k))%tau(i, k, 5) = 0.0_8
          tauxyd = tauxyd + viscsubfaced(viscjminpointer(i, k))%tau(i, k&
&           , 4)
          viscsubfaced(viscjminpointer(i, k))%tau(i, k, 4) = 0.0_8
          tauzzd = tauzzd + viscsubfaced(viscjminpointer(i, k))%tau(i, k&
&           , 3)
          viscsubfaced(viscjminpointer(i, k))%tau(i, k, 3) = 0.0_8
          tauyyd = tauyyd + viscsubfaced(viscjminpointer(i, k))%tau(i, k&
&           , 2)
          viscsubfaced(viscjminpointer(i, k))%tau(i, k, 2) = 0.0_8
          tauxxd = tauxxd + viscsubfaced(viscjminpointer(i, k))%tau(i, k&
&           , 1)
          viscsubfaced(viscjminpointer(i, k))%tau(i, k, 1) = 0.0_8
        end if
        frhoed = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
        fmzd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
        fmyd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
        fmxd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
        tempd52 = sj(i, j, k, 1)*frhoed
        tempd53 = sj(i, j, k, 2)*frhoed
        tempd54 = sj(i, j, k, 3)*frhoed
        ubard = tauxz*tempd54 + tauxy*tempd53 + tauxx*tempd52
        tauxxd = tauxxd + sj(i, j, k, 1)*fmxd + ubar*tempd52
        vbard = tauyz*tempd54 + tauyy*tempd53 + tauxy*tempd52
        tauxyd = tauxyd + sj(i, j, k, 1)*fmyd + sj(i, j, k, 2)*fmxd + &
&         ubar*tempd53 + vbar*tempd52
        wbard = tauzz*tempd54 + tauyz*tempd53 + tauxz*tempd52
        tauxzd = tauxzd + sj(i, j, k, 1)*fmzd + sj(i, j, k, 3)*fmxd + &
&         ubar*tempd54 + wbar*tempd52
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + (ubar*tauxx-q_x+vbar*tauxy+&
&         wbar*tauxz)*frhoed
        tauyyd = tauyyd + sj(i, j, k, 2)*fmyd + vbar*tempd53
        tauyzd = tauyzd + sj(i, j, k, 2)*fmzd + sj(i, j, k, 3)*fmyd + &
&         vbar*tempd54 + wbar*tempd53
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + (ubar*tauxy-q_y+vbar*tauyy+&
&         wbar*tauyz)*frhoed
        tauzzd = tauzzd + sj(i, j, k, 3)*fmzd + wbar*tempd54
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + (ubar*tauxz-q_z+vbar*tauyz+&
&         wbar*tauzz)*frhoed
        q_xd = -(sj(i, j, k, 1)*frhoed)
        q_yd = -(sj(i, j, k, 2)*frhoed)
        q_zd = -(sj(i, j, k, 3)*frhoed)
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + tauxz*fmzd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + tauyz*fmzd
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + tauzz*fmzd
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + tauxy*fmyd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + tauyy*fmyd
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + tauyz*fmyd
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + tauxx*fmxd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + tauxy*fmxd
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + tauxz*fmxd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wbard
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vbard
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*ubard
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          exzd = -tauxzd
          exyd = -tauxyd
          ezzd = -tauzzd
          eyyd = -tauyyd
          tempd45 = fact*exzd
          tempd48 = fact*exyd
          tempd46 = two*fact*ezzd
          tempd47 = two*fact*eyyd
          mutd = tauxzs*tauxzd + tauzzs*tauzzd + tauxxs*tauxxd + tauyys*&
&           tauyyd + tauxys*tauxyd + tauyzs*tauyzd
          tauyzsd = wxy*tempd45 + wzy*tempd46 + wyz*tempd47 + wxz*&
&           tempd48 + mut*tauyzd
          eyzd = -tauyzd
          tauxxsd = wzx*tempd45 + wyx*tempd48 + mut*tauxxd
          exxd = -tauxxd
          tempd49 = fact*eyzd
          tauzzsd = wyz*tempd49 + wxz*tempd45 + mut*tauzzd
          tauyysd = wzy*tempd49 + wxy*tempd48 + mut*tauyyd
          factd = (wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)*exzd + &
&           two*(wzx*tauxzs+wzy*tauyzs)*ezzd + two*(wxy*tauxys+wxz*&
&           tauxzs)*exxd + two*(wyx*tauxys+wyz*tauyzs)*eyyd + (wxy*&
&           tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)*exyd + (wyx*tauxzs+&
&           wyz*tauzzs+wzx*tauxys+wzy*tauyys)*eyzd
          wyxd = tauxxs*tempd48 + tauxys*tempd47 + tauxzs*tempd49
          wzxd = tauxxs*tempd45 + tauxzs*tempd46 + tauxys*tempd49
          wzyd = tauxys*tempd45 + tauyzs*tempd46 + tauyys*tempd49
          wyzd = tauxzs*tempd48 - wzyd + tauyzs*tempd47 + tauzzs*tempd49
          tempd50 = two*fact*exxd
          tauxzsd = wyx*tempd49 + wzx*tempd46 + wxz*tempd50 + wyz*&
&           tempd48 + mut*tauxzd
          tauxysd = wzx*tempd49 + wyx*tempd47 + wxy*tempd50 + wzy*&
&           tempd45 + mut*tauxyd
          wxyd = tauyys*tempd48 - wyxd + tauxys*tempd50 + tauyzs*tempd45
          wxzd = tauyzs*tempd48 - wzxd + tauxzs*tempd50 + tauzzs*tempd45
          v_zd = wyzd
          w_yd = -wyzd
          u_zd = wxzd
          w_xd = -wxzd
          u_yd = wxyd
          v_xd = -wxyd
          tempd51 = ccr1*factd/den
          mued = mued + tempd51
          dend = -(mue*tempd51/den)
          call popcontrol1b(branch)
          if (branch .eq. 0) dend = 0.0_8
          if (u_x**2 + u_y**2 + u_z**2 + v_x**2 + v_y**2 + v_z**2 + w_x&
&             **2 + w_y**2 + w_z**2 .eq. 0.0_8) then
            tempd44 = 0.0
          else
            tempd44 = dend/(2.0*sqrt(u_x**2+u_y**2+u_z**2+v_x**2+v_y**2+&
&             v_z**2+w_x**2+w_y**2+w_z**2))
          end if
          u_xd = 2*u_x*tempd44
          u_yd = u_yd + 2*u_y*tempd44
          u_zd = u_zd + 2*u_z*tempd44
          v_xd = v_xd + 2*v_x*tempd44
          v_yd = 2*v_y*tempd44
          v_zd = v_zd + 2*v_z*tempd44
          w_xd = w_xd + 2*w_x*tempd44
          w_yd = w_yd + 2*w_y*tempd44
          w_zd = 2*w_z*tempd44
        else
          mutd = tauxzs*tauxzd + tauzzs*tauzzd + tauxxs*tauxxd + tauyys*&
&           tauyyd + tauxys*tauxyd + tauyzs*tauyzd
          tauyzsd = mut*tauyzd
          tauxzsd = mut*tauxzd
          tauxysd = mut*tauxyd
          tauzzsd = mut*tauzzd
          tauyysd = mut*tauyyd
          tauxxsd = mut*tauxxd
          u_xd = 0.0_8
          u_yd = 0.0_8
          u_zd = 0.0_8
          w_xd = 0.0_8
          w_yd = 0.0_8
          w_zd = 0.0_8
          v_xd = 0.0_8
          v_yd = 0.0_8
          v_zd = 0.0_8
        end if
        fracdivd = -tauyysd - tauxxsd - tauzzsd
        tempd27 = twothird*fracdivd
        call popreal8(q_z)
        call popreal8(q_y)
        call popreal8(q_x)
        heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
        q_zd = heatcoef*q_zd
        q_yd = heatcoef*q_yd
        q_xd = heatcoef*q_xd
        v_zd = v_zd + tauyzsd
        w_yd = w_yd + tauyzsd
        u_zd = u_zd + tauxzsd
        w_xd = w_xd + tauxzsd
        u_yd = u_yd + tauxysd
        v_xd = v_xd + tauxysd
        w_zd = w_zd + tempd27 + two*tauzzsd
        v_yd = v_yd + tempd27 + two*tauyysd
        u_xd = u_xd + tempd27 + two*tauxxsd
        call popreal8(q_z)
        corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
        sszd = q_z*corrd - corr*q_zd
        call popreal8(q_y)
        ssyd = q_y*corrd - corr*q_yd
        call popreal8(q_x)
        ssxd = q_x*corrd - corr*q_xd
        call popreal8(corr)
        q_xd = q_xd + ssx*corrd
        q_yd = q_yd + ssy*corrd
        q_zd = q_zd + ssz*corrd
        aad(i, j+1, k) = aad(i, j+1, k) + ss*corrd
        aad(i, j, k) = aad(i, j, k) - ss*corrd
        ssd = (aa(i, j+1, k)-aa(i, j, k))*corrd
        call popreal8(w_z)
        corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
        sszd = sszd + w_z*corrd - corr*w_zd
        call popreal8(w_y)
        ssyd = ssyd + w_y*corrd - corr*w_yd
        call popreal8(w_x)
        ssxd = ssxd + w_x*corrd - corr*w_xd
        call popreal8(corr)
        w_xd = w_xd + ssx*corrd
        w_yd = w_yd + ssy*corrd
        w_zd = w_zd + ssz*corrd
        wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) - ss*corrd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
        ssd = ssd - (w(i, j+1, k, ivz)-w(i, j, k, ivz))*corrd
        call popreal8(v_z)
        corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
        sszd = sszd + v_z*corrd - corr*v_zd
        call popreal8(v_y)
        ssyd = ssyd + v_y*corrd - corr*v_yd
        call popreal8(v_x)
        ssxd = ssxd + v_x*corrd - corr*v_xd
        call popreal8(corr)
        v_xd = v_xd + ssx*corrd
        v_yd = v_yd + ssy*corrd
        v_zd = v_zd + ssz*corrd
        wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) - ss*corrd
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
        ssd = ssd - (w(i, j+1, k, ivy)-w(i, j, k, ivy))*corrd
        call popreal8(u_z)
        corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
        sszd = sszd + u_z*corrd - corr*u_zd
        call popreal8(u_y)
        ssyd = ssyd + u_y*corrd - corr*u_yd
        call popreal8(u_x)
        ssxd = ssxd + u_x*corrd - corr*u_xd
        u_xd = u_xd + ssx*corrd
        u_yd = u_yd + ssy*corrd
        u_zd = u_zd + ssz*corrd
        wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) - ss*corrd
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
        call popreal8(ssz)
        call popreal8(ssy)
        call popreal8(ssx)
        ssd = ssd + ssz*sszd + ssx*ssxd + ssy*ssyd - (w(i, j+1, k, ivx)-&
&         w(i, j, k, ivx))*corrd
        temp1 = ssx**2 + ssy**2 + ssz**2
        temp2 = sqrt(temp1)
        if (temp1 .eq. 0.0_8) then
          tempd28 = 0.0
        else
          tempd28 = -(one*ssd/(temp2**3*2.0))
        end if
        sszd = 2*ssz*tempd28 + ss*sszd
        ssyd = 2*ssy*tempd28 + ss*ssyd
        ssxd = 2*ssx*tempd28 + ss*ssxd
        tempd29 = eighth*sszd
        xd(i-1, j+1, k-1, 3) = xd(i-1, j+1, k-1, 3) + tempd29
        xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd29
        xd(i-1, j+1, k, 3) = xd(i-1, j+1, k, 3) + tempd29
        xd(i-1, j-1, k, 3) = xd(i-1, j-1, k, 3) - tempd29
        xd(i, j+1, k-1, 3) = xd(i, j+1, k-1, 3) + tempd29
        xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) - tempd29
        xd(i, j+1, k, 3) = xd(i, j+1, k, 3) + tempd29
        xd(i, j-1, k, 3) = xd(i, j-1, k, 3) - tempd29
        tempd30 = eighth*ssyd
        xd(i-1, j+1, k-1, 2) = xd(i-1, j+1, k-1, 2) + tempd30
        xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd30
        xd(i-1, j+1, k, 2) = xd(i-1, j+1, k, 2) + tempd30
        xd(i-1, j-1, k, 2) = xd(i-1, j-1, k, 2) - tempd30
        xd(i, j+1, k-1, 2) = xd(i, j+1, k-1, 2) + tempd30
        xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) - tempd30
        xd(i, j+1, k, 2) = xd(i, j+1, k, 2) + tempd30
        xd(i, j-1, k, 2) = xd(i, j-1, k, 2) - tempd30
        tempd31 = eighth*ssxd
        xd(i-1, j+1, k-1, 1) = xd(i-1, j+1, k-1, 1) + tempd31
        xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd31
        xd(i-1, j+1, k, 1) = xd(i-1, j+1, k, 1) + tempd31
        xd(i-1, j-1, k, 1) = xd(i-1, j-1, k, 1) - tempd31
        xd(i, j+1, k-1, 1) = xd(i, j+1, k-1, 1) + tempd31
        xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) - tempd31
        xd(i, j+1, k, 1) = xd(i, j+1, k, 1) + tempd31
        xd(i, j-1, k, 1) = xd(i, j-1, k, 1) - tempd31
        tempd32 = fourth*q_zd
        qzd(i-1, j, k-1) = qzd(i-1, j, k-1) + tempd32
        qzd(i, j, k-1) = qzd(i, j, k-1) + tempd32
        qzd(i-1, j, k) = qzd(i-1, j, k) + tempd32
        qzd(i, j, k) = qzd(i, j, k) + tempd32
        tempd33 = fourth*q_yd
        qyd(i-1, j, k-1) = qyd(i-1, j, k-1) + tempd33
        qyd(i, j, k-1) = qyd(i, j, k-1) + tempd33
        qyd(i-1, j, k) = qyd(i-1, j, k) + tempd33
        qyd(i, j, k) = qyd(i, j, k) + tempd33
        tempd34 = fourth*q_xd
        qxd(i-1, j, k-1) = qxd(i-1, j, k-1) + tempd34
        qxd(i, j, k-1) = qxd(i, j, k-1) + tempd34
        qxd(i-1, j, k) = qxd(i-1, j, k) + tempd34
        qxd(i, j, k) = qxd(i, j, k) + tempd34
        tempd35 = fourth*w_zd
        wzd(i-1, j, k-1) = wzd(i-1, j, k-1) + tempd35
        wzd(i, j, k-1) = wzd(i, j, k-1) + tempd35
        wzd(i-1, j, k) = wzd(i-1, j, k) + tempd35
        wzd(i, j, k) = wzd(i, j, k) + tempd35
        tempd36 = fourth*w_yd
        wyd(i-1, j, k-1) = wyd(i-1, j, k-1) + tempd36
        wyd(i, j, k-1) = wyd(i, j, k-1) + tempd36
        wyd(i-1, j, k) = wyd(i-1, j, k) + tempd36
        wyd(i, j, k) = wyd(i, j, k) + tempd36
        tempd37 = fourth*w_xd
        wxd(i-1, j, k-1) = wxd(i-1, j, k-1) + tempd37
        wxd(i, j, k-1) = wxd(i, j, k-1) + tempd37
        wxd(i-1, j, k) = wxd(i-1, j, k) + tempd37
        wxd(i, j, k) = wxd(i, j, k) + tempd37
        tempd38 = fourth*v_zd
        vzd(i-1, j, k-1) = vzd(i-1, j, k-1) + tempd38
        vzd(i, j, k-1) = vzd(i, j, k-1) + tempd38
        vzd(i-1, j, k) = vzd(i-1, j, k) + tempd38
        vzd(i, j, k) = vzd(i, j, k) + tempd38
        tempd39 = fourth*v_yd
        vyd(i-1, j, k-1) = vyd(i-1, j, k-1) + tempd39
        vyd(i, j, k-1) = vyd(i, j, k-1) + tempd39
        vyd(i-1, j, k) = vyd(i-1, j, k) + tempd39
        vyd(i, j, k) = vyd(i, j, k) + tempd39
        tempd40 = fourth*v_xd
        vxd(i-1, j, k-1) = vxd(i-1, j, k-1) + tempd40
        vxd(i, j, k-1) = vxd(i, j, k-1) + tempd40
        vxd(i-1, j, k) = vxd(i-1, j, k) + tempd40
        vxd(i, j, k) = vxd(i, j, k) + tempd40
        tempd41 = fourth*u_zd
        uzd(i-1, j, k-1) = uzd(i-1, j, k-1) + tempd41
        uzd(i, j, k-1) = uzd(i, j, k-1) + tempd41
        uzd(i-1, j, k) = uzd(i-1, j, k) + tempd41
        uzd(i, j, k) = uzd(i, j, k) + tempd41
        tempd42 = fourth*u_yd
        uyd(i-1, j, k-1) = uyd(i-1, j, k-1) + tempd42
        uyd(i, j, k-1) = uyd(i, j, k-1) + tempd42
        uyd(i-1, j, k) = uyd(i-1, j, k) + tempd42
        uyd(i, j, k) = uyd(i, j, k) + tempd42
        tempd43 = fourth*u_xd
        uxd(i-1, j, k-1) = uxd(i-1, j, k-1) + tempd43
        uxd(i, j, k-1) = uxd(i, j, k-1) + tempd43
        uxd(i-1, j, k) = uxd(i-1, j, k) + tempd43
        uxd(i, j, k) = uxd(i, j, k) + tempd43
        muld = mutd + factlamheat*heatcoefd
        mued = mued + mutd + factturbheat*heatcoefd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          revd(i, j, k) = revd(i, j, k) + por*mued
          revd(i, j+1, k) = revd(i, j+1, k) + por*mued
          mued = 0.0_8
        end if
        rlvd(i, j, k) = rlvd(i, j, k) + por*muld
        rlvd(i, j+1, k) = rlvd(i, j+1, k) + por*muld
      end do
      call popreal8(tauxys)
      call popreal8(por)
      call popreal8(fact)
      call popreal8(tauyzs)
      call popreal8(ss)
      call popreal8(mue)
      call popreal8(tauyz)
      call popreal8(tauyy)
      call popreal8(v_z)
      call popreal8(v_y)
      call popreal8(v_x)
      call popreal8(wzy)
      call popreal8(wzx)
      call popreal8(q_z)
      call popreal8(q_y)
      call popreal8(tauxxs)
      call popreal8(q_x)
      call popreal8(tauyys)
      call popreal8(tauzzs)
      call popreal8(tauxz)
      call popreal8(tauxy)
      call popreal8(den)
      call popreal8(tauxx)
      call popreal8(wyz)
      call popreal8(wyx)
      call popreal8(corr)
      call popreal8(w_z)
      call popreal8(w_y)
      call popreal8(w_x)
      call popreal8(tauxzs)
      call popinteger4(j)
      call popinteger4(i)
      call popreal8(u_z)
      call popreal8(tauzz)
      call popreal8(u_y)
      call popreal8(u_x)
      call popreal8(ssz)
      call popreal8(ssy)
      call popreal8(wxz)
      call popreal8(ssx)
      call popreal8(wxy)
      mued = 0.0_8
!
!         viscous fluxes in the k-direction.
!
      mue = zero
      mued = 0.0_8
      do ii=0,nx*ny*kl-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 1
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
        por = half*rfilv
        if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
        mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
        if (eddymodel) then
          mue = por*(rev(i, j, k)+rev(i, j, k+1))
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
        mut = mul + mue
        gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
        factlamheat = one/(prandtl*gm1)
        factturbheat = one/(prandtlturb*gm1)
        heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
        u_x = fourth*(ux(i-1, j-1, k)+ux(i, j-1, k)+ux(i-1, j, k)+ux(i, &
&         j, k))
        u_y = fourth*(uy(i-1, j-1, k)+uy(i, j-1, k)+uy(i-1, j, k)+uy(i, &
&         j, k))
        u_z = fourth*(uz(i-1, j-1, k)+uz(i, j-1, k)+uz(i-1, j, k)+uz(i, &
&         j, k))
        v_x = fourth*(vx(i-1, j-1, k)+vx(i, j-1, k)+vx(i-1, j, k)+vx(i, &
&         j, k))
        v_y = fourth*(vy(i-1, j-1, k)+vy(i, j-1, k)+vy(i-1, j, k)+vy(i, &
&         j, k))
        v_z = fourth*(vz(i-1, j-1, k)+vz(i, j-1, k)+vz(i-1, j, k)+vz(i, &
&         j, k))
        w_x = fourth*(wx(i-1, j-1, k)+wx(i, j-1, k)+wx(i-1, j, k)+wx(i, &
&         j, k))
        w_y = fourth*(wy(i-1, j-1, k)+wy(i, j-1, k)+wy(i-1, j, k)+wy(i, &
&         j, k))
        w_z = fourth*(wz(i-1, j-1, k)+wz(i, j-1, k)+wz(i-1, j, k)+wz(i, &
&         j, k))
        q_x = fourth*(qx(i-1, j-1, k)+qx(i, j-1, k)+qx(i-1, j, k)+qx(i, &
&         j, k))
        q_y = fourth*(qy(i-1, j-1, k)+qy(i, j-1, k)+qy(i-1, j, k)+qy(i, &
&         j, k))
        q_z = fourth*(qz(i-1, j-1, k)+qz(i, j-1, k)+qz(i-1, j, k)+qz(i, &
&         j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center k to cell center k+1.
        ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j, &
&         k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1, 1)+&
&         x(i, j, k+1, 1)-x(i, j, k-1, 1))
        ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j, &
&         k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1, 2)+&
&         x(i, j, k+1, 2)-x(i, j, k-1, 2))
        ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j, &
&         k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1, 3)+&
&         x(i, j, k+1, 3)-x(i, j, k-1, 3))
! determine the length of this vector and create the
! unit normal.
        ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
        call pushreal8(ssx)
        ssx = ss*ssx
        call pushreal8(ssy)
        ssy = ss*ssy
        call pushreal8(ssz)
        ssz = ss*ssz
! correct the gradients.
        corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j, &
&         k, ivx))*ss
        call pushreal8(u_x)
        u_x = u_x - corr*ssx
        call pushreal8(u_y)
        u_y = u_y - corr*ssy
        call pushreal8(u_z)
        u_z = u_z - corr*ssz
        call pushreal8(corr)
        corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j, &
&         k, ivy))*ss
        call pushreal8(v_x)
        v_x = v_x - corr*ssx
        call pushreal8(v_y)
        v_y = v_y - corr*ssy
        call pushreal8(v_z)
        v_z = v_z - corr*ssz
        call pushreal8(corr)
        corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j, &
&         k, ivz))*ss
        call pushreal8(w_x)
        w_x = w_x - corr*ssx
        call pushreal8(w_y)
        w_y = w_y - corr*ssy
        call pushreal8(w_z)
        w_z = w_z - corr*ssz
        call pushreal8(corr)
        corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j, k+1)-aa(i, j, k))&
&         *ss
        call pushreal8(q_x)
        q_x = q_x - corr*ssx
        call pushreal8(q_y)
        q_y = q_y - corr*ssy
        call pushreal8(q_z)
        q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
! we remove the viscosity from the stress tensor (tau)
! to define taus since we still need to separate between
! laminar and turbulent stress for qcr.
! therefore, laminar tau = mue*taus, turbulent
! tau = mue*taus, and total tau = mut*taus.
        fracdiv = twothird*(u_x+v_y+w_z)
        tauxxs = two*u_x - fracdiv
        tauyys = two*v_y - fracdiv
        tauzzs = two*w_z - fracdiv
        tauxys = u_y + v_x
        tauxzs = u_z + w_x
        tauyzs = v_z + w_y
        call pushreal8(q_x)
        q_x = heatcoef*q_x
        call pushreal8(q_y)
        q_y = heatcoef*q_y
        call pushreal8(q_z)
        q_z = heatcoef*q_z
! add qcr corrections if necessary
        if (useqcr) then
! in the qcr formulation, we add an extra term to the turbulent stress tensor:
!
! tau_ij,qcr = tau_ij - e_ij
!
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
!
! remember that the tau_ij in e_ij should use only the eddy viscosity!
! compute denominator
          den = sqrt(u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&           v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z)
          if (den .lt. xminn) then
            den = xminn
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            den = den
          end if
! compute factor that will multiply all tensor components.
! here we add the eddy viscosity that should multiply the stress tensor (tau)
! components as well.
          fact = mue*ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
! the diagonals of the vorticity tensor components are always zero
          wxy = u_y - v_x
          wxz = u_z - w_x
          wyz = v_z - w_y
          wyx = -wxy
          wzx = -wxz
          wzy = -wyz
! compute the extra terms of the boussinesq relation
          exx = fact*(wxy*tauxys+wxz*tauxzs)*two
          eyy = fact*(wyx*tauxys+wyz*tauyzs)*two
          ezz = fact*(wzx*tauxzs+wzy*tauyzs)*two
          exy = fact*(wxy*tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)
          exz = fact*(wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)
          eyz = fact*(wyx*tauxzs+wyz*tauzzs+wzx*tauxys+wzy*tauyys)
! apply the total viscosity to the stress tensor and add extra terms
          tauxx = mut*tauxxs - exx
          tauyy = mut*tauyys - eyy
          tauzz = mut*tauzzs - ezz
          tauxy = mut*tauxys - exy
          tauxz = mut*tauxzs - exz
          tauyz = mut*tauyzs - eyz
          call pushcontrol1b(0)
        else
! just apply the total viscosity to the stress tensor
          tauxx = mut*tauxxs
          tauyy = mut*tauyys
          tauzz = mut*tauzzs
          tauxy = mut*tauxys
          tauxz = mut*tauxzs
          tauyz = mut*tauyzs
          call pushcontrol1b(1)
        end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
        ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
        vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
        wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this k-face.
! update the residuals of cell k and k+1.
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases k == 1
! and k == kl must be tested.
        if (k .eq. 1 .and. storewalltensor .and. visckminpointer(i, j) &
&           .gt. 0) then
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
        end if
! and the k == kl case.
        if (k .eq. kl .and. storewalltensor .and. visckmaxpointer(i, j) &
&           .gt. 0) then
          tauyzd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 6)
          viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 6) = 0.0_8
          tauxzd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 5)
          viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 5) = 0.0_8
          tauxyd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 4)
          viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 4) = 0.0_8
          tauzzd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 3)
          viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 3) = 0.0_8
          tauyyd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 2)
          viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 2) = 0.0_8
          tauxxd = viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 1)
          viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 1) = 0.0_8
        else
          tauzzd = 0.0_8
          tauxxd = 0.0_8
          tauxyd = 0.0_8
          tauxzd = 0.0_8
          tauyyd = 0.0_8
          tauyzd = 0.0_8
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          tauyzd = tauyzd + viscsubfaced(visckminpointer(i, j))%tau(i, j&
&           , 6)
          viscsubfaced(visckminpointer(i, j))%tau(i, j, 6) = 0.0_8
          tauxzd = tauxzd + viscsubfaced(visckminpointer(i, j))%tau(i, j&
&           , 5)
          viscsubfaced(visckminpointer(i, j))%tau(i, j, 5) = 0.0_8
          tauxyd = tauxyd + viscsubfaced(visckminpointer(i, j))%tau(i, j&
&           , 4)
          viscsubfaced(visckminpointer(i, j))%tau(i, j, 4) = 0.0_8
          tauzzd = tauzzd + viscsubfaced(visckminpointer(i, j))%tau(i, j&
&           , 3)
          viscsubfaced(visckminpointer(i, j))%tau(i, j, 3) = 0.0_8
          tauyyd = tauyyd + viscsubfaced(visckminpointer(i, j))%tau(i, j&
&           , 2)
          viscsubfaced(visckminpointer(i, j))%tau(i, j, 2) = 0.0_8
          tauxxd = tauxxd + viscsubfaced(visckminpointer(i, j))%tau(i, j&
&           , 1)
          viscsubfaced(visckminpointer(i, j))%tau(i, j, 1) = 0.0_8
        end if
        frhoed = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
        fmzd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
        fmyd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
        fmxd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
        q_xd = -(sk(i, j, k, 1)*frhoed)
        skd(i, j, k, 1) = skd(i, j, k, 1) - q_x*frhoed
        q_yd = -(sk(i, j, k, 2)*frhoed)
        skd(i, j, k, 2) = skd(i, j, k, 2) - q_y*frhoed
        q_zd = -(sk(i, j, k, 3)*frhoed)
        skd(i, j, k, 3) = skd(i, j, k, 3) - q_z*frhoed
        tempd24 = sk(i, j, k, 3)*frhoed
        tauzzd = tauzzd + sk(i, j, k, 3)*fmzd + wbar*tempd24
        skd(i, j, k, 3) = skd(i, j, k, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
&         tauzz)*frhoed
        tempd25 = sk(i, j, k, 2)*frhoed
        tauyzd = tauyzd + wbar*tempd25 + sk(i, j, k, 3)*fmyd + sk(i, j, &
&         k, 2)*fmzd + vbar*tempd24
        tauyyd = tauyyd + sk(i, j, k, 2)*fmyd + vbar*tempd25
        skd(i, j, k, 2) = skd(i, j, k, 2) + (ubar*tauxy+vbar*tauyy+wbar*&
&         tauyz)*frhoed
        tempd26 = sk(i, j, k, 1)*frhoed
        ubard = tauxy*tempd25 + tauxx*tempd26 + tauxz*tempd24
        tauxzd = tauxzd + wbar*tempd26 + sk(i, j, k, 3)*fmxd + sk(i, j, &
&         k, 1)*fmzd + ubar*tempd24
        vbard = tauyy*tempd25 + tauxy*tempd26 + tauyz*tempd24
        wbard = tauyz*tempd25 + tauxz*tempd26 + tauzz*tempd24
        tauxyd = tauxyd + vbar*tempd26 + sk(i, j, k, 2)*fmxd + sk(i, j, &
&         k, 1)*fmyd + ubar*tempd25
        tauxxd = tauxxd + sk(i, j, k, 1)*fmxd + ubar*tempd26
        skd(i, j, k, 1) = skd(i, j, k, 1) + (ubar*tauxx+vbar*tauxy+wbar*&
&         tauxz)*frhoed
        skd(i, j, k, 1) = skd(i, j, k, 1) + tauxz*fmzd
        skd(i, j, k, 2) = skd(i, j, k, 2) + tauyz*fmzd
        skd(i, j, k, 3) = skd(i, j, k, 3) + tauzz*fmzd
        skd(i, j, k, 1) = skd(i, j, k, 1) + tauxy*fmyd
        skd(i, j, k, 2) = skd(i, j, k, 2) + tauyy*fmyd
        skd(i, j, k, 3) = skd(i, j, k, 3) + tauyz*fmyd
        skd(i, j, k, 1) = skd(i, j, k, 1) + tauxx*fmxd
        skd(i, j, k, 2) = skd(i, j, k, 2) + tauxy*fmxd
        skd(i, j, k, 3) = skd(i, j, k, 3) + tauxz*fmxd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wbard
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vbard
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*ubard
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          exzd = -tauxzd
          exyd = -tauxyd
          ezzd = -tauzzd
          eyyd = -tauyyd
          tempd17 = fact*exzd
          tempd20 = fact*exyd
          tempd18 = two*fact*ezzd
          tempd19 = two*fact*eyyd
          mutd = tauxzs*tauxzd + tauzzs*tauzzd + tauxxs*tauxxd + tauyys*&
&           tauyyd + tauxys*tauxyd + tauyzs*tauyzd
          tauyzsd = wxy*tempd17 + wzy*tempd18 + wyz*tempd19 + wxz*&
&           tempd20 + mut*tauyzd
          eyzd = -tauyzd
          tauxxsd = wzx*tempd17 + wyx*tempd20 + mut*tauxxd
          exxd = -tauxxd
          tempd21 = fact*eyzd
          tauzzsd = wyz*tempd21 + wxz*tempd17 + mut*tauzzd
          tauyysd = wzy*tempd21 + wxy*tempd20 + mut*tauyyd
          factd = (wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)*exzd + &
&           two*(wzx*tauxzs+wzy*tauyzs)*ezzd + two*(wxy*tauxys+wxz*&
&           tauxzs)*exxd + two*(wyx*tauxys+wyz*tauyzs)*eyyd + (wxy*&
&           tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)*exyd + (wyx*tauxzs+&
&           wyz*tauzzs+wzx*tauxys+wzy*tauyys)*eyzd
          wyxd = tauxxs*tempd20 + tauxys*tempd19 + tauxzs*tempd21
          wzxd = tauxxs*tempd17 + tauxzs*tempd18 + tauxys*tempd21
          wzyd = tauxys*tempd17 + tauyzs*tempd18 + tauyys*tempd21
          wyzd = tauxzs*tempd20 - wzyd + tauyzs*tempd19 + tauzzs*tempd21
          tempd22 = two*fact*exxd
          tauxzsd = wyx*tempd21 + wzx*tempd18 + wxz*tempd22 + wyz*&
&           tempd20 + mut*tauxzd
          tauxysd = wzx*tempd21 + wyx*tempd19 + wxy*tempd22 + wzy*&
&           tempd17 + mut*tauxyd
          wxyd = tauyys*tempd20 - wyxd + tauxys*tempd22 + tauyzs*tempd17
          wxzd = tauyzs*tempd20 - wzxd + tauxzs*tempd22 + tauzzs*tempd17
          v_zd = wyzd
          w_yd = -wyzd
          u_zd = wxzd
          w_xd = -wxzd
          u_yd = wxyd
          v_xd = -wxyd
          tempd23 = ccr1*factd/den
          mued = mued + tempd23
          dend = -(mue*tempd23/den)
          call popcontrol1b(branch)
          if (branch .eq. 0) dend = 0.0_8
          if (u_x**2 + u_y**2 + u_z**2 + v_x**2 + v_y**2 + v_z**2 + w_x&
&             **2 + w_y**2 + w_z**2 .eq. 0.0_8) then
            tempd16 = 0.0
          else
            tempd16 = dend/(2.0*sqrt(u_x**2+u_y**2+u_z**2+v_x**2+v_y**2+&
&             v_z**2+w_x**2+w_y**2+w_z**2))
          end if
          u_xd = 2*u_x*tempd16
          u_yd = u_yd + 2*u_y*tempd16
          u_zd = u_zd + 2*u_z*tempd16
          v_xd = v_xd + 2*v_x*tempd16
          v_yd = 2*v_y*tempd16
          v_zd = v_zd + 2*v_z*tempd16
          w_xd = w_xd + 2*w_x*tempd16
          w_yd = w_yd + 2*w_y*tempd16
          w_zd = 2*w_z*tempd16
        else
          mutd = tauxzs*tauxzd + tauzzs*tauzzd + tauxxs*tauxxd + tauyys*&
&           tauyyd + tauxys*tauxyd + tauyzs*tauyzd
          tauyzsd = mut*tauyzd
          tauxzsd = mut*tauxzd
          tauxysd = mut*tauxyd
          tauzzsd = mut*tauzzd
          tauyysd = mut*tauyyd
          tauxxsd = mut*tauxxd
          u_xd = 0.0_8
          u_yd = 0.0_8
          u_zd = 0.0_8
          w_xd = 0.0_8
          w_yd = 0.0_8
          w_zd = 0.0_8
          v_xd = 0.0_8
          v_yd = 0.0_8
          v_zd = 0.0_8
        end if
        fracdivd = -tauyysd - tauxxsd - tauzzsd
        tempd = twothird*fracdivd
        call popreal8(q_z)
        call popreal8(q_y)
        call popreal8(q_x)
        heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
        q_zd = heatcoef*q_zd
        q_yd = heatcoef*q_yd
        q_xd = heatcoef*q_xd
        v_zd = v_zd + tauyzsd
        w_yd = w_yd + tauyzsd
        u_zd = u_zd + tauxzsd
        w_xd = w_xd + tauxzsd
        u_yd = u_yd + tauxysd
        v_xd = v_xd + tauxysd
        w_zd = w_zd + tempd + two*tauzzsd
        v_yd = v_yd + tempd + two*tauyysd
        u_xd = u_xd + tempd + two*tauxxsd
        call popreal8(q_z)
        corrd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
        sszd = q_z*corrd - corr*q_zd
        call popreal8(q_y)
        ssyd = q_y*corrd - corr*q_yd
        call popreal8(q_x)
        ssxd = q_x*corrd - corr*q_xd
        call popreal8(corr)
        q_xd = q_xd + ssx*corrd
        q_yd = q_yd + ssy*corrd
        q_zd = q_zd + ssz*corrd
        aad(i, j, k+1) = aad(i, j, k+1) + ss*corrd
        aad(i, j, k) = aad(i, j, k) - ss*corrd
        ssd = (aa(i, j, k+1)-aa(i, j, k))*corrd
        call popreal8(w_z)
        corrd = -(ssy*w_yd) - ssx*w_xd - ssz*w_zd
        sszd = sszd + w_z*corrd - corr*w_zd
        call popreal8(w_y)
        ssyd = ssyd + w_y*corrd - corr*w_yd
        call popreal8(w_x)
        ssxd = ssxd + w_x*corrd - corr*w_xd
        call popreal8(corr)
        w_xd = w_xd + ssx*corrd
        w_yd = w_yd + ssy*corrd
        w_zd = w_zd + ssz*corrd
        wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) - ss*corrd
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + ss*corrd
        ssd = ssd - (w(i, j, k+1, ivz)-w(i, j, k, ivz))*corrd
        call popreal8(v_z)
        corrd = -(ssy*v_yd) - ssx*v_xd - ssz*v_zd
        sszd = sszd + v_z*corrd - corr*v_zd
        call popreal8(v_y)
        ssyd = ssyd + v_y*corrd - corr*v_yd
        call popreal8(v_x)
        ssxd = ssxd + v_x*corrd - corr*v_xd
        call popreal8(corr)
        v_xd = v_xd + ssx*corrd
        v_yd = v_yd + ssy*corrd
        v_zd = v_zd + ssz*corrd
        wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) - ss*corrd
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + ss*corrd
        ssd = ssd - (w(i, j, k+1, ivy)-w(i, j, k, ivy))*corrd
        call popreal8(u_z)
        corrd = -(ssy*u_yd) - ssx*u_xd - ssz*u_zd
        sszd = sszd + u_z*corrd - corr*u_zd
        call popreal8(u_y)
        ssyd = ssyd + u_y*corrd - corr*u_yd
        call popreal8(u_x)
        ssxd = ssxd + u_x*corrd - corr*u_xd
        u_xd = u_xd + ssx*corrd
        u_yd = u_yd + ssy*corrd
        u_zd = u_zd + ssz*corrd
        wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) - ss*corrd
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + ss*corrd
        call popreal8(ssz)
        call popreal8(ssy)
        call popreal8(ssx)
        ssd = ssd + ssz*sszd + ssx*ssxd + ssy*ssyd - (w(i, j, k+1, ivx)-&
&         w(i, j, k, ivx))*corrd
        temp = ssx**2 + ssy**2 + ssz**2
        temp0 = sqrt(temp)
        if (temp .eq. 0.0_8) then
          tempd0 = 0.0
        else
          tempd0 = -(one*ssd/(temp0**3*2.0))
        end if
        sszd = 2*ssz*tempd0 + ss*sszd
        ssyd = 2*ssy*tempd0 + ss*ssyd
        ssxd = 2*ssx*tempd0 + ss*ssxd
        tempd1 = eighth*sszd
        xd(i-1, j-1, k+1, 3) = xd(i-1, j-1, k+1, 3) + tempd1
        xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd1
        xd(i-1, j, k+1, 3) = xd(i-1, j, k+1, 3) + tempd1
        xd(i-1, j, k-1, 3) = xd(i-1, j, k-1, 3) - tempd1
        xd(i, j-1, k+1, 3) = xd(i, j-1, k+1, 3) + tempd1
        xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) - tempd1
        xd(i, j, k+1, 3) = xd(i, j, k+1, 3) + tempd1
        xd(i, j, k-1, 3) = xd(i, j, k-1, 3) - tempd1
        tempd2 = eighth*ssyd
        xd(i-1, j-1, k+1, 2) = xd(i-1, j-1, k+1, 2) + tempd2
        xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd2
        xd(i-1, j, k+1, 2) = xd(i-1, j, k+1, 2) + tempd2
        xd(i-1, j, k-1, 2) = xd(i-1, j, k-1, 2) - tempd2
        xd(i, j-1, k+1, 2) = xd(i, j-1, k+1, 2) + tempd2
        xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) - tempd2
        xd(i, j, k+1, 2) = xd(i, j, k+1, 2) + tempd2
        xd(i, j, k-1, 2) = xd(i, j, k-1, 2) - tempd2
        tempd3 = eighth*ssxd
        xd(i-1, j-1, k+1, 1) = xd(i-1, j-1, k+1, 1) + tempd3
        xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd3
        xd(i-1, j, k+1, 1) = xd(i-1, j, k+1, 1) + tempd3
        xd(i-1, j, k-1, 1) = xd(i-1, j, k-1, 1) - tempd3
        xd(i, j-1, k+1, 1) = xd(i, j-1, k+1, 1) + tempd3
        xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) - tempd3
        xd(i, j, k+1, 1) = xd(i, j, k+1, 1) + tempd3
        xd(i, j, k-1, 1) = xd(i, j, k-1, 1) - tempd3
        tempd4 = fourth*q_zd
        qzd(i-1, j-1, k) = qzd(i-1, j-1, k) + tempd4
        qzd(i, j-1, k) = qzd(i, j-1, k) + tempd4
        qzd(i-1, j, k) = qzd(i-1, j, k) + tempd4
        qzd(i, j, k) = qzd(i, j, k) + tempd4
        tempd5 = fourth*q_yd
        qyd(i-1, j-1, k) = qyd(i-1, j-1, k) + tempd5
        qyd(i, j-1, k) = qyd(i, j-1, k) + tempd5
        qyd(i-1, j, k) = qyd(i-1, j, k) + tempd5
        qyd(i, j, k) = qyd(i, j, k) + tempd5
        tempd6 = fourth*q_xd
        qxd(i-1, j-1, k) = qxd(i-1, j-1, k) + tempd6
        qxd(i, j-1, k) = qxd(i, j-1, k) + tempd6
        qxd(i-1, j, k) = qxd(i-1, j, k) + tempd6
        qxd(i, j, k) = qxd(i, j, k) + tempd6
        tempd7 = fourth*w_zd
        wzd(i-1, j-1, k) = wzd(i-1, j-1, k) + tempd7
        wzd(i, j-1, k) = wzd(i, j-1, k) + tempd7
        wzd(i-1, j, k) = wzd(i-1, j, k) + tempd7
        wzd(i, j, k) = wzd(i, j, k) + tempd7
        tempd8 = fourth*w_yd
        wyd(i-1, j-1, k) = wyd(i-1, j-1, k) + tempd8
        wyd(i, j-1, k) = wyd(i, j-1, k) + tempd8
        wyd(i-1, j, k) = wyd(i-1, j, k) + tempd8
        wyd(i, j, k) = wyd(i, j, k) + tempd8
        tempd9 = fourth*w_xd
        wxd(i-1, j-1, k) = wxd(i-1, j-1, k) + tempd9
        wxd(i, j-1, k) = wxd(i, j-1, k) + tempd9
        wxd(i-1, j, k) = wxd(i-1, j, k) + tempd9
        wxd(i, j, k) = wxd(i, j, k) + tempd9
        tempd10 = fourth*v_zd
        vzd(i-1, j-1, k) = vzd(i-1, j-1, k) + tempd10
        vzd(i, j-1, k) = vzd(i, j-1, k) + tempd10
        vzd(i-1, j, k) = vzd(i-1, j, k) + tempd10
        vzd(i, j, k) = vzd(i, j, k) + tempd10
        tempd11 = fourth*v_yd
        vyd(i-1, j-1, k) = vyd(i-1, j-1, k) + tempd11
        vyd(i, j-1, k) = vyd(i, j-1, k) + tempd11
        vyd(i-1, j, k) = vyd(i-1, j, k) + tempd11
        vyd(i, j, k) = vyd(i, j, k) + tempd11
        tempd12 = fourth*v_xd
        vxd(i-1, j-1, k) = vxd(i-1, j-1, k) + tempd12
        vxd(i, j-1, k) = vxd(i, j-1, k) + tempd12
        vxd(i-1, j, k) = vxd(i-1, j, k) + tempd12
        vxd(i, j, k) = vxd(i, j, k) + tempd12
        tempd13 = fourth*u_zd
        uzd(i-1, j-1, k) = uzd(i-1, j-1, k) + tempd13
        uzd(i, j-1, k) = uzd(i, j-1, k) + tempd13
        uzd(i-1, j, k) = uzd(i-1, j, k) + tempd13
        uzd(i, j, k) = uzd(i, j, k) + tempd13
        tempd14 = fourth*u_yd
        uyd(i-1, j-1, k) = uyd(i-1, j-1, k) + tempd14
        uyd(i, j-1, k) = uyd(i, j-1, k) + tempd14
        uyd(i-1, j, k) = uyd(i-1, j, k) + tempd14
        uyd(i, j, k) = uyd(i, j, k) + tempd14
        tempd15 = fourth*u_xd
        uxd(i-1, j-1, k) = uxd(i-1, j-1, k) + tempd15
        uxd(i, j-1, k) = uxd(i, j-1, k) + tempd15
        uxd(i-1, j, k) = uxd(i-1, j, k) + tempd15
        uxd(i, j, k) = uxd(i, j, k) + tempd15
        muld = mutd + factlamheat*heatcoefd
        mued = mued + mutd + factturbheat*heatcoefd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          revd(i, j, k) = revd(i, j, k) + por*mued
          revd(i, j, k+1) = revd(i, j, k+1) + por*mued
          mued = 0.0_8
        end if
        rlvd(i, j, k) = rlvd(i, j, k) + por*muld
        rlvd(i, j, k+1) = rlvd(i, j, k+1) + por*muld
      end do
    end if
  end subroutine viscousflux_b
  subroutine viscousflux()
!
!       viscousflux computes the viscous fluxes using a central
!       difference scheme for a block.
!       it is assumed that the pointers in block pointer already point
!       to the correct block.
!
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
! possibly correct the wall shear stress.
! wall function is not aded
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
    real(kind=realtype), parameter :: xminn=1.e-14_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxxs, tauyys, tauzzs
    real(kind=realtype) :: tauxys, tauxzs, tauyzs
    real(kind=realtype) :: exx, eyy, ezz
    real(kind=realtype) :: exy, exz, eyz
    real(kind=realtype) :: wxy, wxz, wyz, wyx, wzx, wzy
    real(kind=realtype) :: den, ccr1, fact
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    logical :: correctfork, storewalltensor
    intrinsic abs
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    real(kind=realtype) :: abs0
! set qcr parameters
    ccr1 = 0.3_realtype
! set rfilv to rfil to indicate that this is the viscous part.
! if rfilv == 0 the viscous residuals need not to be computed
! and a return can be made.
    rfilv = rfil
    if (rfilv .ge. 0.) then
      abs0 = rfilv
    else
      abs0 = -rfilv
    end if
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine whether or not the wall stress tensor and wall heat
! flux must be stored for viscous walls.
      storewalltensor = .false.
      if (wallfunctions) then
        storewalltensor = .true.
      else if (rkstage .eq. 0 .and. currentlevel .eq. groundlevel) then
        storewalltensor = .true.
      end if
!
!         viscous fluxes in the k-direction.
!
      mue = zero
      do ii=0,nx*ny*kl-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, ny) + 2
        k = ii/(nx*ny) + 1
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
        por = half*rfilv
        if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
        mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
        if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j, k+1))
        mut = mul + mue
        gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
        factlamheat = one/(prandtl*gm1)
        factturbheat = one/(prandtlturb*gm1)
        heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
        u_x = fourth*(ux(i-1, j-1, k)+ux(i, j-1, k)+ux(i-1, j, k)+ux(i, &
&         j, k))
        u_y = fourth*(uy(i-1, j-1, k)+uy(i, j-1, k)+uy(i-1, j, k)+uy(i, &
&         j, k))
        u_z = fourth*(uz(i-1, j-1, k)+uz(i, j-1, k)+uz(i-1, j, k)+uz(i, &
&         j, k))
        v_x = fourth*(vx(i-1, j-1, k)+vx(i, j-1, k)+vx(i-1, j, k)+vx(i, &
&         j, k))
        v_y = fourth*(vy(i-1, j-1, k)+vy(i, j-1, k)+vy(i-1, j, k)+vy(i, &
&         j, k))
        v_z = fourth*(vz(i-1, j-1, k)+vz(i, j-1, k)+vz(i-1, j, k)+vz(i, &
&         j, k))
        w_x = fourth*(wx(i-1, j-1, k)+wx(i, j-1, k)+wx(i-1, j, k)+wx(i, &
&         j, k))
        w_y = fourth*(wy(i-1, j-1, k)+wy(i, j-1, k)+wy(i-1, j, k)+wy(i, &
&         j, k))
        w_z = fourth*(wz(i-1, j-1, k)+wz(i, j-1, k)+wz(i-1, j, k)+wz(i, &
&         j, k))
        q_x = fourth*(qx(i-1, j-1, k)+qx(i, j-1, k)+qx(i-1, j, k)+qx(i, &
&         j, k))
        q_y = fourth*(qy(i-1, j-1, k)+qy(i, j-1, k)+qy(i-1, j, k)+qy(i, &
&         j, k))
        q_z = fourth*(qz(i-1, j-1, k)+qz(i, j-1, k)+qz(i-1, j, k)+qz(i, &
&         j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center k to cell center k+1.
        ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j, &
&         k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1, 1)+&
&         x(i, j, k+1, 1)-x(i, j, k-1, 1))
        ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j, &
&         k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1, 2)+&
&         x(i, j, k+1, 2)-x(i, j, k-1, 2))
        ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j, &
&         k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1, 3)+&
&         x(i, j, k+1, 3)-x(i, j, k-1, 3))
! determine the length of this vector and create the
! unit normal.
        ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
        ssx = ss*ssx
        ssy = ss*ssy
        ssz = ss*ssz
! correct the gradients.
        corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j, &
&         k, ivx))*ss
        u_x = u_x - corr*ssx
        u_y = u_y - corr*ssy
        u_z = u_z - corr*ssz
        corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j, &
&         k, ivy))*ss
        v_x = v_x - corr*ssx
        v_y = v_y - corr*ssy
        v_z = v_z - corr*ssz
        corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j, &
&         k, ivz))*ss
        w_x = w_x - corr*ssx
        w_y = w_y - corr*ssy
        w_z = w_z - corr*ssz
        corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j, k+1)-aa(i, j, k))&
&         *ss
        q_x = q_x - corr*ssx
        q_y = q_y - corr*ssy
        q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
! we remove the viscosity from the stress tensor (tau)
! to define taus since we still need to separate between
! laminar and turbulent stress for qcr.
! therefore, laminar tau = mue*taus, turbulent
! tau = mue*taus, and total tau = mut*taus.
        fracdiv = twothird*(u_x+v_y+w_z)
        tauxxs = two*u_x - fracdiv
        tauyys = two*v_y - fracdiv
        tauzzs = two*w_z - fracdiv
        tauxys = u_y + v_x
        tauxzs = u_z + w_x
        tauyzs = v_z + w_y
        q_x = heatcoef*q_x
        q_y = heatcoef*q_y
        q_z = heatcoef*q_z
! add qcr corrections if necessary
        if (useqcr) then
! in the qcr formulation, we add an extra term to the turbulent stress tensor:
!
! tau_ij,qcr = tau_ij - e_ij
!
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
!
! remember that the tau_ij in e_ij should use only the eddy viscosity!
! compute denominator
          den = sqrt(u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&           v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z)
          if (den .lt. xminn) then
            den = xminn
          else
            den = den
          end if
! compute factor that will multiply all tensor components.
! here we add the eddy viscosity that should multiply the stress tensor (tau)
! components as well.
          fact = mue*ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
! the diagonals of the vorticity tensor components are always zero
          wxy = u_y - v_x
          wxz = u_z - w_x
          wyz = v_z - w_y
          wyx = -wxy
          wzx = -wxz
          wzy = -wyz
! compute the extra terms of the boussinesq relation
          exx = fact*(wxy*tauxys+wxz*tauxzs)*two
          eyy = fact*(wyx*tauxys+wyz*tauyzs)*two
          ezz = fact*(wzx*tauxzs+wzy*tauyzs)*two
          exy = fact*(wxy*tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)
          exz = fact*(wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)
          eyz = fact*(wyx*tauxzs+wyz*tauzzs+wzx*tauxys+wzy*tauyys)
! apply the total viscosity to the stress tensor and add extra terms
          tauxx = mut*tauxxs - exx
          tauyy = mut*tauyys - eyy
          tauzz = mut*tauzzs - ezz
          tauxy = mut*tauxys - exy
          tauxz = mut*tauxzs - exz
          tauyz = mut*tauyzs - eyz
        else
! just apply the total viscosity to the stress tensor
          tauxx = mut*tauxxs
          tauyy = mut*tauyys
          tauzz = mut*tauzzs
          tauxy = mut*tauxys
          tauxz = mut*tauxzs
          tauyz = mut*tauyzs
        end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
        ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
        vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
        wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this k-face.
        fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i, &
&         j, k, 3)
        fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i, &
&         j, k, 3)
        fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i, &
&         j, k, 3)
        frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1)
        frhoe = frhoe + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k, 2&
&         )
        frhoe = frhoe + (ubar*tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k, 3&
&         )
        frhoe = frhoe - q_x*sk(i, j, k, 1) - q_y*sk(i, j, k, 2) - q_z*sk&
&         (i, j, k, 3)
! update the residuals of cell k and k+1.
        fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
        fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
        fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
        fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
        fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
        fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
        fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases k == 1
! and k == kl must be tested.
        if (k .eq. 1 .and. storewalltensor .and. visckminpointer(i, j) &
&           .gt. 0) then
! we need to index viscsubface with visckminpointer(i,j)
! since tapenade does not like temporary indexes
          viscsubface(visckminpointer(i, j))%tau(i, j, 1) = tauxx
          viscsubface(visckminpointer(i, j))%tau(i, j, 2) = tauyy
          viscsubface(visckminpointer(i, j))%tau(i, j, 3) = tauzz
          viscsubface(visckminpointer(i, j))%tau(i, j, 4) = tauxy
          viscsubface(visckminpointer(i, j))%tau(i, j, 5) = tauxz
          viscsubface(visckminpointer(i, j))%tau(i, j, 6) = tauyz
          viscsubface(visckminpointer(i, j))%q(i, j, 1) = q_x
          viscsubface(visckminpointer(i, j))%q(i, j, 2) = q_y
          viscsubface(visckminpointer(i, j))%q(i, j, 3) = q_z
        end if
! and the k == kl case.
        if (k .eq. kl .and. storewalltensor .and. visckmaxpointer(i, j) &
&           .gt. 0) then
          viscsubface(visckmaxpointer(i, j))%tau(i, j, 1) = tauxx
          viscsubface(visckmaxpointer(i, j))%tau(i, j, 2) = tauyy
          viscsubface(visckmaxpointer(i, j))%tau(i, j, 3) = tauzz
          viscsubface(visckmaxpointer(i, j))%tau(i, j, 4) = tauxy
          viscsubface(visckmaxpointer(i, j))%tau(i, j, 5) = tauxz
          viscsubface(visckmaxpointer(i, j))%tau(i, j, 6) = tauyz
          viscsubface(visckmaxpointer(i, j))%q(i, j, 1) = q_x
          viscsubface(visckmaxpointer(i, j))%q(i, j, 2) = q_y
          viscsubface(visckmaxpointer(i, j))%q(i, j, 3) = q_z
        end if
      end do
!
!         viscous fluxes in the j-direction.
!
      continue
      mue = zero
      do ii=0,nx*jl*nz-1
        i = mod(ii, nx) + 2
        j = mod(ii/nx, jl) + 1
        k = ii/(nx*jl) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
        por = half*rfilv
        if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
        mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
        if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j+1, k))
        mut = mul + mue
        gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
        factlamheat = one/(prandtl*gm1)
        factturbheat = one/(prandtlturb*gm1)
        heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
        u_x = fourth*(ux(i-1, j, k-1)+ux(i, j, k-1)+ux(i-1, j, k)+ux(i, &
&         j, k))
        u_y = fourth*(uy(i-1, j, k-1)+uy(i, j, k-1)+uy(i-1, j, k)+uy(i, &
&         j, k))
        u_z = fourth*(uz(i-1, j, k-1)+uz(i, j, k-1)+uz(i-1, j, k)+uz(i, &
&         j, k))
        v_x = fourth*(vx(i-1, j, k-1)+vx(i, j, k-1)+vx(i-1, j, k)+vx(i, &
&         j, k))
        v_y = fourth*(vy(i-1, j, k-1)+vy(i, j, k-1)+vy(i-1, j, k)+vy(i, &
&         j, k))
        v_z = fourth*(vz(i-1, j, k-1)+vz(i, j, k-1)+vz(i-1, j, k)+vz(i, &
&         j, k))
        w_x = fourth*(wx(i-1, j, k-1)+wx(i, j, k-1)+wx(i-1, j, k)+wx(i, &
&         j, k))
        w_y = fourth*(wy(i-1, j, k-1)+wy(i, j, k-1)+wy(i-1, j, k)+wy(i, &
&         j, k))
        w_z = fourth*(wz(i-1, j, k-1)+wz(i, j, k-1)+wz(i-1, j, k)+wz(i, &
&         j, k))
        q_x = fourth*(qx(i-1, j, k-1)+qx(i, j, k-1)+qx(i-1, j, k)+qx(i, &
&         j, k))
        q_y = fourth*(qy(i-1, j, k-1)+qy(i, j, k-1)+qy(i-1, j, k)+qy(i, &
&         j, k))
        q_z = fourth*(qz(i-1, j, k-1)+qz(i, j, k-1)+qz(i-1, j, k)+qz(i, &
&         j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center j to cell center j+1.
        ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j+1&
&         , k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1, 1)+&
&         x(i, j+1, k, 1)-x(i, j-1, k, 1))
        ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j+1&
&         , k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1, 2)+&
&         x(i, j+1, k, 2)-x(i, j-1, k, 2))
        ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j+1&
&         , k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1, 3)+&
&         x(i, j+1, k, 3)-x(i, j-1, k, 3))
! determine the length of this vector and create the
! unit normal.
        ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
        ssx = ss*ssx
        ssy = ss*ssy
        ssz = ss*ssz
! correct the gradients.
        corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j, &
&         k, ivx))*ss
        u_x = u_x - corr*ssx
        u_y = u_y - corr*ssy
        u_z = u_z - corr*ssz
        corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j, &
&         k, ivy))*ss
        v_x = v_x - corr*ssx
        v_y = v_y - corr*ssy
        v_z = v_z - corr*ssz
        corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j, &
&         k, ivz))*ss
        w_x = w_x - corr*ssx
        w_y = w_y - corr*ssy
        w_z = w_z - corr*ssz
        corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j+1, k)-aa(i, j, k))&
&         *ss
        q_x = q_x - corr*ssx
        q_y = q_y - corr*ssy
        q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
! we remove the viscosity from the stress tensor (tau)
! to define taus since we still need to separate between
! laminar and turbulent stress for qcr.
! therefore, laminar tau = mue*taus, turbulent
! tau = mue*taus, and total tau = mut*taus.
        fracdiv = twothird*(u_x+v_y+w_z)
        tauxxs = two*u_x - fracdiv
        tauyys = two*v_y - fracdiv
        tauzzs = two*w_z - fracdiv
        tauxys = u_y + v_x
        tauxzs = u_z + w_x
        tauyzs = v_z + w_y
        q_x = heatcoef*q_x
        q_y = heatcoef*q_y
        q_z = heatcoef*q_z
! add qcr corrections if necessary
        if (useqcr) then
! in the qcr formulation, we add an extra term to the turbulent stress tensor:
!
! tau_ij,qcr = tau_ij - e_ij
!
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
!
! remember that the tau_ij in e_ij should use only the eddy viscosity!
! compute denominator
          den = sqrt(u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&           v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z)
          if (den .lt. xminn) then
            den = xminn
          else
            den = den
          end if
! compute factor that will multiply all tensor components.
! here we add the eddy viscosity that should multiply the stress tensor (tau)
! components as well.
          fact = mue*ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
! the diagonals of the vorticity tensor components are always zero
          wxy = u_y - v_x
          wxz = u_z - w_x
          wyz = v_z - w_y
          wyx = -wxy
          wzx = -wxz
          wzy = -wyz
! compute the extra terms of the boussinesq relation
          exx = fact*(wxy*tauxys+wxz*tauxzs)*two
          eyy = fact*(wyx*tauxys+wyz*tauyzs)*two
          ezz = fact*(wzx*tauxzs+wzy*tauyzs)*two
          exy = fact*(wxy*tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)
          exz = fact*(wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)
          eyz = fact*(wyx*tauxzs+wyz*tauzzs+wzx*tauxys+wzy*tauyys)
! apply the total viscosity to the stress tensor and add extra terms
          tauxx = mut*tauxxs - exx
          tauyy = mut*tauyys - eyy
          tauzz = mut*tauzzs - ezz
          tauxy = mut*tauxys - exy
          tauxz = mut*tauxzs - exz
          tauyz = mut*tauyzs - eyz
        else
! just apply the total viscosity to the stress tensor
          tauxx = mut*tauxxs
          tauyy = mut*tauyys
          tauzz = mut*tauzzs
          tauxy = mut*tauxys
          tauxz = mut*tauxzs
          tauyz = mut*tauyzs
        end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
        ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
        vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
        wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
        fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i, &
&         j, k, 3)
        fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i, &
&         j, k, 3)
        fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i, &
&         j, k, 3)
        frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
&         ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*tauxz&
&         +vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k, 1) - &
&         q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
! update the residuals of cell j and j+1.
        fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
        fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
        fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
        fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
        fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
        fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
        fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases j == 1
! and j == jl must be tested.
        if (j .eq. 1 .and. storewalltensor .and. viscjminpointer(i, k) &
&           .gt. 0) then
! we need to index viscsubface with viscjminpointer(i,k)
! since tapenade does not like temporary indexes
          viscsubface(viscjminpointer(i, k))%tau(i, k, 1) = tauxx
          viscsubface(viscjminpointer(i, k))%tau(i, k, 2) = tauyy
          viscsubface(viscjminpointer(i, k))%tau(i, k, 3) = tauzz
          viscsubface(viscjminpointer(i, k))%tau(i, k, 4) = tauxy
          viscsubface(viscjminpointer(i, k))%tau(i, k, 5) = tauxz
          viscsubface(viscjminpointer(i, k))%tau(i, k, 6) = tauyz
          viscsubface(viscjminpointer(i, k))%q(i, k, 1) = q_x
          viscsubface(viscjminpointer(i, k))%q(i, k, 2) = q_y
          viscsubface(viscjminpointer(i, k))%q(i, k, 3) = q_z
        end if
! and the j == jl case.
        if (j .eq. jl .and. storewalltensor .and. viscjmaxpointer(i, k) &
&           .gt. 0) then
          viscsubface(viscjmaxpointer(i, k))%tau(i, k, 1) = tauxx
          viscsubface(viscjmaxpointer(i, k))%tau(i, k, 2) = tauyy
          viscsubface(viscjmaxpointer(i, k))%tau(i, k, 3) = tauzz
          viscsubface(viscjmaxpointer(i, k))%tau(i, k, 4) = tauxy
          viscsubface(viscjmaxpointer(i, k))%tau(i, k, 5) = tauxz
          viscsubface(viscjmaxpointer(i, k))%tau(i, k, 6) = tauyz
          viscsubface(viscjmaxpointer(i, k))%q(i, k, 1) = q_x
          viscsubface(viscjmaxpointer(i, k))%q(i, k, 2) = q_y
          viscsubface(viscjmaxpointer(i, k))%q(i, k, 3) = q_z
        end if
      end do
!
!         viscous fluxes in the i-direction.
!
      continue
      mue = zero
      do ii=0,il*ny*nz-1
        i = mod(ii, il) + 1
        j = mod(ii/il, ny) + 2
        k = ii/(il*ny) + 2
! set the value of the porosity. if not zero, it is set
! to average the eddy-viscosity and to take the factor
! rfilv into account.
        por = half*rfilv
        if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
        mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
        if (eddymodel) mue = por*(rev(i, j, k)+rev(i+1, j, k))
        mut = mul + mue
        gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
        factlamheat = one/(prandtl*gm1)
        factturbheat = one/(prandtlturb*gm1)
        heatcoef = mul*factlamheat + mue*factturbheat
! compute the gradients at the face by averaging the four
! nodal values.
        u_x = fourth*(ux(i, j-1, k-1)+ux(i, j, k-1)+ux(i, j-1, k)+ux(i, &
&         j, k))
        u_y = fourth*(uy(i, j-1, k-1)+uy(i, j, k-1)+uy(i, j-1, k)+uy(i, &
&         j, k))
        u_z = fourth*(uz(i, j-1, k-1)+uz(i, j, k-1)+uz(i, j-1, k)+uz(i, &
&         j, k))
        v_x = fourth*(vx(i, j-1, k-1)+vx(i, j, k-1)+vx(i, j-1, k)+vx(i, &
&         j, k))
        v_y = fourth*(vy(i, j-1, k-1)+vy(i, j, k-1)+vy(i, j-1, k)+vy(i, &
&         j, k))
        v_z = fourth*(vz(i, j-1, k-1)+vz(i, j, k-1)+vz(i, j-1, k)+vz(i, &
&         j, k))
        w_x = fourth*(wx(i, j-1, k-1)+wx(i, j, k-1)+wx(i, j-1, k)+wx(i, &
&         j, k))
        w_y = fourth*(wy(i, j-1, k-1)+wy(i, j, k-1)+wy(i, j-1, k)+wy(i, &
&         j, k))
        w_z = fourth*(wz(i, j-1, k-1)+wz(i, j, k-1)+wz(i, j-1, k)+wz(i, &
&         j, k))
        q_x = fourth*(qx(i, j-1, k-1)+qx(i, j, k-1)+qx(i, j-1, k)+qx(i, &
&         j, k))
        q_y = fourth*(qy(i, j-1, k-1)+qy(i, j, k-1)+qy(i, j-1, k)+qy(i, &
&         j, k))
        q_z = fourth*(qz(i, j-1, k-1)+qz(i, j, k-1)+qz(i, j-1, k)+qz(i, &
&         j, k))
! the gradients in the normal direction are corrected, such
! that no averaging takes places here.
! first determine the vector in the direction from the
! cell center i to cell center i+1.
        ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j-1&
&         , k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1, 1)+&
&         x(i+1, j, k, 1)-x(i-1, j, k, 1))
        ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j-1&
&         , k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1, 2)+&
&         x(i+1, j, k, 2)-x(i-1, j, k, 2))
        ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j-1&
&         , k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1, 3)+&
&         x(i+1, j, k, 3)-x(i-1, j, k, 3))
! determine the length of this vector and create the
! unit normal.
        ss = one/sqrt(ssx*ssx+ssy*ssy+ssz*ssz)
        ssx = ss*ssx
        ssy = ss*ssy
        ssz = ss*ssz
! correct the gradients.
        corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j, &
&         k, ivx))*ss
        u_x = u_x - corr*ssx
        u_y = u_y - corr*ssy
        u_z = u_z - corr*ssz
        corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j, &
&         k, ivy))*ss
        v_x = v_x - corr*ssx
        v_y = v_y - corr*ssy
        v_z = v_z - corr*ssz
        corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j, &
&         k, ivz))*ss
        w_x = w_x - corr*ssx
        w_y = w_y - corr*ssy
        w_z = w_z - corr*ssz
        corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i+1, j, k)-aa(i, j, k))&
&         *ss
        q_x = q_x - corr*ssx
        q_y = q_y - corr*ssy
        q_z = q_z - corr*ssz
! compute the stress tensor and the heat flux vector.
! we remove the viscosity from the stress tensor (tau)
! to define taus since we still need to separate between
! laminar and turbulent stress for qcr.
! therefore, laminar tau = mue*taus, turbulent
! tau = mue*taus, and total tau = mut*taus.
        fracdiv = twothird*(u_x+v_y+w_z)
        tauxxs = two*u_x - fracdiv
        tauyys = two*v_y - fracdiv
        tauzzs = two*w_z - fracdiv
        tauxys = u_y + v_x
        tauxzs = u_z + w_x
        tauyzs = v_z + w_y
        q_x = heatcoef*q_x
        q_y = heatcoef*q_y
        q_z = heatcoef*q_z
! add qcr corrections if necessary
        if (useqcr) then
! in the qcr formulation, we add an extra term to the turbulent stress tensor:
!
! tau_ij,qcr = tau_ij - e_ij
!
! where, according to tmr website (http://turbmodels.larc.nasa.gov/spalart.html):
!
! e_ij = ccr1*(o_ik*tau_jk + o_jk*tau_ik)
!
! we are computing o_ik as follows:
!
! o_ik = 2*w_ik/den
!
! remember that the tau_ij in e_ij should use only the eddy viscosity!
! compute denominator
          den = sqrt(u_x*u_x + u_y*u_y + u_z*u_z + v_x*v_x + v_y*v_y + &
&           v_z*v_z + w_x*w_x + w_y*w_y + w_z*w_z)
          if (den .lt. xminn) then
            den = xminn
          else
            den = den
          end if
! compute factor that will multiply all tensor components.
! here we add the eddy viscosity that should multiply the stress tensor (tau)
! components as well.
          fact = mue*ccr1/den
! compute off-diagonal terms of vorticity tensor (we will ommit the 1/2)
! the diagonals of the vorticity tensor components are always zero
          wxy = u_y - v_x
          wxz = u_z - w_x
          wyz = v_z - w_y
          wyx = -wxy
          wzx = -wxz
          wzy = -wyz
! compute the extra terms of the boussinesq relation
          exx = fact*(wxy*tauxys+wxz*tauxzs)*two
          eyy = fact*(wyx*tauxys+wyz*tauyzs)*two
          ezz = fact*(wzx*tauxzs+wzy*tauyzs)*two
          exy = fact*(wxy*tauyys+wxz*tauyzs+wyx*tauxxs+wyz*tauxzs)
          exz = fact*(wxy*tauyzs+wxz*tauzzs+wzx*tauxxs+wzy*tauxys)
          eyz = fact*(wyx*tauxzs+wyz*tauzzs+wzx*tauxys+wzy*tauyys)
! apply the total viscosity to the stress tensor and add extra terms
          tauxx = mut*tauxxs - exx
          tauyy = mut*tauyys - eyy
          tauzz = mut*tauzzs - ezz
          tauxy = mut*tauxys - exy
          tauxz = mut*tauxzs - exz
          tauyz = mut*tauyzs - eyz
        else
! just apply the total viscosity to the stress tensor
          tauxx = mut*tauxxs
          tauyy = mut*tauyys
          tauzz = mut*tauzzs
          tauxy = mut*tauxys
          tauxz = mut*tauxzs
          tauyz = mut*tauyzs
        end if
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
        ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
        vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
        wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
        fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i, &
&         j, k, 3)
        fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i, &
&         j, k, 3)
        fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i, &
&         j, k, 3)
        frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
&         ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*tauxz&
&         +vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k, 1) - &
&         q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
! update the residuals of cell i and i+1.
        fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
        fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
        fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
        fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
        fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
        fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
        fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
        fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
! store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. both the cases i == 1
! and i == il must be tested.
        if (i .eq. 1 .and. storewalltensor .and. visciminpointer(j, k) &
&           .gt. 0) then
! we need to index viscsubface with visciminpointer(j,k)
! since tapenade does not like temporary indexes
          viscsubface(visciminpointer(j, k))%tau(j, k, 1) = tauxx
          viscsubface(visciminpointer(j, k))%tau(j, k, 2) = tauyy
          viscsubface(visciminpointer(j, k))%tau(j, k, 3) = tauzz
          viscsubface(visciminpointer(j, k))%tau(j, k, 4) = tauxy
          viscsubface(visciminpointer(j, k))%tau(j, k, 5) = tauxz
          viscsubface(visciminpointer(j, k))%tau(j, k, 6) = tauyz
          viscsubface(visciminpointer(j, k))%q(j, k, 1) = q_x
          viscsubface(visciminpointer(j, k))%q(j, k, 2) = q_y
          viscsubface(visciminpointer(j, k))%q(j, k, 3) = q_z
        end if
! and the i == il case.
        if (i .eq. il .and. storewalltensor .and. viscimaxpointer(j, k) &
&           .gt. 0) then
! we need to index viscsubface with viscimaxpointer(j,k)
! since tapenade does not like temporary indexes
          viscsubface(viscimaxpointer(j, k))%tau(j, k, 1) = tauxx
          viscsubface(viscimaxpointer(j, k))%tau(j, k, 2) = tauyy
          viscsubface(viscimaxpointer(j, k))%tau(j, k, 3) = tauzz
          viscsubface(viscimaxpointer(j, k))%tau(j, k, 4) = tauxy
          viscsubface(viscimaxpointer(j, k))%tau(j, k, 5) = tauxz
          viscsubface(viscimaxpointer(j, k))%tau(j, k, 6) = tauyz
          viscsubface(viscimaxpointer(j, k))%q(j, k, 1) = q_x
          viscsubface(viscimaxpointer(j, k))%q(j, k, 2) = q_y
          viscsubface(viscimaxpointer(j, k))%q(j, k, 3) = q_z
        end if
      end do
    end if
  end subroutine viscousflux
!  differentiation of viscousfluxapprox in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *w *x *fw
!   with respect to varying inputs: *rev *aa *w *rlv *x *fw
!   rw status of diff variables: *rev:out *aa:out *w:incr *rlv:out
!                *x:incr *fw:in-out
!   plus diff mem management of: rev:in aa:in w:in rlv:in x:in
!                fw:in
  subroutine viscousfluxapprox_b()
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    integer(kind=inttype) :: ii, jj, kk
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: muld, mued, mutd, heatcoefd
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, &
&   w_yd, w_zd
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: ssxd, ssyd, sszd, ssd, fracdivd
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxxd, tauyyd, tauzzd
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: tauxyd, tauxzd, tauyzd
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    real(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
    real(kind=realtype) :: dd
    real(kind=realtype) :: ddd
    logical :: correctfork
    integer :: branch
    real(kind=realtype) :: tempd14
    real(kind=realtype) :: tempd13
    real(kind=realtype) :: tempd12
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd11
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd22
    real(kind=realtype) :: tempd21
    real(kind=realtype) :: tempd20
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd19
    real(kind=realtype) :: tempd18
    real(kind=realtype) :: tempd17
    real(kind=realtype) :: tempd16
    real(kind=realtype) :: tempd15
    mue = zero
    rfilv = rfil
! viscous fluxes in the i-direction
    do k=2,kl
      do j=2,jl
        do i=1,il
! compute the vector from the center of cell i to cell i+1
          call pushreal8(ssx)
          ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
&           -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
&           , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
          call pushreal8(ssy)
          ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
&           -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
&           , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
          call pushreal8(ssz)
          ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
&           -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
&           , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
! and determine one/ length of vector squared
          call pushreal8(ss)
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          call pushreal8(ssx)
          ssx = ss*ssx
          call pushreal8(ssy)
          ssy = ss*ssy
          call pushreal8(ssz)
          ssz = ss*ssz
! now compute each gradient
          dd = w(i+1, j, k, ivx) - w(i, j, k, ivx)
          call pushreal8(u_x)
          u_x = dd*ssx
          call pushreal8(u_y)
          u_y = dd*ssy
          call pushreal8(u_z)
          u_z = dd*ssz
          dd = w(i+1, j, k, ivy) - w(i, j, k, ivy)
          call pushreal8(v_x)
          v_x = dd*ssx
          call pushreal8(v_y)
          v_y = dd*ssy
          call pushreal8(v_z)
          v_z = dd*ssz
          dd = w(i+1, j, k, ivz) - w(i, j, k, ivz)
          call pushreal8(w_x)
          w_x = dd*ssx
          call pushreal8(w_y)
          w_y = dd*ssy
          call pushreal8(w_z)
          w_z = dd*ssz
          dd = aa(i+1, j, k) - aa(i, j, k)
          call pushreal8(q_x)
          q_x = -(dd*ssx)
          call pushreal8(q_y)
          q_y = -(dd*ssy)
          call pushreal8(q_z)
          q_z = -(dd*ssz)
          call pushreal8(por)
          por = half*rfilv
          if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
          if (eddymodel) then
            mue = por*(rev(i, j, k)+rev(i+1, j, k))
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
          end if
          call pushreal8(mut)
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          call pushreal8(heatcoef)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          call pushreal8(fracdiv)
          fracdiv = twothird*(u_x+v_y+w_z)
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
! compute the viscous fluxes for this i-face.
! update the residuals of cell i and i+1.
        end do
      end do
    end do
! viscous fluxes in the j-direction
    do k=2,kl
      do j=1,jl
        do i=2,il
! compute the vector from the center of cell j to cell j+1
          call pushreal8(ssx)
          ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
          call pushreal8(ssy)
          ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
          call pushreal8(ssz)
          ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
! and determine one/ length of vector squared
          call pushreal8(ss)
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          call pushreal8(ssx)
          ssx = ss*ssx
          call pushreal8(ssy)
          ssy = ss*ssy
          call pushreal8(ssz)
          ssz = ss*ssz
! now compute each gradient
          dd = w(i, j+1, k, ivx) - w(i, j, k, ivx)
          call pushreal8(u_x)
          u_x = dd*ssx
          call pushreal8(u_y)
          u_y = dd*ssy
          call pushreal8(u_z)
          u_z = dd*ssz
          dd = w(i, j+1, k, ivy) - w(i, j, k, ivy)
          call pushreal8(v_x)
          v_x = dd*ssx
          call pushreal8(v_y)
          v_y = dd*ssy
          call pushreal8(v_z)
          v_z = dd*ssz
          dd = w(i, j+1, k, ivz) - w(i, j, k, ivz)
          call pushreal8(w_x)
          w_x = dd*ssx
          call pushreal8(w_y)
          w_y = dd*ssy
          call pushreal8(w_z)
          w_z = dd*ssz
          dd = aa(i, j+1, k) - aa(i, j, k)
          call pushreal8(q_x)
          q_x = -(dd*ssx)
          call pushreal8(q_y)
          q_y = -(dd*ssy)
          call pushreal8(q_z)
          q_z = -(dd*ssz)
          call pushreal8(por)
          por = half*rfilv
          if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
          if (eddymodel) then
            mue = por*(rev(i, j, k)+rev(i, j+1, k))
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
          end if
          call pushreal8(mut)
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          call pushreal8(heatcoef)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          call pushreal8(fracdiv)
          fracdiv = twothird*(u_x+v_y+w_z)
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
! compute the viscous fluxes for this j-face.
! update the residuals of cell j and j+1.
        end do
      end do
    end do
! viscous fluxes in the k-direction
    do k=1,kl
      do j=2,jl
        do i=2,il
! compute the vector from the center of cell k to cell k+1
          call pushreal8(ssx)
          ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
          call pushreal8(ssy)
          ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
          call pushreal8(ssz)
          ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
! and determine one/ length of vector squared
          call pushreal8(ss)
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          call pushreal8(ssx)
          ssx = ss*ssx
          call pushreal8(ssy)
          ssy = ss*ssy
          call pushreal8(ssz)
          ssz = ss*ssz
! now compute each gradient
          dd = w(i, j, k+1, ivx) - w(i, j, k, ivx)
          call pushreal8(u_x)
          u_x = dd*ssx
          call pushreal8(u_y)
          u_y = dd*ssy
          call pushreal8(u_z)
          u_z = dd*ssz
          dd = w(i, j, k+1, ivy) - w(i, j, k, ivy)
          call pushreal8(v_x)
          v_x = dd*ssx
          call pushreal8(v_y)
          v_y = dd*ssy
          call pushreal8(v_z)
          v_z = dd*ssz
          dd = w(i, j, k+1, ivz) - w(i, j, k, ivz)
          call pushreal8(w_x)
          w_x = dd*ssx
          call pushreal8(w_y)
          w_y = dd*ssy
          call pushreal8(w_z)
          w_z = dd*ssz
          dd = aa(i, j, k+1) - aa(i, j, k)
          call pushreal8(q_x)
          q_x = -(dd*ssx)
          call pushreal8(q_y)
          q_y = -(dd*ssy)
          call pushreal8(q_z)
          q_z = -(dd*ssz)
          call pushreal8(por)
          por = half*rfilv
          if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
          if (eddymodel) then
            mue = por*(rev(i, j, k)+rev(i, j, k+1))
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
          end if
          call pushreal8(mut)
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          call pushreal8(heatcoef)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          call pushreal8(fracdiv)
          fracdiv = twothird*(u_x+v_y+w_z)
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
! compute the viscous fluxes for this j-face.
! update the residuals of cell j and j+1.
        end do
      end do
    end do
    revd = 0.0_8
    aad = 0.0_8
    rlvd = 0.0_8
    mued = 0.0_8
    do k=kl,1,-1
      do j=jl,2,-1
        do i=il,2,-1
          frhoed = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
          fmzd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
          fmyd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
          fmxd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
          tauzz = mut*(two*w_z-fracdiv)
          wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
          vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
          tauxx = mut*(two*u_x-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
          tauyy = mut*(two*v_y-fracdiv)
          tauyz = mut*(v_z+w_y)
          tempd19 = sk(i, j, k, 1)*frhoed
          tempd20 = sk(i, j, k, 2)*frhoed
          tempd21 = sk(i, j, k, 3)*frhoed
          ubard = tauxz*tempd21 + tauxy*tempd20 + tauxx*tempd19
          tauxxd = sk(i, j, k, 1)*fmxd + ubar*tempd19
          vbard = tauyz*tempd21 + tauyy*tempd20 + tauxy*tempd19
          tauxyd = sk(i, j, k, 1)*fmyd + sk(i, j, k, 2)*fmxd + ubar*&
&           tempd20 + vbar*tempd19
          wbard = tauzz*tempd21 + tauyz*tempd20 + tauxz*tempd19
          tauxzd = sk(i, j, k, 1)*fmzd + sk(i, j, k, 3)*fmxd + ubar*&
&           tempd21 + wbar*tempd19
          tauyyd = sk(i, j, k, 2)*fmyd + vbar*tempd20
          tauyzd = sk(i, j, k, 2)*fmzd + sk(i, j, k, 3)*fmyd + vbar*&
&           tempd21 + wbar*tempd20
          tauzzd = sk(i, j, k, 3)*fmzd + wbar*tempd21
          q_xd = -(sk(i, j, k, 1)*frhoed)
          q_yd = -(sk(i, j, k, 2)*frhoed)
          q_zd = -(sk(i, j, k, 3)*frhoed)
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
          wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wbard
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
          wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vbard
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
          wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*ubard
          dd = aa(i, j, k+1) - aa(i, j, k)
          heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
          q_zd = heatcoef*q_zd
          q_yd = heatcoef*q_yd
          q_xd = heatcoef*q_xd
          mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&           fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*&
&           tauxyd + (v_z+w_y)*tauyzd
          v_zd = mut*tauyzd
          w_yd = mut*tauyzd
          u_zd = mut*tauxzd
          w_xd = mut*tauxzd
          u_yd = mut*tauxyd
          v_xd = mut*tauxyd
          fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
          call popreal8(fracdiv)
          tempd22 = twothird*fracdivd
          w_zd = tempd22 + mut*two*tauzzd
          v_yd = tempd22 + mut*two*tauyyd
          u_xd = tempd22 + mut*two*tauxxd
          gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          call popreal8(heatcoef)
          muld = mutd + factlamheat*heatcoefd
          mued = mued + mutd + factturbheat*heatcoefd
          call popreal8(mut)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            revd(i, j, k) = revd(i, j, k) + por*mued
            revd(i, j, k+1) = revd(i, j, k+1) + por*mued
            mued = 0.0_8
          end if
          rlvd(i, j, k) = rlvd(i, j, k) + por*muld
          rlvd(i, j, k+1) = rlvd(i, j, k+1) + por*muld
          call popreal8(por)
          call popreal8(q_z)
          ddd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
          sszd = -(dd*q_zd)
          call popreal8(q_y)
          ssyd = -(dd*q_yd)
          call popreal8(q_x)
          ssxd = -(dd*q_xd)
          aad(i, j, k+1) = aad(i, j, k+1) + ddd
          aad(i, j, k) = aad(i, j, k) - ddd
          dd = w(i, j, k+1, ivz) - w(i, j, k, ivz)
          call popreal8(w_z)
          ddd = ssy*w_yd + ssx*w_xd + ssz*w_zd
          sszd = sszd + dd*w_zd
          call popreal8(w_y)
          ssyd = ssyd + dd*w_yd
          call popreal8(w_x)
          ssxd = ssxd + dd*w_xd
          wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + ddd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddd
          dd = w(i, j, k+1, ivy) - w(i, j, k, ivy)
          call popreal8(v_z)
          ddd = ssy*v_yd + ssx*v_xd + ssz*v_zd
          sszd = sszd + dd*v_zd
          call popreal8(v_y)
          ssyd = ssyd + dd*v_yd
          call popreal8(v_x)
          ssxd = ssxd + dd*v_xd
          wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + ddd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddd
          dd = w(i, j, k+1, ivx) - w(i, j, k, ivx)
          call popreal8(u_z)
          ddd = ssy*u_yd + ssx*u_xd + ssz*u_zd
          sszd = sszd + dd*u_zd
          call popreal8(u_y)
          ssyd = ssyd + dd*u_yd
          call popreal8(u_x)
          ssxd = ssxd + dd*u_xd
          wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + ddd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddd
          call popreal8(ssz)
          call popreal8(ssy)
          call popreal8(ssx)
          ssd = ssy*ssyd + ssx*ssxd + ssz*sszd
          temp1 = ssx**2 + ssy**2 + ssz**2
          tempd15 = -(one*ssd/temp1**2)
          sszd = 2*ssz*tempd15 + ss*sszd
          ssyd = 2*ssy*tempd15 + ss*ssyd
          ssxd = 2*ssx*tempd15 + ss*ssxd
          call popreal8(ss)
          call popreal8(ssz)
          tempd16 = eighth*sszd
          xd(i-1, j-1, k+1, 3) = xd(i-1, j-1, k+1, 3) + tempd16
          xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd16
          xd(i-1, j, k+1, 3) = xd(i-1, j, k+1, 3) + tempd16
          xd(i-1, j, k-1, 3) = xd(i-1, j, k-1, 3) - tempd16
          xd(i, j-1, k+1, 3) = xd(i, j-1, k+1, 3) + tempd16
          xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) - tempd16
          xd(i, j, k+1, 3) = xd(i, j, k+1, 3) + tempd16
          xd(i, j, k-1, 3) = xd(i, j, k-1, 3) - tempd16
          call popreal8(ssy)
          tempd17 = eighth*ssyd
          xd(i-1, j-1, k+1, 2) = xd(i-1, j-1, k+1, 2) + tempd17
          xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd17
          xd(i-1, j, k+1, 2) = xd(i-1, j, k+1, 2) + tempd17
          xd(i-1, j, k-1, 2) = xd(i-1, j, k-1, 2) - tempd17
          xd(i, j-1, k+1, 2) = xd(i, j-1, k+1, 2) + tempd17
          xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) - tempd17
          xd(i, j, k+1, 2) = xd(i, j, k+1, 2) + tempd17
          xd(i, j, k-1, 2) = xd(i, j, k-1, 2) - tempd17
          call popreal8(ssx)
          tempd18 = eighth*ssxd
          xd(i-1, j-1, k+1, 1) = xd(i-1, j-1, k+1, 1) + tempd18
          xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd18
          xd(i-1, j, k+1, 1) = xd(i-1, j, k+1, 1) + tempd18
          xd(i-1, j, k-1, 1) = xd(i-1, j, k-1, 1) - tempd18
          xd(i, j-1, k+1, 1) = xd(i, j-1, k+1, 1) + tempd18
          xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) - tempd18
          xd(i, j, k+1, 1) = xd(i, j, k+1, 1) + tempd18
          xd(i, j, k-1, 1) = xd(i, j, k-1, 1) - tempd18
        end do
      end do
    end do
    do k=kl,2,-1
      do j=jl,1,-1
        do i=il,2,-1
          frhoed = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
          fmzd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
          fmyd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
          fmxd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
          tauzz = mut*(two*w_z-fracdiv)
          wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
          vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
          tauxx = mut*(two*u_x-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
          tauyy = mut*(two*v_y-fracdiv)
          tauyz = mut*(v_z+w_y)
          tempd11 = sj(i, j, k, 1)*frhoed
          tempd12 = sj(i, j, k, 2)*frhoed
          tempd13 = sj(i, j, k, 3)*frhoed
          ubard = tauxz*tempd13 + tauxy*tempd12 + tauxx*tempd11
          tauxxd = sj(i, j, k, 1)*fmxd + ubar*tempd11
          vbard = tauyz*tempd13 + tauyy*tempd12 + tauxy*tempd11
          tauxyd = sj(i, j, k, 1)*fmyd + sj(i, j, k, 2)*fmxd + ubar*&
&           tempd12 + vbar*tempd11
          wbard = tauzz*tempd13 + tauyz*tempd12 + tauxz*tempd11
          tauxzd = sj(i, j, k, 1)*fmzd + sj(i, j, k, 3)*fmxd + ubar*&
&           tempd13 + wbar*tempd11
          tauyyd = sj(i, j, k, 2)*fmyd + vbar*tempd12
          tauyzd = sj(i, j, k, 2)*fmzd + sj(i, j, k, 3)*fmyd + vbar*&
&           tempd13 + wbar*tempd12
          tauzzd = sj(i, j, k, 3)*fmzd + wbar*tempd13
          q_xd = -(sj(i, j, k, 1)*frhoed)
          q_yd = -(sj(i, j, k, 2)*frhoed)
          q_zd = -(sj(i, j, k, 3)*frhoed)
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
          wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wbard
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
          wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vbard
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
          wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*ubard
          dd = aa(i, j+1, k) - aa(i, j, k)
          heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
          q_zd = heatcoef*q_zd
          q_yd = heatcoef*q_yd
          q_xd = heatcoef*q_xd
          mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&           fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*&
&           tauxyd + (v_z+w_y)*tauyzd
          v_zd = mut*tauyzd
          w_yd = mut*tauyzd
          u_zd = mut*tauxzd
          w_xd = mut*tauxzd
          u_yd = mut*tauxyd
          v_xd = mut*tauxyd
          fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
          call popreal8(fracdiv)
          tempd14 = twothird*fracdivd
          w_zd = tempd14 + mut*two*tauzzd
          v_yd = tempd14 + mut*two*tauyyd
          u_xd = tempd14 + mut*two*tauxxd
          gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          call popreal8(heatcoef)
          muld = mutd + factlamheat*heatcoefd
          mued = mued + mutd + factturbheat*heatcoefd
          call popreal8(mut)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            revd(i, j, k) = revd(i, j, k) + por*mued
            revd(i, j+1, k) = revd(i, j+1, k) + por*mued
            mued = 0.0_8
          end if
          rlvd(i, j, k) = rlvd(i, j, k) + por*muld
          rlvd(i, j+1, k) = rlvd(i, j+1, k) + por*muld
          call popreal8(por)
          call popreal8(q_z)
          ddd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
          sszd = -(dd*q_zd)
          call popreal8(q_y)
          ssyd = -(dd*q_yd)
          call popreal8(q_x)
          ssxd = -(dd*q_xd)
          aad(i, j+1, k) = aad(i, j+1, k) + ddd
          aad(i, j, k) = aad(i, j, k) - ddd
          dd = w(i, j+1, k, ivz) - w(i, j, k, ivz)
          call popreal8(w_z)
          ddd = ssy*w_yd + ssx*w_xd + ssz*w_zd
          sszd = sszd + dd*w_zd
          call popreal8(w_y)
          ssyd = ssyd + dd*w_yd
          call popreal8(w_x)
          ssxd = ssxd + dd*w_xd
          wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + ddd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddd
          dd = w(i, j+1, k, ivy) - w(i, j, k, ivy)
          call popreal8(v_z)
          ddd = ssy*v_yd + ssx*v_xd + ssz*v_zd
          sszd = sszd + dd*v_zd
          call popreal8(v_y)
          ssyd = ssyd + dd*v_yd
          call popreal8(v_x)
          ssxd = ssxd + dd*v_xd
          wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + ddd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddd
          dd = w(i, j+1, k, ivx) - w(i, j, k, ivx)
          call popreal8(u_z)
          ddd = ssy*u_yd + ssx*u_xd + ssz*u_zd
          sszd = sszd + dd*u_zd
          call popreal8(u_y)
          ssyd = ssyd + dd*u_yd
          call popreal8(u_x)
          ssxd = ssxd + dd*u_xd
          wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + ddd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddd
          call popreal8(ssz)
          call popreal8(ssy)
          call popreal8(ssx)
          ssd = ssy*ssyd + ssx*ssxd + ssz*sszd
          temp0 = ssx**2 + ssy**2 + ssz**2
          tempd7 = -(one*ssd/temp0**2)
          sszd = 2*ssz*tempd7 + ss*sszd
          ssyd = 2*ssy*tempd7 + ss*ssyd
          ssxd = 2*ssx*tempd7 + ss*ssxd
          call popreal8(ss)
          call popreal8(ssz)
          tempd8 = eighth*sszd
          xd(i-1, j+1, k-1, 3) = xd(i-1, j+1, k-1, 3) + tempd8
          xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd8
          xd(i-1, j+1, k, 3) = xd(i-1, j+1, k, 3) + tempd8
          xd(i-1, j-1, k, 3) = xd(i-1, j-1, k, 3) - tempd8
          xd(i, j+1, k-1, 3) = xd(i, j+1, k-1, 3) + tempd8
          xd(i, j-1, k-1, 3) = xd(i, j-1, k-1, 3) - tempd8
          xd(i, j+1, k, 3) = xd(i, j+1, k, 3) + tempd8
          xd(i, j-1, k, 3) = xd(i, j-1, k, 3) - tempd8
          call popreal8(ssy)
          tempd9 = eighth*ssyd
          xd(i-1, j+1, k-1, 2) = xd(i-1, j+1, k-1, 2) + tempd9
          xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd9
          xd(i-1, j+1, k, 2) = xd(i-1, j+1, k, 2) + tempd9
          xd(i-1, j-1, k, 2) = xd(i-1, j-1, k, 2) - tempd9
          xd(i, j+1, k-1, 2) = xd(i, j+1, k-1, 2) + tempd9
          xd(i, j-1, k-1, 2) = xd(i, j-1, k-1, 2) - tempd9
          xd(i, j+1, k, 2) = xd(i, j+1, k, 2) + tempd9
          xd(i, j-1, k, 2) = xd(i, j-1, k, 2) - tempd9
          call popreal8(ssx)
          tempd10 = eighth*ssxd
          xd(i-1, j+1, k-1, 1) = xd(i-1, j+1, k-1, 1) + tempd10
          xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd10
          xd(i-1, j+1, k, 1) = xd(i-1, j+1, k, 1) + tempd10
          xd(i-1, j-1, k, 1) = xd(i-1, j-1, k, 1) - tempd10
          xd(i, j+1, k-1, 1) = xd(i, j+1, k-1, 1) + tempd10
          xd(i, j-1, k-1, 1) = xd(i, j-1, k-1, 1) - tempd10
          xd(i, j+1, k, 1) = xd(i, j+1, k, 1) + tempd10
          xd(i, j-1, k, 1) = xd(i, j-1, k, 1) - tempd10
        end do
      end do
    end do
    do k=kl,2,-1
      do j=jl,2,-1
        do i=il,1,-1
          frhoed = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
          fmzd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
          fmyd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
          fmxd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
          tauzz = mut*(two*w_z-fracdiv)
          wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
          vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
          tauxx = mut*(two*u_x-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
          tauyy = mut*(two*v_y-fracdiv)
          tauyz = mut*(v_z+w_y)
          tempd3 = si(i, j, k, 1)*frhoed
          tempd4 = si(i, j, k, 2)*frhoed
          tempd5 = si(i, j, k, 3)*frhoed
          ubard = tauxz*tempd5 + tauxy*tempd4 + tauxx*tempd3
          tauxxd = si(i, j, k, 1)*fmxd + ubar*tempd3
          vbard = tauyz*tempd5 + tauyy*tempd4 + tauxy*tempd3
          tauxyd = si(i, j, k, 1)*fmyd + si(i, j, k, 2)*fmxd + ubar*&
&           tempd4 + vbar*tempd3
          wbard = tauzz*tempd5 + tauyz*tempd4 + tauxz*tempd3
          tauxzd = si(i, j, k, 1)*fmzd + si(i, j, k, 3)*fmxd + ubar*&
&           tempd5 + wbar*tempd3
          tauyyd = si(i, j, k, 2)*fmyd + vbar*tempd4
          tauyzd = si(i, j, k, 2)*fmzd + si(i, j, k, 3)*fmyd + vbar*&
&           tempd5 + wbar*tempd4
          tauzzd = si(i, j, k, 3)*fmzd + wbar*tempd5
          q_xd = -(si(i, j, k, 1)*frhoed)
          q_yd = -(si(i, j, k, 2)*frhoed)
          q_zd = -(si(i, j, k, 3)*frhoed)
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wbard
          wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wbard
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vbard
          wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vbard
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*ubard
          wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*ubard
          dd = aa(i+1, j, k) - aa(i, j, k)
          heatcoefd = q_y*q_yd + q_x*q_xd + q_z*q_zd
          q_zd = heatcoef*q_zd
          q_yd = heatcoef*q_yd
          q_xd = heatcoef*q_xd
          mutd = (u_z+w_x)*tauxzd + (two*w_z-fracdiv)*tauzzd + (two*u_x-&
&           fracdiv)*tauxxd + (two*v_y-fracdiv)*tauyyd + (u_y+v_x)*&
&           tauxyd + (v_z+w_y)*tauyzd
          v_zd = mut*tauyzd
          w_yd = mut*tauyzd
          u_zd = mut*tauxzd
          w_xd = mut*tauxzd
          u_yd = mut*tauxyd
          v_xd = mut*tauxyd
          fracdivd = -(mut*tauyyd) - mut*tauxxd - mut*tauzzd
          call popreal8(fracdiv)
          tempd6 = twothird*fracdivd
          w_zd = tempd6 + mut*two*tauzzd
          v_yd = tempd6 + mut*two*tauyyd
          u_xd = tempd6 + mut*two*tauxxd
          gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          call popreal8(heatcoef)
          muld = mutd + factlamheat*heatcoefd
          mued = mued + mutd + factturbheat*heatcoefd
          call popreal8(mut)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            revd(i, j, k) = revd(i, j, k) + por*mued
            revd(i+1, j, k) = revd(i+1, j, k) + por*mued
            mued = 0.0_8
          end if
          rlvd(i, j, k) = rlvd(i, j, k) + por*muld
          rlvd(i+1, j, k) = rlvd(i+1, j, k) + por*muld
          call popreal8(por)
          call popreal8(q_z)
          ddd = -(ssy*q_yd) - ssx*q_xd - ssz*q_zd
          sszd = -(dd*q_zd)
          call popreal8(q_y)
          ssyd = -(dd*q_yd)
          call popreal8(q_x)
          ssxd = -(dd*q_xd)
          aad(i+1, j, k) = aad(i+1, j, k) + ddd
          aad(i, j, k) = aad(i, j, k) - ddd
          dd = w(i+1, j, k, ivz) - w(i, j, k, ivz)
          call popreal8(w_z)
          ddd = ssy*w_yd + ssx*w_xd + ssz*w_zd
          sszd = sszd + dd*w_zd
          call popreal8(w_y)
          ssyd = ssyd + dd*w_yd
          call popreal8(w_x)
          ssxd = ssxd + dd*w_xd
          wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + ddd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddd
          dd = w(i+1, j, k, ivy) - w(i, j, k, ivy)
          call popreal8(v_z)
          ddd = ssy*v_yd + ssx*v_xd + ssz*v_zd
          sszd = sszd + dd*v_zd
          call popreal8(v_y)
          ssyd = ssyd + dd*v_yd
          call popreal8(v_x)
          ssxd = ssxd + dd*v_xd
          wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + ddd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddd
          dd = w(i+1, j, k, ivx) - w(i, j, k, ivx)
          call popreal8(u_z)
          ddd = ssy*u_yd + ssx*u_xd + ssz*u_zd
          sszd = sszd + dd*u_zd
          call popreal8(u_y)
          ssyd = ssyd + dd*u_yd
          call popreal8(u_x)
          ssxd = ssxd + dd*u_xd
          wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + ddd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddd
          call popreal8(ssz)
          call popreal8(ssy)
          call popreal8(ssx)
          ssd = ssy*ssyd + ssx*ssxd + ssz*sszd
          temp = ssx**2 + ssy**2 + ssz**2
          tempd = -(one*ssd/temp**2)
          sszd = 2*ssz*tempd + ss*sszd
          ssyd = 2*ssy*tempd + ss*ssyd
          ssxd = 2*ssx*tempd + ss*ssxd
          call popreal8(ss)
          call popreal8(ssz)
          tempd0 = eighth*sszd
          xd(i+1, j-1, k-1, 3) = xd(i+1, j-1, k-1, 3) + tempd0
          xd(i-1, j-1, k-1, 3) = xd(i-1, j-1, k-1, 3) - tempd0
          xd(i+1, j-1, k, 3) = xd(i+1, j-1, k, 3) + tempd0
          xd(i-1, j-1, k, 3) = xd(i-1, j-1, k, 3) - tempd0
          xd(i+1, j, k-1, 3) = xd(i+1, j, k-1, 3) + tempd0
          xd(i-1, j, k-1, 3) = xd(i-1, j, k-1, 3) - tempd0
          xd(i+1, j, k, 3) = xd(i+1, j, k, 3) + tempd0
          xd(i-1, j, k, 3) = xd(i-1, j, k, 3) - tempd0
          call popreal8(ssy)
          tempd1 = eighth*ssyd
          xd(i+1, j-1, k-1, 2) = xd(i+1, j-1, k-1, 2) + tempd1
          xd(i-1, j-1, k-1, 2) = xd(i-1, j-1, k-1, 2) - tempd1
          xd(i+1, j-1, k, 2) = xd(i+1, j-1, k, 2) + tempd1
          xd(i-1, j-1, k, 2) = xd(i-1, j-1, k, 2) - tempd1
          xd(i+1, j, k-1, 2) = xd(i+1, j, k-1, 2) + tempd1
          xd(i-1, j, k-1, 2) = xd(i-1, j, k-1, 2) - tempd1
          xd(i+1, j, k, 2) = xd(i+1, j, k, 2) + tempd1
          xd(i-1, j, k, 2) = xd(i-1, j, k, 2) - tempd1
          call popreal8(ssx)
          tempd2 = eighth*ssxd
          xd(i+1, j-1, k-1, 1) = xd(i+1, j-1, k-1, 1) + tempd2
          xd(i-1, j-1, k-1, 1) = xd(i-1, j-1, k-1, 1) - tempd2
          xd(i+1, j-1, k, 1) = xd(i+1, j-1, k, 1) + tempd2
          xd(i-1, j-1, k, 1) = xd(i-1, j-1, k, 1) - tempd2
          xd(i+1, j, k-1, 1) = xd(i+1, j, k-1, 1) + tempd2
          xd(i-1, j, k-1, 1) = xd(i-1, j, k-1, 1) - tempd2
          xd(i+1, j, k, 1) = xd(i+1, j, k, 1) + tempd2
          xd(i-1, j, k, 1) = xd(i-1, j, k, 1) - tempd2
        end do
      end do
    end do
  end subroutine viscousfluxapprox_b
  subroutine viscousfluxapprox()
    use constants
    use blockpointers
    use flowvarrefstate
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    integer(kind=inttype) :: ii, jj, kk
    real(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
    real(kind=realtype) :: gm1, factlamheat, factturbheat
    real(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
    real(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
    real(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
    real(kind=realtype) :: tauxx, tauyy, tauzz
    real(kind=realtype) :: tauxy, tauxz, tauyz
    real(kind=realtype) :: fmx, fmy, fmz, frhoe
    real(kind=realtype) :: dd
    logical :: correctfork
    mue = zero
    rfilv = rfil
! viscous fluxes in the i-direction
    do k=2,kl
      do j=2,jl
        do i=1,il
! compute the vector from the center of cell i to cell i+1
          ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
&           -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
&           , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
          ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
&           -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
&           , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
          ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
&           -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
&           , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
! and determine one/ length of vector squared
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! now compute each gradient
          dd = w(i+1, j, k, ivx) - w(i, j, k, ivx)
          u_x = dd*ssx
          u_y = dd*ssy
          u_z = dd*ssz
          dd = w(i+1, j, k, ivy) - w(i, j, k, ivy)
          v_x = dd*ssx
          v_y = dd*ssy
          v_z = dd*ssz
          dd = w(i+1, j, k, ivz) - w(i, j, k, ivz)
          w_x = dd*ssx
          w_y = dd*ssy
          w_z = dd*ssz
          dd = aa(i+1, j, k) - aa(i, j, k)
          q_x = -(dd*ssx)
          q_y = -(dd*ssy)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (pori(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
          if (eddymodel) mue = por*(rev(i, j, k)+rev(i+1, j, k))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! compute the viscous fluxes for this i-face.
          fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i&
&           , j, k, 3)
          fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i&
&           , j, k, 3)
          fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i&
&           , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k&
&           , 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
! update the residuals of cell i and i+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
          fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
          fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
          fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
        end do
      end do
    end do
! viscous fluxes in the j-direction
    do k=2,kl
      do j=1,jl
        do i=2,il
! compute the vector from the center of cell j to cell j+1
          ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
          ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
          ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
! and determine one/ length of vector squared
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! now compute each gradient
          dd = w(i, j+1, k, ivx) - w(i, j, k, ivx)
          u_x = dd*ssx
          u_y = dd*ssy
          u_z = dd*ssz
          dd = w(i, j+1, k, ivy) - w(i, j, k, ivy)
          v_x = dd*ssx
          v_y = dd*ssy
          v_z = dd*ssz
          dd = w(i, j+1, k, ivz) - w(i, j, k, ivz)
          w_x = dd*ssx
          w_y = dd*ssy
          w_z = dd*ssz
          dd = aa(i, j+1, k) - aa(i, j, k)
          q_x = -(dd*ssx)
          q_y = -(dd*ssy)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (porj(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
          if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j+1, k))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! compute the viscous fluxes for this j-face.
          fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i&
&           , j, k, 3)
          fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i&
&           , j, k, 3)
          fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i&
&           , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k&
&           , 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
! update the residuals of cell j and j+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
          fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
          fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
          fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
        end do
      end do
    end do
! viscous fluxes in the k-direction
    do k=1,kl
      do j=2,jl
        do i=2,il
! compute the vector from the center of cell k to cell k+1
          ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&           , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
&           , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
          ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&           , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
&           , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
          ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&           , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
&           , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
! and determine one/ length of vector squared
          ss = one/(ssx*ssx+ssy*ssy+ssz*ssz)
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! now compute each gradient
          dd = w(i, j, k+1, ivx) - w(i, j, k, ivx)
          u_x = dd*ssx
          u_y = dd*ssy
          u_z = dd*ssz
          dd = w(i, j, k+1, ivy) - w(i, j, k, ivy)
          v_x = dd*ssx
          v_y = dd*ssy
          v_z = dd*ssz
          dd = w(i, j, k+1, ivz) - w(i, j, k, ivz)
          w_x = dd*ssx
          w_y = dd*ssy
          w_z = dd*ssz
          dd = aa(i, j, k+1) - aa(i, j, k)
          q_x = -(dd*ssx)
          q_y = -(dd*ssy)
          q_z = -(dd*ssz)
          por = half*rfilv
          if (pork(i, j, k) .eq. noflux) por = zero
! compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
          if (eddymodel) mue = por*(rev(i, j, k)+rev(i, j, k+1))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! compute the average velocities for the face. remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! compute the viscous fluxes for this j-face.
          fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i&
&           , j, k, 3)
          fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i&
&           , j, k, 3)
          fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i&
&           , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1) + (&
&           ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k, 2) + (ubar*&
&           tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k, 3) - q_x*sk(i, j, k&
&           , 1) - q_y*sk(i, j, k, 2) - q_z*sk(i, j, k, 3)
! update the residuals of cell j and j+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
          fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
          fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
          fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
        end do
      end do
    end do
  end subroutine viscousfluxapprox
!  differentiation of invisciddissfluxscalarapprox in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *p *w *fw
!   with respect to varying inputs: *p *w *fw *radi *radj *radk
!   rw status of diff variables: *p:incr *w:in-out *fw:in-out *radi:out
!                *radj:out *radk:out
!   plus diff mem management of: p:in w:in fw:in radi:in radj:in
!                radk:in
  subroutine invisciddissfluxscalarapprox_b()
!
!       invisciddissfluxscalar computes the scalar artificial
!       dissipation, see aiaa paper 81-1259, for a given block.
!       therefore it is assumed that the pointers in  blockpointers
!       already point to the correct block.
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: rradd, dis2d
    real(kind=realtype) :: dss1, dss2, ddw, fs
    real(kind=realtype) :: ddwd, fsd
    intrinsic abs
    intrinsic max
    intrinsic min
    real(kind=realtype) :: tmp
    real(kind=realtype) :: tmp0
    real(kind=realtype) :: tmp1
    real(kind=realtype) :: tmp2
    real(kind=realtype) :: tmp3
    real(kind=realtype) :: tmp4
    real(kind=realtype) :: tmp5
    real(kind=realtype) :: tmp6
    real(kind=realtype) :: tmp7
    real(kind=realtype) :: tmp8
    real(kind=realtype) :: tmp9
    real(kind=realtype) :: tmp10
    real(kind=realtype) :: tmp11
    real(kind=realtype) :: tmp12
    real(kind=realtype) :: tmp13
    real(kind=realtype) :: tmp14
    real(kind=realtype) :: tmp15
    real(kind=realtype) :: tmp16
    real(kind=realtype) :: tmp17
    real(kind=realtype) :: tmp18
    real(kind=realtype) :: tmp19
    real(kind=realtype) :: tmp20
    real(kind=realtype) :: tmp21
    real(kind=realtype) :: tmp22
    real(kind=realtype) :: tmp23
    real(kind=realtype) :: tmp24
    real(kind=realtype) :: tmp25
    integer :: branch
    real(kind=realtype) :: tmpd20
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: tmpd
    real(kind=realtype) :: tmpd19
    real(kind=realtype) :: tmpd18
    real(kind=realtype) :: tmpd17
    real(kind=realtype) :: x6
    real(kind=realtype) :: tmpd16
    real(kind=realtype) :: x5
    real(kind=realtype) :: tmpd15
    real(kind=realtype) :: x4
    real(kind=realtype) :: tmpd14
    real(kind=realtype) :: x3
    real(kind=realtype) :: tmpd13
    real(kind=realtype) :: x2
    real(kind=realtype) :: tmpd12
    real(kind=realtype) :: x1
    real(kind=realtype) :: tmpd11
    real(kind=realtype) :: tmpd10
    real(kind=realtype) :: tmpd9
    real(kind=realtype) :: tmpd8
    real(kind=realtype) :: tmpd7
    real(kind=realtype) :: tmpd6
    real(kind=realtype) :: tmpd5
    real(kind=realtype) :: tmpd4
    real(kind=realtype) :: tmpd3
    real(kind=realtype) :: tmpd2
    real(kind=realtype) :: tmpd1
    real(kind=realtype) :: tmpd0
    real(kind=realtype) :: abs0
    real(kind=realtype) :: temp
    real(kind=realtype) :: tmpd25
    real(kind=realtype) :: tmpd24
    real(kind=realtype) :: temp7
    real(kind=realtype) :: y3
    real(kind=realtype) :: tmpd23
    real(kind=realtype) :: temp6
    real(kind=realtype) :: y2
    real(kind=realtype) :: tmpd22
    real(kind=realtype) :: temp5
    real(kind=realtype) :: y1
    real(kind=realtype) :: tmpd21
    real(kind=realtype) :: temp4
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      radid = 0.0_8
      radjd = 0.0_8
      radkd = 0.0_8
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations)
      case (eulerequations)
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr
      case (nsequations, ransequations)
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr/rhoinf**gammainf
      end select
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! replace the total energy by rho times the total enthalpy.
! in this way the numerical solution is total enthalpy preserving
! for the steady euler equations. also replace the velocities by
! the momentum. only done for the entries used in the
! discretization, i.e. ignore the corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            tmp = w(i, j, k, irho)*w(i, j, k, ivx)
            call pushreal8(w(i, j, k, ivx))
            w(i, j, k, ivx) = tmp
            tmp0 = w(i, j, k, irho)*w(i, j, k, ivy)
            call pushreal8(w(i, j, k, ivy))
            w(i, j, k, ivy) = tmp0
            tmp1 = w(i, j, k, irho)*w(i, j, k, ivz)
            call pushreal8(w(i, j, k, ivz))
            w(i, j, k, ivz) = tmp1
            call pushreal8(w(i, j, k, irhoe))
            w(i, j, k, irhoe) = w(i, j, k, irhoe) + p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          tmp2 = w(0, j, k, irho)*w(0, j, k, ivx)
          call pushreal8(w(0, j, k, ivx))
          w(0, j, k, ivx) = tmp2
          tmp3 = w(0, j, k, irho)*w(0, j, k, ivy)
          call pushreal8(w(0, j, k, ivy))
          w(0, j, k, ivy) = tmp3
          tmp4 = w(0, j, k, irho)*w(0, j, k, ivz)
          call pushreal8(w(0, j, k, ivz))
          w(0, j, k, ivz) = tmp4
          call pushreal8(w(0, j, k, irhoe))
          w(0, j, k, irhoe) = w(0, j, k, irhoe) + p(0, j, k)
          tmp5 = w(1, j, k, irho)*w(1, j, k, ivx)
          call pushreal8(w(1, j, k, ivx))
          w(1, j, k, ivx) = tmp5
          tmp6 = w(1, j, k, irho)*w(1, j, k, ivy)
          call pushreal8(w(1, j, k, ivy))
          w(1, j, k, ivy) = tmp6
          tmp7 = w(1, j, k, irho)*w(1, j, k, ivz)
          call pushreal8(w(1, j, k, ivz))
          w(1, j, k, ivz) = tmp7
          call pushreal8(w(1, j, k, irhoe))
          w(1, j, k, irhoe) = w(1, j, k, irhoe) + p(1, j, k)
          tmp8 = w(ie, j, k, irho)*w(ie, j, k, ivx)
          call pushreal8(w(ie, j, k, ivx))
          w(ie, j, k, ivx) = tmp8
          tmp9 = w(ie, j, k, irho)*w(ie, j, k, ivy)
          call pushreal8(w(ie, j, k, ivy))
          w(ie, j, k, ivy) = tmp9
          tmp10 = w(ie, j, k, irho)*w(ie, j, k, ivz)
          call pushreal8(w(ie, j, k, ivz))
          w(ie, j, k, ivz) = tmp10
          call pushreal8(w(ie, j, k, irhoe))
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) + p(ie, j, k)
          tmp11 = w(ib, j, k, irho)*w(ib, j, k, ivx)
          call pushreal8(w(ib, j, k, ivx))
          w(ib, j, k, ivx) = tmp11
          tmp12 = w(ib, j, k, irho)*w(ib, j, k, ivy)
          call pushreal8(w(ib, j, k, ivy))
          w(ib, j, k, ivy) = tmp12
          tmp13 = w(ib, j, k, irho)*w(ib, j, k, ivz)
          call pushreal8(w(ib, j, k, ivz))
          w(ib, j, k, ivz) = tmp13
          call pushreal8(w(ib, j, k, irhoe))
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) + p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          tmp14 = w(i, 0, k, irho)*w(i, 0, k, ivx)
          call pushreal8(w(i, 0, k, ivx))
          w(i, 0, k, ivx) = tmp14
          tmp15 = w(i, 0, k, irho)*w(i, 0, k, ivy)
          call pushreal8(w(i, 0, k, ivy))
          w(i, 0, k, ivy) = tmp15
          tmp16 = w(i, 0, k, irho)*w(i, 0, k, ivz)
          call pushreal8(w(i, 0, k, ivz))
          w(i, 0, k, ivz) = tmp16
          call pushreal8(w(i, 0, k, irhoe))
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) + p(i, 0, k)
          tmp17 = w(i, 1, k, irho)*w(i, 1, k, ivx)
          call pushreal8(w(i, 1, k, ivx))
          w(i, 1, k, ivx) = tmp17
          tmp18 = w(i, 1, k, irho)*w(i, 1, k, ivy)
          call pushreal8(w(i, 1, k, ivy))
          w(i, 1, k, ivy) = tmp18
          tmp19 = w(i, 1, k, irho)*w(i, 1, k, ivz)
          call pushreal8(w(i, 1, k, ivz))
          w(i, 1, k, ivz) = tmp19
          call pushreal8(w(i, 1, k, irhoe))
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) + p(i, 1, k)
          tmp20 = w(i, je, k, irho)*w(i, je, k, ivx)
          call pushreal8(w(i, je, k, ivx))
          w(i, je, k, ivx) = tmp20
          tmp21 = w(i, je, k, irho)*w(i, je, k, ivy)
          call pushreal8(w(i, je, k, ivy))
          w(i, je, k, ivy) = tmp21
          tmp22 = w(i, je, k, irho)*w(i, je, k, ivz)
          call pushreal8(w(i, je, k, ivz))
          w(i, je, k, ivz) = tmp22
          call pushreal8(w(i, je, k, irhoe))
          w(i, je, k, irhoe) = w(i, je, k, irhoe) + p(i, je, k)
          tmp23 = w(i, jb, k, irho)*w(i, jb, k, ivx)
          call pushreal8(w(i, jb, k, ivx))
          w(i, jb, k, ivx) = tmp23
          tmp24 = w(i, jb, k, irho)*w(i, jb, k, ivy)
          call pushreal8(w(i, jb, k, ivy))
          w(i, jb, k, ivy) = tmp24
          tmp25 = w(i, jb, k, irho)*w(i, jb, k, ivz)
          call pushreal8(w(i, jb, k, ivz))
          w(i, jb, k, ivz) = tmp25
          call pushreal8(w(i, jb, k, irhoe))
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) + p(i, jb, k)
        end do
      end do
!
!       dissipative fluxes in the i-direction.
!
      do k=2,kl
        do j=2,jl
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(shocksensor(2, j, k)+two*shocksensor(&
&           1, j, k)+shocksensor(0, j, k)+sslim)
          if (x1 .ge. 0.) then
            dss1 = x1
          else
            dss1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k)+sslim)
            if (x2 .ge. 0.) then
              dss2 = x2
            else
              dss2 = -x2
            end if
! compute the dissipation coefficients for this face.
            call pushreal8(ppor)
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = half
            if (dss1 .lt. dss2) then
              y1 = dss2
            else
              y1 = dss1
            end if
            if (dssmax .gt. y1) then
              call pushreal8(min1)
              min1 = y1
              call pushcontrol1b(0)
            else
              call pushreal8(min1)
              min1 = dssmax
              call pushcontrol1b(1)
            end if
! modification for fd preconditioner note: this lumping
! actually still results in a greater than 3 cell stencil
! in any direction. since this seems to work slightly
! better than the dis2=sigma*fis4*rrad, we will just use
! a 5-cell stencil for doing the pc
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.
!
      do k=2,kl
        do i=2,il
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(shocksensor(i, 2, k)+two*shocksensor(&
&           i, 1, k)+shocksensor(i, 0, k)+sslim)
          if (x3 .ge. 0.) then
            dss1 = x3
          else
            dss1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k)+sslim)
            if (x4 .ge. 0.) then
              dss2 = x4
            else
              dss2 = -x4
            end if
! compute the dissipation coefficients for this face.
            call pushreal8(ppor)
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = half
            if (dss1 .lt. dss2) then
              y2 = dss2
            else
              y2 = dss1
            end if
            if (dssmax .gt. y2) then
              call pushreal8(min2)
              min2 = y2
              call pushcontrol1b(0)
            else
              call pushreal8(min2)
              min2 = dssmax
              call pushcontrol1b(1)
            end if
! modification for fd preconditioner
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.
!
      do j=2,jl
        do i=2,il
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(shocksensor(i, j, 2)+two*shocksensor(&
&           i, j, 1)+shocksensor(i, j, 0)+sslim)
          if (x5 .ge. 0.) then
            dss1 = x5
          else
            dss1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k)+sslim)
            if (x6 .ge. 0.) then
              dss2 = x6
            else
              dss2 = -x6
            end if
! compute the dissipation coefficients for this face.
            call pushreal8(ppor)
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = half
            if (dss1 .lt. dss2) then
              y3 = dss2
            else
              y3 = dss1
            end if
            if (dssmax .gt. y3) then
              call pushreal8(min3)
              min3 = y3
              call pushcontrol1b(0)
            else
              call pushreal8(min3)
              min3 = dssmax
              call pushcontrol1b(1)
            end if
! modification for fd preconditioner
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
! replace rho times the total enthalpy by the total energy and
! store the velocities again instead of the momentum. only for
! those entries that have been altered, i.e. ignore the
! corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            call pushreal8(rhoi)
            rhoi = one/w(i, j, k, irho)
            call pushreal8(w(i, j, k, ivx))
            w(i, j, k, ivx) = w(i, j, k, ivx)*rhoi
            call pushreal8(w(i, j, k, ivy))
            w(i, j, k, ivy) = w(i, j, k, ivy)*rhoi
            call pushreal8(w(i, j, k, ivz))
            w(i, j, k, ivz) = w(i, j, k, ivz)*rhoi
            call pushreal8(w(i, j, k, irhoe))
            w(i, j, k, irhoe) = w(i, j, k, irhoe) - p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          call pushreal8(rhoi)
          rhoi = one/w(0, j, k, irho)
          call pushreal8(w(0, j, k, ivx))
          w(0, j, k, ivx) = w(0, j, k, ivx)*rhoi
          call pushreal8(w(0, j, k, ivy))
          w(0, j, k, ivy) = w(0, j, k, ivy)*rhoi
          call pushreal8(w(0, j, k, ivz))
          w(0, j, k, ivz) = w(0, j, k, ivz)*rhoi
          call pushreal8(w(0, j, k, irhoe))
          w(0, j, k, irhoe) = w(0, j, k, irhoe) - p(0, j, k)
          call pushreal8(rhoi)
          rhoi = one/w(1, j, k, irho)
          call pushreal8(w(1, j, k, ivx))
          w(1, j, k, ivx) = w(1, j, k, ivx)*rhoi
          call pushreal8(w(1, j, k, ivy))
          w(1, j, k, ivy) = w(1, j, k, ivy)*rhoi
          call pushreal8(w(1, j, k, ivz))
          w(1, j, k, ivz) = w(1, j, k, ivz)*rhoi
          call pushreal8(w(1, j, k, irhoe))
          w(1, j, k, irhoe) = w(1, j, k, irhoe) - p(1, j, k)
          call pushreal8(rhoi)
          rhoi = one/w(ie, j, k, irho)
          call pushreal8(w(ie, j, k, ivx))
          w(ie, j, k, ivx) = w(ie, j, k, ivx)*rhoi
          call pushreal8(w(ie, j, k, ivy))
          w(ie, j, k, ivy) = w(ie, j, k, ivy)*rhoi
          call pushreal8(w(ie, j, k, ivz))
          w(ie, j, k, ivz) = w(ie, j, k, ivz)*rhoi
          call pushreal8(w(ie, j, k, irhoe))
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) - p(ie, j, k)
          call pushreal8(rhoi)
          rhoi = one/w(ib, j, k, irho)
          call pushreal8(w(ib, j, k, ivx))
          w(ib, j, k, ivx) = w(ib, j, k, ivx)*rhoi
          call pushreal8(w(ib, j, k, ivy))
          w(ib, j, k, ivy) = w(ib, j, k, ivy)*rhoi
          call pushreal8(w(ib, j, k, ivz))
          w(ib, j, k, ivz) = w(ib, j, k, ivz)*rhoi
          call pushreal8(w(ib, j, k, irhoe))
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) - p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          call pushreal8(rhoi)
          rhoi = one/w(i, 0, k, irho)
          call pushreal8(w(i, 0, k, ivx))
          w(i, 0, k, ivx) = w(i, 0, k, ivx)*rhoi
          call pushreal8(w(i, 0, k, ivy))
          w(i, 0, k, ivy) = w(i, 0, k, ivy)*rhoi
          call pushreal8(w(i, 0, k, ivz))
          w(i, 0, k, ivz) = w(i, 0, k, ivz)*rhoi
          call pushreal8(w(i, 0, k, irhoe))
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) - p(i, 0, k)
          call pushreal8(rhoi)
          rhoi = one/w(i, 1, k, irho)
          call pushreal8(w(i, 1, k, ivx))
          w(i, 1, k, ivx) = w(i, 1, k, ivx)*rhoi
          call pushreal8(w(i, 1, k, ivy))
          w(i, 1, k, ivy) = w(i, 1, k, ivy)*rhoi
          call pushreal8(w(i, 1, k, ivz))
          w(i, 1, k, ivz) = w(i, 1, k, ivz)*rhoi
          call pushreal8(w(i, 1, k, irhoe))
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) - p(i, 1, k)
          call pushreal8(rhoi)
          rhoi = one/w(i, je, k, irho)
          call pushreal8(w(i, je, k, ivx))
          w(i, je, k, ivx) = w(i, je, k, ivx)*rhoi
          call pushreal8(w(i, je, k, ivy))
          w(i, je, k, ivy) = w(i, je, k, ivy)*rhoi
          call pushreal8(w(i, je, k, ivz))
          w(i, je, k, ivz) = w(i, je, k, ivz)*rhoi
          call pushreal8(w(i, je, k, irhoe))
          w(i, je, k, irhoe) = w(i, je, k, irhoe) - p(i, je, k)
          call pushreal8(rhoi)
          rhoi = one/w(i, jb, k, irho)
          call pushreal8(w(i, jb, k, ivx))
          w(i, jb, k, ivx) = w(i, jb, k, ivx)*rhoi
          call pushreal8(w(i, jb, k, ivy))
          w(i, jb, k, ivy) = w(i, jb, k, ivy)*rhoi
          call pushreal8(w(i, jb, k, ivz))
          w(i, jb, k, ivz) = w(i, jb, k, ivz)*rhoi
          call pushreal8(w(i, jb, k, irhoe))
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) - p(i, jb, k)
        end do
      end do
      do k=kl,2,-1
        do i=il,2,-1
          call popreal8(w(i, jb, k, irhoe))
          pd(i, jb, k) = pd(i, jb, k) - wd(i, jb, k, irhoe)
          call popreal8(w(i, jb, k, ivz))
          rhoid = w(i, jb, k, ivz)*wd(i, jb, k, ivz)
          wd(i, jb, k, ivz) = rhoi*wd(i, jb, k, ivz)
          call popreal8(w(i, jb, k, ivy))
          rhoid = rhoid + w(i, jb, k, ivy)*wd(i, jb, k, ivy)
          wd(i, jb, k, ivy) = rhoi*wd(i, jb, k, ivy)
          call popreal8(w(i, jb, k, ivx))
          rhoid = rhoid + w(i, jb, k, ivx)*wd(i, jb, k, ivx)
          wd(i, jb, k, ivx) = rhoi*wd(i, jb, k, ivx)
          call popreal8(rhoi)
          temp7 = w(i, jb, k, irho)
          wd(i, jb, k, irho) = wd(i, jb, k, irho) - one*rhoid/temp7**2
          call popreal8(w(i, je, k, irhoe))
          pd(i, je, k) = pd(i, je, k) - wd(i, je, k, irhoe)
          call popreal8(w(i, je, k, ivz))
          rhoid = w(i, je, k, ivz)*wd(i, je, k, ivz)
          wd(i, je, k, ivz) = rhoi*wd(i, je, k, ivz)
          call popreal8(w(i, je, k, ivy))
          rhoid = rhoid + w(i, je, k, ivy)*wd(i, je, k, ivy)
          wd(i, je, k, ivy) = rhoi*wd(i, je, k, ivy)
          call popreal8(w(i, je, k, ivx))
          rhoid = rhoid + w(i, je, k, ivx)*wd(i, je, k, ivx)
          wd(i, je, k, ivx) = rhoi*wd(i, je, k, ivx)
          call popreal8(rhoi)
          temp6 = w(i, je, k, irho)
          wd(i, je, k, irho) = wd(i, je, k, irho) - one*rhoid/temp6**2
          call popreal8(w(i, 1, k, irhoe))
          pd(i, 1, k) = pd(i, 1, k) - wd(i, 1, k, irhoe)
          call popreal8(w(i, 1, k, ivz))
          rhoid = w(i, 1, k, ivz)*wd(i, 1, k, ivz)
          wd(i, 1, k, ivz) = rhoi*wd(i, 1, k, ivz)
          call popreal8(w(i, 1, k, ivy))
          rhoid = rhoid + w(i, 1, k, ivy)*wd(i, 1, k, ivy)
          wd(i, 1, k, ivy) = rhoi*wd(i, 1, k, ivy)
          call popreal8(w(i, 1, k, ivx))
          rhoid = rhoid + w(i, 1, k, ivx)*wd(i, 1, k, ivx)
          wd(i, 1, k, ivx) = rhoi*wd(i, 1, k, ivx)
          call popreal8(rhoi)
          temp5 = w(i, 1, k, irho)
          wd(i, 1, k, irho) = wd(i, 1, k, irho) - one*rhoid/temp5**2
          call popreal8(w(i, 0, k, irhoe))
          pd(i, 0, k) = pd(i, 0, k) - wd(i, 0, k, irhoe)
          call popreal8(w(i, 0, k, ivz))
          rhoid = w(i, 0, k, ivz)*wd(i, 0, k, ivz)
          wd(i, 0, k, ivz) = rhoi*wd(i, 0, k, ivz)
          call popreal8(w(i, 0, k, ivy))
          rhoid = rhoid + w(i, 0, k, ivy)*wd(i, 0, k, ivy)
          wd(i, 0, k, ivy) = rhoi*wd(i, 0, k, ivy)
          call popreal8(w(i, 0, k, ivx))
          rhoid = rhoid + w(i, 0, k, ivx)*wd(i, 0, k, ivx)
          wd(i, 0, k, ivx) = rhoi*wd(i, 0, k, ivx)
          call popreal8(rhoi)
          temp4 = w(i, 0, k, irho)
          wd(i, 0, k, irho) = wd(i, 0, k, irho) - one*rhoid/temp4**2
        end do
      end do
      do k=kl,2,-1
        do j=jl,2,-1
          call popreal8(w(ib, j, k, irhoe))
          pd(ib, j, k) = pd(ib, j, k) - wd(ib, j, k, irhoe)
          call popreal8(w(ib, j, k, ivz))
          rhoid = w(ib, j, k, ivz)*wd(ib, j, k, ivz)
          wd(ib, j, k, ivz) = rhoi*wd(ib, j, k, ivz)
          call popreal8(w(ib, j, k, ivy))
          rhoid = rhoid + w(ib, j, k, ivy)*wd(ib, j, k, ivy)
          wd(ib, j, k, ivy) = rhoi*wd(ib, j, k, ivy)
          call popreal8(w(ib, j, k, ivx))
          rhoid = rhoid + w(ib, j, k, ivx)*wd(ib, j, k, ivx)
          wd(ib, j, k, ivx) = rhoi*wd(ib, j, k, ivx)
          call popreal8(rhoi)
          temp3 = w(ib, j, k, irho)
          wd(ib, j, k, irho) = wd(ib, j, k, irho) - one*rhoid/temp3**2
          call popreal8(w(ie, j, k, irhoe))
          pd(ie, j, k) = pd(ie, j, k) - wd(ie, j, k, irhoe)
          call popreal8(w(ie, j, k, ivz))
          rhoid = w(ie, j, k, ivz)*wd(ie, j, k, ivz)
          wd(ie, j, k, ivz) = rhoi*wd(ie, j, k, ivz)
          call popreal8(w(ie, j, k, ivy))
          rhoid = rhoid + w(ie, j, k, ivy)*wd(ie, j, k, ivy)
          wd(ie, j, k, ivy) = rhoi*wd(ie, j, k, ivy)
          call popreal8(w(ie, j, k, ivx))
          rhoid = rhoid + w(ie, j, k, ivx)*wd(ie, j, k, ivx)
          wd(ie, j, k, ivx) = rhoi*wd(ie, j, k, ivx)
          call popreal8(rhoi)
          temp2 = w(ie, j, k, irho)
          wd(ie, j, k, irho) = wd(ie, j, k, irho) - one*rhoid/temp2**2
          call popreal8(w(1, j, k, irhoe))
          pd(1, j, k) = pd(1, j, k) - wd(1, j, k, irhoe)
          call popreal8(w(1, j, k, ivz))
          rhoid = w(1, j, k, ivz)*wd(1, j, k, ivz)
          wd(1, j, k, ivz) = rhoi*wd(1, j, k, ivz)
          call popreal8(w(1, j, k, ivy))
          rhoid = rhoid + w(1, j, k, ivy)*wd(1, j, k, ivy)
          wd(1, j, k, ivy) = rhoi*wd(1, j, k, ivy)
          call popreal8(w(1, j, k, ivx))
          rhoid = rhoid + w(1, j, k, ivx)*wd(1, j, k, ivx)
          wd(1, j, k, ivx) = rhoi*wd(1, j, k, ivx)
          call popreal8(rhoi)
          temp1 = w(1, j, k, irho)
          wd(1, j, k, irho) = wd(1, j, k, irho) - one*rhoid/temp1**2
          call popreal8(w(0, j, k, irhoe))
          pd(0, j, k) = pd(0, j, k) - wd(0, j, k, irhoe)
          call popreal8(w(0, j, k, ivz))
          rhoid = w(0, j, k, ivz)*wd(0, j, k, ivz)
          wd(0, j, k, ivz) = rhoi*wd(0, j, k, ivz)
          call popreal8(w(0, j, k, ivy))
          rhoid = rhoid + w(0, j, k, ivy)*wd(0, j, k, ivy)
          wd(0, j, k, ivy) = rhoi*wd(0, j, k, ivy)
          call popreal8(w(0, j, k, ivx))
          rhoid = rhoid + w(0, j, k, ivx)*wd(0, j, k, ivx)
          wd(0, j, k, ivx) = rhoi*wd(0, j, k, ivx)
          call popreal8(rhoi)
          temp0 = w(0, j, k, irho)
          wd(0, j, k, irho) = wd(0, j, k, irho) - one*rhoid/temp0**2
        end do
      end do
      do k=kb,0,-1
        do j=jl,2,-1
          do i=il,2,-1
            call popreal8(w(i, j, k, irhoe))
            pd(i, j, k) = pd(i, j, k) - wd(i, j, k, irhoe)
            call popreal8(w(i, j, k, ivz))
            rhoid = w(i, j, k, ivz)*wd(i, j, k, ivz)
            wd(i, j, k, ivz) = rhoi*wd(i, j, k, ivz)
            call popreal8(w(i, j, k, ivy))
            rhoid = rhoid + w(i, j, k, ivy)*wd(i, j, k, ivy)
            wd(i, j, k, ivy) = rhoi*wd(i, j, k, ivy)
            call popreal8(w(i, j, k, ivx))
            rhoid = rhoid + w(i, j, k, ivx)*wd(i, j, k, ivx)
            wd(i, j, k, ivx) = rhoi*wd(i, j, k, ivx)
            call popreal8(rhoi)
            temp = w(i, j, k, irho)
            wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp**2
          end do
        end do
      end do
      radkd = 0.0_8
      do j=jl,2,-1
        do i=il,2,-1
          do k=kl,1,-1
            fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
            dis2 = fis2*rrad*min3 + sigma*fis4*rrad
            dis2d = ddw*fsd
            ddwd = dis2*fsd
            wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddwd
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
            fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
            ddw = w(i, j, k+1, ivz) - w(i, j, k, ivz)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + ddwd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddwd
            fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
            ddw = w(i, j, k+1, ivy) - w(i, j, k, ivy)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + ddwd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddwd
            fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
            ddw = w(i, j, k+1, ivx) - w(i, j, k, ivx)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + ddwd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddwd
            fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
            rradd = (sigma*fis4+fis2*min3)*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(min3)
            else
              call popreal8(min3)
            end if
            radkd(i, j, k) = radkd(i, j, k) + ppor*rradd
            radkd(i, j, k+1) = radkd(i, j, k+1) + ppor*rradd
            call popreal8(ppor)
          end do
        end do
      end do
      radjd = 0.0_8
      do k=kl,2,-1
        do i=il,2,-1
          do j=jl,1,-1
            fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
            dis2 = fis2*rrad*min2 + sigma*fis4*rrad
            dis2d = ddw*fsd
            ddwd = dis2*fsd
            wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddwd
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
            fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
            ddw = w(i, j+1, k, ivz) - w(i, j, k, ivz)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + ddwd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddwd
            fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
            ddw = w(i, j+1, k, ivy) - w(i, j, k, ivy)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + ddwd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddwd
            fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
            ddw = w(i, j+1, k, ivx) - w(i, j, k, ivx)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + ddwd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddwd
            fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
            rradd = (sigma*fis4+fis2*min2)*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(min2)
            else
              call popreal8(min2)
            end if
            radjd(i, j, k) = radjd(i, j, k) + ppor*rradd
            radjd(i, j+1, k) = radjd(i, j+1, k) + ppor*rradd
            call popreal8(ppor)
          end do
        end do
      end do
      radid = 0.0_8
      do k=kl,2,-1
        do j=jl,2,-1
          do i=il,1,-1
            fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
            dis2 = fis2*rrad*min1 + sigma*fis4*rrad
            dis2d = ddw*fsd
            ddwd = dis2*fsd
            wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddwd
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
            fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
            ddw = w(i+1, j, k, ivz) - w(i, j, k, ivz)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + ddwd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) - ddwd
            fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
            ddw = w(i+1, j, k, ivy) - w(i, j, k, ivy)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + ddwd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) - ddwd
            fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
            ddw = w(i+1, j, k, ivx) - w(i, j, k, ivx)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + ddwd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) - ddwd
            fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            dis2d = dis2d + ddw*fsd
            ddwd = dis2*fsd
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
            rradd = (sigma*fis4+fis2*min1)*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(min1)
            else
              call popreal8(min1)
            end if
            radid(i, j, k) = radid(i, j, k) + ppor*rradd
            radid(i+1, j, k) = radid(i+1, j, k) + ppor*rradd
            call popreal8(ppor)
          end do
        end do
      end do
      do k=kl,2,-1
        do j=jl,2,-1
          do i=il,2,-1
            fwd(i, j, k, irhoe) = sfil*fwd(i, j, k, irhoe)
            fwd(i, j, k, imz) = sfil*fwd(i, j, k, imz)
            fwd(i, j, k, imy) = sfil*fwd(i, j, k, imy)
            fwd(i, j, k, imx) = sfil*fwd(i, j, k, imx)
            fwd(i, j, k, irho) = sfil*fwd(i, j, k, irho)
          end do
        end do
      end do
      do k=kl,2,-1
        do i=il,2,-1
          call popreal8(w(i, jb, k, irhoe))
          pd(i, jb, k) = pd(i, jb, k) + wd(i, jb, k, irhoe)
          call popreal8(w(i, jb, k, ivz))
          tmpd14 = wd(i, jb, k, ivz)
          wd(i, jb, k, ivz) = 0.0_8
          wd(i, jb, k, irho) = wd(i, jb, k, irho) + w(i, jb, k, ivz)*&
&           tmpd14
          wd(i, jb, k, ivz) = wd(i, jb, k, ivz) + w(i, jb, k, irho)*&
&           tmpd14
          call popreal8(w(i, jb, k, ivy))
          tmpd15 = wd(i, jb, k, ivy)
          wd(i, jb, k, ivy) = 0.0_8
          wd(i, jb, k, irho) = wd(i, jb, k, irho) + w(i, jb, k, ivy)*&
&           tmpd15
          wd(i, jb, k, ivy) = wd(i, jb, k, ivy) + w(i, jb, k, irho)*&
&           tmpd15
          call popreal8(w(i, jb, k, ivx))
          tmpd16 = wd(i, jb, k, ivx)
          wd(i, jb, k, ivx) = 0.0_8
          wd(i, jb, k, irho) = wd(i, jb, k, irho) + w(i, jb, k, ivx)*&
&           tmpd16
          wd(i, jb, k, ivx) = wd(i, jb, k, ivx) + w(i, jb, k, irho)*&
&           tmpd16
          call popreal8(w(i, je, k, irhoe))
          pd(i, je, k) = pd(i, je, k) + wd(i, je, k, irhoe)
          call popreal8(w(i, je, k, ivz))
          tmpd17 = wd(i, je, k, ivz)
          wd(i, je, k, ivz) = 0.0_8
          wd(i, je, k, irho) = wd(i, je, k, irho) + w(i, je, k, ivz)*&
&           tmpd17
          wd(i, je, k, ivz) = wd(i, je, k, ivz) + w(i, je, k, irho)*&
&           tmpd17
          call popreal8(w(i, je, k, ivy))
          tmpd18 = wd(i, je, k, ivy)
          wd(i, je, k, ivy) = 0.0_8
          wd(i, je, k, irho) = wd(i, je, k, irho) + w(i, je, k, ivy)*&
&           tmpd18
          wd(i, je, k, ivy) = wd(i, je, k, ivy) + w(i, je, k, irho)*&
&           tmpd18
          call popreal8(w(i, je, k, ivx))
          tmpd19 = wd(i, je, k, ivx)
          wd(i, je, k, ivx) = 0.0_8
          wd(i, je, k, irho) = wd(i, je, k, irho) + w(i, je, k, ivx)*&
&           tmpd19
          wd(i, je, k, ivx) = wd(i, je, k, ivx) + w(i, je, k, irho)*&
&           tmpd19
          call popreal8(w(i, 1, k, irhoe))
          pd(i, 1, k) = pd(i, 1, k) + wd(i, 1, k, irhoe)
          call popreal8(w(i, 1, k, ivz))
          tmpd20 = wd(i, 1, k, ivz)
          wd(i, 1, k, ivz) = 0.0_8
          wd(i, 1, k, irho) = wd(i, 1, k, irho) + w(i, 1, k, ivz)*tmpd20
          wd(i, 1, k, ivz) = wd(i, 1, k, ivz) + w(i, 1, k, irho)*tmpd20
          call popreal8(w(i, 1, k, ivy))
          tmpd21 = wd(i, 1, k, ivy)
          wd(i, 1, k, ivy) = 0.0_8
          wd(i, 1, k, irho) = wd(i, 1, k, irho) + w(i, 1, k, ivy)*tmpd21
          wd(i, 1, k, ivy) = wd(i, 1, k, ivy) + w(i, 1, k, irho)*tmpd21
          call popreal8(w(i, 1, k, ivx))
          tmpd22 = wd(i, 1, k, ivx)
          wd(i, 1, k, ivx) = 0.0_8
          wd(i, 1, k, irho) = wd(i, 1, k, irho) + w(i, 1, k, ivx)*tmpd22
          wd(i, 1, k, ivx) = wd(i, 1, k, ivx) + w(i, 1, k, irho)*tmpd22
          call popreal8(w(i, 0, k, irhoe))
          pd(i, 0, k) = pd(i, 0, k) + wd(i, 0, k, irhoe)
          call popreal8(w(i, 0, k, ivz))
          tmpd23 = wd(i, 0, k, ivz)
          wd(i, 0, k, ivz) = 0.0_8
          wd(i, 0, k, irho) = wd(i, 0, k, irho) + w(i, 0, k, ivz)*tmpd23
          wd(i, 0, k, ivz) = wd(i, 0, k, ivz) + w(i, 0, k, irho)*tmpd23
          call popreal8(w(i, 0, k, ivy))
          tmpd24 = wd(i, 0, k, ivy)
          wd(i, 0, k, ivy) = 0.0_8
          wd(i, 0, k, irho) = wd(i, 0, k, irho) + w(i, 0, k, ivy)*tmpd24
          wd(i, 0, k, ivy) = wd(i, 0, k, ivy) + w(i, 0, k, irho)*tmpd24
          call popreal8(w(i, 0, k, ivx))
          tmpd25 = wd(i, 0, k, ivx)
          wd(i, 0, k, ivx) = 0.0_8
          wd(i, 0, k, irho) = wd(i, 0, k, irho) + w(i, 0, k, ivx)*tmpd25
          wd(i, 0, k, ivx) = wd(i, 0, k, ivx) + w(i, 0, k, irho)*tmpd25
        end do
      end do
      do k=kl,2,-1
        do j=jl,2,-1
          call popreal8(w(ib, j, k, irhoe))
          pd(ib, j, k) = pd(ib, j, k) + wd(ib, j, k, irhoe)
          call popreal8(w(ib, j, k, ivz))
          tmpd2 = wd(ib, j, k, ivz)
          wd(ib, j, k, ivz) = 0.0_8
          wd(ib, j, k, irho) = wd(ib, j, k, irho) + w(ib, j, k, ivz)*&
&           tmpd2
          wd(ib, j, k, ivz) = wd(ib, j, k, ivz) + w(ib, j, k, irho)*&
&           tmpd2
          call popreal8(w(ib, j, k, ivy))
          tmpd3 = wd(ib, j, k, ivy)
          wd(ib, j, k, ivy) = 0.0_8
          wd(ib, j, k, irho) = wd(ib, j, k, irho) + w(ib, j, k, ivy)*&
&           tmpd3
          wd(ib, j, k, ivy) = wd(ib, j, k, ivy) + w(ib, j, k, irho)*&
&           tmpd3
          call popreal8(w(ib, j, k, ivx))
          tmpd4 = wd(ib, j, k, ivx)
          wd(ib, j, k, ivx) = 0.0_8
          wd(ib, j, k, irho) = wd(ib, j, k, irho) + w(ib, j, k, ivx)*&
&           tmpd4
          wd(ib, j, k, ivx) = wd(ib, j, k, ivx) + w(ib, j, k, irho)*&
&           tmpd4
          call popreal8(w(ie, j, k, irhoe))
          pd(ie, j, k) = pd(ie, j, k) + wd(ie, j, k, irhoe)
          call popreal8(w(ie, j, k, ivz))
          tmpd5 = wd(ie, j, k, ivz)
          wd(ie, j, k, ivz) = 0.0_8
          wd(ie, j, k, irho) = wd(ie, j, k, irho) + w(ie, j, k, ivz)*&
&           tmpd5
          wd(ie, j, k, ivz) = wd(ie, j, k, ivz) + w(ie, j, k, irho)*&
&           tmpd5
          call popreal8(w(ie, j, k, ivy))
          tmpd6 = wd(ie, j, k, ivy)
          wd(ie, j, k, ivy) = 0.0_8
          wd(ie, j, k, irho) = wd(ie, j, k, irho) + w(ie, j, k, ivy)*&
&           tmpd6
          wd(ie, j, k, ivy) = wd(ie, j, k, ivy) + w(ie, j, k, irho)*&
&           tmpd6
          call popreal8(w(ie, j, k, ivx))
          tmpd7 = wd(ie, j, k, ivx)
          wd(ie, j, k, ivx) = 0.0_8
          wd(ie, j, k, irho) = wd(ie, j, k, irho) + w(ie, j, k, ivx)*&
&           tmpd7
          wd(ie, j, k, ivx) = wd(ie, j, k, ivx) + w(ie, j, k, irho)*&
&           tmpd7
          call popreal8(w(1, j, k, irhoe))
          pd(1, j, k) = pd(1, j, k) + wd(1, j, k, irhoe)
          call popreal8(w(1, j, k, ivz))
          tmpd8 = wd(1, j, k, ivz)
          wd(1, j, k, ivz) = 0.0_8
          wd(1, j, k, irho) = wd(1, j, k, irho) + w(1, j, k, ivz)*tmpd8
          wd(1, j, k, ivz) = wd(1, j, k, ivz) + w(1, j, k, irho)*tmpd8
          call popreal8(w(1, j, k, ivy))
          tmpd9 = wd(1, j, k, ivy)
          wd(1, j, k, ivy) = 0.0_8
          wd(1, j, k, irho) = wd(1, j, k, irho) + w(1, j, k, ivy)*tmpd9
          wd(1, j, k, ivy) = wd(1, j, k, ivy) + w(1, j, k, irho)*tmpd9
          call popreal8(w(1, j, k, ivx))
          tmpd10 = wd(1, j, k, ivx)
          wd(1, j, k, ivx) = 0.0_8
          wd(1, j, k, irho) = wd(1, j, k, irho) + w(1, j, k, ivx)*tmpd10
          wd(1, j, k, ivx) = wd(1, j, k, ivx) + w(1, j, k, irho)*tmpd10
          call popreal8(w(0, j, k, irhoe))
          pd(0, j, k) = pd(0, j, k) + wd(0, j, k, irhoe)
          call popreal8(w(0, j, k, ivz))
          tmpd11 = wd(0, j, k, ivz)
          wd(0, j, k, ivz) = 0.0_8
          wd(0, j, k, irho) = wd(0, j, k, irho) + w(0, j, k, ivz)*tmpd11
          wd(0, j, k, ivz) = wd(0, j, k, ivz) + w(0, j, k, irho)*tmpd11
          call popreal8(w(0, j, k, ivy))
          tmpd12 = wd(0, j, k, ivy)
          wd(0, j, k, ivy) = 0.0_8
          wd(0, j, k, irho) = wd(0, j, k, irho) + w(0, j, k, ivy)*tmpd12
          wd(0, j, k, ivy) = wd(0, j, k, ivy) + w(0, j, k, irho)*tmpd12
          call popreal8(w(0, j, k, ivx))
          tmpd13 = wd(0, j, k, ivx)
          wd(0, j, k, ivx) = 0.0_8
          wd(0, j, k, irho) = wd(0, j, k, irho) + w(0, j, k, ivx)*tmpd13
          wd(0, j, k, ivx) = wd(0, j, k, ivx) + w(0, j, k, irho)*tmpd13
        end do
      end do
      do k=kb,0,-1
        do j=jl,2,-1
          do i=il,2,-1
            call popreal8(w(i, j, k, irhoe))
            pd(i, j, k) = pd(i, j, k) + wd(i, j, k, irhoe)
            call popreal8(w(i, j, k, ivz))
            tmpd = wd(i, j, k, ivz)
            wd(i, j, k, ivz) = 0.0_8
            wd(i, j, k, irho) = wd(i, j, k, irho) + w(i, j, k, ivz)*tmpd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) + w(i, j, k, irho)*tmpd
            call popreal8(w(i, j, k, ivy))
            tmpd0 = wd(i, j, k, ivy)
            wd(i, j, k, ivy) = 0.0_8
            wd(i, j, k, irho) = wd(i, j, k, irho) + w(i, j, k, ivy)*&
&             tmpd0
            wd(i, j, k, ivy) = wd(i, j, k, ivy) + w(i, j, k, irho)*tmpd0
            call popreal8(w(i, j, k, ivx))
            tmpd1 = wd(i, j, k, ivx)
            wd(i, j, k, ivx) = 0.0_8
            wd(i, j, k, irho) = wd(i, j, k, irho) + w(i, j, k, ivx)*&
&             tmpd1
            wd(i, j, k, ivx) = wd(i, j, k, ivx) + w(i, j, k, irho)*tmpd1
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxscalarapprox_b
  subroutine invisciddissfluxscalarapprox()
!
!       invisciddissfluxscalar computes the scalar artificial
!       dissipation, see aiaa paper 81-1259, for a given block.
!       therefore it is assumed that the pointers in  blockpointers
!       already point to the correct block.
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    implicit none
!
!      local parameter.
!
    real(kind=realtype), parameter :: dssmax=0.25_realtype
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: sslim, rhoi
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: dss1, dss2, ddw, fs
    intrinsic abs
    intrinsic max
    intrinsic min
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! determine the variables used to compute the switch.
! for the inviscid case this is the pressure; for the viscous
! case it is the entropy.
      select case  (equations)
      case (eulerequations)
! inviscid case. pressure switch is based on the pressure.
! also set the value of sslim. to be fully consistent this
! must have the dimension of pressure and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr
      case (nsequations, ransequations)
!===============================================================
! viscous case. pressure switch is based on the entropy.
! also set the value of sslim. to be fully consistent this
! must have the dimension of entropy and it is therefore
! set to a fraction of the free stream value.
        sslim = 0.001_realtype*pinfcorr/rhoinf**gammainf
      end select
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! replace the total energy by rho times the total enthalpy.
! in this way the numerical solution is total enthalpy preserving
! for the steady euler equations. also replace the velocities by
! the momentum. only done for the entries used in the
! discretization, i.e. ignore the corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            w(i, j, k, ivx) = w(i, j, k, irho)*w(i, j, k, ivx)
            w(i, j, k, ivy) = w(i, j, k, irho)*w(i, j, k, ivy)
            w(i, j, k, ivz) = w(i, j, k, irho)*w(i, j, k, ivz)
            w(i, j, k, irhoe) = w(i, j, k, irhoe) + p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          w(0, j, k, ivx) = w(0, j, k, irho)*w(0, j, k, ivx)
          w(0, j, k, ivy) = w(0, j, k, irho)*w(0, j, k, ivy)
          w(0, j, k, ivz) = w(0, j, k, irho)*w(0, j, k, ivz)
          w(0, j, k, irhoe) = w(0, j, k, irhoe) + p(0, j, k)
          w(1, j, k, ivx) = w(1, j, k, irho)*w(1, j, k, ivx)
          w(1, j, k, ivy) = w(1, j, k, irho)*w(1, j, k, ivy)
          w(1, j, k, ivz) = w(1, j, k, irho)*w(1, j, k, ivz)
          w(1, j, k, irhoe) = w(1, j, k, irhoe) + p(1, j, k)
          w(ie, j, k, ivx) = w(ie, j, k, irho)*w(ie, j, k, ivx)
          w(ie, j, k, ivy) = w(ie, j, k, irho)*w(ie, j, k, ivy)
          w(ie, j, k, ivz) = w(ie, j, k, irho)*w(ie, j, k, ivz)
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) + p(ie, j, k)
          w(ib, j, k, ivx) = w(ib, j, k, irho)*w(ib, j, k, ivx)
          w(ib, j, k, ivy) = w(ib, j, k, irho)*w(ib, j, k, ivy)
          w(ib, j, k, ivz) = w(ib, j, k, irho)*w(ib, j, k, ivz)
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) + p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          w(i, 0, k, ivx) = w(i, 0, k, irho)*w(i, 0, k, ivx)
          w(i, 0, k, ivy) = w(i, 0, k, irho)*w(i, 0, k, ivy)
          w(i, 0, k, ivz) = w(i, 0, k, irho)*w(i, 0, k, ivz)
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) + p(i, 0, k)
          w(i, 1, k, ivx) = w(i, 1, k, irho)*w(i, 1, k, ivx)
          w(i, 1, k, ivy) = w(i, 1, k, irho)*w(i, 1, k, ivy)
          w(i, 1, k, ivz) = w(i, 1, k, irho)*w(i, 1, k, ivz)
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) + p(i, 1, k)
          w(i, je, k, ivx) = w(i, je, k, irho)*w(i, je, k, ivx)
          w(i, je, k, ivy) = w(i, je, k, irho)*w(i, je, k, ivy)
          w(i, je, k, ivz) = w(i, je, k, irho)*w(i, je, k, ivz)
          w(i, je, k, irhoe) = w(i, je, k, irhoe) + p(i, je, k)
          w(i, jb, k, ivx) = w(i, jb, k, irho)*w(i, jb, k, ivx)
          w(i, jb, k, ivy) = w(i, jb, k, irho)*w(i, jb, k, ivy)
          w(i, jb, k, ivz) = w(i, jb, k, irho)*w(i, jb, k, ivz)
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) + p(i, jb, k)
        end do
      end do
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      do k=2,kl
        do j=2,jl
          do i=2,il
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
!
!       dissipative fluxes in the i-direction.
!
      do k=2,kl
        do j=2,jl
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(shocksensor(2, j, k)+two*shocksensor(&
&           1, j, k)+shocksensor(0, j, k)+sslim)
          if (x1 .ge. 0.) then
            dss1 = x1
          else
            dss1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k)+sslim)
            if (x2 .ge. 0.) then
              dss2 = x2
            else
              dss2 = -x2
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
            if (dss1 .lt. dss2) then
              y1 = dss2
            else
              y1 = dss1
            end if
            if (dssmax .gt. y1) then
              min1 = y1
            else
              min1 = dssmax
            end if
! modification for fd preconditioner note: this lumping
! actually still results in a greater than 3 cell stencil
! in any direction. since this seems to work slightly
! better than the dis2=sigma*fis4*rrad, we will just use
! a 5-cell stencil for doing the pc
            dis2 = fis2*rrad*min1 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            fs = dis2*ddw
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw = w(i+1, j, k, ivx) - w(i, j, k, ivx)
            fs = dis2*ddw
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw = w(i+1, j, k, ivy) - w(i, j, k, ivy)
            fs = dis2*ddw
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw = w(i+1, j, k, ivz) - w(i, j, k, ivz)
            fs = dis2*ddw
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            fs = dis2*ddw
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.
!
      do k=2,kl
        do i=2,il
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(shocksensor(i, 2, k)+two*shocksensor(&
&           i, 1, k)+shocksensor(i, 0, k)+sslim)
          if (x3 .ge. 0.) then
            dss1 = x3
          else
            dss1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k)+sslim)
            if (x4 .ge. 0.) then
              dss2 = x4
            else
              dss2 = -x4
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
            if (dss1 .lt. dss2) then
              y2 = dss2
            else
              y2 = dss1
            end if
            if (dssmax .gt. y2) then
              min2 = y2
            else
              min2 = dssmax
            end if
! modification for fd preconditioner
            dis2 = fis2*rrad*min2 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            fs = dis2*ddw
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw = w(i, j+1, k, ivx) - w(i, j, k, ivx)
            fs = dis2*ddw
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw = w(i, j+1, k, ivy) - w(i, j, k, ivy)
            fs = dis2*ddw
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw = w(i, j+1, k, ivz) - w(i, j, k, ivz)
            fs = dis2*ddw
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            fs = dis2*ddw
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.
!
      do j=2,jl
        do i=2,il
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(shocksensor(i, j, 2)+two*shocksensor(&
&           i, j, 1)+shocksensor(i, j, 0)+sslim)
          if (x5 .ge. 0.) then
            dss1 = x5
          else
            dss1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k)+sslim)
            if (x6 .ge. 0.) then
              dss2 = x6
            else
              dss2 = -x6
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = half
            rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
            if (dss1 .lt. dss2) then
              y3 = dss2
            else
              y3 = dss1
            end if
            if (dssmax .gt. y3) then
              min3 = y3
            else
              min3 = dssmax
            end if
! modification for fd preconditioner
            dis2 = fis2*rrad*min3 + sigma*fis4*rrad
! compute and scatter the dissipative flux.
! density. store it in the mass flow of the
! appropriate sliding mesh interface.
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            fs = dis2*ddw
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            ddw = w(i, j, k+1, ivx) - w(i, j, k, ivx)
            fs = dis2*ddw
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            ddw = w(i, j, k+1, ivy) - w(i, j, k, ivy)
            fs = dis2*ddw
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            ddw = w(i, j, k+1, ivz) - w(i, j, k, ivz)
            fs = dis2*ddw
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            fs = dis2*ddw
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dss1 to dss2 for the next face.
            dss1 = dss2
          end do
        end do
      end do
! replace rho times the total enthalpy by the total energy and
! store the velocities again instead of the momentum. only for
! those entries that have been altered, i.e. ignore the
! corner halo's.
      do k=0,kb
        do j=2,jl
          do i=2,il
            rhoi = one/w(i, j, k, irho)
            w(i, j, k, ivx) = w(i, j, k, ivx)*rhoi
            w(i, j, k, ivy) = w(i, j, k, ivy)*rhoi
            w(i, j, k, ivz) = w(i, j, k, ivz)*rhoi
            w(i, j, k, irhoe) = w(i, j, k, irhoe) - p(i, j, k)
          end do
        end do
      end do
      do k=2,kl
        do j=2,jl
          rhoi = one/w(0, j, k, irho)
          w(0, j, k, ivx) = w(0, j, k, ivx)*rhoi
          w(0, j, k, ivy) = w(0, j, k, ivy)*rhoi
          w(0, j, k, ivz) = w(0, j, k, ivz)*rhoi
          w(0, j, k, irhoe) = w(0, j, k, irhoe) - p(0, j, k)
          rhoi = one/w(1, j, k, irho)
          w(1, j, k, ivx) = w(1, j, k, ivx)*rhoi
          w(1, j, k, ivy) = w(1, j, k, ivy)*rhoi
          w(1, j, k, ivz) = w(1, j, k, ivz)*rhoi
          w(1, j, k, irhoe) = w(1, j, k, irhoe) - p(1, j, k)
          rhoi = one/w(ie, j, k, irho)
          w(ie, j, k, ivx) = w(ie, j, k, ivx)*rhoi
          w(ie, j, k, ivy) = w(ie, j, k, ivy)*rhoi
          w(ie, j, k, ivz) = w(ie, j, k, ivz)*rhoi
          w(ie, j, k, irhoe) = w(ie, j, k, irhoe) - p(ie, j, k)
          rhoi = one/w(ib, j, k, irho)
          w(ib, j, k, ivx) = w(ib, j, k, ivx)*rhoi
          w(ib, j, k, ivy) = w(ib, j, k, ivy)*rhoi
          w(ib, j, k, ivz) = w(ib, j, k, ivz)*rhoi
          w(ib, j, k, irhoe) = w(ib, j, k, irhoe) - p(ib, j, k)
        end do
      end do
      do k=2,kl
        do i=2,il
          rhoi = one/w(i, 0, k, irho)
          w(i, 0, k, ivx) = w(i, 0, k, ivx)*rhoi
          w(i, 0, k, ivy) = w(i, 0, k, ivy)*rhoi
          w(i, 0, k, ivz) = w(i, 0, k, ivz)*rhoi
          w(i, 0, k, irhoe) = w(i, 0, k, irhoe) - p(i, 0, k)
          rhoi = one/w(i, 1, k, irho)
          w(i, 1, k, ivx) = w(i, 1, k, ivx)*rhoi
          w(i, 1, k, ivy) = w(i, 1, k, ivy)*rhoi
          w(i, 1, k, ivz) = w(i, 1, k, ivz)*rhoi
          w(i, 1, k, irhoe) = w(i, 1, k, irhoe) - p(i, 1, k)
          rhoi = one/w(i, je, k, irho)
          w(i, je, k, ivx) = w(i, je, k, ivx)*rhoi
          w(i, je, k, ivy) = w(i, je, k, ivy)*rhoi
          w(i, je, k, ivz) = w(i, je, k, ivz)*rhoi
          w(i, je, k, irhoe) = w(i, je, k, irhoe) - p(i, je, k)
          rhoi = one/w(i, jb, k, irho)
          w(i, jb, k, ivx) = w(i, jb, k, ivx)*rhoi
          w(i, jb, k, ivy) = w(i, jb, k, ivy)*rhoi
          w(i, jb, k, ivz) = w(i, jb, k, ivz)*rhoi
          w(i, jb, k, irhoe) = w(i, jb, k, irhoe) - p(i, jb, k)
        end do
      end do
    end if
  end subroutine invisciddissfluxscalarapprox
!  differentiation of invisciddissfluxmatrixapprox in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *p *w *fw
!   with respect to varying inputs: *p *w *fw
!   rw status of diff variables: *p:incr *w:incr *fw:in-out
!   plus diff mem management of: p:in w:in fw:in
  subroutine invisciddissfluxmatrixapprox_b()
!
!       invisciddissfluxmatrix computes the matrix artificial
!       dissipation term. instead of the spectral radius, as used in
!       the scalar dissipation scheme, the absolute value of the flux
!       jacobian is used. this leads to a less diffusive and
!       consequently more accurate scheme. it is assumed that the
!       pointers in blockpointers already point to the correct block.
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    use utils_b, only : getcorrectfork
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: rradd
    real(kind=realtype) :: dp1, dp2, ddw, tmp, fs
    real(kind=realtype) :: ddwd, fsd
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
&   abv7d
    logical :: correctfork
    intrinsic abs
    intrinsic max
    intrinsic min
    intrinsic sqrt
    integer :: branch
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd10
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: tempd9
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd8
    real(kind=realtype) :: tempd7
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: abs12
    real(kind=realtype) :: abs11
    real(kind=realtype) :: abs10
    real(kind=realtype) :: abs9
    real(kind=realtype) :: abs8
    real(kind=realtype) :: abs7
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: temp
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    real(kind=realtype) :: temp4
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .ge. thresholdreal) then
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
!
!       dissipative fluxes in the i-direction.
!
      do k=2,kl
        do j=2,jl
          if (shocksensor(2, j, k) - shocksensor(1, j, k) .ge. 0.) then
            abs1 = shocksensor(2, j, k) - shocksensor(1, j, k)
          else
            abs1 = -(shocksensor(2, j, k)-shocksensor(1, j, k))
          end if
          if (shocksensor(1, j, k) - shocksensor(0, j, k) .ge. 0.) then
            abs7 = shocksensor(1, j, k) - shocksensor(0, j, k)
          else
            abs7 = -(shocksensor(1, j, k)-shocksensor(0, j, k))
          end if
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(omega*(shocksensor(2, j, k)+two*&
&           shocksensor(1, j, k)+shocksensor(0, j, k))+oneminomega*(abs1&
&           +abs7)+plim)
          if (x1 .ge. 0.) then
            dp1 = x1
          else
            dp1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            if (shocksensor(i+2, j, k) - shocksensor(i+1, j, k) .ge. 0.&
&           ) then
              abs2 = shocksensor(i+2, j, k) - shocksensor(i+1, j, k)
            else
              abs2 = -(shocksensor(i+2, j, k)-shocksensor(i+1, j, k))
            end if
            if (shocksensor(i+1, j, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs8 = shocksensor(i+1, j, k) - shocksensor(i, j, k)
            else
              abs8 = -(shocksensor(i+1, j, k)-shocksensor(i, j, k))
            end if
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs2+abs8)+plim)
            if (x2 .ge. 0.) then
              dp2 = x2
            else
              dp2 = -x2
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y1 = dp2
            else
              y1 = dp1
            end if
            if (dpmax .gt. y1) then
              min1 = y1
            else
              min1 = dpmax
            end if
            call pushreal8(dis2)
            dis2 = fis2*ppor*min1 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            call pushreal8(dr)
            dr = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            call pushreal8(dru)
            dru = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            call pushreal8(drv)
            drv = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            call pushreal8(drw)
            drw = dis2*ddw
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            call pushreal8(dre)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
              call pushcontrol1b(1)
            else
              call pushcontrol1b(0)
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
            call pushreal8(a2avg)
            a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            call pushreal8(sx)
            sx = si(i, j, k, 1)
            call pushreal8(sy)
            sy = si(i, j, k, 2)
            call pushreal8(sz)
            sz = si(i, j, k, 3)
            call pushreal8(area)
            area = sqrt(sx**2 + sy**2 + sz**2)
            if (1.e-25_realtype .lt. area) then
              max1 = area
            else
              max1 = 1.e-25_realtype
            end if
            tmp = one/max1
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            call pushreal8(havg)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            call pushreal8(aavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacei(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
              call pushcontrol1b(0)
            else
              lam1 = -(unavg-sface+aavg)
              call pushcontrol1b(1)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
              call pushcontrol1b(0)
            else
              lam2 = -(unavg-sface-aavg)
              call pushcontrol1b(1)
            end if
            if (unavg - sface .ge. 0.) then
              call pushreal8(lam3)
              lam3 = unavg - sface
              call pushcontrol1b(0)
            else
              call pushreal8(lam3)
              lam3 = -(unavg-sface)
              call pushcontrol1b(1)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
              call pushcontrol1b(0)
            else
              lam3 = lam3
              call pushcontrol1b(1)
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            call pushreal8(abv2)
            abv2 = half*(lam1-lam2)
            call pushreal8(abv3)
            abv3 = abv1 - lam3
            call pushreal8(abv4)
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.
!
      do k=2,kl
        do i=2,il
          if (shocksensor(i, 2, k) - shocksensor(i, 1, k) .ge. 0.) then
            abs3 = shocksensor(i, 2, k) - shocksensor(i, 1, k)
          else
            abs3 = -(shocksensor(i, 2, k)-shocksensor(i, 1, k))
          end if
          if (shocksensor(i, 1, k) - shocksensor(i, 0, k) .ge. 0.) then
            abs9 = shocksensor(i, 1, k) - shocksensor(i, 0, k)
          else
            abs9 = -(shocksensor(i, 1, k)-shocksensor(i, 0, k))
          end if
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(omega*(shocksensor(i, 2, k)+two*&
&           shocksensor(i, 1, k)+shocksensor(i, 0, k))+oneminomega*(abs3&
&           +abs9)+plim)
          if (x3 .ge. 0.) then
            dp1 = x3
          else
            dp1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            if (shocksensor(i, j+2, k) - shocksensor(i, j+1, k) .ge. 0.&
&           ) then
              abs4 = shocksensor(i, j+2, k) - shocksensor(i, j+1, k)
            else
              abs4 = -(shocksensor(i, j+2, k)-shocksensor(i, j+1, k))
            end if
            if (shocksensor(i, j+1, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs10 = shocksensor(i, j+1, k) - shocksensor(i, j, k)
            else
              abs10 = -(shocksensor(i, j+1, k)-shocksensor(i, j, k))
            end if
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs4+abs10)+plim)
            if (x4 .ge. 0.) then
              dp2 = x4
            else
              dp2 = -x4
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y2 = dp2
            else
              y2 = dp1
            end if
            if (dpmax .gt. y2) then
              min2 = y2
            else
              min2 = dpmax
            end if
            call pushreal8(dis2)
            dis2 = fis2*ppor*min2 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            call pushreal8(dr)
            dr = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            call pushreal8(dru)
            dru = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            call pushreal8(drv)
            drv = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            call pushreal8(drw)
            drw = dis2*ddw
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            call pushreal8(dre)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
              call pushcontrol1b(1)
            else
              call pushcontrol1b(0)
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
            call pushreal8(a2avg)
            a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            call pushreal8(sx)
            sx = sj(i, j, k, 1)
            call pushreal8(sy)
            sy = sj(i, j, k, 2)
            call pushreal8(sz)
            sz = sj(i, j, k, 3)
            call pushreal8(area)
            area = sqrt(sx**2 + sy**2 + sz**2)
            if (1.e-25_realtype .lt. area) then
              max2 = area
            else
              max2 = 1.e-25_realtype
            end if
            tmp = one/max2
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            call pushreal8(havg)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            call pushreal8(aavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacej(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
              call pushcontrol1b(0)
            else
              lam1 = -(unavg-sface+aavg)
              call pushcontrol1b(1)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
              call pushcontrol1b(0)
            else
              lam2 = -(unavg-sface-aavg)
              call pushcontrol1b(1)
            end if
            if (unavg - sface .ge. 0.) then
              call pushreal8(lam3)
              lam3 = unavg - sface
              call pushcontrol1b(0)
            else
              call pushreal8(lam3)
              lam3 = -(unavg-sface)
              call pushcontrol1b(1)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
              call pushcontrol1b(0)
            else
              lam3 = lam3
              call pushcontrol1b(1)
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            call pushreal8(abv2)
            abv2 = half*(lam1-lam2)
            call pushreal8(abv3)
            abv3 = abv1 - lam3
            call pushreal8(abv4)
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.
!
      do j=2,jl
        do i=2,il
          if (shocksensor(i, j, 2) - shocksensor(i, j, 1) .ge. 0.) then
            abs5 = shocksensor(i, j, 2) - shocksensor(i, j, 1)
          else
            abs5 = -(shocksensor(i, j, 2)-shocksensor(i, j, 1))
          end if
          if (shocksensor(i, j, 1) - shocksensor(i, j, 0) .ge. 0.) then
            abs11 = shocksensor(i, j, 1) - shocksensor(i, j, 0)
          else
            abs11 = -(shocksensor(i, j, 1)-shocksensor(i, j, 0))
          end if
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(omega*(shocksensor(i, j, 2)+two*&
&           shocksensor(i, j, 1)+shocksensor(i, j, 0))+oneminomega*(abs5&
&           +abs11)+plim)
          if (x5 .ge. 0.) then
            dp1 = x5
          else
            dp1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            if (shocksensor(i, j, k+2) - shocksensor(i, j, k+1) .ge. 0.&
&           ) then
              abs6 = shocksensor(i, j, k+2) - shocksensor(i, j, k+1)
            else
              abs6 = -(shocksensor(i, j, k+2)-shocksensor(i, j, k+1))
            end if
            if (shocksensor(i, j, k+1) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs12 = shocksensor(i, j, k+1) - shocksensor(i, j, k)
            else
              abs12 = -(shocksensor(i, j, k+1)-shocksensor(i, j, k))
            end if
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k))+oneminomega*(&
&             abs6+abs12)+plim)
            if (x6 .ge. 0.) then
              dp2 = x6
            else
              dp2 = -x6
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y3 = dp2
            else
              y3 = dp1
            end if
            if (dpmax .gt. y3) then
              min3 = y3
            else
              min3 = dpmax
            end if
            call pushreal8(dis2)
            dis2 = fis2*ppor*min3 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            call pushreal8(dr)
            dr = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            call pushreal8(dru)
            dru = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            call pushreal8(drv)
            drv = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            call pushreal8(drw)
            drw = dis2*ddw
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            call pushreal8(dre)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
              call pushcontrol1b(1)
            else
              call pushcontrol1b(0)
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
            call pushreal8(a2avg)
            a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            call pushreal8(sx)
            sx = sk(i, j, k, 1)
            call pushreal8(sy)
            sy = sk(i, j, k, 2)
            call pushreal8(sz)
            sz = sk(i, j, k, 3)
            call pushreal8(area)
            area = sqrt(sx**2 + sy**2 + sz**2)
            if (1.e-25_realtype .lt. area) then
              max3 = area
            else
              max3 = 1.e-25_realtype
            end if
            tmp = one/max3
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            call pushreal8(havg)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            call pushreal8(aavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacek(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
              call pushcontrol1b(0)
            else
              lam1 = -(unavg-sface+aavg)
              call pushcontrol1b(1)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
              call pushcontrol1b(0)
            else
              lam2 = -(unavg-sface-aavg)
              call pushcontrol1b(1)
            end if
            if (unavg - sface .ge. 0.) then
              call pushreal8(lam3)
              lam3 = unavg - sface
              call pushcontrol1b(0)
            else
              call pushreal8(lam3)
              lam3 = -(unavg-sface)
              call pushcontrol1b(1)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
              call pushcontrol1b(0)
            else
              lam3 = lam3
              call pushcontrol1b(1)
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            call pushreal8(abv2)
            abv2 = half*(lam1-lam2)
            call pushreal8(abv3)
            abv3 = abv1 - lam3
            call pushreal8(abv4)
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
      do j=jl,2,-1
        do i=il,2,-1
          do k=kl,1,-1
            fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
            wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
            vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
            uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
            unavg = uavg*sx + vavg*sy + wavg*sz
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            ovaavg = one/aavg
            ova2avg = one/a2avg
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
            lam3d = dre*fsd
            dred = lam3*fsd
            havgd = abv6*fsd
            abv6d = havg*fsd
            unavgd = abv7*fsd
            abv7d = unavg*fsd
            fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
            lam3d = lam3d + drw*fsd
            drwd = lam3*fsd
            wavgd = abv6*fsd
            abv6d = abv6d + wavg*fsd
            abv7d = abv7d + sz*fsd
            fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
            lam3d = lam3d + drv*fsd
            drvd = lam3*fsd
            vavgd = abv6*fsd
            abv6d = abv6d + vavg*fsd
            abv7d = abv7d + sy*fsd
            fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
            lam3d = lam3d + dru*fsd
            drud = lam3*fsd
            uavgd = abv6*fsd
            abv6d = abv6d + uavg*fsd
            abv7d = abv7d + sx*fsd
            fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
            abv6d = abv6d + fsd
            abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
            abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
            ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
            abv3d = ova2avg*abv4*abv6d + abv5*abv7d
            lam3d = lam3d + dr*fsd - abv3d
            abv5d = ovaavg*abv2*abv6d + abv3*abv7d
            ova2avgd = abv3*abv4*abv6d
            unavgd = unavgd - dr*abv5d
            gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
            gm1 = gammaavg - one
            gm53 = gammaavg - five*third
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            call popreal8(abv4)
            tempd10 = gm1*abv4d
            drd = alphaavg*tempd10 - unavg*abv5d + lam3*fsd
            drud = drud + sx*abv5d - uavg*tempd10
            drvd = drvd + sy*abv5d - vavg*tempd10
            drwd = drwd + sz*abv5d - wavg*tempd10
            alphaavgd = dr*tempd10
            uavgd = uavgd - dru*tempd10
            vavgd = vavgd - drv*tempd10
            dred = dred + tempd10
            wavgd = wavgd - drw*tempd10
            drkd = -(gm53*abv4d)
            call popreal8(abv3)
            abv1d = abv3d
            call popreal8(abv2)
            lam1d = half*abv1d + half*abv2d
            lam2d = half*abv1d - half*abv2d
            lam3d = area*lam3d
            lam2d = area*lam2d
            lam1d = area*lam1d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = epsshear*lam3d
              lam3d = 0.0_8
            else
              rradd = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = rradd + epsacoustic*lam2d
              lam2d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = rradd + epsacoustic*lam1d
              lam1d = 0.0_8
            end if
            lam3d = lam3d + rradd
            aavgd = rradd
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(lam3)
              unavgd = unavgd + lam3d
            else
              call popreal8(lam3)
              unavgd = unavgd - lam3d
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              unavgd = unavgd + lam2d
              aavgd = aavgd - lam2d
            else
              aavgd = aavgd + lam2d
              unavgd = unavgd - lam2d
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              unavgd = unavgd + lam1d
              aavgd = aavgd + lam1d
            else
              unavgd = unavgd - lam1d
              aavgd = aavgd - lam1d
            end if
            alphaavgd = alphaavgd + havgd
            tempd9 = half*alphaavgd
            ovgm1 = one/gm1
            aavgd = aavgd - one*ovaavgd/aavg**2
            if (a2avg .eq. 0.0_8) then
              a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
            else
              a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&               ova2avgd/a2avg**2
            end if
            uavgd = uavgd + 2*uavg*tempd9 + sx*unavgd
            vavgd = vavgd + 2*vavg*tempd9 + sy*unavgd
            wavgd = wavgd + 2*wavg*tempd9 + sz*unavgd
            call popreal8(aavg)
            call popreal8(havg)
            kavgd = -(ovgm1*gm53*havgd)
            call popreal8(area)
            call popreal8(sz)
            call popreal8(sy)
            call popreal8(sx)
            call popreal8(a2avg)
            temp4 = w(i, j, k, irho)
            temp3 = w(i, j, k+1, irho)
            tempd7 = gamma(i, j, k+1)*half*a2avgd/temp3
            tempd8 = gamma(i, j, k)*half*a2avgd/temp4
            pd(i, j, k+1) = pd(i, j, k+1) + tempd7
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - p(i, j, k+1)*&
&             tempd7/temp3
            pd(i, j, k) = pd(i, j, k) + tempd8
            wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd8/&
&             temp4
            wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wavgd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
            wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vavgd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
            wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*uavgd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
            call popcontrol1b(branch)
            if (branch .ne. 0) then
              wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*kavgd
              wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
              ddwd = dis2*drkd
              wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, &
&               itu1)*ddwd
              wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + w(i, j, k+1, &
&               irho)*ddwd
              wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&               ddwd
              wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&               ddwd
            end if
            call popreal8(dre)
            ddwd = dis2*dred
            wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddwd
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
            call popreal8(drw)
            ddwd = dis2*drwd
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz&
&             )*ddwd
            wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
            call popreal8(drv)
            ddwd = dis2*drvd
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy&
&             )*ddwd
            wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
            call popreal8(dru)
            ddwd = dis2*drud
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx&
&             )*ddwd
            wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
            call popreal8(dr)
            ddwd = dis2*drd
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
            call popreal8(dis2)
          end do
        end do
      end do
      do k=kl,2,-1
        do i=il,2,-1
          do j=jl,1,-1
            fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
            wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
            vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
            uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
            unavg = uavg*sx + vavg*sy + wavg*sz
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            ovaavg = one/aavg
            ova2avg = one/a2avg
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
            lam3d = dre*fsd
            dred = lam3*fsd
            havgd = abv6*fsd
            abv6d = havg*fsd
            unavgd = abv7*fsd
            abv7d = unavg*fsd
            fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
            lam3d = lam3d + drw*fsd
            drwd = lam3*fsd
            wavgd = abv6*fsd
            abv6d = abv6d + wavg*fsd
            abv7d = abv7d + sz*fsd
            fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
            lam3d = lam3d + drv*fsd
            drvd = lam3*fsd
            vavgd = abv6*fsd
            abv6d = abv6d + vavg*fsd
            abv7d = abv7d + sy*fsd
            fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
            lam3d = lam3d + dru*fsd
            drud = lam3*fsd
            uavgd = abv6*fsd
            abv6d = abv6d + uavg*fsd
            abv7d = abv7d + sx*fsd
            fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
            abv6d = abv6d + fsd
            abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
            abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
            ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
            abv3d = ova2avg*abv4*abv6d + abv5*abv7d
            lam3d = lam3d + dr*fsd - abv3d
            abv5d = ovaavg*abv2*abv6d + abv3*abv7d
            ova2avgd = abv3*abv4*abv6d
            unavgd = unavgd - dr*abv5d
            gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            gm53 = gammaavg - five*third
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            call popreal8(abv4)
            tempd6 = gm1*abv4d
            drd = alphaavg*tempd6 - unavg*abv5d + lam3*fsd
            drud = drud + sx*abv5d - uavg*tempd6
            drvd = drvd + sy*abv5d - vavg*tempd6
            drwd = drwd + sz*abv5d - wavg*tempd6
            alphaavgd = dr*tempd6
            uavgd = uavgd - dru*tempd6
            vavgd = vavgd - drv*tempd6
            dred = dred + tempd6
            wavgd = wavgd - drw*tempd6
            drkd = -(gm53*abv4d)
            call popreal8(abv3)
            abv1d = abv3d
            call popreal8(abv2)
            lam1d = half*abv1d + half*abv2d
            lam2d = half*abv1d - half*abv2d
            lam3d = area*lam3d
            lam2d = area*lam2d
            lam1d = area*lam1d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = epsshear*lam3d
              lam3d = 0.0_8
            else
              rradd = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = rradd + epsacoustic*lam2d
              lam2d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = rradd + epsacoustic*lam1d
              lam1d = 0.0_8
            end if
            lam3d = lam3d + rradd
            aavgd = rradd
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(lam3)
              unavgd = unavgd + lam3d
            else
              call popreal8(lam3)
              unavgd = unavgd - lam3d
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              unavgd = unavgd + lam2d
              aavgd = aavgd - lam2d
            else
              aavgd = aavgd + lam2d
              unavgd = unavgd - lam2d
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              unavgd = unavgd + lam1d
              aavgd = aavgd + lam1d
            else
              unavgd = unavgd - lam1d
              aavgd = aavgd - lam1d
            end if
            alphaavgd = alphaavgd + havgd
            tempd5 = half*alphaavgd
            ovgm1 = one/gm1
            aavgd = aavgd - one*ovaavgd/aavg**2
            if (a2avg .eq. 0.0_8) then
              a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
            else
              a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&               ova2avgd/a2avg**2
            end if
            uavgd = uavgd + 2*uavg*tempd5 + sx*unavgd
            vavgd = vavgd + 2*vavg*tempd5 + sy*unavgd
            wavgd = wavgd + 2*wavg*tempd5 + sz*unavgd
            call popreal8(aavg)
            call popreal8(havg)
            kavgd = -(ovgm1*gm53*havgd)
            call popreal8(area)
            call popreal8(sz)
            call popreal8(sy)
            call popreal8(sx)
            call popreal8(a2avg)
            temp2 = w(i, j, k, irho)
            temp1 = w(i, j+1, k, irho)
            tempd3 = gamma(i, j+1, k)*half*a2avgd/temp1
            tempd4 = gamma(i, j, k)*half*a2avgd/temp2
            pd(i, j+1, k) = pd(i, j+1, k) + tempd3
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - p(i, j+1, k)*&
&             tempd3/temp1
            pd(i, j, k) = pd(i, j, k) + tempd4
            wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd4/&
&             temp2
            wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wavgd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
            wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vavgd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
            wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*uavgd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
            call popcontrol1b(branch)
            if (branch .ne. 0) then
              wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
              wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*kavgd
              ddwd = dis2*drkd
              wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, &
&               itu1)*ddwd
              wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + w(i, j+1, k, &
&               irho)*ddwd
              wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&               ddwd
              wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&               ddwd
            end if
            call popreal8(dre)
            ddwd = dis2*dred
            wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddwd
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
            call popreal8(drw)
            ddwd = dis2*drwd
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz&
&             )*ddwd
            wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
            call popreal8(drv)
            ddwd = dis2*drvd
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy&
&             )*ddwd
            wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
            call popreal8(dru)
            ddwd = dis2*drud
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx&
&             )*ddwd
            wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
            call popreal8(dr)
            ddwd = dis2*drd
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
            call popreal8(dis2)
          end do
        end do
      end do
      do k=kl,2,-1
        do j=jl,2,-1
          do i=il,1,-1
            fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
            wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
            vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
            uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
            unavg = uavg*sx + vavg*sy + wavg*sz
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            ovaavg = one/aavg
            ova2avg = one/a2avg
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
            lam3d = dre*fsd
            dred = lam3*fsd
            havgd = abv6*fsd
            abv6d = havg*fsd
            unavgd = abv7*fsd
            abv7d = unavg*fsd
            fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
            lam3d = lam3d + drw*fsd
            drwd = lam3*fsd
            wavgd = abv6*fsd
            abv6d = abv6d + wavg*fsd
            abv7d = abv7d + sz*fsd
            fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
            lam3d = lam3d + drv*fsd
            drvd = lam3*fsd
            vavgd = abv6*fsd
            abv6d = abv6d + vavg*fsd
            abv7d = abv7d + sy*fsd
            fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
            lam3d = lam3d + dru*fsd
            drud = lam3*fsd
            uavgd = abv6*fsd
            abv6d = abv6d + uavg*fsd
            abv7d = abv7d + sx*fsd
            fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
            abv6d = abv6d + fsd
            abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
            abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
            ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
            abv3d = ova2avg*abv4*abv6d + abv5*abv7d
            lam3d = lam3d + dr*fsd - abv3d
            abv5d = ovaavg*abv2*abv6d + abv3*abv7d
            ova2avgd = abv3*abv4*abv6d
            unavgd = unavgd - dr*abv5d
            gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            gm53 = gammaavg - five*third
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            call popreal8(abv4)
            tempd2 = gm1*abv4d
            drd = alphaavg*tempd2 - unavg*abv5d + lam3*fsd
            drud = drud + sx*abv5d - uavg*tempd2
            drvd = drvd + sy*abv5d - vavg*tempd2
            drwd = drwd + sz*abv5d - wavg*tempd2
            alphaavgd = dr*tempd2
            uavgd = uavgd - dru*tempd2
            vavgd = vavgd - drv*tempd2
            dred = dred + tempd2
            wavgd = wavgd - drw*tempd2
            drkd = -(gm53*abv4d)
            call popreal8(abv3)
            abv1d = abv3d
            call popreal8(abv2)
            lam1d = half*abv1d + half*abv2d
            lam2d = half*abv1d - half*abv2d
            lam3d = area*lam3d
            lam2d = area*lam2d
            lam1d = area*lam1d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = epsshear*lam3d
              lam3d = 0.0_8
            else
              rradd = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = rradd + epsacoustic*lam2d
              lam2d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              rradd = rradd + epsacoustic*lam1d
              lam1d = 0.0_8
            end if
            lam3d = lam3d + rradd
            aavgd = rradd
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8(lam3)
              unavgd = unavgd + lam3d
            else
              call popreal8(lam3)
              unavgd = unavgd - lam3d
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              unavgd = unavgd + lam2d
              aavgd = aavgd - lam2d
            else
              aavgd = aavgd + lam2d
              unavgd = unavgd - lam2d
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              unavgd = unavgd + lam1d
              aavgd = aavgd + lam1d
            else
              unavgd = unavgd - lam1d
              aavgd = aavgd - lam1d
            end if
            alphaavgd = alphaavgd + havgd
            tempd1 = half*alphaavgd
            ovgm1 = one/gm1
            aavgd = aavgd - one*ovaavgd/aavg**2
            if (a2avg .eq. 0.0_8) then
              a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
            else
              a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&               ova2avgd/a2avg**2
            end if
            uavgd = uavgd + 2*uavg*tempd1 + sx*unavgd
            vavgd = vavgd + 2*vavg*tempd1 + sy*unavgd
            wavgd = wavgd + 2*wavg*tempd1 + sz*unavgd
            call popreal8(aavg)
            call popreal8(havg)
            kavgd = -(ovgm1*gm53*havgd)
            call popreal8(area)
            call popreal8(sz)
            call popreal8(sy)
            call popreal8(sx)
            call popreal8(a2avg)
            temp0 = w(i, j, k, irho)
            temp = w(i+1, j, k, irho)
            tempd = gamma(i+1, j, k)*half*a2avgd/temp
            tempd0 = gamma(i, j, k)*half*a2avgd/temp0
            pd(i+1, j, k) = pd(i+1, j, k) + tempd
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - p(i+1, j, k)*&
&             tempd/temp
            pd(i, j, k) = pd(i, j, k) + tempd0
            wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd0/&
&             temp0
            wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wavgd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
            wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vavgd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
            wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*uavgd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
            call popcontrol1b(branch)
            if (branch .ne. 0) then
              wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
              wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*kavgd
              ddwd = dis2*drkd
              wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, &
&               itu1)*ddwd
              wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + w(i+1, j, k, &
&               irho)*ddwd
              wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&               ddwd
              wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&               ddwd
            end if
            call popreal8(dre)
            ddwd = dis2*dred
            wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddwd
            wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
            call popreal8(drw)
            ddwd = dis2*drwd
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz&
&             )*ddwd
            wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
            wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
            call popreal8(drv)
            ddwd = dis2*drvd
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy&
&             )*ddwd
            wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
            wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
            call popreal8(dru)
            ddwd = dis2*drud
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx&
&             )*ddwd
            wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)&
&             *ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
            wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
            call popreal8(dr)
            ddwd = dis2*drd
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
            call popreal8(dis2)
          end do
        end do
      end do
      do k=kl,2,-1
        do j=jl,2,-1
          do i=il,2,-1
            fwd(i, j, k, irhoe) = sfil*fwd(i, j, k, irhoe)
            fwd(i, j, k, imz) = sfil*fwd(i, j, k, imz)
            fwd(i, j, k, imy) = sfil*fwd(i, j, k, imy)
            fwd(i, j, k, imx) = sfil*fwd(i, j, k, imx)
            fwd(i, j, k, irho) = sfil*fwd(i, j, k, irho)
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxmatrixapprox_b
  subroutine invisciddissfluxmatrixapprox()
!
!       invisciddissfluxmatrix computes the matrix artificial
!       dissipation term. instead of the spectral radius, as used in
!       the scalar dissipation scheme, the absolute value of the flux
!       jacobian is used. this leads to a less diffusive and
!       consequently more accurate scheme. it is assumed that the
!       pointers in blockpointers already point to the correct block.
!
    use blockpointers
    use cgnsgrid
    use constants
    use flowvarrefstate
    use inputdiscretization
    use inputphysics
    use iteration
    use utils_b, only : getcorrectfork
    implicit none
!
!      local parameters.
!
    real(kind=realtype), parameter :: dpmax=0.25_realtype
    real(kind=realtype), parameter :: epsacoustic=0.25_realtype
    real(kind=realtype), parameter :: epsshear=0.025_realtype
    real(kind=realtype), parameter :: omega=0.5_realtype
    real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ind
    real(kind=realtype) :: plim, sface
    real(kind=realtype) :: sfil, fis2, fis4
    real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
    real(kind=realtype) :: ppor, rrad, dis2
    real(kind=realtype) :: dp1, dp2, ddw, tmp, fs
    real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
    real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
    real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
    real(kind=realtype) :: kavg, lam1, lam2, lam3, area
    real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
    logical :: correctfork
    intrinsic abs
    intrinsic max
    intrinsic min
    intrinsic sqrt
    real(kind=realtype) :: min3
    real(kind=realtype) :: min2
    real(kind=realtype) :: min1
    real(kind=realtype) :: x6
    real(kind=realtype) :: x5
    real(kind=realtype) :: x4
    real(kind=realtype) :: x3
    real(kind=realtype) :: x2
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs12
    real(kind=realtype) :: abs11
    real(kind=realtype) :: abs10
    real(kind=realtype) :: abs9
    real(kind=realtype) :: abs8
    real(kind=realtype) :: abs7
    real(kind=realtype) :: abs6
    real(kind=realtype) :: abs5
    real(kind=realtype) :: abs4
    real(kind=realtype) :: abs3
    real(kind=realtype) :: abs2
    real(kind=realtype) :: abs1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: max3
    real(kind=realtype) :: max2
    real(kind=realtype) :: max1
    real(kind=realtype) :: y3
    real(kind=realtype) :: y2
    real(kind=realtype) :: y1
    if (rfil .ge. 0.) then
      abs0 = rfil
    else
      abs0 = -rfil
    end if
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
    if (abs0 .lt. thresholdreal) then
      return
    else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
      plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
      correctfork = getcorrectfork()
! initialize sface to zero. this value will be used if the
! block is not moving.
      sface = zero
! set a couple of constants for the scheme.
      fis2 = rfil*vis2
      fis4 = rfil*vis4
      sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
      do k=2,kl
        do j=2,jl
          do i=2,il
            fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
            fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
            fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
            fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
            fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
          end do
        end do
      end do
!
!       dissipative fluxes in the i-direction.
!
      do k=2,kl
        do j=2,jl
          if (shocksensor(2, j, k) - shocksensor(1, j, k) .ge. 0.) then
            abs1 = shocksensor(2, j, k) - shocksensor(1, j, k)
          else
            abs1 = -(shocksensor(2, j, k)-shocksensor(1, j, k))
          end if
          if (shocksensor(1, j, k) - shocksensor(0, j, k) .ge. 0.) then
            abs7 = shocksensor(1, j, k) - shocksensor(0, j, k)
          else
            abs7 = -(shocksensor(1, j, k)-shocksensor(0, j, k))
          end if
          x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
&           shocksensor(0, j, k))/(omega*(shocksensor(2, j, k)+two*&
&           shocksensor(1, j, k)+shocksensor(0, j, k))+oneminomega*(abs1&
&           +abs7)+plim)
          if (x1 .ge. 0.) then
            dp1 = x1
          else
            dp1 = -x1
          end if
! loop in i-direction.
          do i=1,il
            if (shocksensor(i+2, j, k) - shocksensor(i+1, j, k) .ge. 0.&
&           ) then
              abs2 = shocksensor(i+2, j, k) - shocksensor(i+1, j, k)
            else
              abs2 = -(shocksensor(i+2, j, k)-shocksensor(i+1, j, k))
            end if
            if (shocksensor(i+1, j, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs8 = shocksensor(i+1, j, k) - shocksensor(i, j, k)
            else
              abs8 = -(shocksensor(i+1, j, k)-shocksensor(i, j, k))
            end if
            x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i+2, j, k)+two*&
&             shocksensor(i+1, j, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs2+abs8)+plim)
            if (x2 .ge. 0.) then
              dp2 = x2
            else
              dp2 = -x2
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pori(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y1 = dp2
            else
              y1 = dp1
            end if
            if (dpmax .gt. y1) then
              min1 = y1
            else
              min1 = dpmax
            end if
            dis2 = fis2*ppor*min1 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
            dr = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            dru = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drv = dis2*ddw
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drw = dis2*ddw
            ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = si(i, j, k, 1)
            sy = si(i, j, k, 2)
            sz = si(i, j, k, 3)
            area = sqrt(sx**2 + sy**2 + sz**2)
            if (1.e-25_realtype .lt. area) then
              max1 = area
            else
              max1 = 1.e-25_realtype
            end if
            tmp = one/max1
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacei(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the j-direction.
!
      do k=2,kl
        do i=2,il
          if (shocksensor(i, 2, k) - shocksensor(i, 1, k) .ge. 0.) then
            abs3 = shocksensor(i, 2, k) - shocksensor(i, 1, k)
          else
            abs3 = -(shocksensor(i, 2, k)-shocksensor(i, 1, k))
          end if
          if (shocksensor(i, 1, k) - shocksensor(i, 0, k) .ge. 0.) then
            abs9 = shocksensor(i, 1, k) - shocksensor(i, 0, k)
          else
            abs9 = -(shocksensor(i, 1, k)-shocksensor(i, 0, k))
          end if
          x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
&           shocksensor(i, 0, k))/(omega*(shocksensor(i, 2, k)+two*&
&           shocksensor(i, 1, k)+shocksensor(i, 0, k))+oneminomega*(abs3&
&           +abs9)+plim)
          if (x3 .ge. 0.) then
            dp1 = x3
          else
            dp1 = -x3
          end if
! loop in j-direction.
          do j=1,jl
            if (shocksensor(i, j+2, k) - shocksensor(i, j+1, k) .ge. 0.&
&           ) then
              abs4 = shocksensor(i, j+2, k) - shocksensor(i, j+1, k)
            else
              abs4 = -(shocksensor(i, j+2, k)-shocksensor(i, j+1, k))
            end if
            if (shocksensor(i, j+1, k) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs10 = shocksensor(i, j+1, k) - shocksensor(i, j, k)
            else
              abs10 = -(shocksensor(i, j+1, k)-shocksensor(i, j, k))
            end if
            x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j+2, k)+two*&
&             shocksensor(i, j+1, k)+shocksensor(i, j, k))+oneminomega*(&
&             abs4+abs10)+plim)
            if (x4 .ge. 0.) then
              dp2 = x4
            else
              dp2 = -x4
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (porj(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y2 = dp2
            else
              y2 = dp1
            end if
            if (dpmax .gt. y2) then
              min2 = y2
            else
              min2 = dpmax
            end if
            dis2 = fis2*ppor*min2 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
            dr = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            dru = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drv = dis2*ddw
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drw = dis2*ddw
            ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = sj(i, j, k, 1)
            sy = sj(i, j, k, 2)
            sz = sj(i, j, k, 3)
            area = sqrt(sx**2 + sy**2 + sz**2)
            if (1.e-25_realtype .lt. area) then
              max2 = area
            else
              max2 = 1.e-25_realtype
            end if
            tmp = one/max2
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacej(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
!
!       dissipative fluxes in the k-direction.
!
      do j=2,jl
        do i=2,il
          if (shocksensor(i, j, 2) - shocksensor(i, j, 1) .ge. 0.) then
            abs5 = shocksensor(i, j, 2) - shocksensor(i, j, 1)
          else
            abs5 = -(shocksensor(i, j, 2)-shocksensor(i, j, 1))
          end if
          if (shocksensor(i, j, 1) - shocksensor(i, j, 0) .ge. 0.) then
            abs11 = shocksensor(i, j, 1) - shocksensor(i, j, 0)
          else
            abs11 = -(shocksensor(i, j, 1)-shocksensor(i, j, 0))
          end if
          x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
&           shocksensor(i, j, 0))/(omega*(shocksensor(i, j, 2)+two*&
&           shocksensor(i, j, 1)+shocksensor(i, j, 0))+oneminomega*(abs5&
&           +abs11)+plim)
          if (x5 .ge. 0.) then
            dp1 = x5
          else
            dp1 = -x5
          end if
! loop in k-direction.
          do k=1,kl
            if (shocksensor(i, j, k+2) - shocksensor(i, j, k+1) .ge. 0.&
&           ) then
              abs6 = shocksensor(i, j, k+2) - shocksensor(i, j, k+1)
            else
              abs6 = -(shocksensor(i, j, k+2)-shocksensor(i, j, k+1))
            end if
            if (shocksensor(i, j, k+1) - shocksensor(i, j, k) .ge. 0.) &
&           then
              abs12 = shocksensor(i, j, k+1) - shocksensor(i, j, k)
            else
              abs12 = -(shocksensor(i, j, k+1)-shocksensor(i, j, k))
            end if
            x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
&             shocksensor(i, j, k))/(omega*(shocksensor(i, j, k+2)+two*&
&             shocksensor(i, j, k+1)+shocksensor(i, j, k))+oneminomega*(&
&             abs6+abs12)+plim)
            if (x6 .ge. 0.) then
              dp2 = x6
            else
              dp2 = -x6
            end if
! compute the dissipation coefficients for this face.
            ppor = zero
            if (pork(i, j, k) .eq. normalflux) ppor = one
            if (dp1 .lt. dp2) then
              y3 = dp2
            else
              y3 = dp1
            end if
            if (dpmax .gt. y3) then
              min3 = y3
            else
              min3 = dpmax
            end if
            dis2 = fis2*ppor*min3 + sigma*fis4*ppor
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
            ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
            dr = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho&
&             )*w(i, j, k, ivx)
            dru = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho&
&             )*w(i, j, k, ivy)
            drv = dis2*ddw
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho&
&             )*w(i, j, k, ivz)
            drw = dis2*ddw
            ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
            dre = dis2*ddw
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
            if (correctfork) then
              ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&               irho)*w(i, j, k, itu1)
              drk = dis2*ddw
              kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
            else
              drk = zero
              kavg = zero
            end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
            gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
            gm1 = gammaavg - one
            ovgm1 = one/gm1
            gm53 = gammaavg - five*third
! compute the average state at the interface.
            uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
            vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
            wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
            a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, &
&             irho)+gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
            sx = sk(i, j, k, 1)
            sy = sk(i, j, k, 2)
            sz = sk(i, j, k, 3)
            area = sqrt(sx**2 + sy**2 + sz**2)
            if (1.e-25_realtype .lt. area) then
              max3 = area
            else
              max3 = 1.e-25_realtype
            end if
            tmp = one/max3
            sx = sx*tmp
            sy = sy*tmp
            sz = sz*tmp
            alphaavg = half*(uavg**2+vavg**2+wavg**2)
            havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
            aavg = sqrt(a2avg)
            unavg = uavg*sx + vavg*sy + wavg*sz
            ovaavg = one/aavg
            ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
            if (addgridvelocities) sface = sfacek(i, j, k)*tmp
            if (unavg - sface + aavg .ge. 0.) then
              lam1 = unavg - sface + aavg
            else
              lam1 = -(unavg-sface+aavg)
            end if
            if (unavg - sface - aavg .ge. 0.) then
              lam2 = unavg - sface - aavg
            else
              lam2 = -(unavg-sface-aavg)
            end if
            if (unavg - sface .ge. 0.) then
              lam3 = unavg - sface
            else
              lam3 = -(unavg-sface)
            end if
            rrad = lam3 + aavg
            if (lam1 .lt. epsacoustic*rrad) then
              lam1 = epsacoustic*rrad
            else
              lam1 = lam1
            end if
            if (lam2 .lt. epsacoustic*rrad) then
              lam2 = epsacoustic*rrad
            else
              lam2 = lam2
            end if
            if (lam3 .lt. epsshear*rrad) then
              lam3 = epsshear*rrad
            else
              lam3 = lam3
            end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
            lam1 = lam1*area
            lam2 = lam2*area
            lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
            abv1 = half*(lam1+lam2)
            abv2 = half*(lam1-lam2)
            abv3 = abv1 - lam3
            abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - &
&             gm53*drk
            abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
            abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
            abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
            fs = lam3*dr + abv6
            fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
            fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
            fs = lam3*dru + uavg*abv6 + sx*abv7
            fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
            fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
            fs = lam3*drv + vavg*abv6 + sy*abv7
            fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
            fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
            fs = lam3*drw + wavg*abv6 + sz*abv7
            fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
            fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
            fs = lam3*dre + havg*abv6 + unavg*abv7
            fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
            fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
            dp1 = dp2
          end do
        end do
      end do
    end if
  end subroutine invisciddissfluxmatrixapprox
end module fluxes_b

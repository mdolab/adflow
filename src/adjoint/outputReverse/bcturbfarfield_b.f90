!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of bcturbfarfield in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: winf *bvtj1 *bvtj2 *bvtk1 *bvtk2
!                *bvti1 *bvti2
!   with respect to varying inputs: winf *bvtj1 *bvtj2 *bvtk1 *bvtk2
!                *bvti1 *bvti2
!   plus diff mem management of: bvtj1:in bvtj2:in bvtk1:in bvtk2:in
!                bvti1:in bvti2:in bcdata:in
subroutine bcturbfarfield_b(nn)
!
!       bcturbfarfield applies the implicit treatment of the           
!       farfield boundary condition to subface nn. as the farfield     
!       boundary condition is independent of the turbulence model,     
!       this routine is valid for all models. it is assumed that the   
!       pointers in blockpointers are already set to the correct       
!       block on the correct grid level.                               
!
  use constants
  use blockpointers
  use flowvarrefstate
  implicit none
!
!      subroutine arguments.
!
  integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
  integer(kind=inttype) :: i, j, l
  real(kind=realtype) :: nnx, nny, nnz, dot
  integer :: branch
! loop over the faces of the subfaces and set the values of
! bmt and bvt for an implicit treatment.
  do j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
    do i=bcdata(nn)%icbeg,bcdata(nn)%icend
! determine the dot product between the outward pointing
! normal and the free stream velocity direction and add the
! possible grid velocity.
      dot = bcdata(nn)%norm(i, j, 1)*winf(ivx) + bcdata(nn)%norm(i, j, 2&
&       )*winf(ivy) + bcdata(nn)%norm(i, j, 3)*winf(ivz) - bcdata(nn)%&
&       rface(i, j)
! determine whether we are dealing with an inflow or
! outflow boundary here.
      if (dot .gt. zero) then
        call pushcontrol1b(1)
      else
! inflow. turbulent variables are prescribed.
        do l=nt1,nt2
          select case  (bcfaceid(nn)) 
          case (imin) 
            call pushcontrol3b(5)
          case (imax) 
            call pushcontrol3b(4)
          case (jmin) 
            call pushcontrol3b(3)
          case (jmax) 
            call pushcontrol3b(2)
          case (kmin) 
            call pushcontrol3b(1)
          case (kmax) 
            call pushcontrol3b(0)
          case default
            call pushcontrol3b(6)
          end select
        end do
        call pushcontrol1b(0)
      end if
    end do
  end do
  do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
    do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        do l=nt2,nt1,-1
          call popcontrol3b(branch)
          if (branch .lt. 3) then
            if (branch .eq. 0) then
              winfd(l) = winfd(l) + bvtk2d(i, j, l)
              bvtk2d(i, j, l) = 0.0_8
            else if (branch .eq. 1) then
              winfd(l) = winfd(l) + bvtk1d(i, j, l)
              bvtk1d(i, j, l) = 0.0_8
            else
              winfd(l) = winfd(l) + bvtj2d(i, j, l)
              bvtj2d(i, j, l) = 0.0_8
            end if
          else if (branch .lt. 5) then
            if (branch .eq. 3) then
              winfd(l) = winfd(l) + bvtj1d(i, j, l)
              bvtj1d(i, j, l) = 0.0_8
            else
              winfd(l) = winfd(l) + bvti2d(i, j, l)
              bvti2d(i, j, l) = 0.0_8
            end if
          else if (branch .eq. 5) then
            winfd(l) = winfd(l) + bvti1d(i, j, l)
            bvti1d(i, j, l) = 0.0_8
          end if
        end do
      end if
    end do
  end do
end subroutine bcturbfarfield_b

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of initresadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: voladj wadj
!   of linear combination of output variables: voladj dwadj wadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          initres.f90                                     *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-18-2003                                      *
!      * Last modified: 06-28-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INITRESADJ_B(varstart, varend, wadj, wadjb, voladj, voladjb, &
&  dwadj, dwadjb, nn, level, sps)
  USE blockpointers
  USE flowvarrefstate
  USE inputiteration
  USE inputphysics
  USE inputtimespectral
  USE inputunsteady
  USE iteration
  IMPLICIT NONE
!redundent calculation. The entire stencil is zeroed above. May need to be corrected for more complex initalizaitons....
!!$           ! Set the residual in the halo cells to zero. This is just
!!$           ! to avoid possible problems. Their values do not matter.
!!$
!!$           do l=varStart,varEnd
!!$             do k=-2,2!0,kb
!!$               do j=-2,2!0,jb
!!$                  
!!$                 dw(0,j,k,l)  = zero
!!$                 dw(1,j,k,l)  = zero
!!$                 dw(ie,j,k,l) = zero
!!$                 dw(ib,j,k,l) = zero
!!$               enddo
!!$             enddo
!!$
!!$             do k=0,kb
!!$               do i=2,il
!!$                 dw(i,0,k,l)  = zero
!!$                 dw(i,1,k,l)  = zero
!!$                 dw(i,je,k,l) = zero
!!$                 dw(i,jb,k,l) = zero
!!$               enddo
!!$             enddo
!!$
!!$             do j=2,jl
!!$               do i=2,il
!!$                 dw(i,j,0,l)  = zero
!!$                 dw(i,j,1,l)  = zero
!!$                 dw(i,j,ke,l) = zero
!!$                 dw(i,j,kb,l) = zero
!!$               enddo
!!$             enddo
!!$           enddo
  REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
&  ntimeintervalsspectral)
  INTEGER(KIND=INTTYPE), INTENT(IN) :: level
  INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
  INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
  INTEGER(KIND=INTTYPE), INTENT(IN) :: varend
  INTEGER(KIND=INTTYPE), INTENT(IN) :: varstart
  REAL(KIND=REALTYPE) :: voladj(ntimeintervalsspectral), voladjb(&
&  ntimeintervalsspectral)
  REAL(KIND=REALTYPE) :: wadj(-2:2, -2:2, -2:2, nw, &
&  ntimeintervalsspectral), wadjb(-2:2, -2:2, -2:2, nw, &
&  ntimeintervalsspectral)
  INTEGER :: branch
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, l, ll, m, mm
  REAL(KIND=REALTYPE) :: tempb, tempb0
  REAL(KIND=REALTYPE) :: oneoverdt, tmp, tmpb
  REAL(KIND=REALTYPE) :: volspadj, volspadjb
  REAL(KIND=REALTYPE) :: wspadj(-2:2, -2:2, -2:2, nw), wspadjb(-2:2, -2:&
&  2, -2:2, nw)
  EXTERNAL TERMINATE
!
!      ******************************************************************
!      *                                                                *
!      * initres initializes the given range of the residual. Either to *
!      * zero, steady computation, or to an unsteady term for the time  *
!      * spectral and unsteady modes. For the coarser grid levels the   *
!      * residual forcing term is taken into account.                   *
!      *                                                                *
!      * This is a local routine, so assume that pointers are already   *
!      * set.                                                           *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
!
!      Local variables.
!
!unsteady and timespectral variables
!!$
!!$       real(kind=realType), dimension(:,:,:,:), pointer :: ww, wsp, wsp1
!!$       real(kind=realType), dimension(:,:,:),   pointer :: volsp
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Return immediately of no variables are in the range.
  IF (.NOT.varend .LT. varstart) THEN
!moveed outside
!!$
!!$       ! Loop over the number of spectral solutions and domains.
!!$
!!$       spectralLoop: do sps=1,nTimeIntervalsSpectral
!!$
!!$         domains: do nn=1,nDom
!!$
!!$           ! Set the pointers to this block.
!!$
!!$           call setPointers(nn, currentLevel, sps)
! Determine the equation mode and act accordingly.
    SELECT CASE  (equationmode) 
    CASE (unsteady, steady, timespectral) 
!===========================================================
!!$
!!$                call terminate("initRes", &
!!$                                  "Time Spectral ADjoint not yet implemented")
! Time spectral computation. The time derivative of the
! current solution is given by a linear combination of
! all other solutions, i.e. a matrix vector product.
! First store the section to which this block belongs
! in jj.
      jj = sectionid
! Determine the currently active multigrid level.
      IF (currentlevel .EQ. groundlevel) THEN
! Loop over the number of terms which contribute
! to the time derivative.
timeloopfine:DO mm=1,ntimeintervalsspectral
          CALL PUSHREAL8ARRAY(wspadj, 5**3*nw)
! Store the pointer for the variable to be used to
! compute the unsteady source term and the volume.
! Also store in ii the offset needed for vector
! quantities.
          wspadj = wadj(:, :, :, :, mm)
          CALL PUSHREAL8(volspadj)
!(:,:,:,mm)
          volspadj = voladj(mm)
          CALL PUSHINTEGER4(ii)
          ii = 3*(mm-1)
! Loop over the number of variables to be set.
varloopfine:DO l=varstart,varend
! Test for a momentum variable.
            IF (l .EQ. ivx .OR. l .EQ. ivy .OR. l .EQ. ivz) THEN
! Momentum variable. A special treatment is
! needed because it is a vector and the velocities
! are stored instead of the momentum. Set the
! coefficient ll, which defines the row of the
! matrix used later on.
              IF (l .EQ. ivx) THEN
                CALL PUSHINTEGER4(ll)
                ll = 3*sps - 2
                CALL PUSHINTEGER4(1)
              ELSE
                CALL PUSHINTEGER4(0)
              END IF
              IF (l .EQ. ivy) THEN
                CALL PUSHINTEGER4(ll)
                ll = 3*sps - 1
                CALL PUSHINTEGER4(1)
              ELSE
                CALL PUSHINTEGER4(0)
              END IF
              IF (l .EQ. ivz) THEN
                CALL PUSHINTEGER4(ll)
                ll = 3*sps
                CALL PUSHINTEGER4(1)
              ELSE
                CALL PUSHINTEGER4(0)
              END IF
              CALL PUSHREAL8(tmp)
! Loop over the owned cell centers to add the
! contribution from wsp.
!do k=2,kl
!  do j=2,jl
!    do i=2,il
! Store the matrix vector product with the
! velocity in tmp.
!tmp = dvector(jj,ll,ii+1)*wsp(i,j,k,ivx) &
!          + dvector(jj,ll,ii+2)*wsp(i,j,k,ivy) &
!          + dvector(jj,ll,ii+3)*wsp(i,j,k,ivz)
              tmp = dvector(jj, ll, ii+1)*wspadj(0, 0, 0, ivx) + dvector&
&                (jj, ll, ii+2)*wspadj(0, 0, 0, ivy) + dvector(jj, ll, &
&                ii+3)*wspadj(0, 0, 0, ivz)
! Update the residual. Note the
! multiplication with the density to obtain
! the correct time derivative for the
! momentum variable.
!dw(i,j,k,l) = dw(i,j,k,l) &
!     + tmp*volsp(i,j,k)*wsp(i,j,k,irho)
!dwAdj(l,mm) = dwAdj(l,mm) &
!     enddo
!   enddo
! enddo
              CALL PUSHINTEGER4(1)
            ELSE
              CALL PUSHINTEGER4(2)
            END IF
          END DO varloopfine
        END DO timeloopfine
        DO mm=ntimeintervalsspectral,1,-1
          wspadjb(-2:2, -2:2, -2:2, 1:nw) = 0.0
          volspadjb = 0.0
          DO l=varend,varstart,-1
            CALL POPINTEGER4(branch)
            IF (branch .LT. 2) THEN
              tempb = wspadj(0, 0, 0, irho)*dwadjb(l, sps)
              tmpb = volspadj*tempb
              volspadjb = volspadjb + tmp*tempb
              wspadjb(0, 0, 0, irho) = wspadjb(0, 0, 0, irho) + tmp*&
&                volspadj*dwadjb(l, sps)
              CALL POPREAL8(tmp)
              wspadjb(0, 0, 0, ivx) = wspadjb(0, 0, 0, ivx) + dvector(jj&
&                , ll, ii+1)*tmpb
              wspadjb(0, 0, 0, ivy) = wspadjb(0, 0, 0, ivy) + dvector(jj&
&                , ll, ii+2)*tmpb
              wspadjb(0, 0, 0, ivz) = wspadjb(0, 0, 0, ivz) + dvector(jj&
&                , ll, ii+3)*tmpb
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
              CALL POPINTEGER4(branch)
              IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
            ELSE
              tempb0 = dscalar(jj, sps, mm)*dwadjb(l, sps)
              volspadjb = volspadjb + wspadj(0, 0, 0, l)*tempb0
              wspadjb(0, 0, 0, l) = wspadjb(0, 0, 0, l) + volspadj*&
&                tempb0
            END IF
          END DO
          CALL POPINTEGER4(ii)
          CALL POPREAL8(volspadj)
          voladjb(mm) = voladjb(mm) + volspadjb
          CALL POPREAL8ARRAY(wspadj, 5**3*nw)
          wadjb(:, :, :, :, mm) = wadjb(:, :, :, :, mm) + wspadjb
        END DO
      END IF
    END SELECT
  END IF
END SUBROUTINE INITRESADJ_B

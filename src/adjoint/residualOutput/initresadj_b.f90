   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of initresadj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: voladj wadj
   !   of linear combination of output variables: voladj dwadj wadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          initres.f90                                     *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-18-2003                                      *
   !      * Last modified: 06-28-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INITRESADJ_B(varstart, varend, wadj, wadjb, voladj, voladjb, &
   &  dwadj, dwadjb, nn, level, sps)
   USE blockpointers
   USE flowvarrefstate
   USE inputiteration
   USE inputphysics
   USE inputtimespectral
   USE inputunsteady
   USE iteration
   IMPLICIT NONE
   !end select
   !redundent calculation. The entire stencil is zeroed above. May need to be corrected for more complex initalizaitons....
   !!$           ! Set the residual in the halo cells to zero. This is just
   !!$           ! to avoid possible problems. Their values do not matter.
   !!$
   !!$           do l=varStart,varEnd
   !!$             do k=-2,2!0,kb
   !!$               do j=-2,2!0,jb
   !!$                  
   !!$                 dw(0,j,k,l)  = zero
   !!$                 dw(1,j,k,l)  = zero
   !!$                 dw(ie,j,k,l) = zero
   !!$                 dw(ib,j,k,l) = zero
   !!$               enddo
   !!$             enddo
   !!$
   !!$             do k=0,kb
   !!$               do i=2,il
   !!$                 dw(i,0,k,l)  = zero
   !!$                 dw(i,1,k,l)  = zero
   !!$                 dw(i,je,k,l) = zero
   !!$                 dw(i,jb,k,l) = zero
   !!$               enddo
   !!$             enddo
   !!$
   !!$             do j=2,jl
   !!$               do i=2,il
   !!$                 dw(i,j,0,l)  = zero
   !!$                 dw(i,j,1,l)  = zero
   !!$                 dw(i,j,ke,l) = zero
   !!$                 dw(i,j,kb,l) = zero
   !!$               enddo
   !!$             enddo
   !!$           enddo
   REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
   &  ntimeintervalsspectral)
   INTEGER(KIND=INTTYPE), INTENT(IN) :: level
   INTEGER(KIND=INTTYPE), INTENT(IN) :: nn
   INTEGER(KIND=INTTYPE), INTENT(IN) :: sps
   INTEGER(KIND=INTTYPE), INTENT(IN) :: varend
   INTEGER(KIND=INTTYPE), INTENT(IN) :: varstart
   REAL(KIND=REALTYPE) :: voladj(ntimeintervalsspectral), voladjb(&
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: wadj(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), wadjb(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral)
   INTEGER :: branch
   INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, l, ll, m, mm
   REAL(KIND=REALTYPE) :: tempb, tempb0
   REAL(KIND=REALTYPE) :: oneoverdt, tmp, tmpb
   REAL(KIND=REALTYPE) :: volspadj, volspadjb
   REAL(KIND=REALTYPE) :: wspadj(-2:2, -2:2, -2:2, nw), wspadjb(-2:2, -2:&
   &  2, -2:2, nw)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * initres initializes the given range of the residual. Either to *
   !      * zero, steady computation, or to an unsteady term for the time  *
   !      * spectral and unsteady modes. For the coarser grid levels the   *
   !      * residual forcing term is taken into account.                   *
   !      *                                                                *
   !      * This is a local routine, so assume that pointers are already   *
   !      * set.                                                           *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   !
   !      Local variables.
   !
   !unsteady and timespectral variables
   !!$
   !!$       real(kind=realType), dimension(:,:,:,:), pointer :: ww, wsp, wsp1
   !!$       real(kind=realType), dimension(:,:,:),   pointer :: volsp
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately of no variables are in the range.
   IF (.NOT.varend .LT. varstart) THEN
   !moveed outside
   !!$
   !!$       ! Loop over the number of spectral solutions and domains.
   !!$
   !!$       spectralLoop: do sps=1,nTimeIntervalsSpectral
   !!$
   !!$         domains: do nn=1,nDom
   !!$
   !!$           ! Set the pointers to this block.
   !!$
   !!$           call setPointers(nn, currentLevel, sps)
   ! Determine the equation mode and act accordingly.
   !print *,'equation Mode',equationMode,'ref',steady,timespectral,unsteady
   !switch to if statments. this particular case setup doesn't work
   !with tapenade. The steady case dissappears and Tapenade doesn't
   !know how to handle the empty case....
   !           select case (equationMode)
   !             case (steady)
   IF (.NOT.equationmode .EQ. steady) THEN
   !===========================================================
   IF (equationmode .EQ. unsteady) THEN
   !!$                   ! Store the inverse of the physical nonDimensional
   !!$                   ! time step a bit easier.
   !!$
   !!$                   oneOverDt = timeRef/deltaT
   !!$
   !!$                   ! Store the pointer for the variable to be used to compute
   !!$                   ! the unsteady source term. For a runge-kutta smoother this
   !!$                   ! is the solution of the zeroth runge-kutta stage. As for
   !!$                   ! rkStage == 0 this variable is not yet set w is used.
   !!$                   ! For other smoothers w is to be used as well.
   !!$
   !!$                   if(smoother == RungeKutta .and. rkStage > 0) then
   !!$                     ww => wn
   !!$                   else
   !!$                     ww => w
   !!$                   endif
   !!$
   !!$                   ! Determine the currently active multigrid level.
   !!$
   !!$                   unsteadyLevelTest: if(currentLevel == groundLevel) then
   !!$
   !!$                     ! Ground level of the multigrid cycle. Initialize the
   !!$                     ! owned cells to the unsteady source term. First the
   !!$                     ! term for the current time level. Note that in w the
   !!$                     ! velocities are stored and not the momentum variables.
   !!$                     ! Therefore the if-statement is present to correct this.
   !!$
   !!$                     do l=varStart,varEnd
   !!$
   !!$                       if(l == ivx .or. l == ivy .or. l == ivz) then
   !!$
   !!$                         ! Momentum variables.
   !!$
   !!$                         do k=2,kl
   !!$                           do j=2,jl
   !!$                             do i=2,il
   !!$                               dw(i,j,k,l) = coefTime(0)*vol(i,j,k) &
   !!$                                           * ww(i,j,k,l)*ww(i,j,k,irho)
   !!$                             enddo
   !!$                           enddo
   !!$                         enddo
   !!$
   !!$                       else
   !!$
   !!$                         ! Non-momentum variables, for which the variable
   !!$                         ! to be solved is stored; for the flow equations this
   !!$                         ! is the conservative variable, for the turbulent
   !!$                         ! equations the primitive variable.
   !!$
   !!$                         do k=2,kl
   !!$                           do j=2,jl
   !!$                             do i=2,il
   !!$                               dw(i,j,k,l) = coefTime(0)*vol(i,j,k) &
   !!$                                           * ww(i,j,k,l)
   !!$                             enddo
   !!$                           enddo
   !!$                         enddo
   !!$
   !!$                       endif
   !!$
   !!$                     enddo
   !!$
   !!$                     ! The terms from the older time levels. Here the
   !!$                     ! conservative variables are stored. In case of a
   !!$                     ! deforming mesh, also the old volumes must be taken.
   !!$
   !!$                     deformingTest: if( deforming_Grid ) then
   !!$
   !!$                       ! Mesh is deforming and thus the volumes can change.
   !!$                       ! Use the old volumes as well.
   !!$
   !!$                       do m=1,nOldLevels
   !!$                         do l=varStart,varEnd
   !!$                           do k=2,kl
   !!$                             do j=2,jl
   !!$                               do i=2,il
   !!$                                 dw(i,j,k,l) = dw(i,j,k,l)                 &
   !!$                                             + coefTime(m)*volOld(m,i,j,k) &
   !!$                                             * wOld(m,i,j,k,l)
   !!$                               enddo
   !!$                             enddo
   !!$                           enddo
   !!$                         enddo
   !!$                       enddo
   !!$
   !!$                     else deformingTest
   !!$
   !!$                       ! Rigid mesh. The volumes remain constant.
   !!$
   !!$                       do m=1,nOldLevels
   !!$                         do l=varStart,varEnd
   !!$                           do k=2,kl
   !!$                             do j=2,jl
   !!$                               do i=2,il
   !!$                                 dw(i,j,k,l) = dw(i,j,k,l)            &
   !!$                                             + coefTime(m)*vol(i,j,k) &
   !!$                                             * wOld(m,i,j,k,l)
   !!$                               enddo
   !!$                             enddo
   !!$                           enddo
   !!$                         enddo
   !!$                       enddo
   !!$
   !!$                     endif deformingTest
   !!$
   !!$                     ! Multiply the time derivative by the inverse of the
   !!$                     ! time step to obtain the true time derivative.
   !!$                     ! This is done after the summation has been done, because
   !!$                     ! otherwise you run into finite accuracy problems for
   !!$                     ! very small time steps.
   !!$
   !!$                     do l=varStart,varEnd
   !!$                       do k=2,kl
   !!$                         do j=2,jl
   !!$                           do i=2,il
   !!$                             dw(i,j,k,l) = oneOverDt*dw(i,j,k,l)
   !!$                          enddo
   !!$                         enddo
   !!$                       enddo
   !!$                     enddo
   !!$
   !!$                   else unsteadyLevelTest
   !!$
   !!$                     ! Coarse grid level. Initialize the owned cells to the
   !!$                     ! residual forcing term plus a correction for the
   !!$                     ! multigrid treatment of the time derivative term.
   !!$                     ! As the velocities are stored instead of the momentum,
   !!$                     ! these terms must be multiplied by the density.
   !!$
   !!$                     tmp = oneOverDt*coefTime(0)
   !!$
   !!$                     do l=varStart,varEnd
   !!$
   !!$                       if(l == ivx .or. l == ivy .or. l == ivz) then
   !!$
   !!$                         ! Momentum variables.
   !!$
   !!$                         do k=2,kl
   !!$                           do j=2,jl
   !!$                             do i=2,il
   !!$                               dw(i,j,k,l) = tmp*vol(i,j,k)               &
   !!$                                           * (ww(i,j,k,l)*ww(i,j,k,irho)  &
   !!$                                           -  w1(i,j,k,l)*w1(i,j,k,irho))
   !!$                               dw(i,j,k,l) = dw(i,j,k,l) + wr(i,j,k,l)
   !!$                             enddo
   !!$                           enddo
   !!$                         enddo
   !!$
   !!$                       else
   !!$
   !!$                         ! Non-momentum variables.
   !!$
   !!$                         do k=2,kl
   !!$                           do j=2,jl
   !!$                             do i=2,il
   !!$                               dw(i,j,k,l) = tmp*vol(i,j,k)             &
   !!$                                           * (ww(i,j,k,l) - w1(i,j,k,l))
   !!$                               dw(i,j,k,l) =  dw(i,j,k,l) + wr(i,j,k,l)
   !!$                             enddo
   !!$                           enddo
   !!$                         enddo
   !!$
   !!$                       endif
   !!$
   !!$                     enddo
   !!$
   !!$                   endif unsteadyLevelTest
   !case (unsteady)
   ! Unsteady computation.
   ! A further distinction must be made.
   SELECT CASE  (timeintegrationscheme) 
      END SELECT
   ELSE IF (equationmode .EQ. timespectral) THEN
   !===========================================================
   !case (timeSpectral)
   !!$!
   !!$!                call terminate("initRes", &
   !!$!                                  "Time Spectral ADjoint not yet implemented")
   ! Time spectral computation. The time derivative of the
   ! current solution is given by a linear combination of
   ! all other solutions, i.e. a matrix vector product.
   ! First store the section to which this block belongs
   ! in jj.
   jj = sectionid
   ! Determine the currently active multigrid level.
   IF (currentlevel .EQ. groundlevel) THEN
   ! Loop over the number of terms which contribute
   ! to the time derivative.
   timeloopfine:DO mm=1,ntimeintervalsspectral
   CALL PUSHREAL8ARRAY(wspadj, 5**3*nw)
   ! Store the pointer for the variable to be used to
   ! compute the unsteady source term and the volume.
   ! Also store in ii the offset needed for vector
   ! quantities.
   wspadj = wadj(:, :, :, :, mm)
   CALL PUSHREAL8(volspadj)
   !(:,:,:,mm)
   volspadj = voladj(mm)
   CALL PUSHINTEGER4(ii)
   ii = 3*(mm-1)
   ! Loop over the number of variables to be set.
   varloopfine:DO l=varstart,varend
   ! Test for a momentum variable.
   IF (l .EQ. ivx .OR. l .EQ. ivy .OR. l .EQ. ivz) THEN
   ! Momentum variable. A special treatment is
   ! needed because it is a vector and the velocities
   ! are stored instead of the momentum. Set the
   ! coefficient ll, which defines the row of the
   ! matrix used later on.
   IF (l .EQ. ivx) THEN
   CALL PUSHINTEGER4(ll)
   ll = 3*sps - 2
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (l .EQ. ivy) THEN
   CALL PUSHINTEGER4(ll)
   ll = 3*sps - 1
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   IF (l .EQ. ivz) THEN
   CALL PUSHINTEGER4(ll)
   ll = 3*sps
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(tmp)
   ! Loop over the owned cell centers to add the
   ! contribution from wsp.
   !do k=2,kl
   !  do j=2,jl
   !    do i=2,il
   ! Store the matrix vector product with the
   ! velocity in tmp.
   !tmp = dvector(jj,ll,ii+1)*wsp(i,j,k,ivx) &
   !          + dvector(jj,ll,ii+2)*wsp(i,j,k,ivy) &
   !          + dvector(jj,ll,ii+3)*wsp(i,j,k,ivz)
   tmp = dvector(jj, ll, ii+1)*wspadj(0, 0, 0, ivx) + &
   &                  dvector(jj, ll, ii+2)*wspadj(0, 0, 0, ivy) + dvector(&
   &                  jj, ll, ii+3)*wspadj(0, 0, 0, ivz)
   ! Update the residual. Note the
   ! multiplication with the density to obtain
   ! the correct time derivative for the
   ! momentum variable.
   !dw(i,j,k,l) = dw(i,j,k,l) &
   !     + tmp*volsp(i,j,k)*wsp(i,j,k,irho)
   !dwAdj(l,mm) = dwAdj(l,mm) &
   !     enddo
   !   enddo
   ! enddo
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   END DO varloopfine
   END DO timeloopfine
   DO mm=ntimeintervalsspectral,1,-1
   wspadjb(-2:2, -2:2, -2:2, 1:nw) = 0.0
   volspadjb = 0.0
   DO l=varend,varstart,-1
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   tempb = wspadj(0, 0, 0, irho)*dwadjb(l, sps)
   tmpb = volspadj*tempb
   volspadjb = volspadjb + tmp*tempb
   wspadjb(0, 0, 0, irho) = wspadjb(0, 0, 0, irho) + tmp*&
   &                  volspadj*dwadjb(l, sps)
   CALL POPREAL8(tmp)
   wspadjb(0, 0, 0, ivx) = wspadjb(0, 0, 0, ivx) + dvector(&
   &                  jj, ll, ii+1)*tmpb
   wspadjb(0, 0, 0, ivy) = wspadjb(0, 0, 0, ivy) + dvector(&
   &                  jj, ll, ii+2)*tmpb
   wspadjb(0, 0, 0, ivz) = wspadjb(0, 0, 0, ivz) + dvector(&
   &                  jj, ll, ii+3)*tmpb
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) CALL POPINTEGER4(ll)
   ELSE
   tempb0 = dscalar(jj, sps, mm)*dwadjb(l, sps)
   volspadjb = volspadjb + wspadj(0, 0, 0, l)*tempb0
   wspadjb(0, 0, 0, l) = wspadjb(0, 0, 0, l) + volspadj*&
   &                  tempb0
   END IF
   END DO
   CALL POPINTEGER4(ii)
   CALL POPREAL8(volspadj)
   voladjb(mm) = voladjb(mm) + volspadjb
   CALL POPREAL8ARRAY(wspadj, 5**3*nw)
   wadjb(:, :, :, :, mm) = wadjb(:, :, :, :, mm) + wspadjb
   END DO
   END IF
   END IF
   END IF
   END IF
   END SUBROUTINE INITRESADJ_B

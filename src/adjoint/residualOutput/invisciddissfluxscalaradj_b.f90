   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of invisciddissfluxscalaradj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: padj radkadj radjadj
   !                dwadj wadj radiadj sigma
   !   of linear combination of output variables: dwadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidDissFluxScalarAdj.f90                   *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader           *
   !      * Starting date: 06-10-2009                                      *
   !      * Last modified: 06-10-2009                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDDISSFLUXSCALARADJ_B(wadj, wadjb, padj, padjb, dwadj, &
   &  dwadjb, radiadj, radiadjb, radjadj, radjadjb, radkadj, radkadjb, &
   &  icell, jcell, kcell, nn, level, sps)
   USE blockpointers
   USE cgnsgrid
   USE constants
   USE flowvarrefstate
   USE inputadjoint
   USE inputdiscretization
   USE inputphysics
   USE inputtimespectral
   USE iteration
   IMPLICIT NONE
   !!$       do k=2,kl
   !!$         do j=2,jl
   !!$           rhoi           = one/w(0,j,k,irho)
   !!$           w(0,j,k,ivx)   = w(0,j,k,ivx)*rhoi
   !!$           w(0,j,k,ivy)   = w(0,j,k,ivy)*rhoi
   !!$           w(0,j,k,ivz)   = w(0,j,k,ivz)*rhoi
   !!$           w(0,j,k,irhoE) = w(0,j,k,irhoE) - p(0,j,k)
   !!$
   !!$           rhoi           = one/w(1,j,k,irho)
   !!$           w(1,j,k,ivx)   = w(1,j,k,ivx)*rhoi
   !!$           w(1,j,k,ivy)   = w(1,j,k,ivy)*rhoi
   !!$           w(1,j,k,ivz)   = w(1,j,k,ivz)*rhoi
   !!$           w(1,j,k,irhoE) = w(1,j,k,irhoE) - p(1,j,k)
   !!$
   !!$           rhoi            = one/w(ie,j,k,irho)
   !!$           w(ie,j,k,ivx)   = w(ie,j,k,ivx)*rhoi
   !!$           w(ie,j,k,ivy)   = w(ie,j,k,ivy)*rhoi
   !!$           w(ie,j,k,ivz)   = w(ie,j,k,ivz)*rhoi
   !!$           w(ie,j,k,irhoE) = w(ie,j,k,irhoE) - p(ie,j,k)
   !!$
   !!$           rhoi            = one/w(ib,j,k,irho)
   !!$           w(ib,j,k,ivx)   = w(ib,j,k,ivx)*rhoi
   !!$           w(ib,j,k,ivy)   = w(ib,j,k,ivy)*rhoi
   !!$           w(ib,j,k,ivz)   = w(ib,j,k,ivz)*rhoi
   !!$           w(ib,j,k,irhoE) = w(ib,j,k,irhoE) - p(ib,j,k)
   !!$         enddo
   !!$       enddo
   !!$
   !!$       do k=2,kl
   !!$         do i=2,il
   !!$           rhoi           = one/w(i,0,k,irho)
   !!$           w(i,0,k,ivx)   = w(i,0,k,ivx)*rhoi
   !!$           w(i,0,k,ivy)   = w(i,0,k,ivy)*rhoi
   !!$           w(i,0,k,ivz)   = w(i,0,k,ivz)*rhoi
   !!$           w(i,0,k,irhoE) = w(i,0,k,irhoE) - p(i,0,k)
   !!$
   !!$           rhoi           = one/w(i,1,k,irho)
   !!$           w(i,1,k,ivx)   = w(i,1,k,ivx)*rhoi
   !!$           w(i,1,k,ivy)   = w(i,1,k,ivy)*rhoi
   !!$           w(i,1,k,ivz)   = w(i,1,k,ivz)*rhoi
   !!$           w(i,1,k,irhoE) = w(i,1,k,irhoE) - p(i,1,k)
   !!$
   !!$           rhoi            = one/w(i,je,k,irho)
   !!$           w(i,je,k,ivx)   = w(i,je,k,ivx)*rhoi
   !!$           w(i,je,k,ivy)   = w(i,je,k,ivy)*rhoi
   !!$           w(i,je,k,ivz)   = w(i,je,k,ivz)*rhoi
   !!$           w(i,je,k,irhoE) = w(i,je,k,irhoE) - p(i,je,k)
   !!$
   !!$           rhoi            = one/w(i,jb,k,irho)
   !!$           w(i,jb,k,ivx)   = w(i,jb,k,ivx)*rhoi
   !!$           w(i,jb,k,ivy)   = w(i,jb,k,ivy)*rhoi
   !!$           w(i,jb,k,ivz)   = w(i,jb,k,ivz)*rhoi
   !!$           w(i,jb,k,irhoE) = w(i,jb,k,irhoE) - p(i,jb,k)
   !!$         enddo
   !!$       enddo
   REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
   &  ntimeintervalsspectral)
   INTEGER(KIND=INTTYPE) :: icell, jcell, kcell, level, nn, sps
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2, ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: radiadj(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radiadjb(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radjadj(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radjadjb(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radkadj(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral), radkadjb(-1:1, -1:1, -1:1, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE) :: wadj(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), wadjb(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), PARAMETER :: dssmax=0.25_realType
   INTEGER :: branch
   REAL(KIND=REALTYPE) :: ddw, ddwb, dss1, dss1b, dss2, dss2b, fs, fsb, &
   &  temp1b0, temp1b1, temp1b2, temp1b3, temp1b4, temp3b0, temp3b1, &
   &  temp3b2, temp3b3, temp3b4, temp5b0, temp5b1, temp5b2, temp5b3, &
   &  temp5b4
   REAL(KIND=REALTYPE) :: fact
   INTEGER(KIND=INTTYPE) :: i, ind, j, k
   INTEGER(KIND=INTTYPE) :: ii, jj, kk
   REAL(KIND=REALTYPE) :: dis2, dis2b, dis4, dis4b, ppor, rrad, rradb
   REAL(KIND=REALTYPE) :: fis2, fis4, sfil
   REAL(KIND=REALTYPE) :: rhoi, sslim, temp, temp0, temp0b0, temp1, &
   &  temp1b5, temp2, temp2b0, temp3, temp3b5, temp4, temp4b0, tempb
   REAL(KIND=REALTYPE) :: tmp, tmp0, tmp0b, tmp1, tmp1b, tmpb
   REAL(KIND=REALTYPE) :: ss(-2:2, -2:2, -2:2), ssb(-2:2, -2:2, -2:2), &
   &  temp0b, temp1b, temp2b, temp3b, temp4b, temp5b, x1, x1b, x2, x2b, x3&
   &  , x3b, x4, x4b, x5, x5b, x6, x6b
   REAL(KIND=REALTYPE) :: min1, min1b, min2, min2b, min3, min3b, min4, &
   &  min4b, min5, min5b, min6, min6b, y1, y1b, y2, y2b, y3, y3b, y4, y4b, &
   &  y5, y5b, y6, y6b
   INTRINSIC MAX, ABS, MIN
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidDissFluxScalar computes the scalar artificial          *
   !      * dissipation, see AIAA paper 81-1259, for a given block.        *
   !      * Therefore it is assumed that the pointers in  blockPointers    *
   !      * already point to the correct block.                            *
   !      *                                                                *
   !      ******************************************************************
   !
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments
   !
   !
   !      Local parameter.
   !
   !
   !      Local variables.
   !
   !real(kind=realType), dimension(0:ib,0:jb,0:kb) :: ss
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check if rFil == 0. If so, the dissipative flux needs not to
   ! be computed.
   IF (rfil .EQ. zero) THEN
   padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   radkadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   radjadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
   radiadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   ELSE
   !!$           ! Viscous case. Pressure switch is based on the entropy.
   !!$           ! Also set the value of sslim. To be fully consistent this
   !!$           ! must have the dimension of entropy and it is therefore
   !!$           ! set to a fraction of the free stream value.
   !!$
   !!$           sslim = 0.001_realType*pInfCorr/(rhoInf**gammaInf)
   !!$
   !!$           ! Store the entropy in ss. Only fill the entries used in
   !!$           ! the discretization, i.e. ignore the corner halo's.
   !!$
   !!$           do k=0,kb
   !!$             do j=2,jl
   !!$               do i=2,il
   !!$                 ss(i,j,k) = p(i,j,k)/(w(i,j,k,irho)**gamma(i,j,k))
   !!$               enddo
   !!$             enddo
   !!$           enddo
   !!$
   !!$           do k=2,kl
   !!$             do j=2,jl
   !!$               ss(0, j,k) = p(0, j,k)/(w(0, j,k,irho)**gamma(0, j,k))
   !!$               ss(1, j,k) = p(1, j,k)/(w(1, j,k,irho)**gamma(1, j,k))
   !!$               ss(ie,j,k) = p(ie,j,k)/(w(ie,j,k,irho)**gamma(ie,j,k))
   !!$               ss(ib,j,k) = p(ib,j,k)/(w(ib,j,k,irho)**gamma(ib,j,k))
   !!$             enddo
   !!$           enddo
   !!$
   !!$           do k=2,kl
   !!$             do i=2,il
   !!$               ss(i,0, k) = p(i,0, k)/(w(i,0, k,irho)**gamma(i,0, k))
   !!$               ss(i,1, k) = p(i,1, k)/(w(i,1, k,irho)**gamma(i,1, k))
   !!$               ss(i,je,k) = p(i,je,k)/(w(i,je,k,irho)**gamma(i,je,k))
   !!$               ss(i,jb,k) = p(i,jb,k)/(w(i,jb,k,irho)**gamma(i,jb,k))
   !!$             enddo
   !!$           enddo
   ! Determine the variables used to compute the switch.
   ! For the inviscid case this is the pressure; for the viscous
   ! case it is the entropy.
   SELECT CASE  (equations) 
   CASE (eulerequations) 
   ! Inviscid case. Pressure switch is based on the pressure.
   ! Also set the value of sslim. To be fully consistent this
   ! must have the dimension of pressure and it is therefore
   ! set to a fraction of the free stream value.
   sslim = 0.001_realType*pinfcorr
   ! Copy the pressure in ss. Only fill the entries used in
   ! the discretization, i.e. ignore the corner halo's.
   !do we need to ignore the corners in the ADjoint?... leave in for now...
   !0,kb
   DO k=-2,2
   !2,jl
   DO j=-2,2
   !2,il
   DO i=-2,2
   ss(i, j, k) = padj(i, j, k, sps)
   END DO
   END DO
   END DO
   CALL PUSHINTEGER4(1)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ! Set a couple of constants for the scheme.
   fis2 = rfil*vis2
   fis4 = rfil*vis4
   ! Replace the total energy by rho times the total enthalpy.
   ! In this way the numerical solution is total enthalpy preserving
   ! for the steady Euler equations. Also replace the velocities by
   ! the momentum. Only done for the entries used in the
   ! discretization, i.e. ignore the corner halo's.
   !0,kb
   DO k=-2,2
   !2,jl
   DO j=-2,2
   !2,il
   DO i=-2,2
   tmp = wadj(i, j, k, irho, sps)*wadj(i, j, k, ivx, sps)
   CALL PUSHREAL8(wadj(i, j, k, ivx, sps))
   wadj(i, j, k, ivx, sps) = tmp
   tmp0 = wadj(i, j, k, irho, sps)*wadj(i, j, k, ivy, sps)
   CALL PUSHREAL8(wadj(i, j, k, ivy, sps))
   wadj(i, j, k, ivy, sps) = tmp0
   tmp1 = wadj(i, j, k, irho, sps)*wadj(i, j, k, ivz, sps)
   CALL PUSHREAL8(wadj(i, j, k, ivz, sps))
   wadj(i, j, k, ivz, sps) = tmp1
   CALL PUSHREAL8(wadj(i, j, k, irhoe, sps))
   wadj(i, j, k, irhoe, sps) = wadj(i, j, k, irhoe, sps) + padj(i&
   &            , j, k, sps)
   END DO
   END DO
   END DO
   !!$       do k=2,kl
   !!$         do j=2,jl
   !!$           w(0,j,k,ivx)   = w(0,j,k,irho)*w(0,j,k,ivx)
   !!$           w(0,j,k,ivy)   = w(0,j,k,irho)*w(0,j,k,ivy)
   !!$           w(0,j,k,ivz)   = w(0,j,k,irho)*w(0,j,k,ivz)
   !!$           w(0,j,k,irhoE) = w(0,j,k,irhoE) + p(0,j,k)
   !!$
   !!$           w(1,j,k,ivx)   = w(1,j,k,irho)*w(1,j,k,ivx)
   !!$           w(1,j,k,ivy)   = w(1,j,k,irho)*w(1,j,k,ivy)
   !!$           w(1,j,k,ivz)   = w(1,j,k,irho)*w(1,j,k,ivz)
   !!$           w(1,j,k,irhoE) = w(1,j,k,irhoE) + p(1,j,k)
   !!$
   !!$           w(ie,j,k,ivx)   = w(ie,j,k,irho)*w(ie,j,k,ivx)
   !!$           w(ie,j,k,ivy)   = w(ie,j,k,irho)*w(ie,j,k,ivy)
   !!$           w(ie,j,k,ivz)   = w(ie,j,k,irho)*w(ie,j,k,ivz)
   !!$           w(ie,j,k,irhoE) = w(ie,j,k,irhoE) + p(ie,j,k)
   !!$
   !!$           w(ib,j,k,ivx)   = w(ib,j,k,irho)*w(ib,j,k,ivx)
   !!$           w(ib,j,k,ivy)   = w(ib,j,k,irho)*w(ib,j,k,ivy)
   !!$           w(ib,j,k,ivz)   = w(ib,j,k,irho)*w(ib,j,k,ivz)
   !!$           w(ib,j,k,irhoE) = w(ib,j,k,irhoE) + p(ib,j,k)
   !!$         enddo
   !!$       enddo
   !!$       do k=2,kl
   !!$         do i=2,il
   !!$           w(i,0,k,ivx)   = w(i,0,k,irho)*w(i,0,k,ivx)
   !!$           w(i,0,k,ivy)   = w(i,0,k,irho)*w(i,0,k,ivy)
   !!$           w(i,0,k,ivz)   = w(i,0,k,irho)*w(i,0,k,ivz)
   !!$           w(i,0,k,irhoE) = w(i,0,k,irhoE) + p(i,0,k)
   !!$
   !!$           w(i,1,k,ivx)   = w(i,1,k,irho)*w(i,1,k,ivx)
   !!$           w(i,1,k,ivy)   = w(i,1,k,irho)*w(i,1,k,ivy)
   !!$           w(i,1,k,ivz)   = w(i,1,k,irho)*w(i,1,k,ivz)
   !!$           w(i,1,k,irhoE) = w(i,1,k,irhoE) + p(i,1,k)
   !!$
   !!$           w(i,je,k,ivx)   = w(i,je,k,irho)*w(i,je,k,ivx)
   !!$           w(i,je,k,ivy)   = w(i,je,k,irho)*w(i,je,k,ivy)
   !!$           w(i,je,k,ivz)   = w(i,je,k,irho)*w(i,je,k,ivz)
   !!$           w(i,je,k,irhoE) = w(i,je,k,irhoE) + p(i,je,k)
   !!$
   !!$           w(i,jb,k,ivx)   = w(i,jb,k,irho)*w(i,jb,k,ivx)
   !!$           w(i,jb,k,ivy)   = w(i,jb,k,irho)*w(i,jb,k,ivy)
   !!$           w(i,jb,k,ivz)   = w(i,jb,k,irho)*w(i,jb,k,ivz)
   !!$           w(i,jb,k,irhoE) = w(i,jb,k,irhoE) + p(i,jb,k)
   !!$         enddo
   !!$       enddo
   !Following method in the upwind scheme, take the residual onto dwAdj instead 
   !of a separate fw. If it needs to be switched back, fw is dissiptive, dw is
   !inviscid...
   !!$       ! Initialize the dissipative residual to a certain times,
   !!$       ! possibly zero, the previously stored value. Owned cells
   !!$       ! only, because the halo values do not matter.
   !!$
   !!$!       do k=2,kl
   !!$!         do j=2,jl
   !!$!           do i=2,il
   !!$             fw(irho)  = sfil*fw(irho)
   !!$             fw(imx)   = sfil*fw(imx)
   !!$             fw(imy)   = sfil*fw(imy)
   !!$             fw(imz)   = sfil*fw(imz)
   !!$             fw(irhoE) = sfil*fw(irhoE)
   !!$ !          enddo
   !!$ !        enddo
   !!$ !      enddo
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the i-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   ! 
   !set some indices for use later
   i = icell - 1
   j = jcell
   k = kcell
   fact = one
   !do k=2,kl
   !  do j=2,jl
   ! Compute the pressure sensor in the first cell, which
   ! is a halo cell.
   !!dss1 = abs((ss(2,j,k) - two*ss(1,j,k) + ss(0,j,k)) &
   !!     /     (ss(2,j,k) + two*ss(1,j,k) + ss(0,j,k) + sslim))
   ! Loop in i-direction.
   DO ii=-1,0
   x1 = (ss(ii+1, 0, 0)-two*ss(ii, 0, 0)+ss(ii-1, 0, 0))/(ss(ii+1, 0&
   &        , 0)+two*ss(ii, 0, 0)+ss(ii-1, 0, 0)+sslim)
   IF (x1 .GE. 0.) THEN
   dss1 = x1
   CALL PUSHINTEGER4(1)
   ELSE
   dss1 = -x1
   CALL PUSHINTEGER4(0)
   END IF
   x2 = (ss(ii+2, 0, 0)-two*ss(ii+1, 0, 0)+ss(ii, 0, 0))/(ss(ii+2, 0&
   &        , 0)+two*ss(ii+1, 0, 0)+ss(ii, 0, 0)+sslim)
   IF (x2 .GE. 0.) THEN
   dss2 = x2
   CALL PUSHINTEGER4(1)
   ELSE
   dss2 = -x2
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(ppor)
   !print *,'dss2',dss2
   ! Compute the dissipation coefficients for this face.
   ppor = zero
   IF (pori(i, j, k) .EQ. normalflux) THEN
   ppor = half
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(rrad)
   !rrad = ppor*(radI(i,j,k) + radI(i+1,j,k))
   rrad = ppor*(radiadj(ii, 0, 0, sps)+radiadj(ii+1, 0, 0, sps))
   !print *,'radI',radIAdj(ii,0,0),radI(icell+ii,jcell,kcell),icell,jcell,kcell,radIAdj(ii+1,0,0),radI(icell+ii+1,jcell,kcell)
   !lumped Dissipation for preconditioner
   IF (lumpeddiss) THEN
   IF (dss1 .LT. dss2) THEN
   y1 = dss2
   CALL PUSHINTEGER4(1)
   ELSE
   y1 = dss1
   CALL PUSHINTEGER4(0)
   END IF
   IF (dssmax .GT. y1) THEN
   CALL PUSHREAL8(min1)
   min1 = y1
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8(min1)
   min1 = dssmax
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*rrad*min1 + sigma*fis4*rrad
   CALL PUSHREAL8(dis4)
   dis4 = 0.0
   CALL PUSHINTEGER4(0)
   ELSE
   IF (dss1 .LT. dss2) THEN
   y2 = dss2
   CALL PUSHINTEGER4(1)
   ELSE
   y2 = dss1
   CALL PUSHINTEGER4(0)
   END IF
   IF (dssmax .GT. y2) THEN
   CALL PUSHREAL8(min2)
   min2 = y2
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8(min2)
   min2 = dssmax
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*rrad*min2
   !dis4 = dim(fis4*rrad, dis2)
   IF (fis4*rrad - dis2 .GT. 0.0) THEN
   CALL PUSHREAL8(dis4)
   dis4 = fis4*rrad - dis2
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHREAL8(dis4)
   dis4 = 0.0
   CALL PUSHINTEGER4(1)
   END IF
   END IF
   CALL PUSHREAL8(ddw)
   !print *,'dis2,4',dis2,dis4
   ! Compute and scatter the dissipative flux.
   ! Density. Store it in the mass flow of the
   ! appropriate sliding mesh interface.
   ddw = wadj(ii+1, 0, 0, irho, sps) - wadj(ii, 0, 0, irho, sps)
   CALL PUSHREAL8(ddw)
   !fw(i+1,j,k,irho) = fw(i+1,j,k,irho) + fs
   !fw(i,j,k,irho)   = fw(i,j,k,irho)   - fs
   ! X-momentum.
   ddw = wadj(ii+1, 0, 0, ivx, sps) - wadj(ii, 0, 0, ivx, sps)
   CALL PUSHREAL8(ddw)
   !fw(i+1,j,k,imx) = fw(i+1,j,k,imx) + fs
   !fw(i,j,k,imx)   = fw(i,j,k,imx)   - fs
   ! Y-momentum.
   ddw = wadj(ii+1, 0, 0, ivy, sps) - wadj(ii, 0, 0, ivy, sps)
   CALL PUSHREAL8(ddw)
   !fw(i+1,j,k,imy) = fw(i+1,j,k,imy) + fs
   !fw(i,j,k,imy)   = fw(i,j,k,imy)   - fs
   ! Z-momentum.
   ddw = wadj(ii+1, 0, 0, ivz, sps) - wadj(ii, 0, 0, ivz, sps)
   CALL PUSHREAL8(ddw)
   !fw(i+1,j,k,imz) = fw(i+1,j,k,imz) + fs
   !fw(i,j,k,imz)   = fw(i,j,k,imz)   - fs
   ! Energy.
   ddw = wadj(ii+1, 0, 0, irhoe, sps) - wadj(ii, 0, 0, irhoe, sps)
   !fw(i+1,j,k,irhoE) = fw(i+1,j,k,irhoE) + fs
   !fw(i,j,k,irhoE)   = fw(i,j,k,irhoE)   - fs
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   CALL PUSHREAL8(fact)
   fact = -one
   END DO
   !!! Set dss1 to dss2 for the next face.
   !!
   !!dss1 = dss2
   !         enddo
   !       enddo
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the j-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !
   ! do k=2,kl
   !   do i=2,il
   i = icell
   j = jcell - 1
   k = kcell
   fact = one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   x3 = (ss(0, jj+1, 0)-two*ss(0, jj, 0)+ss(0, jj-1, 0))/(ss(0, jj+1&
   &        , 0)+two*ss(0, jj, 0)+ss(0, jj-1, 0)+sslim)
   IF (x3 .GE. 0.) THEN
   dss1 = x3
   CALL PUSHINTEGER4(1)
   ELSE
   dss1 = -x3
   CALL PUSHINTEGER4(0)
   END IF
   x4 = (ss(0, jj+2, 0)-two*ss(0, jj+1, 0)+ss(0, jj, 0))/(ss(0, jj+2&
   &        , 0)+two*ss(0, jj+1, 0)+ss(0, jj, 0)+sslim)
   IF (x4 .GE. 0.) THEN
   dss2 = x4
   CALL PUSHINTEGER4(1)
   ELSE
   dss2 = -x4
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(ppor)
   ! Compute the dissipation coefficients for this face.
   ppor = zero
   IF (porj(i, j, k) .EQ. normalflux) THEN
   ppor = half
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(rrad)
   !rrad = ppor*(radJ(i,j,k) + radJ(i,j+1,k))
   rrad = ppor*(radjadj(0, jj, 0, sps)+radjadj(0, jj+1, 0, sps))
   !lumped Dissipation for preconditioner
   IF (lumpeddiss) THEN
   IF (dss1 .LT. dss2) THEN
   y3 = dss2
   CALL PUSHINTEGER4(1)
   ELSE
   y3 = dss1
   CALL PUSHINTEGER4(0)
   END IF
   IF (dssmax .GT. y3) THEN
   CALL PUSHREAL8(min3)
   min3 = y3
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8(min3)
   min3 = dssmax
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*rrad*min3 + sigma*fis4*rrad
   CALL PUSHREAL8(dis4)
   dis4 = 0.0
   CALL PUSHINTEGER4(0)
   ELSE
   IF (dss1 .LT. dss2) THEN
   y4 = dss2
   CALL PUSHINTEGER4(1)
   ELSE
   y4 = dss1
   CALL PUSHINTEGER4(0)
   END IF
   IF (dssmax .GT. y4) THEN
   CALL PUSHREAL8(min4)
   min4 = y4
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8(min4)
   min4 = dssmax
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*rrad*min4
   !dis4 = dim(fis4*rrad, dis2)
   IF (fis4*rrad - dis2 .GT. 0.0) THEN
   CALL PUSHREAL8(dis4)
   dis4 = fis4*rrad - dis2
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHREAL8(dis4)
   dis4 = 0.0
   CALL PUSHINTEGER4(1)
   END IF
   END IF
   CALL PUSHREAL8(ddw)
   ! Compute and scatter the dissipative flux.
   ! Density. Store it in the mass flow of the
   ! appropriate sliding mesh interface.
   ddw = wadj(0, jj+1, 0, irho, sps) - wadj(0, jj, 0, irho, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j+1,k,irho) = fw(i,j+1,k,irho) + fs
   !fw(i,j,k,irho)   = fw(i,j,k,irho)   - fs
   ! X-momentum.
   ddw = wadj(0, jj+1, 0, ivx, sps) - wadj(0, jj, 0, ivx, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j+1,k,imx) = fw(i,j+1,k,imx) + fs
   !fw(i,j,k,imx)   = fw(i,j,k,imx)   - fs
   ! Y-momentum.
   ddw = wadj(0, jj+1, 0, ivy, sps) - wadj(0, jj, 0, ivy, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j+1,k,imy) = fw(i,j+1,k,imy) + fs
   !fw(i,j,k,imy)   = fw(i,j,k,imy)   - fs
   ! Z-momentum.
   ddw = wadj(0, jj+1, 0, ivz, sps) - wadj(0, jj, 0, ivz, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j+1,k,imz) = fw(i,j+1,k,imz) + fs
   !fw(i,j,k,imz)   = fw(i,j,k,imz)   - fs
   ! Energy.
   ddw = wadj(0, jj+1, 0, irhoe, sps) - wadj(0, jj, 0, irhoe, sps)
   !fw(i,j+1,k,irhoE) = fw(i,j+1,k,irhoE) + fs
   !fw(i,j,k,irhoE)   = fw(i,j,k,irhoE)   - fs
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   CALL PUSHREAL8(fact)
   fact = -one
   END DO
   !!! Set dss1 to dss2 for the next face.
   !!
   !!dss1 = dss2
   !enddo
   !enddo
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the k-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !    
   ! Fluxes in k-direction.
   i = icell
   j = jcell
   k = kcell - 1
   fact = one
   !       do j=2,jl
   !         do i=2,il
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   x5 = (ss(0, 0, kk+1)-two*ss(0, 0, kk)+ss(0, 0, kk-1))/(ss(0, 0, kk&
   &        +1)+two*ss(0, 0, kk)+ss(0, 0, kk-1)+sslim)
   IF (x5 .GE. 0.) THEN
   dss1 = x5
   CALL PUSHINTEGER4(1)
   ELSE
   dss1 = -x5
   CALL PUSHINTEGER4(0)
   END IF
   x6 = (ss(0, 0, kk+2)-two*ss(0, 0, kk+1)+ss(0, 0, kk))/(ss(0, 0, kk&
   &        +2)+two*ss(0, 0, kk+1)+ss(0, 0, kk)+sslim)
   IF (x6 .GE. 0.) THEN
   dss2 = x6
   CALL PUSHINTEGER4(1)
   ELSE
   dss2 = -x6
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(ppor)
   ! Compute the dissipation coefficients for this face.
   ppor = zero
   IF (pork(i, j, k) .EQ. normalflux) THEN
   ppor = half
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(rrad)
   !rrad = ppor*(radK(i,j,k) + radK(i,j,k+1))
   rrad = ppor*(radkadj(0, 0, kk, sps)+radkadj(0, 0, kk+1, sps))
   !lumped Dissipation for preconditioner
   IF (lumpeddiss) THEN
   IF (dss1 .LT. dss2) THEN
   y5 = dss2
   CALL PUSHINTEGER4(1)
   ELSE
   y5 = dss1
   CALL PUSHINTEGER4(0)
   END IF
   IF (dssmax .GT. y5) THEN
   CALL PUSHREAL8(min5)
   min5 = y5
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8(min5)
   min5 = dssmax
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*rrad*min5 + sigma*fis4*rrad
   CALL PUSHREAL8(dis4)
   dis4 = 0.0
   CALL PUSHINTEGER4(0)
   ELSE
   IF (dss1 .LT. dss2) THEN
   y6 = dss2
   CALL PUSHINTEGER4(1)
   ELSE
   y6 = dss1
   CALL PUSHINTEGER4(0)
   END IF
   IF (dssmax .GT. y6) THEN
   CALL PUSHREAL8(min6)
   min6 = y6
   CALL PUSHINTEGER4(0)
   ELSE
   CALL PUSHREAL8(min6)
   min6 = dssmax
   CALL PUSHINTEGER4(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*rrad*min6
   !dis4 = dim(fis4*rrad, dis2)
   IF (fis4*rrad - dis2 .GT. 0.0) THEN
   CALL PUSHREAL8(dis4)
   dis4 = fis4*rrad - dis2
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHREAL8(dis4)
   dis4 = 0.0
   CALL PUSHINTEGER4(1)
   END IF
   END IF
   CALL PUSHREAL8(ddw)
   ! Compute and scatter the dissipative flux.
   ! Density. Store it in the mass flow of the
   ! appropriate sliding mesh interface.
   ddw = wadj(0, 0, kk+1, irho, sps) - wadj(0, 0, kk, irho, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j,k+1,irho) = fw(i,j,k+1,irho) + fs
   !fw(i,j,k,irho)   = fw(i,j,k,irho)   - fs
   ! X-momentum.
   ddw = wadj(0, 0, kk+1, ivx, sps) - wadj(0, 0, kk, ivx, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j,k+1,imx) = fw(i,j,k+1,imx) + fs
   !fw(i,j,k,imx)   = fw(i,j,k,imx)   - fs
   ! Y-momentum.
   ddw = wadj(0, 0, kk+1, ivy, sps) - wadj(0, 0, kk, ivy, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j,k+1,imy) = fw(i,j,k+1,imy) + fs
   !fw(i,j,k,imy)   = fw(i,j,k,imy)   - fs
   ! Z-momentum.
   ddw = wadj(0, 0, kk+1, ivz, sps) - wadj(0, 0, kk, ivz, sps)
   CALL PUSHREAL8(ddw)
   !fw(i,j,k+1,imz) = fw(i,j,k+1,imz) + fs
   !fw(i,j,k,imz)   = fw(i,j,k,imz)   - fs
   ! Energy.
   ddw = wadj(0, 0, kk+1, irhoe, sps) - wadj(0, 0, kk, irhoe, sps)
   !fw(i,j,k+1,irhoE) = fw(i,j,k+1,irhoE) + fs
   !fw(i,j,k,irhoE)   = fw(i,j,k,irhoE)   - fs
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   CALL PUSHREAL8(fact)
   fact = -one
   END DO
   radkadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
   ssb(-2:2, -2:2, -2:2) = 0.0
   DO kk=0,-1,-1
   CALL POPREAL8(fact)
   fsb = fact*dwadjb(irhoe, sps)
   temp5b0 = -(dis4*fsb)
   dis2b = ddw*fsb
   ddwb = dis2*fsb - three*temp5b0
   dis4b = -((wadj(0, 0, kk+2, irhoe, sps)-wadj(0, 0, kk-1, irhoe, &
   &        sps)-three*ddw)*fsb)
   wadjb(0, 0, kk+2, irhoe, sps) = wadjb(0, 0, kk+2, irhoe, sps) + &
   &        temp5b0
   wadjb(0, 0, kk-1, irhoe, sps) = wadjb(0, 0, kk-1, irhoe, sps) - &
   &        temp5b0
   CALL POPREAL8(ddw)
   wadjb(0, 0, kk+1, irhoe, sps) = wadjb(0, 0, kk+1, irhoe, sps) + &
   &        ddwb
   wadjb(0, 0, kk, irhoe, sps) = wadjb(0, 0, kk, irhoe, sps) - ddwb
   fsb = fact*dwadjb(imz, sps)
   temp5b1 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp5b1
   dis4b = dis4b - (wadj(0, 0, kk+2, ivz, sps)-wadj(0, 0, kk-1, ivz, &
   &        sps)-three*ddw)*fsb
   wadjb(0, 0, kk+2, ivz, sps) = wadjb(0, 0, kk+2, ivz, sps) + &
   &        temp5b1
   wadjb(0, 0, kk-1, ivz, sps) = wadjb(0, 0, kk-1, ivz, sps) - &
   &        temp5b1
   CALL POPREAL8(ddw)
   wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + ddwb
   wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) - ddwb
   fsb = fact*dwadjb(imy, sps)
   temp5b2 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp5b2
   dis4b = dis4b - (wadj(0, 0, kk+2, ivy, sps)-wadj(0, 0, kk-1, ivy, &
   &        sps)-three*ddw)*fsb
   wadjb(0, 0, kk+2, ivy, sps) = wadjb(0, 0, kk+2, ivy, sps) + &
   &        temp5b2
   wadjb(0, 0, kk-1, ivy, sps) = wadjb(0, 0, kk-1, ivy, sps) - &
   &        temp5b2
   CALL POPREAL8(ddw)
   wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + ddwb
   wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) - ddwb
   fsb = fact*dwadjb(imx, sps)
   temp5b3 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp5b3
   dis4b = dis4b - (wadj(0, 0, kk+2, ivx, sps)-wadj(0, 0, kk-1, ivx, &
   &        sps)-three*ddw)*fsb
   wadjb(0, 0, kk+2, ivx, sps) = wadjb(0, 0, kk+2, ivx, sps) + &
   &        temp5b3
   wadjb(0, 0, kk-1, ivx, sps) = wadjb(0, 0, kk-1, ivx, sps) - &
   &        temp5b3
   CALL POPREAL8(ddw)
   wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + ddwb
   wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) - ddwb
   fsb = fact*dwadjb(irho, sps)
   temp5b4 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp5b4
   dis4b = dis4b - (wadj(0, 0, kk+2, irho, sps)-wadj(0, 0, kk-1, irho&
   &        , sps)-three*ddw)*fsb
   wadjb(0, 0, kk+2, irho, sps) = wadjb(0, 0, kk+2, irho, sps) + &
   &        temp5b4
   wadjb(0, 0, kk-1, irho, sps) = wadjb(0, 0, kk-1, irho, sps) - &
   &        temp5b4
   CALL POPREAL8(ddw)
   wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + ddwb
   wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) - ddwb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   CALL POPREAL8(dis4)
   CALL POPREAL8(dis2)
   rradb = (sigma*fis4+fis2*min5)*dis2b
   min5b = fis2*rrad*dis2b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8(min5)
   y5b = min5b
   ELSE
   CALL POPREAL8(min5)
   y5b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   dss1b = y5b
   dss2b = 0.0
   ELSE
   dss2b = y5b
   dss1b = 0.0
   END IF
   GOTO 100
   ELSE
   CALL POPREAL8(dis4)
   rradb = 0.0
   END IF
   ELSE
   CALL POPREAL8(dis4)
   rradb = fis4*dis4b
   dis2b = dis2b - dis4b
   END IF
   CALL POPREAL8(dis2)
   rradb = rradb + fis2*min6*dis2b
   min6b = fis2*rrad*dis2b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8(min6)
   y6b = min6b
   ELSE
   CALL POPREAL8(min6)
   y6b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   dss1b = y6b
   dss2b = 0.0
   ELSE
   dss2b = y6b
   dss1b = 0.0
   END IF
   100  CALL POPREAL8(rrad)
   radkadjb(0, 0, kk, sps) = radkadjb(0, 0, kk, sps) + ppor*rradb
   radkadjb(0, 0, kk+1, sps) = radkadjb(0, 0, kk+1, sps) + ppor*rradb
   CALL POPINTEGER4(branch)
   CALL POPREAL8(ppor)
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x6b = -dss2b
   ELSE
   x6b = dss2b
   END IF
   temp4 = sslim + ss(0, 0, kk+2) + two*ss(0, 0, kk+1) + ss(0, 0, kk)
   temp5b = x6b/temp4
   temp4b0 = -((ss(0, 0, kk+2)-two*ss(0, 0, kk+1)+ss(0, 0, kk))*&
   &        temp5b/temp4)
   ssb(0, 0, kk+2) = ssb(0, 0, kk+2) + temp4b0 + temp5b
   ssb(0, 0, kk+1) = ssb(0, 0, kk+1) + two*temp4b0 - two*temp5b
   ssb(0, 0, kk) = ssb(0, 0, kk) + temp4b0 + temp5b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x5b = -dss1b
   ELSE
   x5b = dss1b
   END IF
   temp3 = sslim + ss(0, 0, kk+1) + two*ss(0, 0, kk) + ss(0, 0, kk-1)
   temp4b = x5b/temp3
   temp3b5 = -((ss(0, 0, kk+1)-two*ss(0, 0, kk)+ss(0, 0, kk-1))*&
   &        temp4b/temp3)
   ssb(0, 0, kk+1) = ssb(0, 0, kk+1) + temp3b5 + temp4b
   ssb(0, 0, kk) = ssb(0, 0, kk) + two*temp3b5 - two*temp4b
   ssb(0, 0, kk-1) = ssb(0, 0, kk-1) + temp3b5 + temp4b
   END DO
   radjadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   DO jj=0,-1,-1
   CALL POPREAL8(fact)
   fsb = fact*dwadjb(irhoe, sps)
   temp3b0 = -(dis4*fsb)
   dis2b = ddw*fsb
   ddwb = dis2*fsb - three*temp3b0
   dis4b = -((wadj(0, jj+2, 0, irhoe, sps)-wadj(0, jj-1, 0, irhoe, &
   &        sps)-three*ddw)*fsb)
   wadjb(0, jj+2, 0, irhoe, sps) = wadjb(0, jj+2, 0, irhoe, sps) + &
   &        temp3b0
   wadjb(0, jj-1, 0, irhoe, sps) = wadjb(0, jj-1, 0, irhoe, sps) - &
   &        temp3b0
   CALL POPREAL8(ddw)
   wadjb(0, jj+1, 0, irhoe, sps) = wadjb(0, jj+1, 0, irhoe, sps) + &
   &        ddwb
   wadjb(0, jj, 0, irhoe, sps) = wadjb(0, jj, 0, irhoe, sps) - ddwb
   fsb = fact*dwadjb(imz, sps)
   temp3b1 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp3b1
   dis4b = dis4b - (wadj(0, jj+2, 0, ivz, sps)-wadj(0, jj-1, 0, ivz, &
   &        sps)-three*ddw)*fsb
   wadjb(0, jj+2, 0, ivz, sps) = wadjb(0, jj+2, 0, ivz, sps) + &
   &        temp3b1
   wadjb(0, jj-1, 0, ivz, sps) = wadjb(0, jj-1, 0, ivz, sps) - &
   &        temp3b1
   CALL POPREAL8(ddw)
   wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + ddwb
   wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) - ddwb
   fsb = fact*dwadjb(imy, sps)
   temp3b2 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp3b2
   dis4b = dis4b - (wadj(0, jj+2, 0, ivy, sps)-wadj(0, jj-1, 0, ivy, &
   &        sps)-three*ddw)*fsb
   wadjb(0, jj+2, 0, ivy, sps) = wadjb(0, jj+2, 0, ivy, sps) + &
   &        temp3b2
   wadjb(0, jj-1, 0, ivy, sps) = wadjb(0, jj-1, 0, ivy, sps) - &
   &        temp3b2
   CALL POPREAL8(ddw)
   wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + ddwb
   wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) - ddwb
   fsb = fact*dwadjb(imx, sps)
   temp3b3 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp3b3
   dis4b = dis4b - (wadj(0, jj+2, 0, ivx, sps)-wadj(0, jj-1, 0, ivx, &
   &        sps)-three*ddw)*fsb
   wadjb(0, jj+2, 0, ivx, sps) = wadjb(0, jj+2, 0, ivx, sps) + &
   &        temp3b3
   wadjb(0, jj-1, 0, ivx, sps) = wadjb(0, jj-1, 0, ivx, sps) - &
   &        temp3b3
   CALL POPREAL8(ddw)
   wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + ddwb
   wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) - ddwb
   fsb = fact*dwadjb(irho, sps)
   temp3b4 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp3b4
   dis4b = dis4b - (wadj(0, jj+2, 0, irho, sps)-wadj(0, jj-1, 0, irho&
   &        , sps)-three*ddw)*fsb
   wadjb(0, jj+2, 0, irho, sps) = wadjb(0, jj+2, 0, irho, sps) + &
   &        temp3b4
   wadjb(0, jj-1, 0, irho, sps) = wadjb(0, jj-1, 0, irho, sps) - &
   &        temp3b4
   CALL POPREAL8(ddw)
   wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + ddwb
   wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) - ddwb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   CALL POPREAL8(dis4)
   CALL POPREAL8(dis2)
   rradb = (sigma*fis4+fis2*min3)*dis2b
   min3b = fis2*rrad*dis2b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8(min3)
   y3b = min3b
   ELSE
   CALL POPREAL8(min3)
   y3b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   dss1b = y3b
   dss2b = 0.0
   ELSE
   dss2b = y3b
   dss1b = 0.0
   END IF
   GOTO 110
   ELSE
   CALL POPREAL8(dis4)
   rradb = 0.0
   END IF
   ELSE
   CALL POPREAL8(dis4)
   rradb = fis4*dis4b
   dis2b = dis2b - dis4b
   END IF
   CALL POPREAL8(dis2)
   rradb = rradb + fis2*min4*dis2b
   min4b = fis2*rrad*dis2b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8(min4)
   y4b = min4b
   ELSE
   CALL POPREAL8(min4)
   y4b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   dss1b = y4b
   dss2b = 0.0
   ELSE
   dss2b = y4b
   dss1b = 0.0
   END IF
   110  CALL POPREAL8(rrad)
   radjadjb(0, jj, 0, sps) = radjadjb(0, jj, 0, sps) + ppor*rradb
   radjadjb(0, jj+1, 0, sps) = radjadjb(0, jj+1, 0, sps) + ppor*rradb
   CALL POPINTEGER4(branch)
   CALL POPREAL8(ppor)
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x4b = -dss2b
   ELSE
   x4b = dss2b
   END IF
   temp2 = sslim + ss(0, jj+2, 0) + two*ss(0, jj+1, 0) + ss(0, jj, 0)
   temp3b = x4b/temp2
   temp2b0 = -((ss(0, jj+2, 0)-two*ss(0, jj+1, 0)+ss(0, jj, 0))*&
   &        temp3b/temp2)
   ssb(0, jj+2, 0) = ssb(0, jj+2, 0) + temp2b0 + temp3b
   ssb(0, jj+1, 0) = ssb(0, jj+1, 0) + two*temp2b0 - two*temp3b
   ssb(0, jj, 0) = ssb(0, jj, 0) + temp2b0 + temp3b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x3b = -dss1b
   ELSE
   x3b = dss1b
   END IF
   temp1 = sslim + ss(0, jj+1, 0) + two*ss(0, jj, 0) + ss(0, jj-1, 0)
   temp2b = x3b/temp1
   temp1b5 = -((ss(0, jj+1, 0)-two*ss(0, jj, 0)+ss(0, jj-1, 0))*&
   &        temp2b/temp1)
   ssb(0, jj+1, 0) = ssb(0, jj+1, 0) + temp1b5 + temp2b
   ssb(0, jj, 0) = ssb(0, jj, 0) + two*temp1b5 - two*temp2b
   ssb(0, jj-1, 0) = ssb(0, jj-1, 0) + temp1b5 + temp2b
   END DO
   radiadjb(-1:1, -1:1, -1:1, 1:ntimeintervalsspectral) = 0.0
   DO ii=0,-1,-1
   CALL POPREAL8(fact)
   fsb = fact*dwadjb(irhoe, sps)
   temp1b0 = -(dis4*fsb)
   dis2b = ddw*fsb
   ddwb = dis2*fsb - three*temp1b0
   dis4b = -((wadj(ii+2, 0, 0, irhoe, sps)-wadj(ii-1, 0, 0, irhoe, &
   &        sps)-three*ddw)*fsb)
   wadjb(ii+2, 0, 0, irhoe, sps) = wadjb(ii+2, 0, 0, irhoe, sps) + &
   &        temp1b0
   wadjb(ii-1, 0, 0, irhoe, sps) = wadjb(ii-1, 0, 0, irhoe, sps) - &
   &        temp1b0
   CALL POPREAL8(ddw)
   wadjb(ii+1, 0, 0, irhoe, sps) = wadjb(ii+1, 0, 0, irhoe, sps) + &
   &        ddwb
   wadjb(ii, 0, 0, irhoe, sps) = wadjb(ii, 0, 0, irhoe, sps) - ddwb
   fsb = fact*dwadjb(imz, sps)
   temp1b1 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp1b1
   dis4b = dis4b - (wadj(ii+2, 0, 0, ivz, sps)-wadj(ii-1, 0, 0, ivz, &
   &        sps)-three*ddw)*fsb
   wadjb(ii+2, 0, 0, ivz, sps) = wadjb(ii+2, 0, 0, ivz, sps) + &
   &        temp1b1
   wadjb(ii-1, 0, 0, ivz, sps) = wadjb(ii-1, 0, 0, ivz, sps) - &
   &        temp1b1
   CALL POPREAL8(ddw)
   wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + ddwb
   wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) - ddwb
   fsb = fact*dwadjb(imy, sps)
   temp1b2 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp1b2
   dis4b = dis4b - (wadj(ii+2, 0, 0, ivy, sps)-wadj(ii-1, 0, 0, ivy, &
   &        sps)-three*ddw)*fsb
   wadjb(ii+2, 0, 0, ivy, sps) = wadjb(ii+2, 0, 0, ivy, sps) + &
   &        temp1b2
   wadjb(ii-1, 0, 0, ivy, sps) = wadjb(ii-1, 0, 0, ivy, sps) - &
   &        temp1b2
   CALL POPREAL8(ddw)
   wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + ddwb
   wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) - ddwb
   fsb = fact*dwadjb(imx, sps)
   temp1b3 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp1b3
   dis4b = dis4b - (wadj(ii+2, 0, 0, ivx, sps)-wadj(ii-1, 0, 0, ivx, &
   &        sps)-three*ddw)*fsb
   wadjb(ii+2, 0, 0, ivx, sps) = wadjb(ii+2, 0, 0, ivx, sps) + &
   &        temp1b3
   wadjb(ii-1, 0, 0, ivx, sps) = wadjb(ii-1, 0, 0, ivx, sps) - &
   &        temp1b3
   CALL POPREAL8(ddw)
   wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + ddwb
   wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) - ddwb
   fsb = fact*dwadjb(irho, sps)
   temp1b4 = -(dis4*fsb)
   dis2b = dis2b + ddw*fsb
   ddwb = dis2*fsb - three*temp1b4
   dis4b = dis4b - (wadj(ii+2, 0, 0, irho, sps)-wadj(ii-1, 0, 0, irho&
   &        , sps)-three*ddw)*fsb
   wadjb(ii+2, 0, 0, irho, sps) = wadjb(ii+2, 0, 0, irho, sps) + &
   &        temp1b4
   wadjb(ii-1, 0, 0, irho, sps) = wadjb(ii-1, 0, 0, irho, sps) - &
   &        temp1b4
   CALL POPREAL8(ddw)
   wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + ddwb
   wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) - ddwb
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) THEN
   CALL POPREAL8(dis4)
   CALL POPREAL8(dis2)
   rradb = (sigma*fis4+fis2*min1)*dis2b
   min1b = fis2*rrad*dis2b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8(min1)
   y1b = min1b
   ELSE
   CALL POPREAL8(min1)
   y1b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   dss1b = y1b
   dss2b = 0.0
   ELSE
   dss2b = y1b
   dss1b = 0.0
   END IF
   GOTO 120
   ELSE
   CALL POPREAL8(dis4)
   rradb = 0.0
   END IF
   ELSE
   CALL POPREAL8(dis4)
   rradb = fis4*dis4b
   dis2b = dis2b - dis4b
   END IF
   CALL POPREAL8(dis2)
   rradb = rradb + fis2*min2*dis2b
   min2b = fis2*rrad*dis2b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   CALL POPREAL8(min2)
   y2b = min2b
   ELSE
   CALL POPREAL8(min2)
   y2b = 0.0
   END IF
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   dss1b = y2b
   dss2b = 0.0
   ELSE
   dss2b = y2b
   dss1b = 0.0
   END IF
   120  CALL POPREAL8(rrad)
   radiadjb(ii, 0, 0, sps) = radiadjb(ii, 0, 0, sps) + ppor*rradb
   radiadjb(ii+1, 0, 0, sps) = radiadjb(ii+1, 0, 0, sps) + ppor*rradb
   CALL POPINTEGER4(branch)
   CALL POPREAL8(ppor)
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x2b = -dss2b
   ELSE
   x2b = dss2b
   END IF
   temp0 = sslim + ss(ii+2, 0, 0) + two*ss(ii+1, 0, 0) + ss(ii, 0, 0)
   temp1b = x2b/temp0
   temp0b0 = -((ss(ii+2, 0, 0)-two*ss(ii+1, 0, 0)+ss(ii, 0, 0))*&
   &        temp1b/temp0)
   ssb(ii+2, 0, 0) = ssb(ii+2, 0, 0) + temp0b0 + temp1b
   ssb(ii+1, 0, 0) = ssb(ii+1, 0, 0) + two*temp0b0 - two*temp1b
   ssb(ii, 0, 0) = ssb(ii, 0, 0) + temp0b0 + temp1b
   CALL POPINTEGER4(branch)
   IF (branch .LT. 1) THEN
   x1b = -dss1b
   ELSE
   x1b = dss1b
   END IF
   temp = sslim + ss(ii+1, 0, 0) + two*ss(ii, 0, 0) + ss(ii-1, 0, 0)
   temp0b = x1b/temp
   tempb = -((ss(ii+1, 0, 0)-two*ss(ii, 0, 0)+ss(ii-1, 0, 0))*temp0b/&
   &        temp)
   ssb(ii+1, 0, 0) = ssb(ii+1, 0, 0) + tempb + temp0b
   ssb(ii, 0, 0) = ssb(ii, 0, 0) + two*tempb - two*temp0b
   ssb(ii-1, 0, 0) = ssb(ii-1, 0, 0) + tempb + temp0b
   END DO
   padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   DO k=2,-2,-1
   DO j=2,-2,-1
   DO i=2,-2,-1
   CALL POPREAL8(wadj(i, j, k, irhoe, sps))
   padjb(i, j, k, sps) = padjb(i, j, k, sps) + wadjb(i, j, k, &
   &            irhoe, sps)
   CALL POPREAL8(wadj(i, j, k, ivz, sps))
   tmp1b = wadjb(i, j, k, ivz, sps)
   wadjb(i, j, k, ivz, sps) = 0.0
   wadjb(i, j, k, irho, sps) = wadjb(i, j, k, irho, sps) + wadj(i&
   &            , j, k, ivz, sps)*tmp1b
   wadjb(i, j, k, ivz, sps) = wadjb(i, j, k, ivz, sps) + wadj(i, &
   &            j, k, irho, sps)*tmp1b
   CALL POPREAL8(wadj(i, j, k, ivy, sps))
   tmp0b = wadjb(i, j, k, ivy, sps)
   wadjb(i, j, k, ivy, sps) = 0.0
   wadjb(i, j, k, irho, sps) = wadjb(i, j, k, irho, sps) + wadj(i&
   &            , j, k, ivy, sps)*tmp0b
   wadjb(i, j, k, ivy, sps) = wadjb(i, j, k, ivy, sps) + wadj(i, &
   &            j, k, irho, sps)*tmp0b
   CALL POPREAL8(wadj(i, j, k, ivx, sps))
   tmpb = wadjb(i, j, k, ivx, sps)
   wadjb(i, j, k, ivx, sps) = 0.0
   wadjb(i, j, k, irho, sps) = wadjb(i, j, k, irho, sps) + wadj(i&
   &            , j, k, ivx, sps)*tmpb
   wadjb(i, j, k, ivx, sps) = wadjb(i, j, k, ivx, sps) + wadj(i, &
   &            j, k, irho, sps)*tmpb
   END DO
   END DO
   END DO
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   DO k=2,-2,-1
   DO j=2,-2,-1
   DO i=2,-2,-1
   padjb(i, j, k, sps) = padjb(i, j, k, sps) + ssb(i, j, k)
   ssb(i, j, k) = 0.0
   END DO
   END DO
   END DO
   END IF
   END IF
   END SUBROUTINE INVISCIDDISSFLUXSCALARADJ_B

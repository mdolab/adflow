   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of bceulerwalladj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: padj wadj rfaceadj
   !                skadj sjadj sadj siadj normadj
   !   of linear combination of output variables: padj wadj rfaceadj
   !                skadj sjadj sadj siadj normadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcEulerWallAdj.f90                              *
   !      * Author:        Edwin van der Weide,C.A.(sandy)Mader            *
   !      *                Seongim Choi                                    *
   !      * Starting date: 03-21-2006                                      *
   !      * Last modified: 10-22-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCEULERWALLADJ_B(secondhalo, wadj, wadjb, padj, padjb, sadj, &
   &  sadjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, normadj, normadjb&
   &  , rfaceadj, rfaceadjb, icell, jcell, kcell, nn, level, sps, sps2)
   USE bctypes
   USE blockpointers, ONLY : bcdata, bcfaceid, addgridvelocities, &
   &  nbocos, bctype
   USE constants
   USE flowvarrefstate
   USE inputdiscretization
   USE inputtimespectral
   USE iteration
   IMPLICIT NONE
   INTEGER(KIND=INTTYPE) :: icell, jcell, kcell
   INTEGER(KIND=INTTYPE) :: level, nn, sps, sps2
   REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: normadj
   REAL(KIND=REALTYPE) :: normadjb(nbocos, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2, ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(nbocos, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: rfaceadj
   REAL(KIND=REALTYPE) :: rfaceadjb(nbocos, -2:2, -2:2, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sadj
   REAL(KIND=REALTYPE) :: sadjb(-2:2, -2:2, -2:2, 3, &
   &  ntimeintervalsspectral)
   LOGICAL :: secondhalo
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj
   REAL(KIND=REALTYPE) :: siadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), sjadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), skadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sjadj
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: skadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(KIND=REALTYPE) :: wadjb(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral)
   INTEGER :: ad_from, ad_from0, ad_from1, ad_from2, ad_from3, ad_from4, &
   &  ad_from5, ad_from6, ad_to, ad_to0, ad_to1, ad_to2, ad_to3, ad_to4, &
   &  ad_to5, ad_to6, branch, max1, max2
   LOGICAL :: computebc
   REAL(KIND=REALTYPE) :: dpj, dpjb, dpk, dpkb, qj, qjb, qk, qkb, ri, rib&
   &  , rj, rjb, rk, rkb, temp2b0, vn, vnb
   INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
   INTEGER(KIND=INTTYPE) :: icbeg, icend, jcbeg, jcend, kcbeg, kcend
   INTEGER(KIND=INTTYPE) :: ioffset, joffset, koffset
   INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, kk, l, nnbcs
   INTEGER(KIND=INTTYPE) :: jm1, jp1, km1, kp1
   INTEGER(KIND=INTTYPE) :: jjm1, jjp1, kkm1, kkp1
   INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
   REAL(KIND=REALTYPE) :: padj2(-2:2, -2:2), padj2b(-2:2, -2:2), padj3(-2&
   &  :2, -2:2), padj3b(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: revadj1(-2:2, -2:2), revadj2(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: rface, rfaceb
   REAL(KIND=REALTYPE) :: revadj(-2:2, -2:2, -2:2), rlvadj(-2:2, -2:2, -2&
   &  :2)
   REAL(KIND=REALTYPE) :: rlvadj1(-2:2, -2:2), rlvadj2(-2:2, -2:2)
   REAL(KIND=REALTYPE) :: rxj, rxjb, rxk, rxkb, ryj, ryjb, ryk, rykb, rzj&
   &  , rzjb, rzk, rzkb
   REAL(KIND=REALTYPE) :: sixa, sixab, siya, siyab, siza, sizab, sjxa, &
   &  sjxab, sjya, sjyab, sjza, sjzab
   REAL(KIND=REALTYPE) :: a1, b1, skxa, skxab, skya, skyab, skza, skzab
   REAL(KIND=REALTYPE) :: ssadj(-2:2, -2:2, 3), ssadjb(-2:2, -2:2, 3)
   REAL(KIND=REALTYPE) :: ssi(-3:2, -3:2, 3), ssib(-3:2, -3:2, 3), ssj(-3&
   &  :2, -3:2, 3), ssjb(-3:2, -3:2, 3), ssk(-3:2, -3:2, 3), sskb(-3:2, -3:&
   &  2, 3)
   REAL(KIND=REALTYPE) :: factk, gm53, ovgm1, temp0, temp0b, temp1, &
   &  temp1b, ux, uxb, uy, uyb, uz, uzb
   REAL(KIND=REALTYPE) :: padj0(-2:2, -2:2), padj0b(-2:2, -2:2), padj1(-2&
   &  :2, -2:2), padj1b(-2:2, -2:2), temp, temp2b, tempb
   REAL(KIND=REALTYPE) :: temp2b1, tmp, tmp0, tmp0b, tmpb, wadj0(-2:2, -2&
   &  :2, nw), wadj0b(-2:2, -2:2, nw), wadj1(-2:2, -2:2, nw), wadj1b(-2:2, &
   &  -2:2, nw)
   REAL(KIND=REALTYPE) :: wadj2(-2:2, -2:2, nw), wadj2b(-2:2, -2:2, nw), &
   &  wadj3(-2:2, -2:2, nw), wadj3b(-2:2, -2:2, nw)
   INTEGER(KIND=INTTYPE) :: walltreatment
   INTRINSIC MAX, MIN
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nnbcs=1,nbocos
   CALL PUSHINTEGER4(kbend)
   CALL PUSHINTEGER4(jbend)
   CALL PUSHINTEGER4(ibend)
   CALL PUSHINTEGER4(kbbeg)
   CALL PUSHINTEGER4(jbbeg)
   CALL PUSHINTEGER4(ibbeg)
   CALL PUSHINTEGER4(ksend)
   CALL PUSHINTEGER4(jsend)
   CALL PUSHINTEGER4(isend)
   CALL PUSHINTEGER4(ksbeg)
   CALL PUSHINTEGER4(jsbeg)
   CALL PUSHINTEGER4(isbeg)
   CALL CHECKOVERLAPADJ(nnbcs, icell, jcell, kcell, isbeg, jsbeg, ksbeg&
   &                   , isend, jsend, ksend, ibbeg, jbbeg, kbbeg, ibend, &
   &                   jbend, kbend, computebc)
   IF (computebc) THEN
   ! Check for Euler wall boundary condition.
   IF (bctype(nnbcs) .EQ. eulerwall) THEN
   CALL PUSHBOOLEAN(secondhalo)
   CALL PUSHINTEGER4(jcend)
   CALL PUSHINTEGER4(icend)
   CALL PUSHINTEGER4(jcbeg)
   CALL PUSHINTEGER4(icbeg)
   CALL PUSHINTEGER4(joffset)
   CALL PUSHINTEGER4(ioffset)
   CALL PUSHREAL8ARRAY(padj2, 5**2)
   CALL PUSHREAL8ARRAY(padj1, 5**2)
   CALL PUSHREAL8ARRAY(wadj2, 5**2*nw)
   CALL PUSHREAL8ARRAY(wadj1, 5**2*nw)
   ! Set the pointers for the unit normal and the normal
   ! velocity to make the code more readable.
   !!?norm  => BCData(nn)%norm
   !!?rface => BCData(nn)%rface
   !Copy the states and other parameters to subfaces
   CALL EXTRACTBCSTATESADJ(nnbcs, wadj, padj, wadj0, wadj1, wadj2, &
   &                          wadj3, padj0, padj1, padj2, padj3, rlvadj, &
   &                          revadj, rlvadj1, rlvadj2, revadj1, revadj2, &
   &                          ioffset, joffset, koffset, icell, jcell, &
   &                          kcell, isbeg, jsbeg, ksbeg, isend, jsend, &
   &                          ksend, ibbeg, jbbeg, kbbeg, ibend, jbend, &
   &                          kbend, icbeg, jcbeg, icend, jcend, secondhalo&
   &                          , nn, level, sps, sps2)
   ! Some initialization
   ssi = zero
   ssj = zero
   ssk = zero
   CALL PUSHREAL8(ovgm1)
   ! Easier storage of variables involving gamma.
   ovgm1 = one/(gammainf-one)
   gm53 = gammainf - five*third
   CALL PUSHREAL8(factk)
   factk = -(ovgm1*gm53)
   ! Determine the boundary condition treatment and compute the
   ! undivided pressure gradient accordingly. This gradient is
   ! temporarily stored in the halo pressure.
   SELECT CASE  (wallbctreatment) 
   CASE (constantpressure) 
   ad_from = jcbeg
   ! Constant pressure. Set the gradient to zero.
   DO j=ad_from,jcend
   ad_from0 = icbeg
   DO i=ad_from0,icend
   CALL PUSHINTEGER4(ii)
   ii = i - ioffset
   CALL PUSHINTEGER4(jj)
   jj = j - joffset
   padj1(ii, jj) = zero
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from)
   CALL PUSHINTEGER4(1)
   CASE (linextrapolpressure) 
   ad_from1 = jcbeg
   !===============================================================
   ! Linear extrapolation. Compute the gradient.
   DO j=ad_from1,jcend
   ad_from2 = icbeg
   DO i=ad_from2,icend
   CALL PUSHINTEGER4(ii)
   ii = i - ioffset
   CALL PUSHINTEGER4(jj)
   jj = j - joffset
   padj1(ii, jj) = padj3(ii, jj) - padj2(ii, jj)
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from2)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from1)
   CALL PUSHINTEGER4(2)
   CASE (normalmomentum) 
   !!$
   !!$
   !!$              !===============================================================
   !!$
   !!$           case (quadExtrapolPressure)
   !!$
   !!$              ! Quadratic extrapolation. Does not fit within the
   !!$              ! current data structures.
   !!$              
   !!$              !call terminate("bcEulerWallAdj", "Quadratic extrapolation does not fit within the current data structure for th
   !e boundary stuff")
   !!$              call terminate("bcEulerWallAdj", "Quadratic")
   !!$              !print *, "bcEulerWallAdj: quadExtrapolPressure: STOP"
   !!$
   !===============================================================
   !call terminate("bcEulerWallAdj", &
   !               "No normal momentum in this version.")
   !print *, "bcEulerWallAdj: STOP"
   ! Pressure gradient is computed using the normal momentum
   ! equation. First set a couple of additional variables for
   ! the normals, depending on the block face. Note that the
   ! construction 1: should not be used in these pointers,
   ! because element 0 is needed. Consequently there will be
   ! an offset of 1 for these normals. This is commented in
   ! the code. For moving faces also the grid velocity of
   ! the 1st cell center from the wall is needed.
   SELECT CASE  (bcfaceid(nnbcs)) 
   CASE (imin) 
   IF (secondhalo) THEN
   ssi(:, :, :) = siadj(-1, :, :, :, sps2)
   ssj(:, :, :) = sjadj(0, :, :, :, sps2)
   ssk(:, :, :) = skadj(0, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(0, :, :, :, sps2)
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   ELSE
   ssi(:, :, :) = siadj(-2, :, :, :, sps2)
   ssj(:, :, :) = sjadj(-1, :, :, :, sps2)
   ssk(:, :, :) = skadj(-1, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(-1, :, :, :, sps2)
   CALL PUSHINTEGER4(4)
   ELSE
   CALL PUSHINTEGER4(3)
   END IF
   END IF
   CASE (imax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = siadj(0, :, :, :, sps2)
   ssj(:, :, :) = sjadj(0, :, :, :, sps2)
   ssk(:, :, :) = skadj(0, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(0, :, :, :, sps2)
   CALL PUSHINTEGER4(6)
   ELSE
   CALL PUSHINTEGER4(5)
   END IF
   ELSE
   ssi(:, :, :) = siadj(1, :, :, :, sps2)
   ssj(:, :, :) = sjadj(1, :, :, :, sps2)
   ssk(:, :, :) = skadj(1, :, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(1, :, :, :, sps2)
   CALL PUSHINTEGER4(8)
   ELSE
   CALL PUSHINTEGER4(7)
   END IF
   END IF
   CASE (jmin) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = sjadj(:, -1, :, :, sps2)
   ssj(:, :, :) = siadj(:, 0, :, :, sps2)
   ssk(:, :, :) = skadj(:, 0, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, 0, :, :, sps2)
   CALL PUSHINTEGER4(10)
   ELSE
   CALL PUSHINTEGER4(9)
   END IF
   ELSE
   ssi(:, :, :) = sjadj(:, -2, :, :, sps2)
   ssj(:, :, :) = siadj(:, -1, :, :, sps2)
   ssk(:, :, :) = skadj(:, -1, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, -1, :, :, sps2)
   CALL PUSHINTEGER4(12)
   ELSE
   CALL PUSHINTEGER4(11)
   END IF
   END IF
   CASE (jmax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = sjadj(:, 0, :, :, sps2)
   ssj(:, :, :) = siadj(:, 0, :, :, sps2)
   ssk(:, :, :) = skadj(:, 0, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, 0, :, :, sps2)
   CALL PUSHINTEGER4(14)
   ELSE
   CALL PUSHINTEGER4(13)
   END IF
   ELSE
   ssi(:, :, :) = sjadj(:, 1, :, :, sps2)
   ssj(:, :, :) = siadj(:, 1, :, :, sps2)
   ssk(:, :, :) = skadj(:, 1, :, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, 1, :, :, sps2)
   CALL PUSHINTEGER4(16)
   ELSE
   CALL PUSHINTEGER4(15)
   END IF
   END IF
   CASE (kmin) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = skadj(:, :, -1, :, sps2)
   ssj(:, :, :) = siadj(:, :, 0, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 0, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, 0, :, sps2)
   CALL PUSHINTEGER4(18)
   ELSE
   CALL PUSHINTEGER4(17)
   END IF
   ELSE
   ssi(:, :, :) = skadj(:, :, -2, :, sps2)
   ssj(:, :, :) = siadj(:, :, -1, :, sps2)
   ssk(:, :, :) = sjadj(:, :, -1, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, -1, :, sps2)
   CALL PUSHINTEGER4(20)
   ELSE
   CALL PUSHINTEGER4(19)
   END IF
   END IF
   CASE (kmax) 
   !===========================================================
   IF (secondhalo) THEN
   ssi(:, :, :) = skadj(:, :, 0, :, sps2)
   ssj(:, :, :) = siadj(:, :, 0, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 0, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, 0, :, sps2)
   CALL PUSHINTEGER4(22)
   ELSE
   CALL PUSHINTEGER4(21)
   END IF
   ELSE
   ssi(:, :, :) = skadj(:, :, 1, :, sps2)
   ssj(:, :, :) = siadj(:, :, 1, :, sps2)
   ssk(:, :, :) = sjadj(:, :, 1, :, sps2)
   IF (addgridvelocities) THEN
   ssadj(:, :, :) = sadj(:, :, 1, :, sps2)
   CALL PUSHINTEGER4(24)
   ELSE
   CALL PUSHINTEGER4(23)
   END IF
   END IF
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from3 = jcbeg
   ! Loop over the faces of the generic subface.
   ! Note that now the running indices are j and k. This is
   ! done, because the generic i-direction is assumed to
   ! be the normal direction.
   DO k=ad_from3,jcend
   ! Store the indices k+1, k-1 a bit easier and make
   ! sure that they do not exceed the range of the arrays.
   km1 = k - 1
   IF (bcdata(nnbcs)%jcbeg .LT. km1) THEN
   km1 = km1
   CALL PUSHINTEGER4(1)
   ELSE
   km1 = bcdata(nnbcs)%jcbeg
   CALL PUSHINTEGER4(0)
   END IF
   kp1 = k + 1
   IF (bcdata(nnbcs)%jcend .GT. kp1) THEN
   kp1 = kp1
   CALL PUSHINTEGER4(1)
   ELSE
   kp1 = bcdata(nnbcs)%jcend
   CALL PUSHINTEGER4(0)
   END IF
   IF (1 .LT. kp1 - km1) THEN
   max1 = kp1 - km1
   CALL PUSHINTEGER4(1)
   ELSE
   max1 = 1
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(b1)
   ! Compute the scaling factor for the central difference
   ! in the k-direction.
   b1 = one/max1
   CALL PUSHINTEGER4(kk)
   ! Compute the offset indices.
   kk = k - joffset
   CALL PUSHINTEGER4(kkm1)
   kkm1 = km1 - joffset
   CALL PUSHINTEGER4(kkp1)
   kkp1 = kp1 - joffset
   ad_from4 = icbeg
   ! The generic j-direction.
   DO j=ad_from4,icend
   ! The indices j+1 and j-1. Make sure that they
   ! do not exceed the range of the arrays.
   jm1 = j - 1
   IF (bcdata(nnbcs)%icbeg .LT. jm1) THEN
   jm1 = jm1
   CALL PUSHINTEGER4(1)
   ELSE
   jm1 = bcdata(nnbcs)%icbeg
   CALL PUSHINTEGER4(0)
   END IF
   jp1 = j + 1
   IF (bcdata(nnbcs)%icend .GT. jp1) THEN
   jp1 = jp1
   CALL PUSHINTEGER4(1)
   ELSE
   jp1 = bcdata(nnbcs)%icend
   CALL PUSHINTEGER4(0)
   END IF
   IF (1 .LT. jp1 - jm1) THEN
   max2 = jp1 - jm1
   CALL PUSHINTEGER4(1)
   ELSE
   max2 = 1
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(a1)
   ! Compute the scaling factor for the central
   ! difference in the j-direction.
   a1 = one/max2
   CALL PUSHINTEGER4(jj)
   jj = j - ioffset
   CALL PUSHINTEGER4(jjm1)
   jjm1 = jm1 - ioffset
   CALL PUSHINTEGER4(jjp1)
   jjp1 = jp1 - ioffset
   CALL PUSHREAL8(sixa)
   ! Compute (twice) the average normal in the generic i,
   ! j and k-direction. Note that in j and k-direction
   ! the average in the original indices should be taken
   ! using j-1 and j (and k-1 and k). However due to the
   ! usage of pointers ssj and ssk there is an offset in
   ! the indices of 1 and therefore now the correct
   ! average is obtained with the indices j and j+1
   ! (k and k+1).
   sixa = two*ssi(jj, kk, 1)
   CALL PUSHREAL8(siya)
   siya = two*ssi(jj, kk, 2)
   CALL PUSHREAL8(siza)
   siza = two*ssi(jj, kk, 3)
   CALL PUSHREAL8(sjxa)
   ! it was ssj(j,k,1) + ssj(j+1,k,1)
   sjxa = ssj(jj-1, kk, 1) + ssj(jj, kk, 1)
   CALL PUSHREAL8(sjya)
   ! it was ssj(j,k,2) + ssj(j+1,k,2)
   sjya = ssj(jj-1, kk, 2) + ssj(jj, kk, 2)
   CALL PUSHREAL8(sjza)
   ! it was ssj(j,k,3) + ssj(j+1,k,3)
   sjza = ssj(jj-1, kk, 3) + ssj(jj, kk, 3)
   CALL PUSHREAL8(skxa)
   ! it was ssk(j,k,1) + ssk(j,k+1,1)
   skxa = ssk(jj, kk-1, 1) + ssk(jj, kk, 1)
   CALL PUSHREAL8(skya)
   ! it was ssk(j,k,2) + ssk(j,k+1,2)
   skya = ssk(jj, kk-1, 2) + ssk(jj, kk, 2)
   CALL PUSHREAL8(skza)
   ! it was ssk(j,k,3) + ssk(j,k+1,3)
   skza = ssk(jj, kk-1, 3) + ssk(jj, kk, 3)
   CALL PUSHREAL8(rxj)
   ! Compute the difference of the normal vector and
   ! pressure in j and k-direction. As the indices are
   ! restricted to the 1st halo-layer, the computation
   ! of the internal halo values is not consistent;
   ! however this is not really a problem, because these
   ! values are overwritten in the communication pattern.
   rxj = a1*(normadj(nnbcs, jjp1, kk, 1, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 1, sps2))
   CALL PUSHREAL8(ryj)
   ryj = a1*(normadj(nnbcs, jjp1, kk, 2, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 2, sps2))
   CALL PUSHREAL8(rzj)
   rzj = a1*(normadj(nnbcs, jjp1, kk, 3, sps2)-normadj(nnbcs&
   &                , jjm1, kk, 3, sps2))
   CALL PUSHREAL8(dpj)
   !print *, "jjp1,jjm1, kk =", jjp1,jjm1, kk
   dpj = a1*(padj2(jjp1, kk)-padj2(jjm1, kk))
   CALL PUSHREAL8(rxk)
   rxk = b1*(normadj(nnbcs, jj, kkp1, 1, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 1, sps2))
   CALL PUSHREAL8(ryk)
   ryk = b1*(normadj(nnbcs, jj, kkp1, 2, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 2, sps2))
   CALL PUSHREAL8(rzk)
   rzk = b1*(normadj(nnbcs, jj, kkp1, 3, sps2)-normadj(nnbcs&
   &                , jj, kkm1, 3, sps2))
   CALL PUSHREAL8(dpk)
   !print *, "jj, kkp1, kkm1 =", jj, kkp1, kkm1
   dpk = b1*(padj2(jj, kkp1)-padj2(jj, kkm1))
   CALL PUSHREAL8(ri)
   ! Compute the dot product between the unit vector
   ! and the normal vectors in i, j and k-direction.
   ri = normadj(nnbcs, jj, kk, 1, sps2)*sixa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*siya + normadj(nnbcs, jj, kk, 3, &
   &                sps2)*siza
   CALL PUSHREAL8(rj)
   rj = normadj(nnbcs, jj, kk, 1, sps2)*sjxa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*sjya + normadj(nnbcs, jj, kk, 3, &
   &                sps2)*sjza
   CALL PUSHREAL8(rk)
   rk = normadj(nnbcs, jj, kk, 1, sps2)*skxa + normadj(nnbcs&
   &                , jj, kk, 2, sps2)*skya + normadj(nnbcs, jj, kk, 3, &
   &                sps2)*skza
   CALL PUSHREAL8(ux)
   ! Store the velocity components in ux, uy and uz and
   ! subtract the mesh velocity if the face is moving.
   ux = wadj2(jj, kk, ivx)
   CALL PUSHREAL8(uy)
   uy = wadj2(jj, kk, ivy)
   CALL PUSHREAL8(uz)
   uz = wadj2(jj, kk, ivz)
   IF (addgridvelocities) THEN
   ux = ux - ssadj(jj, kk, 1)
   uy = uy - ssadj(jj, kk, 2)
   uz = uz - ssadj(jj, kk, 3)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(qj)
   ! Compute the velocity components in j and
   ! k-direction.
   qj = ux*sjxa + uy*sjya + uz*sjza
   CALL PUSHREAL8(qk)
   qk = ux*skxa + uy*skya + uz*skza
   ! Compute the pressure gradient, which is stored
   ! in pAdj1. I'm not entirely sure whether this
   ! formulation is correct for moving meshes. It could
   ! be that an additional term is needed there.
   padj1(jj, kk) = ((qj*(ux*rxj+uy*ryj+uz*rzj)+qk*(ux*rxk+uy*&
   &                ryk+uz*rzk))*wadj2(jj, kk, irho)-rj*dpj-rk*dpk)/ri
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from3)
   CALL PUSHINTEGER4(3)
   CASE DEFAULT
   CALL PUSHINTEGER4(0)
   END SELECT
   ad_from5 = jcbeg
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO j=ad_from5,jcend
   ad_from6 = icbeg
   DO i=ad_from6,icend
   CALL PUSHINTEGER4(ii)
   ii = i - ioffset
   CALL PUSHINTEGER4(jj)
   jj = j - joffset
   !BCData(nn)%rface(i,j)
   rface = rfaceadj(nnbcs, ii, jj, sps2)
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   ! max(zero, pAdj2(ii,jj)-pAdj1(ii,jj) )
   padj1(ii, jj) = padj2(ii, jj) - padj1(ii, jj)
   CALL PUSHREAL8(vn)
   !!$
   !!$!                 vn = two*(BCData(nn)%rface(i,j)              &
   !!$!                      - wAdj2(ii,jj,ivx)*normAdj(nn,ii,jj,1) &
   !!$!                      - wAdj2(ii,jj,ivy)*normAdj(nn,ii,jj,2) &
   !!$ !                     - wAdj2(ii,jj,ivz)*normAdj(nn,ii,jj,3))
   !!$
   vn = two*(rface-wadj2(ii, jj, ivx)*normadj(nnbcs, ii, jj, 1&
   &              , sps2)-wadj2(ii, jj, ivy)*normadj(nnbcs, ii, jj, 2, sps2&
   &              )-wadj2(ii, jj, ivz)*normadj(nnbcs, ii, jj, 3, sps2))
   CALL PUSHREAL8(wadj1(ii, jj, irho))
   wadj1(ii, jj, irho) = wadj2(ii, jj, irho)
   CALL PUSHREAL8(wadj1(ii, jj, ivx))
   wadj1(ii, jj, ivx) = wadj2(ii, jj, ivx) + vn*normadj(nnbcs, &
   &              ii, jj, 1, sps2)
   CALL PUSHREAL8(wadj1(ii, jj, ivy))
   wadj1(ii, jj, ivy) = wadj2(ii, jj, ivy) + vn*normadj(nnbcs, &
   &              ii, jj, 2, sps2)
   CALL PUSHREAL8(wadj1(ii, jj, ivz))
   wadj1(ii, jj, ivz) = wadj2(ii, jj, ivz) + vn*normadj(nnbcs, &
   &              ii, jj, 3, sps2)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   CALL PUSHREAL8(wadj1(ii, jj, l))
   wadj1(ii, jj, l) = wadj2(ii, jj, l)
   END DO
   !
   !        Input the viscous effects - rlv1(), and rev1()
   !
   ! Compute the total energy.
   tmp = ovgm1*padj1(ii, jj) + half*wadj1(ii, jj, irho)*(wadj1(&
   &              ii, jj, ivx)**2+wadj1(ii, jj, ivy)**2+wadj1(ii, jj, ivz)&
   &              **2)
   CALL PUSHREAL8(wadj1(ii, jj, irhoe))
   wadj1(ii, jj, irhoe) = tmp
   IF (kpresent) THEN
   tmp0 = wadj1(ii, jj, irhoe) - factk*wadj1(ii, jj, irho)*&
   &                wadj1(ii, jj, itu1)
   CALL PUSHREAL8(wadj1(ii, jj, irhoe))
   wadj1(ii, jj, irhoe) = tmp0
   CALL PUSHINTEGER4(2)
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from6)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from5)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHREAL8ARRAY(padj0, 5**2)
   CALL PUSHREAL8ARRAY(wadj0, 5**2*nw)
   CALL EXTRAPOLATE2NDHALOADJ(nnbcs, icbeg, icend, jcbeg, jcend, &
   &                               ioffset, joffset, wadj0, wadj1, wadj2, &
   &                               padj0, padj1, padj2)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL REPLACEBCSTATESADJ(nnbcs, wadj0, wadj1, wadj2, wadj3, padj0&
   &                          , padj1, padj2, padj3, rlvadj1, rlvadj2, &
   &                          revadj1, revadj2, icell, jcell, kcell, wadj, &
   &                          padj, rlvadj, revadj, secondhalo, nn, level, &
   &                          sps, sps2)
   CALL PUSHINTEGER4(3)
   ELSE
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   CALL PUSHINTEGER4(1)
   END IF
   END DO bocos
   ssadjb(-2:2, -2:2, 1:3) = 0.0
   padj0b(-2:2, -2:2) = 0.0
   padj1b(-2:2, -2:2) = 0.0
   padj2b(-2:2, -2:2) = 0.0
   padj3b(-2:2, -2:2) = 0.0
   wadj0b(-2:2, -2:2, 1:nw) = 0.0
   wadj1b(-2:2, -2:2, 1:nw) = 0.0
   wadj2b(-2:2, -2:2, 1:nw) = 0.0
   DO nnbcs=nbocos,1,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 3) THEN
   CALL REPLACEBCSTATESADJ_B(nnbcs, wadj0, wadj0b, wadj1, wadj1b, &
   &                          wadj2, wadj3, padj0, padj0b, padj1, padj1b, &
   &                          padj2, padj3, rlvadj1, rlvadj2, revadj1, &
   &                          revadj2, icell, jcell, kcell, wadj, wadjb, &
   &                          padj, padjb, rlvadj, revadj, secondhalo, nn, &
   &                          level, sps, sps2)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8ARRAY(wadj0, 5**2*nw)
   CALL POPREAL8ARRAY(padj0, 5**2)
   CALL EXTRAPOLATE2NDHALOADJ_B(nnbcs, icbeg, icend, jcbeg, jcend, &
   &                               ioffset, joffset, wadj0, wadj0b, wadj1, &
   &                               wadj1b, wadj2, wadj2b, padj0, padj0b, &
   &                               padj1, padj1b, padj2, padj2b)
   END IF
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO j=ad_to5,ad_from5,-1
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO i=ad_to6,ad_from6,-1
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 2) THEN
   CALL POPREAL8(wadj1(ii, jj, irhoe))
   tmp0b = wadj1b(ii, jj, irhoe)
   wadj1b(ii, jj, irhoe) = tmp0b
   wadj1b(ii, jj, irho) = wadj1b(ii, jj, irho) - factk*wadj1(ii&
   &              , jj, itu1)*tmp0b
   wadj1b(ii, jj, itu1) = wadj1b(ii, jj, itu1) - factk*wadj1(ii&
   &              , jj, irho)*tmp0b
   END IF
   CALL POPREAL8(wadj1(ii, jj, irhoe))
   tmpb = wadj1b(ii, jj, irhoe)
   wadj1b(ii, jj, irhoe) = 0.0
   temp2b1 = half*wadj1(ii, jj, irho)*tmpb
   padj1b(ii, jj) = padj1b(ii, jj) + ovgm1*tmpb
   wadj1b(ii, jj, irho) = wadj1b(ii, jj, irho) + half*(wadj1(ii, &
   &            jj, ivx)**2+wadj1(ii, jj, ivy)**2+wadj1(ii, jj, ivz)**2)*&
   &            tmpb
   wadj1b(ii, jj, ivx) = wadj1b(ii, jj, ivx) + 2*wadj1(ii, jj, &
   &            ivx)*temp2b1
   wadj1b(ii, jj, ivy) = wadj1b(ii, jj, ivy) + 2*wadj1(ii, jj, &
   &            ivy)*temp2b1
   wadj1b(ii, jj, ivz) = wadj1b(ii, jj, ivz) + 2*wadj1(ii, jj, &
   &            ivz)*temp2b1
   DO l=nt2mg,nt1mg,-1
   CALL POPREAL8(wadj1(ii, jj, l))
   wadj2b(ii, jj, l) = wadj2b(ii, jj, l) + wadj1b(ii, jj, l)
   wadj1b(ii, jj, l) = 0.0
   END DO
   CALL POPREAL8(wadj1(ii, jj, ivz))
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) + wadj1b(ii, jj, ivz&
   &            )
   vnb = normadj(nnbcs, ii, jj, 3, sps2)*wadj1b(ii, jj, ivz)
   normadjb(nnbcs, ii, jj, 3, sps2) = normadjb(nnbcs, ii, jj, 3, &
   &            sps2) + vn*wadj1b(ii, jj, ivz)
   wadj1b(ii, jj, ivz) = 0.0
   CALL POPREAL8(wadj1(ii, jj, ivy))
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) + wadj1b(ii, jj, ivy&
   &            )
   vnb = vnb + normadj(nnbcs, ii, jj, 2, sps2)*wadj1b(ii, jj, ivy&
   &            )
   normadjb(nnbcs, ii, jj, 2, sps2) = normadjb(nnbcs, ii, jj, 2, &
   &            sps2) + vn*wadj1b(ii, jj, ivy)
   wadj1b(ii, jj, ivy) = 0.0
   CALL POPREAL8(wadj1(ii, jj, ivx))
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) + wadj1b(ii, jj, ivx&
   &            )
   vnb = vnb + normadj(nnbcs, ii, jj, 1, sps2)*wadj1b(ii, jj, ivx&
   &            )
   temp2b0 = two*vnb
   normadjb(nnbcs, ii, jj, 1, sps2) = normadjb(nnbcs, ii, jj, 1, &
   &            sps2) + vn*wadj1b(ii, jj, ivx) - wadj2(ii, jj, ivx)*temp2b0
   wadj1b(ii, jj, ivx) = 0.0
   CALL POPREAL8(wadj1(ii, jj, irho))
   wadj2b(ii, jj, irho) = wadj2b(ii, jj, irho) + wadj1b(ii, jj, &
   &            irho)
   wadj1b(ii, jj, irho) = 0.0
   CALL POPREAL8(vn)
   rfaceb = temp2b0
   wadj2b(ii, jj, ivx) = wadj2b(ii, jj, ivx) - normadj(nnbcs, ii&
   &            , jj, 1, sps2)*temp2b0
   wadj2b(ii, jj, ivy) = wadj2b(ii, jj, ivy) - normadj(nnbcs, ii&
   &            , jj, 2, sps2)*temp2b0
   normadjb(nnbcs, ii, jj, 2, sps2) = normadjb(nnbcs, ii, jj, 2, &
   &            sps2) - wadj2(ii, jj, ivy)*temp2b0
   wadj2b(ii, jj, ivz) = wadj2b(ii, jj, ivz) - normadj(nnbcs, ii&
   &            , jj, 3, sps2)*temp2b0
   normadjb(nnbcs, ii, jj, 3, sps2) = normadjb(nnbcs, ii, jj, 3, &
   &            sps2) - wadj2(ii, jj, ivz)*temp2b0
   padj2b(ii, jj) = padj2b(ii, jj) + padj1b(ii, jj)
   padj1b(ii, jj) = -padj1b(ii, jj)
   rfaceadjb(nnbcs, ii, jj, sps2) = rfaceadjb(nnbcs, ii, jj, sps2&
   &            ) + rfaceb
   CALL POPINTEGER4(jj)
   CALL POPINTEGER4(ii)
   END DO
   END DO
   CALL POPINTEGER4(branch)
   IF (branch .LT. 2) THEN
   IF (.NOT.branch .LT. 1) THEN
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO j=ad_to,ad_from,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO i=ad_to0,ad_from0,-1
   padj1b(ii, jj) = 0.0
   CALL POPINTEGER4(jj)
   CALL POPINTEGER4(ii)
   END DO
   END DO
   END IF
   ELSE IF (branch .LT. 3) THEN
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO j=ad_to1,ad_from1,-1
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO i=ad_to2,ad_from2,-1
   padj3b(ii, jj) = padj3b(ii, jj) + padj1b(ii, jj)
   padj2b(ii, jj) = padj2b(ii, jj) - padj1b(ii, jj)
   padj1b(ii, jj) = 0.0
   CALL POPINTEGER4(jj)
   CALL POPINTEGER4(ii)
   END DO
   END DO
   ELSE
   ssib(-3:2, -3:2, 1:3) = 0.0
   ssjb(-3:2, -3:2, 1:3) = 0.0
   sskb(-3:2, -3:2, 1:3) = 0.0
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO k=ad_to3,ad_from3,-1
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   temp2b = padj1b(jj, kk)/ri
   tempb = wadj2(jj, kk, irho)*temp2b
   temp1 = ux*rxj + uy*ryj + uz*rzj
   temp1b = qj*tempb
   temp0 = ux*rxk + uy*ryk + uz*rzk
   temp0b = qk*tempb
   temp = qj*temp1 + qk*temp0
   qjb = temp1*tempb
   qkb = temp0*tempb
   uxb = sjxa*qjb + skxa*qkb + rxk*temp0b + rxj*temp1b
   rxjb = ux*temp1b
   uyb = sjya*qjb + skya*qkb + ryk*temp0b + ryj*temp1b
   ryjb = uy*temp1b
   uzb = sjza*qjb + skza*qkb + rzk*temp0b + rzj*temp1b
   rzjb = uz*temp1b
   rxkb = ux*temp0b
   rykb = uy*temp0b
   rzkb = uz*temp0b
   wadj2b(jj, kk, irho) = wadj2b(jj, kk, irho) + temp*temp2b
   rjb = -(dpj*temp2b)
   dpjb = -(rj*temp2b)
   rkb = -(dpk*temp2b)
   dpkb = -(rk*temp2b)
   rib = -((temp*wadj2(jj, kk, irho)-rj*dpj-rk*dpk)*temp2b/ri)
   padj1b(jj, kk) = 0.0
   CALL POPREAL8(qk)
   skxab = ux*qkb
   skyab = uy*qkb
   skzab = uz*qkb
   CALL POPREAL8(qj)
   sjxab = ux*qjb
   sjyab = uy*qjb
   sjzab = uz*qjb
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   ssadjb(jj, kk, 3) = ssadjb(jj, kk, 3) - uzb
   ssadjb(jj, kk, 2) = ssadjb(jj, kk, 2) - uyb
   ssadjb(jj, kk, 1) = ssadjb(jj, kk, 1) - uxb
   END IF
   CALL POPREAL8(uz)
   wadj2b(jj, kk, ivz) = wadj2b(jj, kk, ivz) + uzb
   CALL POPREAL8(uy)
   wadj2b(jj, kk, ivy) = wadj2b(jj, kk, ivy) + uyb
   CALL POPREAL8(ux)
   wadj2b(jj, kk, ivx) = wadj2b(jj, kk, ivx) + uxb
   CALL POPREAL8(rk)
   normadjb(nnbcs, jj, kk, 1, sps2) = normadjb(nnbcs, jj, kk, 1&
   &              , sps2) + skxa*rkb
   skxab = skxab + normadj(nnbcs, jj, kk, 1, sps2)*rkb
   normadjb(nnbcs, jj, kk, 2, sps2) = normadjb(nnbcs, jj, kk, 2&
   &              , sps2) + skya*rkb
   skyab = skyab + normadj(nnbcs, jj, kk, 2, sps2)*rkb
   normadjb(nnbcs, jj, kk, 3, sps2) = normadjb(nnbcs, jj, kk, 3&
   &              , sps2) + skza*rkb
   skzab = skzab + normadj(nnbcs, jj, kk, 3, sps2)*rkb
   CALL POPREAL8(rj)
   normadjb(nnbcs, jj, kk, 1, sps2) = normadjb(nnbcs, jj, kk, 1&
   &              , sps2) + sjxa*rjb
   sjxab = sjxab + normadj(nnbcs, jj, kk, 1, sps2)*rjb
   normadjb(nnbcs, jj, kk, 2, sps2) = normadjb(nnbcs, jj, kk, 2&
   &              , sps2) + sjya*rjb
   sjyab = sjyab + normadj(nnbcs, jj, kk, 2, sps2)*rjb
   normadjb(nnbcs, jj, kk, 3, sps2) = normadjb(nnbcs, jj, kk, 3&
   &              , sps2) + sjza*rjb
   sjzab = sjzab + normadj(nnbcs, jj, kk, 3, sps2)*rjb
   CALL POPREAL8(ri)
   normadjb(nnbcs, jj, kk, 1, sps2) = normadjb(nnbcs, jj, kk, 1&
   &              , sps2) + sixa*rib
   sixab = normadj(nnbcs, jj, kk, 1, sps2)*rib
   normadjb(nnbcs, jj, kk, 2, sps2) = normadjb(nnbcs, jj, kk, 2&
   &              , sps2) + siya*rib
   siyab = normadj(nnbcs, jj, kk, 2, sps2)*rib
   normadjb(nnbcs, jj, kk, 3, sps2) = normadjb(nnbcs, jj, kk, 3&
   &              , sps2) + siza*rib
   sizab = normadj(nnbcs, jj, kk, 3, sps2)*rib
   CALL POPREAL8(dpk)
   padj2b(jj, kkp1) = padj2b(jj, kkp1) + b1*dpkb
   padj2b(jj, kkm1) = padj2b(jj, kkm1) - b1*dpkb
   CALL POPREAL8(rzk)
   normadjb(nnbcs, jj, kkp1, 3, sps2) = normadjb(nnbcs, jj, &
   &              kkp1, 3, sps2) + b1*rzkb
   normadjb(nnbcs, jj, kkm1, 3, sps2) = normadjb(nnbcs, jj, &
   &              kkm1, 3, sps2) - b1*rzkb
   CALL POPREAL8(ryk)
   normadjb(nnbcs, jj, kkp1, 2, sps2) = normadjb(nnbcs, jj, &
   &              kkp1, 2, sps2) + b1*rykb
   normadjb(nnbcs, jj, kkm1, 2, sps2) = normadjb(nnbcs, jj, &
   &              kkm1, 2, sps2) - b1*rykb
   CALL POPREAL8(rxk)
   normadjb(nnbcs, jj, kkp1, 1, sps2) = normadjb(nnbcs, jj, &
   &              kkp1, 1, sps2) + b1*rxkb
   normadjb(nnbcs, jj, kkm1, 1, sps2) = normadjb(nnbcs, jj, &
   &              kkm1, 1, sps2) - b1*rxkb
   CALL POPREAL8(dpj)
   padj2b(jjp1, kk) = padj2b(jjp1, kk) + a1*dpjb
   padj2b(jjm1, kk) = padj2b(jjm1, kk) - a1*dpjb
   CALL POPREAL8(rzj)
   normadjb(nnbcs, jjp1, kk, 3, sps2) = normadjb(nnbcs, jjp1, &
   &              kk, 3, sps2) + a1*rzjb
   normadjb(nnbcs, jjm1, kk, 3, sps2) = normadjb(nnbcs, jjm1, &
   &              kk, 3, sps2) - a1*rzjb
   CALL POPREAL8(ryj)
   normadjb(nnbcs, jjp1, kk, 2, sps2) = normadjb(nnbcs, jjp1, &
   &              kk, 2, sps2) + a1*ryjb
   normadjb(nnbcs, jjm1, kk, 2, sps2) = normadjb(nnbcs, jjm1, &
   &              kk, 2, sps2) - a1*ryjb
   CALL POPREAL8(rxj)
   normadjb(nnbcs, jjp1, kk, 1, sps2) = normadjb(nnbcs, jjp1, &
   &              kk, 1, sps2) + a1*rxjb
   normadjb(nnbcs, jjm1, kk, 1, sps2) = normadjb(nnbcs, jjm1, &
   &              kk, 1, sps2) - a1*rxjb
   CALL POPREAL8(skza)
   sskb(jj, kk-1, 3) = sskb(jj, kk-1, 3) + skzab
   sskb(jj, kk, 3) = sskb(jj, kk, 3) + skzab
   CALL POPREAL8(skya)
   sskb(jj, kk-1, 2) = sskb(jj, kk-1, 2) + skyab
   sskb(jj, kk, 2) = sskb(jj, kk, 2) + skyab
   CALL POPREAL8(skxa)
   sskb(jj, kk-1, 1) = sskb(jj, kk-1, 1) + skxab
   sskb(jj, kk, 1) = sskb(jj, kk, 1) + skxab
   CALL POPREAL8(sjza)
   ssjb(jj-1, kk, 3) = ssjb(jj-1, kk, 3) + sjzab
   ssjb(jj, kk, 3) = ssjb(jj, kk, 3) + sjzab
   CALL POPREAL8(sjya)
   ssjb(jj-1, kk, 2) = ssjb(jj-1, kk, 2) + sjyab
   ssjb(jj, kk, 2) = ssjb(jj, kk, 2) + sjyab
   CALL POPREAL8(sjxa)
   ssjb(jj-1, kk, 1) = ssjb(jj-1, kk, 1) + sjxab
   ssjb(jj, kk, 1) = ssjb(jj, kk, 1) + sjxab
   CALL POPREAL8(siza)
   ssib(jj, kk, 3) = ssib(jj, kk, 3) + two*sizab
   CALL POPREAL8(siya)
   ssib(jj, kk, 2) = ssib(jj, kk, 2) + two*siyab
   CALL POPREAL8(sixa)
   ssib(jj, kk, 1) = ssib(jj, kk, 1) + two*sixab
   CALL POPINTEGER4(jjp1)
   CALL POPINTEGER4(jjm1)
   CALL POPINTEGER4(jj)
   CALL POPREAL8(a1)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END DO
   CALL POPINTEGER4(kkp1)
   CALL POPINTEGER4(kkm1)
   CALL POPINTEGER4(kk)
   CALL POPREAL8(b1)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)
   END DO
   CALL POPINTEGER4(branch)
   IF (branch .LT. 13) THEN
   IF (branch .LT. 7) THEN
   IF (branch .LT. 4) THEN
   IF (branch .LT. 2) THEN
   IF (branch .LT. 1) GOTO 140
   ELSE IF (branch .LT. 3) THEN
   sadjb(0, :, :, :, sps2) = sadjb(0, :, :, :, sps2) + &
   &                  ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   ELSE
   GOTO 100
   END IF
   skadjb(0, :, :, :, sps2) = skadjb(0, :, :, :, sps2) + sskb&
   &                (:, :, :)
   sjadjb(0, :, :, :, sps2) = sjadjb(0, :, :, :, sps2) + ssjb&
   &                (:, :, :)
   siadjb(-1, :, :, :, sps2) = siadjb(-1, :, :, :, sps2) + &
   &                ssib(:, :, :)
   ELSE
   IF (branch .LT. 6) THEN
   IF (branch .LT. 5) THEN
   sadjb(-1, :, :, :, sps2) = sadjb(-1, :, :, :, sps2) + &
   &                    ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   GOTO 100
   END IF
   ELSE
   sadjb(0, :, :, :, sps2) = sadjb(0, :, :, :, sps2) + &
   &                  ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   END IF
   skadjb(0, :, :, :, sps2) = skadjb(0, :, :, :, sps2) + sskb&
   &                (:, :, :)
   sjadjb(0, :, :, :, sps2) = sjadjb(0, :, :, :, sps2) + ssjb&
   &                (:, :, :)
   siadjb(0, :, :, :, sps2) = siadjb(0, :, :, :, sps2) + ssib&
   &                (:, :, :)
   END IF
   GOTO 140
   100        skadjb(-1, :, :, :, sps2) = skadjb(-1, :, :, :, sps2) + sskb&
   &              (:, :, :)
   sjadjb(-1, :, :, :, sps2) = sjadjb(-1, :, :, :, sps2) + ssjb&
   &              (:, :, :)
   siadjb(-2, :, :, :, sps2) = siadjb(-2, :, :, :, sps2) + ssib&
   &              (:, :, :)
   ELSE
   IF (branch .LT. 10) THEN
   IF (branch .LT. 9) THEN
   IF (.NOT.branch .LT. 8) THEN
   sadjb(1, :, :, :, sps2) = sadjb(1, :, :, :, sps2) + &
   &                    ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   END IF
   skadjb(1, :, :, :, sps2) = skadjb(1, :, :, :, sps2) + &
   &                  sskb(:, :, :)
   sjadjb(1, :, :, :, sps2) = sjadjb(1, :, :, :, sps2) + &
   &                  ssjb(:, :, :)
   siadjb(1, :, :, :, sps2) = siadjb(1, :, :, :, sps2) + &
   &                  ssib(:, :, :)
   GOTO 140
   END IF
   ELSE
   IF (branch .LT. 12) THEN
   IF (branch .LT. 11) THEN
   sadjb(:, 0, :, :, sps2) = sadjb(:, 0, :, :, sps2) + &
   &                    ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   GOTO 110
   END IF
   ELSE
   sadjb(:, -1, :, :, sps2) = sadjb(:, -1, :, :, sps2) + &
   &                  ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   END IF
   skadjb(:, -1, :, :, sps2) = skadjb(:, -1, :, :, sps2) + &
   &                sskb(:, :, :)
   siadjb(:, -1, :, :, sps2) = siadjb(:, -1, :, :, sps2) + &
   &                ssjb(:, :, :)
   sjadjb(:, -2, :, :, sps2) = sjadjb(:, -2, :, :, sps2) + &
   &                ssib(:, :, :)
   GOTO 140
   END IF
   110        skadjb(:, 0, :, :, sps2) = skadjb(:, 0, :, :, sps2) + sskb(:&
   &              , :, :)
   siadjb(:, 0, :, :, sps2) = siadjb(:, 0, :, :, sps2) + ssjb(:&
   &              , :, :)
   sjadjb(:, -1, :, :, sps2) = sjadjb(:, -1, :, :, sps2) + ssib&
   &              (:, :, :)
   END IF
   ELSE IF (branch .LT. 19) THEN
   IF (branch .LT. 16) THEN
   IF (branch .LT. 15) THEN
   IF (.NOT.branch .LT. 14) THEN
   sadjb(:, 0, :, :, sps2) = sadjb(:, 0, :, :, sps2) + &
   &                  ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   END IF
   skadjb(:, 0, :, :, sps2) = skadjb(:, 0, :, :, sps2) + sskb&
   &                (:, :, :)
   siadjb(:, 0, :, :, sps2) = siadjb(:, 0, :, :, sps2) + ssjb&
   &                (:, :, :)
   sjadjb(:, 0, :, :, sps2) = sjadjb(:, 0, :, :, sps2) + ssib&
   &                (:, :, :)
   GOTO 140
   END IF
   ELSE
   IF (branch .LT. 18) THEN
   IF (branch .LT. 17) THEN
   sadjb(:, 1, :, :, sps2) = sadjb(:, 1, :, :, sps2) + &
   &                  ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   GOTO 120
   END IF
   ELSE
   sadjb(:, :, 0, :, sps2) = sadjb(:, :, 0, :, sps2) + ssadjb&
   &                (:, :, :)
   ssadjb(:, :, :) = 0.0
   END IF
   sjadjb(:, :, 0, :, sps2) = sjadjb(:, :, 0, :, sps2) + sskb(:&
   &              , :, :)
   siadjb(:, :, 0, :, sps2) = siadjb(:, :, 0, :, sps2) + ssjb(:&
   &              , :, :)
   skadjb(:, :, -1, :, sps2) = skadjb(:, :, -1, :, sps2) + ssib&
   &              (:, :, :)
   GOTO 140
   END IF
   120      skadjb(:, 1, :, :, sps2) = skadjb(:, 1, :, :, sps2) + sskb(:, &
   &            :, :)
   siadjb(:, 1, :, :, sps2) = siadjb(:, 1, :, :, sps2) + ssjb(:, &
   &            :, :)
   sjadjb(:, 1, :, :, sps2) = sjadjb(:, 1, :, :, sps2) + ssib(:, &
   &            :, :)
   ELSE
   IF (branch .LT. 22) THEN
   IF (branch .LT. 21) THEN
   IF (.NOT.branch .LT. 20) THEN
   sadjb(:, :, -1, :, sps2) = sadjb(:, :, -1, :, sps2) + &
   &                  ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   END IF
   sjadjb(:, :, -1, :, sps2) = sjadjb(:, :, -1, :, sps2) + &
   &                sskb(:, :, :)
   siadjb(:, :, -1, :, sps2) = siadjb(:, :, -1, :, sps2) + &
   &                ssjb(:, :, :)
   skadjb(:, :, -2, :, sps2) = skadjb(:, :, -2, :, sps2) + &
   &                ssib(:, :, :)
   GOTO 140
   END IF
   ELSE
   IF (branch .LT. 24) THEN
   IF (branch .LT. 23) THEN
   sadjb(:, :, 0, :, sps2) = sadjb(:, :, 0, :, sps2) + &
   &                  ssadjb(:, :, :)
   ssadjb(:, :, :) = 0.0
   GOTO 130
   END IF
   ELSE
   sadjb(:, :, 1, :, sps2) = sadjb(:, :, 1, :, sps2) + ssadjb&
   &                (:, :, :)
   ssadjb(:, :, :) = 0.0
   END IF
   sjadjb(:, :, 1, :, sps2) = sjadjb(:, :, 1, :, sps2) + sskb(:&
   &              , :, :)
   siadjb(:, :, 1, :, sps2) = siadjb(:, :, 1, :, sps2) + ssjb(:&
   &              , :, :)
   skadjb(:, :, 1, :, sps2) = skadjb(:, :, 1, :, sps2) + ssib(:&
   &              , :, :)
   GOTO 140
   END IF
   130      sjadjb(:, :, 0, :, sps2) = sjadjb(:, :, 0, :, sps2) + sskb(:, &
   &            :, :)
   siadjb(:, :, 0, :, sps2) = siadjb(:, :, 0, :, sps2) + ssjb(:, &
   &            :, :)
   skadjb(:, :, 0, :, sps2) = skadjb(:, :, 0, :, sps2) + ssib(:, &
   &            :, :)
   END IF
   END IF
   140  CALL POPREAL8(factk)
   CALL POPREAL8(ovgm1)
   CALL POPREAL8ARRAY(wadj1, 5**2*nw)
   CALL POPREAL8ARRAY(wadj2, 5**2*nw)
   CALL POPREAL8ARRAY(padj1, 5**2)
   CALL POPREAL8ARRAY(padj2, 5**2)
   CALL POPINTEGER4(ioffset)
   CALL POPINTEGER4(joffset)
   CALL POPINTEGER4(icbeg)
   CALL POPINTEGER4(jcbeg)
   CALL POPINTEGER4(icend)
   CALL POPINTEGER4(jcend)
   CALL POPBOOLEAN(secondhalo)
   wadj3b(:, :, :) = 0.0
   CALL EXTRACTBCSTATESADJ_B(nnbcs, wadj, wadjb, padj, padjb, wadj0, &
   &                          wadj0b, wadj1, wadj1b, wadj2, wadj2b, wadj3, &
   &                          wadj3b, padj0, padj0b, padj1, padj1b, padj2, &
   &                          padj2b, padj3, padj3b, rlvadj, revadj, &
   &                          rlvadj1, rlvadj2, revadj1, revadj2, ioffset, &
   &                          joffset, koffset, icell, jcell, kcell, isbeg&
   &                          , jsbeg, ksbeg, isend, jsend, ksend, ibbeg, &
   &                          jbbeg, kbbeg, ibend, jbend, kbend, icbeg, &
   &                          jcbeg, icend, jcend, secondhalo, nn, level, &
   &                          sps, sps2)
   END IF
   CALL POPINTEGER4(isbeg)
   CALL POPINTEGER4(jsbeg)
   CALL POPINTEGER4(ksbeg)
   CALL POPINTEGER4(isend)
   CALL POPINTEGER4(jsend)
   CALL POPINTEGER4(ksend)
   CALL POPINTEGER4(ibbeg)
   CALL POPINTEGER4(jbbeg)
   CALL POPINTEGER4(kbbeg)
   CALL POPINTEGER4(ibend)
   CALL POPINTEGER4(jbend)
   CALL POPINTEGER4(kbend)
   END DO
   END SUBROUTINE BCEULERWALLADJ_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of metricadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: xadj
!   of linear combination of output variables: voladj xadj skadj
!                sjadj siadj normadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          metricAdj.f90                                   *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi                                    *
!      * Starting date: 12-15-2007                                      *
!      * Last modified: 12-26-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE METRICADJ_B(xadj, xadjb, siadj, siadjb, sjadj, sjadjb, skadj&
&  , skadjb, voladj, voladjb, normadj, normadjb, icell, jcell, kcell)
  USE bctypes
  USE blockpointers
  USE cgnsgrid
  USE communication
  USE constants
  USE inputtimespectral
  USE section
  IMPLICIT NONE
!                   call terminate("metric", &
!                   "Normals do not sum up to 0")
  INTEGER(KIND=INTTYPE), INTENT(IN) :: icell
  INTEGER(KIND=INTTYPE), INTENT(IN) :: jcell
  INTEGER(KIND=INTTYPE), INTENT(IN) :: kcell
  REAL(KIND=REALTYPE) :: normadj(nbocos, -2:2, -2:2, 3), normadjb(nbocos&
&  , -2:2, -2:2, 3)
  REAL(KIND=REALTYPE) :: siadj(-3:2, -3:2, -3:2, 3), siadjb(-3:2, -3:2, &
&  -3:2, 3), sjadj(-3:2, -3:2, -3:2, 3), sjadjb(-3:2, -3:2, -3:2, 3), &
&  skadj(-3:2, -3:2, -3:2, 3), skadjb(-3:2, -3:2, -3:2, 3)
  REAL(KIND=REALTYPE) :: voladj, voladjb
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3), INTENT(IN) :: &
&  xadj
  REAL(KIND=REALTYPE) :: xadjb(-3:2, -3:2, -3:2, 3)
  REAL(KIND=REALTYPE), PARAMETER :: thresvolume=1.e-2_realType
  INTEGER :: ad_from, ad_from0, ad_from1, ad_from2, ad_from3, ad_from4, &
&  ad_from5, ad_from6, ad_to, ad_to0, ad_to1, ad_to2, ad_to3, ad_to4, &
&  ad_to5, ad_to6, branch, ierr
  LOGICAL :: badvolume, checkall, checki, checkj, checkk, ioverlap, &
&  joverlap, koverlap, secondhalo, volumeisneg
  REAL(KIND=REALTYPE) :: fact, factb, mult, tempb12
  INTEGER(KIND=INTTYPE) :: ibbeg, ibend, jbbeg, jbend, kbbeg, kbend
  CHARACTER(len=10) :: integerstring
  INTEGER(KIND=INTTYPE) :: i, ien, ist, j, jen, jj, jst, k, kk, l, m, n
  INTEGER(KIND=INTTYPE) :: irbeg, irend, jrbeg, jrend, krbeg, krend
  INTEGER(KIND=INTTYPE) :: isbeg, isend, jsbeg, jsend, ksbeg, ksend
  INTEGER(KIND=INTTYPE) :: iend, istart, jend, jstart, kend, kstart
  INTEGER(KIND=INTTYPE) :: mm, ntime, sps
  INTEGER(KIND=INTTYPE) :: nvolbad, nvolbadglobal
  REAL(KIND=REALTYPE) :: ss(-2:2, -2:2, 3), ssb(-2:2, -2:2, 3)
  REAL(KIND=REALTYPE) :: temp, temp0, temp0b, temp1, temp10, temp11, &
&  temp1b, temp2, temp2b, temp3, temp3b, temp4, temp4b, temp5, temp5b, &
&  temp6, temp7, temp8, temp9, tempb10, tempb11, tempb13, tempb3, tempb4&
&  , tempb5, tempb6, tempb7, tempb8, tempb9
  REAL(KIND=REALTYPE) :: abs1, tempb
  REAL(KIND=REALTYPE) :: v1(3), v1b(3), v2(3), v2b(3)
  REAL(KIND=REALTYPE) :: abs2, abs3, abs4, abs5, abs6, abs7, tempb0, &
&  tempb1, tempb2, vp1, vp1b, vp2, vp2b, vp3, vp3b, vp4, vp4b, vp5, vp5b&
&  , vp6, vp6b, xp, xpb, yp, ypb, zp, zpb
  INTRINSIC MAX, ABS, MIN, SQRT
!
!      ******************************************************************
!      *                                                                *
!      * metric computes the face normals and the volume for the given  *
!      * grid level for all spectral solutions. First the volumes are   *
!      * computed assuming that the block is right handed. Then the     *
!      * number of positive and negative volumes are determined. If all *
!      * volumes are positive the block is indeed right handed; if all  *
!      * volumes are negative the block is left handed and both the     *
!      * volumes and the normals must be negated (for the normals this  *
!      * is done by the introduction of fact, which is either -0.5 or   *
!      * 0.5); if there are both positive and negative volumes the mesh *
!      * is not valid.                                                  *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
!       real(kind=realType), dimension(-2:3,-2:3,-2:3,3), intent(in) :: xAdj
!       real(kind=realType), dimension(-2:2,-2:2,-2:2,3), intent(out) :: siAdj, sjAdj, skAdj
!
!      Local parameter.
!
!
!      Local variables.
!
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
! Some initialization for siAdj,sjAdj,skAdj,normAdj 
! Volume needs only one stencil so it does not need initialization
  siadj = zero
  sjadj = zero
  skadj = zero
!
!
!      **************************************************************
!      *                                                            *
!      * Volume computation
!      *                                                            *
!      **************************************************************
!
! Compute the volumes. The hexahedron is split into 6 pyramids
! whose volumes are computed. The volume is positive for a
! right handed block.
! Initialize the volumes to zero. The reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
  k = 0
  j = 0
  i = 0
  n = k - 1
  m = j - 1
  l = i - 1
! always check the volume of changed cell
! Compute the coordinates of the center of gravity.
  xp = eighth*(xadj(i, j, k, 1)+xadj(i, m, k, 1)+xadj(i, m, n, 1)+xadj(i&
&    , j, n, 1)+xadj(l, j, k, 1)+xadj(l, m, k, 1)+xadj(l, m, n, 1)+xadj(&
&    l, j, n, 1))
  yp = eighth*(xadj(i, j, k, 2)+xadj(i, m, k, 2)+xadj(i, m, n, 2)+xadj(i&
&    , j, n, 2)+xadj(l, j, k, 2)+xadj(l, m, k, 2)+xadj(l, m, n, 2)+xadj(&
&    l, j, n, 2))
  zp = eighth*(xadj(i, j, k, 3)+xadj(i, m, k, 3)+xadj(i, m, n, 3)+xadj(i&
&    , j, n, 3)+xadj(l, j, k, 3)+xadj(l, m, k, 3)+xadj(l, m, n, 3)+xadj(&
&    l, j, n, 3))
! Compute the volumes of the 6 sub pyramids. The
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
  CALL VOLPYM2(xadj(i, j, k, 1), xadj(i, j, k, 2), xadj(i, j, k, 3), &
&         xadj(i, j, n, 1), xadj(i, j, n, 2), xadj(i, j, n, 3), xadj(i, &
&         m, n, 1), xadj(i, m, n, 2), xadj(i, m, n, 3), xadj(i, m, k, 1)&
&         , xadj(i, m, k, 2), xadj(i, m, k, 3), xp, yp, zp, vp1)
  CALL VOLPYM2(xadj(l, j, k, 1), xadj(l, j, k, 2), xadj(l, j, k, 3), &
&         xadj(l, m, k, 1), xadj(l, m, k, 2), xadj(l, m, k, 3), xadj(l, &
&         m, n, 1), xadj(l, m, n, 2), xadj(l, m, n, 3), xadj(l, j, n, 1)&
&         , xadj(l, j, n, 2), xadj(l, j, n, 3), xp, yp, zp, vp2)
  CALL VOLPYM2(xadj(i, j, k, 1), xadj(i, j, k, 2), xadj(i, j, k, 3), &
&         xadj(l, j, k, 1), xadj(l, j, k, 2), xadj(l, j, k, 3), xadj(l, &
&         j, n, 1), xadj(l, j, n, 2), xadj(l, j, n, 3), xadj(i, j, n, 1)&
&         , xadj(i, j, n, 2), xadj(i, j, n, 3), xp, yp, zp, vp3)
  CALL VOLPYM2(xadj(i, m, k, 1), xadj(i, m, k, 2), xadj(i, m, k, 3), &
&         xadj(i, m, n, 1), xadj(i, m, n, 2), xadj(i, m, n, 3), xadj(l, &
&         m, n, 1), xadj(l, m, n, 2), xadj(l, m, n, 3), xadj(l, m, k, 1)&
&         , xadj(l, m, k, 2), xadj(l, m, k, 3), xp, yp, zp, vp4)
  CALL VOLPYM2(xadj(i, j, k, 1), xadj(i, j, k, 2), xadj(i, j, k, 3), &
&         xadj(i, m, k, 1), xadj(i, m, k, 2), xadj(i, m, k, 3), xadj(l, &
&         m, k, 1), xadj(l, m, k, 2), xadj(l, m, k, 3), xadj(l, j, k, 1)&
&         , xadj(l, j, k, 2), xadj(l, j, k, 3), xp, yp, zp, vp5)
  CALL VOLPYM2(xadj(i, j, n, 1), xadj(i, j, n, 2), xadj(i, j, n, 3), &
&         xadj(l, j, n, 1), xadj(l, j, n, 2), xadj(l, j, n, 3), xadj(l, &
&         m, n, 1), xadj(l, m, n, 2), xadj(l, m, n, 3), xadj(i, m, n, 1)&
&         , xadj(i, m, n, 2), xadj(i, m, n, 3), xp, yp, zp, vp6)
! Set the volume to 1/6 of the sum of the volumes of the
! pyramid. Remember that volpym computes 6 times the
! volume.
  voladj = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
! Check the volume and update the number of positive
! and negative volumes if needed.
  IF (voladj .GE. 0.) THEN
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
!!$           ! Some additional safety stuff for halo volumes.
!!$
!!$           do k=2,kl
!!$             do j=2,jl
!!$               if(vol(1, j,k) <= eps) vol(1, j,k) = vol(2, j,k)
!!$               if(vol(ie,j,k) <= eps) vol(ie,j,k) = vol(il,j,k)
!!$             enddo
!!$           enddo
!!$
!!$           do k=2,kl
!!$             do i=1,ie
!!$               if(vol(i,1, k) <= eps) vol(i,1, k) = vol(i,2, k)
!!$               if(vol(i,je,k) <= eps) vol(i,je,k) = vol(i,jl,k)
!!$             enddo
!!$           enddo
!!$
!!$           do j=1,je
!!$             do i=1,ie
!!$               if(vol(i,j,1)  <= eps) vol(i,j,1)  = vol(i,j,2)
!!$               if(vol(i,j,ke) <= eps) vol(i,j,ke) = vol(i,j,kl)
!!$             enddo
!!$           enddo
!
!          **************************************************************
!          *                                                            *
!          * Computation of the face normals in i-, j- and k-direction. *
!          * Formula's are valid for a right handed block; for a left   *
!          * handed block the correct orientation is obtained via fact. *
!          * The normals point in the direction of increasing index.    *
!          * The absolute value of fact is 0.5, because the cross       *
!          * product of the two diagonals is twice the normal vector.   *
!          *                                                            *
!          * Note that also the normals of the first level halo cells   *
!          * are computed. These are needed for the viscous fluxes.     *
!          *                                                            *
!          **************************************************************
!
!s           if( flowDoms(nn,level,sps)%rightHanded ) then
  fact = half
!s           else
!s             fact = -half
!s           endif
! Projected areas of cell faces in the i direction.
  kstart = -2
  kend = 2
  jstart = -2
  jend = 2
  istart = -3
  iend = 2
  IF (icell .EQ. il) THEN
    iend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (icell .EQ. 2) THEN
    istart = -2
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (jcell .EQ. 2) THEN
    jstart = -1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (jcell .EQ. jl) THEN
    jend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (kcell .EQ. 2) THEN
    kstart = -1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (kcell .EQ. kl) THEN
    kend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  ad_from = kstart
  CALL PUSHINTEGER4(k)
!-2,2
  DO k=ad_from,kend
    CALL PUSHINTEGER4(n)
    n = k - 1
    ad_from0 = jstart
    CALL PUSHINTEGER4(j)
!-2,2
    DO j=ad_from0,jend
      CALL PUSHINTEGER4(m)
      m = j - 1
      ad_from1 = istart
      CALL PUSHINTEGER4(i)
!-2,2
      DO i=ad_from1,iend
        CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
        v1(1) = xadj(i, j, n, 1) - xadj(i, m, k, 1)
        CALL PUSHREAL8(v1(2))
        v1(2) = xadj(i, j, n, 2) - xadj(i, m, k, 2)
        CALL PUSHREAL8(v1(3))
        v1(3) = xadj(i, j, n, 3) - xadj(i, m, k, 3)
        CALL PUSHREAL8(v2(1))
        v2(1) = xadj(i, j, k, 1) - xadj(i, m, n, 1)
        CALL PUSHREAL8(v2(2))
        v2(2) = xadj(i, j, k, 2) - xadj(i, m, n, 2)
        CALL PUSHREAL8(v2(3))
        v2(3) = xadj(i, j, k, 3) - xadj(i, m, n, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        siadj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        siadj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        siadj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from1)
    END DO
    CALL PUSHINTEGER4(j - 1)
    CALL PUSHINTEGER4(ad_from0)
  END DO
  CALL PUSHINTEGER4(k - 1)
  CALL PUSHINTEGER4(ad_from)
! Projected areas of cell faces in the j direction.
  kstart = -2
  kend = 2
  jstart = -3
  jend = 2
  istart = -2
  iend = 2
  IF (icell .EQ. 2) THEN
    istart = -1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (icell .EQ. il) THEN
    iend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (jcell .EQ. jl) THEN
    jend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (jcell .EQ. 2) THEN
    jstart = -2
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (kcell .EQ. 2) THEN
    kstart = -1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (kcell .EQ. kl) THEN
    kend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  ad_from2 = kstart
!-2,2
  DO k=ad_from2,kend
    CALL PUSHINTEGER4(n)
    n = k - 1
    ad_from3 = jstart
    CALL PUSHINTEGER4(j)
!-2,2
    DO j=ad_from3,jend
      ad_from4 = istart
      CALL PUSHINTEGER4(i)
!-2,2
      DO i=ad_from4,iend
        CALL PUSHINTEGER4(l)
        l = i - 1
        CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
        v1(1) = xadj(i, j, n, 1) - xadj(l, j, k, 1)
        CALL PUSHREAL8(v1(2))
        v1(2) = xadj(i, j, n, 2) - xadj(l, j, k, 2)
        CALL PUSHREAL8(v1(3))
        v1(3) = xadj(i, j, n, 3) - xadj(l, j, k, 3)
        CALL PUSHREAL8(v2(1))
        v2(1) = xadj(l, j, n, 1) - xadj(i, j, k, 1)
        CALL PUSHREAL8(v2(2))
        v2(2) = xadj(l, j, n, 2) - xadj(i, j, k, 2)
        CALL PUSHREAL8(v2(3))
        v2(3) = xadj(l, j, n, 3) - xadj(i, j, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        sjadj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        sjadj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        sjadj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from4)
    END DO
    CALL PUSHINTEGER4(j - 1)
    CALL PUSHINTEGER4(ad_from3)
  END DO
  CALL PUSHINTEGER4(k - 1)
  CALL PUSHINTEGER4(ad_from2)
!print *,'sj2', sjAdj(i,j,k,2),sj(icell+i,jcell+j,kcell+k,2),i,j,k,icell+i,jcell+j,kcell+k
! Projected areas of cell faces in the k direction.
  kstart = -3
  kend = 2
  jstart = -2
  jend = 2
  istart = -2
  iend = 2
  IF (icell .EQ. 2) THEN
    istart = -1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (icell .EQ. il) THEN
    iend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (jcell .EQ. 2) THEN
    jstart = -1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (jcell .EQ. jl) THEN
    jend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (kcell .EQ. kl) THEN
    kend = 1
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
  IF (kcell .EQ. 2) THEN
    kstart = -2
    CALL PUSHINTEGER4(1)
  ELSE
    CALL PUSHINTEGER4(0)
  END IF
!-2,2
  DO k=kstart,kend
    CALL PUSHINTEGER4(j)
!-2,2
    DO j=jstart,jend
      CALL PUSHINTEGER4(m)
      m = j - 1
      CALL PUSHINTEGER4(i)
!-2,2
      DO i=istart,iend
        CALL PUSHINTEGER4(l)
        l = i - 1
        CALL PUSHREAL8(v1(1))
! Determine the two diagonal vectors of the face.
        v1(1) = xadj(i, j, k, 1) - xadj(l, m, k, 1)
        CALL PUSHREAL8(v1(2))
        v1(2) = xadj(i, j, k, 2) - xadj(l, m, k, 2)
        CALL PUSHREAL8(v1(3))
        v1(3) = xadj(i, j, k, 3) - xadj(l, m, k, 3)
        CALL PUSHREAL8(v2(1))
        v2(1) = xadj(l, j, k, 1) - xadj(i, m, k, 1)
        CALL PUSHREAL8(v2(2))
        v2(2) = xadj(l, j, k, 2) - xadj(i, m, k, 2)
        CALL PUSHREAL8(v2(3))
        v2(3) = xadj(l, j, k, 3) - xadj(i, m, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        skadj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        skadj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        skadj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
    END DO
  END DO
!
!        **************************************************************
!        *                                                            *
!        * If the considering cell is on the subfaces, then compute   *
!        * normAdj(-2:2,-2:2,-2:2,3). Otherwise return!               *
!        *                                                            *
!        * The unit normals on the boundary faces. These always point *
!        *  out of the domain, so a multiplication by -1 is needed for *
!        * the iMin, jMin and kMin boundaries.                        *
!        *                                                            *
!        **************************************************************
!
! Determine the range of the stencil for the given cell.
  isbeg = icell - 2
  isend = icell + 2
  jsbeg = jcell - 2
  jsend = jcell + 2
  ksbeg = kcell - 2
  ksend = kcell + 2
! Loop over the number of physical boundary subfaces of the block.
bocoloop:DO mm=1,nbocos
! Determine the range of halo cells which this boundary subface
! will change.
    SELECT CASE  (bcfaceid(mm)) 
    CASE (imin) 
      ibbeg = 0
      ibend = 1
      jbbeg = bcdata(mm)%icbeg
      jbend = bcdata(mm)%icend
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
      CALL PUSHINTEGER4(1)
    CASE (imax) 
!=============================================================
      ibbeg = ie
      ibend = ib
      jbbeg = bcdata(mm)%icbeg
      jbend = bcdata(mm)%icend
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
      CALL PUSHINTEGER4(2)
    CASE (jmin) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = 0
      jbend = 1
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
      CALL PUSHINTEGER4(3)
    CASE (jmax) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = je
      jbend = jb
      kbbeg = bcdata(mm)%jcbeg
      kbend = bcdata(mm)%jcend
      CALL PUSHINTEGER4(4)
    CASE (kmin) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = bcdata(mm)%jcbeg
      jbend = bcdata(mm)%jcend
      kbbeg = 0
      kbend = 1
      CALL PUSHINTEGER4(5)
    CASE (kmax) 
!=============================================================
      ibbeg = bcdata(mm)%icbeg
      ibend = bcdata(mm)%icend
      jbbeg = bcdata(mm)%jcbeg
      jbend = bcdata(mm)%jcend
      kbbeg = ke
      kbend = kb
      CALL PUSHINTEGER4(6)
    CASE DEFAULT
      CALL PUSHINTEGER4(0)
    END SELECT
! Check for an overlap between the stencil range and the
! halo cells influenced by this boundary subface.
    ioverlap = .false.
    IF (isbeg .LE. ibend .AND. isend .GE. ibbeg) THEN
      ioverlap = .true.
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    joverlap = .false.
    IF (jsbeg .LE. jbend .AND. jsend .GE. jbbeg) THEN
      joverlap = .true.
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    koverlap = .false.
    IF (ksbeg .LE. kbend .AND. ksend .GE. kbbeg) THEN
      koverlap = .true.
      CALL PUSHINTEGER4(1)
    ELSE
      CALL PUSHINTEGER4(0)
    END IF
    IF (ioverlap .AND. joverlap .AND. koverlap) THEN
      IF (isbeg .LT. ibbeg) THEN
        irbeg = ibbeg
        CALL PUSHINTEGER4(1)
      ELSE
        irbeg = isbeg
        CALL PUSHINTEGER4(0)
      END IF
      IF (isend .GT. ibend) THEN
        irend = ibend
        CALL PUSHINTEGER4(1)
      ELSE
        irend = isend
        CALL PUSHINTEGER4(0)
      END IF
      IF (jsbeg .LT. jbbeg) THEN
        jrbeg = jbbeg
        CALL PUSHINTEGER4(1)
      ELSE
        jrbeg = jsbeg
        CALL PUSHINTEGER4(0)
      END IF
      IF (jsend .GT. jbend) THEN
        jrend = jbend
        CALL PUSHINTEGER4(1)
      ELSE
        jrend = jsend
        CALL PUSHINTEGER4(0)
      END IF
      IF (ksbeg .LT. kbbeg) THEN
        krbeg = kbbeg
        CALL PUSHINTEGER4(1)
      ELSE
        krbeg = ksbeg
        CALL PUSHINTEGER4(0)
      END IF
      IF (ksend .GT. kbend) THEN
        krend = kbend
        CALL PUSHINTEGER4(1)
      ELSE
        krend = ksend
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHINTEGER4(ist)
      ist = -2
      CALL PUSHINTEGER4(ien)
      ien = 2
      CALL PUSHINTEGER4(jst)
      jst = -2
      CALL PUSHINTEGER4(jen)
      jen = 2
      SELECT CASE  (bcfaceid(mm)) 
      CASE (imin) 
        IF (jcell .EQ. 2) THEN
          ist = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (jcell .EQ. jl) THEN
          ien = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. 2) THEN
          jst = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. kl) THEN
          jen = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        secondhalo = .true.
        IF (irbeg .EQ. irend) THEN
          secondhalo = .false.
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = siadj(-1, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(11)
        ELSE
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = siadj(-2, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(12)
        END IF
      CASE (imax) 
        IF (jcell .EQ. 2) THEN
          ist = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (jcell .EQ. jl) THEN
          ien = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. 2) THEN
          jst = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. kl) THEN
          jen = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        secondhalo = .true.
        IF (irbeg .EQ. irend) THEN
          secondhalo = .false.
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = siadj(0, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(9)
        ELSE
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = siadj(1, ist:ien, jst:jen, :)
          CALL PUSHINTEGER4(10)
        END IF
      CASE (jmin) 
        IF (icell .EQ. 2) THEN
          ist = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (icell .EQ. il) THEN
          ien = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. 2) THEN
          jst = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. kl) THEN
          jen = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        secondhalo = .true.
        IF (jrbeg .EQ. jrend) THEN
          secondhalo = .false.
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -1, jst:jen, :)
          CALL PUSHINTEGER4(7)
        ELSE
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, -2, jst:jen, :)
          CALL PUSHINTEGER4(8)
        END IF
      CASE (jmax) 
        IF (icell .EQ. 2) THEN
          ist = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (icell .EQ. il) THEN
          ien = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. 2) THEN
          jst = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (kcell .EQ. kl) THEN
          jen = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        secondhalo = .true.
        IF (jrbeg .EQ. jrend) THEN
          secondhalo = .false.
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 0, jst:jen, :)
          CALL PUSHINTEGER4(5)
        ELSE
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = sjadj(ist:ien, 1, jst:jen, :)
          CALL PUSHINTEGER4(6)
        END IF
      CASE (kmin) 
        IF (icell .EQ. 2) THEN
          ist = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (icell .EQ. il) THEN
          ien = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (jcell .EQ. 2) THEN
          jst = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (jcell .EQ. jl) THEN
          jen = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        secondhalo = .true.
        IF (krbeg .EQ. krend) THEN
          secondhalo = .false.
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -1, :)
          CALL PUSHINTEGER4(3)
        ELSE
          CALL PUSHREAL8(mult)
          mult = -one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, -2, :)
          CALL PUSHINTEGER4(4)
        END IF
      CASE (kmax) 
        IF (icell .EQ. 2) THEN
          ist = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (icell .EQ. il) THEN
          ien = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (jcell .EQ. 2) THEN
          jst = -1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (jcell .EQ. jl) THEN
          jen = 1
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        secondhalo = .true.
        IF (krbeg .EQ. krend) THEN
          secondhalo = .false.
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHINTEGER4(0)
        END IF
        IF (secondhalo) THEN
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 0, :)
          CALL PUSHINTEGER4(1)
        ELSE
          CALL PUSHREAL8(mult)
          mult = one
          ss(ist:ien, jst:jen, :) = skadj(ist:ien, jst:jen, 1, :)
          CALL PUSHINTEGER4(2)
        END IF
      CASE DEFAULT
        CALL PUSHINTEGER4(0)
      END SELECT
      ad_from5 = jst
      DO kk=ad_from5,jen
        ad_from6 = ist
        DO jj=ad_from6,ien
          CALL PUSHREAL8(xp)
! Compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
          xp = ss(jj, kk, 1)
          CALL PUSHREAL8(yp)
          yp = ss(jj, kk, 2)
          CALL PUSHREAL8(zp)
          zp = ss(jj, kk, 3)
          CALL PUSHREAL8(fact)
          fact = SQRT(xp*xp + yp*yp + zp*zp)
          IF (fact .GT. zero) THEN
            CALL PUSHREAL8(fact)
            fact = mult/fact
            CALL PUSHINTEGER4(1)
          ELSE
            CALL PUSHINTEGER4(0)
          END IF
        END DO
        CALL PUSHINTEGER4(jj - 1)
        CALL PUSHINTEGER4(ad_from6)
      END DO
      CALL PUSHINTEGER4(kk - 1)
      CALL PUSHINTEGER4(ad_from5)
      CALL PUSHINTEGER4(2)
    ELSE
      CALL PUSHINTEGER4(1)
    END IF
  END DO bocoloop
!
!          **************************************************************
!          *                                                            *
!          * Check in debug mode the sum of the normals of the cells.   *
!          * If everything is correct this should sum up to zero.       *
!          *                                                            *
!          **************************************************************
!
  IF (debug) THEN
    CALL PUSHINTEGER4(i)
! Loop over the cells including the 1st level halo's.
    i = 0
    CALL PUSHINTEGER4(j)
    j = 0
    k = 0
    CALL PUSHINTEGER4(l)
    l = i - 1
    CALL PUSHINTEGER4(m)
    m = j - 1
    CALL PUSHINTEGER4(n)
    n = k - 1
! Store the sum of the outward pointing surrounding
! normals in v1. Due to the outward convention the
! normals with the lowest index get a negative sign;
! normals point in the direction of the higher index.
! Store the inverse of the sum of the areas of the
! six faces in fact.
    temp = skadj(i, j, n, 1)**2 + skadj(i, j, n, 2)**2 + skadj(i, j, n, &
&      3)**2
    temp11 = SQRT(temp)
    temp0 = skadj(i, j, k, 1)**2 + skadj(i, j, k, 2)**2 + skadj(i, j, k&
&      , 3)**2
    temp10 = SQRT(temp0)
    temp1 = sjadj(i, m, k, 1)**2 + sjadj(i, m, k, 2)**2 + sjadj(i, m, k&
&      , 3)**2
    temp9 = SQRT(temp1)
    temp2 = sjadj(i, j, k, 1)**2 + sjadj(i, j, k, 2)**2 + sjadj(i, j, k&
&      , 3)**2
    temp8 = SQRT(temp2)
    temp3 = siadj(l, j, k, 1)**2 + siadj(l, j, k, 2)**2 + siadj(l, j, k&
&      , 3)**2
    temp7 = SQRT(temp3)
    temp4 = siadj(i, j, k, 1)**2 + siadj(i, j, k, 2)**2 + siadj(i, j, k&
&      , 3)**2
    temp6 = SQRT(temp4)
    temp5 = temp6 + temp7 + temp8 + temp9 + temp10 + temp11
    temp5b = -(one*factb/temp5**2)
    temp4b = temp5b/(2.0*temp6)
    temp3b = temp5b/(2.0*temp7)
    temp2b = temp5b/(2.0*temp8)
    temp1b = temp5b/(2.0*temp9)
    temp0b = temp5b/(2.0*temp10)
    tempb13 = temp5b/(2.0*temp11)
    CALL POPINTEGER4(n)
    CALL POPINTEGER4(m)
    CALL POPINTEGER4(l)
    CALL POPINTEGER4(j)
    CALL POPINTEGER4(i)
  END IF
  ssb(-2:2, -2:2, 1:3) = 0.0
  DO mm=nbocos,1,-1
    CALL POPINTEGER4(branch)
    IF (.NOT.branch .LT. 2) THEN
      CALL POPINTEGER4(ad_from5)
      CALL POPINTEGER4(ad_to5)
      DO kk=ad_to5,ad_from5,-1
        CALL POPINTEGER4(ad_from6)
        CALL POPINTEGER4(ad_to6)
        DO jj=ad_to6,ad_from6,-1
          factb = zp*normadjb(mm, jj, kk, 3)
          zpb = fact*normadjb(mm, jj, kk, 3)
          normadjb(mm, jj, kk, 3) = 0.0
          factb = factb + yp*normadjb(mm, jj, kk, 2)
          ypb = fact*normadjb(mm, jj, kk, 2)
          normadjb(mm, jj, kk, 2) = 0.0
          factb = factb + xp*normadjb(mm, jj, kk, 1)
          xpb = fact*normadjb(mm, jj, kk, 1)
          normadjb(mm, jj, kk, 1) = 0.0
          CALL POPINTEGER4(branch)
          IF (.NOT.branch .LT. 1) THEN
            CALL POPREAL8(fact)
            factb = -(mult*factb/fact**2)
          END IF
          CALL POPREAL8(fact)
          tempb12 = factb/(2.0*SQRT(xp**2+yp**2+zp**2))
          xpb = xpb + 2*xp*tempb12
          ypb = ypb + 2*yp*tempb12
          zpb = zpb + 2*zp*tempb12
          CALL POPREAL8(zp)
          ssb(jj, kk, 3) = ssb(jj, kk, 3) + zpb
          CALL POPREAL8(yp)
          ssb(jj, kk, 2) = ssb(jj, kk, 2) + ypb
          CALL POPREAL8(xp)
          ssb(jj, kk, 1) = ssb(jj, kk, 1) + xpb
        END DO
      END DO
      CALL POPINTEGER4(branch)
      IF (branch .LT. 7) THEN
        IF (branch .LT. 4) THEN
          IF (branch .LT. 2) THEN
            IF (branch .LT. 1) THEN
              GOTO 120
            ELSE
              skadjb(ist:ien, jst:jen, 0, :) = skadjb(ist:ien, jst:jen, &
&                0, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
            END IF
          ELSE IF (branch .LT. 3) THEN
            skadjb(ist:ien, jst:jen, 1, :) = skadjb(ist:ien, jst:jen, 1&
&              , :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          ELSE
            skadjb(ist:ien, jst:jen, -1, :) = skadjb(ist:ien, jst:jen, -&
&              1, :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
            GOTO 100
          END IF
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
        ELSE
          IF (branch .LT. 6) THEN
            IF (branch .LT. 5) THEN
              skadjb(ist:ien, jst:jen, -2, :) = skadjb(ist:ien, jst:jen&
&                , -2, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
              GOTO 100
            ELSE
              sjadjb(ist:ien, 0, jst:jen, :) = sjadjb(ist:ien, 0, jst:&
&                jen, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
            END IF
          ELSE
            sjadjb(ist:ien, 1, jst:jen, :) = sjadjb(ist:ien, 1, jst:jen&
&              , :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          END IF
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
        END IF
        GOTO 120
 100    CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
      ELSE
        IF (branch .LT. 10) THEN
          IF (branch .LT. 9) THEN
            IF (branch .LT. 8) THEN
              sjadjb(ist:ien, -1, jst:jen, :) = sjadjb(ist:ien, -1, jst:&
&                jen, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
            ELSE
              sjadjb(ist:ien, -2, jst:jen, :) = sjadjb(ist:ien, -2, jst:&
&                jen, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
            END IF
            CALL POPINTEGER4(branch)
            CALL POPINTEGER4(branch)
            CALL POPINTEGER4(branch)
            CALL POPINTEGER4(branch)
            CALL POPINTEGER4(branch)
            GOTO 120
          ELSE
            siadjb(0, ist:ien, jst:jen, :) = siadjb(0, ist:ien, jst:jen&
&              , :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          END IF
        ELSE
          IF (branch .LT. 12) THEN
            IF (branch .LT. 11) THEN
              siadjb(1, ist:ien, jst:jen, :) = siadjb(1, ist:ien, jst:&
&                jen, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
              GOTO 110
            ELSE
              siadjb(-1, ist:ien, jst:jen, :) = siadjb(-1, ist:ien, jst:&
&                jen, :) + ssb(ist:ien, jst:jen, :)
              ssb(ist:ien, jst:jen, :) = 0.0
              CALL POPREAL8(mult)
            END IF
          ELSE
            siadjb(-2, ist:ien, jst:jen, :) = siadjb(-2, ist:ien, jst:&
&              jen, :) + ssb(ist:ien, jst:jen, :)
            ssb(ist:ien, jst:jen, :) = 0.0
            CALL POPREAL8(mult)
          END IF
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          CALL POPINTEGER4(branch)
          GOTO 120
        END IF
 110    CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
        CALL POPINTEGER4(branch)
      END IF
 120  CALL POPINTEGER4(jen)
      CALL POPINTEGER4(jst)
      CALL POPINTEGER4(ien)
      CALL POPINTEGER4(ist)
      CALL POPINTEGER4(branch)
      CALL POPINTEGER4(branch)
      CALL POPINTEGER4(branch)
      CALL POPINTEGER4(branch)
      CALL POPINTEGER4(branch)
      CALL POPINTEGER4(branch)
    END IF
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
    CALL POPINTEGER4(branch)
  END DO
  v1b(1:3) = 0.0
  v2b(1:3) = 0.0
  DO k=kend,kstart,-1
    DO j=jend,jstart,-1
      DO i=iend,istart,-1
        tempb9 = fact*skadjb(i, j, k, 3)
        v1b(1) = v1b(1) + v2(2)*tempb9
        v2b(2) = v2b(2) + v1(1)*tempb9
        v1b(2) = v1b(2) - v2(1)*tempb9
        skadjb(i, j, k, 3) = 0.0
        tempb10 = fact*skadjb(i, j, k, 2)
        v2b(1) = v2b(1) + v1(3)*tempb10 - v1(2)*tempb9
        v1b(3) = v1b(3) + v2(1)*tempb10
        v1b(1) = v1b(1) - v2(3)*tempb10
        skadjb(i, j, k, 2) = 0.0
        tempb11 = fact*skadjb(i, j, k, 1)
        v2b(3) = v2b(3) + v1(2)*tempb11 - v1(1)*tempb10
        v1b(2) = v1b(2) + v2(3)*tempb11
        v1b(3) = v1b(3) - v2(2)*tempb11
        v2b(2) = v2b(2) - v1(3)*tempb11
        skadjb(i, j, k, 1) = 0.0
        CALL POPREAL8(v2(3))
        xadjb(l, j, k, 3) = xadjb(l, j, k, 3) + v2b(3)
        xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v2b(3)
        v2b(3) = 0.0
        CALL POPREAL8(v2(2))
        xadjb(l, j, k, 2) = xadjb(l, j, k, 2) + v2b(2)
        xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v2b(2)
        v2b(2) = 0.0
        CALL POPREAL8(v2(1))
        xadjb(l, j, k, 1) = xadjb(l, j, k, 1) + v2b(1)
        xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v2b(1)
        v2b(1) = 0.0
        CALL POPREAL8(v1(3))
        xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v1b(3)
        xadjb(l, m, k, 3) = xadjb(l, m, k, 3) - v1b(3)
        v1b(3) = 0.0
        CALL POPREAL8(v1(2))
        xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v1b(2)
        xadjb(l, m, k, 2) = xadjb(l, m, k, 2) - v1b(2)
        v1b(2) = 0.0
        CALL POPREAL8(v1(1))
        xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v1b(1)
        xadjb(l, m, k, 1) = xadjb(l, m, k, 1) - v1b(1)
        v1b(1) = 0.0
        CALL POPINTEGER4(l)
      END DO
      CALL POPINTEGER4(i)
      CALL POPINTEGER4(m)
    END DO
    CALL POPINTEGER4(j)
  END DO
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(ad_from2)
  CALL POPINTEGER4(ad_to2)
  DO k=ad_to2,ad_from2,-1
    CALL POPINTEGER4(ad_from3)
    CALL POPINTEGER4(ad_to3)
    DO j=ad_to3,ad_from3,-1
      CALL POPINTEGER4(ad_from4)
      CALL POPINTEGER4(ad_to4)
      DO i=ad_to4,ad_from4,-1
        tempb6 = fact*sjadjb(i, j, k, 3)
        v1b(1) = v1b(1) + v2(2)*tempb6
        v2b(2) = v2b(2) + v1(1)*tempb6
        v1b(2) = v1b(2) - v2(1)*tempb6
        sjadjb(i, j, k, 3) = 0.0
        tempb7 = fact*sjadjb(i, j, k, 2)
        v2b(1) = v2b(1) + v1(3)*tempb7 - v1(2)*tempb6
        v1b(3) = v1b(3) + v2(1)*tempb7
        v1b(1) = v1b(1) - v2(3)*tempb7
        sjadjb(i, j, k, 2) = 0.0
        tempb8 = fact*sjadjb(i, j, k, 1)
        v2b(3) = v2b(3) + v1(2)*tempb8 - v1(1)*tempb7
        v1b(2) = v1b(2) + v2(3)*tempb8
        v1b(3) = v1b(3) - v2(2)*tempb8
        v2b(2) = v2b(2) - v1(3)*tempb8
        sjadjb(i, j, k, 1) = 0.0
        CALL POPREAL8(v2(3))
        xadjb(l, j, n, 3) = xadjb(l, j, n, 3) + v2b(3)
        xadjb(i, j, k, 3) = xadjb(i, j, k, 3) - v2b(3)
        v2b(3) = 0.0
        CALL POPREAL8(v2(2))
        xadjb(l, j, n, 2) = xadjb(l, j, n, 2) + v2b(2)
        xadjb(i, j, k, 2) = xadjb(i, j, k, 2) - v2b(2)
        v2b(2) = 0.0
        CALL POPREAL8(v2(1))
        xadjb(l, j, n, 1) = xadjb(l, j, n, 1) + v2b(1)
        xadjb(i, j, k, 1) = xadjb(i, j, k, 1) - v2b(1)
        v2b(1) = 0.0
        CALL POPREAL8(v1(3))
        xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
        xadjb(l, j, k, 3) = xadjb(l, j, k, 3) - v1b(3)
        v1b(3) = 0.0
        CALL POPREAL8(v1(2))
        xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
        xadjb(l, j, k, 2) = xadjb(l, j, k, 2) - v1b(2)
        v1b(2) = 0.0
        CALL POPREAL8(v1(1))
        xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
        xadjb(l, j, k, 1) = xadjb(l, j, k, 1) - v1b(1)
        v1b(1) = 0.0
        CALL POPINTEGER4(l)
      END DO
      CALL POPINTEGER4(i)
    END DO
    CALL POPINTEGER4(j)
    CALL POPINTEGER4(n)
  END DO
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(ad_from)
  CALL POPINTEGER4(ad_to)
  DO k=ad_to,ad_from,-1
    CALL POPINTEGER4(ad_from0)
    CALL POPINTEGER4(ad_to0)
    DO j=ad_to0,ad_from0,-1
      CALL POPINTEGER4(ad_from1)
      CALL POPINTEGER4(ad_to1)
      DO i=ad_to1,ad_from1,-1
        tempb3 = fact*siadjb(i, j, k, 3)
        v1b(1) = v1b(1) + v2(2)*tempb3
        v2b(2) = v2b(2) + v1(1)*tempb3
        v1b(2) = v1b(2) - v2(1)*tempb3
        siadjb(i, j, k, 3) = 0.0
        tempb4 = fact*siadjb(i, j, k, 2)
        v2b(1) = v2b(1) + v1(3)*tempb4 - v1(2)*tempb3
        v1b(3) = v1b(3) + v2(1)*tempb4
        v1b(1) = v1b(1) - v2(3)*tempb4
        siadjb(i, j, k, 2) = 0.0
        tempb5 = fact*siadjb(i, j, k, 1)
        v2b(3) = v2b(3) + v1(2)*tempb5 - v1(1)*tempb4
        v1b(2) = v1b(2) + v2(3)*tempb5
        v1b(3) = v1b(3) - v2(2)*tempb5
        v2b(2) = v2b(2) - v1(3)*tempb5
        siadjb(i, j, k, 1) = 0.0
        CALL POPREAL8(v2(3))
        xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + v2b(3)
        xadjb(i, m, n, 3) = xadjb(i, m, n, 3) - v2b(3)
        v2b(3) = 0.0
        CALL POPREAL8(v2(2))
        xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + v2b(2)
        xadjb(i, m, n, 2) = xadjb(i, m, n, 2) - v2b(2)
        v2b(2) = 0.0
        CALL POPREAL8(v2(1))
        xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + v2b(1)
        xadjb(i, m, n, 1) = xadjb(i, m, n, 1) - v2b(1)
        v2b(1) = 0.0
        CALL POPREAL8(v1(3))
        xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + v1b(3)
        xadjb(i, m, k, 3) = xadjb(i, m, k, 3) - v1b(3)
        v1b(3) = 0.0
        CALL POPREAL8(v1(2))
        xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + v1b(2)
        xadjb(i, m, k, 2) = xadjb(i, m, k, 2) - v1b(2)
        v1b(2) = 0.0
        CALL POPREAL8(v1(1))
        xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + v1b(1)
        xadjb(i, m, k, 1) = xadjb(i, m, k, 1) - v1b(1)
        v1b(1) = 0.0
      END DO
      CALL POPINTEGER4(i)
      CALL POPINTEGER4(m)
    END DO
    CALL POPINTEGER4(j)
    CALL POPINTEGER4(n)
  END DO
  CALL POPINTEGER4(k)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  IF (branch .LT. 1) voladjb = -voladjb
  tempb = sixth*voladjb
  vp1b = tempb
  vp2b = tempb
  vp3b = tempb
  vp4b = tempb
  vp5b = tempb
  vp6b = tempb
  zpb = 0.0
  ypb = 0.0
  xpb = 0.0
  CALL VOLPYM2_B(xadj(i, j, n, 1), xadjb(i, j, n, 1), xadj(i, j, n, 2), &
&           xadjb(i, j, n, 2), xadj(i, j, n, 3), xadjb(i, j, n, 3), xadj&
&           (l, j, n, 1), xadjb(l, j, n, 1), xadj(l, j, n, 2), xadjb(l, &
&           j, n, 2), xadj(l, j, n, 3), xadjb(l, j, n, 3), xadj(l, m, n&
&           , 1), xadjb(l, m, n, 1), xadj(l, m, n, 2), xadjb(l, m, n, 2)&
&           , xadj(l, m, n, 3), xadjb(l, m, n, 3), xadj(i, m, n, 1), &
&           xadjb(i, m, n, 1), xadj(i, m, n, 2), xadjb(i, m, n, 2), xadj&
&           (i, m, n, 3), xadjb(i, m, n, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp6, vp6b)
  CALL VOLPYM2_B(xadj(i, j, k, 1), xadjb(i, j, k, 1), xadj(i, j, k, 2), &
&           xadjb(i, j, k, 2), xadj(i, j, k, 3), xadjb(i, j, k, 3), xadj&
&           (i, m, k, 1), xadjb(i, m, k, 1), xadj(i, m, k, 2), xadjb(i, &
&           m, k, 2), xadj(i, m, k, 3), xadjb(i, m, k, 3), xadj(l, m, k&
&           , 1), xadjb(l, m, k, 1), xadj(l, m, k, 2), xadjb(l, m, k, 2)&
&           , xadj(l, m, k, 3), xadjb(l, m, k, 3), xadj(l, j, k, 1), &
&           xadjb(l, j, k, 1), xadj(l, j, k, 2), xadjb(l, j, k, 2), xadj&
&           (l, j, k, 3), xadjb(l, j, k, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp5, vp5b)
  CALL VOLPYM2_B(xadj(i, m, k, 1), xadjb(i, m, k, 1), xadj(i, m, k, 2), &
&           xadjb(i, m, k, 2), xadj(i, m, k, 3), xadjb(i, m, k, 3), xadj&
&           (i, m, n, 1), xadjb(i, m, n, 1), xadj(i, m, n, 2), xadjb(i, &
&           m, n, 2), xadj(i, m, n, 3), xadjb(i, m, n, 3), xadj(l, m, n&
&           , 1), xadjb(l, m, n, 1), xadj(l, m, n, 2), xadjb(l, m, n, 2)&
&           , xadj(l, m, n, 3), xadjb(l, m, n, 3), xadj(l, m, k, 1), &
&           xadjb(l, m, k, 1), xadj(l, m, k, 2), xadjb(l, m, k, 2), xadj&
&           (l, m, k, 3), xadjb(l, m, k, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp4, vp4b)
  CALL VOLPYM2_B(xadj(i, j, k, 1), xadjb(i, j, k, 1), xadj(i, j, k, 2), &
&           xadjb(i, j, k, 2), xadj(i, j, k, 3), xadjb(i, j, k, 3), xadj&
&           (l, j, k, 1), xadjb(l, j, k, 1), xadj(l, j, k, 2), xadjb(l, &
&           j, k, 2), xadj(l, j, k, 3), xadjb(l, j, k, 3), xadj(l, j, n&
&           , 1), xadjb(l, j, n, 1), xadj(l, j, n, 2), xadjb(l, j, n, 2)&
&           , xadj(l, j, n, 3), xadjb(l, j, n, 3), xadj(i, j, n, 1), &
&           xadjb(i, j, n, 1), xadj(i, j, n, 2), xadjb(i, j, n, 2), xadj&
&           (i, j, n, 3), xadjb(i, j, n, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp3, vp3b)
  CALL VOLPYM2_B(xadj(l, j, k, 1), xadjb(l, j, k, 1), xadj(l, j, k, 2), &
&           xadjb(l, j, k, 2), xadj(l, j, k, 3), xadjb(l, j, k, 3), xadj&
&           (l, m, k, 1), xadjb(l, m, k, 1), xadj(l, m, k, 2), xadjb(l, &
&           m, k, 2), xadj(l, m, k, 3), xadjb(l, m, k, 3), xadj(l, m, n&
&           , 1), xadjb(l, m, n, 1), xadj(l, m, n, 2), xadjb(l, m, n, 2)&
&           , xadj(l, m, n, 3), xadjb(l, m, n, 3), xadj(l, j, n, 1), &
&           xadjb(l, j, n, 1), xadj(l, j, n, 2), xadjb(l, j, n, 2), xadj&
&           (l, j, n, 3), xadjb(l, j, n, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp2, vp2b)
  CALL VOLPYM2_B(xadj(i, j, k, 1), xadjb(i, j, k, 1), xadj(i, j, k, 2), &
&           xadjb(i, j, k, 2), xadj(i, j, k, 3), xadjb(i, j, k, 3), xadj&
&           (i, j, n, 1), xadjb(i, j, n, 1), xadj(i, j, n, 2), xadjb(i, &
&           j, n, 2), xadj(i, j, n, 3), xadjb(i, j, n, 3), xadj(i, m, n&
&           , 1), xadjb(i, m, n, 1), xadj(i, m, n, 2), xadjb(i, m, n, 2)&
&           , xadj(i, m, n, 3), xadjb(i, m, n, 3), xadj(i, m, k, 1), &
&           xadjb(i, m, k, 1), xadj(i, m, k, 2), xadjb(i, m, k, 2), xadj&
&           (i, m, k, 3), xadjb(i, m, k, 3), xp, xpb, yp, ypb, zp, zpb, &
&           vp1, vp1b)
  tempb0 = eighth*zpb
  xadjb(i, j, k, 3) = xadjb(i, j, k, 3) + tempb0
  xadjb(i, m, k, 3) = xadjb(i, m, k, 3) + tempb0
  xadjb(i, m, n, 3) = xadjb(i, m, n, 3) + tempb0
  xadjb(i, j, n, 3) = xadjb(i, j, n, 3) + tempb0
  xadjb(l, j, k, 3) = xadjb(l, j, k, 3) + tempb0
  xadjb(l, m, k, 3) = xadjb(l, m, k, 3) + tempb0
  xadjb(l, m, n, 3) = xadjb(l, m, n, 3) + tempb0
  xadjb(l, j, n, 3) = xadjb(l, j, n, 3) + tempb0
  tempb1 = eighth*ypb
  xadjb(i, j, k, 2) = xadjb(i, j, k, 2) + tempb1
  xadjb(i, m, k, 2) = xadjb(i, m, k, 2) + tempb1
  xadjb(i, m, n, 2) = xadjb(i, m, n, 2) + tempb1
  xadjb(i, j, n, 2) = xadjb(i, j, n, 2) + tempb1
  xadjb(l, j, k, 2) = xadjb(l, j, k, 2) + tempb1
  xadjb(l, m, k, 2) = xadjb(l, m, k, 2) + tempb1
  xadjb(l, m, n, 2) = xadjb(l, m, n, 2) + tempb1
  xadjb(l, j, n, 2) = xadjb(l, j, n, 2) + tempb1
  tempb2 = eighth*xpb
  xadjb(i, j, k, 1) = xadjb(i, j, k, 1) + tempb2
  xadjb(i, m, k, 1) = xadjb(i, m, k, 1) + tempb2
  xadjb(i, m, n, 1) = xadjb(i, m, n, 1) + tempb2
  xadjb(i, j, n, 1) = xadjb(i, j, n, 1) + tempb2
  xadjb(l, j, k, 1) = xadjb(l, j, k, 1) + tempb2
  xadjb(l, m, k, 1) = xadjb(l, m, k, 1) + tempb2
  xadjb(l, m, n, 1) = xadjb(l, m, n, 1) + tempb2
  xadjb(l, j, n, 1) = xadjb(l, j, n, 1) + tempb2
END SUBROUTINE METRICADJ_B

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
!  
!  Differentiation of inviscidupwindfluxadj in reverse (adjoint) mode:
!   gradient, with respect to input variables: padj dwadj wadj
!                sfacekadj skadj sfacejadj sjadj sfaceiadj siadj
!                gammaconstant
!   of linear combination of output variables: dwadj
!
!      ******************************************************************
!      *                                                                *
!      * File:          inviscidUpwindFluxAdj.f90                       *
!      * Author:        Edwin van der Weide                             *
!      *                Seongim Choi,C.A.(Sandy)Mader                   *
!      * Starting date: 03-20-2006                                      *
!      * Last modified: 04-25-2008                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INVISCIDUPWINDFLUXADJ_B(wadj, wadjb, padj, padjb, dwadj, &
&  dwadjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, sfaceiadj, &
&  sfaceiadjb, sfacejadj, sfacejadjb, sfacekadj, sfacekadjb, icell, &
&  jcell, kcell, finegrid, nn, level, sps)
  USE blockpointers
  USE flowvarrefstate
  USE inputdiscretization
  USE inputphysics
  USE inputtimespectral
  IMPLICIT NONE
  REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
&  ntimeintervalsspectral)
  LOGICAL :: finegrid
  INTEGER(KIND=INTTYPE) :: icell, jcell, kcell, level, nn, sps
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
&  ntimeintervalsspectral), INTENT(IN) :: padj
  REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2, ntimeintervalsspectral)
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
&  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
&  ntimeintervalsspectral), INTENT(IN) :: sfacejadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
&  ntimeintervalsspectral), INTENT(IN) :: sfacekadj
  REAL(KIND=REALTYPE) :: sfaceiadjb(-2:2, -2:2, -2:2, &
&  ntimeintervalsspectral), sfacejadjb(-2:2, -2:2, -2:2, &
&  ntimeintervalsspectral), sfacekadjb(-2:2, -2:2, -2:2, &
&  ntimeintervalsspectral)
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
&  ntimeintervalsspectral), INTENT(IN) :: siadj
  REAL(KIND=REALTYPE) :: siadjb(-3:2, -3:2, -3:2, 3, &
&  ntimeintervalsspectral), sjadjb(-3:2, -3:2, -3:2, 3, &
&  ntimeintervalsspectral), skadjb(-3:2, -3:2, -3:2, 3, &
&  ntimeintervalsspectral)
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
&  ntimeintervalsspectral), INTENT(IN) :: sjadj
  REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
&  ntimeintervalsspectral), INTENT(IN) :: skadj
  REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw, &
&  ntimeintervalsspectral), INTENT(IN) :: wadj
  REAL(KIND=REALTYPE) :: wadjb(-2:2, -2:2, -2:2, nw, &
&  ntimeintervalsspectral)
  INTEGER :: branch
  LOGICAL :: correctfork, firstorderk
  REAL(KIND=REALTYPE) :: du1(nw), du1b(nw), du2(nw), du2b(nw), du3(nw), &
&  du3b(nw)
  REAL(KIND=REALTYPE) :: flux(nwf), fluxb(nwf)
  INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, kk
  REAL(KIND=REALTYPE) :: left(nw), leftb(nw), right(nw), rightb(nw)
  REAL(KIND=REALTYPE) :: max1
  INTEGER(KIND=INTTYPE) :: nwint
  INTEGER(KIND=PORTYPE) :: por
  REAL(KIND=REALTYPE) :: fact, factminmod, sface, sfaceb
  REAL(KIND=REALTYPE) :: gammaface, gammaface2, omk, opk, sx, sxb, sy, &
&  syb, sz, szb
  INTRINSIC MAX
!
!      ******************************************************************
!      *                                                                *
!      * inviscidUpwindFluxAdj computes the artificial dissipation part *
!      * the Euler fluxes by means of an approximate solution of the 1D *
!      * Riemann problem on the face. The fluxes are computed for the   *
!      * given cell of the block to which the variables in              *
!      * blockPointers currently point to.                              *
!      *                                                                *
!      ******************************************************************
!
! sI,sJ,sK
! limiter, firstOrder
!nTimeIntervalsSpectral
!
!      Subroutine arguments.
!
!
!      Local variables.
!
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
  correctfork = kpresent
  IF (1.e-10_realType .LT. one - kappacoef) THEN
    max1 = one - kappacoef
    CALL PUSHINTEGER4(1)
  ELSE
    max1 = 1.e-10_realType
    CALL PUSHINTEGER4(0)
  END IF
! Compute the factor used in the minmod limiter.
  factminmod = (three-kappacoef)/max1
! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
  omk = fourth*(one-kappacoef)
  opk = fourth*(one+kappacoef)
! Initialize sFace to zero. This value will be used if the
! block is not moving.
  sface = zero
! Set the number of variables to be interpolated depending
! whether or not a k-equation is present. If a k-equation is
! present also set the logical firstOrderK. This indicates
! whether or not only a first order approximation is to be used
! for the turbulent kinetic energy.
  IF (correctfork) THEN
    IF (orderturb .EQ. firstorder) THEN
      nwint = nwf
      firstorderk = .true.
      CALL PUSHINTEGER4(1)
    ELSE
      nwint = itu1
      firstorderk = .false.
      CALL PUSHINTEGER4(2)
    END IF
  ELSE
    nwint = nwf
    firstorderk = .false.
    CALL PUSHINTEGER4(0)
  END IF
!
!      ******************************************************************
!      *                                                                *
!      * Flux computation. A distinction is made between first and      *
!      * second order schemes to avoid the overhead for the first order *
!      * scheme.                                                        *
!      *                                                                *
!      ******************************************************************
!
  IF (limiter .EQ. firstorder) THEN
!
!        ****************************************************************
!        *                                                              *
!        * First order reconstruction. The states in the cells are      *
!        * constant. The left and right states are constructed easily.  *
!        *                                                              *
!        ****************************************************************
!
! Fluxes in the i-direction.
    i = icell - 1
    j = jcell
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO ii=-1,0
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = siadj(ii, 0, 0, 1, sps)
      sy = siadj(ii, 0, 0, 2, sps)
      sz = siadj(ii, 0, 0, 3, sps)
      CALL PUSHINTEGER4(por)
      por = pori(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfaceiadj(ii, 0, 0, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(left(irho))
! Determine the left and right state.
      left(irho) = wadj(ii, 0, 0, irho, sps)
      CALL PUSHREAL8(left(ivx))
      left(ivx) = wadj(ii, 0, 0, ivx, sps)
      CALL PUSHREAL8(left(ivy))
      left(ivy) = wadj(ii, 0, 0, ivy, sps)
      CALL PUSHREAL8(left(ivz))
      left(ivz) = wadj(ii, 0, 0, ivz, sps)
      CALL PUSHREAL8(left(irhoe))
      left(irhoe) = padj(ii, 0, 0, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(left(itu1))
        left(itu1) = wadj(ii, 0, 0, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(right(irho))
      right(irho) = wadj(ii+1, 0, 0, irho, sps)
      CALL PUSHREAL8(right(ivx))
      right(ivx) = wadj(ii+1, 0, 0, ivx, sps)
      CALL PUSHREAL8(right(ivy))
      right(ivy) = wadj(ii+1, 0, 0, ivy, sps)
      CALL PUSHREAL8(right(ivz))
      right(ivz) = wadj(ii+1, 0, 0, ivz, sps)
      CALL PUSHREAL8(right(irhoe))
      right(irhoe) = padj(ii+1, 0, 0, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(right(itu1))
        right(itu1) = wadj(ii+1, 0, 0, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
      CALL PUSHREAL8(sz)
      CALL PUSHREAL8(sy)
      CALL PUSHREAL8(sx)
!print *,'gammaface',gammaface,gammaface2
! Compute the dissipative flux across the interface
! and them to dwAdj.
!           call riemannFluxAdj(left,right,flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
      CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
&                    , sx, sy, sz, sface, finegrid)
! Update i and set fact to 1 for the second face.
      i = i + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in j-direction.
    i = icell
    j = jcell - 1
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO jj=-1,0
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = sjadj(0, jj, 0, 1, sps)
      sy = sjadj(0, jj, 0, 2, sps)
      sz = sjadj(0, jj, 0, 3, sps)
      CALL PUSHINTEGER4(por)
      por = porj(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacejadj(0, jj, 0, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(left(irho))
! Determine the left and right state.
      left(irho) = wadj(0, jj, 0, irho, sps)
      CALL PUSHREAL8(left(ivx))
      left(ivx) = wadj(0, jj, 0, ivx, sps)
      CALL PUSHREAL8(left(ivy))
      left(ivy) = wadj(0, jj, 0, ivy, sps)
      CALL PUSHREAL8(left(ivz))
      left(ivz) = wadj(0, jj, 0, ivz, sps)
      CALL PUSHREAL8(left(irhoe))
      left(irhoe) = padj(0, jj, 0, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(left(itu1))
        left(itu1) = wadj(0, jj, 0, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(right(irho))
      right(irho) = wadj(0, jj+1, 0, irho, sps)
      CALL PUSHREAL8(right(ivx))
      right(ivx) = wadj(0, jj+1, 0, ivx, sps)
      CALL PUSHREAL8(right(ivy))
      right(ivy) = wadj(0, jj+1, 0, ivy, sps)
      CALL PUSHREAL8(right(ivz))
      right(ivz) = wadj(0, jj+1, 0, ivz, sps)
      CALL PUSHREAL8(right(irhoe))
      right(irhoe) = padj(0, jj+1, 0, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(right(itu1))
        right(itu1) = wadj(0, jj+1, 0, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
      CALL PUSHREAL8(sz)
      CALL PUSHREAL8(sy)
      CALL PUSHREAL8(sx)
! Compute the dissipative flux across the interface
! and them to dwAdj.
!           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
      CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
&                    , sx, sy, sz, sface, finegrid)
! Update j and set fact to 1 for the second face.
      j = j + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in k-direction.
    i = icell
    j = jcell
    k = kcell - 1
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO kk=-1,0
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = skadj(0, 0, kk, 1, sps)
      sy = skadj(0, 0, kk, 2, sps)
      sz = skadj(0, 0, kk, 3, sps)
      CALL PUSHINTEGER4(por)
      por = pork(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacekadj(0, 0, kk, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(left(irho))
! Determine the left and right state.
      left(irho) = wadj(0, 0, kk, irho, sps)
      CALL PUSHREAL8(left(ivx))
      left(ivx) = wadj(0, 0, kk, ivx, sps)
      CALL PUSHREAL8(left(ivy))
      left(ivy) = wadj(0, 0, kk, ivy, sps)
      CALL PUSHREAL8(left(ivz))
      left(ivz) = wadj(0, 0, kk, ivz, sps)
      CALL PUSHREAL8(left(irhoe))
      left(irhoe) = padj(0, 0, kk, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(left(itu1))
        left(itu1) = wadj(0, 0, kk, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(right(irho))
      right(irho) = wadj(0, 0, kk+1, irho, sps)
      CALL PUSHREAL8(right(ivx))
      right(ivx) = wadj(0, 0, kk+1, ivx, sps)
      CALL PUSHREAL8(right(ivy))
      right(ivy) = wadj(0, 0, kk+1, ivy, sps)
      CALL PUSHREAL8(right(ivz))
      right(ivz) = wadj(0, 0, kk+1, ivz, sps)
      CALL PUSHREAL8(right(irhoe))
      right(irhoe) = padj(0, 0, kk+1, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(right(itu1))
        right(itu1) = wadj(0, 0, kk+1, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
      CALL PUSHREAL8(sz)
      CALL PUSHREAL8(sy)
      CALL PUSHREAL8(sx)
! Compute the dissipative flux across the interface
! and them to dwAdj.
!call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
      CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
&                    , sx, sy, sz, sface, finegrid)
! Update k and set fact to 1 for the second face.
      k = k + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
    padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
    sfacekadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    skadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
    fluxb(1:nwf) = 0.0
    leftb(1:nw) = 0.0
    rightb(1:nw) = 0.0
    sfaceb = 0.0
    DO kk=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
      CALL POPREAL8(sx)
      CALL POPREAL8(sy)
      CALL POPREAL8(sz)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, sfaceb, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(right(itu1))
        wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
&          rightb(itu1)
        rightb(itu1) = 0.0
      END IF
      CALL POPREAL8(right(irhoe))
      padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + rightb(irhoe)
      rightb(irhoe) = 0.0
      CALL POPREAL8(right(ivz))
      wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + rightb&
&        (ivz)
      rightb(ivz) = 0.0
      CALL POPREAL8(right(ivy))
      wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + rightb&
&        (ivy)
      rightb(ivy) = 0.0
      CALL POPREAL8(right(ivx))
      wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + rightb&
&        (ivx)
      rightb(ivx) = 0.0
      CALL POPREAL8(right(irho))
      wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + &
&        rightb(irho)
      rightb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(left(itu1))
        wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + leftb(&
&          itu1)
        leftb(itu1) = 0.0
      END IF
      CALL POPREAL8(left(irhoe))
      padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + leftb(irhoe)
      leftb(irhoe) = 0.0
      CALL POPREAL8(left(ivz))
      wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + leftb(ivz)
      leftb(ivz) = 0.0
      CALL POPREAL8(left(ivy))
      wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + leftb(ivy)
      leftb(ivy) = 0.0
      CALL POPREAL8(left(ivx))
      wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + leftb(ivx)
      leftb(ivx) = 0.0
      CALL POPREAL8(left(irho))
      wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + leftb(&
&        irho)
      leftb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(sface)
        sfacekadjb(0, 0, kk, sps) = sfacekadjb(0, 0, kk, sps) + sfaceb
        sfaceb = 0.0
      END IF
      CALL POPINTEGER4(por)
      skadjb(0, 0, kk, 3, sps) = skadjb(0, 0, kk, 3, sps) + szb
      skadjb(0, 0, kk, 2, sps) = skadjb(0, 0, kk, 2, sps) + syb
      skadjb(0, 0, kk, 1, sps) = skadjb(0, 0, kk, 1, sps) + sxb
    END DO
    sfacejadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    sjadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
    DO jj=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
      CALL POPREAL8(sx)
      CALL POPREAL8(sy)
      CALL POPREAL8(sz)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, sfaceb, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(right(itu1))
        wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
&          rightb(itu1)
        rightb(itu1) = 0.0
      END IF
      CALL POPREAL8(right(irhoe))
      padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + rightb(irhoe)
      rightb(irhoe) = 0.0
      CALL POPREAL8(right(ivz))
      wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + rightb&
&        (ivz)
      rightb(ivz) = 0.0
      CALL POPREAL8(right(ivy))
      wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + rightb&
&        (ivy)
      rightb(ivy) = 0.0
      CALL POPREAL8(right(ivx))
      wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + rightb&
&        (ivx)
      rightb(ivx) = 0.0
      CALL POPREAL8(right(irho))
      wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + &
&        rightb(irho)
      rightb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(left(itu1))
        wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + leftb(&
&          itu1)
        leftb(itu1) = 0.0
      END IF
      CALL POPREAL8(left(irhoe))
      padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + leftb(irhoe)
      leftb(irhoe) = 0.0
      CALL POPREAL8(left(ivz))
      wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + leftb(ivz)
      leftb(ivz) = 0.0
      CALL POPREAL8(left(ivy))
      wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + leftb(ivy)
      leftb(ivy) = 0.0
      CALL POPREAL8(left(ivx))
      wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + leftb(ivx)
      leftb(ivx) = 0.0
      CALL POPREAL8(left(irho))
      wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + leftb(&
&        irho)
      leftb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(sface)
        sfacejadjb(0, jj, 0, sps) = sfacejadjb(0, jj, 0, sps) + sfaceb
        sfaceb = 0.0
      END IF
      CALL POPINTEGER4(por)
      sjadjb(0, jj, 0, 3, sps) = sjadjb(0, jj, 0, 3, sps) + szb
      sjadjb(0, jj, 0, 2, sps) = sjadjb(0, jj, 0, 2, sps) + syb
      sjadjb(0, jj, 0, 1, sps) = sjadjb(0, jj, 0, 1, sps) + sxb
    END DO
    sfaceiadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    siadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
    DO ii=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
      CALL POPREAL8(sx)
      CALL POPREAL8(sy)
      CALL POPREAL8(sz)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, sfaceb, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(right(itu1))
        wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
&          rightb(itu1)
        rightb(itu1) = 0.0
      END IF
      CALL POPREAL8(right(irhoe))
      padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + rightb(irhoe)
      rightb(irhoe) = 0.0
      CALL POPREAL8(right(ivz))
      wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + rightb&
&        (ivz)
      rightb(ivz) = 0.0
      CALL POPREAL8(right(ivy))
      wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + rightb&
&        (ivy)
      rightb(ivy) = 0.0
      CALL POPREAL8(right(ivx))
      wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + rightb&
&        (ivx)
      rightb(ivx) = 0.0
      CALL POPREAL8(right(irho))
      wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + &
&        rightb(irho)
      rightb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(left(itu1))
        wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + leftb(&
&          itu1)
        leftb(itu1) = 0.0
      END IF
      CALL POPREAL8(left(irhoe))
      padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + leftb(irhoe)
      leftb(irhoe) = 0.0
      CALL POPREAL8(left(ivz))
      wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + leftb(ivz)
      leftb(ivz) = 0.0
      CALL POPREAL8(left(ivy))
      wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + leftb(ivy)
      leftb(ivy) = 0.0
      CALL POPREAL8(left(ivx))
      wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + leftb(ivx)
      leftb(ivx) = 0.0
      CALL POPREAL8(left(irho))
      wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + leftb(&
&        irho)
      leftb(irho) = 0.0
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(sface)
        sfaceiadjb(ii, 0, 0, sps) = sfaceiadjb(ii, 0, 0, sps) + sfaceb
        sfaceb = 0.0
      END IF
      CALL POPINTEGER4(por)
      siadjb(ii, 0, 0, 3, sps) = siadjb(ii, 0, 0, 3, sps) + szb
      siadjb(ii, 0, 0, 2, sps) = siadjb(ii, 0, 0, 2, sps) + syb
      siadjb(ii, 0, 0, 1, sps) = siadjb(ii, 0, 0, 1, sps) + sxb
    END DO
  ELSE
!      ==================================================================
!PRINT *,'limiter',limiter
!      ==================================================================
!
!        ****************************************************************
!        *                                                              *
!        * Second order reconstruction of the left and right state.     *
!        * The three differences used in the, possibly nonlinear,       *
!        * interpolation are constructed here; the actual left and      *
!        * right states, or at least the differences from the first     *
!        * order interpolation, are computed in the subroutine          *
!        * leftRightState.                                              *
!        *                                                              *
!        ****************************************************************
!
! Fluxes in the i-direction.
    i = icell - 1
    j = jcell
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO ii=-1,0
      CALL PUSHREAL8(du1(irho))
! Store the three differences used in the interpolation
! in du1, du2, du3.
      du1(irho) = wadj(ii, 0, 0, irho, sps) - wadj(ii-1, 0, 0, irho, sps&
&        )
      CALL PUSHREAL8(du2(irho))
      du2(irho) = wadj(ii+1, 0, 0, irho, sps) - wadj(ii, 0, 0, irho, sps&
&        )
      CALL PUSHREAL8(du3(irho))
      du3(irho) = wadj(ii+2, 0, 0, irho, sps) - wadj(ii+1, 0, 0, irho, &
&        sps)
      CALL PUSHREAL8(du1(ivx))
      du1(ivx) = wadj(ii, 0, 0, ivx, sps) - wadj(ii-1, 0, 0, ivx, sps)
      CALL PUSHREAL8(du2(ivx))
      du2(ivx) = wadj(ii+1, 0, 0, ivx, sps) - wadj(ii, 0, 0, ivx, sps)
      CALL PUSHREAL8(du3(ivx))
      du3(ivx) = wadj(ii+2, 0, 0, ivx, sps) - wadj(ii+1, 0, 0, ivx, sps)
      CALL PUSHREAL8(du1(ivy))
      du1(ivy) = wadj(ii, 0, 0, ivy, sps) - wadj(ii-1, 0, 0, ivy, sps)
      CALL PUSHREAL8(du2(ivy))
      du2(ivy) = wadj(ii+1, 0, 0, ivy, sps) - wadj(ii, 0, 0, ivy, sps)
      CALL PUSHREAL8(du3(ivy))
      du3(ivy) = wadj(ii+2, 0, 0, ivy, sps) - wadj(ii+1, 0, 0, ivy, sps)
      CALL PUSHREAL8(du1(ivz))
      du1(ivz) = wadj(ii, 0, 0, ivz, sps) - wadj(ii-1, 0, 0, ivz, sps)
      CALL PUSHREAL8(du2(ivz))
      du2(ivz) = wadj(ii+1, 0, 0, ivz, sps) - wadj(ii, 0, 0, ivz, sps)
      CALL PUSHREAL8(du3(ivz))
      du3(ivz) = wadj(ii+2, 0, 0, ivz, sps) - wadj(ii+1, 0, 0, ivz, sps)
      CALL PUSHREAL8(du1(irhoe))
      du1(irhoe) = padj(ii, 0, 0, sps) - padj(ii-1, 0, 0, sps)
      CALL PUSHREAL8(du2(irhoe))
      du2(irhoe) = padj(ii+1, 0, 0, sps) - padj(ii, 0, 0, sps)
      CALL PUSHREAL8(du3(irhoe))
      du3(irhoe) = padj(ii+2, 0, 0, sps) - padj(ii+1, 0, 0, sps)
!!$           print *,'pAdj',p(i,  j,k) - p(i-1,j,k),pAdj(ii,  0,0) - pAdj(ii-1,0,0),p(i,  j,k),p(i-1,j,k),pAdj(ii,  0,0), pAdj(i
!i-1,0,0),p(i,  j,k) -pAdj(ii,  0,0),p(i,  j,k) - p(i-1,j,k)-(pAdj(ii,  0,0) - pAdj(ii-1,0,0))
      IF (correctfork) THEN
        CALL PUSHREAL8(du1(itu1))
        du1(itu1) = wadj(ii, 0, 0, itu1, sps) - wadj(ii-1, 0, 0, itu1, &
&          sps)
        CALL PUSHREAL8(du2(itu1))
        du2(itu1) = wadj(ii+1, 0, 0, itu1, sps) - wadj(ii, 0, 0, itu1, &
&          sps)
        CALL PUSHREAL8(du3(itu1))
        du3(itu1) = wadj(ii+2, 0, 0, itu1, sps) - wadj(ii+1, 0, 0, itu1&
&          , sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8ARRAY(right, nw)
      CALL PUSHREAL8ARRAY(left, nw)
! Compute the differences from the first order scheme.
      CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
&                       , factminmod, firstorderk)
!print *,'leftrightadj',left,right,icell,jcell,kcell
! Add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
      left(irho) = left(irho) + wadj(ii, 0, 0, irho, sps)
!print *,'left',left(irho),wAdj(ii,0,0,irho)
      left(ivx) = left(ivx) + wadj(ii, 0, 0, ivx, sps)
      left(ivy) = left(ivy) + wadj(ii, 0, 0, ivy, sps)
      left(ivz) = left(ivz) + wadj(ii, 0, 0, ivz, sps)
      left(irhoe) = left(irhoe) + padj(ii, 0, 0, sps)
      right(irho) = right(irho) + wadj(ii+1, 0, 0, irho, sps)
      right(ivx) = right(ivx) + wadj(ii+1, 0, 0, ivx, sps)
      right(ivy) = right(ivy) + wadj(ii+1, 0, 0, ivy, sps)
      right(ivz) = right(ivz) + wadj(ii+1, 0, 0, ivz, sps)
      right(irhoe) = right(irhoe) + padj(ii+1, 0, 0, sps)
      IF (correctfork) THEN
        left(itu1) = left(itu1) + wadj(ii, 0, 0, itu1, sps)
        right(itu1) = right(itu1) + wadj(ii+1, 0, 0, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = siadj(ii, 0, 0, 1, sps)
      sy = siadj(ii, 0, 0, 2, sps)
      sz = siadj(ii, 0, 0, 3, sps)
      CALL PUSHINTEGER4(por)
      por = pori(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfaceiadj(ii, 0, 0, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
      CALL PUSHREAL8(sz)
      CALL PUSHREAL8(sy)
      CALL PUSHREAL8(sx)
!print *,'gammaface',gammaface,gammaface2
! Compute the dissipative flux across the interface
! and them to dwAdj.
!           print *,'leftrightadj',left,right
!stop
!           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
!          print *,'riemanninputI',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
      CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
&                    , sx, sy, sz, sface, finegrid)
!         print *,'fluxadjI',flux,icell,jcell,kcell
! Update i and set fact to 1 for the second face.
      i = i + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in the j-direction.
    i = icell
    j = jcell - 1
    k = kcell
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO jj=-1,0
      CALL PUSHREAL8(du1(irho))
! Store the three differences used in the interpolation
! in du1, du2, du3.
      du1(irho) = wadj(0, jj, 0, irho, sps) - wadj(0, jj-1, 0, irho, sps&
&        )
      CALL PUSHREAL8(du2(irho))
      du2(irho) = wadj(0, jj+1, 0, irho, sps) - wadj(0, jj, 0, irho, sps&
&        )
      CALL PUSHREAL8(du3(irho))
      du3(irho) = wadj(0, jj+2, 0, irho, sps) - wadj(0, jj+1, 0, irho, &
&        sps)
      CALL PUSHREAL8(du1(ivx))
      du1(ivx) = wadj(0, jj, 0, ivx, sps) - wadj(0, jj-1, 0, ivx, sps)
      CALL PUSHREAL8(du2(ivx))
      du2(ivx) = wadj(0, jj+1, 0, ivx, sps) - wadj(0, jj, 0, ivx, sps)
      CALL PUSHREAL8(du3(ivx))
      du3(ivx) = wadj(0, jj+2, 0, ivx, sps) - wadj(0, jj+1, 0, ivx, sps)
      CALL PUSHREAL8(du1(ivy))
      du1(ivy) = wadj(0, jj, 0, ivy, sps) - wadj(0, jj-1, 0, ivy, sps)
      CALL PUSHREAL8(du2(ivy))
      du2(ivy) = wadj(0, jj+1, 0, ivy, sps) - wadj(0, jj, 0, ivy, sps)
      CALL PUSHREAL8(du3(ivy))
      du3(ivy) = wadj(0, jj+2, 0, ivy, sps) - wadj(0, jj+1, 0, ivy, sps)
      CALL PUSHREAL8(du1(ivz))
      du1(ivz) = wadj(0, jj, 0, ivz, sps) - wadj(0, jj-1, 0, ivz, sps)
      CALL PUSHREAL8(du2(ivz))
      du2(ivz) = wadj(0, jj+1, 0, ivz, sps) - wadj(0, jj, 0, ivz, sps)
      CALL PUSHREAL8(du3(ivz))
      du3(ivz) = wadj(0, jj+2, 0, ivz, sps) - wadj(0, jj+1, 0, ivz, sps)
      CALL PUSHREAL8(du1(irhoe))
      du1(irhoe) = padj(0, jj, 0, sps) - padj(0, jj-1, 0, sps)
      CALL PUSHREAL8(du2(irhoe))
      du2(irhoe) = padj(0, jj+1, 0, sps) - padj(0, jj, 0, sps)
      CALL PUSHREAL8(du3(irhoe))
      du3(irhoe) = padj(0, jj+2, 0, sps) - padj(0, jj+1, 0, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(du1(itu1))
        du1(itu1) = wadj(0, jj, 0, itu1, sps) - wadj(0, jj-1, 0, itu1, &
&          sps)
        CALL PUSHREAL8(du2(itu1))
        du2(itu1) = wadj(0, jj+1, 0, itu1, sps) - wadj(0, jj, 0, itu1, &
&          sps)
        CALL PUSHREAL8(du3(itu1))
        du3(itu1) = wadj(0, jj+2, 0, itu1, sps) - wadj(0, jj+1, 0, itu1&
&          , sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8ARRAY(right, nw)
      CALL PUSHREAL8ARRAY(left, nw)
! Compute the differences from the first order scheme.
      CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
&                       , factminmod, firstorderk)
! Add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
      left(irho) = left(irho) + wadj(0, jj, 0, irho, sps)
      left(ivx) = left(ivx) + wadj(0, jj, 0, ivx, sps)
      left(ivy) = left(ivy) + wadj(0, jj, 0, ivy, sps)
      left(ivz) = left(ivz) + wadj(0, jj, 0, ivz, sps)
      left(irhoe) = left(irhoe) + padj(0, jj, 0, sps)
      right(irho) = right(irho) + wadj(0, jj+1, 0, irho, sps)
      right(ivx) = right(ivx) + wadj(0, jj+1, 0, ivx, sps)
      right(ivy) = right(ivy) + wadj(0, jj+1, 0, ivy, sps)
      right(ivz) = right(ivz) + wadj(0, jj+1, 0, ivz, sps)
      right(irhoe) = right(irhoe) + padj(0, jj+1, 0, sps)
      IF (correctfork) THEN
        left(itu1) = left(itu1) + wadj(0, jj, 0, itu1, sps)
        right(itu1) = right(itu1) + wadj(0, jj+1, 0, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = sjadj(0, jj, 0, 1, sps)
      sy = sjadj(0, jj, 0, 2, sps)
      sz = sjadj(0, jj, 0, 3, sps)
      CALL PUSHINTEGER4(por)
      por = porj(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacejadj(0, jj, 0, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
      CALL PUSHREAL8(sz)
      CALL PUSHREAL8(sy)
      CALL PUSHREAL8(sx)
! Compute the dissipative flux across the interface
! and them to dwAdj.
!call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
      CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
&                    , sx, sy, sz, sface, finegrid)
! Update j and set fact to 1 for the second face.
      j = j + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
! Fluxes in the k-direction.
    i = icell
    j = jcell
    k = kcell - 1
    fact = -one
! Loop over the two faces which contribute to the residual of
! the cell considered.
    DO kk=-1,0
      CALL PUSHREAL8(du1(irho))
! Store the three differences used in the interpolation
! in du1, du2, du3.
      du1(irho) = wadj(0, 0, kk, irho, sps) - wadj(0, 0, kk-1, irho, sps&
&        )
      CALL PUSHREAL8(du2(irho))
      du2(irho) = wadj(0, 0, kk+1, irho, sps) - wadj(0, 0, kk, irho, sps&
&        )
      CALL PUSHREAL8(du3(irho))
      du3(irho) = wadj(0, 0, kk+2, irho, sps) - wadj(0, 0, kk+1, irho, &
&        sps)
      CALL PUSHREAL8(du1(ivx))
      du1(ivx) = wadj(0, 0, kk, ivx, sps) - wadj(0, 0, kk-1, ivx, sps)
      CALL PUSHREAL8(du2(ivx))
      du2(ivx) = wadj(0, 0, kk+1, ivx, sps) - wadj(0, 0, kk, ivx, sps)
      CALL PUSHREAL8(du3(ivx))
      du3(ivx) = wadj(0, 0, kk+2, ivx, sps) - wadj(0, 0, kk+1, ivx, sps)
      CALL PUSHREAL8(du1(ivy))
      du1(ivy) = wadj(0, 0, kk, ivy, sps) - wadj(0, 0, kk-1, ivy, sps)
      CALL PUSHREAL8(du2(ivy))
      du2(ivy) = wadj(0, 0, kk+1, ivy, sps) - wadj(0, 0, kk, ivy, sps)
      CALL PUSHREAL8(du3(ivy))
      du3(ivy) = wadj(0, 0, kk+2, ivy, sps) - wadj(0, 0, kk+1, ivy, sps)
      CALL PUSHREAL8(du1(ivz))
      du1(ivz) = wadj(0, 0, kk, ivz, sps) - wadj(0, 0, kk-1, ivz, sps)
      CALL PUSHREAL8(du2(ivz))
      du2(ivz) = wadj(0, 0, kk+1, ivz, sps) - wadj(0, 0, kk, ivz, sps)
      CALL PUSHREAL8(du3(ivz))
      du3(ivz) = wadj(0, 0, kk+2, ivz, sps) - wadj(0, 0, kk+1, ivz, sps)
      CALL PUSHREAL8(du1(irhoe))
      du1(irhoe) = padj(0, 0, kk, sps) - padj(0, 0, kk-1, sps)
      CALL PUSHREAL8(du2(irhoe))
      du2(irhoe) = padj(0, 0, kk+1, sps) - padj(0, 0, kk, sps)
      CALL PUSHREAL8(du3(irhoe))
      du3(irhoe) = padj(0, 0, kk+2, sps) - padj(0, 0, kk+1, sps)
      IF (correctfork) THEN
        CALL PUSHREAL8(du1(itu1))
        du1(itu1) = wadj(0, 0, kk, itu1, sps) - wadj(0, 0, kk-1, itu1, &
&          sps)
        CALL PUSHREAL8(du2(itu1))
        du2(itu1) = wadj(0, 0, kk+1, itu1, sps) - wadj(0, 0, kk, itu1, &
&          sps)
        CALL PUSHREAL8(du3(itu1))
        du3(itu1) = wadj(0, 0, kk+2, itu1, sps) - wadj(0, 0, kk+1, itu1&
&          , sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8ARRAY(right, nw)
      CALL PUSHREAL8ARRAY(left, nw)
! Compute the differences from the first order scheme.
      CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
&                       , factminmod, firstorderk)
! Add the first order part to the currently stored
! differences, such that the correct state vector
! is stored.
      left(irho) = left(irho) + wadj(0, 0, kk, irho, sps)
      left(ivx) = left(ivx) + wadj(0, 0, kk, ivx, sps)
      left(ivy) = left(ivy) + wadj(0, 0, kk, ivy, sps)
      left(ivz) = left(ivz) + wadj(0, 0, kk, ivz, sps)
      left(irhoe) = left(irhoe) + padj(0, 0, kk, sps)
      right(irho) = right(irho) + wadj(0, 0, kk+1, irho, sps)
      right(ivx) = right(ivx) + wadj(0, 0, kk+1, ivx, sps)
      right(ivy) = right(ivy) + wadj(0, 0, kk+1, ivy, sps)
      right(ivz) = right(ivz) + wadj(0, 0, kk+1, ivz, sps)
      right(irhoe) = right(irhoe) + padj(0, 0, kk+1, sps)
      IF (correctfork) THEN
        left(itu1) = left(itu1) + wadj(0, 0, kk, itu1, sps)
        right(itu1) = right(itu1) + wadj(0, 0, kk+1, itu1, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
! Store the normal vector, the porosity and the
! mesh velocity if present.
      sx = skadj(0, 0, kk, 1, sps)
      sy = skadj(0, 0, kk, 2, sps)
      sz = skadj(0, 0, kk, 3, sps)
      CALL PUSHINTEGER4(por)
      por = pork(i, j, k)
      IF (addgridvelocities) THEN
        CALL PUSHREAL8(sface)
        sface = sfacekadj(0, 0, kk, sps)
        CALL PUSHINTEGER4(1)
      ELSE
        CALL PUSHINTEGER4(0)
      END IF
      CALL PUSHREAL8(gammaface)
! Compute the value of gamma on the face.
! Constant gamma for now.
      gammaface = gammaconstant
      CALL PUSHREAL8(sz)
      CALL PUSHREAL8(sy)
      CALL PUSHREAL8(sx)
! Compute the dissipative flux across the interface
! and them to dwAdj.
!           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
!           print *,'riemanninputk',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
      CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
&                    , sx, sy, sz, sface, finegrid)
!print *,'dwupwind',dwadj,'fact',fact,'flux',flux
! Update k and set fact to 1 for the second face.
      k = k + 1
      CALL PUSHREAL8(fact)
      fact = one
    END DO
    padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
    sfacekadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    skadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
    fluxb(1:nwf) = 0.0
    leftb(1:nw) = 0.0
    rightb(1:nw) = 0.0
    du1b(1:nw) = 0.0
    du2b(1:nw) = 0.0
    du3b(1:nw) = 0.0
    sfaceb = 0.0
    DO kk=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
      CALL POPREAL8(sx)
      CALL POPREAL8(sy)
      CALL POPREAL8(sz)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, sfaceb, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(sface)
        sfacekadjb(0, 0, kk, sps) = sfacekadjb(0, 0, kk, sps) + sfaceb
        sfaceb = 0.0
      END IF
      CALL POPINTEGER4(por)
      skadjb(0, 0, kk, 3, sps) = skadjb(0, 0, kk, 3, sps) + szb
      skadjb(0, 0, kk, 2, sps) = skadjb(0, 0, kk, 2, sps) + syb
      skadjb(0, 0, kk, 1, sps) = skadjb(0, 0, kk, 1, sps) + sxb
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
&          rightb(itu1)
        wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + leftb(&
&          itu1)
      END IF
      padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + rightb(irhoe)
      wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + rightb&
&        (ivz)
      wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + rightb&
&        (ivy)
      wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + rightb&
&        (ivx)
      wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + &
&        rightb(irho)
      padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + leftb(irhoe)
      wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + leftb(ivz)
      wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + leftb(ivy)
      wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + leftb(ivx)
      wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + leftb(&
&        irho)
      CALL POPREAL8ARRAY(left, nw)
      CALL POPREAL8ARRAY(right, nw)
      CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
&                         leftb, right, rightb, nwint, omk, opk, &
&                         factminmod, firstorderk)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(du3(itu1))
        wadjb(0, 0, kk+2, itu1, sps) = wadjb(0, 0, kk+2, itu1, sps) + &
&          du3b(itu1)
        wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
&          du2b(itu1) - du3b(itu1)
        du3b(itu1) = 0.0
        CALL POPREAL8(du2(itu1))
        wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + du1b(&
&          itu1) - du2b(itu1)
        du2b(itu1) = 0.0
        CALL POPREAL8(du1(itu1))
        wadjb(0, 0, kk-1, itu1, sps) = wadjb(0, 0, kk-1, itu1, sps) - &
&          du1b(itu1)
        du1b(itu1) = 0.0
      END IF
      CALL POPREAL8(du3(irhoe))
      padjb(0, 0, kk+2, sps) = padjb(0, 0, kk+2, sps) + du3b(irhoe)
      padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + du2b(irhoe) - &
&        du3b(irhoe)
      du3b(irhoe) = 0.0
      CALL POPREAL8(du2(irhoe))
      padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + du1b(irhoe) - du2b(&
&        irhoe)
      du2b(irhoe) = 0.0
      CALL POPREAL8(du1(irhoe))
      padjb(0, 0, kk-1, sps) = padjb(0, 0, kk-1, sps) - du1b(irhoe)
      du1b(irhoe) = 0.0
      CALL POPREAL8(du3(ivz))
      wadjb(0, 0, kk+2, ivz, sps) = wadjb(0, 0, kk+2, ivz, sps) + du3b(&
&        ivz)
      wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + du2b(&
&        ivz) - du3b(ivz)
      du3b(ivz) = 0.0
      CALL POPREAL8(du2(ivz))
      wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + du1b(ivz) &
&        - du2b(ivz)
      du2b(ivz) = 0.0
      CALL POPREAL8(du1(ivz))
      wadjb(0, 0, kk-1, ivz, sps) = wadjb(0, 0, kk-1, ivz, sps) - du1b(&
&        ivz)
      du1b(ivz) = 0.0
      CALL POPREAL8(du3(ivy))
      wadjb(0, 0, kk+2, ivy, sps) = wadjb(0, 0, kk+2, ivy, sps) + du3b(&
&        ivy)
      wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + du2b(&
&        ivy) - du3b(ivy)
      du3b(ivy) = 0.0
      CALL POPREAL8(du2(ivy))
      wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + du1b(ivy) &
&        - du2b(ivy)
      du2b(ivy) = 0.0
      CALL POPREAL8(du1(ivy))
      wadjb(0, 0, kk-1, ivy, sps) = wadjb(0, 0, kk-1, ivy, sps) - du1b(&
&        ivy)
      du1b(ivy) = 0.0
      CALL POPREAL8(du3(ivx))
      wadjb(0, 0, kk+2, ivx, sps) = wadjb(0, 0, kk+2, ivx, sps) + du3b(&
&        ivx)
      wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + du2b(&
&        ivx) - du3b(ivx)
      du3b(ivx) = 0.0
      CALL POPREAL8(du2(ivx))
      wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + du1b(ivx) &
&        - du2b(ivx)
      du2b(ivx) = 0.0
      CALL POPREAL8(du1(ivx))
      wadjb(0, 0, kk-1, ivx, sps) = wadjb(0, 0, kk-1, ivx, sps) - du1b(&
&        ivx)
      du1b(ivx) = 0.0
      CALL POPREAL8(du3(irho))
      wadjb(0, 0, kk+2, irho, sps) = wadjb(0, 0, kk+2, irho, sps) + du3b&
&        (irho)
      wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + du2b&
&        (irho) - du3b(irho)
      du3b(irho) = 0.0
      CALL POPREAL8(du2(irho))
      wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + du1b(&
&        irho) - du2b(irho)
      du2b(irho) = 0.0
      CALL POPREAL8(du1(irho))
      wadjb(0, 0, kk-1, irho, sps) = wadjb(0, 0, kk-1, irho, sps) - du1b&
&        (irho)
      du1b(irho) = 0.0
    END DO
    sfacejadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    sjadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
    DO jj=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
      CALL POPREAL8(sx)
      CALL POPREAL8(sy)
      CALL POPREAL8(sz)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, sfaceb, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(sface)
        sfacejadjb(0, jj, 0, sps) = sfacejadjb(0, jj, 0, sps) + sfaceb
        sfaceb = 0.0
      END IF
      CALL POPINTEGER4(por)
      sjadjb(0, jj, 0, 3, sps) = sjadjb(0, jj, 0, 3, sps) + szb
      sjadjb(0, jj, 0, 2, sps) = sjadjb(0, jj, 0, 2, sps) + syb
      sjadjb(0, jj, 0, 1, sps) = sjadjb(0, jj, 0, 1, sps) + sxb
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
&          rightb(itu1)
        wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + leftb(&
&          itu1)
      END IF
      padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + rightb(irhoe)
      wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + rightb&
&        (ivz)
      wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + rightb&
&        (ivy)
      wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + rightb&
&        (ivx)
      wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + &
&        rightb(irho)
      padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + leftb(irhoe)
      wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + leftb(ivz)
      wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + leftb(ivy)
      wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + leftb(ivx)
      wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + leftb(&
&        irho)
      CALL POPREAL8ARRAY(left, nw)
      CALL POPREAL8ARRAY(right, nw)
      CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
&                         leftb, right, rightb, nwint, omk, opk, &
&                         factminmod, firstorderk)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(du3(itu1))
        wadjb(0, jj+2, 0, itu1, sps) = wadjb(0, jj+2, 0, itu1, sps) + &
&          du3b(itu1)
        wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
&          du2b(itu1) - du3b(itu1)
        du3b(itu1) = 0.0
        CALL POPREAL8(du2(itu1))
        wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + du1b(&
&          itu1) - du2b(itu1)
        du2b(itu1) = 0.0
        CALL POPREAL8(du1(itu1))
        wadjb(0, jj-1, 0, itu1, sps) = wadjb(0, jj-1, 0, itu1, sps) - &
&          du1b(itu1)
        du1b(itu1) = 0.0
      END IF
      CALL POPREAL8(du3(irhoe))
      padjb(0, jj+2, 0, sps) = padjb(0, jj+2, 0, sps) + du3b(irhoe)
      padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + du2b(irhoe) - &
&        du3b(irhoe)
      du3b(irhoe) = 0.0
      CALL POPREAL8(du2(irhoe))
      padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + du1b(irhoe) - du2b(&
&        irhoe)
      du2b(irhoe) = 0.0
      CALL POPREAL8(du1(irhoe))
      padjb(0, jj-1, 0, sps) = padjb(0, jj-1, 0, sps) - du1b(irhoe)
      du1b(irhoe) = 0.0
      CALL POPREAL8(du3(ivz))
      wadjb(0, jj+2, 0, ivz, sps) = wadjb(0, jj+2, 0, ivz, sps) + du3b(&
&        ivz)
      wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + du2b(&
&        ivz) - du3b(ivz)
      du3b(ivz) = 0.0
      CALL POPREAL8(du2(ivz))
      wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + du1b(ivz) &
&        - du2b(ivz)
      du2b(ivz) = 0.0
      CALL POPREAL8(du1(ivz))
      wadjb(0, jj-1, 0, ivz, sps) = wadjb(0, jj-1, 0, ivz, sps) - du1b(&
&        ivz)
      du1b(ivz) = 0.0
      CALL POPREAL8(du3(ivy))
      wadjb(0, jj+2, 0, ivy, sps) = wadjb(0, jj+2, 0, ivy, sps) + du3b(&
&        ivy)
      wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + du2b(&
&        ivy) - du3b(ivy)
      du3b(ivy) = 0.0
      CALL POPREAL8(du2(ivy))
      wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + du1b(ivy) &
&        - du2b(ivy)
      du2b(ivy) = 0.0
      CALL POPREAL8(du1(ivy))
      wadjb(0, jj-1, 0, ivy, sps) = wadjb(0, jj-1, 0, ivy, sps) - du1b(&
&        ivy)
      du1b(ivy) = 0.0
      CALL POPREAL8(du3(ivx))
      wadjb(0, jj+2, 0, ivx, sps) = wadjb(0, jj+2, 0, ivx, sps) + du3b(&
&        ivx)
      wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + du2b(&
&        ivx) - du3b(ivx)
      du3b(ivx) = 0.0
      CALL POPREAL8(du2(ivx))
      wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + du1b(ivx) &
&        - du2b(ivx)
      du2b(ivx) = 0.0
      CALL POPREAL8(du1(ivx))
      wadjb(0, jj-1, 0, ivx, sps) = wadjb(0, jj-1, 0, ivx, sps) - du1b(&
&        ivx)
      du1b(ivx) = 0.0
      CALL POPREAL8(du3(irho))
      wadjb(0, jj+2, 0, irho, sps) = wadjb(0, jj+2, 0, irho, sps) + du3b&
&        (irho)
      wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + du2b&
&        (irho) - du3b(irho)
      du3b(irho) = 0.0
      CALL POPREAL8(du2(irho))
      wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + du1b(&
&        irho) - du2b(irho)
      du2b(irho) = 0.0
      CALL POPREAL8(du1(irho))
      wadjb(0, jj-1, 0, irho, sps) = wadjb(0, jj-1, 0, irho, sps) - du1b&
&        (irho)
      du1b(irho) = 0.0
    END DO
    sfaceiadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
    siadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
    DO ii=0,-1,-1
      CALL POPREAL8(fact)
      fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
      fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
      fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
      fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
      fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
      CALL POPREAL8(sx)
      CALL POPREAL8(sy)
      CALL POPREAL8(sz)
      CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
&                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
&                      szb, sface, sfaceb, finegrid)
      CALL POPREAL8(gammaface)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(sface)
        sfaceiadjb(ii, 0, 0, sps) = sfaceiadjb(ii, 0, 0, sps) + sfaceb
        sfaceb = 0.0
      END IF
      CALL POPINTEGER4(por)
      siadjb(ii, 0, 0, 3, sps) = siadjb(ii, 0, 0, 3, sps) + szb
      siadjb(ii, 0, 0, 2, sps) = siadjb(ii, 0, 0, 2, sps) + syb
      siadjb(ii, 0, 0, 1, sps) = siadjb(ii, 0, 0, 1, sps) + sxb
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
&          rightb(itu1)
        wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + leftb(&
&          itu1)
      END IF
      padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + rightb(irhoe)
      wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + rightb&
&        (ivz)
      wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + rightb&
&        (ivy)
      wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + rightb&
&        (ivx)
      wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + &
&        rightb(irho)
      padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + leftb(irhoe)
      wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + leftb(ivz)
      wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + leftb(ivy)
      wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + leftb(ivx)
      wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + leftb(&
&        irho)
      CALL POPREAL8ARRAY(left, nw)
      CALL POPREAL8ARRAY(right, nw)
      CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
&                         leftb, right, rightb, nwint, omk, opk, &
&                         factminmod, firstorderk)
      CALL POPINTEGER4(branch)
      IF (.NOT.branch .LT. 1) THEN
        CALL POPREAL8(du3(itu1))
        wadjb(ii+2, 0, 0, itu1, sps) = wadjb(ii+2, 0, 0, itu1, sps) + &
&          du3b(itu1)
        wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
&          du2b(itu1) - du3b(itu1)
        du3b(itu1) = 0.0
        CALL POPREAL8(du2(itu1))
        wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + du1b(&
&          itu1) - du2b(itu1)
        du2b(itu1) = 0.0
        CALL POPREAL8(du1(itu1))
        wadjb(ii-1, 0, 0, itu1, sps) = wadjb(ii-1, 0, 0, itu1, sps) - &
&          du1b(itu1)
        du1b(itu1) = 0.0
      END IF
      CALL POPREAL8(du3(irhoe))
      padjb(ii+2, 0, 0, sps) = padjb(ii+2, 0, 0, sps) + du3b(irhoe)
      padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + du2b(irhoe) - &
&        du3b(irhoe)
      du3b(irhoe) = 0.0
      CALL POPREAL8(du2(irhoe))
      padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + du1b(irhoe) - du2b(&
&        irhoe)
      du2b(irhoe) = 0.0
      CALL POPREAL8(du1(irhoe))
      padjb(ii-1, 0, 0, sps) = padjb(ii-1, 0, 0, sps) - du1b(irhoe)
      du1b(irhoe) = 0.0
      CALL POPREAL8(du3(ivz))
      wadjb(ii+2, 0, 0, ivz, sps) = wadjb(ii+2, 0, 0, ivz, sps) + du3b(&
&        ivz)
      wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + du2b(&
&        ivz) - du3b(ivz)
      du3b(ivz) = 0.0
      CALL POPREAL8(du2(ivz))
      wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + du1b(ivz) &
&        - du2b(ivz)
      du2b(ivz) = 0.0
      CALL POPREAL8(du1(ivz))
      wadjb(ii-1, 0, 0, ivz, sps) = wadjb(ii-1, 0, 0, ivz, sps) - du1b(&
&        ivz)
      du1b(ivz) = 0.0
      CALL POPREAL8(du3(ivy))
      wadjb(ii+2, 0, 0, ivy, sps) = wadjb(ii+2, 0, 0, ivy, sps) + du3b(&
&        ivy)
      wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + du2b(&
&        ivy) - du3b(ivy)
      du3b(ivy) = 0.0
      CALL POPREAL8(du2(ivy))
      wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + du1b(ivy) &
&        - du2b(ivy)
      du2b(ivy) = 0.0
      CALL POPREAL8(du1(ivy))
      wadjb(ii-1, 0, 0, ivy, sps) = wadjb(ii-1, 0, 0, ivy, sps) - du1b(&
&        ivy)
      du1b(ivy) = 0.0
      CALL POPREAL8(du3(ivx))
      wadjb(ii+2, 0, 0, ivx, sps) = wadjb(ii+2, 0, 0, ivx, sps) + du3b(&
&        ivx)
      wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + du2b(&
&        ivx) - du3b(ivx)
      du3b(ivx) = 0.0
      CALL POPREAL8(du2(ivx))
      wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + du1b(ivx) &
&        - du2b(ivx)
      du2b(ivx) = 0.0
      CALL POPREAL8(du1(ivx))
      wadjb(ii-1, 0, 0, ivx, sps) = wadjb(ii-1, 0, 0, ivx, sps) - du1b(&
&        ivx)
      du1b(ivx) = 0.0
      CALL POPREAL8(du3(irho))
      wadjb(ii+2, 0, 0, irho, sps) = wadjb(ii+2, 0, 0, irho, sps) + du3b&
&        (irho)
      wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + du2b&
&        (irho) - du3b(irho)
      du3b(irho) = 0.0
      CALL POPREAL8(du2(irho))
      wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + du1b(&
&        irho) - du2b(irho)
      du2b(irho) = 0.0
      CALL POPREAL8(du1(irho))
      wadjb(ii-1, 0, 0, irho, sps) = wadjb(ii-1, 0, 0, irho, sps) - du1b&
&        (irho)
      du1b(irho) = 0.0
    END DO
  END IF
  CALL POPINTEGER4(branch)
  CALL POPINTEGER4(branch)
  !gammaconstantb = 0.0
END SUBROUTINE INVISCIDUPWINDFLUXADJ_B

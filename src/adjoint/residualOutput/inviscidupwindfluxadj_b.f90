   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade - Version 2.2 (r1239) - Wed 28 Jun 2006 04:59:55 PM CEST
   !  
   !  Differentiation of inviscidupwindfluxadj in reverse (adjoint) mode:
   !   gradient, with respect to input variables: padj dwadj wadj
   !                sfacekadj skadj sfacejadj sjadj sfaceiadj siadj
   !                gammaconstant
   !   of linear combination of output variables: dwadj
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidUpwindFluxAdj.f90                       *
   !      * Author:        Edwin van der Weide                             *
   !      *                Seongim Choi,C.A.(Sandy)Mader                   *
   !      * Starting date: 03-20-2006                                      *
   !      * Last modified: 04-25-2008                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDUPWINDFLUXADJ_B(wadj, wadjb, padj, padjb, dwadj, &
   &  dwadjb, siadj, siadjb, sjadj, sjadjb, skadj, skadjb, sfaceiadj, &
   &  sfaceiadjb, sfacejadj, sfacejadjb, sfacekadj, sfacekadjb, icell, &
   &  jcell, kcell, finegrid, nn, level, sps)
   USE blockpointers
   USE flowvarrefstate
   USE inputdiscretization
   USE inputphysics
   USE inputtimespectral
   IMPLICIT NONE
   REAL(KIND=REALTYPE) :: dwadj(nw, ntimeintervalsspectral), dwadjb(nw, &
   &  ntimeintervalsspectral)
   LOGICAL :: finegrid
   INTEGER(KIND=INTTYPE) :: icell, jcell, kcell, level, nn, sps
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: padj
   REAL(KIND=REALTYPE) :: padjb(-2:2, -2:2, -2:2, ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfaceiadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfacejadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), INTENT(IN) :: sfacekadj
   REAL(KIND=REALTYPE) :: sfaceiadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacejadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral), sfacekadjb(-2:2, -2:2, -2:2, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: siadj
   REAL(KIND=REALTYPE) :: siadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), sjadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), skadjb(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral)
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: sjadj
   REAL(KIND=REALTYPE), DIMENSION(-3:2, -3:2, -3:2, 3, &
   &  ntimeintervalsspectral), INTENT(IN) :: skadj
   REAL(KIND=REALTYPE), DIMENSION(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral), INTENT(IN) :: wadj
   REAL(KIND=REALTYPE) :: wadjb(-2:2, -2:2, -2:2, nw, &
   &  ntimeintervalsspectral)
   INTEGER :: branch
   LOGICAL :: correctfork, firstorderk
   REAL(KIND=REALTYPE) :: du1(nw), du1b(nw), du2(nw), du2b(nw), du3(nw), &
   &  du3b(nw)
   REAL(KIND=REALTYPE) :: flux(nwf), fluxb(nwf)
   INTEGER(KIND=INTTYPE) :: i, ii, j, jj, k, kk
   REAL(KIND=REALTYPE) :: left(nw), leftb(nw), right(nw), rightb(nw)
   REAL(KIND=REALTYPE) :: max1
   INTEGER(KIND=INTTYPE) :: nwint
   INTEGER(KIND=PORTYPE) :: por
   REAL(KIND=REALTYPE) :: fact, factminmod, sface, sfaceb
   REAL(KIND=REALTYPE) :: gammaface, gammaface2, omk, opk, sx, sxb, sy, &
   &  syb, sz, szb
   INTRINSIC MAX
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidUpwindFluxAdj computes the artificial dissipation part *
   !      * the Euler fluxes by means of an approximate solution of the 1D *
   !      * Riemann problem on the face. The fluxes are computed for the   *
   !      * given cell of the block to which the variables in              *
   !      * blockPointers currently point to.                              *
   !      *                                                                *
   !      ******************************************************************
   !
   ! sI,sJ,sK
   ! limiter, firstOrder
   !nTimeIntervalsSpectral
   !
   !      Subroutine arguments.
   !
   !
   !      Local variables.
   !
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   correctfork = kpresent
   IF (1.e-10_realType .LT. one - kappacoef) THEN
   max1 = one - kappacoef
   CALL PUSHINTEGER4(1)
   ELSE
   max1 = 1.e-10_realType
   CALL PUSHINTEGER4(0)
   END IF
   ! Compute the factor used in the minmod limiter.
   factminmod = (three-kappacoef)/max1
   ! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
   omk = fourth*(one-kappacoef)
   opk = fourth*(one+kappacoef)
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set the number of variables to be interpolated depending
   ! whether or not a k-equation is present. If a k-equation is
   ! present also set the logical firstOrderK. This indicates
   ! whether or not only a first order approximation is to be used
   ! for the turbulent kinetic energy.
   IF (correctfork) THEN
   IF (orderturb .EQ. firstorder) THEN
   nwint = nwf
   firstorderk = .true.
   CALL PUSHINTEGER4(1)
   ELSE
   nwint = itu1
   firstorderk = .false.
   CALL PUSHINTEGER4(2)
   END IF
   ELSE
   nwint = nwf
   firstorderk = .false.
   CALL PUSHINTEGER4(0)
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Flux computation. A distinction is made between first and      *
   !      * second order schemes to avoid the overhead for the first order *
   !      * scheme.                                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   IF (limiter .EQ. firstorder) THEN
   !
   !        ****************************************************************
   !        *                                                              *
   !        * First order reconstruction. The states in the cells are      *
   !        * constant. The left and right states are constructed easily.  *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   i = icell - 1
   j = jcell
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO ii=-1,0
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = siadj(ii, 0, 0, 1, sps)
   sy = siadj(ii, 0, 0, 2, sps)
   sz = siadj(ii, 0, 0, 3, sps)
   CALL PUSHINTEGER4(por)
   por = pori(i, j, k)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfaceiadj(ii, 0, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(left(irho))
   ! Determine the left and right state.
   left(irho) = wadj(ii, 0, 0, irho, sps)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = wadj(ii, 0, 0, ivx, sps)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = wadj(ii, 0, 0, ivy, sps)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = wadj(ii, 0, 0, ivz, sps)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = padj(ii, 0, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = wadj(ii, 0, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = wadj(ii+1, 0, 0, irho, sps)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = wadj(ii+1, 0, 0, ivx, sps)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = wadj(ii+1, 0, 0, ivy, sps)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = wadj(ii+1, 0, 0, ivz, sps)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = padj(ii+1, 0, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = wadj(ii+1, 0, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(gammaface)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   CALL PUSHREAL8(sz)
   CALL PUSHREAL8(sy)
   CALL PUSHREAL8(sx)
   !print *,'gammaface',gammaface,gammaface2
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left,right,flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
   &                    , sx, sy, sz, sface, finegrid)
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   CALL PUSHREAL8(fact)
   fact = one
   END DO
   ! Fluxes in j-direction.
   i = icell
   j = jcell - 1
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = sjadj(0, jj, 0, 1, sps)
   sy = sjadj(0, jj, 0, 2, sps)
   sz = sjadj(0, jj, 0, 3, sps)
   CALL PUSHINTEGER4(por)
   por = porj(i, j, k)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacejadj(0, jj, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(left(irho))
   ! Determine the left and right state.
   left(irho) = wadj(0, jj, 0, irho, sps)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = wadj(0, jj, 0, ivx, sps)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = wadj(0, jj, 0, ivy, sps)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = wadj(0, jj, 0, ivz, sps)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = padj(0, jj, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = wadj(0, jj, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = wadj(0, jj+1, 0, irho, sps)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = wadj(0, jj+1, 0, ivx, sps)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = wadj(0, jj+1, 0, ivy, sps)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = wadj(0, jj+1, 0, ivz, sps)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = wadj(0, jj+1, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(gammaface)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   CALL PUSHREAL8(sz)
   CALL PUSHREAL8(sy)
   CALL PUSHREAL8(sx)
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
   &                    , sx, sy, sz, sface, finegrid)
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   CALL PUSHREAL8(fact)
   fact = one
   END DO
   ! Fluxes in k-direction.
   i = icell
   j = jcell
   k = kcell - 1
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = skadj(0, 0, kk, 1, sps)
   sy = skadj(0, 0, kk, 2, sps)
   sz = skadj(0, 0, kk, 3, sps)
   CALL PUSHINTEGER4(por)
   por = pork(i, j, k)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacekadj(0, 0, kk, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(left(irho))
   ! Determine the left and right state.
   left(irho) = wadj(0, 0, kk, irho, sps)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = wadj(0, 0, kk, ivx, sps)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = wadj(0, 0, kk, ivy, sps)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = wadj(0, 0, kk, ivz, sps)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = padj(0, 0, kk, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = wadj(0, 0, kk, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = wadj(0, 0, kk+1, irho, sps)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = wadj(0, 0, kk+1, ivx, sps)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = wadj(0, 0, kk+1, ivy, sps)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = wadj(0, 0, kk+1, ivz, sps)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = wadj(0, 0, kk+1, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(gammaface)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   CALL PUSHREAL8(sz)
   CALL PUSHREAL8(sy)
   CALL PUSHREAL8(sx)
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
   &                    , sx, sy, sz, sface, finegrid)
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   CALL PUSHREAL8(fact)
   fact = one
   END DO
   padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
   sfacekadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   skadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
   fluxb(1:nwf) = 0.0
   leftb(1:nw) = 0.0
   rightb(1:nw) = 0.0
   sfaceb = 0.0
   DO kk=0,-1,-1
   CALL POPREAL8(fact)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   CALL POPREAL8(sx)
   CALL POPREAL8(sy)
   CALL POPREAL8(sz)
   CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
   &                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
   &                      szb, sface, sfaceb, finegrid)
   CALL POPREAL8(gammaface)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(right(itu1))
   wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
   &          rightb(itu1)
   rightb(itu1) = 0.0
   END IF
   CALL POPREAL8(right(irhoe))
   padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + rightb(irhoe)
   rightb(irhoe) = 0.0
   CALL POPREAL8(right(ivz))
   wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + rightb&
   &        (ivz)
   rightb(ivz) = 0.0
   CALL POPREAL8(right(ivy))
   wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + rightb&
   &        (ivy)
   rightb(ivy) = 0.0
   CALL POPREAL8(right(ivx))
   wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + rightb&
   &        (ivx)
   rightb(ivx) = 0.0
   CALL POPREAL8(right(irho))
   wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + &
   &        rightb(irho)
   rightb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(left(itu1))
   wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + leftb(&
   &          itu1)
   leftb(itu1) = 0.0
   END IF
   CALL POPREAL8(left(irhoe))
   padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + leftb(irhoe)
   leftb(irhoe) = 0.0
   CALL POPREAL8(left(ivz))
   wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + leftb(ivz)
   leftb(ivz) = 0.0
   CALL POPREAL8(left(ivy))
   wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + leftb(ivy)
   leftb(ivy) = 0.0
   CALL POPREAL8(left(ivx))
   wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + leftb(ivx)
   leftb(ivx) = 0.0
   CALL POPREAL8(left(irho))
   wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + leftb(&
   &        irho)
   leftb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(sface)
   sfacekadjb(0, 0, kk, sps) = sfacekadjb(0, 0, kk, sps) + sfaceb
   sfaceb = 0.0
   END IF
   CALL POPINTEGER4(por)
   skadjb(0, 0, kk, 3, sps) = skadjb(0, 0, kk, 3, sps) + szb
   skadjb(0, 0, kk, 2, sps) = skadjb(0, 0, kk, 2, sps) + syb
   skadjb(0, 0, kk, 1, sps) = skadjb(0, 0, kk, 1, sps) + sxb
   END DO
   sfacejadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   sjadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
   DO jj=0,-1,-1
   CALL POPREAL8(fact)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   CALL POPREAL8(sx)
   CALL POPREAL8(sy)
   CALL POPREAL8(sz)
   CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
   &                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
   &                      szb, sface, sfaceb, finegrid)
   CALL POPREAL8(gammaface)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(right(itu1))
   wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
   &          rightb(itu1)
   rightb(itu1) = 0.0
   END IF
   CALL POPREAL8(right(irhoe))
   padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + rightb(irhoe)
   rightb(irhoe) = 0.0
   CALL POPREAL8(right(ivz))
   wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + rightb&
   &        (ivz)
   rightb(ivz) = 0.0
   CALL POPREAL8(right(ivy))
   wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + rightb&
   &        (ivy)
   rightb(ivy) = 0.0
   CALL POPREAL8(right(ivx))
   wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + rightb&
   &        (ivx)
   rightb(ivx) = 0.0
   CALL POPREAL8(right(irho))
   wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + &
   &        rightb(irho)
   rightb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(left(itu1))
   wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + leftb(&
   &          itu1)
   leftb(itu1) = 0.0
   END IF
   CALL POPREAL8(left(irhoe))
   padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + leftb(irhoe)
   leftb(irhoe) = 0.0
   CALL POPREAL8(left(ivz))
   wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + leftb(ivz)
   leftb(ivz) = 0.0
   CALL POPREAL8(left(ivy))
   wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + leftb(ivy)
   leftb(ivy) = 0.0
   CALL POPREAL8(left(ivx))
   wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + leftb(ivx)
   leftb(ivx) = 0.0
   CALL POPREAL8(left(irho))
   wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + leftb(&
   &        irho)
   leftb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(sface)
   sfacejadjb(0, jj, 0, sps) = sfacejadjb(0, jj, 0, sps) + sfaceb
   sfaceb = 0.0
   END IF
   CALL POPINTEGER4(por)
   sjadjb(0, jj, 0, 3, sps) = sjadjb(0, jj, 0, 3, sps) + szb
   sjadjb(0, jj, 0, 2, sps) = sjadjb(0, jj, 0, 2, sps) + syb
   sjadjb(0, jj, 0, 1, sps) = sjadjb(0, jj, 0, 1, sps) + sxb
   END DO
   sfaceiadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   siadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
   DO ii=0,-1,-1
   CALL POPREAL8(fact)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   CALL POPREAL8(sx)
   CALL POPREAL8(sy)
   CALL POPREAL8(sz)
   CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
   &                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
   &                      szb, sface, sfaceb, finegrid)
   CALL POPREAL8(gammaface)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(right(itu1))
   wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
   &          rightb(itu1)
   rightb(itu1) = 0.0
   END IF
   CALL POPREAL8(right(irhoe))
   padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + rightb(irhoe)
   rightb(irhoe) = 0.0
   CALL POPREAL8(right(ivz))
   wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + rightb&
   &        (ivz)
   rightb(ivz) = 0.0
   CALL POPREAL8(right(ivy))
   wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + rightb&
   &        (ivy)
   rightb(ivy) = 0.0
   CALL POPREAL8(right(ivx))
   wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + rightb&
   &        (ivx)
   rightb(ivx) = 0.0
   CALL POPREAL8(right(irho))
   wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + &
   &        rightb(irho)
   rightb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(left(itu1))
   wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + leftb(&
   &          itu1)
   leftb(itu1) = 0.0
   END IF
   CALL POPREAL8(left(irhoe))
   padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + leftb(irhoe)
   leftb(irhoe) = 0.0
   CALL POPREAL8(left(ivz))
   wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + leftb(ivz)
   leftb(ivz) = 0.0
   CALL POPREAL8(left(ivy))
   wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + leftb(ivy)
   leftb(ivy) = 0.0
   CALL POPREAL8(left(ivx))
   wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + leftb(ivx)
   leftb(ivx) = 0.0
   CALL POPREAL8(left(irho))
   wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + leftb(&
   &        irho)
   leftb(irho) = 0.0
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(sface)
   sfaceiadjb(ii, 0, 0, sps) = sfaceiadjb(ii, 0, 0, sps) + sfaceb
   sfaceb = 0.0
   END IF
   CALL POPINTEGER4(por)
   siadjb(ii, 0, 0, 3, sps) = siadjb(ii, 0, 0, 3, sps) + szb
   siadjb(ii, 0, 0, 2, sps) = siadjb(ii, 0, 0, 2, sps) + syb
   siadjb(ii, 0, 0, 1, sps) = siadjb(ii, 0, 0, 1, sps) + sxb
   END DO
   ELSE
   !      ==================================================================
   !PRINT *,'limiter',limiter
   !      ==================================================================
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Second order reconstruction of the left and right state.     *
   !        * The three differences used in the, possibly nonlinear,       *
   !        * interpolation are constructed here; the actual left and      *
   !        * right states, or at least the differences from the first     *
   !        * order interpolation, are computed in the subroutine          *
   !        * leftRightState.                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   i = icell - 1
   j = jcell
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO ii=-1,0
   CALL PUSHREAL8(du1(irho))
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = wadj(ii, 0, 0, irho, sps) - wadj(ii-1, 0, 0, irho, sps&
   &        )
   CALL PUSHREAL8(du2(irho))
   du2(irho) = wadj(ii+1, 0, 0, irho, sps) - wadj(ii, 0, 0, irho, sps&
   &        )
   CALL PUSHREAL8(du3(irho))
   du3(irho) = wadj(ii+2, 0, 0, irho, sps) - wadj(ii+1, 0, 0, irho, &
   &        sps)
   CALL PUSHREAL8(du1(ivx))
   du1(ivx) = wadj(ii, 0, 0, ivx, sps) - wadj(ii-1, 0, 0, ivx, sps)
   CALL PUSHREAL8(du2(ivx))
   du2(ivx) = wadj(ii+1, 0, 0, ivx, sps) - wadj(ii, 0, 0, ivx, sps)
   CALL PUSHREAL8(du3(ivx))
   du3(ivx) = wadj(ii+2, 0, 0, ivx, sps) - wadj(ii+1, 0, 0, ivx, sps)
   CALL PUSHREAL8(du1(ivy))
   du1(ivy) = wadj(ii, 0, 0, ivy, sps) - wadj(ii-1, 0, 0, ivy, sps)
   CALL PUSHREAL8(du2(ivy))
   du2(ivy) = wadj(ii+1, 0, 0, ivy, sps) - wadj(ii, 0, 0, ivy, sps)
   CALL PUSHREAL8(du3(ivy))
   du3(ivy) = wadj(ii+2, 0, 0, ivy, sps) - wadj(ii+1, 0, 0, ivy, sps)
   CALL PUSHREAL8(du1(ivz))
   du1(ivz) = wadj(ii, 0, 0, ivz, sps) - wadj(ii-1, 0, 0, ivz, sps)
   CALL PUSHREAL8(du2(ivz))
   du2(ivz) = wadj(ii+1, 0, 0, ivz, sps) - wadj(ii, 0, 0, ivz, sps)
   CALL PUSHREAL8(du3(ivz))
   du3(ivz) = wadj(ii+2, 0, 0, ivz, sps) - wadj(ii+1, 0, 0, ivz, sps)
   CALL PUSHREAL8(du1(irhoe))
   du1(irhoe) = padj(ii, 0, 0, sps) - padj(ii-1, 0, 0, sps)
   CALL PUSHREAL8(du2(irhoe))
   du2(irhoe) = padj(ii+1, 0, 0, sps) - padj(ii, 0, 0, sps)
   CALL PUSHREAL8(du3(irhoe))
   du3(irhoe) = padj(ii+2, 0, 0, sps) - padj(ii+1, 0, 0, sps)
   !!$           print *,'pAdj',p(i,  j,k) - p(i-1,j,k),pAdj(ii,  0,0) - pAdj(ii-1,0,0),p(i,  j,k),p(i-1,j,k),pAdj(ii,  0,0), pAdj(i
   !i-1,0,0),p(i,  j,k) -pAdj(ii,  0,0),p(i,  j,k) - p(i-1,j,k)-(pAdj(ii,  0,0) - pAdj(ii-1,0,0))
   IF (correctfork) THEN
   CALL PUSHREAL8(du1(itu1))
   du1(itu1) = wadj(ii, 0, 0, itu1, sps) - wadj(ii-1, 0, 0, itu1, &
   &          sps)
   CALL PUSHREAL8(du2(itu1))
   du2(itu1) = wadj(ii+1, 0, 0, itu1, sps) - wadj(ii, 0, 0, itu1, &
   &          sps)
   CALL PUSHREAL8(du3(itu1))
   du3(itu1) = wadj(ii+2, 0, 0, itu1, sps) - wadj(ii+1, 0, 0, itu1&
   &          , sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
   &                       , factminmod, firstorderk)
   !print *,'leftrightadj',left,right,icell,jcell,kcell
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + wadj(ii, 0, 0, irho, sps)
   !print *,'left',left(irho),wAdj(ii,0,0,irho)
   left(ivx) = left(ivx) + wadj(ii, 0, 0, ivx, sps)
   left(ivy) = left(ivy) + wadj(ii, 0, 0, ivy, sps)
   left(ivz) = left(ivz) + wadj(ii, 0, 0, ivz, sps)
   left(irhoe) = left(irhoe) + padj(ii, 0, 0, sps)
   right(irho) = right(irho) + wadj(ii+1, 0, 0, irho, sps)
   right(ivx) = right(ivx) + wadj(ii+1, 0, 0, ivx, sps)
   right(ivy) = right(ivy) + wadj(ii+1, 0, 0, ivy, sps)
   right(ivz) = right(ivz) + wadj(ii+1, 0, 0, ivz, sps)
   right(irhoe) = right(irhoe) + padj(ii+1, 0, 0, sps)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + wadj(ii, 0, 0, itu1, sps)
   right(itu1) = right(itu1) + wadj(ii+1, 0, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = siadj(ii, 0, 0, 1, sps)
   sy = siadj(ii, 0, 0, 2, sps)
   sz = siadj(ii, 0, 0, 3, sps)
   CALL PUSHINTEGER4(por)
   por = pori(i, j, k)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfaceiadj(ii, 0, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(gammaface)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   CALL PUSHREAL8(sz)
   CALL PUSHREAL8(sy)
   CALL PUSHREAL8(sx)
   !print *,'gammaface',gammaface,gammaface2
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           print *,'leftrightadj',left,right
   !stop
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   !          print *,'riemanninputI',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
   CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
   &                    , sx, sy, sz, sface, finegrid)
   !         print *,'fluxadjI',flux,icell,jcell,kcell
   ! Update i and set fact to 1 for the second face.
   i = i + 1
   CALL PUSHREAL8(fact)
   fact = one
   END DO
   ! Fluxes in the j-direction.
   i = icell
   j = jcell - 1
   k = kcell
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO jj=-1,0
   CALL PUSHREAL8(du1(irho))
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = wadj(0, jj, 0, irho, sps) - wadj(0, jj-1, 0, irho, sps&
   &        )
   CALL PUSHREAL8(du2(irho))
   du2(irho) = wadj(0, jj+1, 0, irho, sps) - wadj(0, jj, 0, irho, sps&
   &        )
   CALL PUSHREAL8(du3(irho))
   du3(irho) = wadj(0, jj+2, 0, irho, sps) - wadj(0, jj+1, 0, irho, &
   &        sps)
   CALL PUSHREAL8(du1(ivx))
   du1(ivx) = wadj(0, jj, 0, ivx, sps) - wadj(0, jj-1, 0, ivx, sps)
   CALL PUSHREAL8(du2(ivx))
   du2(ivx) = wadj(0, jj+1, 0, ivx, sps) - wadj(0, jj, 0, ivx, sps)
   CALL PUSHREAL8(du3(ivx))
   du3(ivx) = wadj(0, jj+2, 0, ivx, sps) - wadj(0, jj+1, 0, ivx, sps)
   CALL PUSHREAL8(du1(ivy))
   du1(ivy) = wadj(0, jj, 0, ivy, sps) - wadj(0, jj-1, 0, ivy, sps)
   CALL PUSHREAL8(du2(ivy))
   du2(ivy) = wadj(0, jj+1, 0, ivy, sps) - wadj(0, jj, 0, ivy, sps)
   CALL PUSHREAL8(du3(ivy))
   du3(ivy) = wadj(0, jj+2, 0, ivy, sps) - wadj(0, jj+1, 0, ivy, sps)
   CALL PUSHREAL8(du1(ivz))
   du1(ivz) = wadj(0, jj, 0, ivz, sps) - wadj(0, jj-1, 0, ivz, sps)
   CALL PUSHREAL8(du2(ivz))
   du2(ivz) = wadj(0, jj+1, 0, ivz, sps) - wadj(0, jj, 0, ivz, sps)
   CALL PUSHREAL8(du3(ivz))
   du3(ivz) = wadj(0, jj+2, 0, ivz, sps) - wadj(0, jj+1, 0, ivz, sps)
   CALL PUSHREAL8(du1(irhoe))
   du1(irhoe) = padj(0, jj, 0, sps) - padj(0, jj-1, 0, sps)
   CALL PUSHREAL8(du2(irhoe))
   du2(irhoe) = padj(0, jj+1, 0, sps) - padj(0, jj, 0, sps)
   CALL PUSHREAL8(du3(irhoe))
   du3(irhoe) = padj(0, jj+2, 0, sps) - padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(du1(itu1))
   du1(itu1) = wadj(0, jj, 0, itu1, sps) - wadj(0, jj-1, 0, itu1, &
   &          sps)
   CALL PUSHREAL8(du2(itu1))
   du2(itu1) = wadj(0, jj+1, 0, itu1, sps) - wadj(0, jj, 0, itu1, &
   &          sps)
   CALL PUSHREAL8(du3(itu1))
   du3(itu1) = wadj(0, jj+2, 0, itu1, sps) - wadj(0, jj+1, 0, itu1&
   &          , sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
   &                       , factminmod, firstorderk)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + wadj(0, jj, 0, irho, sps)
   left(ivx) = left(ivx) + wadj(0, jj, 0, ivx, sps)
   left(ivy) = left(ivy) + wadj(0, jj, 0, ivy, sps)
   left(ivz) = left(ivz) + wadj(0, jj, 0, ivz, sps)
   left(irhoe) = left(irhoe) + padj(0, jj, 0, sps)
   right(irho) = right(irho) + wadj(0, jj+1, 0, irho, sps)
   right(ivx) = right(ivx) + wadj(0, jj+1, 0, ivx, sps)
   right(ivy) = right(ivy) + wadj(0, jj+1, 0, ivy, sps)
   right(ivz) = right(ivz) + wadj(0, jj+1, 0, ivz, sps)
   right(irhoe) = right(irhoe) + padj(0, jj+1, 0, sps)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + wadj(0, jj, 0, itu1, sps)
   right(itu1) = right(itu1) + wadj(0, jj+1, 0, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = sjadj(0, jj, 0, 1, sps)
   sy = sjadj(0, jj, 0, 2, sps)
   sz = sjadj(0, jj, 0, 3, sps)
   CALL PUSHINTEGER4(por)
   por = porj(i, j, k)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacejadj(0, jj, 0, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(gammaface)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   CALL PUSHREAL8(sz)
   CALL PUSHREAL8(sy)
   CALL PUSHREAL8(sx)
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
   &                    , sx, sy, sz, sface, finegrid)
   ! Update j and set fact to 1 for the second face.
   j = j + 1
   CALL PUSHREAL8(fact)
   fact = one
   END DO
   ! Fluxes in the k-direction.
   i = icell
   j = jcell
   k = kcell - 1
   fact = -one
   ! Loop over the two faces which contribute to the residual of
   ! the cell considered.
   DO kk=-1,0
   CALL PUSHREAL8(du1(irho))
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = wadj(0, 0, kk, irho, sps) - wadj(0, 0, kk-1, irho, sps&
   &        )
   CALL PUSHREAL8(du2(irho))
   du2(irho) = wadj(0, 0, kk+1, irho, sps) - wadj(0, 0, kk, irho, sps&
   &        )
   CALL PUSHREAL8(du3(irho))
   du3(irho) = wadj(0, 0, kk+2, irho, sps) - wadj(0, 0, kk+1, irho, &
   &        sps)
   CALL PUSHREAL8(du1(ivx))
   du1(ivx) = wadj(0, 0, kk, ivx, sps) - wadj(0, 0, kk-1, ivx, sps)
   CALL PUSHREAL8(du2(ivx))
   du2(ivx) = wadj(0, 0, kk+1, ivx, sps) - wadj(0, 0, kk, ivx, sps)
   CALL PUSHREAL8(du3(ivx))
   du3(ivx) = wadj(0, 0, kk+2, ivx, sps) - wadj(0, 0, kk+1, ivx, sps)
   CALL PUSHREAL8(du1(ivy))
   du1(ivy) = wadj(0, 0, kk, ivy, sps) - wadj(0, 0, kk-1, ivy, sps)
   CALL PUSHREAL8(du2(ivy))
   du2(ivy) = wadj(0, 0, kk+1, ivy, sps) - wadj(0, 0, kk, ivy, sps)
   CALL PUSHREAL8(du3(ivy))
   du3(ivy) = wadj(0, 0, kk+2, ivy, sps) - wadj(0, 0, kk+1, ivy, sps)
   CALL PUSHREAL8(du1(ivz))
   du1(ivz) = wadj(0, 0, kk, ivz, sps) - wadj(0, 0, kk-1, ivz, sps)
   CALL PUSHREAL8(du2(ivz))
   du2(ivz) = wadj(0, 0, kk+1, ivz, sps) - wadj(0, 0, kk, ivz, sps)
   CALL PUSHREAL8(du3(ivz))
   du3(ivz) = wadj(0, 0, kk+2, ivz, sps) - wadj(0, 0, kk+1, ivz, sps)
   CALL PUSHREAL8(du1(irhoe))
   du1(irhoe) = padj(0, 0, kk, sps) - padj(0, 0, kk-1, sps)
   CALL PUSHREAL8(du2(irhoe))
   du2(irhoe) = padj(0, 0, kk+1, sps) - padj(0, 0, kk, sps)
   CALL PUSHREAL8(du3(irhoe))
   du3(irhoe) = padj(0, 0, kk+2, sps) - padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   CALL PUSHREAL8(du1(itu1))
   du1(itu1) = wadj(0, 0, kk, itu1, sps) - wadj(0, 0, kk-1, itu1, &
   &          sps)
   CALL PUSHREAL8(du2(itu1))
   du2(itu1) = wadj(0, 0, kk+1, itu1, sps) - wadj(0, 0, kk, itu1, &
   &          sps)
   CALL PUSHREAL8(du3(itu1))
   du3(itu1) = wadj(0, 0, kk+2, itu1, sps) - wadj(0, 0, kk+1, itu1&
   &          , sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATEADJ(du1, du2, du3, left, right, nwint, omk, opk&
   &                       , factminmod, firstorderk)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + wadj(0, 0, kk, irho, sps)
   left(ivx) = left(ivx) + wadj(0, 0, kk, ivx, sps)
   left(ivy) = left(ivy) + wadj(0, 0, kk, ivy, sps)
   left(ivz) = left(ivz) + wadj(0, 0, kk, ivz, sps)
   left(irhoe) = left(irhoe) + padj(0, 0, kk, sps)
   right(irho) = right(irho) + wadj(0, 0, kk+1, irho, sps)
   right(ivx) = right(ivx) + wadj(0, 0, kk+1, ivx, sps)
   right(ivy) = right(ivy) + wadj(0, 0, kk+1, ivy, sps)
   right(ivz) = right(ivz) + wadj(0, 0, kk+1, ivz, sps)
   right(irhoe) = right(irhoe) + padj(0, 0, kk+1, sps)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + wadj(0, 0, kk, itu1, sps)
   right(itu1) = right(itu1) + wadj(0, 0, kk+1, itu1, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sx = skadj(0, 0, kk, 1, sps)
   sy = skadj(0, 0, kk, 2, sps)
   sz = skadj(0, 0, kk, 3, sps)
   CALL PUSHINTEGER4(por)
   por = pork(i, j, k)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacekadj(0, 0, kk, sps)
   CALL PUSHINTEGER4(1)
   ELSE
   CALL PUSHINTEGER4(0)
   END IF
   CALL PUSHREAL8(gammaface)
   ! Compute the value of gamma on the face.
   ! Constant gamma for now.
   gammaface = gammaconstant
   CALL PUSHREAL8(sz)
   CALL PUSHREAL8(sy)
   CALL PUSHREAL8(sx)
   ! Compute the dissipative flux across the interface
   ! and them to dwAdj.
   !           call riemannFluxAdj(left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace)
   !           print *,'riemanninputk',left, right, flux,por,gammaFace,correctForK,sX,sY,sZ,sFace,fineGrid
   CALL RIEMANNFLUXADJ(left, right, flux, por, gammaface, correctfork&
   &                    , sx, sy, sz, sface, finegrid)
   !print *,'dwupwind',dwadj,'fact',fact,'flux',flux
   ! Update k and set fact to 1 for the second face.
   k = k + 1
   CALL PUSHREAL8(fact)
   fact = one
   END DO
   padjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   wadjb(-2:2, -2:2, -2:2, 1:nw, 1:ntimeintervalsspectral) = 0.0
   sfacekadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   skadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
   fluxb(1:nwf) = 0.0
   leftb(1:nw) = 0.0
   rightb(1:nw) = 0.0
   du1b(1:nw) = 0.0
   du2b(1:nw) = 0.0
   du3b(1:nw) = 0.0
   sfaceb = 0.0
   DO kk=0,-1,-1
   CALL POPREAL8(fact)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   CALL POPREAL8(sx)
   CALL POPREAL8(sy)
   CALL POPREAL8(sz)
   CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
   &                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
   &                      szb, sface, sfaceb, finegrid)
   CALL POPREAL8(gammaface)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(sface)
   sfacekadjb(0, 0, kk, sps) = sfacekadjb(0, 0, kk, sps) + sfaceb
   sfaceb = 0.0
   END IF
   CALL POPINTEGER4(por)
   skadjb(0, 0, kk, 3, sps) = skadjb(0, 0, kk, 3, sps) + szb
   skadjb(0, 0, kk, 2, sps) = skadjb(0, 0, kk, 2, sps) + syb
   skadjb(0, 0, kk, 1, sps) = skadjb(0, 0, kk, 1, sps) + sxb
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
   &          rightb(itu1)
   wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + leftb(&
   &          itu1)
   END IF
   padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + rightb(irhoe)
   wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + rightb&
   &        (ivz)
   wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + rightb&
   &        (ivy)
   wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + rightb&
   &        (ivx)
   wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + &
   &        rightb(irho)
   padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + leftb(irhoe)
   wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + leftb(ivz)
   wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + leftb(ivy)
   wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + leftb(ivx)
   wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + leftb(&
   &        irho)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
   &                         leftb, right, rightb, nwint, omk, opk, &
   &                         factminmod, firstorderk)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(du3(itu1))
   wadjb(0, 0, kk+2, itu1, sps) = wadjb(0, 0, kk+2, itu1, sps) + &
   &          du3b(itu1)
   wadjb(0, 0, kk+1, itu1, sps) = wadjb(0, 0, kk+1, itu1, sps) + &
   &          du2b(itu1) - du3b(itu1)
   du3b(itu1) = 0.0
   CALL POPREAL8(du2(itu1))
   wadjb(0, 0, kk, itu1, sps) = wadjb(0, 0, kk, itu1, sps) + du1b(&
   &          itu1) - du2b(itu1)
   du2b(itu1) = 0.0
   CALL POPREAL8(du1(itu1))
   wadjb(0, 0, kk-1, itu1, sps) = wadjb(0, 0, kk-1, itu1, sps) - &
   &          du1b(itu1)
   du1b(itu1) = 0.0
   END IF
   CALL POPREAL8(du3(irhoe))
   padjb(0, 0, kk+2, sps) = padjb(0, 0, kk+2, sps) + du3b(irhoe)
   padjb(0, 0, kk+1, sps) = padjb(0, 0, kk+1, sps) + du2b(irhoe) - &
   &        du3b(irhoe)
   du3b(irhoe) = 0.0
   CALL POPREAL8(du2(irhoe))
   padjb(0, 0, kk, sps) = padjb(0, 0, kk, sps) + du1b(irhoe) - du2b(&
   &        irhoe)
   du2b(irhoe) = 0.0
   CALL POPREAL8(du1(irhoe))
   padjb(0, 0, kk-1, sps) = padjb(0, 0, kk-1, sps) - du1b(irhoe)
   du1b(irhoe) = 0.0
   CALL POPREAL8(du3(ivz))
   wadjb(0, 0, kk+2, ivz, sps) = wadjb(0, 0, kk+2, ivz, sps) + du3b(&
   &        ivz)
   wadjb(0, 0, kk+1, ivz, sps) = wadjb(0, 0, kk+1, ivz, sps) + du2b(&
   &        ivz) - du3b(ivz)
   du3b(ivz) = 0.0
   CALL POPREAL8(du2(ivz))
   wadjb(0, 0, kk, ivz, sps) = wadjb(0, 0, kk, ivz, sps) + du1b(ivz) &
   &        - du2b(ivz)
   du2b(ivz) = 0.0
   CALL POPREAL8(du1(ivz))
   wadjb(0, 0, kk-1, ivz, sps) = wadjb(0, 0, kk-1, ivz, sps) - du1b(&
   &        ivz)
   du1b(ivz) = 0.0
   CALL POPREAL8(du3(ivy))
   wadjb(0, 0, kk+2, ivy, sps) = wadjb(0, 0, kk+2, ivy, sps) + du3b(&
   &        ivy)
   wadjb(0, 0, kk+1, ivy, sps) = wadjb(0, 0, kk+1, ivy, sps) + du2b(&
   &        ivy) - du3b(ivy)
   du3b(ivy) = 0.0
   CALL POPREAL8(du2(ivy))
   wadjb(0, 0, kk, ivy, sps) = wadjb(0, 0, kk, ivy, sps) + du1b(ivy) &
   &        - du2b(ivy)
   du2b(ivy) = 0.0
   CALL POPREAL8(du1(ivy))
   wadjb(0, 0, kk-1, ivy, sps) = wadjb(0, 0, kk-1, ivy, sps) - du1b(&
   &        ivy)
   du1b(ivy) = 0.0
   CALL POPREAL8(du3(ivx))
   wadjb(0, 0, kk+2, ivx, sps) = wadjb(0, 0, kk+2, ivx, sps) + du3b(&
   &        ivx)
   wadjb(0, 0, kk+1, ivx, sps) = wadjb(0, 0, kk+1, ivx, sps) + du2b(&
   &        ivx) - du3b(ivx)
   du3b(ivx) = 0.0
   CALL POPREAL8(du2(ivx))
   wadjb(0, 0, kk, ivx, sps) = wadjb(0, 0, kk, ivx, sps) + du1b(ivx) &
   &        - du2b(ivx)
   du2b(ivx) = 0.0
   CALL POPREAL8(du1(ivx))
   wadjb(0, 0, kk-1, ivx, sps) = wadjb(0, 0, kk-1, ivx, sps) - du1b(&
   &        ivx)
   du1b(ivx) = 0.0
   CALL POPREAL8(du3(irho))
   wadjb(0, 0, kk+2, irho, sps) = wadjb(0, 0, kk+2, irho, sps) + du3b&
   &        (irho)
   wadjb(0, 0, kk+1, irho, sps) = wadjb(0, 0, kk+1, irho, sps) + du2b&
   &        (irho) - du3b(irho)
   du3b(irho) = 0.0
   CALL POPREAL8(du2(irho))
   wadjb(0, 0, kk, irho, sps) = wadjb(0, 0, kk, irho, sps) + du1b(&
   &        irho) - du2b(irho)
   du2b(irho) = 0.0
   CALL POPREAL8(du1(irho))
   wadjb(0, 0, kk-1, irho, sps) = wadjb(0, 0, kk-1, irho, sps) - du1b&
   &        (irho)
   du1b(irho) = 0.0
   END DO
   sfacejadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   sjadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
   DO jj=0,-1,-1
   CALL POPREAL8(fact)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   CALL POPREAL8(sx)
   CALL POPREAL8(sy)
   CALL POPREAL8(sz)
   CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
   &                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
   &                      szb, sface, sfaceb, finegrid)
   CALL POPREAL8(gammaface)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(sface)
   sfacejadjb(0, jj, 0, sps) = sfacejadjb(0, jj, 0, sps) + sfaceb
   sfaceb = 0.0
   END IF
   CALL POPINTEGER4(por)
   sjadjb(0, jj, 0, 3, sps) = sjadjb(0, jj, 0, 3, sps) + szb
   sjadjb(0, jj, 0, 2, sps) = sjadjb(0, jj, 0, 2, sps) + syb
   sjadjb(0, jj, 0, 1, sps) = sjadjb(0, jj, 0, 1, sps) + sxb
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
   &          rightb(itu1)
   wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + leftb(&
   &          itu1)
   END IF
   padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + rightb(irhoe)
   wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + rightb&
   &        (ivz)
   wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + rightb&
   &        (ivy)
   wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + rightb&
   &        (ivx)
   wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + &
   &        rightb(irho)
   padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + leftb(irhoe)
   wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + leftb(ivz)
   wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + leftb(ivy)
   wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + leftb(ivx)
   wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + leftb(&
   &        irho)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
   &                         leftb, right, rightb, nwint, omk, opk, &
   &                         factminmod, firstorderk)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(du3(itu1))
   wadjb(0, jj+2, 0, itu1, sps) = wadjb(0, jj+2, 0, itu1, sps) + &
   &          du3b(itu1)
   wadjb(0, jj+1, 0, itu1, sps) = wadjb(0, jj+1, 0, itu1, sps) + &
   &          du2b(itu1) - du3b(itu1)
   du3b(itu1) = 0.0
   CALL POPREAL8(du2(itu1))
   wadjb(0, jj, 0, itu1, sps) = wadjb(0, jj, 0, itu1, sps) + du1b(&
   &          itu1) - du2b(itu1)
   du2b(itu1) = 0.0
   CALL POPREAL8(du1(itu1))
   wadjb(0, jj-1, 0, itu1, sps) = wadjb(0, jj-1, 0, itu1, sps) - &
   &          du1b(itu1)
   du1b(itu1) = 0.0
   END IF
   CALL POPREAL8(du3(irhoe))
   padjb(0, jj+2, 0, sps) = padjb(0, jj+2, 0, sps) + du3b(irhoe)
   padjb(0, jj+1, 0, sps) = padjb(0, jj+1, 0, sps) + du2b(irhoe) - &
   &        du3b(irhoe)
   du3b(irhoe) = 0.0
   CALL POPREAL8(du2(irhoe))
   padjb(0, jj, 0, sps) = padjb(0, jj, 0, sps) + du1b(irhoe) - du2b(&
   &        irhoe)
   du2b(irhoe) = 0.0
   CALL POPREAL8(du1(irhoe))
   padjb(0, jj-1, 0, sps) = padjb(0, jj-1, 0, sps) - du1b(irhoe)
   du1b(irhoe) = 0.0
   CALL POPREAL8(du3(ivz))
   wadjb(0, jj+2, 0, ivz, sps) = wadjb(0, jj+2, 0, ivz, sps) + du3b(&
   &        ivz)
   wadjb(0, jj+1, 0, ivz, sps) = wadjb(0, jj+1, 0, ivz, sps) + du2b(&
   &        ivz) - du3b(ivz)
   du3b(ivz) = 0.0
   CALL POPREAL8(du2(ivz))
   wadjb(0, jj, 0, ivz, sps) = wadjb(0, jj, 0, ivz, sps) + du1b(ivz) &
   &        - du2b(ivz)
   du2b(ivz) = 0.0
   CALL POPREAL8(du1(ivz))
   wadjb(0, jj-1, 0, ivz, sps) = wadjb(0, jj-1, 0, ivz, sps) - du1b(&
   &        ivz)
   du1b(ivz) = 0.0
   CALL POPREAL8(du3(ivy))
   wadjb(0, jj+2, 0, ivy, sps) = wadjb(0, jj+2, 0, ivy, sps) + du3b(&
   &        ivy)
   wadjb(0, jj+1, 0, ivy, sps) = wadjb(0, jj+1, 0, ivy, sps) + du2b(&
   &        ivy) - du3b(ivy)
   du3b(ivy) = 0.0
   CALL POPREAL8(du2(ivy))
   wadjb(0, jj, 0, ivy, sps) = wadjb(0, jj, 0, ivy, sps) + du1b(ivy) &
   &        - du2b(ivy)
   du2b(ivy) = 0.0
   CALL POPREAL8(du1(ivy))
   wadjb(0, jj-1, 0, ivy, sps) = wadjb(0, jj-1, 0, ivy, sps) - du1b(&
   &        ivy)
   du1b(ivy) = 0.0
   CALL POPREAL8(du3(ivx))
   wadjb(0, jj+2, 0, ivx, sps) = wadjb(0, jj+2, 0, ivx, sps) + du3b(&
   &        ivx)
   wadjb(0, jj+1, 0, ivx, sps) = wadjb(0, jj+1, 0, ivx, sps) + du2b(&
   &        ivx) - du3b(ivx)
   du3b(ivx) = 0.0
   CALL POPREAL8(du2(ivx))
   wadjb(0, jj, 0, ivx, sps) = wadjb(0, jj, 0, ivx, sps) + du1b(ivx) &
   &        - du2b(ivx)
   du2b(ivx) = 0.0
   CALL POPREAL8(du1(ivx))
   wadjb(0, jj-1, 0, ivx, sps) = wadjb(0, jj-1, 0, ivx, sps) - du1b(&
   &        ivx)
   du1b(ivx) = 0.0
   CALL POPREAL8(du3(irho))
   wadjb(0, jj+2, 0, irho, sps) = wadjb(0, jj+2, 0, irho, sps) + du3b&
   &        (irho)
   wadjb(0, jj+1, 0, irho, sps) = wadjb(0, jj+1, 0, irho, sps) + du2b&
   &        (irho) - du3b(irho)
   du3b(irho) = 0.0
   CALL POPREAL8(du2(irho))
   wadjb(0, jj, 0, irho, sps) = wadjb(0, jj, 0, irho, sps) + du1b(&
   &        irho) - du2b(irho)
   du2b(irho) = 0.0
   CALL POPREAL8(du1(irho))
   wadjb(0, jj-1, 0, irho, sps) = wadjb(0, jj-1, 0, irho, sps) - du1b&
   &        (irho)
   du1b(irho) = 0.0
   END DO
   sfaceiadjb(-2:2, -2:2, -2:2, 1:ntimeintervalsspectral) = 0.0
   siadjb(-3:2, -3:2, -3:2, 1:3, 1:ntimeintervalsspectral) = 0.0
   DO ii=0,-1,-1
   CALL POPREAL8(fact)
   fluxb(irhoe) = fluxb(irhoe) + fact*dwadjb(irhoe, sps)
   fluxb(imz) = fluxb(imz) + fact*dwadjb(imz, sps)
   fluxb(imy) = fluxb(imy) + fact*dwadjb(imy, sps)
   fluxb(imx) = fluxb(imx) + fact*dwadjb(imx, sps)
   fluxb(irho) = fluxb(irho) + fact*dwadjb(irho, sps)
   CALL POPREAL8(sx)
   CALL POPREAL8(sy)
   CALL POPREAL8(sz)
   CALL RIEMANNFLUXADJ_B(left, leftb, right, rightb, flux, fluxb, por&
   &                      , gammaface, correctfork, sx, sxb, sy, syb, sz, &
   &                      szb, sface, sfaceb, finegrid)
   CALL POPREAL8(gammaface)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(sface)
   sfaceiadjb(ii, 0, 0, sps) = sfaceiadjb(ii, 0, 0, sps) + sfaceb
   sfaceb = 0.0
   END IF
   CALL POPINTEGER4(por)
   siadjb(ii, 0, 0, 3, sps) = siadjb(ii, 0, 0, 3, sps) + szb
   siadjb(ii, 0, 0, 2, sps) = siadjb(ii, 0, 0, 2, sps) + syb
   siadjb(ii, 0, 0, 1, sps) = siadjb(ii, 0, 0, 1, sps) + sxb
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
   &          rightb(itu1)
   wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + leftb(&
   &          itu1)
   END IF
   padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + rightb(irhoe)
   wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + rightb&
   &        (ivz)
   wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + rightb&
   &        (ivy)
   wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + rightb&
   &        (ivx)
   wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + &
   &        rightb(irho)
   padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + leftb(irhoe)
   wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + leftb(ivz)
   wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + leftb(ivy)
   wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + leftb(ivx)
   wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + leftb(&
   &        irho)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATEADJ_B(du1, du1b, du2, du2b, du3, du3b, left, &
   &                         leftb, right, rightb, nwint, omk, opk, &
   &                         factminmod, firstorderk)
   CALL POPINTEGER4(branch)
   IF (.NOT.branch .LT. 1) THEN
   CALL POPREAL8(du3(itu1))
   wadjb(ii+2, 0, 0, itu1, sps) = wadjb(ii+2, 0, 0, itu1, sps) + &
   &          du3b(itu1)
   wadjb(ii+1, 0, 0, itu1, sps) = wadjb(ii+1, 0, 0, itu1, sps) + &
   &          du2b(itu1) - du3b(itu1)
   du3b(itu1) = 0.0
   CALL POPREAL8(du2(itu1))
   wadjb(ii, 0, 0, itu1, sps) = wadjb(ii, 0, 0, itu1, sps) + du1b(&
   &          itu1) - du2b(itu1)
   du2b(itu1) = 0.0
   CALL POPREAL8(du1(itu1))
   wadjb(ii-1, 0, 0, itu1, sps) = wadjb(ii-1, 0, 0, itu1, sps) - &
   &          du1b(itu1)
   du1b(itu1) = 0.0
   END IF
   CALL POPREAL8(du3(irhoe))
   padjb(ii+2, 0, 0, sps) = padjb(ii+2, 0, 0, sps) + du3b(irhoe)
   padjb(ii+1, 0, 0, sps) = padjb(ii+1, 0, 0, sps) + du2b(irhoe) - &
   &        du3b(irhoe)
   du3b(irhoe) = 0.0
   CALL POPREAL8(du2(irhoe))
   padjb(ii, 0, 0, sps) = padjb(ii, 0, 0, sps) + du1b(irhoe) - du2b(&
   &        irhoe)
   du2b(irhoe) = 0.0
   CALL POPREAL8(du1(irhoe))
   padjb(ii-1, 0, 0, sps) = padjb(ii-1, 0, 0, sps) - du1b(irhoe)
   du1b(irhoe) = 0.0
   CALL POPREAL8(du3(ivz))
   wadjb(ii+2, 0, 0, ivz, sps) = wadjb(ii+2, 0, 0, ivz, sps) + du3b(&
   &        ivz)
   wadjb(ii+1, 0, 0, ivz, sps) = wadjb(ii+1, 0, 0, ivz, sps) + du2b(&
   &        ivz) - du3b(ivz)
   du3b(ivz) = 0.0
   CALL POPREAL8(du2(ivz))
   wadjb(ii, 0, 0, ivz, sps) = wadjb(ii, 0, 0, ivz, sps) + du1b(ivz) &
   &        - du2b(ivz)
   du2b(ivz) = 0.0
   CALL POPREAL8(du1(ivz))
   wadjb(ii-1, 0, 0, ivz, sps) = wadjb(ii-1, 0, 0, ivz, sps) - du1b(&
   &        ivz)
   du1b(ivz) = 0.0
   CALL POPREAL8(du3(ivy))
   wadjb(ii+2, 0, 0, ivy, sps) = wadjb(ii+2, 0, 0, ivy, sps) + du3b(&
   &        ivy)
   wadjb(ii+1, 0, 0, ivy, sps) = wadjb(ii+1, 0, 0, ivy, sps) + du2b(&
   &        ivy) - du3b(ivy)
   du3b(ivy) = 0.0
   CALL POPREAL8(du2(ivy))
   wadjb(ii, 0, 0, ivy, sps) = wadjb(ii, 0, 0, ivy, sps) + du1b(ivy) &
   &        - du2b(ivy)
   du2b(ivy) = 0.0
   CALL POPREAL8(du1(ivy))
   wadjb(ii-1, 0, 0, ivy, sps) = wadjb(ii-1, 0, 0, ivy, sps) - du1b(&
   &        ivy)
   du1b(ivy) = 0.0
   CALL POPREAL8(du3(ivx))
   wadjb(ii+2, 0, 0, ivx, sps) = wadjb(ii+2, 0, 0, ivx, sps) + du3b(&
   &        ivx)
   wadjb(ii+1, 0, 0, ivx, sps) = wadjb(ii+1, 0, 0, ivx, sps) + du2b(&
   &        ivx) - du3b(ivx)
   du3b(ivx) = 0.0
   CALL POPREAL8(du2(ivx))
   wadjb(ii, 0, 0, ivx, sps) = wadjb(ii, 0, 0, ivx, sps) + du1b(ivx) &
   &        - du2b(ivx)
   du2b(ivx) = 0.0
   CALL POPREAL8(du1(ivx))
   wadjb(ii-1, 0, 0, ivx, sps) = wadjb(ii-1, 0, 0, ivx, sps) - du1b(&
   &        ivx)
   du1b(ivx) = 0.0
   CALL POPREAL8(du3(irho))
   wadjb(ii+2, 0, 0, irho, sps) = wadjb(ii+2, 0, 0, irho, sps) + du3b&
   &        (irho)
   wadjb(ii+1, 0, 0, irho, sps) = wadjb(ii+1, 0, 0, irho, sps) + du2b&
   &        (irho) - du3b(irho)
   du3b(irho) = 0.0
   CALL POPREAL8(du2(irho))
   wadjb(ii, 0, 0, irho, sps) = wadjb(ii, 0, 0, irho, sps) + du1b(&
   &        irho) - du2b(irho)
   du2b(irho) = 0.0
   CALL POPREAL8(du1(irho))
   wadjb(ii-1, 0, 0, irho, sps) = wadjb(ii-1, 0, 0, irho, sps) - du1b&
   &        (irho)
   du1b(irho) = 0.0
   END DO
   END IF
   CALL POPINTEGER4(branch)
   CALL POPINTEGER4(branch)

   END SUBROUTINE INVISCIDUPWINDFLUXADJ_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of computerootbendingmoment in reverse (adjoint) mode:
   !   gradient     of useful results: bendingmoment
   !   with respect to varying inputs: pointref sol bendingmoment
   !   RW status of diff variables: pointref:out sol:out bendingmoment:in-out
   !
   !****************************************************
   !
   !   Filename: rootBendingMomentAnalysis.f90
   !   Author: C.A.(Sandy) Mader
   !   Date Started: July 10, 2011
   !   Date Modified: July 10,2011
   !
   !****************************************************
   SUBROUTINE COMPUTEROOTBENDINGMOMENT_B(sol, solb, bendingmoment, &
   &  bendingmomentb)
   USE COSTFUNCTIONS
   USE INPUTPHYSICS
   IMPLICIT NONE
   !*******************************************************
   !                                                      *
   ! Compute a normalized bending moment coefficient from *
   ! the force and moment coefficient. At the moment this *
   ! Routine only works for a half body. Additional logic *
   ! would be needed for a full body.                     *
   !                                                      *
   !*******************************************************
   ! liftDirection, dragDirection,pointref,pointrefec
   !input/output variables
   REAL(kind=realtype), DIMENSION(ncostfunction) :: sol
   REAL(kind=realtype), DIMENSION(ncostfunction) :: solb
   REAL(kind=realtype) :: bendingmoment
   REAL(kind=realtype) :: bendingmomentb
   !Subroutine Variables
   REAL(kind=realtype) :: cmx, cmy, cmz, cfx, cfy, cfz
   REAL(kind=realtype) :: cmxb, cmyb, cmzb, cfxb, cfyb, cfzb
   REAL(kind=realtype) :: elasticmomentx, elasticmomenty, elasticmomentz
   REAL(kind=realtype) :: elasticmomentxb, elasticmomentyb, &
   &  elasticmomentzb
   INTEGER(kind=inttype) :: liftindex
   REAL(kind=realtype) :: alpha, beta
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb
   INTRINSIC SQRT
   !Begin execution
   !determine the liftIndex from the flow and liftdirection
   CALL GETDIRANGLE(veldirfreestream, liftdirection, liftindex, alpha&
   &                , beta)
   !Set some basic variables from the solution, do the analysis based on
   !the coefficients so that it is well scaled
   cmx = sol(costfuncmomxcoef)
   cmy = sol(costfuncmomycoef)
   cmz = sol(costfuncmomzcoef)
   cfx = sol(costfuncforcexcoef)
   cfy = sol(costfuncforceycoef)
   cfz = sol(costfuncforcezcoef)
   !sum up the moments about the root elastic center to determine the effect of sweep on the moment
   IF (liftindex .EQ. 2) THEN
   !z out wing sum momentx,momentz
   elasticmomentx = cmx + cfy*(pointrefec(3)-pointref(3)) - cfz*(&
   &      pointrefec(2)-pointref(2))
   elasticmomentz = cmz - cfy*(pointrefec(1)-pointref(1)) + cfx*(&
   &      pointrefec(2)-pointref(2))
   IF (elasticmomentx**2 + elasticmomentz**2 .EQ. 0.0) THEN
   tempb = 0.0
   ELSE
   tempb = bendingmomentb/(2.0*SQRT(elasticmomentx**2+elasticmomentz&
   &        **2))
   END IF
   elasticmomentxb = 2*elasticmomentx*tempb
   elasticmomentzb = 2*elasticmomentz*tempb
   pointrefb = 0.0
   cmzb = elasticmomentzb
   cfyb = (pointrefec(3)-pointref(3))*elasticmomentxb - (pointrefec(1)-&
   &      pointref(1))*elasticmomentzb
   pointrefb(1) = cfy*elasticmomentzb
   cfxb = (pointrefec(2)-pointref(2))*elasticmomentzb
   pointrefb(2) = -(cfx*elasticmomentzb)
   cmxb = elasticmomentxb
   pointrefb(3) = pointrefb(3) - cfy*elasticmomentxb
   cfzb = -((pointrefec(2)-pointref(2))*elasticmomentxb)
   pointrefb(2) = pointrefb(2) + cfz*elasticmomentxb
   bendingmomentb = 0.0
   cmyb = 0.0
   ELSE
   IF (liftindex .EQ. 3) THEN
   !y out wing sum momentx,momenty
   elasticmomentx = cmx + cfz*(pointrefec(2)-pointref(2)) + cfy*(&
   &        pointrefec(3)-pointref(3))
   elasticmomenty = cmy + cfz*(pointrefec(1)-pointref(1)) + cfx*(&
   &        pointrefec(3)-pointref(3))
   IF (elasticmomentx**2 + elasticmomenty**2 .EQ. 0.0) THEN
   tempb0 = 0.0
   ELSE
   tempb0 = bendingmomentb/(2.0*SQRT(elasticmomentx**2+&
   &          elasticmomenty**2))
   END IF
   elasticmomentxb = 2*elasticmomentx*tempb0
   elasticmomentyb = 2*elasticmomenty*tempb0
   pointrefb = 0.0
   cmyb = elasticmomentyb
   cfzb = (pointrefec(2)-pointref(2))*elasticmomentxb + (pointrefec(1&
   &        )-pointref(1))*elasticmomentyb
   pointrefb(1) = -(cfz*elasticmomentyb)
   cfxb = (pointrefec(3)-pointref(3))*elasticmomentyb
   pointrefb(3) = -(cfx*elasticmomentyb)
   cmxb = elasticmomentxb
   pointrefb(2) = pointrefb(2) - cfz*elasticmomentxb
   cfyb = (pointrefec(3)-pointref(3))*elasticmomentxb
   pointrefb(3) = pointrefb(3) - cfy*elasticmomentxb
   bendingmomentb = 0.0
   ELSE
   pointrefb = 0.0
   cfxb = 0.0
   cfyb = 0.0
   cfzb = 0.0
   cmxb = 0.0
   cmyb = 0.0
   END IF
   cmzb = 0.0
   END IF
   solb = 0.0
   solb(costfuncforcezcoef) = cfzb
   solb(costfuncforceycoef) = solb(costfuncforceycoef) + cfyb
   solb(costfuncforcexcoef) = solb(costfuncforcexcoef) + cfxb
   solb(costfuncmomzcoef) = solb(costfuncmomzcoef) + cmzb
   solb(costfuncmomycoef) = solb(costfuncmomycoef) + cmyb
   solb(costfuncmomxcoef) = solb(costfuncmomxcoef) + cmxb
   END SUBROUTINE COMPUTEROOTBENDINGMOMENT_B

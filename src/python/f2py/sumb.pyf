!    -*- f90 -*-
python module solverunsteadyale__user__routines 
    interface solverunsteadyale_user_interface 
        subroutine alecallback_python(t) ! in :test:solverUnsteady_ALE.f90
          real(kind=realtype) :: t
        end subroutine alecallback_python
    end interface solverunsteadyale_user_interface
end python module solverunsteadyale__user__routines


#ifdef USE_COMPLEX
python module libsumb_cs ! in 
#else
python module libsumb
#endif
    interface  ! in :sumb

       ! ############################################################################
       ! SUmb Routines
       ! ############################################################################

       module utils
         subroutine writeintromessage ! in :sumb:../../utils/initExec.F90
         end subroutine writeintromessage

         subroutine getliftdirfromsymmetry(liftdir)
           integer(kind=inttype), intent(out) :: liftdir
         end subroutine getliftdirfromsymmetry

         subroutine allocconvarrays(nitertot) ! in :sumb:../../initFlow/allocConvArrays.f90
           integer(kind=inttype) :: nitertot
         end subroutine allocconvarrays
         
         subroutine alloctimearrays(nitertot) ! in :sumb:../../initFlow/allocTimeArrays.f90
           integer(kind=inttype) :: ntimetot
         end subroutine alloctimearrays
         
       end module utils

       module walldistance

         subroutine updatewalldistancealllevels ! in :sumb:../../wallDistance/updateWallDistanceAllLevels.f90
         end subroutine updatewalldistancealllevels

       end module walldistance

       module initializeflow

         subroutine initflow 
         end subroutine initflow
       
         subroutine initflowrestart
         end subroutine initflowrestart

         subroutine referencestate
         end subroutine referencestate

         subroutine setuniformflow
         end subroutine setuniformflow

         subroutine allocrestartfiles(nfiles) 
           integer(kind=inttype) :: nfiles
         end subroutine allocrestartfiles

         subroutine setrestartfiles(filename,i)
           character*(*) intent(in) :: filename
           integer(kind=inttype) :: i
         end subroutine setrestartfiles

       end module initializeflow

       module flowutils 

         subroutine updategamma
         end subroutine updategamma

       end module flowutils

       module inputparamroutines

         subroutine setdefaultvalues()
         end subroutine setdefaultvalues

         subroutine monitorvariables(variables) ! in :test:monitorVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine monitorvariables
         
         subroutine surfacevariables(variables) ! in :test:surfaceVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine surfacevariables
         
         subroutine volumevariables(variables) ! in :test:volumeVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine volumevariables
         
         subroutine isovariables(variables) ! in :test:volumeVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine isovariables
         
         subroutine initializeisosurfacevariables(values,nvalues) ! in :test:setIsoSurfaceValues.F90
           real(kind=realtype), dimension(nvalues),intent(in) :: values
           integer(kind=inttype), optional,intent(in),check(len(values)>=nvalues),depend(values) :: nvalues=len(values)
         end subroutine initializeisosurfacevariables
         
         subroutine setisosurfacevariable(variable,ivar) ! in :test:setIsoSurfaceValues.F90
           character*(*), intent(in) :: variable
           integer(kind=inttype), intent(in) :: ivar
         end subroutine setisosurfacevariable

         subroutine dummyreadparamfile ! in :sumb:../../inputParam/readParamFile.f90
         end subroutine dummyreadparamfile

       end module inputparamroutines

       subroutine addparaslice(slicename,pt,direction,famlist,n) ! in :test:liftDistribution.F90
         character*(*) intent(in) :: slicename
         real(kind=realtype) dimension(3),intent(in) :: pt
         real(kind=realtype) dimension(3),intent(in) :: direction
         integer(kind=inttype) dimension(n),intent(in) :: famlist
         integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)

       end subroutine addparaslice

       subroutine addabsslice(slicename,pt,direction,famlist,n) ! in :test:liftDistribution.F90
         character*(*) intent(in) :: slicename
         real(kind=realtype) dimension(3),intent(in) :: pt
         real(kind=realtype) dimension(3),intent(in) :: direction
         integer(kind=inttype) dimension(n),intent(in) :: famlist
         integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
       end subroutine addabsslice

       subroutine addliftdistribution(nsegments,dir_vec,dir_ind, distname,famlist,n) ! in :test:liftDistribution.F90
         integer(kind=inttype) intent(in) :: nsegments
         real(kind=realtype) dimension(3), intent(in) :: dir_vec
         integer(kind=inttype), intent(in) :: dir_ind
         character*(*) intent(in) :: distname
         integer(kind=inttype) dimension(n),intent(in) :: famlist
         integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
       end subroutine addliftdistribution
       
       subroutine writetecplot(slicefile, writeslices, liftfile, writelift, surffile, writesurf)
         character*(*), intent(in) :: slicefile
         logical, intent(in) :: writeslices
         character*(*), intent(in) :: liftfile
         logical, intent(in) :: writelift
         character*(*), intent(in) :: surffile
         logical, intent(in) :: writesurf
       end subroutine writeliftdistributionfile

      
       subroutine partitionandreadgrid(partitiononly) ! in :sumb:../../partitioning/partitionAndReadGrid.f90
         logical :: partitiononly
       end subroutine partitionandreadgrid

       subroutine preprocessing ! in :sumb:../../preprocessing/preprocessing.f90
       end subroutine preprocessing
     
       subroutine updatecoordinatesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updatecoordinatesalllevels

       subroutine updatemetricsalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updatemetricsalllevels

       subroutine updategridvelocitiesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updategridvelocitiesalllevels

       subroutine updateperiodicinfoalllevels
       end subroutine updateperiodicinfoalllevels

       subroutine updateflow
       end subroutine updateflow

       subroutine updatereferencepoint
       end subroutine updatereferencepoint

       subroutine updaterotationrate(rotcenter,rotrate,blocks,nblocks) ! in :test:updateRotationRate.f90
         real(kind=realtype) dimension(3),intent(in) :: rotcenter
         real(kind=realtype) dimension(3),intent(in) :: rotrate
         integer(kind=inttype) dimension(nblocks),intent(in) :: blocks
         integer(kind=inttype), optional,intent(in),check(len(blocks)>=nblocks),depend(blocks) :: nblocks=len(blocks)
       end subroutine updaterotationrate

       subroutine adjustinflowangle(alpha, beta, liftindex)
         real(kind=realtype) intent(in) :: alpha
         real(kind=realtype) intent(in):: beta
         integer(kind=inttype) intent(in) :: liftindex
       end subroutine adjustinflowangle



       subroutine solver ! in :sumb:../../solver/solver.F90
       end subroutine solver

       subroutine checkpartitioning(np,load_inbalance,face_inbalance) ! in :test:checkPartitioning.f90
         integer(kind=inttype) intent(in) :: np
         real(kind=realtype) intent(out) :: load_inbalance
         real(kind=realtype) intent(out) :: face_inbalance
       end subroutine checkpartitioning

       subroutine writesol ! in :sumb:../../output/writeSol.f90
       end subroutine writesol


       subroutine updateslidingalllevels ! in :sumb:../../slidingComm/updateSlidingAllLevels.f90
       end subroutine updateslidingalllevels

       subroutine solversteady ! in :sumb:../../solver/solverSteady.f90
       end subroutine solversteady

       subroutine inittimesteppart1 ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine inittimesteppart1

       subroutine inittimesteppart2 ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine inittimesteppart2

       subroutine solvestate ! in :sumb:../../solver/solveState.F90
       end subroutine solvestate

       subroutine checkwriteunsteadyinloop ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine checkwriteunsteadyinloop

       subroutine checkwriteunsteadyendloop ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine checkwriteunsteadyendloop

       subroutine getsolution(sps) ! in :test:getSolution.f90
         integer(kind=inttype) :: sps
        end subroutine getsolution

        subroutine mapvector(vec1,n1,famlist1,nf1,vec2,n2,famlist2,nf2) ! in :test:liftDistribution.F90
          real(kind=realtype) dimension(3,n1),intent(in) :: vec1
          integer(kind=inttype), optional,check(shape(vec1,1)==n1),depend(vec1) :: n1=shape(vec1,1)
          integer(kind=inttype) dimension(nf1),intent(in) :: famlist1
          integer(kind=inttype), optional,check(len(famlist1)>=nf1),depend(famlist1) :: nf1=len(famlist1)
          real(kind=realtype) dimension(3,n2),intent(inout) :: vec2
          integer(kind=inttype), optional,check(shape(vec2,1)==n2),depend(vec2) :: n2=shape(vec2,1)
          integer(kind=inttype) dimension(nf2),intent(in) :: famlist2
          integer(kind=inttype), optional,check(len(famlist2)>=nf2),depend(famlist2) :: nf2=len(famlist2)
        end subroutine mapvector

       ! ############################################################################
       ! Added by HDN
       ! ############################################################################
       subroutine solverunsteady_ale(alecallback_python) ! in :test:solverUnsteady_ALE.F90
         use solverunsteadyale__user__routines
         external alecallback_python
       end subroutine solverunsteady_ale

       ! For operations related to mesh-warping
       subroutine shiftcoorandvolumes ! in :sumb:../../preprocessing/shiftCoorAndVolumes.F90
       end subroutine shiftcoorandvolumes

       subroutine shiftlevelale ! in :sumb:../../sovler/geomUtilsALE.F90
       end subroutine shiftlevelale

       subroutine solverunsteadywrapbegin ! in :sumb:../../solver/solverUnsteadyWrap.F90
       end subroutine solverunsteadyerapbegin

       subroutine solverunsteadywrapinloop ! in :sumb:../../solver/solverUnsteadyWrap.F90
       end subroutine solverunsteadywrapinloop

       subroutine solverunsteadywrapend ! in :sumb:../../solver/solverUnsteadyWrap.F90
       end subroutine solverunsteadywrapend
     

       ! ############################################################################
       ! SUmb Mesh/Forces Interface Routines
       ! ############################################################################

        subroutine setfamilyinfo(famlist,n) ! in :test:getForces.F90
          integer(kind=inttype) dimension(n),intent(in) :: famlist
          integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
        end subroutine setfamilyinfo

       subroutine getcgnsmeshindices(ndof,indices)
         integer(kind=inttype) intent(in) :: ndof
         integer(kind=inttype) dimension(ndof),intent(out),depend(ndof) :: indices
       end subroutine getcgnsmeshindices

       subroutine setgrid(grid,ndof) ! in :test:setGrid.f90
         real(kind=realtype) dimension(ndof),intent(in) :: grid
         integer(kind=inttype) optional,intent(in),check(len(grid)>=ndof),depend(grid) :: ndof=len(grid)
       end subroutine setgrid

       subroutine getgrid(grid,ndof) ! in :test:setGrid.f90
            real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: grid
            integer(kind=inttype) intent(in) :: ndof
        end subroutine getgrid

       subroutine getsurfacesize(npts, ncells, famlist, n) ! in :test:getForces.f90
         integer(kind=inttype) intent(out) :: npts
         integer(kind=inttype) intent(out) :: ncells
         integer(kind=inttype) dimension(n),intent(in) :: famlist
         integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
       end subroutine getsurfacesize

        subroutine getsurfaceconnectivity(conn,ncell) ! in :test:getForces.f90
          integer(kind=inttype) dimension(4 * ncell),intent(inout) :: conn
          integer(kind=inttype) optional,intent(in),check((len(conn))/(4)>=ncell),depend(conn) :: ncell=(len(conn))/(4)
        end subroutine getsurfaceconnectivity

        subroutine getforces(forces,npts,sps_in) ! in :test:getForces.F90
            real(kind=realtype) dimension(3 * npts),intent(inout) :: forces
            integer(kind=inttype), optional,intent(in),check((len(forces))/(3)>=npts),depend(forces) :: npts=(len(forces))/(3)
            integer(kind=inttype) intent(in) :: sps_in
        end subroutine getforces

        subroutine getsurfacepoints(points,npts,sps_in) ! in :test:getForces.f90
          integer(kind=inttype), intent(in) :: sps_in
          real(kind=realtype) dimension(3,npts),intent(inout) :: points
          integer(kind=inttype) optional,intent(in),check(shape(points,1)==npts),depend(points) :: npts=shape(points,1)
        end subroutine getsurfacepoints

       subroutine getareas(areas,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: areas
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareas

       subroutine getareasensitivity(darea,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: darea
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareasensitivity

       subroutine updatecoorfinemesh(dtadvance, sps) ! in preprocessing/updateCoorFineMesh.f90 
         integer(kind=inttype), intent(in) :: sps
         real(kind=realtype), dimension(*), intent(in) :: dtadvance
       end subroutine updatecoorfinemesh

       

       ! ############################################################################
       ! SUmb ADjoint Debugging Routines
       ! ############################################################################

       subroutine determinestencil(lumped)
         logical :: lumped 
       end subroutine determinestencil
       
       ! ############################################################################
       ! SUmb ADjoint Core Routines
       ! ############################################################################

       subroutine initializepetsc 
       end subroutine initializepetsc

       subroutine preprocessingadjoint 
       end subroutine preprocessingadjoint
    
       ! State Variables
       subroutine createpetscvars
       end subroutine createpetscvars

       subroutine destroypetscvars
       end subroutine destroypetscvars

       ! KSP Setup
       subroutine setuppetscksp 
       end subroutine setuppetscksp

       subroutine setupallresidualmatricesfwd
       end subroutine setupallresidualmatricesfwd


       subroutine solveadjoint(rhs,psi,checksolution,nstate) ! in :test:solveADjointTransposePETSc.F90
         real(kind=realtype) dimension(nstate) :: rhs
         real(kind=realtype) dimension(nstate),depend(nstate) :: psi
         logical :: checksolution
         integer(kind=inttype), optional,check(len(rhs)>=nstate),depend(rhs) :: nstate=len(rhs)
       end subroutine solveadjoint

        subroutine solveadjointforrhs(invec,outvec,ndof,relativetolerance) ! in :test:matrixFreeRoutines.F90
            real(kind=realtype) dimension(ndof),intent(in) :: invec
            real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: outvec
            integer(kind=inttype), optional,intent(in),check(len(invec)>=ndof),depend(invec) :: ndof=len(invec)
            real(kind=realtype) intent(in) :: relativetolerance
        end subroutine solveadjointforrhs
        subroutine solvedirectforrhs(invec,outvec,ndof,relativetolerance) ! in :test:matrixFreeRoutines.F90
            real(kind=realtype) dimension(ndof),intent(in) :: invec
            real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: outvec
            integer(kind=inttype), optional,intent(in),check(len(invec)>=ndof),depend(invec) :: ndof=len(invec)
            real(kind=realtype) intent(in) :: relativetolerance
        end subroutine solvedirectforrhs


        subroutine saveadjointmatrix(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
        end subroutine saveadjointmatrix
        subroutine saveadjointpc(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
          end subroutine saveadjointpc
          subroutine saveadjointrhs(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
          end subroutine saveadjointrhs

          subroutine savecellcenters(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
          end subroutine savecellcenters


       ! -------- Partial Derivative Functions -----------
       
       ! -------- Get/Set Functions --------------------
       subroutine getstates(states,ndimw) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(ndimw),intent(out),depend(ndimw) :: states
         integer(kind=inttype) intent(in) :: ndimw
       end subroutine getstates

       subroutine setstates(states,ndimw) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(ndimw),intent(in) :: states
         integer(kind=inttype) optional,intent(in),check(len(states)>=ndimw),depend(states) :: ndimw=len(states)
       end subroutine setstates

       subroutine getinfosize(isize)
         integer(kind=inttype) intent(out) :: isize
       end subroutine getinfosize

       subroutine setinfo(info,isize) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(isize),intent(in) :: info
         integer(kind=inttype) optional,intent(in),check(len(info)>=isize),depend(info) :: isize=len(info)
       end subroutine setinfo

       subroutine getinfo(info,isize) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(isize),intent(out),depend(isize) :: info
         integer(kind=inttype) intent(in) :: isize
       end subroutine setinfo

       subroutine getres(res,ndimw) ! in :test:NKUtilities.F90
         real(kind=realtype) dimension(ndimw),intent(in,out) :: res
         integer(kind=inttype) optional,intent(in),check(len(res)>=ndimw),depend(res) :: ndimw=len(res)
       end subroutine getres

       subroutine spectralprecscribedmotion(input,nin,dxv,nout)
         real(kind=realtype) dimension(nin),intent(in) :: input
         integer(kind=inttype), optional,intent(in),check(len(input)>=nin),depend(input) :: nin=len(input)
         real(kind=realtype) dimension(nout),intent(out),depend(nout) :: dxv
         integer(kind=inttype) intent(in) :: nout
       end subroutine spectralprecscribedmotion
#ifndef USE_COMPLEX
        subroutine computematrixfreeproductfwd(xvdot,extradot,wdot,usespatial,usestate,dwdot,funcsdot,fdot,spatialsize,extrasize,statesize,costsize,fsize) ! in :test:matrixFreeRoutines.F90
            real(kind=realtype) dimension(spatialsize),intent(in) :: xvdot
            real(kind=realtype) dimension(extrasize),intent(in) :: extradot
            real(kind=realtype) dimension(statesize),intent(in) :: wdot
            logical intent(in) :: usespatial
            logical intent(in) :: usestate
            real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: dwdot
            real(kind=realtype) dimension(costsize),intent(out),depend(costsize) :: funcsdot
            real(kind=realtype) dimension(3,fsize),intent(out),depend(fsize) :: fdot
            integer(kind=inttype), optional,intent(in),check(len(xvdot)>=spatialsize),depend(xvdot) :: spatialsize=len(xvdot)
            integer(kind=inttype), optional,intent(in),check(len(extradot)>=extrasize),depend(extradot) :: extrasize=len(extradot)
            integer(kind=inttype), optional,intent(in),check(len(wdot)>=statesize),depend(wdot) :: statesize=len(wdot)
            integer(kind=inttype) intent(in) :: costsize
            integer(kind=inttype) intent(in) :: fsize
        end subroutine computematrixfreeproductfwd

        subroutine computematrixfreeproductbwd(dwbar,funcsbar,fbar,usespatial,usestate,xvbar,extrabar,wbar,spatialsize,extrasize,statesize,costsize,fsize) ! in :test:matrixFreeRoutines.F90
            real(kind=realtype) dimension(statesize),intent(in) :: dwbar
            real(kind=realtype) dimension(costsize),intent(in) :: funcsbar
            real(kind=realtype) dimension(3,fsize),intent(in) :: fbar
            logical intent(in) :: usespatial
            logical intent(in) :: usestate
            real(kind=realtype) dimension(spatialsize),intent(out),depend(spatialsize) :: xvbar
            real(kind=realtype) dimension(extrasize),intent(out),depend(extrasize) :: extrabar
            real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: wbar
            integer(kind=inttype) intent(in) :: spatialsize
            integer(kind=inttype) intent(in) :: extrasize
            integer(kind=inttype), optional,intent(in),check(len(dwbar)>=statesize),depend(dwbar) :: statesize=len(dwbar)
            integer(kind=inttype), optional,intent(in),check(len(funcsbar)>=costsize),depend(funcsbar) :: costsize=len(funcsbar)
            integer(kind=inttype), optional,intent(in),check(shape(fbar,1)==fsize),depend(fbar) :: fsize=shape(fbar,1)
        end subroutine computematrixfreeproductbwd

        subroutine computematrixfreeproductbwdfast(dwbar,wbar,statesize) ! in :test:test.F90
          real(kind=realtype) dimension(statesize),intent(in) :: dwbar
          real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: wbar
          integer(kind=inttype), optional,check(len(dwbar)>=statesize),depend(dwbar) :: statesize=len(dwbar)
        end subroutine computematrixfreeproductbwdfast
#endif
       ! ------------- Misc --------------------
 

       ! ############################################################################
       ! Newton-Krylov Solver Routines
       ! ############################################################################

       subroutine applypc(in_vec,out_vec,ndof) ! in :test:NKsolver.F90
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
         integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
       end subroutine applypc

       subroutine applyadjointpc(in_vec,out_vec,ndof) ! in :test:NKsolver.F90
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
         integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
       end subroutine applyadjointpc

       subroutine destroynksolver
       end subroutine destroynksolver

       subroutine destroyanksolver
       end subroutine destroyanksolver
       
       ! ############################################################################
       ! SUmb Modules
       ! ############################################################################
       module constants ! in :sumb:../../modules/constants.F90
         use precision
         integer parameter,optional :: maxstringlen   = 256
         integer parameter,optional :: maxcgnsnamelen =  32
         integer(kind=inttype) parameter,optional :: eulerequations=1_inttype
         integer(kind=inttype) parameter,optional :: nsequations=2_inttype
         integer(kind=inttype) parameter,optional :: ransequations=3_inttype
         integer(kind=inttype) parameter,optional :: steady=1_inttype
         integer(kind=inttype) parameter,optional :: unsteady=2_inttype
         integer(kind=inttype) parameter,optional :: timespectral=3_inttype
         integer(kind=inttype) parameter,optional :: internalflow=1_inttype
         integer(kind=inttype) parameter,optional :: externalflow=2_inttype
         integer(kind=inttype) parameter,optional :: cpconstant=1_inttype
         integer(kind=inttype) parameter,optional :: cptempcurvefits=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmaras=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmarasedwards=3_inttype
         integer(kind=inttype) parameter,optional :: komegawilcox=4_inttype
         integer(kind=inttype) parameter,optional :: komegamodified=5_inttype
         integer(kind=inttype) parameter,optional :: ktau=6_inttype
         integer(kind=inttype) parameter,optional :: mentersst=7_inttype
         integer(kind=inttype) parameter,optional :: v2f=10_inttype
         integer(kind=inttype) parameter,optional :: strain=1_inttype
         integer(kind=inttype) parameter,optional :: vorticity=2_inttype
         integer(kind=inttype) parameter,optional :: katolaunder=3_inttype
         integer(kind=inttype) parameter,optional :: dissscalar=1_inttype
         integer(kind=inttype) parameter,optional :: dissmatrix=2_inttype
         integer(kind=inttype) parameter,optional :: disscusp=3_inttype
         integer(kind=inttype) parameter,optional :: upwind=9_inttype
         integer(kind=inttype) parameter,optional :: roe=1_inttype
         integer(kind=inttype) parameter,optional :: vanleer=2_inttype
         integer(kind=inttype) parameter,optional :: ausmdv=3_inttype
         integer(kind=inttype) parameter,optional :: nolimiter=2_inttype
         integer(kind=inttype) parameter,optional :: vanalbeda=3_inttype
         integer(kind=inttype) parameter,optional :: minmod=4_inttype
         integer(kind=inttype) parameter,optional :: noprecond=1_inttype
         integer(kind=inttype) parameter,optional :: turkel=2_inttype
         integer(kind=inttype) parameter,optional :: choimerkle=3_inttype
         integer(kind=inttype) parameter,optional :: constantpressure=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapolpressure=2_inttype
         integer(kind=inttype) parameter,optional :: quadextrapolpressure=3_inttype
         integer(kind=inttype) parameter,optional :: normalmomentum=4_inttype
         integer(kind=inttype) parameter,optional :: constantextrapol=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapol=2_inttype
         integer(kind=inttype) parameter,optional :: rungekutta=1_inttype
         integer(kind=inttype) parameter,optional :: dadi=2_inttype
         integer(kind=inttype) parameter,optional :: nllusgs=3_inttype
         integer(kind=inttype) parameter,optional :: nllusgsline=4_inttype
         integer(kind=inttype) parameter,optional :: segregated=1_inttype
         integer(kind=inttype) parameter,optional :: coupled=2_inttype
         integer(kind=inttype) parameter,optional :: gmres=1_inttype
         integer(kind=inttype) parameter,optional :: adi=2_inttype
         integer(kind=inttype) parameter,optional :: bcdirichlet0=0_inttype
         integer(kind=inttype) parameter,optional :: bcneumann0=1_inttype
         integer(kind=inttype) parameter,optional :: noresaveraging=0_inttype
         integer(kind=inttype) parameter,optional :: alwaysresaveraging=1_inttype
         integer(kind=inttype) parameter,optional :: alternateresaveraging=2_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxnotdefined=0_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxexplicit=1_inttype
         integer(kind=inttype) parameter,optional :: turbrelaximplicit=2_inttype
         integer(kind=inttype) parameter,optional :: precisionsingle=1
         integer(kind=inttype) parameter,optional :: precisiondouble=2
         integer(kind=inttype) parameter,optional :: bdf=1
         integer(kind=inttype) parameter,optional :: explicitrk=2
         integer(kind=inttype) parameter,optional :: implicitrk=3
         integer(kind=inttype) parameter,optional :: md=4
         integer(kind=inttype) :: nolinesearch=0
         integer(kind=inttype) :: cubiclinesearch=1
         integer(kind=inttype) :: nonmonotonelinesearch=2
       end module constants

       module communication ! in :sumb:../../modules/communication.f90
         use precision
         integer :: sumb_comm_world
         integer :: myid
         integer :: nproc
         integer(kind=inttype) :: sendbuffersize_1to1
         integer(kind=inttype) :: sendbuffersize
         integer(kind=inttype) :: recvbuffersize_1to1
         integer(kind=inttype) :: recvbuffersize
         integer(kind=inttype) :: sendbuffersizeover
         integer(kind=inttype) :: recvbuffersizeover
         real(kind=realtype) allocatable,dimension(:) :: sendbuffer
         real(kind=realtype) allocatable,dimension(:) :: recvbuffer
         integer allocatable,dimension(:) :: sendrequests
         integer allocatable,dimension(:) :: recvrequests
       end module communication

       module inputdiscretization ! in :sumb:../../modules/inputParam.f90
         use accuracy
         integer(kind=inttype) :: spacediscr
         integer(kind=inttype) :: spacediscrcoarse
         integer(kind=inttype) :: orderturb
         integer(kind=inttype) :: limiter
         integer(kind=inttype) :: riemann
         integer(kind=inttype) :: riemanncoarse
         integer(kind=inttype) :: precond
         integer(kind=inttype) :: eulerwallbctreatment
         integer(kind=inttype) :: viscwallbctreatment
         integer(kind=inttype) :: outflowtreatment
         real(kind=realtype) :: vis2
         real(kind=realtype) :: vis4
         real(kind=realtype) :: vis2coarse
         real(kind=realtype) :: adis
         real(kind=realtype) :: kappacoef
         logical :: vortexcorr
         logical :: dirscaling
         logical :: radiineededfine
         logical :: radiineededcoarse
         logical :: lumpeddiss
         real(kind=realtype) :: sigma
         logical :: useapproxwalldistance
         logical :: lowspeedpreconditioner
       end module inputdiscretization

       module cgnsgrid
         use constants
         integer(kind=inttype) :: cgnsndom
       end module cgnsgrid

       module inputio ! in :sumb:../../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: solfile
         integer(kind=inttype) parameter,optional :: precisiondouble=2
         character(len=maxstringlen) :: surfacesolfile
         character(len=maxstringlen) :: slicesolfile ! TEMPORARY
         character(len=maxstringlen) :: liftdistributionfile ! TEMPORARY
         character(len=maxstringlen) :: cpfile
         logical :: writecoormeter
         integer(kind=inttype) :: precisionsol
         integer(kind=inttype) :: precisiongrid
         character(len=maxstringlen) :: newgridfile
         character(len=maxstringlen) :: gridfile
         logical :: storeconvinneriter
         logical :: storerindlayer
         logical :: checkrestartsol
         logical :: autoparameterupdate
         logical :: writesymmetry
         logical :: writefarfield
         logical :: viscoussurfacevelocities
         integer(kind=inttype) parameter,optional :: precisionsingle=1
         logical optional :: firstwrite=.true.
         character(len=maxstringlen) :: paramfile
         character(len=maxstringlen) :: forcedvolumefile
         character(len=maxstringlen) :: forcedsurfacefile
         character(len=maxstringlen) :: forcedliftfile
         character(len=maxstringlen) :: forcedslicefile
       end module inputio

       module inputiteration ! in :sumb:../../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: mgdescription
         integer(kind=inttype) :: ncycles
         integer(kind=inttype) :: ncyclescoarse
         integer(kind=inttype) :: nsavevolume
         integer(kind=inttype) :: nsavesurface
         integer(kind=inttype) :: nsgstartup
         integer(kind=inttype) :: smoother
         integer(kind=inttype) :: nrkstages
         integer(kind=inttype) :: resaveraging
         real(kind=realtype) :: cfllimit
         integer(kind=inttype) :: turbtreatment
         integer(kind=inttype) :: nsubiterturb
         integer(kind=inttype) :: nsubiterations
         integer(kind=inttype) :: turbsmoother
         integer(kind=inttype) :: turbrelax
         integer(kind=inttype) :: mgboundcorr
         integer(kind=inttype) :: mgstartlevel
         integer(kind=inttype) :: nmgsteps
         integer(kind=inttype) :: nmglevels
         integer(kind=inttype) :: miniternum
         integer(kind=inttype) :: convcheckwindowsize
         integer(kind=inttype) allocatable,dimension(:) :: cyclestrategy
         real(kind=realtype) :: cfl
         real(kind=realtype) :: cflcoarse
         real(kind=realtype) :: fcoll
         real(kind=realtype) :: smoop
         real(kind=realtype) :: alfaturb
         real(kind=realtype) :: betaturb
         real(kind=realtype) :: l2conv
         real(kind=realtype) :: l2convcoarse
         real(kind=realtype) :: l2convrel
         real(kind=realtype) :: epscoefconv
         real(kind=realtype) allocatable,dimension(:) :: etark
         real(kind=realtype) allocatable,dimension(:) :: cdisrk
         real(kind=realtype), dimension(4) :: turbresscale
         logical :: freezeturbsource
         logical :: printiterations
         logical :: printwarnings
         real(kind=realtype) ::maxl2deviationfactor
       end module inputiteration

       module inputmotion ! in :sumb:../../modules/inputParam.f90
         use precision
         real(kind=realtype), dimension(3) :: rotpoint
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouryrot
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourxrot
         integer(kind=inttype) :: degreefourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouralpha
         real(kind=realtype) :: omegafourbeta
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourbeta
         integer(kind=inttype) :: degreepolbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourmach
         integer(kind=inttype) :: degreepolmach
         real(kind=realtype) :: omegafourmach
         integer(kind=inttype) :: degreepolalpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolmach
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourmach
         real(kind=realtype) allocatable,dimension(:) :: coefpolzrot
         logical :: gridmotionspecified
         real(kind=realtype) :: omegafourzrot
         integer(kind=inttype) :: degreefouryrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolyrot
         integer(kind=inttype) :: degreefourbeta
         real(kind=realtype) :: omegafouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourzrot
         integer(kind=inttype) :: degreepolzrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourzrot
         real(kind=realtype) :: omegafouryrot
         integer(kind=inttype) :: degreefourzrot
         integer(kind=inttype) :: degreefourmach
         integer(kind=inttype) :: degreefouralpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolalpha
         real(kind=realtype) :: omegafourxrot
         integer(kind=inttype) :: degreepolyrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouryrot
         integer(kind=inttype) :: degreepolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolbeta
       end module inputmotion
       
       module inputparallel ! in :sumb:../../modules/inputParam.f90
         real(kind=realtype) :: loadimbalance
         logical :: splitblocks
         integer(kind=inttype) :: loadbalanceiter
       end module inputparallel

       module inputphysics ! in :sumb:../../modules/inputParam.f90
         use precision

         integer(kind=inttype) :: equations
         integer(kind=inttype) :: equationmode
         integer(kind=inttype) :: flowtype
         integer(kind=inttype) :: turbmodel
         integer(kind=inttype) :: cpmodel
         integer(kind=inttype) :: turbprod
         integer(kind=inttype) :: rvfn
         logical :: rvfb
         logical :: wallfunctions
         real(kind=realtype) :: mach
         real(kind=realtype) :: machcoef
         real(kind=realtype) :: machgrid
         real(kind=realtype) :: reynolds
         real(kind=realtype) :: reynoldslength
         real(kind=realtype) :: gammaconstant
         real(kind=realtype) :: rgasdim
         real(kind=realtype) :: prandtl
         real(kind=realtype) :: prandtlturb
         real(kind=realtype) :: pklim
         real(kind=realtype) :: walloffset
         real(kind=realtype) :: eddyvisinfratio
         real(kind=realtype) :: turbintensityinf
         real(kind=realtype) :: surfaceref
         real(kind=realtype) :: lengthref
         real(kind=realtype) dimension(3) :: veldirfreestream
         real(kind=realtype) dimension(3) :: liftdirection
         real(kind=realtype) dimension(3) :: dragdirection
         real(kind=realtype) dimension(3) :: pointref
         real(kind=realtype) dimension(3) :: pointrefec
         logical :: forcesastractions
         real(kind=realtype) :: ssuthdim
         real(kind=realtype) :: musuthdim
         real(kind=realtype) :: tsuthdim
         real(kind=realtype) :: walldistcutoff
       end module inputphysics

       module inputadjoint ! in :sumb:../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: adjointpcside
         character(len=maxstringlen) :: matrixordering
         character(len=maxstringlen) :: adjointsolvertype
         character(len=maxstringlen) :: localpctype
         character(len=maxstringlen) :: precondtype
         real(kind=realtype) :: adjabstol
         real(kind=realtype) :: adjdivtol
         real(kind=realtype) :: adjreltol
         real(kind=realtype) :: adjreltolrel
         integer(kind=inttype) :: overlap
         integer(kind=inttype) :: adjmonstep
         integer(kind=inttype) :: filllevel
         integer(kind=inttype) :: adjmaxiter
         integer(kind=inttype) :: adjrestart
         integer(kind=inttype) :: innerpreconits
         integer(kind=inttype) :: outerpreconits
         logical :: approxpc
         logical :: adpc
         logical :: viscpc
         logical :: frozenturbulence
         logical :: usediagtspc
         logical :: restartadjoint
         logical :: setmonitor
         logical :: printtiming
         logical :: firstrun
         logical :: verifystate
         logical :: verifyspatial
         logical :: verifyextra
         logical :: usematrixfreedrdw
         integer(kind=inttype) :: applyadjointpcsubspacesize
       end module inputadjoint

       module inputtimespectral ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) :: ntimeintervalsspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: dscalar
         real(kind=realtype) allocatable,dimension(:,:,:) :: dvector
         real(kind=realtype) :: dtunsteadyrestartspectral
         logical :: writeunsteadyrestartspectral
         integer(kind=inttype) :: nunsteadysolspectral
         logical :: writeunsteadyvolspectral
         logical :: writeunsteadysurfspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: rotmatrixspectral
       end module inputtimespectral
              module inputoverset
         logical :: lowoversetmemory
         real(kind=realtype) :: nearwalldist
         real(kind=realtype) :: backgroundvolscale
         real(kind=realtype) :: oversetprojtol
         real(kind=realtype) :: overlapfactor
         logical :: debugzipper
       end module inputoverset

       module inputunsteady ! in :test:inputParam.f90
         use accuracy
         real(kind=realtype) :: deltat
         logical :: useale
         integer(kind=inttype) :: timeintegrationscheme
         logical :: updatewalldistanceunsteady
         integer(kind=inttype) :: timeaccuracy
         integer(kind=inttype) :: ntimestepsfine
         integer(kind=inttype) :: ntimestepscoarse
       end module inputunsteady

       module iteration ! in :sumb:../../modules/iteration.f90
         use precision
         integer(kind=inttype) :: groundlevel
         integer(kind=inttype) :: currentlevel
         integer(kind=inttype) :: rkstage
         integer(kind=inttype) :: nstepscycling
         integer(kind=inttype) allocatable,dimension(:) :: cycling
         integer(kind=inttype) :: itertot
         real(kind=realtype) :: rfil
         real(kind=realtype) :: t0solver
         logical :: converged
         logical :: exchangepressureearly
         logical :: standalonemode
         logical :: changing_grid
         logical :: deforming_grid
         logical :: changingoverset
         integer(kind=inttype) :: noldsolavail
         integer(kind=inttype) :: noldlevels
         real(kind=realtype) allocatable,dimension(:) :: coeftime
         logical :: timespectralgridsnotwritten
         logical, dimension(:), allocatable :: oldsolwritten       
       end module iteration

       module monitor ! in :sumb:../../modules/monitor.f90
         use constants
         integer :: nmonsum
         integer :: nmonmax
         integer :: nmon
         real(kind=realtype) allocatable,dimension(:) :: monloc
         real(kind=realtype) allocatable,dimension(:) :: monglob
         real(kind=realtype) allocatable,dimension(:) :: monref
         character(len=32) allocatable,dimension(:) :: monnames
         logical :: monmachorhmax
         logical :: showcpu
         logical :: monmasssliding
         logical :: monmassfamilies
         integer :: nitercur
         real(kind=realtype) allocatable,dimension(:,:,:) :: convarray
         integer(kind=inttype) :: ntimestepsrestart
         integer(kind=inttype) :: timestepunsteady
         real(kind=realtype) :: timeunsteady
         real(kind=realtype) :: timeunsteadyrestart
         real(kind=realtype) allocatable,dimension(:) :: timearray
         real(kind=realtype) allocatable,dimension(:,:) :: timedataarray
         logical :: writegrid
         logical :: writevolume
         logical :: writesurface
       end module monitor

       module block ! in :sumb:../../modules/block.f90
         use constants
         integer(kind=inttype) :: ndom
         integer(kind=inttype) allocatable,dimension(:) :: ncellglobal
       end module block

       module flowvarrefstate ! in :sumb:../../modules/flowVarRefState.f90
         use constants
         integer(kind=inttype) :: nw
         integer(kind=inttype) :: nwf
         integer(kind=inttype) :: nwt
         integer(kind=inttype) :: nt1
         integer(kind=inttype) :: nt2
         real(kind=realtype) :: pref
         real(kind=realtype) :: rhoref
         real(kind=realtype) :: tref
         real(kind=realtype) :: muref
         real(kind=realtype) :: timeref
         real(kind=realtype) :: lref
         logical :: lrefspecified
         real(kind=realtype) :: pinfdim
         real(kind=realtype) :: rhoinfdim
         real(kind=realtype) :: tinfdim
         real(kind=realtype) :: mudim
         real(kind=realtype) :: rhoinf
         real(kind=realtype) :: uinf
         real(kind=realtype) :: pinf
         real(kind=realtype) :: pinfcorr
         real(kind=realtype) :: rgas
         real(kind=realtype) :: muinf
         real(kind=realtype) :: gammainf
         real(kind=realtype) allocatable,dimension(:) :: winf
         logical :: kpresent
         logical :: eddymodel
         logical :: viscous
       end module flowvarrefstate

       module killsignals ! in :sumb:../../modules/killSignals.f90
         use precision
         logical :: frompython
         logical :: routinefailed
         logical :: fatalfail
         logical :: adjointfailed
       end module killsignals

       module costfunctions ! in :test:costFunctions.F90
          use constants
            integer(kind=inttype) :: ncostfunction
            integer(kind=inttype) parameter,optional :: costfunccdq=30
            integer(kind=inttype) parameter,optional :: costfuncforcezcoef=10
            integer(kind=inttype) parameter,optional :: costfuncmomzcoef=16
            integer(kind=inttype) parameter,optional :: costfunccm0=17
            integer(kind=inttype) parameter,optional :: costfuncforcex=5
            integer(kind=inttype) parameter,optional :: costfuncclq=25
            integer(kind=inttype) parameter,optional :: costfuncdrag=2
            integer(kind=inttype) parameter,optional :: costfunccl0=22
            integer(kind=inttype) parameter,optional :: costfunccmzqdot=21
            integer(kind=inttype) parameter,optional :: costfuncforcexcoef=8
            integer(kind=inttype) parameter,optional :: costfunccmzq=20
            integer(kind=inttype) parameter,optional :: costfunccmzalphadot=19
            integer(kind=inttype) parameter,optional :: costfunclift=1
            integer(kind=inttype) parameter,optional :: costfunccd0=27
            integer(kind=inttype) parameter,optional :: costfuncclqdot=26
            integer(kind=inttype) parameter,optional :: costfuncforcey=6
            integer(kind=inttype) parameter,optional :: costfuncforcez=7
            integer(kind=inttype) parameter,optional :: costfuncmomz=13
            integer(kind=inttype) parameter,optional :: costfunccdqdot=31
            integer(kind=inttype) parameter,optional :: costfuncmomx=11
            integer(kind=inttype) parameter,optional :: costfuncmomy=12
            integer(kind=inttype) parameter,optional :: costfunccdalphadot=29
            integer(kind=inttype) parameter,optional :: costfuncmomxcoef=14
            integer(kind=inttype) parameter,optional :: costfunccdalpha=28
            integer(kind=inttype) parameter,optional :: costfuncliftcoef=3
            integer(kind=inttype) parameter,optional :: costfunccmzalpha=18
            integer(kind=inttype) parameter,optional :: costfuncdragcoef=4
            integer(kind=inttype) parameter,optional :: costfuncclalphadot=24
            integer(kind=inttype) parameter,optional :: costfuncforceycoef=9
            integer(kind=inttype) parameter,optional :: costfuncclalpha=23
            integer(kind=inttype) parameter,optional :: costfuncmomycoef=15
            integer(kind=inttype) parameter,optional :: costfunccfy0=32	
            integer(kind=inttype) parameter,optional :: costfunccfyalpha=33 
            integer(kind=inttype) parameter,optional :: costfunccfyalphadot=34
            integer(kind=inttype) parameter,optional :: costfunccfyq=35
            integer(kind=inttype) parameter,optional :: costfunccfyqdot=36
            integer(kind=inttype) parameter,optional :: costfuncbendingcoef=37
            integer(kind=inttype) parameter,optional :: costfuncsepsensor=38
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgx=39
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgy=40
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgz=41
            integer(kind=inttype) parameter,optional :: costfunccavitation=42
            real(kind=realtype) dimension(42) :: funcvalues
            real(kind=realtype) sepsensoroffset
            real(kind=realtype) sepsensorsharpness
       end module costfunctions
      
       module adjointvars ! in :test:ADjointVars.F90
         use constants
         use costfunctions
         integer(kind=inttype) :: ncellslocal(20)
         integer(kind=inttype) :: nnodeslocal(20)
         integer(kind=inttype) :: ndesignpointrefz
         integer(kind=inttype) :: ndesignpointrefy
         integer(kind=inttype) :: ndesignssa
         integer(kind=inttype) :: ndesignextra
         integer(kind=inttype) :: ndesignrotcenx
         integer(kind=inttype) :: ndesignpointrefx
         integer(kind=inttype) :: ndesignrotz
         integer(kind=inttype) :: ndesignrotx
         integer(kind=inttype) :: ndesignroty
         integer(kind=inttype) :: ndesignrotcenz
         integer(kind=inttype) :: ndesignaoa
         integer(kind=inttype) :: ndesignrotceny
         integer(kind=inttype) :: ndesignmachgrid
         integer(kind=inttype) :: ndesignmach
         integer(kind=inttype) :: ndesignlengthref
         integer(kind=inttype) :: ndesignsurfaceref
         integer(kind=inttype) :: ndesigndisserror
         integer(kind=inttype) :: ndesignpressure
         integer(kind=inttype) :: ndesigntemperature
         integer(kind=inttype) :: ndesigndensity
       end module adjointvars

       module adjointpetsc
         real(kind=realtype) :: adjresinit, adjresstart, adjresfinal
       end module adjointpetsc

       module inputtsstabderiv ! in :test:inputParam.f90
         logical :: usewindaxis
         logical :: tsrmode
         logical :: tsstability
         logical :: tsbetamode
         logical :: tsmachmode
         logical :: tsaltitudemode
         logical :: tspmode
         logical :: tsqmode
         logical :: tsalphamode
         logical :: tsalphafollowing 
       end module inputtsstabderiv

        module surfacefamilies ! in :test:inputParam.F90
          integer(kind=inttype), allocatable,dimension(:) :: famgroups
          character(len=32), dimension(:), allocatable :: famnames
          integer(kind=inttype), allocatable,dimension(:) :: famiswall
        end module surfacefamilies

       module nksolvervars ! in :test:NKsolverVars.F90
         use constants
         integer(kind=inttype) :: nk_innerpreconits
         integer(kind=inttype) :: nk_outerpreconits
         integer(kind=inttype) :: nk_jacobianlag
         logical :: usenksolver
         logical :: nk_adpc
         logical :: nk_useew
         logical :: nk_viscpc
         logical :: rkreset
         integer(kind=inttype) :: nk_ls
         integer(kind=inttype) :: nk_subspace
         integer(kind=inttype) :: nk_asmoverlap
         real(kind=realtype) :: nk_rtolinit
         integer(kind=inttype) :: nk_ilufill
         real(kind=realtype) :: nk_switchtol
         real(kind=realtype) :: nk_cfl0
         real(kind=realtype) :: totalr0
         real(kind=realtype) :: totalrstart
         real(kind=realtype) :: totalrfinal
         integer(kind=inttype) :: applypcsubspacesize
         logical :: freestreamresset
       end module nksolvervars

       module anksolvervars ! in :test:NKsolverVars.F90
         use constants
         integer(kind=inttype) :: ank_innerpreconits
         integer(kind=inttype) :: ank_jacobianlag
         logical :: useanksolver
         logical :: ank_useturbdadi
         integer(kind=inttype) :: ank_subspace
         integer(kind=inttype) :: ank_asmoverlap
         real(kind=realtype) :: ank_rtol
         integer(kind=inttype) :: ank_ilufill
         real(kind=realtype) :: ank_switchtol
         real(kind=realtype) :: ank_cfl0
       end module anksolvervars
    end interface 

#ifdef USE_COMPLEX
end python module libsumb_cs
#else
end python module libsumb
#endif



!    -*- f90 -*-
python module solverunsteadyale__user__routines 
    interface solverunsteadyale_user_interface 
        subroutine alecallback_python(t) ! in :test:solverUnsteady_ALE.f90
            real(kind=realtype) :: t
        end subroutine alecallback_python
    end interface solverunsteadyale_user_interface
end python module solverunsteadyale__user__routines

#ifdef USE_COMPLEX
python module libsumb_cs ! in 
#else
python module libsumb
#endif
    interface  ! in :sumb

       ! ############################################################################
       ! SUmb Routines
       ! ############################################################################
        subroutine openlog(filename) ! in :test:log.F90
          character*(*) :: filename
        end subroutine openlog
        
        subroutine closelog()
        end subroutine closelog

       subroutine writeintromessage ! in :sumb:../../utils/initExec.F90
       end subroutine writeintromessage
       
       subroutine readparamfile ! in :sumb:../../inputParam/readParamFile.f90
       end subroutine readparamfile
       
       subroutine setdefaultvalues()
       end subroutine setdefaultvalues

       subroutine monitorvariables(variables) ! in :test:monitorVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine monitorvariables
       
       subroutine surfacevariables(variables) ! in :test:surfaceVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine surfacevariables

       subroutine volumevariables(variables) ! in :test:volumeVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine volumevariables

       subroutine isovariables(variables) ! in :test:volumeVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine isovariables

       subroutine initializeisosurfacevariables(values,nvalues) ! in :test:setIsoSurfaceValues.F90
         real(kind=realtype), dimension(nvalues),intent(in) :: values
         integer(kind=inttype), optional,intent(in),check(len(values)>=nvalues),depend(values) :: nvalues=len(values)
       end subroutine initializeisosurfacevariables
 
       subroutine setisosurfacevariable(variable,ivar) ! in :test:setIsoSurfaceValues.F90
         character*(*), intent(in) :: variable
         integer(kind=inttype), intent(in) :: ivar
       end subroutine setisosurfacevariable
       
       subroutine addparaslice(slicename,pt,direction,mask,nmask) ! in :test:liftDistribution.F90
         character*(*) intent(in) :: slicename
         real(kind=realtype) dimension(3),intent(in) :: pt
         real(kind=realtype) dimension(3),intent(in) :: direction
         integer(kind=inttype) dimension(nmask),intent(in) :: mask
         integer(kind=inttype), optional,intent(in),check(len(mask)>=nmask),depend(mask)
       end subroutine addparaslice

       subroutine addabsslice(slicename,pt,direction,mask,nmask) ! in :test:liftDistribution.F90
         character*(*) intent(in) :: slicename
         real(kind=realtype) dimension(3),intent(in) :: pt
         real(kind=realtype) dimension(3),intent(in) :: direction
         integer(kind=inttype) dimension(nmask),intent(in) :: mask
         integer(kind=inttype), optional,intent(in),check(len(mask)>=nmask),depend(mask)
       end subroutine addabsslice

       subroutine addliftdistribution(nsegments,dir_vec,dir_ind, distname, mask, nmask) ! in :test:liftDistribution.F90
         integer(kind=inttype) intent(in) :: nsegments
         real(kind=realtype) dimension(3), intent(in) :: dir_vec
         integer(kind=inttype), intent(in) :: dir_ind
         character*(*) intent(in) :: distname
         integer(kind=inttype) dimension(nmask),intent(in) :: mask
         integer(kind=inttype), optional,intent(in),check(len(mask)>=nmask),depend(mask)
       end subroutine addliftdistribution
       
       subroutine writeliftdistributionfile(filename)
         character*(*), intent(in) :: filename
       end subroutine writeliftdistributionfile

       subroutine writeslicesfile(filename)
         character*(*), intent(in) :: filename
       end subroutine writeslicesfile

       subroutine dummyreadparamfile ! in :sumb:../../inputParam/readParamFile.f90
       end subroutine dummyreadparamfile
       
       subroutine partitionandreadgrid(partitiononly) ! in :sumb:../../partitioning/partitionAndReadGrid.f90
         logical :: partitiononly
       end subroutine partitionandreadgrid

       subroutine preprocessing ! in :sumb:../../preprocessing/preprocessing.f90
       end subroutine preprocessing

       subroutine preprocessingpart2 ! in :sumb:../../preprocessing/preprocessing.f90
       end subroutine preprocessingpart2
     
       subroutine initflow ! in :sumb:../../initFlow/initFlow.f90
       end subroutine initflow

       subroutine initflowpart2 ! in :sumb:../../initFlow/initFlow.f90
       end subroutine initflowpart2

       subroutine updategamma
       end subroutine updategamma

       subroutine updatecoordinatesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updatecoordinatesalllevels

       subroutine updatemetricsalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updatemetricsalllevels

       subroutine updategridvelocitiesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updategridvelocitiesalllevels

       subroutine updateperiodicinfoalllevels
       end subroutine updateperiodicinfoalllevels

       subroutine updateflow
       end subroutine updateflow

       subroutine referencestate
       end subroutine referencestate

       subroutine setflowinfinitystate
       end subroutine setflowinfinitystate

       subroutine updatereferencepoint
       end subroutine updatereferencepoint

       subroutine updaterotationrate(rotcenter,rotrate,blocks,nblocks) ! in :test:updateRotationRate.f90
         real(kind=realtype) dimension(3),intent(in) :: rotcenter
         real(kind=realtype) dimension(3),intent(in) :: rotrate
         integer(kind=inttype) dimension(nblocks),intent(in) :: blocks
         integer(kind=inttype), optional,intent(in),check(len(blocks)>=nblocks),depend(blocks) :: nblocks=len(blocks)
       end subroutine updaterotationrate

       subroutine adjustinflowangle(alpha, beta, liftindex)
         real(kind=realtype) intent(in) :: alpha
         real(kind=realtype) intent(in):: beta
         integer(kind=inttype) intent(in) :: liftindex
       end subroutine adjustinflowangle

       subroutine setuniformflow
       end subroutine setuniformflow

       subroutine initdepvarandhalos(halosread)
         logical intent(in) :: halosread
       end subroutine initdepvarandhalos

       subroutine allocconvarrays(nitertot) ! in :sumb:../../initFlow/allocConvArrays.f90
         integer(kind=inttype) :: nitertot
       end subroutine allocconvarrays

       subroutine alloctimearrays(nitertot) ! in :sumb:../../initFlow/allocTimeArrays.f90
         integer(kind=inttype) :: ntimetot
       end subroutine alloctimearrays

       subroutine solver ! in :sumb:../../solver/solver.F90
       end subroutine solver

       subroutine checkpartitioning(np,load_inbalance,face_inbalance) ! in :test:checkPartitioning.f90
         integer(kind=inttype) intent(in) :: np
         real(kind=realtype) intent(out) :: load_inbalance
         real(kind=realtype) intent(out) :: face_inbalance
       end subroutine checkpartitioning

       subroutine writesol ! in :sumb:../../output/writeSol.f90
       end subroutine writesol

       subroutine updatewalldistancealllevels ! in :sumb:../../wallDistance/updateWallDistanceAllLevels.f90
       end subroutine updatewalldistancealllevels

       subroutine updateslidingalllevels ! in :sumb:../../slidingComm/updateSlidingAllLevels.f90
       end subroutine updateslidingalllevels

       subroutine solversteady ! in :sumb:../../solver/solverSteady.f90
       end subroutine solversteady

       subroutine inittimesteppart1 ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine inittimesteppart1

       subroutine inittimesteppart2 ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine inittimesteppart2

       subroutine solvestate ! in :sumb:../../solver/solveState.F90
       end subroutine solvestate

       subroutine checkwriteunsteadyinloop ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine checkwriteunsteadyinloop

       subroutine checkwriteunsteadyendloop ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine checkwriteunsteadyendloop

       subroutine getsolution(sps) ! in :test:getSolution.f90
         integer(kind=inttype) :: sps
        end subroutine getsolution

        subroutine setfullmask
        end subroutine setfullmask
        
        subroutine setmask
        end subroutine setmask

        subroutine setnmaskfams(n)
          integer(kind=inttype), intent(in) :: n
        end subroutine setnmaskfams
        
        subroutine setmaskfam(i, fam)
          integer(kind=inttype), intent(in) :: i
          character(32), intent(in) :: fam
        end subroutine setmaskfam

       ! ############################################################################
       ! Added by HDN
       ! ############################################################################
       subroutine solverunsteady_ale(alecallback_python) ! in :test:solverUnsteady_ALE.F90
         use solverunsteadyale__user__routines
         external alecallback_python
       end subroutine solverunsteady_ale

       ! For operations related to mesh-warping
       subroutine shiftcoorandvolumes ! in :sumb:../../preprocessing/shiftCoorAndVolumes.F90
       end subroutine shiftcoorandvolumes

       subroutine shiftlevelale ! in :sumb:../../sovler/geomUtilsALE.F90
       end subroutine shiftlevelale

       subroutine solverunsteadywrapbegin ! in :sumb:../../solver/solverUnsteadyWrap.F90
       end subroutine solverunsteadyerapbegin

       subroutine solverunsteadywrapinloop ! in :sumb:../../solver/solverUnsteadyWrap.F90
       end subroutine solverunsteadywrapinloop

       subroutine solverunsteadywrapend ! in :sumb:../../solver/solverUnsteadyWrap.F90
       end subroutine solverunsteadywrapend
     
       subroutine getheatflux(hflux,npts,sps_in) ! in :test:getHeatFlux.f90
         real(kind=realtype) dimension(npts),intent(out),depend(npts) :: hflux
         integer(kind=inttype) intent(in) :: npts
         integer(kind=inttype) intent(in) :: sps_in
       end subroutine getheatflux

       subroutine heatfluxes ! in :test:getHeatFlux.f90
       end subroutine heatfluxes

       subroutine settnswall(tnsw,npts,sps_in) ! in :test:setTNSWall.f90
         real(kind=realtype) dimension(npts),intent(in) :: tnsw
         integer(kind=inttype) optional,intent(in),check(len(tnsw)>=npts),depend(tnsw) :: npts=len(tnsw)
         integer(kind=inttype) intent(in) :: sps_in
       end subroutine settnswall

       ! ############################################################################
       ! SUmb Mesh/Forces Interface Routines
       ! ############################################################################

       subroutine getcgnsmeshindices(ndof,indices)
         integer(kind=inttype) intent(in) :: ndof
         integer(kind=inttype) dimension(ndof),intent(out),depend(ndof) :: indices
       end subroutine getcgnsmeshindices

       subroutine setgrid(grid,ndof) ! in :test:setGrid.f90
         real(kind=realtype) dimension(ndof),intent(in) :: grid
         integer(kind=inttype) optional,intent(in),check(len(grid)>=ndof),depend(grid) :: ndof=len(grid)
       end subroutine setgrid

       subroutine setgridsimple(grid,ndof) ! in :test:setGrid.f90
         real(kind=realtype) dimension(ndof),intent(in) :: grid
         integer(kind=inttype) optional,intent(in),check(len(grid)>=ndof),depend(grid) :: ndof=len(grid)
       end subroutine setgridsimple

       subroutine getgrid(grid,ndof) ! in :test:setGrid.f90
            real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: grid
            integer(kind=inttype) intent(in) :: ndof
        end subroutine getgrid

       subroutine getnpatches(npatches) ! in :test:getForces.f90
         integer(kind=inttype) intent(out) :: npatches
       end subroutine getnpatches
 
       subroutine getpatchname(ipatch,patchname) ! in :test:getForces.f90
         integer(kind=inttype) intent(in) :: ipatch
         character*(*) intent(inout) :: patchname
       end subroutine getpatchname

       subroutine getpatchsize(ipatch,patchsize) ! in :test:getForces.f90
         integer(kind=inttype) intent(in) :: ipatch
         integer(kind=inttype) dimension(2), intent(out) :: patchsize
       end subroutine getpatchsize

       subroutine getforcesize(npts, ncells) ! in :test:getForces.f90
         integer(kind=inttype) intent(out) :: npts
         integer(kind=inttype) intent(out) :: ncells
       end subroutine getforcesize

        subroutine getforceconnectivity(conn,ncell) ! in :test:getForces.f90
          integer(kind=inttype) dimension(4 * ncell),intent(inout) :: conn
          integer(kind=inttype) optional,intent(in),check((len(conn))/(4)>=ncell),depend(conn) :: ncell=(len(conn))/(4)
        end subroutine getforceconnectivity

        subroutine getforces(forces,npts,sps_in) ! in :test:getForces.f90
          real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: forces
          integer(kind=inttype) intent(in) :: npts
          integer(kind=inttype) intent(in) :: sps_in
        end subroutine getforces
        
        subroutine getforcepoints(points,npts,sps_in) ! in :test:getForces.f90
          integer(kind=inttype), intent(in) :: sps_in
          real(kind=realtype) dimension(3,npts),intent(inout) :: points
          integer(kind=inttype) optional,intent(in),check(shape(points,1)==npts),depend(points) :: npts=shape(points,1)
       end subroutine getforcepoints

       subroutine getareas(areas,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: areas
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareas

       subroutine getareasensitivity(darea,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: darea
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareasensitivity

       ! ############################################################################
       ! SUmb ADjoint Debugging Routines
       ! ############################################################################

       subroutine determinestencil(lumped)
         logical :: lumped 
       end subroutine determinestencil
       
       ! ############################################################################
       ! SUmb ADjoint Core Routines
       ! ############################################################################

       subroutine initializepetsc 
       end subroutine initializepetsc

       subroutine preprocessingadjoint 
       end subroutine preprocessingadjoint
    
       ! State Variables
       subroutine createpetscvars
       end subroutine createpetscvars

       subroutine destroypetscvars
       end subroutine destroypetscvars

       ! KSP Setup
       subroutine setuppetscksp 
       end subroutine setuppetscksp

       subroutine setupallresidualmatricesfwd
       end subroutine setupallresidualmatricesfwd


       subroutine solveadjoint(rhs,psi,checksolution,nstate) ! in :test:solveADjointTransposePETSc.F90
         real(kind=realtype) dimension(nstate) :: rhs
         real(kind=realtype) dimension(nstate),depend(nstate) :: psi
         logical :: checksolution
         integer(kind=inttype), optional,check(len(rhs)>=nstate),depend(rhs) :: nstate=len(rhs)
       end subroutine solveadjoint


        subroutine saveadjointmatrix(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
        end subroutine saveadjointmatrix
        subroutine saveadjointpc(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
          end subroutine saveadjointpc
          subroutine saveadjointrhs(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
          end subroutine saveadjointrhs

       ! -------- Partial Derivative Functions -----------
       
       ! -------- Get/Set Functions --------------------
       subroutine getstates(states,ndimw) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(ndimw),intent(out),depend(ndimw) :: states
         integer(kind=inttype) intent(in) :: ndimw
       end subroutine getstates

       subroutine setstates(states,ndimw) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(ndimw),intent(in) :: states
         integer(kind=inttype) optional,intent(in),check(len(states)>=ndimw),depend(states) :: ndimw=len(states)
       end subroutine setstates

       subroutine getinfosize(isize)
         integer(kind=inttype) intent(out) :: isize
       end subroutine getinfosize

       subroutine setinfo(info,isize) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(isize),intent(in) :: info
         integer(kind=inttype) optional,intent(in),check(len(info)>=isize),depend(info) :: isize=len(info)
       end subroutine setinfo

       subroutine getinfo(info,isize) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(isize),intent(out),depend(isize) :: info
         integer(kind=inttype) intent(in) :: isize
       end subroutine setinfo

       subroutine getres(res,ndimw) ! in :test:NKUtilities.F90
         real(kind=realtype) dimension(ndimw),intent(in,out) :: res
         integer(kind=inttype) optional,intent(in),check(len(res)>=ndimw),depend(res) :: ndimw=len(res)
       end subroutine getres

       subroutine spectralprecscribedmotion(input,nin,dxv,nout)
         real(kind=realtype) dimension(nin),intent(in) :: input
         integer(kind=inttype), optional,intent(in),check(len(input)>=nin),depend(input) :: nin=len(input)
         real(kind=realtype) dimension(nout),intent(out),depend(nout) :: dxv
         integer(kind=inttype) intent(in) :: nout
       end subroutine spectralprecscribedmotion
#ifndef USE_COMPLEX
        subroutine computematrixfreeproductfwd(xvdot,extradot,wdot,usespatial,usestate,dwdot,funcsdot,fdot,spatialsize,extrasize,statesize,costsize,fsize) ! in :test:matrixFreeRoutines.F90
            real(kind=realtype) dimension(spatialsize),intent(in) :: xvdot
            real(kind=realtype) dimension(extrasize),intent(in) :: extradot
            real(kind=realtype) dimension(statesize),intent(in) :: wdot
            logical intent(in) :: usespatial
            logical intent(in) :: usestate
            real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: dwdot
            real(kind=realtype) dimension(costsize),intent(out),depend(costsize) :: funcsdot
            real(kind=realtype) dimension(3,fsize),intent(out),depend(fsize) :: fdot
            integer(kind=inttype), optional,intent(in),check(len(xvdot)>=spatialsize),depend(xvdot) :: spatialsize=len(xvdot)
            integer(kind=inttype), optional,intent(in),check(len(extradot)>=extrasize),depend(extradot) :: extrasize=len(extradot)
            integer(kind=inttype), optional,intent(in),check(len(wdot)>=statesize),depend(wdot) :: statesize=len(wdot)
            integer(kind=inttype) intent(in) :: costsize
            integer(kind=inttype) intent(in) :: fsize
        end subroutine computematrixfreeproductfwd

        subroutine computematrixfreeproductbwd(dwbar,funcsbar,fbar,usespatial,usestate,xvbar,extrabar,wbar,spatialsize,extrasize,statesize,costsize,fsize) ! in :test:matrixFreeRoutines.F90
            real(kind=realtype) dimension(statesize),intent(in) :: dwbar
            real(kind=realtype) dimension(costsize),intent(in) :: funcsbar
            real(kind=realtype) dimension(3,fsize),intent(in) :: fbar
            logical intent(in) :: usespatial
            logical intent(in) :: usestate
            real(kind=realtype) dimension(spatialsize),intent(out),depend(spatialsize) :: xvbar
            real(kind=realtype) dimension(extrasize),intent(out),depend(extrasize) :: extrabar
            real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: wbar
            integer(kind=inttype) intent(in) :: spatialsize
            integer(kind=inttype) intent(in) :: extrasize
            integer(kind=inttype), optional,intent(in),check(len(dwbar)>=statesize),depend(dwbar) :: statesize=len(dwbar)
            integer(kind=inttype), optional,intent(in),check(len(funcsbar)>=costsize),depend(funcsbar) :: costsize=len(funcsbar)
            integer(kind=inttype), optional,intent(in),check(shape(fbar,1)==fsize),depend(fbar) :: fsize=shape(fbar,1)
        end subroutine computematrixfreeproductbwd

        subroutine computematrixfreeproductbwdfast(dwbar,wbar,statesize) ! in :test:test.F90
          real(kind=realtype) dimension(statesize),intent(in) :: dwbar
          real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: wbar
          integer(kind=inttype), optional,check(len(dwbar)>=statesize),depend(dwbar) :: statesize=len(dwbar)
        end subroutine computematrixfreeproductbwdfast
#endif
       ! ------------- Misc --------------------
 
       subroutine getliftdirfromsymmetry(liftdir)
         integer(kind=inttype), intent(out) :: liftdir
       end subroutine getliftdirfromsymmetry

       ! ############################################################################
       ! Newton-Krylov Solver Routines
       ! ############################################################################

       subroutine applypc(in_vec,out_vec,ndof) ! in :test:NKsolver.F90
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
         integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
       end subroutine applypc

       subroutine applyadjointpc(in_vec,out_vec,ndof) ! in :test:NKsolver.F90
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
         integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
       end subroutine applyadjointpc

       subroutine getcurrentresidual(rhores,totalrres)
         real(kind=realtype), intent(out) :: rhores
         real(kind=realtype), intent(out) :: totalrres
       end subroutine getcurrentresidual

       subroutine getfreestreamresidual(rhores,totalrres)
         real(kind=realtype), intent(out) :: rhores
         real(kind=realtype), intent(out) :: totalrres
       end subroutine getfreestreamresidual

       subroutine computeresidualnk
       end subroutine computeresidualnk

       subroutine setupnksolver
       end subroutine setupnksolver
       
       subroutine destroynksolver
       end subroutine destroynksolver
       
       ! ############################################################################
       ! Time Spectral Stability Routines
       ! ############################################################################

       subroutine stabilityderivativedriver
       end subroutine stabilityderivativedriver

       ! ############################################################################
       ! SUmb Modules
       ! ############################################################################
       module constants ! in :sumb:../../modules/constants.F90
         use precision
         integer parameter,optional :: maxstringlen   = 256
         integer parameter,optional :: maxcgnsnamelen =  32
       end module constants

       module communication ! in :sumb:../../modules/communication.f90
         use precision
         integer :: sumb_comm_world
         integer :: myid
         integer :: nproc
         integer(kind=inttype) :: sendbuffersize_1to1
         integer(kind=inttype) :: sendbuffersize
         integer(kind=inttype) :: recvbuffersize_1to1
         integer(kind=inttype) :: recvbuffersize
         integer(kind=inttype) :: sendbuffersizeover
         integer(kind=inttype) :: recvbuffersizeover
         real(kind=realtype) allocatable,dimension(:) :: sendbuffer
         real(kind=realtype) allocatable,dimension(:) :: recvbuffer
         integer allocatable,dimension(:) :: sendrequests
         integer allocatable,dimension(:) :: recvrequests
       end module communication

       module inputdiscretization ! in :sumb:../../modules/inputParam.f90
         use accuracy
         integer(kind=inttype) parameter,optional :: dissscalar=1_inttype
         integer(kind=inttype) parameter,optional :: dissmatrix=2_inttype
         integer(kind=inttype) parameter,optional :: disscusp=3_inttype
         integer(kind=inttype) parameter,optional :: upwind=9_inttype
         integer(kind=inttype) parameter,optional :: roe=1_inttype
         integer(kind=inttype) parameter,optional :: vanleer=2_inttype
         integer(kind=inttype) parameter,optional :: ausmdv=3_inttype
         integer(kind=inttype) parameter,optional :: nolimiter=2_inttype
         integer(kind=inttype) parameter,optional :: vanalbeda=3_inttype
         integer(kind=inttype) parameter,optional :: minmod=4_inttype
         integer(kind=inttype) parameter,optional :: noprecond=1_inttype
         integer(kind=inttype) parameter,optional :: turkel=2_inttype
         integer(kind=inttype) parameter,optional :: choimerkle=3_inttype
         integer(kind=inttype) parameter,optional :: constantpressure=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapolpressure=2_inttype
         integer(kind=inttype) parameter,optional :: quadextrapolpressure=3_inttype
         integer(kind=inttype) parameter,optional :: normalmomentum=4_inttype
         integer(kind=inttype) parameter,optional :: constantextrapol=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapol=2_inttype
         integer(kind=inttype) :: spacediscr
         integer(kind=inttype) :: spacediscrcoarse
         integer(kind=inttype) :: orderturb
         integer(kind=inttype) :: limiter
         integer(kind=inttype) :: riemann
         integer(kind=inttype) :: riemanncoarse
         integer(kind=inttype) :: precond
         integer(kind=inttype) :: wallbctreatment
         integer(kind=inttype) :: outflowtreatment
         real(kind=realtype) :: vis2
         real(kind=realtype) :: vis4
         real(kind=realtype) :: vis2coarse
         real(kind=realtype) :: adis
         real(kind=realtype) :: kappacoef
         logical :: vortexcorr
         logical :: dirscaling
         logical :: radiineededfine
         logical :: radiineededcoarse
         logical :: lumpeddiss
         real(kind=realtype) :: sigma
         logical :: useapproxwalldistance
         logical :: lowspeedpreconditioner
       end module inputdiscretization

       module cgnsgrid
         use constants
         integer(kind=inttype) :: cgnsndom
       end module cgnsgrid

       module inputio ! in :sumb:../../modules/inputParam.f90
         use constants
         integer(kind=inttype) parameter,optional :: noformat=0
         character(len=maxstringlen) :: solfile
         integer(kind=inttype) parameter,optional :: precisiondouble=2
         character(len=maxstringlen) :: surfacesolfile
         character(len=maxstringlen) :: cpfile
         logical :: writecoormeter
         integer(kind=inttype) :: precisionsol
         integer(kind=inttype) :: precisiongrid
         integer(kind=inttype) parameter,optional :: cgnsformat=1
         character(len=maxstringlen) :: newgridfile
         character(len=maxstringlen) :: restartfile
         logical :: restart
         character(len=maxstringlen) :: plot3dconnfile
         integer(kind=inttype) :: fileformatread
         character(len=maxstringlen) :: gridfile
         logical :: storeconvinneriter
         logical :: storerindlayer
         logical :: checkrestartsol
         logical :: autoparameterupdate
         logical :: writesymmetry
         logical :: writefarfield
         logical :: viscoussurfacevelocities
         logical :: slicefiletractions
         integer(kind=inttype) parameter,optional :: precisionsingle=1
         logical optional :: firstwrite=.true.
         integer(kind=inttype) :: fileformatwrite
         integer(kind=inttype) parameter,optional :: plot3dformat=2
         character(len=maxstringlen) :: paramfile
       end module inputio

       module localmg ! in :test:localModules.f90
         use constants
         character(len=maxstringlen) :: mgdescription
       end module localmg

       module inputiteration ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) parameter,optional :: rungekutta=1_inttype
         integer(kind=inttype) parameter,optional :: dadi=2_inttype
         integer(kind=inttype) parameter,optional :: nllusgs=3_inttype
         integer(kind=inttype) parameter,optional :: nllusgsline=4_inttype
         integer(kind=inttype) parameter,optional :: segregated=1_inttype
         integer(kind=inttype) parameter,optional :: coupled=2_inttype
         integer(kind=inttype) parameter,optional :: gmres=1_inttype
         integer(kind=inttype) parameter,optional :: adi=2_inttype
         integer(kind=inttype) parameter,optional :: bcdirichlet0=0_inttype
         integer(kind=inttype) parameter,optional :: bcneumann=1_inttype
         integer(kind=inttype) parameter,optional :: noresaveraging=0_inttype
         integer(kind=inttype) parameter,optional :: alwaysresaveraging=1_inttype
         integer(kind=inttype) parameter,optional :: alternateresaveraging=2_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxnotdefined=0_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxexplicit=1_inttype
         integer(kind=inttype) parameter,optional :: turbrelaximplicit=2_inttype
         integer(kind=inttype) :: ncycles
         integer(kind=inttype) :: ncyclescoarse
         integer(kind=inttype) :: nsavevolume
         integer(kind=inttype) :: nsavesurface
         integer(kind=inttype) :: nsgstartup
         integer(kind=inttype) :: smoother
         integer(kind=inttype) :: nrkstages
         integer(kind=inttype) :: resaveraging
         real(kind=realtype) :: cfllimit
         integer(kind=inttype) :: turbtreatment
         integer(kind=inttype) :: nsubiterturb
         integer(kind=inttype) :: nsubiterations
         integer(kind=inttype) :: turbsmoother
         integer(kind=inttype) :: turbrelax
         integer(kind=inttype) :: mgboundcorr
         integer(kind=inttype) :: mgstartlevel
         integer(kind=inttype) :: nmgsteps
         integer(kind=inttype) :: nmglevels
         integer(kind=inttype) :: miniternum
         integer(kind=inttype) :: convcheckwindowsize
         integer(kind=inttype) allocatable,dimension(:) :: cyclestrategy
         real(kind=realtype) :: cfl
         real(kind=realtype) :: cflcoarse
         real(kind=realtype) :: fcoll
         real(kind=realtype) :: smoop
         real(kind=realtype) :: alfaturb
         real(kind=realtype) :: betaturb
         real(kind=realtype) :: l2conv
         real(kind=realtype) :: l2convcoarse
         real(kind=realtype) :: l2convrel
         real(kind=realtype) :: epscoefconv
         real(kind=realtype) allocatable,dimension(:) :: etark
         real(kind=realtype) allocatable,dimension(:) :: cdisrk
         real(kind=realtype), dimension(4) :: turbresscale
         logical :: freezeturbsource
         logical :: printiterations
         logical :: printwarnings
       end module inputiteration

       module inputmotion ! in :sumb:../../modules/inputParam.f90
         use precision
         real(kind=realtype), dimension(3) :: rotpoint
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouryrot
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourxrot
         integer(kind=inttype) :: degreefourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouralpha
         real(kind=realtype) :: omegafourbeta
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourbeta
         integer(kind=inttype) :: degreepolbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourmach
         integer(kind=inttype) :: degreepolmach
         real(kind=realtype) :: omegafourmach
         integer(kind=inttype) :: degreepolalpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolmach
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourmach
         real(kind=realtype) allocatable,dimension(:) :: coefpolzrot
         logical :: gridmotionspecified
         real(kind=realtype) :: omegafourzrot
         integer(kind=inttype) :: degreefouryrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolyrot
         integer(kind=inttype) :: degreefourbeta
         real(kind=realtype) :: omegafouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourzrot
         integer(kind=inttype) :: degreepolzrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourzrot
         real(kind=realtype) :: omegafouryrot
         integer(kind=inttype) :: degreefourzrot
         integer(kind=inttype) :: degreefourmach
         integer(kind=inttype) :: degreefouralpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolalpha
         real(kind=realtype) :: omegafourxrot
         integer(kind=inttype) :: degreepolyrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouryrot
         integer(kind=inttype) :: degreepolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolbeta
       end module inputmotion
       
       module inputparallel ! in :sumb:../../modules/inputParam.f90
         real(kind=realtype) :: loadimbalance
         logical :: splitblocks
         integer(kind=inttype) :: loadbalanceiter
       end module inputparallel

       module inputphysics ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) parameter,optional :: eulerequations=1_inttype
         integer(kind=inttype) parameter,optional :: nsequations=2_inttype
         integer(kind=inttype) parameter,optional :: ransequations=3_inttype
         integer(kind=inttype) parameter,optional :: steady=1_inttype
         integer(kind=inttype) parameter,optional :: unsteady=2_inttype
         integer(kind=inttype) parameter,optional :: timespectral=3_inttype
         integer(kind=inttype) parameter,optional :: internalflow=1_inttype
         integer(kind=inttype) parameter,optional :: externalflow=2_inttype
         integer(kind=inttype) parameter,optional :: cpconstant=1_inttype
         integer(kind=inttype) parameter,optional :: cptempcurvefits=2_inttype
         integer(kind=inttype) parameter,optional :: baldwinlomax=1_inttype
         integer(kind=inttype) parameter,optional :: spalartallmaras=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmarasedwards=3_inttype
         integer(kind=inttype) parameter,optional :: komegawilcox=4_inttype
         integer(kind=inttype) parameter,optional :: komegamodified=5_inttype
         integer(kind=inttype) parameter,optional :: ktau=6_inttype
         integer(kind=inttype) parameter,optional :: mentersst=7_inttype
         integer(kind=inttype) parameter,optional :: v2f=10_inttype
         integer(kind=inttype) parameter,optional :: strain=1_inttype
         integer(kind=inttype) parameter,optional :: vorticity=2_inttype
         integer(kind=inttype) parameter,optional :: katolaunder=3_inttype
         integer(kind=inttype) :: equations
         integer(kind=inttype) :: equationmode
         integer(kind=inttype) :: flowtype
         integer(kind=inttype) :: turbmodel
         integer(kind=inttype) :: cpmodel
         integer(kind=inttype) :: turbprod
         integer(kind=inttype) :: rvfn
         logical :: rvfb
         logical :: wallfunctions
         real(kind=realtype) :: mach
         real(kind=realtype) :: machcoef
         real(kind=realtype) :: machgrid
         real(kind=realtype) :: reynolds
         real(kind=realtype) :: reynoldslength
         real(kind=realtype) :: tempfreestream
         real(kind=realtype) :: gammaconstant
         real(kind=realtype) :: rgasdim
         real(kind=realtype) :: prandtl
         real(kind=realtype) :: prandtlturb
         real(kind=realtype) :: pklim
         real(kind=realtype) :: walloffset
         real(kind=realtype) :: eddyvisinfratio
         real(kind=realtype) :: turbintensityinf
         real(kind=realtype) :: surfaceref
         real(kind=realtype) :: lengthref
         real(kind=realtype) dimension(3) :: veldirfreestream
         real(kind=realtype) dimension(3) :: liftdirection
         real(kind=realtype) dimension(3) :: dragdirection
         real(kind=realtype) dimension(3) :: pointref
         real(kind=realtype) dimension(3) :: pointrefec
         logical :: forcesastractions
         real(kind=realtype) :: ssuthdim
         real(kind=realtype) :: musuthdim
         real(kind=realtype) :: tsuthdim
       end module inputphysics

       module inputadjoint ! in :sumb:../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: adjointpcside
         character(len=maxstringlen) :: matrixordering
         character(len=maxstringlen) :: adjointsolvertype
         character(len=maxstringlen) :: localpctype
         character(len=maxstringlen) :: precondtype
         real(kind=realtype) :: adjabstol
         real(kind=realtype) :: adjdivtol
         real(kind=realtype) :: adjreltol
         real(kind=realtype) :: adjreltolrel
         integer(kind=inttype) :: overlap
         integer(kind=inttype) :: adjmonstep
         integer(kind=inttype) :: filllevel
         integer(kind=inttype) :: adjmaxiter
         integer(kind=inttype) :: adjrestart
         integer(kind=inttype) :: innerpreconits
         integer(kind=inttype) :: outerpreconits
         logical :: approxpc
         logical :: adpc
         logical :: viscpc
         logical :: frozenturbulence
         logical :: usediagtspc
         logical :: restartadjoint
         logical :: setmonitor
         logical :: printtiming
         logical :: firstrun
         logical :: verifystate
         logical :: verifyspatial
         logical :: verifyextra
         logical :: usematrixfreedrdw
         integer(kind=inttype) :: applyadjointpcsubspacesize
       end module inputadjoint

       module inputtimespectral ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) :: ntimeintervalsspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: dscalar
         real(kind=realtype) allocatable,dimension(:,:,:) :: dvector
         real(kind=realtype) :: dtunsteadyrestartspectral
         logical :: writeunsteadyrestartspectral
         integer(kind=inttype) :: nunsteadysolspectral
         logical :: writeunsteadyvolspectral
         logical :: writeunsteadysurfspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: rotmatrixspectral
       end module inputtimespectral
       
       module inputunsteady ! in :test:inputParam.f90
         use accuracy
         integer(kind=inttype) parameter,optional :: bdf=1
         real(kind=realtype) :: deltat
         logical :: useale
         integer(kind=inttype) parameter,optional :: implicitrk=3
         integer(kind=inttype) :: timeintegrationscheme
         logical :: updatewalldistanceunsteady
         integer(kind=inttype) :: timeaccuracy
         integer(kind=inttype) parameter,optional :: explicitrk=2
         integer(kind=inttype) parameter,optional :: md=4
         integer(kind=inttype) :: ntimestepsfine
         integer(kind=inttype) :: ntimestepscoarse
       end module inputunsteady

       module inputoverset ! in :sumb:../../modules/inputParam.f90
         use precison
         integer(kind=inttype) parameter,optional :: trilinear=1_inttype
         logical :: oversetdonorsareguesses
         logical :: avgrestrictresforblanks
         integer(kind=inttype) :: oversetinterptype
         integer(kind=inttype) :: oversetinterptypecoarse
         real(kind=realtype) :: allowabledonorquality
       end module inputoverset

       module iteration ! in :sumb:../../modules/iteration.f90
         use precision
         integer(kind=inttype) :: groundlevel
         integer(kind=inttype) :: currentlevel
         integer(kind=inttype) :: rkstage
         integer(kind=inttype) :: nstepscycling
         integer(kind=inttype) allocatable,dimension(:) :: cycling
         integer(kind=inttype) :: nmgvar
         integer(kind=inttype) :: nt1mg
         integer(kind=inttype) :: nt2mg
         logical :: restricteddyvis
         logical :: turbsegregated
         logical :: turbcoupled
         integer(kind=inttype) :: itertot
         real(kind=realtype) :: rfil
         real(kind=realtype) :: t0solver
         logical :: converged
         logical :: exchangepressureearly
         logical :: standalonemode
         logical :: changing_grid
         logical :: deforming_grid
         logical :: changingoverset
         logical optional :: pv3initialized=.false.
         integer(kind=inttype) :: noldsolavail
         integer(kind=inttype) :: noldlevels
         real(kind=realtype) allocatable,dimension(:) :: coeftime
         logical :: timespectralgridsnotwritten
         logical, dimension(:), allocatable :: oldsolwritten       
       end module iteration

       module monitor ! in :sumb:../../modules/monitor.f90
         use constants
         integer parameter,optional :: fieldwidth=12
         integer parameter,optional :: decimalwidth=5
         integer :: nmonsum
         integer :: nmonmax
         integer :: nmon
         real(kind=realtype) allocatable,dimension(:) :: monloc
         real(kind=realtype) allocatable,dimension(:) :: monglob
         real(kind=realtype) allocatable,dimension(:) :: monref
         character(len=32) allocatable,dimension(:) :: monnames
         logical :: monmachorhmax
         logical :: showcpu
         logical :: monmasssliding
         logical :: monmassfamilies
         integer :: niterold
         integer :: nitercur
         real(kind=realtype) allocatable,dimension(:,:,:) :: convarray
         integer(kind=inttype) :: ntimestepsrestart
         integer(kind=inttype) :: timestepunsteady
         real(kind=realtype) :: timeunsteady
         real(kind=realtype) :: timeunsteadyrestart
         real(kind=realtype) allocatable,dimension(:) :: timearray
         real(kind=realtype) allocatable,dimension(:,:) :: timedataarray
         logical :: writegrid
         logical :: writevolume
         logical :: writesurface
         logical :: coeffconvcheck
       end module monitor

       module block ! in :sumb:../../modules/block.f90
         use constants
         integer(kind=portype) parameter,optional :: leftstarted=-1_portype
         integer(kind=portype) parameter,optional :: regular=0_portype
         integer(kind=portype) parameter,optional :: rightstarted=1_portype
         integer(kind=inttype) parameter,optional :: nosubinlet=0_inttype
         integer(kind=inttype) parameter,optional :: totalconditions=1_inttype
         integer(kind=inttype) parameter,optional :: massflow=2_inttype
         integer(kind=inttype) :: ndom
         integer(kind=inttype) allocatable,dimension(:) :: ncellglobal
       end module block

       module flowvarrefstate ! in :sumb:../../modules/flowVarRefState.f90
         use constants
         integer(kind=inttype) :: nw
         integer(kind=inttype) :: nwf
         integer(kind=inttype) :: nwt
         integer(kind=inttype) :: nt1
         integer(kind=inttype) :: nt2
         real(kind=realtype) :: pref
         real(kind=realtype) :: rhoref
         real(kind=realtype) :: tref
         real(kind=realtype) :: muref
         real(kind=realtype) :: timeref
         real(kind=realtype) :: lref
         logical :: lrefspecified
         real(kind=realtype) :: pinfdim
         real(kind=realtype) :: rhoinfdim
         real(kind=realtype) :: mudim
         real(kind=realtype) :: rhoinf
         real(kind=realtype) :: uinf
         real(kind=realtype) :: pinf
         real(kind=realtype) :: pinfcorr
         real(kind=realtype) :: rgas
         real(kind=realtype) :: muinf
         real(kind=realtype) :: gammainf
         real(kind=realtype) allocatable,dimension(:) :: winf
         logical :: kpresent
         logical :: eddymodel
         logical :: viscous
       end module flowvarrefstate

       module killsignals ! in :sumb:../../modules/killSignals.f90
         use precision
         integer(kind=inttype) parameter,optional :: nosignal=0_int_type
         integer(kind=inttype) parameter,optional :: signalwrite=1_int_type
         integer(kind=inttype) parameter,optional :: signalwritequit=2_int_type
         integer(kind=inttype) :: localsignal
         integer(kind=inttype) :: globalsignal
         logical :: frompython
         logical :: routinefailed
         logical :: fatalfail
         logical :: adjointfailed
       end module killsignals

       module costfunctions ! in :test:costFunctions.F90
          use constants
            integer(kind=inttype) :: ncostfunction
            integer(kind=inttype) parameter,optional :: costfunccdq=30
            integer(kind=inttype) parameter,optional :: costfuncforcezcoef=10
            integer(kind=inttype) parameter,optional :: costfuncmomzcoef=16
            integer(kind=inttype) parameter,optional :: costfunccm0=17
            integer(kind=inttype) parameter,optional :: costfuncforcex=5
            integer(kind=inttype) parameter,optional :: costfuncclq=25
            integer(kind=inttype) parameter,optional :: costfuncdrag=2
            integer(kind=inttype) parameter,optional :: costfunccl0=22
            integer(kind=inttype) parameter,optional :: costfunccmzqdot=21
            integer(kind=inttype) parameter,optional :: costfuncforcexcoef=8
            integer(kind=inttype) parameter,optional :: costfunccmzq=20
            integer(kind=inttype) parameter,optional :: costfunccmzalphadot=19
            real(kind=realtype) allocatable,dimension(:) :: functionvalue
            integer(kind=inttype) parameter,optional :: costfunclift=1
            integer(kind=inttype) parameter,optional :: costfunccd0=27
            integer(kind=inttype) parameter,optional :: costfuncclqdot=26
            integer(kind=inttype) parameter,optional :: costfuncforcey=6
            integer(kind=inttype) parameter,optional :: costfuncforcez=7
            integer(kind=inttype) parameter,optional :: costfuncmomz=13
            integer(kind=inttype) parameter,optional :: costfunccdqdot=31
            integer(kind=inttype) parameter,optional :: costfuncmomx=11
            integer(kind=inttype) parameter,optional :: costfuncmomy=12
            integer(kind=inttype) parameter,optional :: costfunccdalphadot=29
            integer(kind=inttype) parameter,optional :: costfuncmomxcoef=14
            integer(kind=inttype) parameter,optional :: costfunccdalpha=28
            integer(kind=inttype) parameter,optional :: costfuncliftcoef=3
            integer(kind=inttype) parameter,optional :: costfunccmzalpha=18
            integer(kind=inttype) parameter,optional :: costfuncdragcoef=4
            integer(kind=inttype) parameter,optional :: costfuncclalphadot=24
            integer(kind=inttype) parameter,optional :: costfuncforceycoef=9
            integer(kind=inttype) parameter,optional :: costfuncclalpha=23
            integer(kind=inttype) parameter,optional :: costfuncmomycoef=15
            integer(kind=inttype) parameter,optional :: costfunccfy0=32	
            integer(kind=inttype) parameter,optional :: costfunccfyalpha=33 
            integer(kind=inttype) parameter,optional :: costfunccfyalphadot=34
            integer(kind=inttype) parameter,optional :: costfunccfyq=35
            integer(kind=inttype) parameter,optional :: costfunccfyqdot=36
            integer(kind=inttype) parameter,optional :: costfuncbendingcoef=37
            integer(kind=inttype) parameter,optional :: costfuncsepsensor=38
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgx=39
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgy=40
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgz=41
            integer(kind=inttype) parameter,optional :: costfunccavitation=42
            real(kind=realtype) sepsensoroffset
            real(kind=realtype) sepsensorsharpness
       end module costfunctions

      
       module adjointvars ! in :test:ADjointVars.F90
         use constants
         use costfunctions
         integer(kind=inttype) :: ncellslocal(20)
         integer(kind=inttype) :: nnodeslocal(20)
         integer(kind=inttype) :: ndesignpointrefz
         integer(kind=inttype) :: ndesignpointrefy
         integer(kind=inttype) :: ndesignssa
         integer(kind=inttype) :: ndesignextra
         integer(kind=inttype) :: ndesignrotcenx
         integer(kind=inttype) :: ndesignpointrefx
         integer(kind=inttype) :: ndesignrotz
         integer(kind=inttype) :: ndesignrotx
         integer(kind=inttype) :: ndesignroty
         integer(kind=inttype) :: ndesignrotcenz
         integer(kind=inttype) :: ndesignaoa
         integer(kind=inttype) :: ndesignrotceny
         integer(kind=inttype) :: ndesignmachgrid
         integer(kind=inttype) :: ndesignmach
         integer(kind=inttype) :: ndesignlengthref
         integer(kind=inttype) :: ndesignsurfaceref
         integer(kind=inttype) :: ndesigndisserror
         integer(kind=inttype) :: ndesignpressure
         integer(kind=inttype) :: ndesigntemperature
         integer(kind=inttype) :: ndesignreynolds
       end module adjointvars

       module adjointpetsc
         real(kind=realtype) :: adjresinit, adjresstart, adjresfinal
       end module adjointpetsc

       module inputtsstabderiv ! in :test:inputParam.f90
         logical :: usewindaxis
         logical :: tsrmode
         logical :: tsstability
         logical :: tsbetamode
         logical :: tsmachmode
         logical :: tsaltitudemode
         logical :: tspmode
         logical :: tsqmode
         logical :: tsalphamode
         logical :: tsalphafollowing 
       end module inputtsstabderiv

       module nksolvervars ! in :test:NKsolverVars.F90
         use constants
         integer(kind=inttype) :: innerpreconits
         integer(kind=inttype) :: outerpreconits
         integer(kind=inttype) :: jacobian_lag
         logical :: usenksolver
         logical :: nkadpc
         logical :: nkuseew
         logical :: nkviscpc
         integer(kind=inttype) :: nkls
         integer(kind=inttype) :: nolinesearch=0
         integer(kind=inttype) :: cubiclinesearch=1
         integer(kind=inttype) :: nonmonotonelinesearch=2
         integer(kind=inttype) :: snes_max_funcs
         real(kind=realtype) :: snes_rtol
         character(len=maxstringlen) :: global_pc_side
         integer(kind=inttype) :: snes_max_its
         character(len=maxstringlen) :: ksp_solver_type
         integer(kind=inttype) :: ksp_subspace
         integer(kind=inttype) :: asm_overlap
         character(len=maxstringlen) :: global_pc_type
         real(kind=realtype) :: ksp_atol
         integer(kind=inttype) :: ksp_max_it
         integer(kind=inttype) :: local_pc_ilu_level
         real(kind=realtype) :: snes_stol
         real(kind=realtype) :: snes_atol
         character(len=maxstringlen) :: local_pc_ordering
         real(kind=realtype) :: ksp_div_tol=10
         real(kind=realtype) :: nk_switch_tol
         real(kind=realtype) :: ksp_rtol
         real(kind=realtype) :: totalr0
         real(kind=realtype) :: totalrstart
         real(kind=realtype) :: totalrfinal
         logical :: rkreset
         integer(kind=inttype) :: nrkreset
         integer(kind=inttype) :: applypcsubspacesize
         logical :: freestreamresset
         integer(kind=inttype) :: nksolvecount
       end module nksolvervars
      
       ! ############################################################################
       ! Coupler API Routines
       ! ############################################################################

       module couplerparam ! in :sumb:../../modules/couplerParam.f90 
         use precision
         use constants
         character(len=80) allocatable,dimension(:) :: datanamessumb
         integer(kind=inttype) :: nnodestrue
         integer(kind=inttype) :: ntetraalloc
         integer(kind=inttype) :: npyraalloc
         integer(kind=inttype) allocatable,dimension(:) :: iwsumb
         integer(kind=inttype) :: npyratrue
         integer(kind=inttype) :: ndatasumb
         integer(kind=inttype) :: nprismtrue
         real(kind=realtype) :: pini
         integer(kind=inttype) :: nprismalloc
         real(kind=realtype) dimension(3) :: veldirini
         integer(kind=inttype) :: nnodesalloc
         integer(kind=inttype) :: nhexatrue
         real(kind=realtype) :: rhoini
         integer(kind=inttype) :: ntetratrue
         integer parameter,optional :: maxcplnamelen=80
         logical :: cplgetcoarsesol
         integer(kind=inttype) :: nhexaalloc
         character(len=80) :: codename
         real(kind=realtype) :: machini

       end module couplerparam

       subroutine sumb_init ! in :sumb:../../utils/SUmb_init.f90
         use communication
         implicit none
       end subroutine sumb_init

       subroutine sumb_finalize ! in :sumb:../../utils/SUmb_finalize.f90
         use communication
         implicit none
       end subroutine sumb_finalize

        subroutine testrev(dwbar,wbar,statesize) ! in :test:test.F90
          real(kind=realtype) dimension(statesize),intent(in) :: dwbar
          real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: wbar
          integer(kind=inttype), optional,check(len(dwbar)>=statesize),depend(dwbar) :: statesize=len(dwbar)
        end subroutine testrev

        subroutine testrevspatial(dwbar,xbar,statesize,spatialsize) ! in :test:test.F90
            real(kind=realtype) dimension(statesize),intent(in) :: dwbar
            real(kind=realtype) dimension(spatialsize),intent(out),depend(spatialsize) :: xbar
            integer(kind=inttype), optional,check(len(dwbar)>=statesize),depend(dwbar) :: statesize=len(dwbar)
            integer(kind=inttype) :: spatialsize
        end subroutine testrevspatial

    end interface 

#ifdef USE_COMPLEX
end python module libsumb_cs
#else
end python module libsumb
#endif



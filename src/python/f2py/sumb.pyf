!    -*- f90 -*-
python module solverunsteadymd__user__routines 
    interface solverunsteadymd_user_interface 
        subroutine mdcallback_python(t) ! in :test:solverUnsteadyMD.F90:solverunsteadymd:unknown_interface
            real*8 :: t
        end subroutine mdcallback_python
    end interface solverunsteadymd_user_interface
end python module solverunsteadymd__user__routines

#ifdef USE_COMPLEX
python module libsumb_cs ! in 
#else
python module libsumb
#endif
    interface  ! in :sumb

       ! ############################################################################
       ! SUmb Routines
       ! ############################################################################

       subroutine writeintromessage ! in :sumb:../../utils/initExec.F90
       end subroutine writeintromessage
       
       subroutine readparamfile ! in :sumb:../../inputParam/readParamFile.f90
       end subroutine readparamfile
       
       subroutine setdefaultvalues()
       end subroutine setdefaultvalues

       subroutine monitorvariables(variables) ! in :test:monitorVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine monitorvariables
       
       subroutine surfacevariables(variables) ! in :test:surfaceVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine surfacevariables

       subroutine volumevariables(variables) ! in :test:volumeVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine volumevariables

       subroutine isovariables(variables) ! in :test:volumeVariables.f90
         character*(*) intent(inout) :: variables
       end subroutine isovariables

       subroutine initializeisosurfacevariables(values,nvalues) ! in :test:setIsoSurfaceValues.F90
         real(kind=realtype), dimension(nvalues),intent(in) :: values
         integer(kind=inttype), optional,intent(in),check(len(values)>=nvalues),depend(values) :: nvalues=len(values)
       end subroutine initializeisosurfacevariables
 
       subroutine setisosurfacevariable(variable,ivar) ! in :test:setIsoSurfaceValues.F90
         character*(*), intent(in) :: variable
         integer(kind=inttype), intent(in) :: ivar
       end subroutine setisosurfacevariable
       
       subroutine addparaslice(slicename,pt,direction) ! in :test:liftDistribution.F90
         character*(*) intent(in) :: slicename
         real(kind=realtype) dimension(3),intent(in) :: pt
         real(kind=realtype) dimension(3),intent(in) :: direction
       end subroutine addparaslice

       subroutine addabsslice(slicename,pt,direction) ! in :test:liftDistribution.F90
         character*(*) intent(in) :: slicename
         real(kind=realtype) dimension(3),intent(in) :: pt
         real(kind=realtype) dimension(3),intent(in) :: direction
       end subroutine addabsslice

       subroutine addliftdistribution(nsegments,dir_vec,dir_ind, distname) ! in :test:liftDistribution.F90
         integer(kind=inttype) intent(in) :: nsegments
         real(kind=realtype) dimension(3), intent(in) :: dir_vec
         integer(kind=inttype), intent(in) :: dir_ind
         character*(*) intent(in) :: distname
       end subroutine addliftdistribution
       
       subroutine writeliftdistributionfile(filename)
         character*(*), intent(in) :: filename
       end subroutine writeliftdistributionfile

       subroutine writeslicesfile(filename)
         character*(*), intent(in) :: filename
       end subroutine writeslicesfile

       subroutine dummyreadparamfile ! in :sumb:../../inputParam/readParamFile.f90
       end subroutine dummyreadparamfile
       
       subroutine partitionandreadgrid ! in :sumb:../../partitioning/partitionAndReadGrid.f90
       end subroutine partitionandreadgrid

       subroutine preprocessing ! in :sumb:../../preprocessing/preprocessing.f90
       end subroutine preprocessing
     
       subroutine initflow ! in :sumb:../../initFlow/initFlow.f90
       end subroutine initflow

       subroutine updatecoordinatesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updatecoordinatesalllevels

       subroutine updatemetricsalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updatemetricsalllevels

       subroutine updategridvelocitiesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
       end subroutine updategridvelocitiesalllevels

       subroutine updateperiodicinfoalllevels
       end subroutine updateperiodicinfoalllevels

       subroutine updateflow
       end subroutine updateflow

       subroutine referencestate
       end subroutine referencestate

       subroutine setflowinfinitystate
       end subroutine setflowinfinitystate
       
       subroutine updatereferencepoint
       end subroutine updatereferencepoint

       subroutine updaterotationrate(rotcenter,rotrate,blocks,nblocks) ! in :test:updateRotationRate.f90
         real(kind=realtype) dimension(3),intent(in) :: rotcenter
         real(kind=realtype) dimension(3),intent(in) :: rotrate
         integer(kind=inttype) dimension(nblocks),intent(in) :: blocks
         integer(kind=inttype), optional,intent(in),check(len(blocks)>=nblocks),depend(blocks) :: nblocks=len(blocks)
       end subroutine updaterotationrate

       subroutine adjustinflowangle(alpha, beta, liftindex)
         real(kind=realtype) intent(in) :: alpha
         real(kind=realtype) intent(in):: beta
         integer(kind=inttype) intent(in) :: liftindex
       end subroutine adjustinflowangle

       subroutine setuniformflow
       end subroutine setuniformflow
       subroutine allocconvarrays(nitertot) ! in :sumb:../../initFlow/allocConvArrays.f90
         integer(kind=inttype) :: nitertot
       end subroutine allocconvarrays

       subroutine alloctimearrays(nitertot) ! in :sumb:../../initFlow/allocTimeArrays.f90
         integer(kind=inttype) :: ntimetot
       end subroutine alloctimearrays

       subroutine solver ! in :sumb:../../solver/solver.F90
       end subroutine solver

       subroutine checkpartitioning(np,load_inbalance,face_inbalance) ! in :test:checkPartitioning.f90
         integer(kind=inttype) intent(in) :: np
         real(kind=realtype) intent(out) :: load_inbalance
         real(kind=realtype) intent(out) :: face_inbalance
       end subroutine checkpartitioning

       subroutine writesol ! in :sumb:../../output/writeSol.f90
       end subroutine writesol

       subroutine updatewalldistancealllevels ! in :sumb:../../wallDistance/updateWallDistanceAllLevels.f90
       end subroutine updatewalldistancealllevels

       subroutine updateslidingalllevels ! in :sumb:../../slidingComm/updateSlidingAllLevels.f90
       end subroutine updateslidingalllevels

       subroutine solversteady ! in :sumb:../../solver/solverSteady.f90
       end subroutine solversteady

       subroutine inittimesteppart1 ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine inittimesteppart1

       subroutine inittimesteppart2 ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine inittimesteppart2

       subroutine solvestate ! in :sumb:../../solver/solveState.F90
       end subroutine solvestate

       subroutine checkwriteunsteadyinloop ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine checkwriteunsteadyinloop

       subroutine checkwriteunsteadyendloop ! in :sumb:../../solver/solverUnsteady.F90
       end subroutine checkwriteunsteadyendloop

       subroutine getsolution(sps) ! in :sumb:../../adjoint/designExport.f90
         integer(kind=inttype) intent(in) :: sps
       end subroutine getsolution

       subroutine solverunsteadymd(mdcallback_python) ! in :test:solverUnsteadyMD.F90
         use solverunsteadymd__user__routines
         external mdcallback_python
       end subroutine solverunsteadymd

       ! ############################################################################
       ! SUmb Mesh/Forces Interface Routines
       ! ############################################################################

       subroutine getcgnsmeshindices(ndof,indices)
         integer(kind=inttype) intent(in) :: ndof
         integer(kind=inttype) dimension(ndof),intent(out),depend(ndof) :: indices
       end subroutine getcgnsmeshindices

       subroutine setgrid(grid,ndof) ! in :test:setGrid.f90
         real(kind=realtype) dimension(ndof),intent(in) :: grid
         integer(kind=inttype) optional,intent(in),check(len(grid)>=ndof),depend(grid) :: ndof=len(grid)
       end subroutine setgrid

       subroutine setgridsimple(grid,ndof) ! in :test:setGrid.f90
         real(kind=realtype) dimension(ndof),intent(in) :: grid
         integer(kind=inttype) optional,intent(in),check(len(grid)>=ndof),depend(grid) :: ndof=len(grid)
       end subroutine setgridsimple

       subroutine getgrid(grid,ndof) ! in :test:setGrid.f90
            real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: grid
            integer(kind=inttype) intent(in) :: ndof
        end subroutine getgrid

       subroutine getnpatches(npatches) ! in :test:getForces.f90
         integer(kind=inttype) intent(out) :: npatches
       end subroutine getnpatches
 
       subroutine getpatchname(ipatch,patchname) ! in :test:getForces.f90
         integer(kind=inttype) intent(in) :: ipatch
         character*(*) intent(inout) :: patchname
       end subroutine getpatchname

       subroutine getpatchsize(ipatch,patchsize) ! in :test:getForces.f90
         integer(kind=inttype) intent(in) :: ipatch
         integer(kind=inttype) dimension(2), intent(out) :: patchsize
       end subroutine getpatchsize

       subroutine getforcesize(npts, ncells) ! in :test:getForces.f90
         integer(kind=inttype) intent(out) :: npts
         integer(kind=inttype) intent(out) :: ncells
       end subroutine getforcesize

        subroutine getforceconnectivity(conn,ncell) ! in :test:getForces.f90
          integer(kind=inttype) dimension(4 * ncell),intent(inout) :: conn
          integer(kind=inttype) optional,intent(in),check((len(conn))/(4)>=ncell),depend(conn) :: ncell=(len(conn))/(4)
        end subroutine getforceconnectivity

        subroutine getforces(forcesp,forcesv,npts,sps_in) ! in :test:getForces.f90
          real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: forcesp
          real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: forcesv
          integer(kind=inttype) intent(in) :: npts
          integer(kind=inttype) intent(in) :: sps_in
        end subroutine getforces
        
        subroutine getforcepoints(points,npts,sps_in) ! in :test:getForces.f90
          integer(kind=inttype), intent(in) :: sps_in
          real(kind=realtype) dimension(3,npts),intent(inout) :: points
          integer(kind=inttype) optional,intent(in),check(shape(points,1)==npts),depend(points) :: npts=shape(points,1)
       end subroutine getforcepoints

       subroutine getareas(areas,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: areas
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareas

       subroutine getareasensitivity(darea,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: darea
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareasensitivity

       ! ############################################################################
       ! SUmb ADjoint Debugging Routines
       ! ############################################################################

       subroutine determinestencil(lumped)
         logical :: lumped 
       end subroutine determinestencil
       
       subroutine verifyad
       end subroutine verifyad

       ! ############################################################################
       ! SUmb ADjoint Core Routines
       ! ############################################################################

       subroutine initializepetsc 
       end subroutine initializepetsc

       subroutine preprocessingadjoint 
       end subroutine preprocessingadjoint
    
       ! State Variables
       subroutine createpetscvars
       end subroutine createpetscvars

       subroutine destroypetscvars
       end subroutine destroypetscvars

       ! KSP Setup
       subroutine setuppetscksp 
       end subroutine setuppetscksp

       subroutine setupallresidualmatricesfwd
       end subroutine setupallresidualmatricesfwd

       subroutine setupadjointmatrix
       end subroutine setupadjointmatrix

       subroutine setupspatialmatrix(usead)
         logical, intent(in) :: usead
       end subroutine setupspatialmatrix

       subroutine setupextramatrix
       end subroutine setupextramatrix

       subroutine solveadjointtransposepetsc ! in :sumb:../../adjoint/solveADjointPETSc.F90
       end subroutine solveadjointtransposepetsc

        subroutine saveadjointmatrix(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
        end subroutine saveadjointmatrix
        subroutine saveadjointpc(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
          end subroutine saveadjointpc
          subroutine saveadjointrhs(filename) ! in :test:saveAdjoint.F90
            character*(*) intent(in) :: filename
          end subroutine saveadjointrhs

       ! -------- Partial Derivative Functions -----------
       
       subroutine zeroobjpartials(statesetup,spatialsetup)
         logical :: statesetup
         logical :: spatialsetup
       end subroutine zeroobjpartials

       subroutine computeobjectivepartialsfwd(costfunction) ! in :sumb:../../adjoint/computeObjPartials.F90
         integer(kind=inttype) intent(in) :: costfunction
       end subroutine computeobjectivepartialsfwd

        subroutine getdidw(output,nstate) ! in :test:computeObjPartials.F90
            real(kind=realtype) dimension(nstate),intent(inout) :: output
            integer(kind=inttype) optional,intent(in,out),check(len(output)>=nstate),depend(output) :: nstate=len(output)
        end subroutine getdidw

        subroutine getdidx(output,ndof) ! in :test:computeObjPartials.F90
          real(kind=realtype) dimension(ndof),intent(inout) :: output
          integer(kind=inttype) optional,intent(in),check(len(output)>=ndof),depend(output) :: ndof=len(output)
        end subroutine getdidx

       ! -------- Get/Set Functions --------------------
       subroutine getstates(states,ndimw) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(ndimw),intent(out),depend(ndimw) :: states
         integer(kind=inttype) intent(in) :: ndimw
       end subroutine getstates

       subroutine setstates(states,ndimw) ! in :test:getADjoint.F90
         real(kind=realtype) dimension(ndimw),intent(in) :: states
         integer(kind=inttype) optional,intent(in),check(len(states)>=ndimw),depend(states) :: ndimw=len(states)
       end subroutine setstates

       subroutine getres(res,ndimw) ! in :test:NKUtilities.F90
         real(kind=realtype) dimension(ndimw),intent(in,out) :: res
         integer(kind=inttype) optional,intent(in),check(len(res)>=ndimw),depend(res) :: ndimw=len(res)
       end subroutine getres

       subroutine getdrdxvpsi(dxv,ndof,adjoint,nstate) ! in :test:getdRdXvPsi.F90
         real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: dxv
         integer(kind=inttype) intent(in) :: ndof
         real(kind=realtype) dimension(nstate),intent(in) :: adjoint
         integer(kind=inttype) optional,intent(in),check(len(adjoint)>=nstate),depend(adjoint) :: nstate=len(adjoint)
       end subroutine getdrdxvpsi
       
       subroutine spectralprecscribedmotion(input,nin,dxv,nout)
         real(kind=realtype) dimension(nin),intent(in) :: input
         integer(kind=inttype), optional,intent(in),check(len(input)>=nin),depend(input) :: nin=len(input)
         real(kind=realtype) dimension(nout),intent(out),depend(nout) :: dxv
         integer(kind=inttype) intent(in) :: nout
       end subroutine spectralprecscribedmotion
  
        subroutine getdrdapsi(output,ndv,adjoint,nstate) ! in :test:getdRdaPsi.F90
            real(kind=realtype) dimension(ndv),intent(out),depend(ndv) :: output
            integer(kind=inttype) intent(in) :: ndv
            real(kind=realtype) dimension(nstate),intent(in) :: adjoint
            integer(kind=inttype) optional,intent(in),check(len(adjoint)>=nstate),depend(adjoint) :: nstate=len(adjoint)
        end subroutine getdrdapsi

       subroutine getadjoint(nstate,adjoint) ! in :test:getADjoint.F90
         integer(kind=inttype) intent(in) :: nstate
         real(kind=realtype) dimension(nstate),intent(out),depend(nstate) :: adjoint
       end subroutine getadjoint

       subroutine setadjoint(nstate,adjoint) ! in :test:setADjoint.F90
         integer(kind=inttype) optional,intent(in),check(len(adjoint)>=nstate),depend(adjoint) :: nstate=len(adjoint)
         real(kind=realtype) dimension(nstate),intent(in) :: adjoint
       end subroutine setadjoint

       ! ------------- Misc --------------------
    
       subroutine matrixinfo(pdrdwt,pdrdwpret,pdrdx,pdrda,pdfdw,pdfdx,plocal,psum,pmax) ! in :test:matrixInfo.F90
         logical intent(in) :: pdrdwt
         logical intent(in) :: pdrdwpret
         logical intent(in) :: pdrdx
         logical intent(in) :: pdrda
         logical intent(in) :: pdfdw
         logical intent(in) :: pdfdx
         logical intent(in) :: plocal
         logical intent(in) :: psum
         logical intent(in) :: pmax
       end subroutine matrixinfo
      
       subroutine releasememadjoint
       end subroutine releasememadjoint

       ! ############################################################################
       ! SUmb Adjoint Coupling Routines
       ! ############################################################################

       subroutine setupcouplingmatrixstruct(pts,npts,nts) ! in :sumb:../../adjoint/setupCouplingMatrixStruct.F90
         real(kind=realtype) dimension(3,npts,nts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) optional,intent(in),check(shape(pts,2)==nts),depend(pts) :: nts=shape(pts,2)
       end subroutine setupcouplingmatrixstruct

       subroutine getdfdxvec(ndof,vec_in,vec_out) ! in :test:getdFdxVec.f90
         integer(kind=inttype) optional,intent(in),check(len(vec_in)>=ndof),depend(vec_in) :: ndof=len(vec_in)
         real(kind=realtype) dimension(ndof),intent(in) :: vec_in
         real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: vec_out
       end subroutine getdfdxvec

       subroutine getdfdxtvec(ndof,vec_in,vec_out) ! in :test:getdFdxVec.f90
         integer(kind=inttype) optional,intent(in),check(len(vec_in)>=ndof),depend(vec_in) :: ndof=len(vec_in)
         real(kind=realtype) dimension(ndof),intent(in) :: vec_in
         real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: vec_out
       end subroutine getdfdxtvec

       subroutine agumentrhs(ndof,phi) ! in :test:agumentRHS.f90
         integer(kind=inttype) optional,intent(in),check(len(phi)>=ndof),depend(phi) :: ndof=len(phi)
         real(kind=realtype) dimension(ndof),intent(in) :: phi
       end subroutine agumentrhs
      
       ! ############################################################################
       ! Newton-Krylov Solver Routines
       ! ############################################################################

       subroutine applypc(in_vec,out_vec,ndof) ! in :test:NKsolver.F90
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
         integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
       end subroutine applypc

       subroutine applyadjointpc(in_vec,out_vec,ndof) ! in :test:NKsolver.F90
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
         integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
       end subroutine applyadjointpc

        subroutine getdfdwtvec(in_vec,in_dof,out_vec,out_dof) ! in :test:agumentRHS.F90
            real(kind=realtype) dimension(in_dof),intent(in) :: in_vec
            integer(kind=inttype) optional,intent(in),check(len(in_vec)>=in_dof),depend(in_vec) :: in_dof=len(in_vec)
            real(kind=realtype) dimension(out_dof),intent(in,out) :: out_vec
            integer(kind=inttype) optional,intent(in),check(len(out_vec)>=out_dof),depend(out_vec) :: out_dof=len(out_vec)
        end subroutine getdfdwtvec


       subroutine getdrdwtvec(in_vec,out_vec,ndof) ! in :test:NKsolver.F90
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
         integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: n=len(in_vec)
       end subroutine getdrdwtvec

       subroutine getcurrentresidual(rhores,totalrres)
         real(kind=realtype), intent(out) :: rhores
         real(kind=realtype), intent(out) :: totalrres
       end subroutine getcurrentresidual

       subroutine getfreestreamresidual(rhores,totalrres)
         real(kind=realtype), intent(out) :: rhores
         real(kind=realtype), intent(out) :: totalrres
       end subroutine getfreestreamresidual

       subroutine computeresidualnk
       end subroutine computeresidualnk

       subroutine setupnksolver
       end subroutine setupnksolver
       
       subroutine destroynksolver
       end subroutine destroynksolver
       
       subroutine nkbenchmark(nkres,niter)
         logical :: nkres
         integer(kind=inttype) :: niter
       end subroutine nkbenchmark

       ! ############################################################################
       ! Time Spectral Stability Routines
       ! ############################################################################

       subroutine stabilityderivativedriver
       end subroutine stabilityderivativedriver

       ! ############################################################################
       ! SUmb Modules
       ! ############################################################################
       module constants ! in :sumb:../../modules/constants.F90
         use precision
         integer parameter,optional :: maxstringlen   = 256
         integer parameter,optional :: maxcgnsnamelen =  32
       end module constants

       module communication ! in :sumb:../../modules/communication.f90
         use precision
         integer :: sumb_comm_world
         integer :: myid
         integer :: nproc
         integer(kind=inttype) :: sendbuffersize_1to1
         integer(kind=inttype) :: sendbuffersize
         integer(kind=inttype) :: recvbuffersize_1to1
         integer(kind=inttype) :: recvbuffersize
         integer(kind=inttype) :: sendbuffersizeover
         integer(kind=inttype) :: recvbuffersizeover
         real(kind=realtype) allocatable,dimension(:) :: sendbuffer
         real(kind=realtype) allocatable,dimension(:) :: recvbuffer
         integer allocatable,dimension(:) :: sendrequests
         integer allocatable,dimension(:) :: recvrequests
       end module communication

       module inputdiscretization ! in :sumb:../../modules/inputParam.f90
         use accuracy
         integer(kind=inttype) parameter,optional :: dissscalar=1_inttype
         integer(kind=inttype) parameter,optional :: dissmatrix=2_inttype
         integer(kind=inttype) parameter,optional :: disscusp=3_inttype
         integer(kind=inttype) parameter,optional :: upwind=9_inttype
         integer(kind=inttype) parameter,optional :: roe=1_inttype
         integer(kind=inttype) parameter,optional :: vanleer=2_inttype
         integer(kind=inttype) parameter,optional :: ausmdv=3_inttype
         integer(kind=inttype) parameter,optional :: nolimiter=2_inttype
         integer(kind=inttype) parameter,optional :: vanalbeda=3_inttype
         integer(kind=inttype) parameter,optional :: minmod=4_inttype
         integer(kind=inttype) parameter,optional :: noprecond=1_inttype
         integer(kind=inttype) parameter,optional :: turkel=2_inttype
         integer(kind=inttype) parameter,optional :: choimerkle=3_inttype
         integer(kind=inttype) parameter,optional :: constantpressure=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapolpressure=2_inttype
         integer(kind=inttype) parameter,optional :: quadextrapolpressure=3_inttype
         integer(kind=inttype) parameter,optional :: normalmomentum=4_inttype
         integer(kind=inttype) parameter,optional :: constantextrapol=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapol=2_inttype
         integer(kind=inttype) :: spacediscr
         integer(kind=inttype) :: spacediscrcoarse
         integer(kind=inttype) :: orderturb
         integer(kind=inttype) :: limiter
         integer(kind=inttype) :: riemann
         integer(kind=inttype) :: riemanncoarse
         integer(kind=inttype) :: precond
         integer(kind=inttype) :: wallbctreatment
         integer(kind=inttype) :: outflowtreatment
         real(kind=realtype) :: vis2
         real(kind=realtype) :: vis4
         real(kind=realtype) :: vis2coarse
         real(kind=realtype) :: adis
         real(kind=realtype) :: kappacoef
         logical :: vortexcorr
         logical :: dirscaling
         logical :: radiineededfine
         logical :: radiineededcoarse
         logical :: lumpeddiss
         real(kind=realtype) :: sigma
         logical :: useapproxwalldistance
         logical :: updatewallassociation
       end module inputdiscretization

       module cgnsgrid
         use constants
         integer(kind=inttype) :: cgnsndom
       end module cgnsgrid

       module inputio ! in :sumb:../../modules/inputParam.f90
         use constants
         integer(kind=inttype) parameter,optional :: noformat=0
         character(len=maxstringlen) :: solfile
         integer(kind=inttype) parameter,optional :: precisiondouble=2
         character(len=maxstringlen) :: surfacesolfile
         character(len=maxstringlen) :: cpfile
         logical :: writecoormeter
         integer(kind=inttype) :: precisionsol
         integer(kind=inttype) :: precisiongrid
         integer(kind=inttype) parameter,optional :: cgnsformat=1
         character(len=maxstringlen) :: newgridfile
         character(len=maxstringlen) :: restartfile
         logical :: restart
         character(len=maxstringlen) :: plot3dconnfile
         integer(kind=inttype) :: fileformatread
         character(len=maxstringlen) :: gridfile
         logical :: storeconvinneriter
         logical :: storerindlayer
         logical :: checkrestartsol
         logical :: autoparameterupdate
         logical :: writesymmetry
         logical :: writefarfield
         logical :: viscoussurfacevelocities
         integer(kind=inttype) parameter,optional :: precisionsingle=1
         logical optional :: firstwrite=.true.
         integer(kind=inttype) :: fileformatwrite
         integer(kind=inttype) parameter,optional :: plot3dformat=2
         character(len=maxstringlen) :: paramfile
       end module inputio

       module localmg ! in :test:localModules.f90
         use constants
         character(len=maxstringlen) :: mgdescription
       end module localmg

       module inputiteration ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) parameter,optional :: rungekutta=1_inttype
         integer(kind=inttype) parameter,optional :: dadi=2_inttype
         integer(kind=inttype) parameter,optional :: nllusgs=3_inttype
         integer(kind=inttype) parameter,optional :: nllusgsline=4_inttype
         integer(kind=inttype) parameter,optional :: segregated=1_inttype
         integer(kind=inttype) parameter,optional :: coupled=2_inttype
         integer(kind=inttype) parameter,optional :: gmres=1_inttype
         integer(kind=inttype) parameter,optional :: adi=2_inttype
         integer(kind=inttype) parameter,optional :: bcdirichlet0=0_inttype
         integer(kind=inttype) parameter,optional :: bcneumann=1_inttype
         integer(kind=inttype) parameter,optional :: noresaveraging=0_inttype
         integer(kind=inttype) parameter,optional :: alwaysresaveraging=1_inttype
         integer(kind=inttype) parameter,optional :: alternateresaveraging=2_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxnotdefined=0_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxexplicit=1_inttype
         integer(kind=inttype) parameter,optional :: turbrelaximplicit=2_inttype
         integer(kind=inttype) :: ncycles
         integer(kind=inttype) :: ncyclescoarse
         integer(kind=inttype) :: nsavevolume
         integer(kind=inttype) :: nsavesurface
         integer(kind=inttype) :: nsgstartup
         integer(kind=inttype) :: smoother
         integer(kind=inttype) :: nrkstages
         integer(kind=inttype) :: resaveraging
         real(kind=realtype) :: cfllimit
         integer(kind=inttype) :: turbtreatment
         integer(kind=inttype) :: nsubiterturb
         integer(kind=inttype) :: nsubiterations
         integer(kind=inttype) :: turbsmoother
         integer(kind=inttype) :: turbrelax
         integer(kind=inttype) :: mgboundcorr
         integer(kind=inttype) :: mgstartlevel
         integer(kind=inttype) :: nmgsteps
         integer(kind=inttype) :: nmglevels
         integer(kind=inttype) :: miniternum
         integer(kind=inttype) :: convcheckwindowsize
         integer(kind=inttype) allocatable,dimension(:) :: cyclestrategy
         real(kind=realtype) :: cfl
         real(kind=realtype) :: cflcoarse
         real(kind=realtype) :: fcoll
         real(kind=realtype) :: smoop
         real(kind=realtype) :: alfaturb
         real(kind=realtype) :: betaturb
         real(kind=realtype) :: l2conv
         real(kind=realtype) :: l2convcoarse
         real(kind=realtype) :: l2convrel
         real(kind=realtype) :: epscoefconv
         real(kind=realtype) allocatable,dimension(:) :: etark
         real(kind=realtype) allocatable,dimension(:) :: cdisrk
         logical :: freezeturbsource
         logical :: printiterations
       end module inputiteration

       module inputmotion ! in :sumb:../../modules/inputParam.f90
         use precision
         real(kind=realType), dimension(3) :: rotpoint
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouryrot
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourxrot
         integer(kind=inttype) :: degreefourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouralpha
         real(kind=realtype) :: omegafourbeta
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourbeta
         integer(kind=inttype) :: degreepolbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourmach
         integer(kind=inttype) :: degreepolmach
         real(kind=realtype) :: omegafourmach
         integer(kind=inttype) :: degreepolalpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolmach
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourmach
         real(kind=realtype) allocatable,dimension(:) :: coefpolzrot
         logical :: gridmotionspecified
         real(kind=realtype) :: omegafourzrot
         integer(kind=inttype) :: degreefouryrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolyrot
         integer(kind=inttype) :: degreefourbeta
         real(kind=realtype) :: omegafouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourzrot
         integer(kind=inttype) :: degreepolzrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourzrot
         real(kind=realtype) :: omegafouryrot
         integer(kind=inttype) :: degreefourzrot
         integer(kind=inttype) :: degreefourmach
         integer(kind=inttype) :: degreefouralpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolalpha
         real(kind=realtype) :: omegafourxrot
         integer(kind=inttype) :: degreepolyrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouryrot
         integer(kind=inttype) :: degreepolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolbeta
       end module inputmotion
       
       module inputparallel ! in :sumb:../../modules/inputParam.f90
         real(kind=realtype) :: loadimbalance
         logical :: splitblocks
         integer(kind=inttype) :: loadbalanceiter
       end module inputparallel

       module inputphysics ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) parameter,optional :: eulerequations=1_inttype
         integer(kind=inttype) parameter,optional :: nsequations=2_inttype
         integer(kind=inttype) parameter,optional :: ransequations=3_inttype
         integer(kind=inttype) parameter,optional :: steady=1_inttype
         integer(kind=inttype) parameter,optional :: unsteady=2_inttype
         integer(kind=inttype) parameter,optional :: timespectral=3_inttype
         integer(kind=inttype) parameter,optional :: internalflow=1_inttype
         integer(kind=inttype) parameter,optional :: externalflow=2_inttype
         integer(kind=inttype) parameter,optional :: cpconstant=1_inttype
         integer(kind=inttype) parameter,optional :: cptempcurvefits=2_inttype
         integer(kind=inttype) parameter,optional :: baldwinlomax=1_inttype
         integer(kind=inttype) parameter,optional :: spalartallmaras=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmarasedwards=3_inttype
         integer(kind=inttype) parameter,optional :: komegawilcox=4_inttype
         integer(kind=inttype) parameter,optional :: komegamodified=5_inttype
         integer(kind=inttype) parameter,optional :: ktau=6_inttype
         integer(kind=inttype) parameter,optional :: mentersst=7_inttype
         integer(kind=inttype) parameter,optional :: v2f=10_inttype
         integer(kind=inttype) parameter,optional :: strain=1_inttype
         integer(kind=inttype) parameter,optional :: vorticity=2_inttype
         integer(kind=inttype) parameter,optional :: katolaunder=3_inttype
         integer(kind=inttype) :: equations
         integer(kind=inttype) :: equationmode
         integer(kind=inttype) :: flowtype
         integer(kind=inttype) :: turbmodel
         integer(kind=inttype) :: cpmodel
         integer(kind=inttype) :: turbprod
         integer(kind=inttype) :: rvfn
         logical :: rvfb
         logical :: wallfunctions
         real(kind=realtype) :: mach
         real(kind=realtype) :: machcoef
         real(kind=realtype) :: machgrid
         real(kind=realtype) :: reynolds
         real(kind=realtype) :: reynoldslength
         real(kind=realtype) :: tempfreestream
         real(kind=realtype) :: gammaconstant
         real(kind=realtype) :: rgasdim
         real(kind=realtype) :: prandtl
         real(kind=realtype) :: prandtlturb
         real(kind=realtype) :: pklim
         real(kind=realtype) :: walloffset
         real(kind=realtype) :: eddyvisinfratio
         real(kind=realtype) :: turbintensityinf
         real(kind=realtype) :: surfaceref
         real(kind=realtype) :: lengthref
         real(kind=realtype) dimension(3) :: veldirfreestream
         real(kind=realtype) dimension(3) :: liftdirection
         real(kind=realtype) dimension(3) :: dragdirection
         real(kind=realtype) dimension(3) :: pointref
         real(kind=realtype) dimension(3) :: pointrefec
         logical :: forcesastractions
       end module inputphysics

       module inputadjoint ! in :sumb:../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: adjointpcside
         character(len=maxstringlen) :: matrixordering
         character(len=maxstringlen) :: adjointsolvertype
         character(len=maxstringlen) :: localpctype
         character(len=maxstringlen) :: precondtype
         real(kind=realtype) :: adjabstol
         real(kind=realtype) :: adjdivtol
         real(kind=realtype) :: adjreltol
         real(kind=realtype) :: adjreltolrel
         integer(kind=inttype) :: overlap
         integer(kind=inttype) :: adjmonstep
         integer(kind=inttype) :: filllevel
         integer(kind=inttype) :: adjmaxiter
         integer(kind=inttype) :: adjrestart
         integer(kind=inttype) :: innerpreconits
         integer(kind=inttype) :: outerpreconits
         logical :: approxpc
         logical :: adpc
         logical :: viscpc
         logical :: frozenturbulence
         logical :: usediagtspc
         logical :: restartadjoint
         logical :: solveadjoint
         logical :: setmonitor
         logical :: printtiming
         logical :: firstrun
         logical :: verifystate
         logical :: verifyspatial
         logical :: verifyextra
         integer(kind=inttype) :: applyadjointpcsubspacesize
       end module inputadjoint

       module inputtimespectral ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) :: ntimeintervalsspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: dscalar
         real(kind=realtype) allocatable,dimension(:,:,:) :: dvector
         real(kind=realtype) :: dtunsteadyrestartspectral
         logical :: writeunsteadyrestartspectral
         integer(kind=inttype) :: nunsteadysolspectral
         logical :: writeunsteadyvolspectral
         logical :: writeunsteadysurfspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: rotmatrixspectral
       end module inputtimespectral
       
       module inputunsteady ! in :test:inputParam.f90
         use accuracy
         integer(kind=inttype) parameter,optional :: bdf=1
         real(kind=realtype) :: deltat
         integer(kind=inttype) parameter,optional :: implicitrk=3
         integer(kind=inttype) :: timeintegrationscheme
         logical :: updatewalldistanceunsteady
         integer(kind=inttype) :: timeaccuracy
         integer(kind=inttype) parameter,optional :: explicitrk=2
         integer(kind=inttype) parameter,optional :: md=4
         integer(kind=inttype) :: ntimestepsfine
         integer(kind=inttype) :: ntimestepscoarse
       end module inputunsteady

       module inputoverset ! in :sumb:../../modules/inputParam.f90
         use precison
         integer(kind=inttype) parameter,optional :: trilinear=1_inttype
         logical :: oversetdonorsareguesses
         logical :: avgrestrictresforblanks
         integer(kind=inttype) :: oversetinterptype
         integer(kind=inttype) :: oversetinterptypecoarse
         real(kind=realtype) :: allowabledonorquality
       end module inputoverset

       module iteration ! in :sumb:../../modules/iteration.f90
         use precision
         integer(kind=inttype) :: groundlevel
         integer(kind=inttype) :: currentlevel
         integer(kind=inttype) :: rkstage
         integer(kind=inttype) :: nstepscycling
         integer(kind=inttype) allocatable,dimension(:) :: cycling
         integer(kind=inttype) :: nmgvar
         integer(kind=inttype) :: nt1mg
         integer(kind=inttype) :: nt2mg
         logical :: restricteddyvis
         logical :: turbsegregated
         logical :: turbcoupled
         integer(kind=inttype) :: itertot
         real(kind=realtype) :: rfil
         real(kind=realtype) :: t0solver
         logical :: converged
         logical :: exchangepressureearly
         logical :: standalonemode
         logical :: changing_grid
         logical :: deforming_grid
         logical :: changingoverset
         logical optional :: pv3initialized=.false.
         integer(kind=inttype) :: noldsolavail
         integer(kind=inttype) :: noldlevels
         real(kind=realtype) allocatable,dimension(:) :: coeftime
         logical :: timespectralgridsnotwritten
         logical, dimension(:), allocatable :: oldsolwritten       
       end module iteration

       module monitor ! in :sumb:../../modules/monitor.f90
         use constants
         integer parameter,optional :: fieldwidth=12
         integer parameter,optional :: decimalwidth=5
         integer :: nmonsum
         integer :: nmonmax
         integer :: nmon
         real(kind=realtype) allocatable,dimension(:) :: monloc
         real(kind=realtype) allocatable,dimension(:) :: monglob
         real(kind=realtype) allocatable,dimension(:) :: monRef
         character(len=32) allocatable,dimension(:) :: monnames
         logical :: monmachorhmax
         logical :: showcpu
         logical :: monMassSliding
         logical :: monMassFamilies
         integer :: niterold
         integer :: nitercur
         real(kind=realtype) allocatable,dimension(:,:,:) :: convarray
         integer(kind=inttype) :: ntimestepsrestart
         integer(kind=inttype) :: timestepunsteady
         real(kind=realtype) :: timeunsteady
         real(kind=realtype) :: timeunsteadyrestart
         real(kind=realtype) allocatable,dimension(:) :: timearray
         real(kind=realtype) allocatable,dimension(:,:) :: timedataarray
         logical :: writegrid
         logical :: writevolume
         logical :: writesurface
         logical :: coeffconvcheck
       end module monitor

       module block ! in :sumb:../../modules/block.f90
         use constants
         integer(kind=portype) parameter,optional :: leftstarted=-1_portype
         integer(kind=portype) parameter,optional :: regular=0_portype
         integer(kind=portype) parameter,optional :: rightstarted=1_portype
         integer(kind=inttype) parameter,optional :: nosubinlet=0_inttype
         integer(kind=inttype) parameter,optional :: totalconditions=1_inttype
         integer(kind=inttype) parameter,optional :: massflow=2_inttype
         integer(kind=inttype) :: ndom
         integer(kind=inttype) allocatable,dimension(:) :: ncellglobal
       end module block

       module flowvarrefstate ! in :sumb:../../modules/flowVarRefState.f90
         use constants
         integer(kind=inttype) :: nw
         integer(kind=inttype) :: nwf
         integer(kind=inttype) :: nwt
         integer(kind=inttype) :: nt1
         integer(kind=inttype) :: nt2
         real(kind=realtype) :: pref
         real(kind=realtype) :: rhoref
         real(kind=realtype) :: tref
         real(kind=realtype) :: muref
         real(kind=realtype) :: timeref
         real(kind=realtype) :: lref
         logical :: lrefspecified
         real(kind=realtype) :: pinfdim
         real(kind=realtype) :: rhoinfdim
         real(kind=realtype) :: mudim
         real(kind=realtype) :: rhoinf
         real(kind=realtype) :: uinf
         real(kind=realtype) :: pinf
         real(kind=realtype) :: pinfcorr
         real(kind=realtype) :: rgas
         real(kind=realtype) :: muinf
         real(kind=realtype) :: gammainf
         real(kind=realtype) allocatable,dimension(:) :: winf
         logical :: kpresent
         logical :: eddymodel
         logical :: viscous
       end module flowvarrefstate

       module killsignals ! in :sumb:../../modules/killSignals.f90
         use precision
         integer(kind=inttype) parameter,optional :: nosignal=0_int_type
         integer(kind=inttype) parameter,optional :: signalwrite=1_int_type
         integer(kind=inttype) parameter,optional :: signalwritequit=2_int_type
         integer(kind=inttype) :: localsignal
         integer(kind=inttype) :: globalsignal
         logical :: frompython
         logical :: routinefailed
         logical :: fatalfail
         logical :: adjointfailed
       end module killsignals

       module costfunctions ! in :test:costFunctions.F90
          use constants
            integer(kind=inttype) parameter,optional :: costfunccdq=30
            integer(kind=inttype) parameter,optional :: costfuncforcezcoef=10
            integer(kind=inttype) parameter,optional :: costfuncmomzcoef=16
            integer(kind=inttype) parameter,optional :: costfunccm0=17
            integer(kind=inttype) parameter,optional :: costfuncforcex=5
            integer(kind=inttype) parameter,optional :: costfuncclq=25
            integer(kind=inttype) parameter,optional :: costfuncdrag=2
            integer(kind=inttype) parameter,optional :: costfunccl0=22
            integer(kind=inttype) parameter,optional :: costfunccmzqdot=21
            integer(kind=inttype) parameter,optional :: costfuncforcexcoef=8
            integer(kind=inttype) parameter,optional :: costfunccmzq=20
            integer(kind=inttype) parameter,optional :: costfunccmzalphadot=19
            real(kind=realtype) allocatable,dimension(:) :: functionvalue
            integer(kind=inttype) parameter,optional :: costfunclift=1
            integer(kind=inttype) parameter,optional :: costfunccd0=27
            integer(kind=inttype) parameter,optional :: costfuncclqdot=26
            integer(kind=inttype) parameter,optional :: costfuncforcey=6
            integer(kind=inttype) parameter,optional :: costfuncforcez=7
            integer(kind=inttype) parameter,optional :: costfuncmomz=13
            integer(kind=inttype) parameter,optional :: costfunccdqdot=31
            integer(kind=inttype) parameter,optional :: costfuncmomx=11
            integer(kind=inttype) parameter,optional :: costfuncmomy=12
            integer(kind=inttype) parameter,optional :: costfunccdalphadot=29
            integer(kind=inttype) parameter,optional :: costfuncmomxcoef=14
            integer(kind=inttype) parameter,optional :: costfunccdalpha=28
            integer(kind=inttype) parameter,optional :: costfuncliftcoef=3
            integer(kind=inttype) parameter,optional :: costfunccmzalpha=18
            integer(kind=inttype) parameter,optional :: costfuncdragcoef=4
            integer(kind=inttype) parameter,optional :: costfuncclalphadot=24
            integer(kind=inttype) parameter,optional :: ncostfunction=37
            integer(kind=inttype) parameter,optional :: costfuncforceycoef=9
            integer(kind=inttype) parameter,optional :: costfuncclalpha=23
            integer(kind=inttype) parameter,optional :: costfuncmomycoef=15
            integer(kind=inttype) parameter,optional :: costfunccfy0=32	
            integer(kind=inttype) parameter,optional :: costfunccfyalpha=33 
            integer(kind=inttype) parameter,optional :: costfunccfyalphadot=34
            integer(kind=inttype) parameter,optional :: costfunccfyq=35
            integer(kind=inttype) parameter,optional :: costfunccfyqdot=36
            integer(kind=inttype) parameter,optional :: costfuncbendingcoef=37
       end module costfunctions

       module adjointpetsc ! in :sumb:ADjointPETSc.F90
         use constants
         real(kind=realtype) allocatable,dimension(:) :: adjreshist
         logical :: petscblockmatrix
         integer(kind=inttype) :: adjconvits
       end module adjointpetsc
       
       module adjointvars ! in :test:ADjointVars.F90
         use constants
         use costfunctions
         integer(kind=inttype) :: ncellslocal(20)
         integer(kind=inttype) :: nnodeslocal(20)
         integer(kind=inttype) :: ndesignpointrefz
         integer(kind=inttype) :: ndesignpointrefy
         integer(kind=inttype) :: ndesignssa
         integer(kind=inttype) :: ndesignextra
         integer(kind=inttype) :: ndesignrotcenx
         integer(kind=inttype) :: ndesignpointrefx
         integer(kind=inttype) :: ndesignrotz
         integer(kind=inttype) :: ndesignrotx
         integer(kind=inttype) :: ndesignroty
         integer(kind=inttype) :: ndesignrotcenz
         integer(kind=inttype) :: ndesignaoa
         integer(kind=inttype) :: ndesignrotceny
         real(kind=realtype) allocatable,dimension(:) :: dida
         integer(kind=inttype) :: ndesignmachgrid
         integer(kind=inttype) :: ndesignmach
         integer(kind=inttype) :: ndesignlengthref
         integer(kind=inttype) :: ndesignsurfaceref
         integer(kind=inttype) :: ndesigndisserror
       end module adjointvars

       module inputtsstabderiv ! in :test:inputParam.f90
         logical :: usewindaxis
         logical :: tsrmode
         logical :: tsstability
         logical :: tsbetamode
         logical :: tsmachmode
         logical :: tsaltitudemode
         logical :: tspmode
         logical :: tsqmode
         logical :: tsalphamode
       end module inputtsstabderiv

       module nksolvervars ! in :test:NKsolverVars.F90
         use constants
         integer(kind=inttype) :: innerpreconits
         integer(kind=inttype) :: outerpreconits
         integer(kind=inttype) :: jacobian_lag
         logical :: usenksolver
         logical :: nkfinitedifferencepc
         integer(kind=inttype) :: snes_max_funcs
         real(kind=realtype) :: snes_rtol
         character(len=maxstringlen) :: global_pc_side
         integer(kind=inttype) :: snes_max_its
         character(len=maxstringlen) :: ksp_solver_type
         integer(kind=inttype) :: ksp_subspace
         integer(kind=inttype) :: asm_overlap
         character(len=maxstringlen) :: global_pc_type
         real(kind=realtype) :: ksp_atol
         integer(kind=inttype) :: ksp_max_it
         integer(kind=inttype) :: local_pc_ilu_level
         real(kind=realtype) :: snes_stol
         real(kind=realtype) :: snes_atol
         character(len=maxstringlen) :: local_pc_ordering
         real(kind=realtype) :: ksp_div_tol=10
         real(kind=realtype) :: nk_switch_tol
         real(kind=realtype) :: ksp_rtol
         real(kind=realtype) :: totalr0
         real(kind=realtype) :: totalrstart
         real(kind=realtype) :: totalrfinal
         logical :: rkreset
         integer(kind=inttype) :: nrkreset
         integer(kind=inttype) :: applypcsubspacesize
       end module nksolvervars
      
       ! ############################################################################
       ! Coupler API Routines
       ! ############################################################################

       module couplerparam ! in :sumb:../../modules/couplerParam.f90 
         use precision
         use constants
         character(len=80) allocatable,dimension(:) :: datanamessumb
         integer(kind=inttype) :: nnodestrue
         integer(kind=inttype) :: ntetraalloc
         integer(kind=inttype) :: npyraalloc
         integer(kind=inttype) allocatable,dimension(:) :: iwsumb
         integer(kind=inttype) :: npyratrue
         integer(kind=inttype) :: ndatasumb
         integer(kind=inttype) :: nprismtrue
         real(kind=realtype) :: pini
         integer(kind=inttype) :: nprismalloc
         real(kind=realtype) dimension(3) :: veldirini
         integer(kind=inttype) :: nnodesalloc
         integer(kind=inttype) :: nhexatrue
         real(kind=realtype) :: rhoini
         integer(kind=inttype) :: ntetratrue
         integer parameter,optional :: maxcplnamelen=80
         logical :: cplgetcoarsesol
         integer(kind=inttype) :: nhexaalloc
         character(len=80) :: codename
         real(kind=realtype) :: machini

       end module couplerparam

       subroutine sumb_init ! in :sumb:../../utils/SUmb_init.f90
         use communication
         implicit none
       end subroutine SUmb_init

       subroutine sumb_finalize ! in :sumb:../../utils/SUmb_finalize.f90
         use communication
         implicit none
       end subroutine SUmb_finalize

    end interface 

#ifdef USE_COMPLEX
end python module libsumb_cs
#else
end python module libsumb
#endif

! This file was auto-generated with f2py (version:2.39.235_1700).
! See http://cens.ioc.ee/projects/f2py2e/
!
! File manually edited by Andre C. Marta and Seonghyeon Hahn on Aug.26,2005

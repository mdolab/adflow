   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of block_res in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: *(flowdoms.x) *(flowdoms.w)
   !                *(flowdoms.dw) *(*bcdata.f) *(*bcdata.m) pointref
   !                costfuncmat moment lift cforce drag force cd cl
   !                cmoment
   !   with respect to varying inputs: *(flowdoms.x) *(flowdoms.w)
   !                mach machgrid lengthref surfaceref machcoef pointref
   !                alpha beta
   !   RW status of diff variables: *(flowdoms.x):in-out *(flowdoms.w):in-out
   !                *(flowdoms.dw):out *(*bcdata.f):out *(*bcdata.m):out
   !                mach:in machgrid:in lengthref:in surfaceref:in
   !                machcoef:in pointref:in-out costfuncmat:out moment:out
   !                lift:out alpha:in cforce:out drag:out force:out
   !                cd:out beta:in cl:out cmoment:out
   !   Plus diff mem management of: flowdoms.x:in flowdoms.vol:in
   !                flowdoms.w:in flowdoms.dw:in rev:in bvtj1:in bvtj2:in
   !                p:in sfacei:in sfacej:in s:in gamma:in sfacek:in
   !                bmtk1:in bmtk2:in rlv:in bvtk1:in bvtk2:in bmti1:in
   !                bmti2:in si:in sj:in sk:in bvti1:in bvti2:in fw:in
   !                bmtj1:in bmtj2:in viscsubface:in *viscsubface.tau:in
   !                bcdata:in *bcdata.norm:in *bcdata.rface:in *bcdata.f:in
   !                *bcdata.m:in radi:in radj:in radk:in
   ! This is a super-combined function that combines the original
   ! functionality of: 
   ! Pressure Computation
   ! timeStep
   ! applyAllBCs
   ! initRes
   ! residual 
   ! The real difference between this and the original modules is that it
   ! it only operates on a single block at a time and as such the nominal
   ! block/sps loop is outside the calculation. This routine is suitable
   ! for forward mode AD with Tapenade
   SUBROUTINE BLOCK_RES_T(nn, sps, usespatial, useforces, alpha, alphad, &
   &  beta, betad, liftindex, force, forced, moment, momentd, lift, liftd, &
   &  drag, dragd, cforce, cforced, cmoment, cmomentd, cl, cld, cd, cdd)
   USE ITERATION
   USE FLOWVARREFSTATE
   USE DIFFSIZES
   USE MONITOR
   USE BLOCKPOINTERS_D
   USE INPUTADJOINT
   USE SECTION
   USE INPUTTIMESPECTRAL
   USE COSTFUNCTIONS
   USE INPUTPHYSICS
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   !  Hint: ISIZE4OFDrfflowdoms_w should be the size of dimension 4 of array *flowdoms%w
   !  Hint: ISIZE3OFDrfflowdoms_w should be the size of dimension 3 of array *flowdoms%w
   !  Hint: ISIZE2OFDrfflowdoms_w should be the size of dimension 2 of array *flowdoms%w
   !  Hint: ISIZE1OFDrfflowdoms_w should be the size of dimension 1 of array *flowdoms%w
   !  Hint: ISIZE4OFDrfflowdoms_x should be the size of dimension 4 of array *flowdoms%x
   !  Hint: ISIZE3OFDrfflowdoms_x should be the size of dimension 3 of array *flowdoms%x
   !  Hint: ISIZE2OFDrfflowdoms_x should be the size of dimension 2 of array *flowdoms%x
   !  Hint: ISIZE1OFDrfflowdoms_x should be the size of dimension 1 of array *flowdoms%x
   !  Hint: ISIZE3OFDrfradk should be the size of dimension 3 of array *radk
   !  Hint: ISIZE2OFDrfradk should be the size of dimension 2 of array *radk
   !  Hint: ISIZE1OFDrfradk should be the size of dimension 1 of array *radk
   !  Hint: ISIZE3OFDrfradj should be the size of dimension 3 of array *radj
   !  Hint: ISIZE2OFDrfradj should be the size of dimension 2 of array *radj
   !  Hint: ISIZE1OFDrfradj should be the size of dimension 1 of array *radj
   !  Hint: ISIZE3OFDrfradi should be the size of dimension 3 of array *radi
   !  Hint: ISIZE2OFDrfradi should be the size of dimension 2 of array *radi
   !  Hint: ISIZE1OFDrfradi should be the size of dimension 1 of array *radi
   !  Hint: ISIZE3OFDrfDrfbcdata_norm should be the size of dimension 3 of array **bcdata%norm
   !  Hint: ISIZE2OFDrfDrfbcdata_norm should be the size of dimension 2 of array **bcdata%norm
   !  Hint: ISIZE1OFDrfDrfbcdata_norm should be the size of dimension 1 of array **bcdata%norm
   !  Hint: ISIZE4OFDrfsk should be the size of dimension 4 of array *sk
   !  Hint: ISIZE3OFDrfsk should be the size of dimension 3 of array *sk
   !  Hint: ISIZE2OFDrfsk should be the size of dimension 2 of array *sk
   !  Hint: ISIZE1OFDrfsk should be the size of dimension 1 of array *sk
   !  Hint: ISIZE4OFDrfsj should be the size of dimension 4 of array *sj
   !  Hint: ISIZE3OFDrfsj should be the size of dimension 3 of array *sj
   !  Hint: ISIZE2OFDrfsj should be the size of dimension 2 of array *sj
   !  Hint: ISIZE1OFDrfsj should be the size of dimension 1 of array *sj
   !  Hint: ISIZE4OFDrfsi should be the size of dimension 4 of array *si
   !  Hint: ISIZE3OFDrfsi should be the size of dimension 3 of array *si
   !  Hint: ISIZE2OFDrfsi should be the size of dimension 2 of array *si
   !  Hint: ISIZE1OFDrfsi should be the size of dimension 1 of array *si
   !  Hint: ISIZE3OFDrfrlv should be the size of dimension 3 of array *rlv
   !  Hint: ISIZE2OFDrfrlv should be the size of dimension 2 of array *rlv
   !  Hint: ISIZE1OFDrfrlv should be the size of dimension 1 of array *rlv
   !  Hint: ISIZE3OFDrfsfacek should be the size of dimension 3 of array *sfacek
   !  Hint: ISIZE2OFDrfsfacek should be the size of dimension 2 of array *sfacek
   !  Hint: ISIZE1OFDrfsfacek should be the size of dimension 1 of array *sfacek
   !  Hint: ISIZE3OFDrfgamma should be the size of dimension 3 of array *gamma
   !  Hint: ISIZE2OFDrfgamma should be the size of dimension 2 of array *gamma
   !  Hint: ISIZE1OFDrfgamma should be the size of dimension 1 of array *gamma
   !  Hint: ISIZE3OFDrfsfacej should be the size of dimension 3 of array *sfacej
   !  Hint: ISIZE2OFDrfsfacej should be the size of dimension 2 of array *sfacej
   !  Hint: ISIZE1OFDrfsfacej should be the size of dimension 1 of array *sfacej
   !  Hint: ISIZE3OFDrfsfacei should be the size of dimension 3 of array *sfacei
   !  Hint: ISIZE2OFDrfsfacei should be the size of dimension 2 of array *sfacei
   !  Hint: ISIZE1OFDrfsfacei should be the size of dimension 1 of array *sfacei
   !  Hint: ISIZE3OFDrfp should be the size of dimension 3 of array *p
   !  Hint: ISIZE2OFDrfp should be the size of dimension 2 of array *p
   !  Hint: ISIZE1OFDrfp should be the size of dimension 1 of array *p
   !  Hint: ISIZE3OFDrfrev should be the size of dimension 3 of array *rev
   !  Hint: ISIZE2OFDrfrev should be the size of dimension 2 of array *rev
   !  Hint: ISIZE1OFDrfrev should be the size of dimension 1 of array *rev
   !  Hint: ISIZE4OFDrfflowdoms_dw should be the size of dimension 4 of array *flowdoms%dw
   !  Hint: ISIZE3OFDrfflowdoms_dw should be the size of dimension 3 of array *flowdoms%dw
   !  Hint: ISIZE2OFDrfflowdoms_dw should be the size of dimension 2 of array *flowdoms%dw
   !  Hint: ISIZE1OFDrfflowdoms_dw should be the size of dimension 1 of array *flowdoms%dw
   !  Hint: ISIZE3OFDrfflowdoms_vol should be the size of dimension 3 of array *flowdoms%vol
   !  Hint: ISIZE2OFDrfflowdoms_vol should be the size of dimension 2 of array *flowdoms%vol
   !  Hint: ISIZE1OFDrfflowdoms_vol should be the size of dimension 1 of array *flowdoms%vol
   !  Hint: ISIZE3OFDrfDrfbcdata_m should be the size of dimension 3 of array **bcdata%m
   !  Hint: ISIZE2OFDrfDrfbcdata_m should be the size of dimension 2 of array **bcdata%m
   !  Hint: ISIZE1OFDrfDrfbcdata_m should be the size of dimension 1 of array **bcdata%m
   !  Hint: ISIZE3OFDrfDrfbcdata_f should be the size of dimension 3 of array **bcdata%f
   !  Hint: ISIZE2OFDrfDrfbcdata_f should be the size of dimension 2 of array **bcdata%f
   !  Hint: ISIZE1OFDrfDrfbcdata_f should be the size of dimension 1 of array **bcdata%f
   IMPLICIT NONE
   ! Input Arguments:
   INTEGER(kind=inttype), INTENT(IN) :: nn, sps
   LOGICAL, INTENT(IN) :: usespatial, useforces
   REAL(kind=realtype), INTENT(IN) :: alpha, beta
   REAL(kind=realtype), INTENT(IN) :: alphad, betad
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   ! Output Arguments: Note: Cannot put intent(out) since reverse mode
   ! may NOT compute these values and then compilation will fail
   REAL(kind=realtype), DIMENSION(3) :: force, moment, cforce, cmoment
   REAL(kind=realtype), DIMENSION(3) :: forced, momentd, cforced, &
   &  cmomentd
   REAL(kind=realtype) :: lift, drag, cl, cd
   REAL(kind=realtype) :: liftd, dragd, cld, cdd
   ! Working Variables
   REAL(kind=realtype) :: gm1, v2, fact
   REAL(kind=realtype) :: v2d, factd
   INTEGER(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj, lend
   INTEGER(kind=inttype) :: nstate
   REAL(kind=realtype), DIMENSION(nsections) :: t
   REAL(kind=realtype), DIMENSION(nsections) :: td
   REAL(kind=realtype), DIMENSION(3) :: cfp, cfv, cmp, cmv
   REAL(kind=realtype), DIMENSION(3) :: cfpd, cfvd, cmpd, cmvd
   REAL(kind=realtype) :: yplusmax, scaledim, tmp
   REAL(kind=realtype) :: scaledimd, tmpd
   LOGICAL :: useoldcoor
   REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: wsp
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: volsp
   REAL(realtype) :: result1
   INTRINSIC MAX
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   INTRINSIC REAL
   INTEGER :: ii3
   INTEGER :: ii2
   INTEGER :: ii1
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2, ii1)%&
   &                              x, flowdomsd(ii3, ii2, ii1)%x, &
   &                              ISIZE1OFDrfflowdoms_x*&
   &                              ISIZE2OFDrfflowdoms_x*&
   &                              ISIZE3OFDrfflowdoms_x*&
   &                              ISIZE4OFDrfflowdoms_x)
   END DO
   END DO
   END DO
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2, ii1)%&
   &                              w, flowdomsd(ii3, ii2, ii1)%w, &
   &                              ISIZE1OFDrfflowdoms_w*&
   &                              ISIZE2OFDrfflowdoms_w*&
   &                              ISIZE3OFDrfflowdoms_w*&
   &                              ISIZE4OFDrfflowdoms_w)
   END DO
   END DO
   END DO
   CALL DEBUG_TGT_REAL8('mach', mach, machd)
   CALL DEBUG_TGT_REAL8('machgrid', machgrid, machgridd)
   CALL DEBUG_TGT_REAL8('lengthref', lengthref, lengthrefd)
   CALL DEBUG_TGT_REAL8('surfaceref', surfaceref, surfacerefd)
   CALL DEBUG_TGT_REAL8('machcoef', machcoef, machcoefd)
   CALL DEBUG_TGT_REAL8ARRAY('pointref', pointref, pointrefd, 3)
   CALL DEBUG_TGT_REAL8('alpha', alpha, alphad)
   CALL DEBUG_TGT_REAL8('beta', beta, betad)
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   useoldcoor = .false.
   ! Setup number of state variable based on turbulence assumption
   IF (frozenturbulence) THEN
   nstate = nwf
   ELSE
   nstate = nw
   END IF
   ! Set pointers to input/output variables
   wd => flowdomsd(nn, currentlevel, sps)%w
   w => flowdoms(nn, currentlevel, sps)%w
   dwd => flowdomsd(nn, 1, sps)%dw
   dw => flowdoms(nn, 1, sps)%dw
   xd => flowdomsd(nn, currentlevel, sps)%x
   x => flowdoms(nn, currentlevel, sps)%x
   vold => flowdomsd(nn, currentlevel, sps)%vol
   vol => flowdoms(nn, currentlevel, sps)%vol
   ! ------------------------------------------------
   !        Additional 'Extra' Components
   ! ------------------------------------------------ 
   liftdirectiond = 0.0_8
   dragdirectiond = 0.0_8
   CALL DEBUG_TGT_CALL('ADJUSTINFLOWANGLE', .TRUE., .FALSE.)
   CALL ADJUSTINFLOWANGLE_T(alpha, alphad, beta, betad, liftindex)
   CALL DEBUG_TGT_EXIT()
   CALL DEBUG_TGT_CALL('REFERENCESTATE', .TRUE., .FALSE.)
   CALL REFERENCESTATE_T()
   CALL DEBUG_TGT_EXIT()
   CALL DEBUG_TGT_CALL('SETFLOWINFINITYSTATE', .TRUE., .FALSE.)
   CALL SETFLOWINFINITYSTATE_T()
   CALL DEBUG_TGT_EXIT()
   ! ------------------------------------------------
   !        Additional Spatial Components
   ! ------------------------------------------------
   IF (usespatial) THEN
   CALL DEBUG_TGT_CALL('XHALO_BLOCK', .TRUE., .FALSE.)
   CALL XHALO_BLOCK_T()
   CALL DEBUG_TGT_EXIT()
   CALL DEBUG_TGT_CALL('METRIC_BLOCK', .TRUE., .FALSE.)
   CALL METRIC_BLOCK_T()
   CALL DEBUG_TGT_EXIT()
   ! -------------------------------------
   ! These functions are required for TS
   ! --------------------------------------
   t = timeunsteadyrestart
   IF (equationmode .EQ. timespectral) THEN
   DO mm=1,nsections
   result1 = REAL(ntimeintervalsspectral, realtype)
   td(mm) = 0.0_8
   t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/result1
   END DO
   END IF
   CALL DEBUG_TGT_CALL('GRIDVELOCITIESFINELEVEL_BLOCK', .TRUE., .FALSE.&
   &                 )
   CALL GRIDVELOCITIESFINELEVEL_BLOCK_T(useoldcoor, t, sps)
   CALL DEBUG_TGT_EXIT()
   CALL DEBUG_TGT_CALL('NORMALVELOCITIES_BLOCK', .TRUE., .FALSE.)
   ! Required for TS
   CALL NORMALVELOCITIES_BLOCK_T(sps)
   ! Required for TS
   CALL DEBUG_TGT_EXIT()
   ELSE
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   flowdomsd(ii3, ii2, ii1)%vol = 0.0_8
   END DO
   END DO
   END DO
   sfaceid = 0.0_8
   sfacejd = 0.0_8
   sd = 0.0_8
   sfacekd = 0.0_8
   sid = 0.0_8
   sjd = 0.0_8
   skd = 0.0_8
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%norm = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%rface = 0.0_8
   END DO
   END IF
   ! ------------------------------------------------
   !        Normal Residual Computation
   ! ------------------------------------------------
   ! Compute the pressures
   gm1 = gammaconstant - one
   pd = 0.0_8
   ! Compute P 
   DO k=0,kb
   DO j=0,jb
   DO i=0,ib
   v2d = 2*w(i, j, k, ivx)*wd(i, j, k, ivx) + 2*w(i, j, k, ivy)*wd(&
   &          i, j, k, ivy) + 2*w(i, j, k, ivz)*wd(i, j, k, ivz)
   v2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
   &          2
   pd(i, j, k) = gm1*(wd(i, j, k, irhoe)-half*(wd(i, j, k, irho)*v2&
   &          +w(i, j, k, irho)*v2d))
   p(i, j, k) = gm1*(w(i, j, k, irhoe)-half*w(i, j, k, irho)*v2)
   IF (p(i, j, k) .LT. 1.e-4_realType*pinfcorr) THEN
   pd(i, j, k) = 1.e-4_realType*pinfcorrd
   p(i, j, k) = 1.e-4_realType*pinfcorr
   ELSE
   p(i, j, k) = p(i, j, k)
   END IF
   END DO
   END DO
   END DO
   CALL DEBUG_TGT_CALL('COMPUTELAMVISCOSITY', .TRUE., .FALSE.)
   ! Compute Laminar/eddy viscosity if required
   CALL COMPUTELAMVISCOSITY_T()
   CALL DEBUG_TGT_EXIT()
   CALL DEBUG_TGT_CALL('COMPUTEEDDYVISCOSITY', .TRUE., .FALSE.)
   CALL COMPUTEEDDYVISCOSITY_T()
   CALL DEBUG_TGT_EXIT()
   CALL DEBUG_TGT_CALL('APPLYALLBC_BLOCK', .TRUE., .FALSE.)
   !  Apply all BC's
   CALL APPLYALLBC_BLOCK_T(.true.)
   CALL DEBUG_TGT_EXIT()
   CALL DEBUG_TGT_CALL('TIMESTEP_BLOCK', .TRUE., .FALSE.)
   ! Compute skin_friction Velocity (only for wall Functions)
   ! #ifndef TAPENADE_REVERSE
   !   call computeUtau_block
   ! #endif
   ! Compute time step and spectral radius
   CALL TIMESTEP_BLOCK_T(.false.)
   CALL DEBUG_TGT_EXIT()
   ! -------------------------------
   ! Compute turbulence residual for RANS equations
   IF (equations .EQ. ransequations) THEN
   CALL DEBUG_TGT_CALL('UNSTEADYTURBSPECTRAL_BLOCK', .TRUE., .FALSE.)
   ! Initialize only the Turblent Variables
   CALL UNSTEADYTURBSPECTRAL_BLOCK_T(itu1, itu2, nn, sps)
   CALL DEBUG_TGT_EXIT()
   SELECT CASE  (turbmodel) 
   CASE (spalartallmaras) 
   CALL DEBUG_TGT_CALL('SA_BLOCK', .TRUE., .FALSE.)
   !call determineDistance2(1, sps)
   CALL SA_BLOCK_T(.true.)
   CALL DEBUG_TGT_EXIT()
   CASE DEFAULT
   CALL TERMINATE('turbResidual', &
   &                  'Only SA turbulence adjoint implemented')
   END SELECT
   ELSE
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
   END DO
   END DO
   END DO
   END IF
   ! -------------------------------  
   ! Next initialize residual for flow variables. The is the only place
   ! where there is an n^2 dependance. There are issues with
   ! initRes. So only the necesary timespectral code has been copied
   ! here. See initres for more information and comments.
   ! sps here is the on-spectral instance
   IF (ntimeintervalsspectral .EQ. 1) THEN
   dwd(:, :, :, 1:nwf) = 0.0_8
   dw(:, :, :, 1:nwf) = zero
   ELSE
   ! Zero dw on all spectral instances
   spectralloop1:DO sps2=1,ntimeintervalsspectral
   flowdomsd(nn, 1, sps2)%dw(:, :, :, 1:nwf) = 0.0_8
   flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
   END DO spectralloop1
   spectralloop2:DO sps2=1,ntimeintervalsspectral
   jj = sectionid
   timeloopfine:DO mm=1,ntimeintervalsspectral
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2&
   &                                    , ii1)%x, flowdomsd(ii3, ii2, ii1)%x&
   &                                    , ISIZE1OFDrfflowdoms_x*&
   &                                    ISIZE2OFDrfflowdoms_x*&
   &                                    ISIZE3OFDrfflowdoms_x*&
   &                                    ISIZE4OFDrfflowdoms_x)
   END DO
   END DO
   END DO
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2&
   &                                    , ii1)%vol, flowdomsd(ii3, ii2, ii1)&
   &                                    %vol, ISIZE1OFDrfflowdoms_vol*&
   &                                    ISIZE2OFDrfflowdoms_vol*&
   &                                    ISIZE3OFDrfflowdoms_vol)
   END DO
   END DO
   END DO
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2&
   &                                    , ii1)%w, flowdomsd(ii3, ii2, ii1)%w&
   &                                    , ISIZE1OFDrfflowdoms_w*&
   &                                    ISIZE2OFDrfflowdoms_w*&
   &                                    ISIZE3OFDrfflowdoms_w*&
   &                                    ISIZE4OFDrfflowdoms_w)
   END DO
   END DO
   END DO
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2&
   &                                    , ii1)%dw, flowdomsd(ii3, ii2, ii1)%&
   &                                    dw, ISIZE1OFDrfflowdoms_dw*&
   &                                    ISIZE2OFDrfflowdoms_dw*&
   &                                    ISIZE3OFDrfflowdoms_dw*&
   &                                    ISIZE4OFDrfflowdoms_dw)
   END DO
   END DO
   END DO
   CALL DEBUG_TGT_REAL8ARRAY('rev', rev, revd, ISIZE1OFDrfrev*&
   &                              ISIZE2OFDrfrev*ISIZE3OFDrfrev)
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFDrfp*&
   &                              ISIZE2OFDrfp*ISIZE3OFDrfp)
   CALL DEBUG_TGT_REAL8ARRAY('sfacei', sfacei, sfaceid, &
   &                              ISIZE1OFDrfsfacei*ISIZE2OFDrfsfacei*&
   &                              ISIZE3OFDrfsfacei)
   CALL DEBUG_TGT_REAL8ARRAY('sfacej', sfacej, sfacejd, &
   &                              ISIZE1OFDrfsfacej*ISIZE2OFDrfsfacej*&
   &                              ISIZE3OFDrfsfacej)
   CALL DEBUG_TGT_REAL8ARRAY('gamma', gamma, gammad, &
   &                              ISIZE1OFDrfgamma*ISIZE2OFDrfgamma*&
   &                              ISIZE3OFDrfgamma)
   CALL DEBUG_TGT_REAL8ARRAY('sfacek', sfacek, sfacekd, &
   &                              ISIZE1OFDrfsfacek*ISIZE2OFDrfsfacek*&
   &                              ISIZE3OFDrfsfacek)
   CALL DEBUG_TGT_REAL8ARRAY('rlv', rlv, rlvd, ISIZE1OFDrfrlv*&
   &                              ISIZE2OFDrfrlv*ISIZE3OFDrfrlv)
   CALL DEBUG_TGT_REAL8ARRAY('si', si, sid, ISIZE1OFDrfsi*&
   &                              ISIZE2OFDrfsi*ISIZE3OFDrfsi*ISIZE4OFDrfsi)
   CALL DEBUG_TGT_REAL8ARRAY('sj', sj, sjd, ISIZE1OFDrfsj*&
   &                              ISIZE2OFDrfsj*ISIZE3OFDrfsj*ISIZE4OFDrfsj)
   CALL DEBUG_TGT_REAL8ARRAY('sk', sk, skd, ISIZE1OFDrfsk*&
   &                              ISIZE2OFDrfsk*ISIZE3OFDrfsk*ISIZE4OFDrfsk)
   DO ii1=1,ISIZE1OFDrfbcdata
   CALL DEBUG_TGT_REAL8ARRAY('bcdata', bcdata(ii1)%norm, &
   &                                bcdatad(ii1)%norm, &
   &                                ISIZE1OFDrfDrfbcdata_norm*&
   &                                ISIZE2OFDrfDrfbcdata_norm*&
   &                                ISIZE3OFDrfDrfbcdata_norm)
   END DO
   CALL DEBUG_TGT_REAL8ARRAY('radi', radi, radid, ISIZE1OFDrfradi&
   &                              *ISIZE2OFDrfradi*ISIZE3OFDrfradi)
   CALL DEBUG_TGT_REAL8ARRAY('radj', radj, radjd, ISIZE1OFDrfradj&
   &                              *ISIZE2OFDrfradj*ISIZE3OFDrfradj)
   CALL DEBUG_TGT_REAL8ARRAY('radk', radk, radkd, ISIZE1OFDrfradk&
   &                              *ISIZE2OFDrfradk*ISIZE3OFDrfradk)
   CALL DEBUG_TGT_REAL8('pinf', pinf, pinfd)
   CALL DEBUG_TGT_REAL8('timeref', timeref, timerefd)
   CALL DEBUG_TGT_REAL8('rhoinf', rhoinf, rhoinfd)
   CALL DEBUG_TGT_REAL8('pinfcorr', pinfcorr, pinfcorrd)
   CALL DEBUG_TGT_REAL8('rgas', rgas, rgasd)
   CALL DEBUG_TGT_REAL8('pref', pref, prefd)
   CALL DEBUG_TGT_REAL8('lengthref', lengthref, lengthrefd)
   CALL DEBUG_TGT_REAL8('surfaceref', surfaceref, surfacerefd)
   CALL DEBUG_TGT_REAL8('machcoef', machcoef, machcoefd)
   CALL DEBUG_TGT_REAL8ARRAY('dragdirection', dragdirection, &
   &                              dragdirectiond, 3)
   CALL DEBUG_TGT_REAL8ARRAY('liftdirection', liftdirection, &
   &                              liftdirectiond, 3)
   CALL DEBUG_TGT_REAL8ARRAY('pointref', pointref, pointrefd, 3)
   CALL DEBUG_TGT_REAL8('alpha', alpha, alphad)
   CALL DEBUG_TGT_REAL8('beta', beta, betad)
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   ii = 3*(mm-1)
   varloopfine:DO l=1,nwf
   IF ((l .EQ. ivx .OR. l .EQ. ivy) .OR. l .EQ. ivz) THEN
   IF (l .EQ. ivx) ll = 3*sps2 - 2
   IF (l .EQ. ivy) ll = 3*sps2 - 1
   IF (l .EQ. ivz) ll = 3*sps2
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   tmpd = dvector(jj, ll, ii+1)*flowdomsd(nn, 1, mm)%w(i&
   &                    , j, k, ivx) + dvector(jj, ll, ii+2)*flowdomsd(nn, 1&
   &                    , mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
   &                    flowdomsd(nn, 1, mm)%w(i, j, k, ivz)
   tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i, j&
   &                    , k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, 1, mm&
   &                    )%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*flowdoms(&
   &                    nn, 1, mm)%w(i, j, k, ivz)
   flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
   &                    1, sps2)%dw(i, j, k, l) + (tmpd*flowdoms(nn, 1, mm)%&
   &                    vol(i, j, k)+tmp*flowdomsd(nn, 1, mm)%vol(i, j, k))*&
   &                    flowdoms(nn, 1, mm)%w(i, j, k, irho) + tmp*flowdoms(&
   &                    nn, 1, mm)%vol(i, j, k)*flowdomsd(nn, 1, mm)%w(i, j&
   &                    , k, irho)
   flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
   &                    , sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%vol&
   &                    (i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
   END DO
   END DO
   END DO
   ELSE
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! This is: dw = dw + dscalar*vol*w
   flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
   &                    1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*(&
   &                    flowdomsd(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm&
   &                    )%w(i, j, k, l)+flowdoms(nn, 1, mm)%vol(i, j, k)*&
   &                    flowdomsd(nn, 1, mm)%w(i, j, k, l))
   flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
   &                    , sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
   &                    flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm)&
   &                    %w(i, j, k, l)
   END DO
   END DO
   END DO
   END IF
   END DO varloopfine
   END DO timeloopfine
   END DO spectralloop2
   END IF
   CALL DEBUG_TGT_CALL('RESIDUAL_BLOCK', .TRUE., .FALSE.)
   !  Actual residual calc
   CALL RESIDUAL_BLOCK_T()
   CALL DEBUG_TGT_EXIT()
   ! Divide through by the volume
   DO sps2=1,ntimeintervalsspectral
   DO l=1,nstate
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = (flowdomsd(nn, 1, &
   &              sps2)%dw(i, j, k, l)*flowdoms(nn, currentlevel, sps2)%vol(&
   &              i, j, k)-flowdoms(nn, 1, sps2)%dw(i, j, k, l)*flowdomsd(nn&
   &              , currentlevel, sps2)%vol(i, j, k))/flowdoms(nn, &
   &              currentlevel, sps2)%vol(i, j, k)**2
   flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, sps2)&
   &              %dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%vol(i, j&
   &              , k)
   END DO
   END DO
   END DO
   END DO
   END DO
   ! We are now done with the residuals, we move on to the forces and
   ! moments
   IF (useforces) THEN
   CALL DEBUG_TGT_CALL('FORCESANDMOMENTS', .TRUE., .FALSE.)
   CALL FORCESANDMOMENTS_T(cfp, cfpd, cfv, cfvd, cmp, cmpd, cmv, cmvd, &
   &                      yplusmax)
   CALL DEBUG_TGT_EXIT()
   scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
   scaledim = pref/pinf
   ! Sum pressure and viscous contributions
   cforced = cfpd + cfvd
   cforce = cfp + cfv
   cmomentd = cmpd + cmvd
   cmoment = cmp + cmv
   ! Get Lift coef and Drag coef
   cdd = cforced(1)*dragdirection(1) + cforce(1)*dragdirectiond(1) + &
   &      cforced(2)*dragdirection(2) + cforce(2)*dragdirectiond(2) + &
   &      cforced(3)*dragdirection(3) + cforce(3)*dragdirectiond(3)
   cd = cforce(1)*dragdirection(1) + cforce(2)*dragdirection(2) + &
   &      cforce(3)*dragdirection(3)
   cld = cforced(1)*liftdirection(1) + cforce(1)*liftdirectiond(1) + &
   &      cforced(2)*liftdirection(2) + cforce(2)*liftdirectiond(2) + &
   &      cforced(3)*liftdirection(3) + cforce(3)*liftdirectiond(3)
   cl = cforce(1)*liftdirection(1) + cforce(2)*liftdirection(2) + &
   &      cforce(3)*liftdirection(3)
   ! Divide by fact to get the forces, Lift and Drag back
   factd = -(two*gammainf*lref**2*(((pinfd*machcoef+pinf*machcoefd)*&
   &      scaledim+pinf*machcoef*scaledimd)*machcoef*surfaceref+pinf*&
   &      machcoef*scaledim*(machcoefd*surfaceref+machcoef*surfacerefd))/(&
   &      gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*scaledim)**2)
   fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
   &      scaledim)
   forced = (cforced*fact-cforce*factd)/fact**2
   force = cforce/fact
   liftd = (cld*fact-cl*factd)/fact**2
   lift = cl/fact
   dragd = (cdd*fact-cd*factd)/fact**2
   drag = cd/fact
   ! Moment factor has an extra lengthRef
   factd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*lref)&
   &      **2
   fact = fact/(lengthref*lref)
   momentd = (cmomentd*fact-cmoment*factd)/fact**2
   moment = cmoment/fact
   ELSE
   force = zero
   moment = zero
   cforce = zero
   cmoment = zero
   lift = zero
   drag = zero
   cd = zero
   cd = zero
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%f = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%m = 0.0_8
   END DO
   momentd = 0.0_8
   liftd = 0.0_8
   cforced = 0.0_8
   dragd = 0.0_8
   forced = 0.0_8
   cdd = 0.0_8
   cld = 0.0_8
   cmomentd = 0.0_8
   END IF
   CALL DEBUG_TGT_CALL('GETCOSTFUNCMAT', .TRUE., .FALSE.)
   CALL GETCOSTFUNCMAT_T(alpha, alphad, beta, betad, liftindex)
   CALL DEBUG_TGT_EXIT()
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2, ii1)%&
   &                              x, flowdomsd(ii3, ii2, ii1)%x, &
   &                              ISIZE1OFDrfflowdoms_x*&
   &                              ISIZE2OFDrfflowdoms_x*&
   &                              ISIZE3OFDrfflowdoms_x*&
   &                              ISIZE4OFDrfflowdoms_x)
   END DO
   END DO
   END DO
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2, ii1)%&
   &                              w, flowdomsd(ii3, ii2, ii1)%w, &
   &                              ISIZE1OFDrfflowdoms_w*&
   &                              ISIZE2OFDrfflowdoms_w*&
   &                              ISIZE3OFDrfflowdoms_w*&
   &                              ISIZE4OFDrfflowdoms_w)
   END DO
   END DO
   END DO
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2, ii1)%&
   &                              dw, flowdomsd(ii3, ii2, ii1)%dw, &
   &                              ISIZE1OFDrfflowdoms_dw*&
   &                              ISIZE2OFDrfflowdoms_dw*&
   &                              ISIZE3OFDrfflowdoms_dw*&
   &                              ISIZE4OFDrfflowdoms_dw)
   END DO
   END DO
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   CALL DEBUG_TGT_REAL8ARRAY('bcdata', bcdata(ii1)%f, bcdatad(ii1)%f&
   &                          , ISIZE1OFDrfDrfbcdata_f*&
   &                          ISIZE2OFDrfDrfbcdata_f*ISIZE3OFDrfDrfbcdata_f)
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   CALL DEBUG_TGT_REAL8ARRAY('bcdata', bcdata(ii1)%m, bcdatad(ii1)%m&
   &                          , ISIZE1OFDrfDrfbcdata_m*&
   &                          ISIZE2OFDrfDrfbcdata_m*ISIZE3OFDrfDrfbcdata_m)
   END DO
   CALL DEBUG_TGT_REAL8ARRAY('pointref', pointref, pointrefd, 3)
   CALL DEBUG_TGT_REAL8ARRAY('costfuncmat', costfuncmat, costfuncmatd, &
   &                        6*ncostfunction)
   CALL DEBUG_TGT_REAL8ARRAY('moment', moment, momentd, 3)
   CALL DEBUG_TGT_REAL8('lift', lift, liftd)
   CALL DEBUG_TGT_REAL8ARRAY('cforce', cforce, cforced, 3)
   CALL DEBUG_TGT_REAL8('drag', drag, dragd)
   CALL DEBUG_TGT_REAL8ARRAY('force', force, forced, 3)
   CALL DEBUG_TGT_REAL8('cd', cd, cdd)
   CALL DEBUG_TGT_REAL8('cl', cl, cld)
   CALL DEBUG_TGT_REAL8ARRAY('cmoment', cmoment, cmomentd, 3)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END SUBROUTINE BLOCK_RES_T

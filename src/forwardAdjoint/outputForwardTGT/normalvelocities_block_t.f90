   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of normalvelocities_block in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: *(*bcdata.rface)
   !   with respect to varying inputs: *sfacei *sfacej *sfacek *si
   !                *sj *sk
   !   Plus diff mem management of: sfacei:in sfacej:in sfacek:in
   !                si:in sj:in sk:in bcdata:in *bcdata.rface:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          normalVelocities.f90                            *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 02-23-2004                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE NORMALVELOCITIES_BLOCK_T(sps)
   USE ITERATION
   USE BLOCKPOINTERS_D
   USE BCTYPES
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   !  Hint: ISIZE4OFDrfsk should be the size of dimension 4 of array *sk
   !  Hint: ISIZE3OFDrfsk should be the size of dimension 3 of array *sk
   !  Hint: ISIZE2OFDrfsk should be the size of dimension 2 of array *sk
   !  Hint: ISIZE1OFDrfsk should be the size of dimension 1 of array *sk
   !  Hint: ISIZE4OFDrfsj should be the size of dimension 4 of array *sj
   !  Hint: ISIZE3OFDrfsj should be the size of dimension 3 of array *sj
   !  Hint: ISIZE2OFDrfsj should be the size of dimension 2 of array *sj
   !  Hint: ISIZE1OFDrfsj should be the size of dimension 1 of array *sj
   !  Hint: ISIZE4OFDrfsi should be the size of dimension 4 of array *si
   !  Hint: ISIZE3OFDrfsi should be the size of dimension 3 of array *si
   !  Hint: ISIZE2OFDrfsi should be the size of dimension 2 of array *si
   !  Hint: ISIZE1OFDrfsi should be the size of dimension 1 of array *si
   !  Hint: ISIZE3OFDrfsfacek should be the size of dimension 3 of array *sfacek
   !  Hint: ISIZE2OFDrfsfacek should be the size of dimension 2 of array *sfacek
   !  Hint: ISIZE1OFDrfsfacek should be the size of dimension 1 of array *sfacek
   !  Hint: ISIZE3OFDrfsfacej should be the size of dimension 3 of array *sfacej
   !  Hint: ISIZE2OFDrfsfacej should be the size of dimension 2 of array *sfacej
   !  Hint: ISIZE1OFDrfsfacej should be the size of dimension 1 of array *sfacej
   !  Hint: ISIZE3OFDrfsfacei should be the size of dimension 3 of array *sfacei
   !  Hint: ISIZE2OFDrfsfacei should be the size of dimension 2 of array *sfacei
   !  Hint: ISIZE1OFDrfsfacei should be the size of dimension 1 of array *sfacei
   !  Hint: ISIZE2OFDrfDrfbcdata_rface should be the size of dimension 2 of array **bcdata%rface
   !  Hint: ISIZE1OFDrfDrfbcdata_rface should be the size of dimension 1 of array **bcdata%rface
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * normalVelocitiesAllLevels computes the normal grid             *
   !      * velocities of some boundary faces of the moving blocks for     *
   !      * spectral mode sps. All grid levels from ground level to the    *
   !      * coarsest level are considered.                                 *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: sps
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm
   INTEGER(kind=inttype) :: i, j
   REAL(kind=realtype) :: weight, mult
   REAL(kind=realtype) :: weightd
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: sface
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: sfaced
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssd
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   INTEGER :: ii1
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   INTRINSIC ASSOCIATED
   INTRINSIC SQRT
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('sfacei', sfacei, sfaceid, &
   &                        ISIZE1OFDrfsfacei*ISIZE2OFDrfsfacei*&
   &                        ISIZE3OFDrfsfacei)
   CALL DEBUG_TGT_REAL8ARRAY('sfacej', sfacej, sfacejd, &
   &                        ISIZE1OFDrfsfacej*ISIZE2OFDrfsfacej*&
   &                        ISIZE3OFDrfsfacej)
   CALL DEBUG_TGT_REAL8ARRAY('sfacek', sfacek, sfacekd, &
   &                        ISIZE1OFDrfsfacek*ISIZE2OFDrfsfacek*&
   &                        ISIZE3OFDrfsfacek)
   CALL DEBUG_TGT_REAL8ARRAY('si', si, sid, ISIZE1OFDrfsi*ISIZE2OFDrfsi&
   &                        *ISIZE3OFDrfsi*ISIZE4OFDrfsi)
   CALL DEBUG_TGT_REAL8ARRAY('sj', sj, sjd, ISIZE1OFDrfsj*ISIZE2OFDrfsj&
   &                        *ISIZE3OFDrfsj*ISIZE4OFDrfsj)
   CALL DEBUG_TGT_REAL8ARRAY('sk', sk, skd, ISIZE1OFDrfsk*ISIZE2OFDrfsk&
   &                        *ISIZE3OFDrfsk*ISIZE4OFDrfsk)
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check for a moving block. As it is possible that in a
   ! multidisicplinary environment additional grid velocities
   ! are set, the test should be done on addGridVelocities
   ! and not on blockIsMoving.
   IF (addgridvelocities) THEN
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%rface = 0.0_8
   END DO
   !
   !            ************************************************************
   !            *                                                          *
   !            * Determine the normal grid velocities of the boundaries.  *
   !            * As these values are based on the unit normal. A division *
   !            * by the length of the normal is needed.                   *
   !            * Furthermore the boundary unit normals are per definition *
   !            * outward pointing, while on the iMin, jMin and kMin       *
   !            * boundaries the face normals are inward pointing. This    *
   !            * is taken into account by the factor mult.                *
   !            *                                                          *
   !            ************************************************************
   !
   ! Loop over the boundary subfaces.
   bocoloop:DO mm=1,nbocos
   ! Check whether rFace is allocated.
   IF (ASSOCIATED(bcdata(mm)%rface)) THEN
   ! Determine the block face on which the subface is
   ! located and set some variables accordingly.
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   mult = -one
   ssd => sid(1, :, :, :)
   ss => si(1, :, :, :)
   sfaced => sfaceid(1, :, :)
   sface => sfacei(1, :, :)
   CASE (imax) 
   mult = one
   ssd => sid(il, :, :, :)
   ss => si(il, :, :, :)
   sfaced => sfaceid(il, :, :)
   sface => sfacei(il, :, :)
   CASE (jmin) 
   mult = -one
   ssd => sjd(:, 1, :, :)
   ss => sj(:, 1, :, :)
   sfaced => sfacejd(:, 1, :)
   sface => sfacej(:, 1, :)
   CASE (jmax) 
   mult = one
   ssd => sjd(:, jl, :, :)
   ss => sj(:, jl, :, :)
   sfaced => sfacejd(:, jl, :)
   sface => sfacej(:, jl, :)
   CASE (kmin) 
   mult = -one
   ssd => skd(:, :, 1, :)
   ss => sk(:, :, 1, :)
   sfaced => sfacekd(:, :, 1)
   sface => sfacek(:, :, 1)
   CASE (kmax) 
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('sfacei', sfacei, sfaceid, &
   &                                ISIZE1OFDrfsfacei*ISIZE2OFDrfsfacei*&
   &                                ISIZE3OFDrfsfacei)
   CALL DEBUG_TGT_REAL8ARRAY('sfacej', sfacej, sfacejd, &
   &                                ISIZE1OFDrfsfacej*ISIZE2OFDrfsfacej*&
   &                                ISIZE3OFDrfsfacej)
   CALL DEBUG_TGT_REAL8ARRAY('sfacek', sfacek, sfacekd, &
   &                                ISIZE1OFDrfsfacek*ISIZE2OFDrfsfacek*&
   &                                ISIZE3OFDrfsfacek)
   CALL DEBUG_TGT_REAL8ARRAY('si', si, sid, ISIZE1OFDrfsi*&
   &                                ISIZE2OFDrfsi*ISIZE3OFDrfsi*&
   &                                ISIZE4OFDrfsi)
   CALL DEBUG_TGT_REAL8ARRAY('sj', sj, sjd, ISIZE1OFDrfsj*&
   &                                ISIZE2OFDrfsj*ISIZE3OFDrfsj*&
   &                                ISIZE4OFDrfsj)
   CALL DEBUG_TGT_REAL8ARRAY('sk', sk, skd, ISIZE1OFDrfsk*&
   &                                ISIZE2OFDrfsk*ISIZE3OFDrfsk*&
   &                                ISIZE4OFDrfsk)
   DO ii1=1,ISIZE1OFDrfbcdata
   CALL DEBUG_TGT_REAL8ARRAY('bcdata', bcdata(ii1)%rface, &
   &                                  bcdatad(ii1)%rface, &
   &                                  ISIZE1OFDrfDrfbcdata_rface*&
   &                                  ISIZE2OFDrfDrfbcdata_rface)
   END DO
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   mult = one
   ssd => skd(:, :, kl, :)
   ss => sk(:, :, kl, :)
   sfaced => sfacekd(:, :, kl)
   sface => sfacek(:, :, kl)
   END SELECT
   ! Loop over the faces of the subface.
   DO j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
   DO i=bcdata(mm)%icbeg,bcdata(mm)%icend
   ! Compute the inverse of the length of the normal
   ! vector and possibly correct for inward pointing.
   arg1d = 2*ss(i, j, 1)*ssd(i, j, 1) + 2*ss(i, j, 2)*ssd(i, j&
   &              , 2) + 2*ss(i, j, 3)*ssd(i, j, 3)
   arg1 = ss(i, j, 1)**2 + ss(i, j, 2)**2 + ss(i, j, 3)**2
   IF (arg1 .EQ. 0.0_8) THEN
   weightd = 0.0_8
   ELSE
   weightd = arg1d/(2.0*SQRT(arg1))
   END IF
   weight = SQRT(arg1)
   IF (weight .GT. zero) THEN
   weightd = -(mult*weightd/weight**2)
   weight = mult/weight
   END IF
   ! Compute the normal velocity based on the outward
   ! pointing unit normal.
   bcdatad(mm)%rface(i, j) = weightd*sface(i, j) + weight*&
   &              sfaced(i, j)
   bcdata(mm)%rface(i, j) = weight*sface(i, j)
   END DO
   END DO
   END IF
   END DO bocoloop
   ELSE
   ! Block is not moving. Loop over the boundary faces and set
   ! the normal grid velocity to zero if allocated.
   DO mm=1,nbocos
   IF (ASSOCIATED(bcdata(mm)%rface)) THEN
   bcdatad(mm)%rface = 0.0_8
   bcdata(mm)%rface = zero
   END IF
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%rface = 0.0_8
   END DO
   END IF
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   DO ii1=1,ISIZE1OFDrfbcdata
   CALL DEBUG_TGT_REAL8ARRAY('bcdata', bcdata(ii1)%rface, bcdatad(ii1&
   &                          )%rface, ISIZE1OFDrfDrfbcdata_rface*&
   &                          ISIZE2OFDrfDrfbcdata_rface)
   END DO
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END SUBROUTINE NORMALVELOCITIES_BLOCK_T

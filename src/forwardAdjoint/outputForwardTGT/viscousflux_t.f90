   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of viscousflux in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: *p *fw *(*viscsubface.tau)
   !   with respect to varying inputs: *rev *p *gamma *w *rlv *x *vol
   !                *si *sj *sk *fw *(*bcdata.norm)
   !   Plus diff mem management of: rev:in p:in gamma:in w:in rlv:in
   !                x:in vol:in si:in sj:in sk:in fw:in viscsubface:in
   !                *viscsubface.tau:in bcdata:in *bcdata.norm:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          viscousFlux.f90                                 *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-21-2003                                      *
   !      * Last modified: 04-18-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE VISCOUSFLUX_T()
   USE ITERATION
   USE FLOWVARREFSTATE
   USE BLOCKPOINTERS_D
   USE INPUTPHYSICS
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfviscsubface should be the size of dimension 1 of array *viscsubface
   !  Hint: ISIZE3OFDrfDrfbcdata_norm should be the size of dimension 3 of array **bcdata%norm
   !  Hint: ISIZE2OFDrfDrfbcdata_norm should be the size of dimension 2 of array **bcdata%norm
   !  Hint: ISIZE1OFDrfDrfbcdata_norm should be the size of dimension 1 of array **bcdata%norm
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   !  Hint: ISIZE4OFDrffw should be the size of dimension 4 of array *fw
   !  Hint: ISIZE3OFDrffw should be the size of dimension 3 of array *fw
   !  Hint: ISIZE2OFDrffw should be the size of dimension 2 of array *fw
   !  Hint: ISIZE1OFDrffw should be the size of dimension 1 of array *fw
   !  Hint: ISIZE4OFDrfsk should be the size of dimension 4 of array *sk
   !  Hint: ISIZE3OFDrfsk should be the size of dimension 3 of array *sk
   !  Hint: ISIZE2OFDrfsk should be the size of dimension 2 of array *sk
   !  Hint: ISIZE1OFDrfsk should be the size of dimension 1 of array *sk
   !  Hint: ISIZE4OFDrfsj should be the size of dimension 4 of array *sj
   !  Hint: ISIZE3OFDrfsj should be the size of dimension 3 of array *sj
   !  Hint: ISIZE2OFDrfsj should be the size of dimension 2 of array *sj
   !  Hint: ISIZE1OFDrfsj should be the size of dimension 1 of array *sj
   !  Hint: ISIZE4OFDrfsi should be the size of dimension 4 of array *si
   !  Hint: ISIZE3OFDrfsi should be the size of dimension 3 of array *si
   !  Hint: ISIZE2OFDrfsi should be the size of dimension 2 of array *si
   !  Hint: ISIZE1OFDrfsi should be the size of dimension 1 of array *si
   !  Hint: ISIZE3OFDrfvol should be the size of dimension 3 of array *vol
   !  Hint: ISIZE2OFDrfvol should be the size of dimension 2 of array *vol
   !  Hint: ISIZE1OFDrfvol should be the size of dimension 1 of array *vol
   !  Hint: ISIZE4OFDrfx should be the size of dimension 4 of array *x
   !  Hint: ISIZE3OFDrfx should be the size of dimension 3 of array *x
   !  Hint: ISIZE2OFDrfx should be the size of dimension 2 of array *x
   !  Hint: ISIZE1OFDrfx should be the size of dimension 1 of array *x
   !  Hint: ISIZE3OFDrfrlv should be the size of dimension 3 of array *rlv
   !  Hint: ISIZE2OFDrfrlv should be the size of dimension 2 of array *rlv
   !  Hint: ISIZE1OFDrfrlv should be the size of dimension 1 of array *rlv
   !  Hint: ISIZE4OFDrfw should be the size of dimension 4 of array *w
   !  Hint: ISIZE3OFDrfw should be the size of dimension 3 of array *w
   !  Hint: ISIZE2OFDrfw should be the size of dimension 2 of array *w
   !  Hint: ISIZE1OFDrfw should be the size of dimension 1 of array *w
   !  Hint: ISIZE3OFDrfgamma should be the size of dimension 3 of array *gamma
   !  Hint: ISIZE2OFDrfgamma should be the size of dimension 2 of array *gamma
   !  Hint: ISIZE1OFDrfgamma should be the size of dimension 1 of array *gamma
   !  Hint: ISIZE3OFDrfp should be the size of dimension 3 of array *p
   !  Hint: ISIZE2OFDrfp should be the size of dimension 2 of array *p
   !  Hint: ISIZE1OFDrfp should be the size of dimension 1 of array *p
   !  Hint: ISIZE3OFDrfrev should be the size of dimension 3 of array *rev
   !  Hint: ISIZE2OFDrfrev should be the size of dimension 2 of array *rev
   !  Hint: ISIZE1OFDrfrev should be the size of dimension 1 of array *rev
   !  Hint: ISIZE3OFDrfDrfviscsubface_tau should be the size of dimension 3 of array **viscsubface%tau
   !  Hint: ISIZE2OFDrfDrfviscsubface_tau should be the size of dimension 2 of array **viscsubface%tau
   !  Hint: ISIZE1OFDrfDrfviscsubface_tau should be the size of dimension 1 of array **viscsubface%tau
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * viscousFlux computes the viscous fluxes using a central        *
   !      * difference scheme for a block.                                 *
   !      * It is assumed that the pointers in block pointer already point *
   !      * to the correct block.                                          *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: twothird=two*third
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, nn
   INTEGER(kind=inttype) :: k1, k2, kk
   REAL(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
   REAL(kind=realtype) :: muld, mued, mutd, heatcoefd
   REAL(kind=realtype) :: gm1, factlamheat, factturbheat
   REAL(kind=realtype) :: gm1d, factlamheatd, factturbheatd
   REAL(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
   REAL(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, w_yd&
   &  , w_zd
   REAL(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
   REAL(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
   REAL(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
   REAL(kind=realtype) :: corrd, ssxd, ssyd, sszd, ssd, fracdivd
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxd, tauyyd, tauzzd
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyd, tauxzd, tauyzd
   REAL(kind=realtype) :: fmx, fmy, fmz, frhoe
   REAL(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: ux, uy, uz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: uxd, uyd, uzd
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: vx, vy, vz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: vxd, vyd, vzd
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: wx, wy, wz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: wxd, wyd, wzd
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: qx, qy, qz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: qxd, qyd, qzd
   LOGICAL :: correctfork, storewalltensor
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: result1d
   INTEGER :: ii1
   INTRINSIC ABS
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   REAL(kind=realtype) :: abs0
   INTRINSIC SQRT
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('rev', rev, revd, ISIZE1OFDrfrev*&
   &                        ISIZE2OFDrfrev*ISIZE3OFDrfrev)
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFDrfp*ISIZE2OFDrfp*&
   &                        ISIZE3OFDrfp)
   CALL DEBUG_TGT_REAL8ARRAY('gamma', gamma, gammad, ISIZE1OFDrfgamma*&
   &                        ISIZE2OFDrfgamma*ISIZE3OFDrfgamma)
   CALL DEBUG_TGT_REAL8ARRAY('w', w, wd, ISIZE1OFDrfw*ISIZE2OFDrfw*&
   &                        ISIZE3OFDrfw*ISIZE4OFDrfw)
   CALL DEBUG_TGT_REAL8ARRAY('rlv', rlv, rlvd, ISIZE1OFDrfrlv*&
   &                        ISIZE2OFDrfrlv*ISIZE3OFDrfrlv)
   CALL DEBUG_TGT_REAL8ARRAY('x', x, xd, ISIZE1OFDrfx*ISIZE2OFDrfx*&
   &                        ISIZE3OFDrfx*ISIZE4OFDrfx)
   CALL DEBUG_TGT_REAL8ARRAY('vol', vol, vold, ISIZE1OFDrfvol*&
   &                        ISIZE2OFDrfvol*ISIZE3OFDrfvol)
   CALL DEBUG_TGT_REAL8ARRAY('si', si, sid, ISIZE1OFDrfsi*ISIZE2OFDrfsi&
   &                        *ISIZE3OFDrfsi*ISIZE4OFDrfsi)
   CALL DEBUG_TGT_REAL8ARRAY('sj', sj, sjd, ISIZE1OFDrfsj*ISIZE2OFDrfsj&
   &                        *ISIZE3OFDrfsj*ISIZE4OFDrfsj)
   CALL DEBUG_TGT_REAL8ARRAY('sk', sk, skd, ISIZE1OFDrfsk*ISIZE2OFDrfsk&
   &                        *ISIZE3OFDrfsk*ISIZE4OFDrfsk)
   CALL DEBUG_TGT_REAL8ARRAY('fw', fw, fwd, ISIZE1OFDrffw*ISIZE2OFDrffw&
   &                        *ISIZE3OFDrffw*ISIZE4OFDrffw)
   DO ii1=1,ISIZE1OFDrfbcdata
   CALL DEBUG_TGT_REAL8ARRAY('bcdata', bcdata(ii1)%norm, bcdatad(ii1)&
   &                          %norm, ISIZE1OFDrfDrfbcdata_norm*&
   &                          ISIZE2OFDrfDrfbcdata_norm*&
   &                          ISIZE3OFDrfDrfbcdata_norm)
   END DO
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   ! 
   ! Initialize the nodal graident variables to zero
   qx = zero
   qy = zero
   qz = zero
   ux = zero
   uy = zero
   uz = zero
   vx = zero
   vy = zero
   vz = zero
   wx = zero
   wy = zero
   wz = zero
   ! Set rFilv to rFil to indicate that this is the viscous part.
   ! If rFilv == 0 the viscous residuals need not to be computed
   ! and a return can be made.
   rfilv = rfil
   IF (rfilv .GE. 0.) THEN
   abs0 = rfilv
   ELSE
   abs0 = -rfilv
   END IF
   IF (abs0 .LT. thresholdreal) THEN
   DO ii1=1,ISIZE1OFDrfviscsubface
   viscsubfaced(ii1)%tau = 0.0_8
   END DO
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFDrfp*ISIZE2OFDrfp*&
   &                          ISIZE3OFDrfp)
   CALL DEBUG_TGT_REAL8ARRAY('fw', fw, fwd, ISIZE1OFDrffw*&
   &                          ISIZE2OFDrffw*ISIZE3OFDrffw*ISIZE4OFDrffw)
   DO ii1=1,ISIZE1OFDrfviscsubface
   CALL DEBUG_TGT_REAL8ARRAY('viscsubface', viscsubface(ii1)%tau, &
   &                            viscsubfaced(ii1)%tau, &
   &                            ISIZE1OFDrfDrfviscsubface_tau*&
   &                            ISIZE2OFDrfDrfviscsubface_tau*&
   &                            ISIZE3OFDrfDrfviscsubface_tau)
   END DO
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   RETURN
   ELSE
   ! Determine whether or not the pressure must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   ! Determine whether or not the wall stress tensor and wall heat
   ! flux must be stored for viscous walls.
   storewalltensor = .false.
   IF (wallfunctions) THEN
   storewalltensor = .true.
   ELSE IF (rkstage .EQ. 0 .AND. currentlevel .EQ. groundlevel) THEN
   storewalltensor = .true.
   END IF
   ! Store the speed of sound squared instead of the pressure.
   ! To be 100 percent correct, substract 2/3*rho*k (if present)
   ! from the pressure to obtain the true presssure. First layer of
   ! halo's, because that's what is needed by the viscous stencil.
   DO k=1,ke
   DO j=1,je
   DO i=1,ie
   IF (correctfork) THEN
   pd(i, j, k) = pd(i, j, k) - twothird*(wd(i, j, k, irho)*w(i&
   &              , j, k, itu1)+w(i, j, k, irho)*wd(i, j, k, itu1))
   p(i, j, k) = p(i, j, k) - twothird*w(i, j, k, irho)*w(i, j, &
   &              k, itu1)
   END IF
   pd(i, j, k) = ((gammad(i, j, k)*p(i, j, k)+gamma(i, j, k)*pd(i&
   &            , j, k))*w(i, j, k, irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j&
   &            , k, irho))/w(i, j, k, irho)**2
   p(i, j, k) = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
   END DO
   END DO
   END DO
   ! Compute the nodal gradients for the nodes in the plane k = 1.
   k = 1
   k1 = 1
   k2 = 2
   qzd = 0.0_8
   qyd = 0.0_8
   qxd = 0.0_8
   wzd = 0.0_8
   wyd = 0.0_8
   wxd = 0.0_8
   vzd = 0.0_8
   vyd = 0.0_8
   vxd = 0.0_8
   uzd = 0.0_8
   uyd = 0.0_8
   uxd = 0.0_8
   CALL DEBUG_TGT_CALL('NODALGRADIENTS', .TRUE., .FALSE.)
   CALL NODALGRADIENTS_T(ux, uxd, uy, uyd, uz, uzd, vx, vxd, vy, vyd, &
   &                    vz, vzd, wx, wxd, wy, wyd, wz, wzd, qx, qxd, qy, qyd&
   &                    , qz, qzd)
   CALL DEBUG_TGT_EXIT()
   ! Compute the viscous fluxes for the faces k == 1 and update
   ! the residuals for the cells k == 2.
   mue = zero
   DO ii1=1,ISIZE1OFDrfviscsubface
   viscsubfaced(ii1)%tau = 0.0_8
   END DO
   mued = 0.0_8
   DO j=2,jl
   DO i=2,il
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pork(i, j, 1) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   muld = por*(rlvd(i, j, 1)+rlvd(i, j, 2))
   mul = por*(rlv(i, j, 1)+rlv(i, j, 2))
   IF (eddymodel) THEN
   mued = por*(revd(i, j, 1)+revd(i, j, 2))
   mue = por*(rev(i, j, 1)+rev(i, j, 2))
   END IF
   mutd = muld + mued
   mut = mul + mue
   gm1d = half*(gammad(i, j, 1)+gammad(i, j, 2))
   gm1 = half*(gamma(i, j, 1)+gamma(i, j, 2)) - one
   factlamheatd = -(one*prandtl*gm1d/(prandtl*gm1)**2)
   factlamheat = one/(prandtl*gm1)
   factturbheatd = -(one*prandtlturb*gm1d/(prandtlturb*gm1)**2)
   factturbheat = one/(prandtlturb*gm1)
   heatcoefd = muld*factlamheat + mul*factlamheatd + mued*&
   &          factturbheat + mue*factturbheatd
   heatcoef = mul*factlamheat + mue*factturbheat
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_xd = fourth*(uxd(i-1, j-1, k1)+uxd(i, j-1, k1)+uxd(i-1, j, k1)&
   &          +uxd(i, j, k1))
   u_x = fourth*(ux(i-1, j-1, k1)+ux(i, j-1, k1)+ux(i-1, j, k1)+ux(&
   &          i, j, k1))
   u_yd = fourth*(uyd(i-1, j-1, k1)+uyd(i, j-1, k1)+uyd(i-1, j, k1)&
   &          +uyd(i, j, k1))
   u_y = fourth*(uy(i-1, j-1, k1)+uy(i, j-1, k1)+uy(i-1, j, k1)+uy(&
   &          i, j, k1))
   u_zd = fourth*(uzd(i-1, j-1, k1)+uzd(i, j-1, k1)+uzd(i-1, j, k1)&
   &          +uzd(i, j, k1))
   u_z = fourth*(uz(i-1, j-1, k1)+uz(i, j-1, k1)+uz(i-1, j, k1)+uz(&
   &          i, j, k1))
   v_xd = fourth*(vxd(i-1, j-1, k1)+vxd(i, j-1, k1)+vxd(i-1, j, k1)&
   &          +vxd(i, j, k1))
   v_x = fourth*(vx(i-1, j-1, k1)+vx(i, j-1, k1)+vx(i-1, j, k1)+vx(&
   &          i, j, k1))
   v_yd = fourth*(vyd(i-1, j-1, k1)+vyd(i, j-1, k1)+vyd(i-1, j, k1)&
   &          +vyd(i, j, k1))
   v_y = fourth*(vy(i-1, j-1, k1)+vy(i, j-1, k1)+vy(i-1, j, k1)+vy(&
   &          i, j, k1))
   v_zd = fourth*(vzd(i-1, j-1, k1)+vzd(i, j-1, k1)+vzd(i-1, j, k1)&
   &          +vzd(i, j, k1))
   v_z = fourth*(vz(i-1, j-1, k1)+vz(i, j-1, k1)+vz(i-1, j, k1)+vz(&
   &          i, j, k1))
   w_xd = fourth*(wxd(i-1, j-1, k1)+wxd(i, j-1, k1)+wxd(i-1, j, k1)&
   &          +wxd(i, j, k1))
   w_x = fourth*(wx(i-1, j-1, k1)+wx(i, j-1, k1)+wx(i-1, j, k1)+wx(&
   &          i, j, k1))
   w_yd = fourth*(wyd(i-1, j-1, k1)+wyd(i, j-1, k1)+wyd(i-1, j, k1)&
   &          +wyd(i, j, k1))
   w_y = fourth*(wy(i-1, j-1, k1)+wy(i, j-1, k1)+wy(i-1, j, k1)+wy(&
   &          i, j, k1))
   w_zd = fourth*(wzd(i-1, j-1, k1)+wzd(i, j-1, k1)+wzd(i-1, j, k1)&
   &          +wzd(i, j, k1))
   w_z = fourth*(wz(i-1, j-1, k1)+wz(i, j-1, k1)+wz(i-1, j, k1)+wz(&
   &          i, j, k1))
   q_xd = fourth*(qxd(i-1, j-1, k1)+qxd(i, j-1, k1)+qxd(i-1, j, k1)&
   &          +qxd(i, j, k1))
   q_x = fourth*(qx(i-1, j-1, k1)+qx(i, j-1, k1)+qx(i-1, j, k1)+qx(&
   &          i, j, k1))
   q_yd = fourth*(qyd(i-1, j-1, k1)+qyd(i, j-1, k1)+qyd(i-1, j, k1)&
   &          +qyd(i, j, k1))
   q_y = fourth*(qy(i-1, j-1, k1)+qy(i, j-1, k1)+qy(i-1, j, k1)+qy(&
   &          i, j, k1))
   q_zd = fourth*(qzd(i-1, j-1, k1)+qzd(i, j-1, k1)+qzd(i-1, j, k1)&
   &          +qzd(i, j, k1))
   q_z = fourth*(qz(i-1, j-1, k1)+qz(i, j-1, k1)+qz(i-1, j, k1)+qz(&
   &          i, j, k1))
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center k to cell center k+1.
   ssxd = eighth*(xd(i-1, j-1, k+1, 1)-xd(i-1, j-1, k-1, 1)+xd(i-1&
   &          , j, k+1, 1)-xd(i-1, j, k-1, 1)+xd(i, j-1, k+1, 1)-xd(i, j-1, &
   &          k-1, 1)+xd(i, j, k+1, 1)-xd(i, j, k-1, 1))
   ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j, &
   &          k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1, 1)+&
   &          x(i, j, k+1, 1)-x(i, j, k-1, 1))
   ssyd = eighth*(xd(i-1, j-1, k+1, 2)-xd(i-1, j-1, k-1, 2)+xd(i-1&
   &          , j, k+1, 2)-xd(i-1, j, k-1, 2)+xd(i, j-1, k+1, 2)-xd(i, j-1, &
   &          k-1, 2)+xd(i, j, k+1, 2)-xd(i, j, k-1, 2))
   ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j, &
   &          k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1, 2)+&
   &          x(i, j, k+1, 2)-x(i, j, k-1, 2))
   sszd = eighth*(xd(i-1, j-1, k+1, 3)-xd(i-1, j-1, k-1, 3)+xd(i-1&
   &          , j, k+1, 3)-xd(i-1, j, k-1, 3)+xd(i, j-1, k+1, 3)-xd(i, j-1, &
   &          k-1, 3)+xd(i, j, k+1, 3)-xd(i, j, k-1, 3))
   ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j, &
   &          k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1, 3)+&
   &          x(i, j, k+1, 3)-x(i, j, k-1, 3))
   ! Determine the length of this vector and create the
   ! unit normal.
   arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz + &
   &          ssz*sszd
   arg1 = ssx*ssx + ssy*ssy + ssz*ssz
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   ssd = -(one*result1d/result1**2)
   ss = one/result1
   ssxd = ssd*ssx + ss*ssxd
   ssx = ss*ssx
   ssyd = ssd*ssy + ss*ssyd
   ssy = ss*ssy
   sszd = ssd*ssz + ss*sszd
   ssz = ss*ssz
   ! Correct the gradients.
   corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz + &
   &          u_z*sszd - (wd(i, j, k+1, ivx)-wd(i, j, k, ivx))*ss - (w(i, j&
   &          , k+1, ivx)-w(i, j, k, ivx))*ssd
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j, &
   &          k, ivx))*ss
   u_xd = u_xd - corrd*ssx - corr*ssxd
   u_x = u_x - corr*ssx
   u_yd = u_yd - corrd*ssy - corr*ssyd
   u_y = u_y - corr*ssy
   u_zd = u_zd - corrd*ssz - corr*sszd
   u_z = u_z - corr*ssz
   corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz + &
   &          v_z*sszd - (wd(i, j, k+1, ivy)-wd(i, j, k, ivy))*ss - (w(i, j&
   &          , k+1, ivy)-w(i, j, k, ivy))*ssd
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j, &
   &          k, ivy))*ss
   v_xd = v_xd - corrd*ssx - corr*ssxd
   v_x = v_x - corr*ssx
   v_yd = v_yd - corrd*ssy - corr*ssyd
   v_y = v_y - corr*ssy
   v_zd = v_zd - corrd*ssz - corr*sszd
   v_z = v_z - corr*ssz
   corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz + &
   &          w_z*sszd - (wd(i, j, k+1, ivz)-wd(i, j, k, ivz))*ss - (w(i, j&
   &          , k+1, ivz)-w(i, j, k, ivz))*ssd
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j, &
   &          k, ivz))*ss
   w_xd = w_xd - corrd*ssx - corr*ssxd
   w_x = w_x - corr*ssx
   w_yd = w_yd - corrd*ssy - corr*ssyd
   w_y = w_y - corr*ssy
   w_zd = w_zd - corrd*ssz - corr*sszd
   w_z = w_z - corr*ssz
   corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz + &
   &          q_z*sszd + (pd(i, j, k+1)-pd(i, j, k))*ss + (p(i, j, k+1)-p(i&
   &          , j, k))*ssd
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j, k+1)-p(i, j, k))*&
   &          ss
   q_xd = q_xd - corrd*ssx - corr*ssxd
   q_x = q_x - corr*ssx
   q_yd = q_yd - corrd*ssy - corr*ssyd
   q_y = q_y - corr*ssy
   q_zd = q_zd - corrd*ssz - corr*sszd
   q_z = q_z - corr*ssz
   ! Compute the stress tensor and the heat flux vector.
   fracdivd = twothird*(u_xd+v_yd+w_zd)
   fracdiv = twothird*(u_x+v_y+w_z)
   tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
   tauxx = mut*(two*u_x-fracdiv)
   tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
   tauyy = mut*(two*v_y-fracdiv)
   tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
   tauzz = mut*(two*w_z-fracdiv)
   tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
   tauxy = mut*(u_y+v_x)
   tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
   tauxz = mut*(u_z+w_x)
   tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
   tauyz = mut*(v_z+w_y)
   q_xd = heatcoefd*q_x + heatcoef*q_xd
   q_x = heatcoef*q_x
   q_yd = heatcoefd*q_y + heatcoef*q_yd
   q_y = heatcoef*q_y
   q_zd = heatcoefd*q_z + heatcoef*q_zd
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubard = half*(wd(i, j, 1, ivx)+wd(i, j, 2, ivx))
   ubar = half*(w(i, j, 1, ivx)+w(i, j, 2, ivx))
   vbard = half*(wd(i, j, 1, ivy)+wd(i, j, 2, ivy))
   vbar = half*(w(i, j, 1, ivy)+w(i, j, 2, ivy))
   wbard = half*(wd(i, j, 1, ivz)+wd(i, j, 2, ivz))
   wbar = half*(w(i, j, 1, ivz)+w(i, j, 2, ivz))
   ! Compute the viscous fluxes for this k-face.
   fmxd = tauxxd*sk(i, j, 1, 1) + tauxx*skd(i, j, 1, 1) + tauxyd*sk&
   &          (i, j, 1, 2) + tauxy*skd(i, j, 1, 2) + tauxzd*sk(i, j, 1, 3) +&
   &          tauxz*skd(i, j, 1, 3)
   fmx = tauxx*sk(i, j, 1, 1) + tauxy*sk(i, j, 1, 2) + tauxz*sk(i, &
   &          j, 1, 3)
   fmyd = tauxyd*sk(i, j, 1, 1) + tauxy*skd(i, j, 1, 1) + tauyyd*sk&
   &          (i, j, 1, 2) + tauyy*skd(i, j, 1, 2) + tauyzd*sk(i, j, 1, 3) +&
   &          tauyz*skd(i, j, 1, 3)
   fmy = tauxy*sk(i, j, 1, 1) + tauyy*sk(i, j, 1, 2) + tauyz*sk(i, &
   &          j, 1, 3)
   fmzd = tauxzd*sk(i, j, 1, 1) + tauxz*skd(i, j, 1, 1) + tauyzd*sk&
   &          (i, j, 1, 2) + tauyz*skd(i, j, 1, 2) + tauzzd*sk(i, j, 1, 3) +&
   &          tauzz*skd(i, j, 1, 3)
   fmz = tauxz*sk(i, j, 1, 1) + tauyz*sk(i, j, 1, 2) + tauzz*sk(i, &
   &          j, 1, 3)
   frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+wbard*&
   &          tauxz+wbar*tauxzd)*sk(i, j, 1, 1) + (ubar*tauxx+vbar*tauxy+&
   &          wbar*tauxz)*skd(i, j, 1, 1) + (ubard*tauxy+ubar*tauxyd+vbard*&
   &          tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*sk(i, j, 1, 2) + (&
   &          ubar*tauxy+vbar*tauyy+wbar*tauyz)*skd(i, j, 1, 2) + (ubard*&
   &          tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd+wbard*tauzz+wbar*&
   &          tauzzd)*sk(i, j, 1, 3) + (ubar*tauxz+vbar*tauyz+wbar*tauzz)*&
   &          skd(i, j, 1, 3) - q_xd*sk(i, j, 1, 1) - q_x*skd(i, j, 1, 1) - &
   &          q_yd*sk(i, j, 1, 2) - q_y*skd(i, j, 1, 2) - q_zd*sk(i, j, 1, 3&
   &          ) - q_z*skd(i, j, 1, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, 1, 1) + (&
   &          ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, 1, 2) + (ubar*tauxz&
   &          +vbar*tauyz+wbar*tauzz)*sk(i, j, 1, 3) - q_x*sk(i, j, 1, 1) - &
   &          q_y*sk(i, j, 1, 2) - q_z*sk(i, j, 1, 3)
   ! Update the residuals of cell k == 2.
   fwd(i, j, 2, imx) = fwd(i, j, 2, imx) + fmxd
   fw(i, j, 2, imx) = fw(i, j, 2, imx) + fmx
   fwd(i, j, 2, imy) = fwd(i, j, 2, imy) + fmyd
   fw(i, j, 2, imy) = fw(i, j, 2, imy) + fmy
   fwd(i, j, 2, imz) = fwd(i, j, 2, imz) + fmzd
   fw(i, j, 2, imz) = fw(i, j, 2, imz) + fmz
   fwd(i, j, 2, irhoe) = fwd(i, j, 2, irhoe) + frhoed
   fw(i, j, 2, irhoe) = fw(i, j, 2, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface.
   IF (storewalltensor .AND. visckminpointer(i, j) .GT. 0) THEN
   nn = visckminpointer(i, j)
   viscsubfaced(nn)%tau(i, j, 1) = tauxxd
   viscsubface(nn)%tau(i, j, 1) = tauxx
   viscsubfaced(nn)%tau(i, j, 2) = tauyyd
   viscsubface(nn)%tau(i, j, 2) = tauyy
   viscsubfaced(nn)%tau(i, j, 3) = tauzzd
   viscsubface(nn)%tau(i, j, 3) = tauzz
   viscsubfaced(nn)%tau(i, j, 4) = tauxyd
   viscsubface(nn)%tau(i, j, 4) = tauxy
   viscsubfaced(nn)%tau(i, j, 5) = tauxzd
   viscsubface(nn)%tau(i, j, 5) = tauxz
   viscsubfaced(nn)%tau(i, j, 6) = tauyzd
   viscsubface(nn)%tau(i, j, 6) = tauyz
   viscsubface(nn)%q(i, j, 1) = q_x
   viscsubface(nn)%q(i, j, 2) = q_y
   viscsubface(nn)%q(i, j, 3) = q_z
   END IF
   END DO
   END DO
   ! Loop over the k-planes.
   kloop:DO k=2,kl
   ! Switch the indices k1 and k2.
   kk = k1
   k1 = k2
   k2 = kk
   CALL DEBUG_TGT_CALL('NODALGRADIENTS', .TRUE., .FALSE.)
   ! Compute the nodal gradients for the nodes in this k-plane.
   ! The results are stored in ux(:,:,k1), etc.
   CALL NODALGRADIENTS_T(ux, uxd, uy, uyd, uz, uzd, vx, vxd, vy, vyd&
   &                      , vz, vzd, wx, wxd, wy, wyd, wz, wzd, qx, qxd, qy&
   &                      , qyd, qz, qzd)
   CALL DEBUG_TGT_EXIT()
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the k-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   DO j=2,jl
   DO i=2,il
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pork(i, j, k) .EQ. noflux) THEN
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('rev', rev, revd, ISIZE1OFDrfrev&
   &                                  *ISIZE2OFDrfrev*ISIZE3OFDrfrev)
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFDrfp*&
   &                                  ISIZE2OFDrfp*ISIZE3OFDrfp)
   CALL DEBUG_TGT_REAL8ARRAY('gamma', gamma, gammad, &
   &                                  ISIZE1OFDrfgamma*ISIZE2OFDrfgamma*&
   &                                  ISIZE3OFDrfgamma)
   CALL DEBUG_TGT_REAL8ARRAY('w', w, wd, ISIZE1OFDrfw*&
   &                                  ISIZE2OFDrfw*ISIZE3OFDrfw*ISIZE4OFDrfw&
   &                                 )
   CALL DEBUG_TGT_REAL8ARRAY('rlv', rlv, rlvd, ISIZE1OFDrfrlv&
   &                                  *ISIZE2OFDrfrlv*ISIZE3OFDrfrlv)
   CALL DEBUG_TGT_REAL8ARRAY('x', x, xd, ISIZE1OFDrfx*&
   &                                  ISIZE2OFDrfx*ISIZE3OFDrfx*ISIZE4OFDrfx&
   &                                 )
   CALL DEBUG_TGT_REAL8ARRAY('vol', vol, vold, ISIZE1OFDrfvol&
   &                                  *ISIZE2OFDrfvol*ISIZE3OFDrfvol)
   CALL DEBUG_TGT_REAL8ARRAY('si', si, sid, ISIZE1OFDrfsi*&
   &                                  ISIZE2OFDrfsi*ISIZE3OFDrfsi*&
   &                                  ISIZE4OFDrfsi)
   CALL DEBUG_TGT_REAL8ARRAY('sj', sj, sjd, ISIZE1OFDrfsj*&
   &                                  ISIZE2OFDrfsj*ISIZE3OFDrfsj*&
   &                                  ISIZE4OFDrfsj)
   CALL DEBUG_TGT_REAL8ARRAY('sk', sk, skd, ISIZE1OFDrfsk*&
   &                                  ISIZE2OFDrfsk*ISIZE3OFDrfsk*&
   &                                  ISIZE4OFDrfsk)
   CALL DEBUG_TGT_REAL8ARRAY('fw', fw, fwd, ISIZE1OFDrffw*&
   &                                  ISIZE2OFDrffw*ISIZE3OFDrffw*&
   &                                  ISIZE4OFDrffw)
   DO ii1=1,ISIZE1OFDrfviscsubface
   CALL DEBUG_TGT_REAL8ARRAY('viscsubface', viscsubface(ii1&
   &                                    )%tau, viscsubfaced(ii1)%tau, &
   &                                    ISIZE1OFDrfDrfviscsubface_tau*&
   &                                    ISIZE2OFDrfDrfviscsubface_tau*&
   &                                    ISIZE3OFDrfDrfviscsubface_tau)
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   CALL DEBUG_TGT_REAL8ARRAY('bcdata', bcdata(ii1)%norm, &
   &                                    bcdatad(ii1)%norm, &
   &                                    ISIZE1OFDrfDrfbcdata_norm*&
   &                                    ISIZE2OFDrfDrfbcdata_norm*&
   &                                    ISIZE3OFDrfDrfbcdata_norm)
   END DO
   CALL DEBUG_TGT_REAL8ARRAY('wx', wx, wxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wy', wy, wyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wz', wz, wzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qx', qx, qxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qy', qy, qyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qz', qz, qzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('ux', ux, uxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uy', uy, uyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uz', uz, uzd, il*jl*2)
   CALL DEBUG_TGT_REAL8('mue', mue, mued)
   CALL DEBUG_TGT_REAL8ARRAY('vx', vx, vxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vy', vy, vyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vz', vz, vzd, il*jl*2)
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   por = zero
   END IF
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   muld = por*(rlvd(i, j, k)+rlvd(i, j, k+1))
   mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
   IF (eddymodel) THEN
   mued = por*(revd(i, j, k)+revd(i, j, k+1))
   mue = por*(rev(i, j, k)+rev(i, j, k+1))
   END IF
   mutd = muld + mued
   mut = mul + mue
   gm1d = half*(gammad(i, j, k)+gammad(i, j, k+1))
   gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
   factlamheatd = -(one*prandtl*gm1d/(prandtl*gm1)**2)
   factlamheat = one/(prandtl*gm1)
   factturbheatd = -(one*prandtlturb*gm1d/(prandtlturb*gm1)**2)
   factturbheat = one/(prandtlturb*gm1)
   heatcoefd = muld*factlamheat + mul*factlamheatd + mued*&
   &            factturbheat + mue*factturbheatd
   heatcoef = mul*factlamheat + mue*factturbheat
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_xd = fourth*(uxd(i-1, j-1, k1)+uxd(i, j-1, k1)+uxd(i-1, j, &
   &            k1)+uxd(i, j, k1))
   u_x = fourth*(ux(i-1, j-1, k1)+ux(i, j-1, k1)+ux(i-1, j, k1)+&
   &            ux(i, j, k1))
   u_yd = fourth*(uyd(i-1, j-1, k1)+uyd(i, j-1, k1)+uyd(i-1, j, &
   &            k1)+uyd(i, j, k1))
   u_y = fourth*(uy(i-1, j-1, k1)+uy(i, j-1, k1)+uy(i-1, j, k1)+&
   &            uy(i, j, k1))
   u_zd = fourth*(uzd(i-1, j-1, k1)+uzd(i, j-1, k1)+uzd(i-1, j, &
   &            k1)+uzd(i, j, k1))
   u_z = fourth*(uz(i-1, j-1, k1)+uz(i, j-1, k1)+uz(i-1, j, k1)+&
   &            uz(i, j, k1))
   v_xd = fourth*(vxd(i-1, j-1, k1)+vxd(i, j-1, k1)+vxd(i-1, j, &
   &            k1)+vxd(i, j, k1))
   v_x = fourth*(vx(i-1, j-1, k1)+vx(i, j-1, k1)+vx(i-1, j, k1)+&
   &            vx(i, j, k1))
   v_yd = fourth*(vyd(i-1, j-1, k1)+vyd(i, j-1, k1)+vyd(i-1, j, &
   &            k1)+vyd(i, j, k1))
   v_y = fourth*(vy(i-1, j-1, k1)+vy(i, j-1, k1)+vy(i-1, j, k1)+&
   &            vy(i, j, k1))
   v_zd = fourth*(vzd(i-1, j-1, k1)+vzd(i, j-1, k1)+vzd(i-1, j, &
   &            k1)+vzd(i, j, k1))
   v_z = fourth*(vz(i-1, j-1, k1)+vz(i, j-1, k1)+vz(i-1, j, k1)+&
   &            vz(i, j, k1))
   w_xd = fourth*(wxd(i-1, j-1, k1)+wxd(i, j-1, k1)+wxd(i-1, j, &
   &            k1)+wxd(i, j, k1))
   w_x = fourth*(wx(i-1, j-1, k1)+wx(i, j-1, k1)+wx(i-1, j, k1)+&
   &            wx(i, j, k1))
   w_yd = fourth*(wyd(i-1, j-1, k1)+wyd(i, j-1, k1)+wyd(i-1, j, &
   &            k1)+wyd(i, j, k1))
   w_y = fourth*(wy(i-1, j-1, k1)+wy(i, j-1, k1)+wy(i-1, j, k1)+&
   &            wy(i, j, k1))
   w_zd = fourth*(wzd(i-1, j-1, k1)+wzd(i, j-1, k1)+wzd(i-1, j, &
   &            k1)+wzd(i, j, k1))
   w_z = fourth*(wz(i-1, j-1, k1)+wz(i, j-1, k1)+wz(i-1, j, k1)+&
   &            wz(i, j, k1))
   q_xd = fourth*(qxd(i-1, j-1, k1)+qxd(i, j-1, k1)+qxd(i-1, j, &
   &            k1)+qxd(i, j, k1))
   q_x = fourth*(qx(i-1, j-1, k1)+qx(i, j-1, k1)+qx(i-1, j, k1)+&
   &            qx(i, j, k1))
   q_yd = fourth*(qyd(i-1, j-1, k1)+qyd(i, j-1, k1)+qyd(i-1, j, &
   &            k1)+qyd(i, j, k1))
   q_y = fourth*(qy(i-1, j-1, k1)+qy(i, j-1, k1)+qy(i-1, j, k1)+&
   &            qy(i, j, k1))
   q_zd = fourth*(qzd(i-1, j-1, k1)+qzd(i, j-1, k1)+qzd(i-1, j, &
   &            k1)+qzd(i, j, k1))
   q_z = fourth*(qz(i-1, j-1, k1)+qz(i, j-1, k1)+qz(i-1, j, k1)+&
   &            qz(i, j, k1))
   !!$             write(unitvf,*) i,j,k, u_x, u_y, u_z
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center k to cell center k+1.
   ssxd = eighth*(xd(i-1, j-1, k+1, 1)-xd(i-1, j-1, k-1, 1)+xd(i-&
   &            1, j, k+1, 1)-xd(i-1, j, k-1, 1)+xd(i, j-1, k+1, 1)-xd(i, j-&
   &            1, k-1, 1)+xd(i, j, k+1, 1)-xd(i, j, k-1, 1))
   ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
   &            , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
   &            , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
   ssyd = eighth*(xd(i-1, j-1, k+1, 2)-xd(i-1, j-1, k-1, 2)+xd(i-&
   &            1, j, k+1, 2)-xd(i-1, j, k-1, 2)+xd(i, j-1, k+1, 2)-xd(i, j-&
   &            1, k-1, 2)+xd(i, j, k+1, 2)-xd(i, j, k-1, 2))
   ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
   &            , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
   &            , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
   sszd = eighth*(xd(i-1, j-1, k+1, 3)-xd(i-1, j-1, k-1, 3)+xd(i-&
   &            1, j, k+1, 3)-xd(i-1, j, k-1, 3)+xd(i, j-1, k+1, 3)-xd(i, j-&
   &            1, k-1, 3)+xd(i, j, k+1, 3)-xd(i, j, k-1, 3))
   ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
   &            , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
   &            , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
   ! Determine the length of this vector and create the
   ! unit normal.
   arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz +&
   &            ssz*sszd
   arg1 = ssx*ssx + ssy*ssy + ssz*ssz
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   ssd = -(one*result1d/result1**2)
   ss = one/result1
   ssxd = ssd*ssx + ss*ssxd
   ssx = ss*ssx
   ssyd = ssd*ssy + ss*ssyd
   ssy = ss*ssy
   sszd = ssd*ssz + ss*sszd
   ssz = ss*ssz
   ! Correct the gradients.
   corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz +&
   &            u_z*sszd - (wd(i, j, k+1, ivx)-wd(i, j, k, ivx))*ss - (w(i, &
   &            j, k+1, ivx)-w(i, j, k, ivx))*ssd
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j&
   &            , k, ivx))*ss
   u_xd = u_xd - corrd*ssx - corr*ssxd
   u_x = u_x - corr*ssx
   u_yd = u_yd - corrd*ssy - corr*ssyd
   u_y = u_y - corr*ssy
   u_zd = u_zd - corrd*ssz - corr*sszd
   u_z = u_z - corr*ssz
   corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz +&
   &            v_z*sszd - (wd(i, j, k+1, ivy)-wd(i, j, k, ivy))*ss - (w(i, &
   &            j, k+1, ivy)-w(i, j, k, ivy))*ssd
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j&
   &            , k, ivy))*ss
   v_xd = v_xd - corrd*ssx - corr*ssxd
   v_x = v_x - corr*ssx
   v_yd = v_yd - corrd*ssy - corr*ssyd
   v_y = v_y - corr*ssy
   v_zd = v_zd - corrd*ssz - corr*sszd
   v_z = v_z - corr*ssz
   corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz +&
   &            w_z*sszd - (wd(i, j, k+1, ivz)-wd(i, j, k, ivz))*ss - (w(i, &
   &            j, k+1, ivz)-w(i, j, k, ivz))*ssd
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j&
   &            , k, ivz))*ss
   w_xd = w_xd - corrd*ssx - corr*ssxd
   w_x = w_x - corr*ssx
   w_yd = w_yd - corrd*ssy - corr*ssyd
   w_y = w_y - corr*ssy
   w_zd = w_zd - corrd*ssz - corr*sszd
   w_z = w_z - corr*ssz
   corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz +&
   &            q_z*sszd + (pd(i, j, k+1)-pd(i, j, k))*ss + (p(i, j, k+1)-p(&
   &            i, j, k))*ssd
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j, k+1)-p(i, j, k))&
   &            *ss
   q_xd = q_xd - corrd*ssx - corr*ssxd
   q_x = q_x - corr*ssx
   q_yd = q_yd - corrd*ssy - corr*ssyd
   q_y = q_y - corr*ssy
   q_zd = q_zd - corrd*ssz - corr*sszd
   q_z = q_z - corr*ssz
   ! Compute the stress tensor and the heat flux vector.
   fracdivd = twothird*(u_xd+v_yd+w_zd)
   fracdiv = twothird*(u_x+v_y+w_z)
   tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
   tauxx = mut*(two*u_x-fracdiv)
   tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
   tauyy = mut*(two*v_y-fracdiv)
   tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
   tauzz = mut*(two*w_z-fracdiv)
   tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
   tauxy = mut*(u_y+v_x)
   tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
   tauxz = mut*(u_z+w_x)
   tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
   tauyz = mut*(v_z+w_y)
   q_xd = heatcoefd*q_x + heatcoef*q_xd
   q_x = heatcoef*q_x
   q_yd = heatcoefd*q_y + heatcoef*q_yd
   q_y = heatcoef*q_y
   q_zd = heatcoefd*q_z + heatcoef*q_zd
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubard = half*(wd(i, j, k, ivx)+wd(i, j, k+1, ivx))
   ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
   vbard = half*(wd(i, j, k, ivy)+wd(i, j, k+1, ivy))
   vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
   wbard = half*(wd(i, j, k, ivz)+wd(i, j, k+1, ivz))
   wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
   ! Compute the viscous fluxes for this k-face.
   fmxd = tauxxd*sk(i, j, k, 1) + tauxx*skd(i, j, k, 1) + tauxyd*&
   &            sk(i, j, k, 2) + tauxy*skd(i, j, k, 2) + tauxzd*sk(i, j, k, &
   &            3) + tauxz*skd(i, j, k, 3)
   fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i&
   &            , j, k, 3)
   fmyd = tauxyd*sk(i, j, k, 1) + tauxy*skd(i, j, k, 1) + tauyyd*&
   &            sk(i, j, k, 2) + tauyy*skd(i, j, k, 2) + tauyzd*sk(i, j, k, &
   &            3) + tauyz*skd(i, j, k, 3)
   fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i&
   &            , j, k, 3)
   fmzd = tauxzd*sk(i, j, k, 1) + tauxz*skd(i, j, k, 1) + tauyzd*&
   &            sk(i, j, k, 2) + tauyz*skd(i, j, k, 2) + tauzzd*sk(i, j, k, &
   &            3) + tauzz*skd(i, j, k, 3)
   fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i&
   &            , j, k, 3)
   frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
   &            wbard*tauxz+wbar*tauxzd)*sk(i, j, k, 1) + (ubar*tauxx+vbar*&
   &            tauxy+wbar*tauxz)*skd(i, j, k, 1) + (ubard*tauxy+ubar*tauxyd&
   &            +vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*sk(i, j, k&
   &            , 2) + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*skd(i, j, k, 2) + &
   &            (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd+wbard*tauzz&
   &            +wbar*tauzzd)*sk(i, j, k, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
   &            tauzz)*skd(i, j, k, 3) - q_xd*sk(i, j, k, 1) - q_x*skd(i, j&
   &            , k, 1) - q_yd*sk(i, j, k, 2) - q_y*skd(i, j, k, 2) - q_zd*&
   &            sk(i, j, k, 3) - q_z*skd(i, j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1) + (&
   &            ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k, 2) + (ubar*&
   &            tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k, 3) - q_x*sk(i, j, k&
   &            , 1) - q_y*sk(i, j, k, 2) - q_z*sk(i, j, k, 3)
   ! Update the residuals of cell k and k+1.
   fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fmxd
   fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
   fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fmyd
   fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
   fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fmzd
   fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
   fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + frhoed
   fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface.
   IF (k .EQ. kl .AND. storewalltensor .AND. visckmaxpointer(i, j&
   &              ) .GT. 0) THEN
   nn = visckmaxpointer(i, j)
   viscsubfaced(nn)%tau(i, j, 1) = tauxxd
   viscsubface(nn)%tau(i, j, 1) = tauxx
   viscsubfaced(nn)%tau(i, j, 2) = tauyyd
   viscsubface(nn)%tau(i, j, 2) = tauyy
   viscsubfaced(nn)%tau(i, j, 3) = tauzzd
   viscsubface(nn)%tau(i, j, 3) = tauzz
   viscsubfaced(nn)%tau(i, j, 4) = tauxyd
   viscsubface(nn)%tau(i, j, 4) = tauxy
   viscsubfaced(nn)%tau(i, j, 5) = tauxzd
   viscsubface(nn)%tau(i, j, 5) = tauxz
   viscsubfaced(nn)%tau(i, j, 6) = tauyzd
   viscsubface(nn)%tau(i, j, 6) = tauyz
   viscsubface(nn)%q(i, j, 1) = q_x
   viscsubface(nn)%q(i, j, 2) = q_y
   viscsubface(nn)%q(i, j, 3) = q_z
   END IF
   END DO
   END DO
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the j-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   DO j=1,jl
   DO i=2,il
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (porj(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   muld = por*(rlvd(i, j, k)+rlvd(i, j+1, k))
   mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
   IF (eddymodel) THEN
   mued = por*(revd(i, j, k)+revd(i, j+1, k))
   mue = por*(rev(i, j, k)+rev(i, j+1, k))
   END IF
   mutd = muld + mued
   mut = mul + mue
   gm1d = half*(gammad(i, j, k)+gammad(i, j+1, k))
   gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
   factlamheatd = -(one*prandtl*gm1d/(prandtl*gm1)**2)
   factlamheat = one/(prandtl*gm1)
   factturbheatd = -(one*prandtlturb*gm1d/(prandtlturb*gm1)**2)
   factturbheat = one/(prandtlturb*gm1)
   heatcoefd = muld*factlamheat + mul*factlamheatd + mued*&
   &            factturbheat + mue*factturbheatd
   heatcoef = mul*factlamheat + mue*factturbheat
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_xd = fourth*(uxd(i-1, j, k1)+uxd(i, j, k1)+uxd(i-1, j, k2)+&
   &            uxd(i, j, k2))
   u_x = fourth*(ux(i-1, j, k1)+ux(i, j, k1)+ux(i-1, j, k2)+ux(i&
   &            , j, k2))
   u_yd = fourth*(uyd(i-1, j, k1)+uyd(i, j, k1)+uyd(i-1, j, k2)+&
   &            uyd(i, j, k2))
   u_y = fourth*(uy(i-1, j, k1)+uy(i, j, k1)+uy(i-1, j, k2)+uy(i&
   &            , j, k2))
   u_zd = fourth*(uzd(i-1, j, k1)+uzd(i, j, k1)+uzd(i-1, j, k2)+&
   &            uzd(i, j, k2))
   u_z = fourth*(uz(i-1, j, k1)+uz(i, j, k1)+uz(i-1, j, k2)+uz(i&
   &            , j, k2))
   v_xd = fourth*(vxd(i-1, j, k1)+vxd(i, j, k1)+vxd(i-1, j, k2)+&
   &            vxd(i, j, k2))
   v_x = fourth*(vx(i-1, j, k1)+vx(i, j, k1)+vx(i-1, j, k2)+vx(i&
   &            , j, k2))
   v_yd = fourth*(vyd(i-1, j, k1)+vyd(i, j, k1)+vyd(i-1, j, k2)+&
   &            vyd(i, j, k2))
   v_y = fourth*(vy(i-1, j, k1)+vy(i, j, k1)+vy(i-1, j, k2)+vy(i&
   &            , j, k2))
   v_zd = fourth*(vzd(i-1, j, k1)+vzd(i, j, k1)+vzd(i-1, j, k2)+&
   &            vzd(i, j, k2))
   v_z = fourth*(vz(i-1, j, k1)+vz(i, j, k1)+vz(i-1, j, k2)+vz(i&
   &            , j, k2))
   w_xd = fourth*(wxd(i-1, j, k1)+wxd(i, j, k1)+wxd(i-1, j, k2)+&
   &            wxd(i, j, k2))
   w_x = fourth*(wx(i-1, j, k1)+wx(i, j, k1)+wx(i-1, j, k2)+wx(i&
   &            , j, k2))
   w_yd = fourth*(wyd(i-1, j, k1)+wyd(i, j, k1)+wyd(i-1, j, k2)+&
   &            wyd(i, j, k2))
   w_y = fourth*(wy(i-1, j, k1)+wy(i, j, k1)+wy(i-1, j, k2)+wy(i&
   &            , j, k2))
   w_zd = fourth*(wzd(i-1, j, k1)+wzd(i, j, k1)+wzd(i-1, j, k2)+&
   &            wzd(i, j, k2))
   w_z = fourth*(wz(i-1, j, k1)+wz(i, j, k1)+wz(i-1, j, k2)+wz(i&
   &            , j, k2))
   q_xd = fourth*(qxd(i-1, j, k1)+qxd(i, j, k1)+qxd(i-1, j, k2)+&
   &            qxd(i, j, k2))
   q_x = fourth*(qx(i-1, j, k1)+qx(i, j, k1)+qx(i-1, j, k2)+qx(i&
   &            , j, k2))
   q_yd = fourth*(qyd(i-1, j, k1)+qyd(i, j, k1)+qyd(i-1, j, k2)+&
   &            qyd(i, j, k2))
   q_y = fourth*(qy(i-1, j, k1)+qy(i, j, k1)+qy(i-1, j, k2)+qy(i&
   &            , j, k2))
   q_zd = fourth*(qzd(i-1, j, k1)+qzd(i, j, k1)+qzd(i-1, j, k2)+&
   &            qzd(i, j, k2))
   q_z = fourth*(qz(i-1, j, k1)+qz(i, j, k1)+qz(i-1, j, k2)+qz(i&
   &            , j, k2))
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center j to cell center j+1.
   ssxd = eighth*(xd(i-1, j+1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(i-&
   &            1, j+1, k, 1)-xd(i-1, j-1, k, 1)+xd(i, j+1, k-1, 1)-xd(i, j-&
   &            1, k-1, 1)+xd(i, j+1, k, 1)-xd(i, j-1, k, 1))
   ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
   &            +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
   &            , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
   ssyd = eighth*(xd(i-1, j+1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(i-&
   &            1, j+1, k, 2)-xd(i-1, j-1, k, 2)+xd(i, j+1, k-1, 2)-xd(i, j-&
   &            1, k-1, 2)+xd(i, j+1, k, 2)-xd(i, j-1, k, 2))
   ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
   &            +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
   &            , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
   sszd = eighth*(xd(i-1, j+1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(i-&
   &            1, j+1, k, 3)-xd(i-1, j-1, k, 3)+xd(i, j+1, k-1, 3)-xd(i, j-&
   &            1, k-1, 3)+xd(i, j+1, k, 3)-xd(i, j-1, k, 3))
   ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
   &            +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
   &            , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
   ! Determine the length of this vector and create the
   ! unit normal.
   arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz +&
   &            ssz*sszd
   arg1 = ssx*ssx + ssy*ssy + ssz*ssz
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   ssd = -(one*result1d/result1**2)
   ss = one/result1
   ssxd = ssd*ssx + ss*ssxd
   ssx = ss*ssx
   ssyd = ssd*ssy + ss*ssyd
   ssy = ss*ssy
   sszd = ssd*ssz + ss*sszd
   ssz = ss*ssz
   ! Correct the gradients.
   corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz +&
   &            u_z*sszd - (wd(i, j+1, k, ivx)-wd(i, j, k, ivx))*ss - (w(i, &
   &            j+1, k, ivx)-w(i, j, k, ivx))*ssd
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j&
   &            , k, ivx))*ss
   u_xd = u_xd - corrd*ssx - corr*ssxd
   u_x = u_x - corr*ssx
   u_yd = u_yd - corrd*ssy - corr*ssyd
   u_y = u_y - corr*ssy
   u_zd = u_zd - corrd*ssz - corr*sszd
   u_z = u_z - corr*ssz
   corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz +&
   &            v_z*sszd - (wd(i, j+1, k, ivy)-wd(i, j, k, ivy))*ss - (w(i, &
   &            j+1, k, ivy)-w(i, j, k, ivy))*ssd
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j&
   &            , k, ivy))*ss
   v_xd = v_xd - corrd*ssx - corr*ssxd
   v_x = v_x - corr*ssx
   v_yd = v_yd - corrd*ssy - corr*ssyd
   v_y = v_y - corr*ssy
   v_zd = v_zd - corrd*ssz - corr*sszd
   v_z = v_z - corr*ssz
   corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz +&
   &            w_z*sszd - (wd(i, j+1, k, ivz)-wd(i, j, k, ivz))*ss - (w(i, &
   &            j+1, k, ivz)-w(i, j, k, ivz))*ssd
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j&
   &            , k, ivz))*ss
   w_xd = w_xd - corrd*ssx - corr*ssxd
   w_x = w_x - corr*ssx
   w_yd = w_yd - corrd*ssy - corr*ssyd
   w_y = w_y - corr*ssy
   w_zd = w_zd - corrd*ssz - corr*sszd
   w_z = w_z - corr*ssz
   corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz +&
   &            q_z*sszd + (pd(i, j+1, k)-pd(i, j, k))*ss + (p(i, j+1, k)-p(&
   &            i, j, k))*ssd
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j+1, k)-p(i, j, k))&
   &            *ss
   q_xd = q_xd - corrd*ssx - corr*ssxd
   q_x = q_x - corr*ssx
   q_yd = q_yd - corrd*ssy - corr*ssyd
   q_y = q_y - corr*ssy
   q_zd = q_zd - corrd*ssz - corr*sszd
   q_z = q_z - corr*ssz
   ! Compute the stress tensor and the heat flux vector.
   fracdivd = twothird*(u_xd+v_yd+w_zd)
   fracdiv = twothird*(u_x+v_y+w_z)
   tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
   tauxx = mut*(two*u_x-fracdiv)
   tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
   tauyy = mut*(two*v_y-fracdiv)
   tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
   tauzz = mut*(two*w_z-fracdiv)
   tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
   tauxy = mut*(u_y+v_x)
   tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
   tauxz = mut*(u_z+w_x)
   tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
   tauyz = mut*(v_z+w_y)
   q_xd = heatcoefd*q_x + heatcoef*q_xd
   q_x = heatcoef*q_x
   q_yd = heatcoefd*q_y + heatcoef*q_yd
   q_y = heatcoef*q_y
   q_zd = heatcoefd*q_z + heatcoef*q_zd
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubard = half*(wd(i, j, k, ivx)+wd(i, j+1, k, ivx))
   ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
   vbard = half*(wd(i, j, k, ivy)+wd(i, j+1, k, ivy))
   vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
   wbard = half*(wd(i, j, k, ivz)+wd(i, j+1, k, ivz))
   wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
   ! Compute the viscous fluxes for this j-face.
   fmxd = tauxxd*sj(i, j, k, 1) + tauxx*sjd(i, j, k, 1) + tauxyd*&
   &            sj(i, j, k, 2) + tauxy*sjd(i, j, k, 2) + tauxzd*sj(i, j, k, &
   &            3) + tauxz*sjd(i, j, k, 3)
   fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i&
   &            , j, k, 3)
   fmyd = tauxyd*sj(i, j, k, 1) + tauxy*sjd(i, j, k, 1) + tauyyd*&
   &            sj(i, j, k, 2) + tauyy*sjd(i, j, k, 2) + tauyzd*sj(i, j, k, &
   &            3) + tauyz*sjd(i, j, k, 3)
   fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i&
   &            , j, k, 3)
   fmzd = tauxzd*sj(i, j, k, 1) + tauxz*sjd(i, j, k, 1) + tauyzd*&
   &            sj(i, j, k, 2) + tauyz*sjd(i, j, k, 2) + tauzzd*sj(i, j, k, &
   &            3) + tauzz*sjd(i, j, k, 3)
   fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i&
   &            , j, k, 3)
   frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
   &            wbard*tauxz+wbar*tauxzd)*sj(i, j, k, 1) + (ubar*tauxx+vbar*&
   &            tauxy+wbar*tauxz)*sjd(i, j, k, 1) + (ubard*tauxy+ubar*tauxyd&
   &            +vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*sj(i, j, k&
   &            , 2) + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sjd(i, j, k, 2) + &
   &            (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd+wbard*tauzz&
   &            +wbar*tauzzd)*sj(i, j, k, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
   &            tauzz)*sjd(i, j, k, 3) - q_xd*sj(i, j, k, 1) - q_x*sjd(i, j&
   &            , k, 1) - q_yd*sj(i, j, k, 2) - q_y*sjd(i, j, k, 2) - q_zd*&
   &            sj(i, j, k, 3) - q_z*sjd(i, j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
   &            ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
   &            tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k&
   &            , 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
   ! Update the residuals of cell j and j+1.
   fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fmxd
   fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
   fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fmyd
   fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
   fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fmzd
   fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
   fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + frhoed
   fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface. Both the cases j == 1
   ! and j == jl must be tested.
   IF (j .EQ. 1 .AND. storewalltensor .AND. viscjminpointer(i, k)&
   &              .GT. 0) THEN
   nn = viscjminpointer(i, k)
   viscsubfaced(nn)%tau(i, k, 1) = tauxxd
   viscsubface(nn)%tau(i, k, 1) = tauxx
   viscsubfaced(nn)%tau(i, k, 2) = tauyyd
   viscsubface(nn)%tau(i, k, 2) = tauyy
   viscsubfaced(nn)%tau(i, k, 3) = tauzzd
   viscsubface(nn)%tau(i, k, 3) = tauzz
   viscsubfaced(nn)%tau(i, k, 4) = tauxyd
   viscsubface(nn)%tau(i, k, 4) = tauxy
   viscsubfaced(nn)%tau(i, k, 5) = tauxzd
   viscsubface(nn)%tau(i, k, 5) = tauxz
   viscsubfaced(nn)%tau(i, k, 6) = tauyzd
   viscsubface(nn)%tau(i, k, 6) = tauyz
   viscsubface(nn)%q(i, k, 1) = q_x
   viscsubface(nn)%q(i, k, 2) = q_y
   viscsubface(nn)%q(i, k, 3) = q_z
   END IF
   ! And the j == jl case.
   IF (j .EQ. jl .AND. storewalltensor .AND. viscjmaxpointer(i, k&
   &              ) .GT. 0) THEN
   nn = viscjmaxpointer(i, k)
   viscsubfaced(nn)%tau(i, k, 1) = tauxxd
   viscsubface(nn)%tau(i, k, 1) = tauxx
   viscsubfaced(nn)%tau(i, k, 2) = tauyyd
   viscsubface(nn)%tau(i, k, 2) = tauyy
   viscsubfaced(nn)%tau(i, k, 3) = tauzzd
   viscsubface(nn)%tau(i, k, 3) = tauzz
   viscsubfaced(nn)%tau(i, k, 4) = tauxyd
   viscsubface(nn)%tau(i, k, 4) = tauxy
   viscsubfaced(nn)%tau(i, k, 5) = tauxzd
   viscsubface(nn)%tau(i, k, 5) = tauxz
   viscsubfaced(nn)%tau(i, k, 6) = tauyzd
   viscsubface(nn)%tau(i, k, 6) = tauyz
   viscsubface(nn)%q(i, k, 1) = q_x
   viscsubface(nn)%q(i, k, 2) = q_y
   viscsubface(nn)%q(i, k, 3) = q_z
   END IF
   END DO
   END DO
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the i-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   DO j=2,jl
   DO i=1,il
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pori(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   muld = por*(rlvd(i, j, k)+rlvd(i+1, j, k))
   mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
   IF (eddymodel) THEN
   mued = por*(revd(i, j, k)+revd(i+1, j, k))
   mue = por*(rev(i, j, k)+rev(i+1, j, k))
   END IF
   mutd = muld + mued
   mut = mul + mue
   gm1d = half*(gammad(i, j, k)+gammad(i+1, j, k))
   gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
   factlamheatd = -(one*prandtl*gm1d/(prandtl*gm1)**2)
   factlamheat = one/(prandtl*gm1)
   factturbheatd = -(one*prandtlturb*gm1d/(prandtlturb*gm1)**2)
   factturbheat = one/(prandtlturb*gm1)
   heatcoefd = muld*factlamheat + mul*factlamheatd + mued*&
   &            factturbheat + mue*factturbheatd
   heatcoef = mul*factlamheat + mue*factturbheat
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_xd = fourth*(uxd(i, j-1, k1)+uxd(i, j, k1)+uxd(i, j-1, k2)+&
   &            uxd(i, j, k2))
   u_x = fourth*(ux(i, j-1, k1)+ux(i, j, k1)+ux(i, j-1, k2)+ux(i&
   &            , j, k2))
   u_yd = fourth*(uyd(i, j-1, k1)+uyd(i, j, k1)+uyd(i, j-1, k2)+&
   &            uyd(i, j, k2))
   u_y = fourth*(uy(i, j-1, k1)+uy(i, j, k1)+uy(i, j-1, k2)+uy(i&
   &            , j, k2))
   u_zd = fourth*(uzd(i, j-1, k1)+uzd(i, j, k1)+uzd(i, j-1, k2)+&
   &            uzd(i, j, k2))
   u_z = fourth*(uz(i, j-1, k1)+uz(i, j, k1)+uz(i, j-1, k2)+uz(i&
   &            , j, k2))
   v_xd = fourth*(vxd(i, j-1, k1)+vxd(i, j, k1)+vxd(i, j-1, k2)+&
   &            vxd(i, j, k2))
   v_x = fourth*(vx(i, j-1, k1)+vx(i, j, k1)+vx(i, j-1, k2)+vx(i&
   &            , j, k2))
   v_yd = fourth*(vyd(i, j-1, k1)+vyd(i, j, k1)+vyd(i, j-1, k2)+&
   &            vyd(i, j, k2))
   v_y = fourth*(vy(i, j-1, k1)+vy(i, j, k1)+vy(i, j-1, k2)+vy(i&
   &            , j, k2))
   v_zd = fourth*(vzd(i, j-1, k1)+vzd(i, j, k1)+vzd(i, j-1, k2)+&
   &            vzd(i, j, k2))
   v_z = fourth*(vz(i, j-1, k1)+vz(i, j, k1)+vz(i, j-1, k2)+vz(i&
   &            , j, k2))
   w_xd = fourth*(wxd(i, j-1, k1)+wxd(i, j, k1)+wxd(i, j-1, k2)+&
   &            wxd(i, j, k2))
   w_x = fourth*(wx(i, j-1, k1)+wx(i, j, k1)+wx(i, j-1, k2)+wx(i&
   &            , j, k2))
   w_yd = fourth*(wyd(i, j-1, k1)+wyd(i, j, k1)+wyd(i, j-1, k2)+&
   &            wyd(i, j, k2))
   w_y = fourth*(wy(i, j-1, k1)+wy(i, j, k1)+wy(i, j-1, k2)+wy(i&
   &            , j, k2))
   w_zd = fourth*(wzd(i, j-1, k1)+wzd(i, j, k1)+wzd(i, j-1, k2)+&
   &            wzd(i, j, k2))
   w_z = fourth*(wz(i, j-1, k1)+wz(i, j, k1)+wz(i, j-1, k2)+wz(i&
   &            , j, k2))
   q_xd = fourth*(qxd(i, j-1, k1)+qxd(i, j, k1)+qxd(i, j-1, k2)+&
   &            qxd(i, j, k2))
   q_x = fourth*(qx(i, j-1, k1)+qx(i, j, k1)+qx(i, j-1, k2)+qx(i&
   &            , j, k2))
   q_yd = fourth*(qyd(i, j-1, k1)+qyd(i, j, k1)+qyd(i, j-1, k2)+&
   &            qyd(i, j, k2))
   q_y = fourth*(qy(i, j-1, k1)+qy(i, j, k1)+qy(i, j-1, k2)+qy(i&
   &            , j, k2))
   q_zd = fourth*(qzd(i, j-1, k1)+qzd(i, j, k1)+qzd(i, j-1, k2)+&
   &            qzd(i, j, k2))
   q_z = fourth*(qz(i, j-1, k1)+qz(i, j, k1)+qz(i, j-1, k2)+qz(i&
   &            , j, k2))
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center i to cell center i+1.
   ssxd = eighth*(xd(i+1, j-1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(i+&
   &            1, j-1, k, 1)-xd(i-1, j-1, k, 1)+xd(i+1, j, k-1, 1)-xd(i-1, &
   &            j, k-1, 1)+xd(i+1, j, k, 1)-xd(i-1, j, k, 1))
   ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
   &            -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
   &            , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
   ssyd = eighth*(xd(i+1, j-1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(i+&
   &            1, j-1, k, 2)-xd(i-1, j-1, k, 2)+xd(i+1, j, k-1, 2)-xd(i-1, &
   &            j, k-1, 2)+xd(i+1, j, k, 2)-xd(i-1, j, k, 2))
   ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
   &            -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
   &            , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
   sszd = eighth*(xd(i+1, j-1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(i+&
   &            1, j-1, k, 3)-xd(i-1, j-1, k, 3)+xd(i+1, j, k-1, 3)-xd(i-1, &
   &            j, k-1, 3)+xd(i+1, j, k, 3)-xd(i-1, j, k, 3))
   ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
   &            -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
   &            , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
   ! Determine the length of this vector and create the
   ! unit normal.
   arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz +&
   &            ssz*sszd
   arg1 = ssx*ssx + ssy*ssy + ssz*ssz
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   ssd = -(one*result1d/result1**2)
   ss = one/result1
   ssxd = ssd*ssx + ss*ssxd
   ssx = ss*ssx
   ssyd = ssd*ssy + ss*ssyd
   ssy = ss*ssy
   sszd = ssd*ssz + ss*sszd
   ssz = ss*ssz
   ! Correct the gradients.
   corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz +&
   &            u_z*sszd - (wd(i+1, j, k, ivx)-wd(i, j, k, ivx))*ss - (w(i+1&
   &            , j, k, ivx)-w(i, j, k, ivx))*ssd
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j&
   &            , k, ivx))*ss
   u_xd = u_xd - corrd*ssx - corr*ssxd
   u_x = u_x - corr*ssx
   u_yd = u_yd - corrd*ssy - corr*ssyd
   u_y = u_y - corr*ssy
   u_zd = u_zd - corrd*ssz - corr*sszd
   u_z = u_z - corr*ssz
   corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz +&
   &            v_z*sszd - (wd(i+1, j, k, ivy)-wd(i, j, k, ivy))*ss - (w(i+1&
   &            , j, k, ivy)-w(i, j, k, ivy))*ssd
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j&
   &            , k, ivy))*ss
   v_xd = v_xd - corrd*ssx - corr*ssxd
   v_x = v_x - corr*ssx
   v_yd = v_yd - corrd*ssy - corr*ssyd
   v_y = v_y - corr*ssy
   v_zd = v_zd - corrd*ssz - corr*sszd
   v_z = v_z - corr*ssz
   corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz +&
   &            w_z*sszd - (wd(i+1, j, k, ivz)-wd(i, j, k, ivz))*ss - (w(i+1&
   &            , j, k, ivz)-w(i, j, k, ivz))*ssd
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j&
   &            , k, ivz))*ss
   w_xd = w_xd - corrd*ssx - corr*ssxd
   w_x = w_x - corr*ssx
   w_yd = w_yd - corrd*ssy - corr*ssyd
   w_y = w_y - corr*ssy
   w_zd = w_zd - corrd*ssz - corr*sszd
   w_z = w_z - corr*ssz
   corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz +&
   &            q_z*sszd + (pd(i+1, j, k)-pd(i, j, k))*ss + (p(i+1, j, k)-p(&
   &            i, j, k))*ssd
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i+1, j, k)-p(i, j, k))&
   &            *ss
   q_xd = q_xd - corrd*ssx - corr*ssxd
   q_x = q_x - corr*ssx
   q_yd = q_yd - corrd*ssy - corr*ssyd
   q_y = q_y - corr*ssy
   q_zd = q_zd - corrd*ssz - corr*sszd
   q_z = q_z - corr*ssz
   ! Compute the stress tensor and the heat flux vector.
   fracdivd = twothird*(u_xd+v_yd+w_zd)
   fracdiv = twothird*(u_x+v_y+w_z)
   tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
   tauxx = mut*(two*u_x-fracdiv)
   tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
   tauyy = mut*(two*v_y-fracdiv)
   tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
   tauzz = mut*(two*w_z-fracdiv)
   tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
   tauxy = mut*(u_y+v_x)
   tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
   tauxz = mut*(u_z+w_x)
   tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
   tauyz = mut*(v_z+w_y)
   q_xd = heatcoefd*q_x + heatcoef*q_xd
   q_x = heatcoef*q_x
   q_yd = heatcoefd*q_y + heatcoef*q_yd
   q_y = heatcoef*q_y
   q_zd = heatcoefd*q_z + heatcoef*q_zd
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubard = half*(wd(i, j, k, ivx)+wd(i+1, j, k, ivx))
   ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
   vbard = half*(wd(i, j, k, ivy)+wd(i+1, j, k, ivy))
   vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
   wbard = half*(wd(i, j, k, ivz)+wd(i+1, j, k, ivz))
   wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
   ! Compute the viscous fluxes for this i-face.
   fmxd = tauxxd*si(i, j, k, 1) + tauxx*sid(i, j, k, 1) + tauxyd*&
   &            si(i, j, k, 2) + tauxy*sid(i, j, k, 2) + tauxzd*si(i, j, k, &
   &            3) + tauxz*sid(i, j, k, 3)
   fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i&
   &            , j, k, 3)
   fmyd = tauxyd*si(i, j, k, 1) + tauxy*sid(i, j, k, 1) + tauyyd*&
   &            si(i, j, k, 2) + tauyy*sid(i, j, k, 2) + tauyzd*si(i, j, k, &
   &            3) + tauyz*sid(i, j, k, 3)
   fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i&
   &            , j, k, 3)
   fmzd = tauxzd*si(i, j, k, 1) + tauxz*sid(i, j, k, 1) + tauyzd*&
   &            si(i, j, k, 2) + tauyz*sid(i, j, k, 2) + tauzzd*si(i, j, k, &
   &            3) + tauzz*sid(i, j, k, 3)
   fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i&
   &            , j, k, 3)
   frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
   &            wbard*tauxz+wbar*tauxzd)*si(i, j, k, 1) + (ubar*tauxx+vbar*&
   &            tauxy+wbar*tauxz)*sid(i, j, k, 1) + (ubard*tauxy+ubar*tauxyd&
   &            +vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*si(i, j, k&
   &            , 2) + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sid(i, j, k, 2) + &
   &            (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd+wbard*tauzz&
   &            +wbar*tauzzd)*si(i, j, k, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
   &            tauzz)*sid(i, j, k, 3) - q_xd*si(i, j, k, 1) - q_x*sid(i, j&
   &            , k, 1) - q_yd*si(i, j, k, 2) - q_y*sid(i, j, k, 2) - q_zd*&
   &            si(i, j, k, 3) - q_z*sid(i, j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
   &            ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
   &            tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k&
   &            , 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
   ! Update the residuals of cell i and i+1.
   fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fmxd
   fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
   fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fmyd
   fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
   fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fmzd
   fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
   fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + frhoed
   fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface. Both the cases i == 1
   ! and i == il must be tested.
   IF (i .EQ. 1 .AND. storewalltensor .AND. visciminpointer(j, k)&
   &              .GT. 0) THEN
   nn = visciminpointer(j, k)
   viscsubfaced(nn)%tau(j, k, 1) = tauxxd
   viscsubface(nn)%tau(j, k, 1) = tauxx
   viscsubfaced(nn)%tau(j, k, 2) = tauyyd
   viscsubface(nn)%tau(j, k, 2) = tauyy
   viscsubfaced(nn)%tau(j, k, 3) = tauzzd
   viscsubface(nn)%tau(j, k, 3) = tauzz
   viscsubfaced(nn)%tau(j, k, 4) = tauxyd
   viscsubface(nn)%tau(j, k, 4) = tauxy
   viscsubfaced(nn)%tau(j, k, 5) = tauxzd
   viscsubface(nn)%tau(j, k, 5) = tauxz
   viscsubfaced(nn)%tau(j, k, 6) = tauyzd
   viscsubface(nn)%tau(j, k, 6) = tauyz
   viscsubface(nn)%q(j, k, 1) = q_x
   viscsubface(nn)%q(j, k, 2) = q_y
   viscsubface(nn)%q(j, k, 3) = q_z
   END IF
   ! And the i == il case.
   IF (i .EQ. il .AND. storewalltensor .AND. viscimaxpointer(j, k&
   &              ) .GT. 0) THEN
   nn = viscimaxpointer(j, k)
   viscsubfaced(nn)%tau(j, k, 1) = tauxxd
   viscsubface(nn)%tau(j, k, 1) = tauxx
   viscsubfaced(nn)%tau(j, k, 2) = tauyyd
   viscsubface(nn)%tau(j, k, 2) = tauyy
   viscsubfaced(nn)%tau(j, k, 3) = tauzzd
   viscsubface(nn)%tau(j, k, 3) = tauzz
   viscsubfaced(nn)%tau(j, k, 4) = tauxyd
   viscsubface(nn)%tau(j, k, 4) = tauxy
   viscsubfaced(nn)%tau(j, k, 5) = tauxzd
   viscsubface(nn)%tau(j, k, 5) = tauxz
   viscsubfaced(nn)%tau(j, k, 6) = tauyzd
   viscsubface(nn)%tau(j, k, 6) = tauyz
   viscsubface(nn)%q(j, k, 1) = q_x
   viscsubface(nn)%q(j, k, 2) = q_y
   viscsubface(nn)%q(j, k, 3) = q_z
   END IF
   END DO
   END DO
   END DO kloop
   ! Restore the pressure in p. Again only the first layer of
   ! halo cells.
   DO k=1,ke
   DO j=1,je
   DO i=1,ie
   pd(i, j, k) = ((wd(i, j, k, irho)*p(i, j, k)+w(i, j, k, irho)*&
   &            pd(i, j, k))*gamma(i, j, k)-w(i, j, k, irho)*p(i, j, k)*&
   &            gammad(i, j, k))/gamma(i, j, k)**2
   p(i, j, k) = w(i, j, k, irho)*p(i, j, k)/gamma(i, j, k)
   END DO
   END DO
   END DO
   IF (correctfork) THEN
   DO k=1,ke
   DO j=1,je
   DO i=1,ie
   pd(i, j, k) = pd(i, j, k) + twothird*(wd(i, j, k, irho)*w(i&
   &              , j, k, itu1)+w(i, j, k, irho)*wd(i, j, k, itu1))
   p(i, j, k) = p(i, j, k) + twothird*w(i, j, k, irho)*w(i, j, &
   &              k, itu1)
   END DO
   END DO
   END DO
   END IF
   CALL DEBUG_TGT_CALL('UTAUWF', .TRUE., .FALSE.)
   ! Possibly correct the wall shear stress.
   CALL UTAUWF_T(rfilv)
   CALL DEBUG_TGT_EXIT()
   END IF
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFDrfp*ISIZE2OFDrfp*&
   &                        ISIZE3OFDrfp)
   CALL DEBUG_TGT_REAL8ARRAY('fw', fw, fwd, ISIZE1OFDrffw*ISIZE2OFDrffw&
   &                        *ISIZE3OFDrffw*ISIZE4OFDrffw)
   DO ii1=1,ISIZE1OFDrfviscsubface
   CALL DEBUG_TGT_REAL8ARRAY('viscsubface', viscsubface(ii1)%tau, &
   &                          viscsubfaced(ii1)%tau, &
   &                          ISIZE1OFDrfDrfviscsubface_tau*&
   &                          ISIZE2OFDrfDrfviscsubface_tau*&
   &                          ISIZE3OFDrfDrfviscsubface_tau)
   END DO
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
      CONTAINS
   !  Differentiation of nodalgradients in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: wx wy wz qx qy qz ux uy uz
   !                vx vy vz
   !   with respect to varying inputs: *p *w *vol *si *sj *sk wx wy
   !                wz qx qy qz ux uy uz vx vy vz
   !   Plus diff mem management of: p:in w:in vol:in si:in sj:in sk:in
   SUBROUTINE NODALGRADIENTS_T(ux, uxd, uy, uyd, uz, uzd, vx, vxd, vy, &
   &    vyd, vz, vzd, wx, wxd, wy, wyd, wz, wzd, qx, qxd, qy, qyd, qz, qzd)
   USE DIFFSIZES
   !  Hint: ISIZE4OFDrfsk should be the size of dimension 4 of array *sk
   !  Hint: ISIZE3OFDrfsk should be the size of dimension 3 of array *sk
   !  Hint: ISIZE2OFDrfsk should be the size of dimension 2 of array *sk
   !  Hint: ISIZE1OFDrfsk should be the size of dimension 1 of array *sk
   !  Hint: ISIZE4OFDrfsj should be the size of dimension 4 of array *sj
   !  Hint: ISIZE3OFDrfsj should be the size of dimension 3 of array *sj
   !  Hint: ISIZE2OFDrfsj should be the size of dimension 2 of array *sj
   !  Hint: ISIZE1OFDrfsj should be the size of dimension 1 of array *sj
   !  Hint: ISIZE4OFDrfsi should be the size of dimension 4 of array *si
   !  Hint: ISIZE3OFDrfsi should be the size of dimension 3 of array *si
   !  Hint: ISIZE2OFDrfsi should be the size of dimension 2 of array *si
   !  Hint: ISIZE1OFDrfsi should be the size of dimension 1 of array *si
   !  Hint: ISIZE3OFDrfvol should be the size of dimension 3 of array *vol
   !  Hint: ISIZE2OFDrfvol should be the size of dimension 2 of array *vol
   !  Hint: ISIZE1OFDrfvol should be the size of dimension 1 of array *vol
   !  Hint: ISIZE4OFDrfw should be the size of dimension 4 of array *w
   !  Hint: ISIZE3OFDrfw should be the size of dimension 3 of array *w
   !  Hint: ISIZE2OFDrfw should be the size of dimension 2 of array *w
   !  Hint: ISIZE1OFDrfw should be the size of dimension 1 of array *w
   !  Hint: ISIZE3OFDrfp should be the size of dimension 3 of array *p
   !  Hint: ISIZE2OFDrfp should be the size of dimension 2 of array *p
   !  Hint: ISIZE1OFDrfp should be the size of dimension 1 of array *p
   IMPLICIT NONE
   !
   !        Subroutine arguments
   !
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: ux, uy, &
   &    uz, vx, vy, vz, wx, wy, wz, qx, qy, qz
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: uxd, uyd&
   &    , uzd, vxd, vyd, vzd, wxd, wyd, wzd, qxd, qyd, qzd
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: oneoverv, ubar, vbar, wbar, a2
   REAL(kind=realtype) :: oneovervd, ubard, vbard, wbard, a2d
   REAL(kind=realtype) :: sx, sx1, sy, sy1, sz, sz1
   REAL(kind=realtype) :: sxd, sx1d, syd, sy1d, szd, sz1d
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFDrfp*ISIZE2OFDrfp*&
   &                          ISIZE3OFDrfp)
   CALL DEBUG_TGT_REAL8ARRAY('w', w, wd, ISIZE1OFDrfw*ISIZE2OFDrfw*&
   &                          ISIZE3OFDrfw*ISIZE4OFDrfw)
   CALL DEBUG_TGT_REAL8ARRAY('vol', vol, vold, ISIZE1OFDrfvol*&
   &                          ISIZE2OFDrfvol*ISIZE3OFDrfvol)
   CALL DEBUG_TGT_REAL8ARRAY('si', si, sid, ISIZE1OFDrfsi*&
   &                          ISIZE2OFDrfsi*ISIZE3OFDrfsi*ISIZE4OFDrfsi)
   CALL DEBUG_TGT_REAL8ARRAY('sj', sj, sjd, ISIZE1OFDrfsj*&
   &                          ISIZE2OFDrfsj*ISIZE3OFDrfsj*ISIZE4OFDrfsj)
   CALL DEBUG_TGT_REAL8ARRAY('sk', sk, skd, ISIZE1OFDrfsk*&
   &                          ISIZE2OFDrfsk*ISIZE3OFDrfsk*ISIZE4OFDrfsk)
   CALL DEBUG_TGT_REAL8ARRAY('wx', wx, wxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wy', wy, wyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wz', wz, wzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qx', qx, qxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qy', qy, qyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qz', qz, qzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('ux', ux, uxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uy', uy, uyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uz', uz, uzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vx', vx, vxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vy', vy, vyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vz', vz, vzd, il*jl*2)
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! First part. Contribution in the k-direction. As the viscous
   ! fluxes are computed per k-plane, the values of the surface
   ! integrals in gauss's theorem are only scattered to one node.
   ! Consequently this part is an initialization as well.
   ! Loop over the j and i direction.
   DO j=1,jl
   DO i=1,il
   ! Store 8 times the average normal for the contribution from
   ! the k-layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sx1d = skd(i, j, k, 1) + skd(i+1, j, k, 1) + skd(i, j+1, k, 1) +&
   &          skd(i+1, j+1, k, 1)
   sx1 = sk(i, j, k, 1) + sk(i+1, j, k, 1) + sk(i, j+1, k, 1) + sk(&
   &          i+1, j+1, k, 1)
   sy1d = skd(i, j, k, 2) + skd(i+1, j, k, 2) + skd(i, j+1, k, 2) +&
   &          skd(i+1, j+1, k, 2)
   sy1 = sk(i, j, k, 2) + sk(i+1, j, k, 2) + sk(i, j+1, k, 2) + sk(&
   &          i+1, j+1, k, 2)
   sz1d = skd(i, j, k, 3) + skd(i+1, j, k, 3) + skd(i, j+1, k, 3) +&
   &          skd(i+1, j+1, k, 3)
   sz1 = sk(i, j, k, 3) + sk(i+1, j, k, 3) + sk(i, j+1, k, 3) + sk(&
   &          i+1, j+1, k, 3)
   sxd = sx1d + skd(i, j, k-1, 1) + skd(i+1, j, k-1, 1) + skd(i, j+&
   &          1, k-1, 1) + skd(i+1, j+1, k-1, 1)
   sx = sx1 + sk(i, j, k-1, 1) + sk(i+1, j, k-1, 1) + sk(i, j+1, k-&
   &          1, 1) + sk(i+1, j+1, k-1, 1)
   syd = sy1d + skd(i, j, k-1, 2) + skd(i+1, j, k-1, 2) + skd(i, j+&
   &          1, k-1, 2) + skd(i+1, j+1, k-1, 2)
   sy = sy1 + sk(i, j, k-1, 2) + sk(i+1, j, k-1, 2) + sk(i, j+1, k-&
   &          1, 2) + sk(i+1, j+1, k-1, 2)
   szd = sz1d + skd(i, j, k-1, 3) + skd(i+1, j, k-1, 3) + skd(i, j+&
   &          1, k-1, 3) + skd(i+1, j+1, k-1, 3)
   sz = sz1 + sk(i, j, k-1, 3) + sk(i+1, j, k-1, 3) + sk(i, j+1, k-&
   &          1, 3) + sk(i+1, j+1, k-1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubard = fourth*(wd(i, j, k, ivx)+wd(i+1, j, k, ivx)+wd(i, j+1, k&
   &          , ivx)+wd(i+1, j+1, k, ivx))
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j+1, k, &
   &          ivx)+w(i+1, j+1, k, ivx))
   vbard = fourth*(wd(i, j, k, ivy)+wd(i+1, j, k, ivy)+wd(i, j+1, k&
   &          , ivy)+wd(i+1, j+1, k, ivy))
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j+1, k, &
   &          ivy)+w(i+1, j+1, k, ivy))
   wbard = fourth*(wd(i, j, k, ivz)+wd(i+1, j, k, ivz)+wd(i, j+1, k&
   &          , ivz)+wd(i+1, j+1, k, ivz))
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j+1, k, &
   &          ivz)+w(i+1, j+1, k, ivz))
   a2d = fourth*(pd(i, j, k)+pd(i+1, j, k)+pd(i, j+1, k)+pd(i+1, j+&
   &          1, k))
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j+1, k)+p(i+1, j+1, k)&
   &          )
   ! Set the velocity and speed of sound square gradients.
   ! The minus sign is there, because these normals are inward
   ! pointing for the nodal k-layer. The exception is a2,
   ! because the gradient of -a2 is stored, as this is needed
   ! in the heat fluxes.
   uxd(i, j, k1) = -(ubard*sx+ubar*sxd)
   ux(i, j, k1) = -(ubar*sx)
   uyd(i, j, k1) = -(ubard*sy+ubar*syd)
   uy(i, j, k1) = -(ubar*sy)
   uzd(i, j, k1) = -(ubard*sz+ubar*szd)
   uz(i, j, k1) = -(ubar*sz)
   vxd(i, j, k1) = -(vbard*sx+vbar*sxd)
   vx(i, j, k1) = -(vbar*sx)
   vyd(i, j, k1) = -(vbard*sy+vbar*syd)
   vy(i, j, k1) = -(vbar*sy)
   vzd(i, j, k1) = -(vbard*sz+vbar*szd)
   vz(i, j, k1) = -(vbar*sz)
   wxd(i, j, k1) = -(wbard*sx+wbar*sxd)
   wx(i, j, k1) = -(wbar*sx)
   wyd(i, j, k1) = -(wbard*sy+wbar*syd)
   wy(i, j, k1) = -(wbar*sy)
   wzd(i, j, k1) = -(wbard*sz+wbar*szd)
   wz(i, j, k1) = -(wbar*sz)
   qxd(i, j, k1) = a2d*sx + a2*sxd
   qx(i, j, k1) = a2*sx
   qyd(i, j, k1) = a2d*sy + a2*syd
   qy(i, j, k1) = a2*sy
   qzd(i, j, k1) = a2d*sz + a2*szd
   qz(i, j, k1) = a2*sz
   ! Store 8 times the average normal for the contribution from
   ! the k+1 layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sxd = sx1d + skd(i, j, k+1, 1) + skd(i+1, j, k+1, 1) + skd(i, j+&
   &          1, k+1, 1) + skd(i+1, j+1, k+1, 1)
   sx = sx1 + sk(i, j, k+1, 1) + sk(i+1, j, k+1, 1) + sk(i, j+1, k+&
   &          1, 1) + sk(i+1, j+1, k+1, 1)
   syd = sy1d + skd(i, j, k+1, 2) + skd(i+1, j, k+1, 2) + skd(i, j+&
   &          1, k+1, 2) + skd(i+1, j+1, k+1, 2)
   sy = sy1 + sk(i, j, k+1, 2) + sk(i+1, j, k+1, 2) + sk(i, j+1, k+&
   &          1, 2) + sk(i+1, j+1, k+1, 2)
   szd = sz1d + skd(i, j, k+1, 3) + skd(i+1, j, k+1, 3) + skd(i, j+&
   &          1, k+1, 3) + skd(i+1, j+1, k+1, 3)
   sz = sz1 + sk(i, j, k+1, 3) + sk(i+1, j, k+1, 3) + sk(i, j+1, k+&
   &          1, 3) + sk(i+1, j+1, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubard = fourth*(wd(i, j, k+1, ivx)+wd(i+1, j, k+1, ivx)+wd(i, j+&
   &          1, k+1, ivx)+wd(i+1, j+1, k+1, ivx))
   ubar = fourth*(w(i, j, k+1, ivx)+w(i+1, j, k+1, ivx)+w(i, j+1, k&
   &          +1, ivx)+w(i+1, j+1, k+1, ivx))
   vbard = fourth*(wd(i, j, k+1, ivy)+wd(i+1, j, k+1, ivy)+wd(i, j+&
   &          1, k+1, ivy)+wd(i+1, j+1, k+1, ivy))
   vbar = fourth*(w(i, j, k+1, ivy)+w(i+1, j, k+1, ivy)+w(i, j+1, k&
   &          +1, ivy)+w(i+1, j+1, k+1, ivy))
   wbard = fourth*(wd(i, j, k+1, ivz)+wd(i+1, j, k+1, ivz)+wd(i, j+&
   &          1, k+1, ivz)+wd(i+1, j+1, k+1, ivz))
   wbar = fourth*(w(i, j, k+1, ivz)+w(i+1, j, k+1, ivz)+w(i, j+1, k&
   &          +1, ivz)+w(i+1, j+1, k+1, ivz))
   a2d = fourth*(pd(i, j, k+1)+pd(i+1, j, k+1)+pd(i, j+1, k+1)+pd(i&
   &          +1, j+1, k+1))
   a2 = fourth*(p(i, j, k+1)+p(i+1, j, k+1)+p(i, j+1, k+1)+p(i+1, j&
   &          +1, k+1))
   ! Update the velocity and (minus) the speed of sound
   ! gradients. As the normals are now outward pointing for
   ! the nodes in the k-layer, there is a plus sign for the
   ! velocity gradients and a minus sign for minus the speed
   ! of sound squared.
   uxd(i, j, k1) = uxd(i, j, k1) + ubard*sx + ubar*sxd
   ux(i, j, k1) = ux(i, j, k1) + ubar*sx
   uyd(i, j, k1) = uyd(i, j, k1) + ubard*sy + ubar*syd
   uy(i, j, k1) = uy(i, j, k1) + ubar*sy
   uzd(i, j, k1) = uzd(i, j, k1) + ubard*sz + ubar*szd
   uz(i, j, k1) = uz(i, j, k1) + ubar*sz
   vxd(i, j, k1) = vxd(i, j, k1) + vbard*sx + vbar*sxd
   vx(i, j, k1) = vx(i, j, k1) + vbar*sx
   vyd(i, j, k1) = vyd(i, j, k1) + vbard*sy + vbar*syd
   vy(i, j, k1) = vy(i, j, k1) + vbar*sy
   vzd(i, j, k1) = vzd(i, j, k1) + vbard*sz + vbar*szd
   vz(i, j, k1) = vz(i, j, k1) + vbar*sz
   wxd(i, j, k1) = wxd(i, j, k1) + wbard*sx + wbar*sxd
   wx(i, j, k1) = wx(i, j, k1) + wbar*sx
   wyd(i, j, k1) = wyd(i, j, k1) + wbard*sy + wbar*syd
   wy(i, j, k1) = wy(i, j, k1) + wbar*sy
   wzd(i, j, k1) = wzd(i, j, k1) + wbard*sz + wbar*szd
   wz(i, j, k1) = wz(i, j, k1) + wbar*sz
   qxd(i, j, k1) = qxd(i, j, k1) - a2d*sx - a2*sxd
   qx(i, j, k1) = qx(i, j, k1) - a2*sx
   qyd(i, j, k1) = qyd(i, j, k1) - a2d*sy - a2*syd
   qy(i, j, k1) = qy(i, j, k1) - a2*sy
   qzd(i, j, k1) = qzd(i, j, k1) - a2d*sz - a2*szd
   qz(i, j, k1) = qz(i, j, k1) - a2*sz
   END DO
   END DO
   ! Second part. Contribution in the j-direction.
   ! The contribution is scattered to both the left and right node
   ! in j-direction.
   DO j=1,je
   DO i=1,il
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sxd = sjd(i, j-1, k, 1) + sjd(i+1, j-1, k, 1) + sjd(i, j-1, k+1&
   &          , 1) + sjd(i+1, j-1, k+1, 1) + sjd(i, j, k, 1) + sjd(i+1, j, k&
   &          , 1) + sjd(i, j, k+1, 1) + sjd(i+1, j, k+1, 1)
   sx = sj(i, j-1, k, 1) + sj(i+1, j-1, k, 1) + sj(i, j-1, k+1, 1) &
   &          + sj(i+1, j-1, k+1, 1) + sj(i, j, k, 1) + sj(i+1, j, k, 1) + &
   &          sj(i, j, k+1, 1) + sj(i+1, j, k+1, 1)
   syd = sjd(i, j-1, k, 2) + sjd(i+1, j-1, k, 2) + sjd(i, j-1, k+1&
   &          , 2) + sjd(i+1, j-1, k+1, 2) + sjd(i, j, k, 2) + sjd(i+1, j, k&
   &          , 2) + sjd(i, j, k+1, 2) + sjd(i+1, j, k+1, 2)
   sy = sj(i, j-1, k, 2) + sj(i+1, j-1, k, 2) + sj(i, j-1, k+1, 2) &
   &          + sj(i+1, j-1, k+1, 2) + sj(i, j, k, 2) + sj(i+1, j, k, 2) + &
   &          sj(i, j, k+1, 2) + sj(i+1, j, k+1, 2)
   szd = sjd(i, j-1, k, 3) + sjd(i+1, j-1, k, 3) + sjd(i, j-1, k+1&
   &          , 3) + sjd(i+1, j-1, k+1, 3) + sjd(i, j, k, 3) + sjd(i+1, j, k&
   &          , 3) + sjd(i, j, k+1, 3) + sjd(i+1, j, k+1, 3)
   sz = sj(i, j-1, k, 3) + sj(i+1, j-1, k, 3) + sj(i, j-1, k+1, 3) &
   &          + sj(i+1, j-1, k+1, 3) + sj(i, j, k, 3) + sj(i+1, j, k, 3) + &
   &          sj(i, j, k+1, 3) + sj(i+1, j, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubard = fourth*(wd(i, j, k, ivx)+wd(i+1, j, k, ivx)+wd(i, j, k+1&
   &          , ivx)+wd(i+1, j, k+1, ivx))
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i+1, j, k+1, ivx))
   vbard = fourth*(wd(i, j, k, ivy)+wd(i+1, j, k, ivy)+wd(i, j, k+1&
   &          , ivy)+wd(i+1, j, k+1, ivy))
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i+1, j, k+1, ivy))
   wbard = fourth*(wd(i, j, k, ivz)+wd(i+1, j, k, ivz)+wd(i, j, k+1&
   &          , ivz)+wd(i+1, j, k+1, ivz))
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i+1, j, k+1, ivz))
   a2d = fourth*(pd(i, j, k)+pd(i+1, j, k)+pd(i, j, k+1)+pd(i+1, j&
   &          , k+1))
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j, k+1)+p(i+1, j, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (j .GT. 1) THEN
   uxd(i, j-1, k1) = uxd(i, j-1, k1) + ubard*sx + ubar*sxd
   ux(i, j-1, k1) = ux(i, j-1, k1) + ubar*sx
   uyd(i, j-1, k1) = uyd(i, j-1, k1) + ubard*sy + ubar*syd
   uy(i, j-1, k1) = uy(i, j-1, k1) + ubar*sy
   uzd(i, j-1, k1) = uzd(i, j-1, k1) + ubard*sz + ubar*szd
   uz(i, j-1, k1) = uz(i, j-1, k1) + ubar*sz
   vxd(i, j-1, k1) = vxd(i, j-1, k1) + vbard*sx + vbar*sxd
   vx(i, j-1, k1) = vx(i, j-1, k1) + vbar*sx
   vyd(i, j-1, k1) = vyd(i, j-1, k1) + vbard*sy + vbar*syd
   vy(i, j-1, k1) = vy(i, j-1, k1) + vbar*sy
   vzd(i, j-1, k1) = vzd(i, j-1, k1) + vbard*sz + vbar*szd
   vz(i, j-1, k1) = vz(i, j-1, k1) + vbar*sz
   wxd(i, j-1, k1) = wxd(i, j-1, k1) + wbard*sx + wbar*sxd
   wx(i, j-1, k1) = wx(i, j-1, k1) + wbar*sx
   wyd(i, j-1, k1) = wyd(i, j-1, k1) + wbard*sy + wbar*syd
   wy(i, j-1, k1) = wy(i, j-1, k1) + wbar*sy
   wzd(i, j-1, k1) = wzd(i, j-1, k1) + wbard*sz + wbar*szd
   wz(i, j-1, k1) = wz(i, j-1, k1) + wbar*sz
   qxd(i, j-1, k1) = qxd(i, j-1, k1) - a2d*sx - a2*sxd
   qx(i, j-1, k1) = qx(i, j-1, k1) - a2*sx
   qyd(i, j-1, k1) = qyd(i, j-1, k1) - a2d*sy - a2*syd
   qy(i, j-1, k1) = qy(i, j-1, k1) - a2*sy
   qzd(i, j-1, k1) = qzd(i, j-1, k1) - a2d*sz - a2*szd
   qz(i, j-1, k1) = qz(i, j-1, k1) - a2*sz
   END IF
   IF (j .LT. je) THEN
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFDrfp*&
   &                                ISIZE2OFDrfp*ISIZE3OFDrfp)
   CALL DEBUG_TGT_REAL8ARRAY('w', w, wd, ISIZE1OFDrfw*&
   &                                ISIZE2OFDrfw*ISIZE3OFDrfw*ISIZE4OFDrfw)
   CALL DEBUG_TGT_REAL8ARRAY('vol', vol, vold, ISIZE1OFDrfvol*&
   &                                ISIZE2OFDrfvol*ISIZE3OFDrfvol)
   CALL DEBUG_TGT_REAL8ARRAY('si', si, sid, ISIZE1OFDrfsi*&
   &                                ISIZE2OFDrfsi*ISIZE3OFDrfsi*&
   &                                ISIZE4OFDrfsi)
   CALL DEBUG_TGT_REAL8ARRAY('sj', sj, sjd, ISIZE1OFDrfsj*&
   &                                ISIZE2OFDrfsj*ISIZE3OFDrfsj*&
   &                                ISIZE4OFDrfsj)
   CALL DEBUG_TGT_REAL8ARRAY('wx', wx, wxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wy', wy, wyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wz', wz, wzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qx', qx, qxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qy', qy, qyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qz', qz, qzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('ux', ux, uxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uy', uy, uyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uz', uz, uzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vx', vx, vxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vy', vy, vyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vz', vz, vzd, il*jl*2)
   CALL DEBUG_TGT_REAL8('wbar', wbar, wbard)
   CALL DEBUG_TGT_REAL8('vbar', vbar, vbard)
   CALL DEBUG_TGT_REAL8('ubar', ubar, ubard)
   CALL DEBUG_TGT_REAL8('a2', a2, a2d)
   CALL DEBUG_TGT_REAL8('sx', sx, sxd)
   CALL DEBUG_TGT_REAL8('sy', sy, syd)
   CALL DEBUG_TGT_REAL8('sz', sz, szd)
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   uxd(i, j, k1) = uxd(i, j, k1) - ubard*sx - ubar*sxd
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uyd(i, j, k1) = uyd(i, j, k1) - ubard*sy - ubar*syd
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uzd(i, j, k1) = uzd(i, j, k1) - ubard*sz - ubar*szd
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vxd(i, j, k1) = vxd(i, j, k1) - vbard*sx - vbar*sxd
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vyd(i, j, k1) = vyd(i, j, k1) - vbard*sy - vbar*syd
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vzd(i, j, k1) = vzd(i, j, k1) - vbard*sz - vbar*szd
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wxd(i, j, k1) = wxd(i, j, k1) - wbard*sx - wbar*sxd
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wyd(i, j, k1) = wyd(i, j, k1) - wbard*sy - wbar*syd
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wzd(i, j, k1) = wzd(i, j, k1) - wbard*sz - wbar*szd
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qxd(i, j, k1) = qxd(i, j, k1) + a2d*sx + a2*sxd
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qyd(i, j, k1) = qyd(i, j, k1) + a2d*sy + a2*syd
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qzd(i, j, k1) = qzd(i, j, k1) + a2d*sz + a2*szd
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   END IF
   END DO
   END DO
   ! Third part. Contribution in the i-direction.
   ! The contribution is scattered to both the left and right node
   ! in i-direction.
   DO j=1,jl
   DO i=1,ie
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sxd = sid(i-1, j, k, 1) + sid(i-1, j+1, k, 1) + sid(i-1, j, k+1&
   &          , 1) + sid(i-1, j+1, k+1, 1) + sid(i, j, k, 1) + sid(i, j+1, k&
   &          , 1) + sid(i, j, k+1, 1) + sid(i, j+1, k+1, 1)
   sx = si(i-1, j, k, 1) + si(i-1, j+1, k, 1) + si(i-1, j, k+1, 1) &
   &          + si(i-1, j+1, k+1, 1) + si(i, j, k, 1) + si(i, j+1, k, 1) + &
   &          si(i, j, k+1, 1) + si(i, j+1, k+1, 1)
   syd = sid(i-1, j, k, 2) + sid(i-1, j+1, k, 2) + sid(i-1, j, k+1&
   &          , 2) + sid(i-1, j+1, k+1, 2) + sid(i, j, k, 2) + sid(i, j+1, k&
   &          , 2) + sid(i, j, k+1, 2) + sid(i, j+1, k+1, 2)
   sy = si(i-1, j, k, 2) + si(i-1, j+1, k, 2) + si(i-1, j, k+1, 2) &
   &          + si(i-1, j+1, k+1, 2) + si(i, j, k, 2) + si(i, j+1, k, 2) + &
   &          si(i, j, k+1, 2) + si(i, j+1, k+1, 2)
   szd = sid(i-1, j, k, 3) + sid(i-1, j+1, k, 3) + sid(i-1, j, k+1&
   &          , 3) + sid(i-1, j+1, k+1, 3) + sid(i, j, k, 3) + sid(i, j+1, k&
   &          , 3) + sid(i, j, k+1, 3) + sid(i, j+1, k+1, 3)
   sz = si(i-1, j, k, 3) + si(i-1, j+1, k, 3) + si(i-1, j, k+1, 3) &
   &          + si(i-1, j+1, k+1, 3) + si(i, j, k, 3) + si(i, j+1, k, 3) + &
   &          si(i, j, k+1, 3) + si(i, j+1, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubard = fourth*(wd(i, j, k, ivx)+wd(i, j+1, k, ivx)+wd(i, j, k+1&
   &          , ivx)+wd(i, j+1, k+1, ivx))
   ubar = fourth*(w(i, j, k, ivx)+w(i, j+1, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i, j+1, k+1, ivx))
   vbard = fourth*(wd(i, j, k, ivy)+wd(i, j+1, k, ivy)+wd(i, j, k+1&
   &          , ivy)+wd(i, j+1, k+1, ivy))
   vbar = fourth*(w(i, j, k, ivy)+w(i, j+1, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i, j+1, k+1, ivy))
   wbard = fourth*(wd(i, j, k, ivz)+wd(i, j+1, k, ivz)+wd(i, j, k+1&
   &          , ivz)+wd(i, j+1, k+1, ivz))
   wbar = fourth*(w(i, j, k, ivz)+w(i, j+1, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i, j+1, k+1, ivz))
   a2d = fourth*(pd(i, j, k)+pd(i, j+1, k)+pd(i, j, k+1)+pd(i, j+1&
   &          , k+1))
   a2 = fourth*(p(i, j, k)+p(i, j+1, k)+p(i, j, k+1)+p(i, j+1, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (i .GT. 1) THEN
   uxd(i-1, j, k1) = uxd(i-1, j, k1) + ubard*sx + ubar*sxd
   ux(i-1, j, k1) = ux(i-1, j, k1) + ubar*sx
   uyd(i-1, j, k1) = uyd(i-1, j, k1) + ubard*sy + ubar*syd
   uy(i-1, j, k1) = uy(i-1, j, k1) + ubar*sy
   uzd(i-1, j, k1) = uzd(i-1, j, k1) + ubard*sz + ubar*szd
   uz(i-1, j, k1) = uz(i-1, j, k1) + ubar*sz
   vxd(i-1, j, k1) = vxd(i-1, j, k1) + vbard*sx + vbar*sxd
   vx(i-1, j, k1) = vx(i-1, j, k1) + vbar*sx
   vyd(i-1, j, k1) = vyd(i-1, j, k1) + vbard*sy + vbar*syd
   vy(i-1, j, k1) = vy(i-1, j, k1) + vbar*sy
   vzd(i-1, j, k1) = vzd(i-1, j, k1) + vbard*sz + vbar*szd
   vz(i-1, j, k1) = vz(i-1, j, k1) + vbar*sz
   wxd(i-1, j, k1) = wxd(i-1, j, k1) + wbard*sx + wbar*sxd
   wx(i-1, j, k1) = wx(i-1, j, k1) + wbar*sx
   wyd(i-1, j, k1) = wyd(i-1, j, k1) + wbard*sy + wbar*syd
   wy(i-1, j, k1) = wy(i-1, j, k1) + wbar*sy
   wzd(i-1, j, k1) = wzd(i-1, j, k1) + wbard*sz + wbar*szd
   wz(i-1, j, k1) = wz(i-1, j, k1) + wbar*sz
   qxd(i-1, j, k1) = qxd(i-1, j, k1) - a2d*sx - a2*sxd
   qx(i-1, j, k1) = qx(i-1, j, k1) - a2*sx
   qyd(i-1, j, k1) = qyd(i-1, j, k1) - a2d*sy - a2*syd
   qy(i-1, j, k1) = qy(i-1, j, k1) - a2*sy
   qzd(i-1, j, k1) = qzd(i-1, j, k1) - a2d*sz - a2*szd
   qz(i-1, j, k1) = qz(i-1, j, k1) - a2*sz
   END IF
   IF (i .LT. ie) THEN
   uxd(i, j, k1) = uxd(i, j, k1) - ubard*sx - ubar*sxd
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uyd(i, j, k1) = uyd(i, j, k1) - ubard*sy - ubar*syd
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uzd(i, j, k1) = uzd(i, j, k1) - ubard*sz - ubar*szd
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vxd(i, j, k1) = vxd(i, j, k1) - vbard*sx - vbar*sxd
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vyd(i, j, k1) = vyd(i, j, k1) - vbard*sy - vbar*syd
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vzd(i, j, k1) = vzd(i, j, k1) - vbard*sz - vbar*szd
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wxd(i, j, k1) = wxd(i, j, k1) - wbard*sx - wbar*sxd
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wyd(i, j, k1) = wyd(i, j, k1) - wbard*sy - wbar*syd
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wzd(i, j, k1) = wzd(i, j, k1) - wbard*sz - wbar*szd
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qxd(i, j, k1) = qxd(i, j, k1) + a2d*sx + a2*sxd
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qyd(i, j, k1) = qyd(i, j, k1) + a2d*sy + a2*syd
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qzd(i, j, k1) = qzd(i, j, k1) + a2d*sz + a2*szd
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   END IF
   END DO
   END DO
   ! Divide by 8 times the volume to obtain the correct gradients.
   DO j=1,jl
   DO i=1,il
   ! Compute the inverse of 8 times the volume for this node.
   oneovervd = -(one*(vold(i, j, k)+vold(i, j, k+1)+vold(i+1, j, k)&
   &          +vold(i+1, j, k+1)+vold(i, j+1, k)+vold(i, j+1, k+1)+vold(i+1&
   &          , j+1, k)+vold(i+1, j+1, k+1))/(vol(i, j, k)+vol(i, j, k+1)+&
   &          vol(i+1, j, k)+vol(i+1, j, k+1)+vol(i, j+1, k)+vol(i, j+1, k+1&
   &          )+vol(i+1, j+1, k)+vol(i+1, j+1, k+1))**2)
   oneoverv = one/(vol(i, j, k)+vol(i, j, k+1)+vol(i+1, j, k)+vol(i&
   &          +1, j, k+1)+vol(i, j+1, k)+vol(i, j+1, k+1)+vol(i+1, j+1, k)+&
   &          vol(i+1, j+1, k+1))
   ! Compute the correct velocity gradients and "unit" heat
   ! fluxes. The velocity gradients are stored in ux, etc.
   uxd(i, j, k1) = uxd(i, j, k1)*oneoverv + ux(i, j, k1)*oneovervd
   ux(i, j, k1) = ux(i, j, k1)*oneoverv
   uyd(i, j, k1) = uyd(i, j, k1)*oneoverv + uy(i, j, k1)*oneovervd
   uy(i, j, k1) = uy(i, j, k1)*oneoverv
   uzd(i, j, k1) = uzd(i, j, k1)*oneoverv + uz(i, j, k1)*oneovervd
   uz(i, j, k1) = uz(i, j, k1)*oneoverv
   vxd(i, j, k1) = vxd(i, j, k1)*oneoverv + vx(i, j, k1)*oneovervd
   vx(i, j, k1) = vx(i, j, k1)*oneoverv
   vyd(i, j, k1) = vyd(i, j, k1)*oneoverv + vy(i, j, k1)*oneovervd
   vy(i, j, k1) = vy(i, j, k1)*oneoverv
   vzd(i, j, k1) = vzd(i, j, k1)*oneoverv + vz(i, j, k1)*oneovervd
   vz(i, j, k1) = vz(i, j, k1)*oneoverv
   wxd(i, j, k1) = wxd(i, j, k1)*oneoverv + wx(i, j, k1)*oneovervd
   wx(i, j, k1) = wx(i, j, k1)*oneoverv
   wyd(i, j, k1) = wyd(i, j, k1)*oneoverv + wy(i, j, k1)*oneovervd
   wy(i, j, k1) = wy(i, j, k1)*oneoverv
   wzd(i, j, k1) = wzd(i, j, k1)*oneoverv + wz(i, j, k1)*oneovervd
   wz(i, j, k1) = wz(i, j, k1)*oneoverv
   qxd(i, j, k1) = qxd(i, j, k1)*oneoverv + qx(i, j, k1)*oneovervd
   qx(i, j, k1) = qx(i, j, k1)*oneoverv
   qyd(i, j, k1) = qyd(i, j, k1)*oneoverv + qy(i, j, k1)*oneovervd
   qy(i, j, k1) = qy(i, j, k1)*oneoverv
   qzd(i, j, k1) = qzd(i, j, k1)*oneoverv + qz(i, j, k1)*oneovervd
   qz(i, j, k1) = qz(i, j, k1)*oneoverv
   END DO
   END DO
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('wx', wx, wxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wy', wy, wyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('wz', wz, wzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qx', qx, qxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qy', qy, qyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('qz', qz, qzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('ux', ux, uxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uy', uy, uyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('uz', uz, uzd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vx', vx, vxd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vy', vy, vyd, il*jl*2)
   CALL DEBUG_TGT_REAL8ARRAY('vz', vz, vzd, il*jl*2)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END SUBROUTINE NODALGRADIENTS_T
   SUBROUTINE NODALGRADIENTS(ux, uy, uz, vx, vy, vz, wx, wy, wz, qx, qy, &
   &    qz)
   IMPLICIT NONE
   !
   !        Subroutine arguments
   !
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: ux, uy, &
   &    uz, vx, vy, vz, wx, wy, wz, qx, qy, qz
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: oneoverv, ubar, vbar, wbar, a2
   REAL(kind=realtype) :: sx, sx1, sy, sy1, sz, sz1
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! First part. Contribution in the k-direction. As the viscous
   ! fluxes are computed per k-plane, the values of the surface
   ! integrals in gauss's theorem are only scattered to one node.
   ! Consequently this part is an initialization as well.
   ! Loop over the j and i direction.
   DO j=1,jl
   DO i=1,il
   ! Store 8 times the average normal for the contribution from
   ! the k-layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sx1 = sk(i, j, k, 1) + sk(i+1, j, k, 1) + sk(i, j+1, k, 1) + sk(&
   &          i+1, j+1, k, 1)
   sy1 = sk(i, j, k, 2) + sk(i+1, j, k, 2) + sk(i, j+1, k, 2) + sk(&
   &          i+1, j+1, k, 2)
   sz1 = sk(i, j, k, 3) + sk(i+1, j, k, 3) + sk(i, j+1, k, 3) + sk(&
   &          i+1, j+1, k, 3)
   sx = sx1 + sk(i, j, k-1, 1) + sk(i+1, j, k-1, 1) + sk(i, j+1, k-&
   &          1, 1) + sk(i+1, j+1, k-1, 1)
   sy = sy1 + sk(i, j, k-1, 2) + sk(i+1, j, k-1, 2) + sk(i, j+1, k-&
   &          1, 2) + sk(i+1, j+1, k-1, 2)
   sz = sz1 + sk(i, j, k-1, 3) + sk(i+1, j, k-1, 3) + sk(i, j+1, k-&
   &          1, 3) + sk(i+1, j+1, k-1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j+1, k, &
   &          ivx)+w(i+1, j+1, k, ivx))
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j+1, k, &
   &          ivy)+w(i+1, j+1, k, ivy))
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j+1, k, &
   &          ivz)+w(i+1, j+1, k, ivz))
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j+1, k)+p(i+1, j+1, k)&
   &          )
   ! Set the velocity and speed of sound square gradients.
   ! The minus sign is there, because these normals are inward
   ! pointing for the nodal k-layer. The exception is a2,
   ! because the gradient of -a2 is stored, as this is needed
   ! in the heat fluxes.
   ux(i, j, k1) = -(ubar*sx)
   uy(i, j, k1) = -(ubar*sy)
   uz(i, j, k1) = -(ubar*sz)
   vx(i, j, k1) = -(vbar*sx)
   vy(i, j, k1) = -(vbar*sy)
   vz(i, j, k1) = -(vbar*sz)
   wx(i, j, k1) = -(wbar*sx)
   wy(i, j, k1) = -(wbar*sy)
   wz(i, j, k1) = -(wbar*sz)
   qx(i, j, k1) = a2*sx
   qy(i, j, k1) = a2*sy
   qz(i, j, k1) = a2*sz
   ! Store 8 times the average normal for the contribution from
   ! the k+1 layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sx = sx1 + sk(i, j, k+1, 1) + sk(i+1, j, k+1, 1) + sk(i, j+1, k+&
   &          1, 1) + sk(i+1, j+1, k+1, 1)
   sy = sy1 + sk(i, j, k+1, 2) + sk(i+1, j, k+1, 2) + sk(i, j+1, k+&
   &          1, 2) + sk(i+1, j+1, k+1, 2)
   sz = sz1 + sk(i, j, k+1, 3) + sk(i+1, j, k+1, 3) + sk(i, j+1, k+&
   &          1, 3) + sk(i+1, j+1, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k+1, ivx)+w(i+1, j, k+1, ivx)+w(i, j+1, k&
   &          +1, ivx)+w(i+1, j+1, k+1, ivx))
   vbar = fourth*(w(i, j, k+1, ivy)+w(i+1, j, k+1, ivy)+w(i, j+1, k&
   &          +1, ivy)+w(i+1, j+1, k+1, ivy))
   wbar = fourth*(w(i, j, k+1, ivz)+w(i+1, j, k+1, ivz)+w(i, j+1, k&
   &          +1, ivz)+w(i+1, j+1, k+1, ivz))
   a2 = fourth*(p(i, j, k+1)+p(i+1, j, k+1)+p(i, j+1, k+1)+p(i+1, j&
   &          +1, k+1))
   ! Update the velocity and (minus) the speed of sound
   ! gradients. As the normals are now outward pointing for
   ! the nodes in the k-layer, there is a plus sign for the
   ! velocity gradients and a minus sign for minus the speed
   ! of sound squared.
   ux(i, j, k1) = ux(i, j, k1) + ubar*sx
   uy(i, j, k1) = uy(i, j, k1) + ubar*sy
   uz(i, j, k1) = uz(i, j, k1) + ubar*sz
   vx(i, j, k1) = vx(i, j, k1) + vbar*sx
   vy(i, j, k1) = vy(i, j, k1) + vbar*sy
   vz(i, j, k1) = vz(i, j, k1) + vbar*sz
   wx(i, j, k1) = wx(i, j, k1) + wbar*sx
   wy(i, j, k1) = wy(i, j, k1) + wbar*sy
   wz(i, j, k1) = wz(i, j, k1) + wbar*sz
   qx(i, j, k1) = qx(i, j, k1) - a2*sx
   qy(i, j, k1) = qy(i, j, k1) - a2*sy
   qz(i, j, k1) = qz(i, j, k1) - a2*sz
   END DO
   END DO
   ! Second part. Contribution in the j-direction.
   ! The contribution is scattered to both the left and right node
   ! in j-direction.
   DO j=1,je
   DO i=1,il
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sx = sj(i, j-1, k, 1) + sj(i+1, j-1, k, 1) + sj(i, j-1, k+1, 1) &
   &          + sj(i+1, j-1, k+1, 1) + sj(i, j, k, 1) + sj(i+1, j, k, 1) + &
   &          sj(i, j, k+1, 1) + sj(i+1, j, k+1, 1)
   sy = sj(i, j-1, k, 2) + sj(i+1, j-1, k, 2) + sj(i, j-1, k+1, 2) &
   &          + sj(i+1, j-1, k+1, 2) + sj(i, j, k, 2) + sj(i+1, j, k, 2) + &
   &          sj(i, j, k+1, 2) + sj(i+1, j, k+1, 2)
   sz = sj(i, j-1, k, 3) + sj(i+1, j-1, k, 3) + sj(i, j-1, k+1, 3) &
   &          + sj(i+1, j-1, k+1, 3) + sj(i, j, k, 3) + sj(i+1, j, k, 3) + &
   &          sj(i, j, k+1, 3) + sj(i+1, j, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i+1, j, k+1, ivx))
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i+1, j, k+1, ivy))
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i+1, j, k+1, ivz))
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j, k+1)+p(i+1, j, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (j .GT. 1) THEN
   ux(i, j-1, k1) = ux(i, j-1, k1) + ubar*sx
   uy(i, j-1, k1) = uy(i, j-1, k1) + ubar*sy
   uz(i, j-1, k1) = uz(i, j-1, k1) + ubar*sz
   vx(i, j-1, k1) = vx(i, j-1, k1) + vbar*sx
   vy(i, j-1, k1) = vy(i, j-1, k1) + vbar*sy
   vz(i, j-1, k1) = vz(i, j-1, k1) + vbar*sz
   wx(i, j-1, k1) = wx(i, j-1, k1) + wbar*sx
   wy(i, j-1, k1) = wy(i, j-1, k1) + wbar*sy
   wz(i, j-1, k1) = wz(i, j-1, k1) + wbar*sz
   qx(i, j-1, k1) = qx(i, j-1, k1) - a2*sx
   qy(i, j-1, k1) = qy(i, j-1, k1) - a2*sy
   qz(i, j-1, k1) = qz(i, j-1, k1) - a2*sz
   END IF
   IF (j .LT. je) THEN
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   END IF
   END DO
   END DO
   ! Third part. Contribution in the i-direction.
   ! The contribution is scattered to both the left and right node
   ! in i-direction.
   DO j=1,jl
   DO i=1,ie
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sx = si(i-1, j, k, 1) + si(i-1, j+1, k, 1) + si(i-1, j, k+1, 1) &
   &          + si(i-1, j+1, k+1, 1) + si(i, j, k, 1) + si(i, j+1, k, 1) + &
   &          si(i, j, k+1, 1) + si(i, j+1, k+1, 1)
   sy = si(i-1, j, k, 2) + si(i-1, j+1, k, 2) + si(i-1, j, k+1, 2) &
   &          + si(i-1, j+1, k+1, 2) + si(i, j, k, 2) + si(i, j+1, k, 2) + &
   &          si(i, j, k+1, 2) + si(i, j+1, k+1, 2)
   sz = si(i-1, j, k, 3) + si(i-1, j+1, k, 3) + si(i-1, j, k+1, 3) &
   &          + si(i-1, j+1, k+1, 3) + si(i, j, k, 3) + si(i, j+1, k, 3) + &
   &          si(i, j, k+1, 3) + si(i, j+1, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i, j+1, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i, j+1, k+1, ivx))
   vbar = fourth*(w(i, j, k, ivy)+w(i, j+1, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i, j+1, k+1, ivy))
   wbar = fourth*(w(i, j, k, ivz)+w(i, j+1, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i, j+1, k+1, ivz))
   a2 = fourth*(p(i, j, k)+p(i, j+1, k)+p(i, j, k+1)+p(i, j+1, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (i .GT. 1) THEN
   ux(i-1, j, k1) = ux(i-1, j, k1) + ubar*sx
   uy(i-1, j, k1) = uy(i-1, j, k1) + ubar*sy
   uz(i-1, j, k1) = uz(i-1, j, k1) + ubar*sz
   vx(i-1, j, k1) = vx(i-1, j, k1) + vbar*sx
   vy(i-1, j, k1) = vy(i-1, j, k1) + vbar*sy
   vz(i-1, j, k1) = vz(i-1, j, k1) + vbar*sz
   wx(i-1, j, k1) = wx(i-1, j, k1) + wbar*sx
   wy(i-1, j, k1) = wy(i-1, j, k1) + wbar*sy
   wz(i-1, j, k1) = wz(i-1, j, k1) + wbar*sz
   qx(i-1, j, k1) = qx(i-1, j, k1) - a2*sx
   qy(i-1, j, k1) = qy(i-1, j, k1) - a2*sy
   qz(i-1, j, k1) = qz(i-1, j, k1) - a2*sz
   END IF
   IF (i .LT. ie) THEN
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   END IF
   END DO
   END DO
   ! Divide by 8 times the volume to obtain the correct gradients.
   DO j=1,jl
   DO i=1,il
   ! Compute the inverse of 8 times the volume for this node.
   oneoverv = one/(vol(i, j, k)+vol(i, j, k+1)+vol(i+1, j, k)+vol(i&
   &          +1, j, k+1)+vol(i, j+1, k)+vol(i, j+1, k+1)+vol(i+1, j+1, k)+&
   &          vol(i+1, j+1, k+1))
   ! Compute the correct velocity gradients and "unit" heat
   ! fluxes. The velocity gradients are stored in ux, etc.
   ux(i, j, k1) = ux(i, j, k1)*oneoverv
   uy(i, j, k1) = uy(i, j, k1)*oneoverv
   uz(i, j, k1) = uz(i, j, k1)*oneoverv
   vx(i, j, k1) = vx(i, j, k1)*oneoverv
   vy(i, j, k1) = vy(i, j, k1)*oneoverv
   vz(i, j, k1) = vz(i, j, k1)*oneoverv
   wx(i, j, k1) = wx(i, j, k1)*oneoverv
   wy(i, j, k1) = wy(i, j, k1)*oneoverv
   wz(i, j, k1) = wz(i, j, k1)*oneoverv
   qx(i, j, k1) = qx(i, j, k1)*oneoverv
   qy(i, j, k1) = qy(i, j, k1)*oneoverv
   qz(i, j, k1) = qz(i, j, k1)*oneoverv
   END DO
   END DO
   END SUBROUTINE NODALGRADIENTS
   END SUBROUTINE VISCOUSFLUX_T

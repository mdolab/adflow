   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of etotarray in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: etot
   !   with respect to varying inputs: k p u v w etot rho (global)rgas
   !      ==================================================================
   SUBROUTINE ETOTARRAY_T(rho, rhod, u, ud, v, vd, w, wd, p, pd, k, kd, &
   &  etot, etotd, correctfork, kk)
   USE CONSTANTS
   USE DIFFSIZES
   !  Hint: ISIZE1OFrho should be the size of dimension 1 of array rho
   !  Hint: ISIZE1OFetot should be the size of dimension 1 of array etot
   !  Hint: ISIZE1OFw should be the size of dimension 1 of array w
   !  Hint: ISIZE1OFv should be the size of dimension 1 of array v
   !  Hint: ISIZE1OFu should be the size of dimension 1 of array u
   !  Hint: ISIZE1OFp should be the size of dimension 1 of array p
   !  Hint: ISIZE1OFk should be the size of dimension 1 of array k
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * EtotArray computes the total energy from the given density,    *
   !      * velocity and presssure for the given kk elements of the arrays.*
   !      * First the internal energy per unit mass is computed and after  *
   !      * that the kinetic energy is added as well the conversion to     *
   !      * energy per unit volume.                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: rho, p, k
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: rhod, pd, kd
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: u, v, w
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: ud, vd, wd
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: etot
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: etotd
   LOGICAL, INTENT(IN) :: correctfork
   INTEGER(kind=inttype), INTENT(IN) :: kk
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('k', k, kd, ISIZE1OFk)
   CALL DEBUG_TGT_REAL8ARRAY('p', p, pd, ISIZE1OFp)
   CALL DEBUG_TGT_REAL8ARRAY('u', u, ud, ISIZE1OFu)
   CALL DEBUG_TGT_REAL8ARRAY('v', v, vd, ISIZE1OFv)
   CALL DEBUG_TGT_REAL8ARRAY('w', w, wd, ISIZE1OFw)
   CALL DEBUG_TGT_REAL8ARRAY('etot', etot, etotd, ISIZE1OFetot)
   CALL DEBUG_TGT_REAL8ARRAY('rho', rho, rhod, ISIZE1OFrho)
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   CALL DEBUG_TGT_CALL('EINTARRAY', .TRUE., .FALSE.)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the internal energy for unit mass.
   CALL EINTARRAY_T(rho, rhod, p, pd, k, kd, etot, etotd, correctfork, kk&
   &            )
   CALL DEBUG_TGT_EXIT()
   ! Add the kinetic energy.
   DO i=1,kk
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('u', u, ud, ISIZE1OFu)
   CALL DEBUG_TGT_REAL8ARRAY('v', v, vd, ISIZE1OFv)
   CALL DEBUG_TGT_REAL8ARRAY('w', w, wd, ISIZE1OFw)
   CALL DEBUG_TGT_REAL8ARRAY('etot', etot, etotd, ISIZE1OFetot)
   CALL DEBUG_TGT_REAL8ARRAY('rho', rho, rhod, ISIZE1OFrho)
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   etotd(i) = rhod(i)*(etot(i)+half*(u(i)*u(i)+v(i)*v(i)+w(i)*w(i))) + &
   &      rho(i)*(etotd(i)+half*(ud(i)*u(i)+u(i)*ud(i)+vd(i)*v(i)+v(i)*vd(i)&
   &      +wd(i)*w(i)+w(i)*wd(i)))
   etot(i) = rho(i)*(etot(i)+half*(u(i)*u(i)+v(i)*v(i)+w(i)*w(i)))
   END DO
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('etot', etot, etotd, ISIZE1OFetot)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END SUBROUTINE ETOTARRAY_T

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of unsteadyturbspectral_block in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: *dw
   !   with respect to varying inputs: *(flowdoms.w)
   !   Plus diff mem management of: flowdoms.w:in dw:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          unsteadyTurbSpectral.f90                        *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 08-22-2004                                      *
   !      * Last modified: 06-28-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE UNSTEADYTURBSPECTRAL_BLOCK_T(ntu1, ntu2, nn, sps)
   USE ITERATION
   USE BLOCKPOINTERS_D
   USE INPUTTIMESPECTRAL
   USE INPUTPHYSICS
   USE DIFFSIZES
   !  Hint: ISIZE4OFDrfflowdoms_w should be the size of dimension 4 of array *flowdoms%w
   !  Hint: ISIZE3OFDrfflowdoms_w should be the size of dimension 3 of array *flowdoms%w
   !  Hint: ISIZE2OFDrfflowdoms_w should be the size of dimension 2 of array *flowdoms%w
   !  Hint: ISIZE1OFDrfflowdoms_w should be the size of dimension 1 of array *flowdoms%w
   !  Hint: ISIZE4OFDrfdw should be the size of dimension 4 of array *dw
   !  Hint: ISIZE3OFDrfdw should be the size of dimension 3 of array *dw
   !  Hint: ISIZE2OFDrfdw should be the size of dimension 2 of array *dw
   !  Hint: ISIZE1OFDrfdw should be the size of dimension 1 of array *dw
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * unsteadyTurbSpectral determines the spectral time derivative   *
   !      * for all owned cells. This routine is called before the actual  *
   !      * solve routines, such that the treatment is identical for all   *
   !      * spectral solutions. The results is stored in the corresponding *
   !      * entry in dw.                                                   *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: ntu1, ntu2, nn, sps
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: ii, mm, i, j, k
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   INTEGER :: ii3
   INTEGER :: ii2
   INTEGER :: ii1
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, ii2, ii1)%&
   &                              w, flowdomsd(ii3, ii2, ii1)%w, &
   &                              ISIZE1OFDrfflowdoms_w*&
   &                              ISIZE2OFDrfflowdoms_w*&
   &                              ISIZE3OFDrfflowdoms_w*&
   &                              ISIZE4OFDrfflowdoms_w)
   END DO
   END DO
   END DO
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   ! Return immediately if not the time spectral equations are to
   ! be solved.
   IF (equationmode .NE. timespectral) THEN
   dwd = 0.0_8
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('dw', dw, dwd, ISIZE1OFDrfdw*&
   &                          ISIZE2OFDrfdw*ISIZE3OFDrfdw*ISIZE4OFDrfdw)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   RETURN
   ELSE
   dwd = 0.0_8
   ! Loop over the number of turbulent transport equations.
   nadvloop:DO ii=ntu1,ntu2
   ! Initialize the time derivative to zero for the owned
   ! cell centers.
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   CALL DEBUG_TGT_REAL8ARRAY('flowdoms', flowdoms(ii3, &
   &                                        ii2, ii1)%w, flowdomsd(ii3, ii2&
   &                                        , ii1)%w, ISIZE1OFDrfflowdoms_w*&
   &                                        ISIZE2OFDrfflowdoms_w*&
   &                                        ISIZE3OFDrfflowdoms_w*&
   &                                        ISIZE4OFDrfflowdoms_w)
   END DO
   END DO
   END DO
   CALL DEBUG_TGT_REAL8ARRAY('dw', dw, dwd, ISIZE1OFDrfdw*&
   &                                  ISIZE2OFDrfdw*ISIZE3OFDrfdw*&
   &                                  ISIZE4OFDrfdw)
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   dwd(i, j, k, ii) = 0.0_8
   dw(i, j, k, ii) = zero
   END DO
   END DO
   END DO
   ! Loop over the number of terms which contribute to the
   ! time derivative.
   DO mm=1,ntimeintervalsspectral
   ! Add the contribution to the time derivative for
   ! all owned cells.
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   dwd(i, j, k, ii) = dwd(i, j, k, ii) + dscalar(sectionid, &
   &                sps, mm)*flowdomsd(nn, currentlevel, mm)%w(i, j, k, ii)
   dw(i, j, k, ii) = dw(i, j, k, ii) + dscalar(sectionid, sps&
   &                , mm)*flowdoms(nn, currentlevel, mm)%w(i, j, k, ii)
   END DO
   END DO
   END DO
   END DO
   END DO nadvloop
   END IF
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('dw', dw, dwd, ISIZE1OFDrfdw*ISIZE2OFDrfdw&
   &                        *ISIZE3OFDrfdw*ISIZE4OFDrfdw)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END SUBROUTINE UNSTEADYTURBSPECTRAL_BLOCK_T

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of derivativerigidrotangle in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: derivativerigidrotangle
   !   with respect to varying inputs: timeref
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          derivativeRigidRotAngle.f90                     *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 06-01-2004                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   FUNCTION DERIVATIVERIGIDROTANGLE_T(degreepolrot, coefpolrot, &
   &  degreefourrot, omegafourrot, coscoeffourrot, sincoeffourrot, t, &
   &  derivativerigidrotangle)
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * derivativeRigidRotAngle computes the time derivative of the    *
   !      * rigid body rotation angle at the given time for the given      *
   !      * arguments. The angle is described by a combination of a        *
   !      * polynomial and fourier series.                                 *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Function type
   !
   REAL(kind=realtype) :: derivativerigidrotangle
   REAL(kind=realtype) :: derivativerigidrotangle_t
   !
   !      Function arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: degreepolrot
   INTEGER(kind=inttype), INTENT(IN) :: degreefourrot
   REAL(kind=realtype), INTENT(IN) :: omegafourrot, t
   REAL(kind=realtype), DIMENSION(0:*), INTENT(IN) :: coefpolrot
   REAL(kind=realtype), DIMENSION(0:*), INTENT(IN) :: coscoeffourrot
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: sincoeffourrot
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn
   REAL(kind=realtype) :: dphi, val
   INTEGER :: pwy1
   REAL(kind=realtype) :: pwr1
   INTRINSIC COS
   INTRINSIC SIN
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8('timeref', timeref, timerefd)
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately if this is a steady computation.
   IF (equationmode .EQ. steady) THEN
   derivativerigidrotangle = zero
   derivativerigidrotangle_t = 0.0_8
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8('derivativerigidrotangle', &
   &                     derivativerigidrotangle, derivativerigidrotangle_t)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   RETURN
   ELSE
   ! Compute the polynomial contribution.
   dphi = zero
   DO nn=1,degreepolrot
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8('timeref', timeref, timerefd)
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   pwy1 = nn - 1
   pwr1 = t**pwy1
   dphi = dphi + nn*coefpolrot(nn)*pwr1
   END DO
   ! Compute the fourier contribution.
   DO nn=1,degreefourrot
   val = nn*omegafourrot
   dphi = dphi - val*coscoeffourrot(nn)*SIN(val*t)
   dphi = dphi + val*sincoeffourrot(nn)*COS(val*t)
   END DO
   ! Set derivativeRigidRotAngle to dPhi. Multiply by timeRef
   ! to obtain the correct non-dimensional value.
   derivativerigidrotangle_t = dphi*timerefd
   derivativerigidrotangle = timeref*dphi
   END IF
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8('derivativerigidrotangle', &
   &                   derivativerigidrotangle, derivativerigidrotangle_t)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END FUNCTION DERIVATIVERIGIDROTANGLE_T

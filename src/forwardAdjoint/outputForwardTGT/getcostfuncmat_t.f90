   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of getcostfuncmat in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: costfuncmat
   !   with respect to varying inputs: pinf pref lengthref surfaceref
   !                machcoef dragdirection liftdirection alpha beta
   SUBROUTINE GETCOSTFUNCMAT_T(alpha, alphad, beta, betad, liftindex)
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE COSTFUNCTIONS
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !     ******************************************************************
   !     *                                                                *
   !     * Compute the cost function vector needed to calculate           *
   !     * dIdw, dIdx and dIda.                                            *
   !     *                                                                *
   !     ******************************************************************
   !
   !Subroutine Vars Input/Ouput
   REAL(kind=realtype), INTENT(IN) :: alpha, beta
   REAL(kind=realtype), INTENT(IN) :: alphad, betad
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   ! Working vars
   REAL(kind=realtype) :: fact, scaledim
   REAL(kind=realtype) :: factd, scaledimd
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8('pinf', pinf, pinfd)
   CALL DEBUG_TGT_REAL8('pref', pref, prefd)
   CALL DEBUG_TGT_REAL8('lengthref', lengthref, lengthrefd)
   CALL DEBUG_TGT_REAL8('surfaceref', surfaceref, surfacerefd)
   CALL DEBUG_TGT_REAL8('machcoef', machcoef, machcoefd)
   CALL DEBUG_TGT_REAL8ARRAY('dragdirection', dragdirection, &
   &                        dragdirectiond, 3)
   CALL DEBUG_TGT_REAL8ARRAY('liftdirection', liftdirection, &
   &                        liftdirectiond, 3)
   CALL DEBUG_TGT_REAL8('alpha', alpha, alphad)
   CALL DEBUG_TGT_REAL8('beta', beta, betad)
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   CALL DEBUG_TGT_CALL('ADJUSTINFLOWANGLE', .TRUE., .FALSE.)
   CALL ADJUSTINFLOWANGLE_T(alpha, alphad, beta, betad, liftindex)
   CALL DEBUG_TGT_EXIT()
   scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
   scaledim = pref/pinf
   factd = -(two*gammainf*lref**2*((pinfd*surfaceref+pinf*surfacerefd)*&
   &    machcoef**2*scaledim+pinf*surfaceref*(2*machcoef*machcoefd*scaledim+&
   &    machcoef**2*scaledimd))/(gammainf*pinf*machcoef**2*surfaceref*lref**&
   &    2*scaledim)**2)
   fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
   costfuncmat = zero
   costfuncmatd = 0.0_8
   ! Just set the ones we know
   costfuncmatd(:, costfunclift) = (/liftdirectiond(1), liftdirectiond(2)&
   &    , liftdirectiond(3), 0.0_8, 0.0_8, 0.0_8/)
   costfuncmat(:, costfunclift) = (/liftdirection(1), liftdirection(2), &
   &    liftdirection(3), zero, zero, zero/)
   costfuncmatd(:, costfuncdrag) = (/dragdirectiond(1), dragdirectiond(2)&
   &    , dragdirectiond(3), 0.0_8, 0.0_8, 0.0_8/)
   costfuncmat(:, costfuncdrag) = (/dragdirection(1), dragdirection(2), &
   &    dragdirection(3), zero, zero, zero/)
   costfuncmatd(:, costfuncliftcoef) = (/liftdirectiond(1)*fact+&
   &    liftdirection(1)*factd, liftdirectiond(2)*fact+liftdirection(2)*&
   &    factd, liftdirectiond(3)*fact+liftdirection(3)*factd, 0.0_8, 0.0_8, &
   &    0.0_8/)
   costfuncmat(:, costfuncliftcoef) = (/liftdirection(1)*fact, &
   &    liftdirection(2)*fact, liftdirection(3)*fact, zero, zero, zero/)
   costfuncmatd(:, costfuncdragcoef) = (/dragdirectiond(1)*fact+&
   &    dragdirection(1)*factd, dragdirectiond(2)*fact+dragdirection(2)*&
   &    factd, dragdirectiond(3)*fact+dragdirection(3)*factd, 0.0_8, 0.0_8, &
   &    0.0_8/)
   costfuncmat(:, costfuncdragcoef) = (/dragdirection(1)*fact, &
   &    dragdirection(2)*fact, dragdirection(3)*fact, zero, zero, zero/)
   costfuncmatd(:, costfuncforcex) = 0.0_8
   costfuncmat(:, costfuncforcex) = (/one, zero, zero, zero, zero, zero/)
   costfuncmatd(:, costfuncforcey) = 0.0_8
   costfuncmat(:, costfuncforcey) = (/zero, one, zero, zero, zero, zero/)
   costfuncmatd(:, costfuncforcez) = 0.0_8
   costfuncmat(:, costfuncforcez) = (/zero, zero, one, zero, zero, zero/)
   costfuncmatd(:, costfuncforcexcoef) = (/factd, 0.0_8, 0.0_8, 0.0_8, &
   &    0.0_8, 0.0_8/)
   costfuncmat(:, costfuncforcexcoef) = (/fact, zero, zero, zero, zero, &
   &    zero/)
   costfuncmatd(:, costfuncforceycoef) = (/0.0_8, factd, 0.0_8, 0.0_8, &
   &    0.0_8, 0.0_8/)
   costfuncmat(:, costfuncforceycoef) = (/zero, fact, zero, zero, zero, &
   &    zero/)
   costfuncmatd(:, costfuncforcezcoef) = (/0.0_8, 0.0_8, factd, 0.0_8, &
   &    0.0_8, 0.0_8/)
   costfuncmat(:, costfuncforcezcoef) = (/zero, zero, fact, zero, zero, &
   &    zero/)
   costfuncmatd(:, costfuncmomx) = 0.0_8
   costfuncmat(:, costfuncmomx) = (/zero, zero, zero, one, zero, zero/)
   costfuncmatd(:, costfuncmomy) = 0.0_8
   costfuncmat(:, costfuncmomy) = (/zero, zero, zero, zero, one, zero/)
   costfuncmatd(:, costfuncmomz) = 0.0_8
   costfuncmat(:, costfuncmomz) = (/zero, zero, zero, zero, zero, one/)
   ! update fact to get the moment
   factd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*lref)**&
   &    2
   fact = fact/(lengthref*lref)
   costfuncmatd(:, costfuncmomxcoef) = (/0.0_8, 0.0_8, 0.0_8, factd, &
   &    0.0_8, 0.0_8/)
   costfuncmat(:, costfuncmomxcoef) = (/zero, zero, zero, fact, zero, &
   &    zero/)
   costfuncmatd(:, costfuncmomycoef) = (/0.0_8, 0.0_8, 0.0_8, 0.0_8, &
   &    factd, 0.0_8/)
   costfuncmat(:, costfuncmomycoef) = (/zero, zero, zero, zero, fact, &
   &    zero/)
   costfuncmatd(:, costfuncmomzcoef) = (/0.0_8, 0.0_8, 0.0_8, 0.0_8, &
   &    0.0_8, factd/)
   costfuncmat(:, costfuncmomzcoef) = (/zero, zero, zero, zero, zero, &
   &    fact/)
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('costfuncmat', costfuncmat, costfuncmatd, &
   &                        6*ncostfunction)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END SUBROUTINE GETCOSTFUNCMAT_T

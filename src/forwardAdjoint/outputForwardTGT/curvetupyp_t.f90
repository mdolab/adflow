   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
   !
   !  Differentiation of curvetupyp in forward (tangent) mode (with options debugTangent i4 dr8 r8):
   !   variations   of useful results: tup
   !   with respect to varying inputs: tup yp
   !
   !      ==================================================================
   !
   SUBROUTINE CURVETUPYP_T(tup, tupd, yp, ypd, ntu1, ntu2)
   USE CONSTANTS
   USE PARAMTURB
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * CurveTupYp determines the value of the turbulent variables     *
   !      * ntu1 to ntu2 for the given yplus.                              *
   !      * This data has been curve fitted with cubic splines.            *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: ntu1, ntu2
   REAL(kind=realtype), INTENT(IN) :: yp
   REAL(kind=realtype), INTENT(IN) :: ypd
   REAL(kind=realtype), DIMENSION(ntu1:ntu2), INTENT(OUT) :: tup
   REAL(kind=realtype), DIMENSION(ntu1:ntu2), INTENT(OUT) :: tupd
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: ii, nn, start, mm
   REAL(kind=realtype) :: x, x2, x3, epswall, fwall
   REAL(kind=realtype) :: xd, x2d, x3d
   INTRINSIC EXP
   REAL(kind=realtype) :: max2d
   INTRINSIC MAX
   EXTERNAL DEBUG_TGT_HERE
   LOGICAL :: DEBUG_TGT_HERE
   REAL(kind=realtype) :: max1d
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: max1
   IF (.TRUE. .AND. DEBUG_TGT_HERE('entry', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('tup', tup, tupd, ntu2 - ntu1 + 1)
   CALL DEBUG_TGT_REAL8('yp', yp, ypd)
   CALL DEBUG_TGT_DISPLAY('entry')
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the situation we are dealing with.
   IF (yp .LE. ypt(0)) THEN
   ! Yplus is less than the smallest number in the curve
   ! fit. The treatment is turbulence model dependent.
   SELECT CASE  (turbmodel) 
   CASE (spalartallmaras, spalartallmarasedwards) 
   ! Transport variable is zero on the wall. Use linear
   ! interpolation.
   xd = ypd/ypt(0)
   x = yp/ypt(0)
   DO mm=ntu1,ntu2
   tupd(mm) = tup0(1, mm)*xd
   tup(mm) = x*tup0(1, mm)
   END DO
   CASE (komegawilcox, komegamodified, mentersst) 
   !=============================================================
   ! Use the near wall expressions for k and omega.
   xd = ypd/ypt(0)
   x = yp/ypt(0)
   DO mm=ntu1,ntu2
   SELECT CASE  (mm) 
   CASE (itu1) 
   IF (tulogfit(mm)) THEN
   tupd(mm) = EXP(tup0(1, mm))*3.23_realType*x**2.23*xd
   tup(mm) = EXP(tup0(1, mm))*x**3.23_realType
   ELSE
   tupd(mm) = tup0(1, mm)*3.23_realType*x**2.23*xd
   tup(mm) = tup0(1, mm)*x**3.23_realType
   END IF
   CASE (itu2) 
   IF (tulogfit(mm)) THEN
   IF (x .LT. eps) THEN
   max1 = eps
   max1d = 0.0_8
   ELSE
   max1d = xd
   max1 = x
   END IF
   tupd(mm) = -(EXP(tup0(1, mm))*2*max1*max1d/(max1**2)**2)
   tup(mm) = EXP(tup0(1, mm))/max1**2
   ELSE
   IF (x .LT. eps) THEN
   max2 = eps
   max2d = 0.0_8
   ELSE
   max2d = xd
   max2 = x
   END IF
   tupd(mm) = -(tup0(1, mm)*2*max2*max2d/(max2**2)**2)
   tup(mm) = tup0(1, mm)/max2**2
   END IF
   END SELECT
   END DO
   CASE (ktau) 
   !=============================================================
   ! Use the near wall expressions for k and tau.
   xd = ypd/ypt(0)
   x = yp/ypt(0)
   DO mm=ntu1,ntu2
   SELECT CASE  (mm) 
   CASE (itu1) 
   IF (tulogfit(mm)) THEN
   tupd(mm) = EXP(tup0(1, mm))*3.23_realType*x**2.23*xd
   tup(mm) = EXP(tup0(1, mm))*x**3.23_realType
   ELSE
   tupd(mm) = tup0(1, mm)*3.23_realType*x**2.23*xd
   tup(mm) = tup0(1, mm)*x**3.23_realType
   END IF
   CASE (itu2) 
   IF (tulogfit(mm)) THEN
   tupd(mm) = EXP(tup0(1, mm))*(xd*x+x*xd)
   tup(mm) = EXP(tup0(1, mm))*x*x
   ELSE
   tupd(mm) = tup0(1, mm)*(xd*x+x*xd)
   tup(mm) = tup0(1, mm)*x*x
   END IF
   END SELECT
   END DO
   CASE (v2f) 
   !=============================================================
   ! Use the near wall expressions for k, epsilon, v2 and f.
   xd = ypd/ypt(0)
   x = yp/ypt(0)
   DO mm=ntu1,ntu2
   SELECT CASE  (mm) 
   CASE (itu1) 
   IF (tulogfit(mm)) THEN
   tupd(mm) = EXP(tup0(1, mm))*2*x*xd
   tup(mm) = EXP(tup0(1, mm))*x**2
   ELSE
   tupd(mm) = tup0(1, mm)*2*x*xd
   tup(mm) = tup0(1, mm)*x**2
   END IF
   CASE (itu2) 
   ! epsilon cannot be fitted logarithmically.
   IF (tulogfit(mm)) THEN
   IF (.TRUE. .AND. DEBUG_TGT_HERE('middle', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('tup', tup, tupd, ntu2 - ntu1 + &
   &                                  1)
   CALL DEBUG_TGT_REAL8('x', x, xd)
   CALL DEBUG_TGT_DISPLAY('middle')
   END IF
   CALL TERMINATE('curveTupYp', &
   &                     'Check curveFit, epsilon cannot be fitted with log'&
   &                       )
   ELSE
   IF (rvfn .EQ. 1) epswall = 0.33_realType
   IF (rvfn .EQ. 6) epswall = 0.27_realType
   tupd(mm) = (tup0(1, mm)-epswall)*xd
   tup(mm) = epswall + (tup0(1, mm)-epswall)*x
   END IF
   CASE (itu3) 
   IF (tulogfit(mm)) THEN
   tupd(mm) = EXP(tup0(1, mm))*4*x**3*xd
   tup(mm) = EXP(tup0(1, mm))*x**4
   ELSE
   tupd(mm) = tup0(1, mm)*4*x**3*xd
   tup(mm) = tup0(1, mm)*x**4
   END IF
   CASE (itu4) 
   IF (tulogfit(mm)) THEN
   IF (rvfn .EQ. 1) CALL TERMINATE('curveTupYp', &
   &                           'Check curveFit, f cannot be fitted with log'&
   &                                        )
   IF (rvfn .EQ. 6) THEN
   tupd(mm) = tupd(mm)*EXP(tup(mm))*x + EXP(tup(mm))*xd
   tup(mm) = EXP(tup(mm))*x
   END IF
   ELSE
   IF (rvfn .EQ. 1) fwall = -0.0035_realType
   IF (rvfn .EQ. 6) fwall = zero
   tupd(mm) = (tup0(1, mm)-fwall)*xd
   tup(mm) = fwall + (tup0(1, mm)-fwall)*x
   END IF
   CASE (itu5) 
   IF (tulogfit(mm)) THEN
   tupd(mm) = tupd(mm)*EXP(tup(mm))*x**4 + EXP(tup(mm))*4*x**3*&
   &              xd
   tup(mm) = EXP(tup(mm))*x**4
   ELSE
   tupd(mm) = tup0(1, mm)*4*x**3*xd
   tup(mm) = tup0(1, mm)*x**4
   END IF
   END SELECT
   END DO
   END SELECT
   ELSE IF (yp .GE. ypt(nfit)) THEN
   !=================================================================
   ! Yplus is larger than the largest number in the curve
   ! fit. Set tup to the largest value available.
   nn = nfit
   x = ypt(nn) - ypt(nn-1)
   x2 = x*x
   x3 = x*x2
   DO mm=ntu1,ntu2
   tupd(mm) = 0.0_8
   tup(mm) = tup0(nn, mm) + tup1(nn, mm)*x + tup2(nn, mm)*x2 + tup3(&
   &        nn, mm)*x3
   IF (tulogfit(mm)) THEN
   tupd(mm) = tupd(mm)*EXP(tup(mm))
   tup(mm) = EXP(tup(mm))
   END IF
   END DO
   ELSE
   !=================================================================
   ! y-plus is in the range of the curve fits.
   ! First find the correct interval.
   ii = nfit
   start = 1
   interval:DO 
   ! Next guess for the interval.
   nn = start + ii/2
   ! Determine the situation we are having here.
   IF (yp .GT. ypt(nn)) THEN
   ! Yplus is larger than the upper boundary of
   ! the current interval. Update the lower boundary.
   start = nn + 1
   ii = ii - 1
   ELSE IF (yp .GE. ypt(nn-1)) THEN
   GOTO 100
   END IF
   ! This is the correct range. Exit the do-loop.
   ! Modify ii for the next branch to search.
   ii = ii/2
   END DO interval
   ! Compute tup using the cubic polynomial for this interval.
   100 xd = ypd
   x = yp - ypt(nn-1)
   x2d = xd*x + x*xd
   x2 = x*x
   x3d = xd*x2 + x*x2d
   x3 = x*x2
   DO mm=ntu1,ntu2
   tupd(mm) = tup1(nn, mm)*xd + tup2(nn, mm)*x2d + tup3(nn, mm)*x3d
   tup(mm) = tup0(nn, mm) + tup1(nn, mm)*x + tup2(nn, mm)*x2 + tup3(&
   &        nn, mm)*x3
   IF (tulogfit(mm)) THEN
   tupd(mm) = tupd(mm)*EXP(tup(mm))
   tup(mm) = EXP(tup(mm))
   END IF
   END DO
   END IF
   IF (.TRUE. .AND. DEBUG_TGT_HERE('exit', .FALSE.)) THEN
   CALL DEBUG_TGT_REAL8ARRAY('tup', tup, tupd, ntu2 - ntu1 + 1)
   CALL DEBUG_TGT_DISPLAY('exit')
   END IF
   END SUBROUTINE CURVETUPYP_T

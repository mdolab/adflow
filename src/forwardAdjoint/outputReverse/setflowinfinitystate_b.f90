   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of setflowinfinitystate in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: veldirfreestream machcoef gammainf
   !                pinf rhoinf tref winf pinfcorr rgas
   !   with respect to varying inputs: veldirfreestream machcoef gammainf
   !                pinf rhoinf tref muinf uinf rgas
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          setFlowInfinityState.f90                        *
   !      * Author:        Edwin van der Weide, Georgi Kalitzin            *
   !      * Starting date: 02-21-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE SETFLOWINFINITYSTATE_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * setFlowInfinityState sets the free stream state vector of      *
   !      * the flow variables. If nothing is specified for each of the    *
   !      * farfield boundaries, these values will be taken to define the  *
   !      * free stream.                                                   *
   !      *                                                                *
   !      ******************************************************************
   !
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE PARAMTURB
   IMPLICIT NONE
   !
   !      Local variables
   !
   INTEGER(kind=inttype) :: ierr
   REAL(kind=realtype) :: nuinf, ktmp, uinf2
   REAL(kind=realtype) :: nuinfd, ktmpd, uinf2d
   !
   !      Function definition
   !
   REAL(kind=realtype) :: SANUKNOWNEDDYRATIO
   ! Dummy parameters
   REAL(kind=realtype) :: vinf, zinf
   REAL(kind=realtype) :: vinfd, zinfd
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   INTEGER :: branch
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tmpd2
   REAL(kind=realtype) :: tmpd1
   REAL(kind=realtype) :: tmpd0
   REAL(kind=realtype) :: temp
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the velocity squared based on MachCoef;
   ! needed for the initialization of the turbulent energy,
   ! especially for moving geometries.
   uinf2 = machcoef*machcoef*gammainf*pinf/rhoinf
   ! Allocate the memory for wInf.
   ! zero out the winf first
   winf(:) = zero
   ! Set the reference value of the flow variables, except the total
   ! energy. This will be computed at the end of this routine.
   winf(irho) = rhoinf
   winf(ivx) = uinf*veldirfreestream(1)
   winf(ivy) = uinf*veldirfreestream(2)
   winf(ivz) = uinf*veldirfreestream(3)
   ! Set the turbulent variables if transport variables are
   ! to be solved.
   IF (equations .EQ. ransequations) THEN
   nuinf = muinf/rhoinf
   SELECT CASE  (turbmodel) 
   CASE (spalartallmaras, spalartallmarasedwards) 
   winf(itu1) = SANUKNOWNEDDYRATIO(eddyvisinfratio, nuinf)
   CALL PUSHCONTROL3B(1)
   CASE (komegawilcox, komegamodified, mentersst) 
   !   wInf(itu1) = 1.341946*nuInf   ! eddyVis = 0.009*lamVis
   !=============================================================
   winf(itu1) = 1.5_realType*uinf2*turbintensityinf**2
   tmp = winf(itu1)/(eddyvisinfratio*nuinf)
   CALL PUSHREAL8(winf(itu2))
   winf(itu2) = tmp
   CALL PUSHCONTROL3B(2)
   CASE (ktau) 
   !=============================================================
   winf(itu1) = 1.5_realType*uinf2*turbintensityinf**2
   tmp0 = eddyvisinfratio*nuinf/winf(itu1)
   CALL PUSHREAL8(winf(itu2))
   winf(itu2) = tmp0
   CALL PUSHCONTROL3B(3)
   CASE (v2f) 
   !=============================================================
   winf(itu1) = 1.5_realType*uinf2*turbintensityinf**2
   tmp1 = 0.09_realType*winf(itu1)**2/(eddyvisinfratio*nuinf)
   CALL PUSHREAL8(winf(itu2))
   winf(itu2) = tmp1
   tmp2 = 0.666666_realType*winf(itu1)
   CALL PUSHREAL8(winf(itu3))
   winf(itu3) = tmp2
   CALL PUSHREAL8(winf(itu4))
   winf(itu4) = 0.0_realType
   CALL PUSHCONTROL3B(4)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ELSE
   CALL PUSHCONTROL3B(5)
   END IF
   ! Set the value of pInfCorr. In case a k-equation is present
   ! add 2/3 times rho*k.
   pinfcorr = pinf
   IF (kpresent) THEN
   pinfcorr = pinf + two*third*rhoinf*winf(itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the free stream total energy.
   ktmp = zero
   IF (kpresent) THEN
   ktmp = winf(itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   vinf = zero
   zinf = zero
   CALL ETOTARRAY_B(rhoinf, rhoinfd, uinf, uinfd, vinf, vinfd, zinf, &
   &            zinfd, pinfcorr, pinfcorrd, ktmp, ktmpd, winf(irhoe), winfd&
   &            (irhoe), kpresent, 1)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) winfd(itu1) = winfd(itu1) + ktmpd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tempd3 = two*third*pinfcorrd
   pinfd = pinfd + pinfcorrd
   rhoinfd = rhoinfd + winf(itu1)*tempd3
   winfd(itu1) = winfd(itu1) + rhoinf*tempd3
   pinfcorrd = 0.0_8
   END IF
   pinfd = pinfd + pinfcorrd
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .EQ. 0) THEN
   uinf2d = 0.0_8
   nuinfd = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   CALL SANUKNOWNEDDYRATIO_B(eddyvisinfratio, nuinf, nuinfd, winfd(&
   &                         itu1))
   winfd(itu1) = 0.0_8
   uinf2d = 0.0_8
   ELSE
   CALL POPREAL8(winf(itu2))
   tmpd = winfd(itu2)
   winfd(itu2) = 0.0_8
   tempd0 = tmpd/(eddyvisinfratio*nuinf)
   winfd(itu1) = winfd(itu1) + tempd0
   nuinfd = -(winf(itu1)*tempd0/nuinf)
   uinf2d = turbintensityinf**2*1.5_realType*winfd(itu1)
   winfd(itu1) = 0.0_8
   END IF
   ELSE IF (branch .EQ. 3) THEN
   CALL POPREAL8(winf(itu2))
   tmpd0 = winfd(itu2)
   winfd(itu2) = 0.0_8
   tempd1 = eddyvisinfratio*tmpd0/winf(itu1)
   nuinfd = tempd1
   winfd(itu1) = winfd(itu1) - nuinf*tempd1/winf(itu1)
   uinf2d = turbintensityinf**2*1.5_realType*winfd(itu1)
   winfd(itu1) = 0.0_8
   ELSE IF (branch .EQ. 4) THEN
   CALL POPREAL8(winf(itu4))
   winfd(itu4) = 0.0_8
   CALL POPREAL8(winf(itu3))
   tmpd1 = winfd(itu3)
   winfd(itu3) = 0.0_8
   winfd(itu1) = winfd(itu1) + 0.666666_realType*tmpd1
   CALL POPREAL8(winf(itu2))
   tmpd2 = winfd(itu2)
   winfd(itu2) = 0.0_8
   tempd2 = 0.09_realType*tmpd2/(eddyvisinfratio*nuinf)
   winfd(itu1) = winfd(itu1) + 2*winf(itu1)*tempd2
   nuinfd = -(winf(itu1)**2*tempd2/nuinf)
   uinf2d = turbintensityinf**2*1.5_realType*winfd(itu1)
   winfd(itu1) = 0.0_8
   ELSE
   muinfd = 0.0_8
   uinf2d = 0.0_8
   GOTO 100
   END IF
   muinfd = nuinfd/rhoinf
   rhoinfd = rhoinfd - muinf*nuinfd/rhoinf**2
   100 temp = machcoef**2/rhoinf
   tempd = gammainf*pinf*uinf2d/rhoinf
   uinfd = uinfd + veldirfreestream(3)*winfd(ivz)
   veldirfreestreamd(3) = veldirfreestreamd(3) + uinf*winfd(ivz)
   winfd(ivz) = 0.0_8
   uinfd = uinfd + veldirfreestream(2)*winfd(ivy)
   veldirfreestreamd(2) = veldirfreestreamd(2) + uinf*winfd(ivy)
   winfd(ivy) = 0.0_8
   uinfd = uinfd + veldirfreestream(1)*winfd(ivx)
   veldirfreestreamd(1) = veldirfreestreamd(1) + uinf*winfd(ivx)
   winfd(ivx) = 0.0_8
   rhoinfd = rhoinfd + winfd(irho) - temp*tempd
   machcoefd = machcoefd + 2*machcoef*tempd
   gammainfd = gammainfd + temp*pinf*uinf2d
   pinfd = pinfd + temp*gammainf*uinf2d
   END SUBROUTINE SETFLOWINFINITYSTATE_B

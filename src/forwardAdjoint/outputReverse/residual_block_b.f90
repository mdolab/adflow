!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
!
!  Differentiation of residual_block in reverse (adjoint) mode:
!   gradient     of useful results: *dw *w *x
!   with respect to varying inputs: *rev *p *sfacei *sfacej *sfacek
!                *dw *w *rlv *x *vol *si *sj *sk *(*bcdata.norm)
!                *radi *radj *radk vis4 kappacoef vis2 vis2coarse
!                sigma *cdisrk
!   Plus diff mem management of: rev:in p:in sfacei:in sfacej:in
!                gamma:in sfacek:in dw:in w:in rlv:in x:in vol:in
!                d2wall:in si:in sj:in sk:in fw:in rotmatrixi:in
!                rotmatrixj:in rotmatrixk:in viscsubface:in *viscsubface.tau:in
!                *viscsubface.q:in *viscsubface.utau:in bcdata:in
!                *bcdata.norm:in radi:in radj:in radk:in cgnsdoms:in
!
!      ******************************************************************
!      *                                                                *
!      * File:          residual.f90                                    *
!      * Author:        Edwin van der Weide, Steve Repsher (blanking)   *
!      * Starting date: 03-15-2003                                      *
!      * Last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE RESIDUAL_BLOCK_B()
  USE INPUTITERATION
  USE CGNSGRID
  USE BLOCKPOINTERS_B
  USE INPUTTIMESPECTRAL
  USE INPUTDISCRETIZATION
  USE ITERATION
  USE FLOWVARREFSTATE
  USE DIFFSIZES
  !  Hint: ISIZE4OFDrfw should be the size of dimension 4 of array *w
  !  Hint: ISIZE3OFDrfw should be the size of dimension 3 of array *w
  !  Hint: ISIZE2OFDrfw should be the size of dimension 2 of array *w
  !  Hint: ISIZE1OFDrfw should be the size of dimension 1 of array *w
  !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
  IMPLICIT NONE
  !
  !      ******************************************************************
  !      *                                                                *
  !      * residual computes the residual of the mean flow equations on   *
  !      * the current MG level.                                          *
  !      *                                                                *
  !      ******************************************************************
  !
  !
  !      Local variables.
  !
  INTEGER(kind=inttype) :: sps, nn, discr
  INTEGER(kind=inttype) :: i, j, k, l
  LOGICAL :: finegrid
  REAL(realtype) :: result1
  INTEGER :: branch
  INTRINSIC REAL
  INTEGER :: ii1
  !
  !      ******************************************************************
  !      *                                                                *
  !      * Begin execution                                                *
  !      *                                                                *
  !      ******************************************************************
  !
  ! Add the source terms from the level 0 cooling model.
  ! Set the value of rFil, which controls the fraction of the old
  ! dissipation residual to be used. This is only for the runge-kutta
  ! schemes; for other smoothers rFil is simply set to 1.0.
  ! Note the index rkStage+1 for cdisRK. The reason is that the
  ! residual computation is performed before rkStage is incremented.
  IF (smoother .EQ. rungekutta) THEN
     rfil = cdisrk(rkstage+1)
  ELSE
     rfil = one
  END IF
  ! Initialize the local arrays to monitor the massflows to zero.
  ! Set the value of the discretization, depending on the grid level,
  ! and the logical fineGrid, which indicates whether or not this
  ! is the finest grid level of the current mg cycle.
  discr = spacediscrcoarse
  IF (currentlevel .EQ. 1) discr = spacediscr
  finegrid = .false.
  IF (currentlevel .EQ. groundlevel) finegrid = .true.
  ! Compute the artificial dissipation fluxes.
  ! This depends on the parameter discr.
  SELECT CASE  (discr) 
  CASE (dissscalar) 
     ! Standard scalar dissipation scheme.
     IF (finegrid) THEN
        CALL PUSHREAL8ARRAY(w, ISIZE1OFDrfw*ISIZE2OFDrfw*ISIZE3OFDrfw*&
             &                    ISIZE4OFDrfw)
        CALL INVISCIDDISSFLUXSCALAR()
        CALL PUSHCONTROL3B(1)
     ELSE
        CALL PUSHREAL8ARRAY(w, ISIZE1OFDrfw*ISIZE2OFDrfw*ISIZE3OFDrfw*&
             &                    ISIZE4OFDrfw)
        CALL INVISCIDDISSFLUXSCALARCOARSE()
        CALL PUSHCONTROL3B(2)
     END IF
  CASE (dissmatrix) 
     !===========================================================
     ! Matrix dissipation scheme.
     IF (finegrid) THEN
        CALL INVISCIDDISSFLUXMATRIX()
        CALL PUSHCONTROL3B(3)
     ELSE
        CALL INVISCIDDISSFLUXMATRIXCOARSE()
        CALL PUSHCONTROL3B(4)
     END IF
  CASE (disscusp) 
     CALL PUSHCONTROL3B(5)
  CASE (upwind) 
     !===========================================================
     ! Dissipation via an upwind scheme.
     CALL INVISCIDUPWINDFLUX(finegrid)
     CALL PUSHCONTROL3B(6)
  CASE DEFAULT
     CALL PUSHCONTROL3B(0)
  END SELECT
  ! Compute the viscous flux in case of a viscous computation.
  IF (viscous) THEN
     CALL PUSHCONTROL1B(1)
  ELSE
     CALL PUSHCONTROL1B(0)
  END IF
  ! Add the dissipative and possibly viscous fluxes to the
  ! Euler fluxes. Loop over the owned cells and add fw to dw.
  ! Also multiply by iblank so that no updates occur in holes
  ! or on the overset boundary.
  DO l=1,nwf
     DO k=2,kl
        DO j=2,jl
           DO i=2,il
              CALL PUSHREAL8(result1)
              result1 = REAL(iblank(i, j, k), realtype)
           END DO
        END DO
     END DO
  END DO
  fwb = 0.0_8
  DO l=nwf,1,-1
     DO k=kl,2,-1
        DO j=jl,2,-1
           DO i=il,2,-1
              fwb(i, j, k, l) = fwb(i, j, k, l) + result1*dwb(i, j, k, l)
              dwb(i, j, k, l) = result1*dwb(i, j, k, l)
              CALL POPREAL8(result1)
           END DO
        END DO
     END DO
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
     revb = 0.0_8
     pb = 0.0_8
     rlvb = 0.0_8
     volb = 0.0_8
     sib = 0.0_8
     sjb = 0.0_8
     skb = 0.0_8
     DO ii1=1,ISIZE1OFDrfbcdata
        bcdatab(ii1)%norm = 0.0_8
     END DO
  ELSE
     CALL VISCOUSFLUX_B()
  END IF
  CALL POPCONTROL3B(branch)
  IF (branch .LT. 3) THEN
     IF (branch .EQ. 0) THEN
        sfaceib = 0.0_8
        sfacejb = 0.0_8
        sfacekb = 0.0_8
        radib = 0.0_8
        radjb = 0.0_8
        radkb = 0.0_8
     ELSE
        IF (branch .EQ. 1) THEN
           CALL POPREAL8ARRAY(w, ISIZE1OFDrfw*ISIZE2OFDrfw*ISIZE3OFDrfw*&
                &                     ISIZE4OFDrfw)
           CALL INVISCIDDISSFLUXSCALAR_B()
        ELSE
           CALL POPREAL8ARRAY(w, ISIZE1OFDrfw*ISIZE2OFDrfw*ISIZE3OFDrfw*&
                &                     ISIZE4OFDrfw)
           CALL INVISCIDDISSFLUXSCALARCOARSE_B()
        END IF
        sfaceib = 0.0_8
        sfacejb = 0.0_8
        sfacekb = 0.0_8
     END IF
  ELSE IF (branch .LT. 5) THEN
     IF (branch .EQ. 3) THEN
        CALL INVISCIDDISSFLUXMATRIX_B()
     ELSE
        CALL INVISCIDDISSFLUXMATRIXCOARSE_B()
     END IF
     radib = 0.0_8
     radjb = 0.0_8
     radkb = 0.0_8
  ELSE IF (branch .EQ. 5) THEN
     sfaceib = 0.0_8
     sfacejb = 0.0_8
     sfacekb = 0.0_8
     radib = 0.0_8
     radjb = 0.0_8
     radkb = 0.0_8
  ELSE
     CALL INVISCIDUPWINDFLUX_B(finegrid)
     radib = 0.0_8
     radjb = 0.0_8
     radkb = 0.0_8
  END IF
  CALL INVISCIDCENTRALFLUX_B()
  vis4b = 0.0_8
  kappacoefb = 0.0_8
  vis2b = 0.0_8
  vis2coarseb = 0.0_8
  sigmab = 0.0_8
  cdisrkb = 0.0_8
END SUBROUTINE RESIDUAL_BLOCK_B

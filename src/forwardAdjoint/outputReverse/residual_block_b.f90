   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of residual_block in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *dw *w
   !   with respect to varying inputs: *rev *p *gamma *dw *w *rlv
   !                *radi *radj *radk
   !   Plus diff mem management of: rev:in p:in gamma:in dw:in w:in
   !                rlv:in fw:in viscsubface:in *viscsubface.tau:in
   !                radi:in radj:in radk:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          residual.f90                                    *
   !      * Author:        Edwin van der Weide, Steve Repsher (blanking)   *
   !      * Starting date: 03-15-2003                                      *
   !      * Last modified: 10-29-2007                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE RESIDUAL_BLOCK_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * residual computes the residual of the mean flow equations on   *
   !      * the current MG level.                                          *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE CGNSGRID
   USE FLOWVARREFSTATE
   USE INPUTITERATION
   USE INPUTDISCRETIZATION
   USE INPUTTIMESPECTRAL
   USE ITERATION
   IMPLICIT NONE
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: sps, nn, discr
   INTEGER(kind=inttype) :: i, j, k, l
   LOGICAL :: finegrid
   INTRINSIC REAL
   INTEGER :: branch
   REAL(kind=realtype) :: tempb
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Add the source terms from the level 0 cooling model.
   ! Set the value of rFil, which controls the fraction of the old
   ! dissipation residual to be used. This is only for the runge-kutta
   ! schemes; for other smoothers rFil is simply set to 1.0.
   ! Note the index rkStage+1 for cdisRK. The reason is that the
   ! residual computation is performed before rkStage is incremented.
   IF (smoother .EQ. rungekutta) THEN
   rfil = cdisrk(rkstage+1)
   ELSE
   rfil = one
   END IF
   ! Initialize the local arrays to monitor the massflows to zero.
   ! Set the value of the discretization, depending on the grid level,
   ! and the logical fineGrid, which indicates whether or not this
   ! is the finest grid level of the current mg cycle.
   discr = spacediscrcoarse
   IF (currentlevel .EQ. 1) discr = spacediscr
   finegrid = .false.
   IF (currentlevel .EQ. groundlevel) finegrid = .true.
   ! Compute the artificial dissipation fluxes.
   ! This depends on the parameter discr.
   SELECT CASE  (discr) 
   CASE (dissscalar) 
   ! Standard scalar dissipation scheme.
   IF (finegrid) THEN
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4)&
   &                  )
   CALL INVISCIDDISSFLUXSCALAR()
   CALL PUSHCONTROL3B(1)
   ELSE
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4)&
   &                  )
   CALL INVISCIDDISSFLUXSCALARCOARSE()
   CALL PUSHCONTROL3B(2)
   END IF
   CASE (dissmatrix) 
   !===========================================================
   ! Matrix dissipation scheme.
   IF (finegrid) THEN
   CALL INVISCIDDISSFLUXMATRIX()
   CALL PUSHCONTROL3B(3)
   ELSE
   CALL INVISCIDDISSFLUXMATRIXCOARSE()
   CALL PUSHCONTROL3B(4)
   END IF
   CASE (disscusp) 
   CALL PUSHCONTROL3B(5)
   CASE (upwind) 
   !===========================================================
   ! Dissipation via an upwind scheme.
   CALL INVISCIDUPWINDFLUX(finegrid)
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ! Compute the viscous flux in case of a viscous computation.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   fwb = 0.0_8
   DO l=nwf,1,-1
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   tempb = REAL(iblank(i, j, k), realtype)*dwb(i, j, k, l)
   fwb(i, j, k, l) = fwb(i, j, k, l) + tempb
   dwb(i, j, k, l) = tempb
   END DO
   END DO
   END DO
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   revb = 0.0_8
   pb = 0.0_8
   gammab = 0.0_8
   rlvb = 0.0_8
   ELSE
   CALL VISCOUSFLUX_B()
   END IF
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .EQ. 0) THEN
   radib = 0.0_8
   radjb = 0.0_8
   radkb = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL INVISCIDDISSFLUXSCALAR_B()
   ELSE
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL INVISCIDDISSFLUXSCALARCOARSE_B()
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL INVISCIDDISSFLUXMATRIX_B()
   ELSE
   CALL INVISCIDDISSFLUXMATRIXCOARSE_B()
   END IF
   radib = 0.0_8
   radjb = 0.0_8
   radkb = 0.0_8
   ELSE IF (branch .EQ. 5) THEN
   radib = 0.0_8
   radjb = 0.0_8
   radkb = 0.0_8
   ELSE
   CALL INVISCIDUPWINDFLUX_B(finegrid)
   radib = 0.0_8
   radjb = 0.0_8
   radkb = 0.0_8
   END IF
   CALL INVISCIDCENTRALFLUX_B()
   END SUBROUTINE RESIDUAL_BLOCK_B

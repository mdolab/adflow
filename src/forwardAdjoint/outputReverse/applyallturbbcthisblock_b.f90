   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of applyallturbbcthisblock in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *w
   !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *w *bvtk1
   !                *bvtk2 *bvti1 *bvti2
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
   !                bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
   !      ==================================================================
   SUBROUTINE APPLYALLTURBBCTHISBLOCK_B(secondhalo)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * applyAllTurbBCThisBlock sets the halo values of the            *
   !      * turbulent variables and eddy viscosity for the block the       *
   !      * variables in blockPointers currently point to.                 *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: secondhalo
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j, l, m
   REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: bmt
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: bvt, ww1, ww2
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: ad_from5
   INTEGER :: ad_to5
   INTEGER :: ad_from6
   INTEGER :: ad_to6
   INTEGER :: ad_from7
   INTEGER :: ad_to7
   INTEGER :: ad_from8
   INTEGER :: ad_to8
   INTEGER :: ad_from9
   INTEGER :: ad_to9
   INTEGER :: ad_from10
   INTEGER :: ad_to10
   INTEGER :: branch
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tmpd1
   REAL(kind=realtype) :: tmpd0
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nn=1,nbocos
   ! Loop over the faces and set the state in
   ! the turbulent halo cells.
   IF (wallfunctions) THEN
   CALL PUSHCONTROL3B(0)
   ELSE
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   ad_from0 = bcdata(nn)%jcbeg
   DO j=ad_from0,bcdata(nn)%jcend
   ad_from = bcdata(nn)%icbeg
   i = bcdata(nn)%icend + 1
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL3B(2)
   CASE (imax) 
   ad_from2 = bcdata(nn)%jcbeg
   DO j=ad_from2,bcdata(nn)%jcend
   ad_from1 = bcdata(nn)%icbeg
   i = bcdata(nn)%icend + 1
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from2)
   CALL PUSHCONTROL3B(3)
   CASE (jmin) 
   ad_from4 = bcdata(nn)%jcbeg
   DO j=ad_from4,bcdata(nn)%jcend
   ad_from3 = bcdata(nn)%icbeg
   i = bcdata(nn)%icend + 1
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   CALL PUSHCONTROL3B(4)
   CASE (jmax) 
   ad_from6 = bcdata(nn)%jcbeg
   DO j=ad_from6,bcdata(nn)%jcend
   ad_from5 = bcdata(nn)%icbeg
   i = bcdata(nn)%icend + 1
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from5)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from6)
   CALL PUSHCONTROL3B(5)
   CASE (kmin) 
   ad_from8 = bcdata(nn)%jcbeg
   DO j=ad_from8,bcdata(nn)%jcend
   ad_from7 = bcdata(nn)%icbeg
   i = bcdata(nn)%icend + 1
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from7)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from8)
   CALL PUSHCONTROL3B(6)
   CASE (kmax) 
   ad_from10 = bcdata(nn)%jcbeg
   DO j=ad_from10,bcdata(nn)%jcend
   ad_from9 = bcdata(nn)%icbeg
   i = bcdata(nn)%icend + 1
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from9)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from10)
   CALL PUSHCONTROL3B(7)
   CASE DEFAULT
   CALL PUSHCONTROL3B(1)
   END SELECT
   END IF
   ! Set the value of the eddy viscosity, depending on the type of
   ! boundary condition. Only if the turbulence model is an eddy
   ! viscosity model of course.
   IF (eddymodel) THEN
   IF (bctype(nn) .EQ. nswalladiabatic .OR. bctype(nn) .EQ. &
   &         nswallisothermal) THEN
   CALL PUSHCONTROL2B(0)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   ! Extrapolate the turbulent variables in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO bocos
   bvtj1d = 0.0_8
   bvtj2d = 0.0_8
   bvtk1d = 0.0_8
   bvtk2d = 0.0_8
   bvti1d = 0.0_8
   bvti2d = 0.0_8
   DO nn=nbocos,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) CALL TURB2NDHALO_B(nn)
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   CALL BCEDDYWALL_B(nn)
   ELSE IF (branch .EQ. 1) THEN
   CALL BCEDDYNOWALL_B(nn)
   END IF
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 4) THEN
   IF (branch .GE. 2) THEN
   IF (branch .EQ. 2) THEN
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   DO l=nt2,nt1,-1
   DO m=nt2,nt1,-1
   wd(2, i, j, m) = wd(2, i, j, m) - bmti1(i, j, l, m)*wd&
   &                   (1, i, j, l)
   END DO
   bvti1d(i, j, l) = bvti1d(i, j, l) + wd(1, i, j, l)
   wd(1, i, j, l) = 0.0_8
   END DO
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO j=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   DO l=nt2,nt1,-1
   DO m=nt2,nt1,-1
   tmpd = wd(ie, i, j, l)
   wd(ie, i, j, l) = tmpd
   wd(il, i, j, m) = wd(il, i, j, m) - bmti2(i, j, l, m)*&
   &                   tmpd
   END DO
   bvti2d(i, j, l) = bvti2d(i, j, l) + wd(ie, i, j, l)
   wd(ie, i, j, l) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   END IF
   ELSE IF (branch .LT. 6) THEN
   IF (branch .EQ. 4) THEN
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO i=ad_to3,ad_from3,-1
   DO l=nt2,nt1,-1
   DO m=nt2,nt1,-1
   wd(i, 2, j, m) = wd(i, 2, j, m) - bmtj1(i, j, l, m)*wd(i&
   &                 , 1, j, l)
   END DO
   bvtj1d(i, j, l) = bvtj1d(i, j, l) + wd(i, 1, j, l)
   wd(i, 1, j, l) = 0.0_8
   END DO
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO j=ad_to6,ad_from6,-1
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO i=ad_to5,ad_from5,-1
   DO l=nt2,nt1,-1
   DO m=nt2,nt1,-1
   tmpd0 = wd(i, je, j, l)
   wd(i, je, j, l) = tmpd0
   wd(i, jl, j, m) = wd(i, jl, j, m) - bmtj2(i, j, l, m)*&
   &                 tmpd0
   END DO
   bvtj2d(i, j, l) = bvtj2d(i, j, l) + wd(i, je, j, l)
   wd(i, je, j, l) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   ELSE IF (branch .EQ. 6) THEN
   CALL POPINTEGER4(ad_from8)
   CALL POPINTEGER4(ad_to8)
   DO j=ad_to8,ad_from8,-1
   CALL POPINTEGER4(ad_from7)
   CALL POPINTEGER4(ad_to7)
   DO i=ad_to7,ad_from7,-1
   DO l=nt2,nt1,-1
   DO m=nt2,nt1,-1
   wd(i, j, 2, m) = wd(i, j, 2, m) - bmtk1(i, j, l, m)*wd(i, &
   &               j, 1, l)
   END DO
   bvtk1d(i, j, l) = bvtk1d(i, j, l) + wd(i, j, 1, l)
   wd(i, j, 1, l) = 0.0_8
   END DO
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from10)
   CALL POPINTEGER4(ad_to10)
   DO j=ad_to10,ad_from10,-1
   CALL POPINTEGER4(ad_from9)
   CALL POPINTEGER4(ad_to9)
   DO i=ad_to9,ad_from9,-1
   DO l=nt2,nt1,-1
   DO m=nt2,nt1,-1
   tmpd1 = wd(i, j, ke, l)
   wd(i, j, ke, l) = tmpd1
   wd(i, j, kl, m) = wd(i, j, kl, m) - bmtk2(i, j, l, m)*&
   &               tmpd1
   END DO
   bvtk2d(i, j, l) = bvtk2d(i, j, l) + wd(i, j, ke, l)
   wd(i, j, ke, l) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   END DO
   END SUBROUTINE APPLYALLTURBBCTHISBLOCK_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of invisciddissfluxmatrixapprox in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *p *gamma *w *si *sj *sk *fw
   !   with respect to varying inputs: *p *gamma *w *si *sj *sk pinfcorr
   !   Plus diff mem management of: p:in gamma:in w:in si:in sj:in
   !                sk:in fw:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidDissFluxMatrixApprox.f90                *
   !      * Author:        Gaetan K.W. Kenway                              *
   !      * Starting date: 12-02-2014                                      *
   !      * Last modified: 12-02-2014                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDDISSFLUXMATRIXAPPROX_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidDissFluxMatrix computes the matrix artificial          *
   !      * dissipation term. Instead of the spectral radius, as used in   *
   !      * the scalar dissipation scheme, the absolute value of the flux  *
   !      * jacobian is used. This leads to a less diffusive and           *
   !      * consequently more accurate scheme. It is assumed that the      *
   !      * pointers in blockPointers already point to the correct block.  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE CGNSGRID
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      Local parameters.
   !
   REAL(kind=realtype), PARAMETER :: dpmax=0.25_realType
   REAL(kind=realtype), PARAMETER :: epsacoustic=0.25_realType
   REAL(kind=realtype), PARAMETER :: epsshear=0.025_realType
   REAL(kind=realtype), PARAMETER :: omega=0.5_realType
   REAL(kind=realtype), PARAMETER :: oneminomega=one-omega
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ind
   REAL(kind=realtype) :: plim, sface
   REAL(kind=realtype) :: plimd, sfaced
   REAL(kind=realtype) :: sfil, fis2, fis4
   REAL(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
   REAL(kind=realtype) :: gammaavgd, gm1d, ovgm1d, gm53d
   REAL(kind=realtype) :: ppor, rrad, dis2
   REAL(kind=realtype) :: rradd, dis2d
   REAL(kind=realtype) :: dp1, dp2, ddw, tmp, fs
   REAL(kind=realtype) :: dp1d, dp2d, ddwd, tmpd, fsd
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
   REAL(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd, sxd, syd, &
   & szd
   REAL(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
   REAL(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
   REAL(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
   REAL(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
   REAL(kind=realtype) :: kavg, lam1, lam2, lam3, area
   REAL(kind=realtype) :: kavgd, lam1d, lam2d, lam3d, aread
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, abv7d
   LOGICAL :: correctfork
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC MIN
   INTRINSIC SQRT
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: tempd14
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: tempd13
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: tempd12
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd11
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: x6d
   REAL(kind=realtype) :: max2d
   REAL(kind=realtype) :: min3
   REAL(kind=realtype) :: min2
   REAL(kind=realtype) :: min1
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: min1d
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: temp16
   REAL(kind=realtype) :: temp15
   REAL(kind=realtype) :: x5d
   REAL(kind=realtype) :: temp14
   REAL(kind=realtype) :: y3d
   REAL(kind=realtype) :: temp13
   REAL(kind=realtype) :: temp12
   REAL(kind=realtype) :: temp11
   REAL(kind=realtype) :: temp10
   REAL(kind=realtype) :: max1d
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: abs12
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: abs11
   REAL(kind=realtype) :: abs10
   REAL(kind=realtype) :: min3d
   REAL(kind=realtype) :: x4d
   REAL(kind=realtype) :: y2d
   REAL(kind=realtype) :: abs9
   REAL(kind=realtype) :: abs8
   REAL(kind=realtype) :: abs7
   REAL(kind=realtype) :: abs6
   REAL(kind=realtype) :: abs5
   REAL(kind=realtype) :: abs4
   REAL(kind=realtype) :: abs3
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: max3d
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: min2d
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: x3d
   REAL(kind=realtype) :: tempd16
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: y1d
   REAL(kind=realtype) :: temp4
   REAL(kind=realtype) :: tempd15
   IF (rfil .GE. 0.) THEN
   abs0 = rfil
   ELSE
   abs0 = -rfil
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check if rFil == 0. If so, the dissipative flux needs not to
   ! be computed.
   IF (abs0 .LT. thresholdreal) THEN
   pinfcorrd = 0.0_8
   ELSE
   ! Set the value of plim. To be fully consistent this must have
   ! the dimension of a pressure. Therefore a fraction of pInfCorr
   ! is used.
   plim = 0.001_realType*pinfcorr
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .EQ. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   ! Initialize sface to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set a couple of constants for the scheme.
   fis2 = rfil*vis2
   fis4 = rfil*vis4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the i-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   IF (shocksensor(2, j, k) - shocksensor(1, j, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs1)
   abs1 = shocksensor(2, j, k) - shocksensor(1, j, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs1)
   abs1 = -(shocksensor(2, j, k)-shocksensor(1, j, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(1, j, k) - shocksensor(0, j, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs7)
   abs7 = shocksensor(1, j, k) - shocksensor(0, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs7)
   abs7 = -(shocksensor(1, j, k)-shocksensor(0, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+shocksensor(&
   &         0, j, k))/(omega*(shocksensor(2, j, k)+two*shocksensor(1, j, k&
   &         )+shocksensor(0, j, k))+oneminomega*(abs1+abs7)+plim)
   IF (x1 .GE. 0.) THEN
   dp1 = x1
   CALL PUSHCONTROL1B(0)
   ELSE
   dp1 = -x1
   CALL PUSHCONTROL1B(1)
   END IF
   ! Loop in i-direction.
   DO i=1,il
   IF (shocksensor(i+2, j, k) - shocksensor(i+1, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs2)
   abs2 = shocksensor(i+2, j, k) - shocksensor(i+1, j, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs2)
   abs2 = -(shocksensor(i+2, j, k)-shocksensor(i+1, j, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i+1, j, k) - shocksensor(i, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs8)
   abs8 = shocksensor(i+1, j, k) - shocksensor(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs8)
   abs8 = -(shocksensor(i+1, j, k)-shocksensor(i, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
   &           shocksensor(i, j, k))/(omega*(shocksensor(i+2, j, k)+two*&
   &           shocksensor(i+1, j, k)+shocksensor(i, j, k))+oneminomega*(&
   &           abs2+abs8)+plim)
   IF (x2 .GE. 0.) THEN
   dp2 = x2
   CALL PUSHCONTROL1B(0)
   ELSE
   dp2 = -x2
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the dissipation coefficients for this face.
   CALL PUSHREAL8(ppor)
   ppor = zero
   IF (pori(i, j, k) .EQ. normalflux) ppor = one
   IF (dp1 .LT. dp2) THEN
   y1 = dp2
   CALL PUSHCONTROL1B(0)
   ELSE
   y1 = dp1
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dpmax .GT. y1) THEN
   min1 = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   min1 = dpmax
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*ppor*min1 + sigma*fis4*ppor
   ! Construct the vector of the first and third differences
   ! multiplied by the appropriate constants.
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
   CALL PUSHREAL8(dr)
   dr = dis2*ddw
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*&
   &           w(i, j, k, ivx)
   CALL PUSHREAL8(dru)
   dru = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*&
   &           w(i, j, k, ivy)
   CALL PUSHREAL8(drv)
   drv = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*&
   &           w(i, j, k, ivz)
   CALL PUSHREAL8(drw)
   drw = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
   CALL PUSHREAL8(dre)
   dre = dis2*ddw
   ! In case a k-equation is present, compute the difference
   ! of rhok and store the average value of k. If not present,
   ! set both these values to zero, such that later on no
   ! decision needs to be made anymore.
   IF (correctfork) THEN
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
   &             irho)*w(i, j, k, itu1)
   CALL PUSHREAL8(drk)
   drk = dis2*ddw
   CALL PUSHREAL8(kavg)
   kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(drk)
   drk = zero
   CALL PUSHREAL8(kavg)
   kavg = zero
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the average value of gamma and compute some
   ! expressions in which it occurs.
   gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   gm53 = gammaavg - five*third
   ! Compute the average state at the interface.
   uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
   vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
   wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
   CALL PUSHREAL8(a2avg)
   a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)&
   &           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
   CALL PUSHREAL8(sx)
   sx = si(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = si(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = si(i, j, k, 3)
   CALL PUSHREAL8(area)
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   CALL PUSHREAL8(max1)
   max1 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max1)
   max1 = 1.e-25_realType
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = one/max1
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   CALL PUSHREAL8(aavg)
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ! The mesh velocity if the face is moving. It must be
   ! divided by the area to obtain a true velocity.
   IF (addgridvelocities) THEN
   sface = sfacei(i, j, k)*tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   IF (unavg - sface + aavg .GE. 0.) THEN
   lam1 = unavg - sface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-sface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface - aavg .GE. 0.) THEN
   lam2 = unavg - sface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-sface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface .GE. 0.) THEN
   CALL PUSHREAL8(lam3)
   lam3 = unavg - sface
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(lam3)
   lam3 = -(unavg-sface)
   CALL PUSHCONTROL1B(1)
   END IF
   rrad = lam3 + aavg
   IF (lam1 .LT. epsacoustic*rrad) THEN
   lam1 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam1 = lam1
   END IF
   IF (lam2 .LT. epsacoustic*rrad) THEN
   lam2 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam2 = lam2
   END IF
   IF (lam3 .LT. epsshear*rrad) THEN
   lam3 = epsshear*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = lam3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   CALL PUSHREAL8(abv2)
   abv2 = half*(lam1-lam2)
   CALL PUSHREAL8(abv3)
   abv3 = abv1 - lam3
   CALL PUSHREAL8(abv4)
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
   &           *drk
   ! Compute and scatter the dissipative flux.
   ! Density.
   ! X-momentum.
   ! Y-momentum.
   ! Z-momentum.
   ! Energy.
   ! Set dp1 to dp2 for the next face.
   dp1 = dp2
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the j-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO i=2,il
   IF (shocksensor(i, 2, k) - shocksensor(i, 1, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs3)
   abs3 = shocksensor(i, 2, k) - shocksensor(i, 1, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs3)
   abs3 = -(shocksensor(i, 2, k)-shocksensor(i, 1, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, 1, k) - shocksensor(i, 0, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs9)
   abs9 = shocksensor(i, 1, k) - shocksensor(i, 0, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs9)
   abs9 = -(shocksensor(i, 1, k)-shocksensor(i, 0, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+shocksensor(&
   &         i, 0, k))/(omega*(shocksensor(i, 2, k)+two*shocksensor(i, 1, k&
   &         )+shocksensor(i, 0, k))+oneminomega*(abs3+abs9)+plim)
   IF (x3 .GE. 0.) THEN
   dp1 = x3
   CALL PUSHCONTROL1B(0)
   ELSE
   dp1 = -x3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Loop in j-direction.
   DO j=1,jl
   IF (shocksensor(i, j+2, k) - shocksensor(i, j+1, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs4)
   abs4 = shocksensor(i, j+2, k) - shocksensor(i, j+1, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs4)
   abs4 = -(shocksensor(i, j+2, k)-shocksensor(i, j+1, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, j+1, k) - shocksensor(i, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs10)
   abs10 = shocksensor(i, j+1, k) - shocksensor(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs10)
   abs10 = -(shocksensor(i, j+1, k)-shocksensor(i, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
   &           shocksensor(i, j, k))/(omega*(shocksensor(i, j+2, k)+two*&
   &           shocksensor(i, j+1, k)+shocksensor(i, j, k))+oneminomega*(&
   &           abs4+abs10)+plim)
   IF (x4 .GE. 0.) THEN
   dp2 = x4
   CALL PUSHCONTROL1B(0)
   ELSE
   dp2 = -x4
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the dissipation coefficients for this face.
   CALL PUSHREAL8(ppor)
   ppor = zero
   IF (porj(i, j, k) .EQ. normalflux) ppor = one
   IF (dp1 .LT. dp2) THEN
   y2 = dp2
   CALL PUSHCONTROL1B(0)
   ELSE
   y2 = dp1
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dpmax .GT. y2) THEN
   min2 = y2
   CALL PUSHCONTROL1B(0)
   ELSE
   min2 = dpmax
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*ppor*min2 + sigma*fis4*ppor
   ! Construct the vector of the first and third differences
   ! multiplied by the appropriate constants.
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
   CALL PUSHREAL8(dr)
   dr = dis2*ddw
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*&
   &           w(i, j, k, ivx)
   CALL PUSHREAL8(dru)
   dru = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*&
   &           w(i, j, k, ivy)
   CALL PUSHREAL8(drv)
   drv = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*&
   &           w(i, j, k, ivz)
   CALL PUSHREAL8(drw)
   drw = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
   CALL PUSHREAL8(dre)
   dre = dis2*ddw
   ! In case a k-equation is present, compute the difference
   ! of rhok and store the average value of k. If not present,
   ! set both these values to zero, such that later on no
   ! decision needs to be made anymore.
   IF (correctfork) THEN
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
   &             irho)*w(i, j, k, itu1)
   CALL PUSHREAL8(drk)
   drk = dis2*ddw
   CALL PUSHREAL8(kavg)
   kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(drk)
   drk = zero
   CALL PUSHREAL8(kavg)
   kavg = zero
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the average value of gamma and compute some
   ! expressions in which it occurs.
   gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   gm53 = gammaavg - five*third
   ! Compute the average state at the interface.
   uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
   vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
   wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
   CALL PUSHREAL8(a2avg)
   a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)&
   &           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
   CALL PUSHREAL8(sx)
   sx = sj(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sj(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sj(i, j, k, 3)
   CALL PUSHREAL8(area)
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   CALL PUSHREAL8(max2)
   max2 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max2)
   max2 = 1.e-25_realType
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = one/max2
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   CALL PUSHREAL8(aavg)
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ! The mesh velocity if the face is moving. It must be
   ! divided by the area to obtain a true velocity.
   IF (addgridvelocities) THEN
   sface = sfacej(i, j, k)*tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   IF (unavg - sface + aavg .GE. 0.) THEN
   lam1 = unavg - sface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-sface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface - aavg .GE. 0.) THEN
   lam2 = unavg - sface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-sface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface .GE. 0.) THEN
   CALL PUSHREAL8(lam3)
   lam3 = unavg - sface
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(lam3)
   lam3 = -(unavg-sface)
   CALL PUSHCONTROL1B(1)
   END IF
   rrad = lam3 + aavg
   IF (lam1 .LT. epsacoustic*rrad) THEN
   lam1 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam1 = lam1
   END IF
   IF (lam2 .LT. epsacoustic*rrad) THEN
   lam2 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam2 = lam2
   END IF
   IF (lam3 .LT. epsshear*rrad) THEN
   lam3 = epsshear*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = lam3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   CALL PUSHREAL8(abv2)
   abv2 = half*(lam1-lam2)
   CALL PUSHREAL8(abv3)
   abv3 = abv1 - lam3
   CALL PUSHREAL8(abv4)
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
   &           *drk
   ! Compute and scatter the dissipative flux.
   ! Density.
   ! X-momentum.
   ! Y-momentum.
   ! Z-momentum.
   ! Energy.
   ! Set dp1 to dp2 for the next face.
   dp1 = dp2
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the k-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO j=2,jl
   DO i=2,il
   IF (shocksensor(i, j, 2) - shocksensor(i, j, 1) .GE. 0.) THEN
   CALL PUSHREAL8(abs5)
   abs5 = shocksensor(i, j, 2) - shocksensor(i, j, 1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs5)
   abs5 = -(shocksensor(i, j, 2)-shocksensor(i, j, 1))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, j, 1) - shocksensor(i, j, 0) .GE. 0.) THEN
   CALL PUSHREAL8(abs11)
   abs11 = shocksensor(i, j, 1) - shocksensor(i, j, 0)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs11)
   abs11 = -(shocksensor(i, j, 1)-shocksensor(i, j, 0))
   CALL PUSHCONTROL1B(1)
   END IF
   x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+shocksensor(&
   &         i, j, 0))/(omega*(shocksensor(i, j, 2)+two*shocksensor(i, j, 1&
   &         )+shocksensor(i, j, 0))+oneminomega*(abs5+abs11)+plim)
   IF (x5 .GE. 0.) THEN
   dp1 = x5
   CALL PUSHCONTROL1B(0)
   ELSE
   dp1 = -x5
   CALL PUSHCONTROL1B(1)
   END IF
   ! Loop in k-direction.
   DO k=1,kl
   IF (shocksensor(i, j, k+2) - shocksensor(i, j, k+1) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs6)
   abs6 = shocksensor(i, j, k+2) - shocksensor(i, j, k+1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs6)
   abs6 = -(shocksensor(i, j, k+2)-shocksensor(i, j, k+1))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, j, k+1) - shocksensor(i, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs12)
   abs12 = shocksensor(i, j, k+1) - shocksensor(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs12)
   abs12 = -(shocksensor(i, j, k+1)-shocksensor(i, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
   &           shocksensor(i, j, k))/(omega*(shocksensor(i, j, k+2)+two*&
   &           shocksensor(i, j, k+1)+shocksensor(i, j, k))+oneminomega*(&
   &           abs6+abs12)+plim)
   IF (x6 .GE. 0.) THEN
   dp2 = x6
   CALL PUSHCONTROL1B(0)
   ELSE
   dp2 = -x6
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the dissipation coefficients for this face.
   CALL PUSHREAL8(ppor)
   ppor = zero
   IF (pork(i, j, k) .EQ. normalflux) ppor = one
   IF (dp1 .LT. dp2) THEN
   y3 = dp2
   CALL PUSHCONTROL1B(0)
   ELSE
   y3 = dp1
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dpmax .GT. y3) THEN
   min3 = y3
   CALL PUSHCONTROL1B(0)
   ELSE
   min3 = dpmax
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*ppor*min3 + sigma*fis4*ppor
   ! Construct the vector of the first and third differences
   ! multiplied by the appropriate constants.
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
   CALL PUSHREAL8(dr)
   dr = dis2*ddw
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*&
   &           w(i, j, k, ivx)
   CALL PUSHREAL8(dru)
   dru = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*&
   &           w(i, j, k, ivy)
   CALL PUSHREAL8(drv)
   drv = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*&
   &           w(i, j, k, ivz)
   CALL PUSHREAL8(drw)
   drw = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
   CALL PUSHREAL8(dre)
   dre = dis2*ddw
   ! In case a k-equation is present, compute the difference
   ! of rhok and store the average value of k. If not present,
   ! set both these values to zero, such that later on no
   ! decision needs to be made anymore.
   IF (correctfork) THEN
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
   &             irho)*w(i, j, k, itu1)
   CALL PUSHREAL8(drk)
   drk = dis2*ddw
   CALL PUSHREAL8(kavg)
   kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(drk)
   drk = zero
   CALL PUSHREAL8(kavg)
   kavg = zero
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the average value of gamma and compute some
   ! expressions in which it occurs.
   gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
   gm1 = gammaavg - one
   gm53 = gammaavg - five*third
   ! Compute the average state at the interface.
   uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
   vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
   wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
   CALL PUSHREAL8(a2avg)
   a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)&
   &           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
   CALL PUSHREAL8(sx)
   sx = sk(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sk(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sk(i, j, k, 3)
   CALL PUSHREAL8(area)
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   CALL PUSHREAL8(max3)
   max3 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max3)
   max3 = 1.e-25_realType
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = one/max3
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   CALL PUSHREAL8(aavg)
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ! The mesh velocity if the face is moving. It must be
   ! divided by the area to obtain a true velocity.
   IF (addgridvelocities) THEN
   sface = sfacek(i, j, k)*tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   IF (unavg - sface + aavg .GE. 0.) THEN
   lam1 = unavg - sface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-sface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface - aavg .GE. 0.) THEN
   lam2 = unavg - sface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-sface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface .GE. 0.) THEN
   CALL PUSHREAL8(lam3)
   lam3 = unavg - sface
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(lam3)
   lam3 = -(unavg-sface)
   CALL PUSHCONTROL1B(1)
   END IF
   rrad = lam3 + aavg
   IF (lam1 .LT. epsacoustic*rrad) THEN
   lam1 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam1 = lam1
   END IF
   IF (lam2 .LT. epsacoustic*rrad) THEN
   lam2 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam2 = lam2
   END IF
   IF (lam3 .LT. epsshear*rrad) THEN
   lam3 = epsshear*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = lam3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   CALL PUSHREAL8(abv2)
   abv2 = half*(lam1-lam2)
   CALL PUSHREAL8(abv3)
   abv3 = abv1 - lam3
   CALL PUSHREAL8(abv4)
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
   &           *drk
   ! Compute and scatter the dissipative flux.
   ! Density.
   ! X-momentum.
   ! Y-momentum.
   ! Z-momentum.
   ! Energy.
   ! Set dp1 to dp2 for the next face.
   dp1 = dp2
   END DO
   END DO
   END DO
   plimd = 0.0_8
   sfaced = 0.0_8
   DO j=jl,2,-1
   DO i=il,2,-1
   dp1d = 0.0_8
   DO k=kl,1,-1
   dp2d = dp1d
   fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
   wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
   gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
   gm1 = gammaavg - one
   vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
   uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
   unavg = uavg*sx + vavg*sy + wavg*sz
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   gm53 = gammaavg - five*third
   ovaavg = one/aavg
   ova2avg = one/a2avg
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ovgm1 = one/gm1
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
   lam3d = dre*fsd
   dred = lam3*fsd
   havgd = abv6*fsd
   abv6d = havg*fsd
   unavgd = abv7*fsd
   abv7d = unavg*fsd
   fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
   lam3d = lam3d + drw*fsd
   drwd = lam3*fsd
   wavgd = abv6*fsd
   abv6d = abv6d + wavg*fsd
   szd = abv7*fsd
   abv7d = abv7d + sz*fsd
   fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
   lam3d = lam3d + drv*fsd
   drvd = lam3*fsd
   vavgd = abv6*fsd
   abv6d = abv6d + vavg*fsd
   syd = abv7*fsd
   abv7d = abv7d + sy*fsd
   fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
   lam3d = lam3d + dru*fsd
   drud = lam3*fsd
   uavgd = abv6*fsd
   abv6d = abv6d + uavg*fsd
   sxd = abv7*fsd
   abv7d = abv7d + sx*fsd
   fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
   abv6d = abv6d + fsd
   abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
   abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
   ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
   abv3d = ova2avg*abv4*abv6d + abv5*abv7d
   lam3d = lam3d + dr*fsd - abv3d
   abv5d = ovaavg*abv2*abv6d + abv3*abv7d
   ova2avgd = abv3*abv4*abv6d
   sxd = sxd + dru*abv5d
   syd = syd + drv*abv5d
   szd = szd + drw*abv5d
   unavgd = unavgd - dr*abv5d
   CALL POPREAL8(abv4)
   tempd16 = gm1*abv4d
   drd = alphaavg*tempd16 - unavg*abv5d + lam3*fsd
   drud = drud + sx*abv5d - uavg*tempd16
   drvd = drvd + sy*abv5d - vavg*tempd16
   drwd = drwd + sz*abv5d - wavg*tempd16
   gm1d = (alphaavg*dr-uavg*dru-vavg*drv+dre-wavg*drw)*abv4d
   alphaavgd = dr*tempd16
   uavgd = uavgd - dru*tempd16
   vavgd = vavgd - drv*tempd16
   dred = dred + tempd16
   wavgd = wavgd - drw*tempd16
   gm53d = -(drk*abv4d)
   drkd = -(gm53*abv4d)
   CALL POPREAL8(abv3)
   abv1d = abv3d
   CALL POPREAL8(abv2)
   lam1d = half*abv1d + half*abv2d
   lam2d = half*abv1d - half*abv2d
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
   lam3d = area*lam3d
   lam2d = area*lam2d
   lam1d = area*lam1d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = epsshear*lam3d
   lam3d = 0.0_8
   ELSE
   rradd = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = rradd + epsacoustic*lam2d
   lam2d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = rradd + epsacoustic*lam1d
   lam1d = 0.0_8
   END IF
   lam3d = lam3d + rradd
   aavgd = rradd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   unavgd = unavgd + lam3d
   sfaced = sfaced - lam3d
   ELSE
   CALL POPREAL8(lam3)
   sfaced = sfaced + lam3d
   unavgd = unavgd - lam3d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam2d
   sfaced = sfaced - lam2d
   aavgd = aavgd - lam2d
   ELSE
   sfaced = sfaced + lam2d
   unavgd = unavgd - lam2d
   aavgd = aavgd + lam2d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam1d
   sfaced = sfaced - lam1d
   aavgd = aavgd + lam1d
   ELSE
   sfaced = sfaced + lam1d
   unavgd = unavgd - lam1d
   aavgd = aavgd - lam1d
   END IF
   tmp = one/max3
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tmpd = 0.0_8
   ELSE
   tmpd = sfacek(i, j, k)*sfaced
   sfaced = 0.0_8
   END IF
   alphaavgd = alphaavgd + havgd
   tempd15 = half*alphaavgd
   tempd14 = ovgm1*havgd
   aavgd = aavgd - one*ovaavgd/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgd = tempd14 - one*ova2avgd/a2avg**2
   ELSE
   a2avgd = aavgd/(2.0*SQRT(a2avg)) + tempd14 - one*ova2avgd/&
   &             a2avg**2
   END IF
   uavgd = uavgd + 2*uavg*tempd15 + sx*unavgd
   sxd = sxd + uavg*unavgd
   vavgd = vavgd + 2*vavg*tempd15 + sy*unavgd
   syd = syd + vavg*unavgd
   wavgd = wavgd + 2*wavg*tempd15 + sz*unavgd
   szd = szd + wavg*unavgd
   CALL POPREAL8(aavg)
   ovgm1d = (a2avg-gm53*kavg)*havgd
   gm53d = gm53d - kavg*tempd14
   kavgd = -(gm53*tempd14)
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tmpd = tmpd + sy*syd + sx*sxd + sz*szd
   szd = tmp*szd
   syd = tmp*syd
   sxd = tmp*sxd
   max3d = -(one*tmpd/max3**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max3)
   aread = aread + max3d
   ELSE
   CALL POPREAL8(max3)
   END IF
   gm1d = gm1d - one*ovgm1d/gm1**2
   CALL POPREAL8(area)
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempd11 = 0.0
   ELSE
   tempd11 = aread/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxd = sxd + 2*sx*tempd11
   syd = syd + 2*sy*tempd11
   szd = szd + 2*sz*tempd11
   CALL POPREAL8(sz)
   skd(i, j, k, 3) = skd(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   skd(i, j, k, 2) = skd(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
   CALL POPREAL8(a2avg)
   temp16 = w(i, j, k, irho)
   temp15 = w(i, j, k+1, irho)
   temp14 = p(i, j, k+1)
   temp13 = gamma(i, j, k+1)
   tempd12 = half*a2avgd/temp15
   tempd13 = half*a2avgd/temp16
   gammad(i, j, k+1) = gammad(i, j, k+1) + temp14*tempd12
   pd(i, j, k+1) = pd(i, j, k+1) + temp13*tempd12
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - temp13*temp14*&
   &           tempd12/temp15
   gammad(i, j, k) = gammad(i, j, k) + p(i, j, k)*tempd13
   pd(i, j, k) = pd(i, j, k) + gamma(i, j, k)*tempd13
   wd(i, j, k, irho) = wd(i, j, k, irho) - gamma(i, j, k)*p(i, j&
   &           , k)*tempd13/temp16
   wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wavgd
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
   wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vavgd
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
   wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*uavgd
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
   gammaavgd = gm1d + gm53d
   gammad(i, j, k+1) = gammad(i, j, k+1) + half*gammaavgd
   gammad(i, j, k) = gammad(i, j, k) + half*gammaavgd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(kavg)
   CALL POPREAL8(drk)
   dis2d = 0.0_8
   ELSE
   CALL POPREAL8(kavg)
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*kavgd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
   CALL POPREAL8(drk)
   dis2d = ddw*drkd
   ddwd = dis2*drkd
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, &
   &             itu1)*ddwd
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + w(i, j, k+1, &
   &             irho)*ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
   &             ddwd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
   &             ddwd
   ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
   END IF
   CALL POPREAL8(dre)
   dis2d = dis2d + ddw*dred
   ddwd = dis2*dred
   CALL POPREAL8(ddw)
   wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddwd
   wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
   CALL POPREAL8(drw)
   dis2d = dis2d + ddw*drwd
   ddwd = dis2*drwd
   CALL POPREAL8(ddw)
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
   &           ddwd
   wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
   CALL POPREAL8(drv)
   dis2d = dis2d + ddw*drvd
   ddwd = dis2*drvd
   CALL POPREAL8(ddw)
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
   &           ddwd
   wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
   CALL POPREAL8(dru)
   dis2d = dis2d + ddw*drud
   ddwd = dis2*drud
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
   &           ddwd
   wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
   ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
   CALL POPREAL8(dr)
   dis2d = dis2d + ddw*drd
   ddwd = dis2*drd
   CALL POPREAL8(ddw)
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
   CALL POPREAL8(dis2)
   min3d = fis2*ppor*dis2d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y3d = min3d
   ELSE
   y3d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dp2d = dp2d + y3d
   dp1d = 0.0_8
   ELSE
   dp1d = y3d
   END IF
   CALL POPREAL8(ppor)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x6d = dp2d
   ELSE
   x6d = -dp2d
   END IF
   temp12 = omega*(shocksensor(i, j, k+2)+two*shocksensor(i, j, k&
   &           +1)+shocksensor(i, j, k)) + oneminomega*(abs6+abs12) + plim
   plimd = plimd - (shocksensor(i, j, k+2)-two*shocksensor(i, j, &
   &           k+1)+shocksensor(i, j, k))*x6d/temp12**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs12)
   ELSE
   CALL POPREAL8(abs12)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs6)
   ELSE
   CALL POPREAL8(abs6)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x5d = dp1d
   ELSE
   x5d = -dp1d
   END IF
   temp11 = omega*(shocksensor(i, j, 2)+two*shocksensor(i, j, 1)+&
   &         shocksensor(i, j, 0)) + oneminomega*(abs5+abs11) + plim
   plimd = plimd - (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
   &         shocksensor(i, j, 0))*x5d/temp11**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs11)
   ELSE
   CALL POPREAL8(abs11)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs5)
   ELSE
   CALL POPREAL8(abs5)
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO i=il,2,-1
   dp1d = 0.0_8
   DO j=jl,1,-1
   dp2d = dp1d
   fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
   wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
   gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
   uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
   unavg = uavg*sx + vavg*sy + wavg*sz
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   gm53 = gammaavg - five*third
   ovaavg = one/aavg
   ova2avg = one/a2avg
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ovgm1 = one/gm1
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
   lam3d = dre*fsd
   dred = lam3*fsd
   havgd = abv6*fsd
   abv6d = havg*fsd
   unavgd = abv7*fsd
   abv7d = unavg*fsd
   fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
   lam3d = lam3d + drw*fsd
   drwd = lam3*fsd
   wavgd = abv6*fsd
   abv6d = abv6d + wavg*fsd
   szd = abv7*fsd
   abv7d = abv7d + sz*fsd
   fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
   lam3d = lam3d + drv*fsd
   drvd = lam3*fsd
   vavgd = abv6*fsd
   abv6d = abv6d + vavg*fsd
   syd = abv7*fsd
   abv7d = abv7d + sy*fsd
   fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
   lam3d = lam3d + dru*fsd
   drud = lam3*fsd
   uavgd = abv6*fsd
   abv6d = abv6d + uavg*fsd
   sxd = abv7*fsd
   abv7d = abv7d + sx*fsd
   fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
   abv6d = abv6d + fsd
   abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
   abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
   ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
   abv3d = ova2avg*abv4*abv6d + abv5*abv7d
   lam3d = lam3d + dr*fsd - abv3d
   abv5d = ovaavg*abv2*abv6d + abv3*abv7d
   ova2avgd = abv3*abv4*abv6d
   sxd = sxd + dru*abv5d
   syd = syd + drv*abv5d
   szd = szd + drw*abv5d
   unavgd = unavgd - dr*abv5d
   CALL POPREAL8(abv4)
   tempd10 = gm1*abv4d
   drd = alphaavg*tempd10 - unavg*abv5d + lam3*fsd
   drud = drud + sx*abv5d - uavg*tempd10
   drvd = drvd + sy*abv5d - vavg*tempd10
   drwd = drwd + sz*abv5d - wavg*tempd10
   gm1d = (alphaavg*dr-uavg*dru-vavg*drv+dre-wavg*drw)*abv4d
   alphaavgd = dr*tempd10
   uavgd = uavgd - dru*tempd10
   vavgd = vavgd - drv*tempd10
   dred = dred + tempd10
   wavgd = wavgd - drw*tempd10
   gm53d = -(drk*abv4d)
   drkd = -(gm53*abv4d)
   CALL POPREAL8(abv3)
   abv1d = abv3d
   CALL POPREAL8(abv2)
   lam1d = half*abv1d + half*abv2d
   lam2d = half*abv1d - half*abv2d
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
   lam3d = area*lam3d
   lam2d = area*lam2d
   lam1d = area*lam1d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = epsshear*lam3d
   lam3d = 0.0_8
   ELSE
   rradd = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = rradd + epsacoustic*lam2d
   lam2d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = rradd + epsacoustic*lam1d
   lam1d = 0.0_8
   END IF
   lam3d = lam3d + rradd
   aavgd = rradd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   unavgd = unavgd + lam3d
   sfaced = sfaced - lam3d
   ELSE
   CALL POPREAL8(lam3)
   sfaced = sfaced + lam3d
   unavgd = unavgd - lam3d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam2d
   sfaced = sfaced - lam2d
   aavgd = aavgd - lam2d
   ELSE
   sfaced = sfaced + lam2d
   unavgd = unavgd - lam2d
   aavgd = aavgd + lam2d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam1d
   sfaced = sfaced - lam1d
   aavgd = aavgd + lam1d
   ELSE
   sfaced = sfaced + lam1d
   unavgd = unavgd - lam1d
   aavgd = aavgd - lam1d
   END IF
   tmp = one/max2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tmpd = 0.0_8
   ELSE
   tmpd = sfacej(i, j, k)*sfaced
   sfaced = 0.0_8
   END IF
   alphaavgd = alphaavgd + havgd
   tempd9 = half*alphaavgd
   tempd8 = ovgm1*havgd
   aavgd = aavgd - one*ovaavgd/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgd = tempd8 - one*ova2avgd/a2avg**2
   ELSE
   a2avgd = aavgd/(2.0*SQRT(a2avg)) + tempd8 - one*ova2avgd/&
   &             a2avg**2
   END IF
   uavgd = uavgd + 2*uavg*tempd9 + sx*unavgd
   sxd = sxd + uavg*unavgd
   vavgd = vavgd + 2*vavg*tempd9 + sy*unavgd
   syd = syd + vavg*unavgd
   wavgd = wavgd + 2*wavg*tempd9 + sz*unavgd
   szd = szd + wavg*unavgd
   CALL POPREAL8(aavg)
   ovgm1d = (a2avg-gm53*kavg)*havgd
   gm53d = gm53d - kavg*tempd8
   kavgd = -(gm53*tempd8)
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tmpd = tmpd + sy*syd + sx*sxd + sz*szd
   szd = tmp*szd
   syd = tmp*syd
   sxd = tmp*sxd
   max2d = -(one*tmpd/max2**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max2)
   aread = aread + max2d
   ELSE
   CALL POPREAL8(max2)
   END IF
   gm1d = gm1d - one*ovgm1d/gm1**2
   CALL POPREAL8(area)
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempd5 = 0.0
   ELSE
   tempd5 = aread/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxd = sxd + 2*sx*tempd5
   syd = syd + 2*sy*tempd5
   szd = szd + 2*sz*tempd5
   CALL POPREAL8(sz)
   sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
   CALL POPREAL8(a2avg)
   temp10 = w(i, j, k, irho)
   temp9 = w(i, j+1, k, irho)
   temp8 = p(i, j+1, k)
   temp7 = gamma(i, j+1, k)
   tempd6 = half*a2avgd/temp9
   tempd7 = half*a2avgd/temp10
   gammad(i, j+1, k) = gammad(i, j+1, k) + temp8*tempd6
   pd(i, j+1, k) = pd(i, j+1, k) + temp7*tempd6
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - temp7*temp8*tempd6&
   &           /temp9
   gammad(i, j, k) = gammad(i, j, k) + p(i, j, k)*tempd7
   pd(i, j, k) = pd(i, j, k) + gamma(i, j, k)*tempd7
   wd(i, j, k, irho) = wd(i, j, k, irho) - gamma(i, j, k)*p(i, j&
   &           , k)*tempd7/temp10
   wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wavgd
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
   wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vavgd
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
   wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*uavgd
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
   gammaavgd = gm1d + gm53d
   gammad(i, j+1, k) = gammad(i, j+1, k) + half*gammaavgd
   gammad(i, j, k) = gammad(i, j, k) + half*gammaavgd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(kavg)
   CALL POPREAL8(drk)
   dis2d = 0.0_8
   ELSE
   CALL POPREAL8(kavg)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*kavgd
   CALL POPREAL8(drk)
   dis2d = ddw*drkd
   ddwd = dis2*drkd
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, &
   &             itu1)*ddwd
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + w(i, j+1, k, &
   &             irho)*ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
   &             ddwd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
   &             ddwd
   ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
   END IF
   CALL POPREAL8(dre)
   dis2d = dis2d + ddw*dred
   ddwd = dis2*dred
   CALL POPREAL8(ddw)
   wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddwd
   wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
   CALL POPREAL8(drw)
   dis2d = dis2d + ddw*drwd
   ddwd = dis2*drwd
   CALL POPREAL8(ddw)
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
   &           ddwd
   wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
   CALL POPREAL8(drv)
   dis2d = dis2d + ddw*drvd
   ddwd = dis2*drvd
   CALL POPREAL8(ddw)
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
   &           ddwd
   wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
   CALL POPREAL8(dru)
   dis2d = dis2d + ddw*drud
   ddwd = dis2*drud
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
   &           ddwd
   wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
   ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
   CALL POPREAL8(dr)
   dis2d = dis2d + ddw*drd
   ddwd = dis2*drd
   CALL POPREAL8(ddw)
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
   CALL POPREAL8(dis2)
   min2d = fis2*ppor*dis2d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y2d = min2d
   ELSE
   y2d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dp2d = dp2d + y2d
   dp1d = 0.0_8
   ELSE
   dp1d = y2d
   END IF
   CALL POPREAL8(ppor)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x4d = dp2d
   ELSE
   x4d = -dp2d
   END IF
   temp6 = omega*(shocksensor(i, j+2, k)+two*shocksensor(i, j+1, &
   &           k)+shocksensor(i, j, k)) + oneminomega*(abs4+abs10) + plim
   plimd = plimd - (shocksensor(i, j+2, k)-two*shocksensor(i, j+1&
   &           , k)+shocksensor(i, j, k))*x4d/temp6**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs10)
   ELSE
   CALL POPREAL8(abs10)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs4)
   ELSE
   CALL POPREAL8(abs4)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x3d = dp1d
   ELSE
   x3d = -dp1d
   END IF
   temp5 = omega*(shocksensor(i, 2, k)+two*shocksensor(i, 1, k)+&
   &         shocksensor(i, 0, k)) + oneminomega*(abs3+abs9) + plim
   plimd = plimd - (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
   &         shocksensor(i, 0, k))*x3d/temp5**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs9)
   ELSE
   CALL POPREAL8(abs9)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs3)
   ELSE
   CALL POPREAL8(abs3)
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   dp1d = 0.0_8
   DO i=il,1,-1
   dp2d = dp1d
   fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
   wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
   gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
   uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
   unavg = uavg*sx + vavg*sy + wavg*sz
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   gm53 = gammaavg - five*third
   ovaavg = one/aavg
   ova2avg = one/a2avg
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ovgm1 = one/gm1
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
   lam3d = dre*fsd
   dred = lam3*fsd
   havgd = abv6*fsd
   abv6d = havg*fsd
   unavgd = abv7*fsd
   abv7d = unavg*fsd
   fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
   lam3d = lam3d + drw*fsd
   drwd = lam3*fsd
   wavgd = abv6*fsd
   abv6d = abv6d + wavg*fsd
   szd = abv7*fsd
   abv7d = abv7d + sz*fsd
   fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
   lam3d = lam3d + drv*fsd
   drvd = lam3*fsd
   vavgd = abv6*fsd
   abv6d = abv6d + vavg*fsd
   syd = abv7*fsd
   abv7d = abv7d + sy*fsd
   fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
   lam3d = lam3d + dru*fsd
   drud = lam3*fsd
   uavgd = abv6*fsd
   abv6d = abv6d + uavg*fsd
   sxd = abv7*fsd
   abv7d = abv7d + sx*fsd
   fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
   abv6d = abv6d + fsd
   abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
   abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
   ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
   abv3d = ova2avg*abv4*abv6d + abv5*abv7d
   lam3d = lam3d + dr*fsd - abv3d
   abv5d = ovaavg*abv2*abv6d + abv3*abv7d
   ova2avgd = abv3*abv4*abv6d
   sxd = sxd + dru*abv5d
   syd = syd + drv*abv5d
   szd = szd + drw*abv5d
   unavgd = unavgd - dr*abv5d
   CALL POPREAL8(abv4)
   tempd4 = gm1*abv4d
   drd = alphaavg*tempd4 - unavg*abv5d + lam3*fsd
   drud = drud + sx*abv5d - uavg*tempd4
   drvd = drvd + sy*abv5d - vavg*tempd4
   drwd = drwd + sz*abv5d - wavg*tempd4
   gm1d = (alphaavg*dr-uavg*dru-vavg*drv+dre-wavg*drw)*abv4d
   alphaavgd = dr*tempd4
   uavgd = uavgd - dru*tempd4
   vavgd = vavgd - drv*tempd4
   dred = dred + tempd4
   wavgd = wavgd - drw*tempd4
   gm53d = -(drk*abv4d)
   drkd = -(gm53*abv4d)
   CALL POPREAL8(abv3)
   abv1d = abv3d
   CALL POPREAL8(abv2)
   lam1d = half*abv1d + half*abv2d
   lam2d = half*abv1d - half*abv2d
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
   lam3d = area*lam3d
   lam2d = area*lam2d
   lam1d = area*lam1d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = epsshear*lam3d
   lam3d = 0.0_8
   ELSE
   rradd = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = rradd + epsacoustic*lam2d
   lam2d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradd = rradd + epsacoustic*lam1d
   lam1d = 0.0_8
   END IF
   lam3d = lam3d + rradd
   aavgd = rradd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   unavgd = unavgd + lam3d
   sfaced = sfaced - lam3d
   ELSE
   CALL POPREAL8(lam3)
   sfaced = sfaced + lam3d
   unavgd = unavgd - lam3d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam2d
   sfaced = sfaced - lam2d
   aavgd = aavgd - lam2d
   ELSE
   sfaced = sfaced + lam2d
   unavgd = unavgd - lam2d
   aavgd = aavgd + lam2d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam1d
   sfaced = sfaced - lam1d
   aavgd = aavgd + lam1d
   ELSE
   sfaced = sfaced + lam1d
   unavgd = unavgd - lam1d
   aavgd = aavgd - lam1d
   END IF
   tmp = one/max1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tmpd = 0.0_8
   ELSE
   tmpd = sfacei(i, j, k)*sfaced
   sfaced = 0.0_8
   END IF
   alphaavgd = alphaavgd + havgd
   tempd3 = half*alphaavgd
   tempd2 = ovgm1*havgd
   aavgd = aavgd - one*ovaavgd/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgd = tempd2 - one*ova2avgd/a2avg**2
   ELSE
   a2avgd = aavgd/(2.0*SQRT(a2avg)) + tempd2 - one*ova2avgd/&
   &             a2avg**2
   END IF
   uavgd = uavgd + 2*uavg*tempd3 + sx*unavgd
   sxd = sxd + uavg*unavgd
   vavgd = vavgd + 2*vavg*tempd3 + sy*unavgd
   syd = syd + vavg*unavgd
   wavgd = wavgd + 2*wavg*tempd3 + sz*unavgd
   szd = szd + wavg*unavgd
   CALL POPREAL8(aavg)
   ovgm1d = (a2avg-gm53*kavg)*havgd
   gm53d = gm53d - kavg*tempd2
   kavgd = -(gm53*tempd2)
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tmpd = tmpd + sy*syd + sx*sxd + sz*szd
   szd = tmp*szd
   syd = tmp*syd
   sxd = tmp*sxd
   max1d = -(one*tmpd/max1**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max1)
   aread = aread + max1d
   ELSE
   CALL POPREAL8(max1)
   END IF
   gm1d = gm1d - one*ovgm1d/gm1**2
   CALL POPREAL8(area)
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempd = 0.0
   ELSE
   tempd = aread/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxd = sxd + 2*sx*tempd
   syd = syd + 2*sy*tempd
   szd = szd + 2*sz*tempd
   CALL POPREAL8(sz)
   sid(i, j, k, 3) = sid(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   sid(i, j, k, 2) = sid(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
   CALL POPREAL8(a2avg)
   temp4 = w(i, j, k, irho)
   temp3 = w(i+1, j, k, irho)
   temp2 = p(i+1, j, k)
   temp1 = gamma(i+1, j, k)
   tempd0 = half*a2avgd/temp3
   tempd1 = half*a2avgd/temp4
   gammad(i+1, j, k) = gammad(i+1, j, k) + temp2*tempd0
   pd(i+1, j, k) = pd(i+1, j, k) + temp1*tempd0
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - temp1*temp2*tempd0&
   &           /temp3
   gammad(i, j, k) = gammad(i, j, k) + p(i, j, k)*tempd1
   pd(i, j, k) = pd(i, j, k) + gamma(i, j, k)*tempd1
   wd(i, j, k, irho) = wd(i, j, k, irho) - gamma(i, j, k)*p(i, j&
   &           , k)*tempd1/temp4
   wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wavgd
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
   wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vavgd
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
   wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*uavgd
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
   gammaavgd = gm1d + gm53d
   gammad(i+1, j, k) = gammad(i+1, j, k) + half*gammaavgd
   gammad(i, j, k) = gammad(i, j, k) + half*gammaavgd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(kavg)
   CALL POPREAL8(drk)
   dis2d = 0.0_8
   ELSE
   CALL POPREAL8(kavg)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*kavgd
   CALL POPREAL8(drk)
   dis2d = ddw*drkd
   ddwd = dis2*drkd
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, &
   &             itu1)*ddwd
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + w(i+1, j, k, &
   &             irho)*ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
   &             ddwd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
   &             ddwd
   ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
   END IF
   CALL POPREAL8(dre)
   dis2d = dis2d + ddw*dred
   ddwd = dis2*dred
   CALL POPREAL8(ddw)
   wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddwd
   wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
   CALL POPREAL8(drw)
   dis2d = dis2d + ddw*drwd
   ddwd = dis2*drwd
   CALL POPREAL8(ddw)
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
   &           ddwd
   wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
   CALL POPREAL8(drv)
   dis2d = dis2d + ddw*drvd
   ddwd = dis2*drvd
   CALL POPREAL8(ddw)
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
   &           ddwd
   wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
   CALL POPREAL8(dru)
   dis2d = dis2d + ddw*drud
   ddwd = dis2*drud
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
   &           ddwd
   wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)*&
   &           ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
   ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
   CALL POPREAL8(dr)
   dis2d = dis2d + ddw*drd
   ddwd = dis2*drd
   CALL POPREAL8(ddw)
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddwd
   wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
   CALL POPREAL8(dis2)
   min1d = fis2*ppor*dis2d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y1d = min1d
   ELSE
   y1d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dp2d = dp2d + y1d
   dp1d = 0.0_8
   ELSE
   dp1d = y1d
   END IF
   CALL POPREAL8(ppor)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x2d = dp2d
   ELSE
   x2d = -dp2d
   END IF
   temp0 = omega*(shocksensor(i+2, j, k)+two*shocksensor(i+1, j, &
   &           k)+shocksensor(i, j, k)) + oneminomega*(abs2+abs8) + plim
   plimd = plimd - (shocksensor(i+2, j, k)-two*shocksensor(i+1, j&
   &           , k)+shocksensor(i, j, k))*x2d/temp0**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs8)
   ELSE
   CALL POPREAL8(abs8)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs2)
   ELSE
   CALL POPREAL8(abs2)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x1d = dp1d
   ELSE
   x1d = -dp1d
   END IF
   temp = omega*(shocksensor(2, j, k)+two*shocksensor(1, j, k)+&
   &         shocksensor(0, j, k)) + oneminomega*(abs1+abs7) + plim
   plimd = plimd - (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
   &         shocksensor(0, j, k))*x1d/temp**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs7)
   ELSE
   CALL POPREAL8(abs7)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs1)
   ELSE
   CALL POPREAL8(abs1)
   END IF
   END DO
   END DO
   pinfcorrd = 0.001_realType*plimd
   END IF
   END SUBROUTINE INVISCIDDISSFLUXMATRIXAPPROX_B

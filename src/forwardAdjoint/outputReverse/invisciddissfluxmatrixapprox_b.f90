   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of invisciddissfluxmatrixapprox in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *p *gamma *w *si *sj *sk *fw
   !   with respect to varying inputs: *p *gamma *w *si *sj *sk pinfcorr
   !   Plus diff mem management of: p:in gamma:in w:in si:in sj:in
   !                sk:in fw:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidDissFluxMatrixApprox.f90                *
   !      * Author:        Gaetan K.W. Kenway                              *
   !      * Starting date: 12-02-2014                                      *
   !      * Last modified: 12-02-2014                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDDISSFLUXMATRIXAPPROX_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidDissFluxMatrix computes the matrix artificial          *
   !      * dissipation term. Instead of the spectral radius, as used in   *
   !      * the scalar dissipation scheme, the absolute value of the flux  *
   !      * jacobian is used. This leads to a less diffusive and           *
   !      * consequently more accurate scheme. It is assumed that the      *
   !      * pointers in blockPointers already point to the correct block.  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE CGNSGRID
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      Local parameters.
   !
   REAL(kind=realtype), PARAMETER :: dpmax=0.25_realType
   REAL(kind=realtype), PARAMETER :: epsacoustic=0.25_realType
   REAL(kind=realtype), PARAMETER :: epsshear=0.025_realType
   REAL(kind=realtype), PARAMETER :: omega=0.5_realType
   REAL(kind=realtype), PARAMETER :: oneminomega=one-omega
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ind
   REAL(kind=realtype) :: plim, sface
   REAL(kind=realtype) :: plimb, sfaceb
   REAL(kind=realtype) :: sfil, fis2, fis4
   REAL(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
   REAL(kind=realtype) :: gammaavgb, gm1b, ovgm1b, gm53b
   REAL(kind=realtype) :: ppor, rrad, dis2
   REAL(kind=realtype) :: rradb, dis2b
   REAL(kind=realtype) :: dp1, dp2, ddw, tmp, fs
   REAL(kind=realtype) :: dp1b, dp2b, ddwb, tmpb, fsb
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
   REAL(kind=realtype) :: drb, drub, drvb, drwb, dreb, drkb, sxb, syb, &
   & szb
   REAL(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
   REAL(kind=realtype) :: uavgb, vavgb, wavgb, a2avgb, aavgb, havgb
   REAL(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
   REAL(kind=realtype) :: alphaavgb, unavgb, ovaavgb, ova2avgb
   REAL(kind=realtype) :: kavg, lam1, lam2, lam3, area
   REAL(kind=realtype) :: kavgb, lam1b, lam2b, lam3b, areab
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype) :: abv1b, abv2b, abv3b, abv4b, abv5b, abv6b, abv7b
   LOGICAL :: correctfork
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC MIN
   INTRINSIC SQRT
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: x3b
   REAL(kind=realtype) :: y1b
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: x6b
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: min3
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: min2
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: max2b
   REAL(kind=realtype) :: min1
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb16
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb15
   REAL(kind=realtype) :: tempb14
   REAL(kind=realtype) :: tempb13
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: tempb10
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: min1b
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x2b
   REAL(kind=realtype) :: temp16
   REAL(kind=realtype) :: temp15
   REAL(kind=realtype) :: temp14
   REAL(kind=realtype) :: temp13
   REAL(kind=realtype) :: x5b
   REAL(kind=realtype) :: temp12
   REAL(kind=realtype) :: temp11
   REAL(kind=realtype) :: y3b
   REAL(kind=realtype) :: temp10
   REAL(kind=realtype) :: max1b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: abs12
   REAL(kind=realtype) :: abs11
   REAL(kind=realtype) :: abs10
   REAL(kind=realtype) :: x1b
   REAL(kind=realtype) :: min3b
   REAL(kind=realtype) :: x4b
   REAL(kind=realtype) :: y2b
   REAL(kind=realtype) :: abs9
   REAL(kind=realtype) :: abs8
   REAL(kind=realtype) :: abs7
   REAL(kind=realtype) :: abs6
   REAL(kind=realtype) :: abs5
   REAL(kind=realtype) :: abs4
   REAL(kind=realtype) :: abs3
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: max3b
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: min2b
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: temp4
   IF (rfil .GE. 0.) THEN
   abs0 = rfil
   ELSE
   abs0 = -rfil
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check if rFil == 0. If so, the dissipative flux needs not to
   ! be computed.
   IF (abs0 .LT. thresholdreal) THEN
   pinfcorrb = 0.0_8
   ELSE
   ! Set the value of plim. To be fully consistent this must have
   ! the dimension of a pressure. Therefore a fraction of pInfCorr
   ! is used.
   plim = 0.001_realType*pinfcorr
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .EQ. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   ! Initialize sface to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set a couple of constants for the scheme.
   fis2 = rfil*vis2
   fis4 = rfil*vis4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the i-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   IF (shocksensor(2, j, k) - shocksensor(1, j, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs1)
   abs1 = shocksensor(2, j, k) - shocksensor(1, j, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs1)
   abs1 = -(shocksensor(2, j, k)-shocksensor(1, j, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(1, j, k) - shocksensor(0, j, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs7)
   abs7 = shocksensor(1, j, k) - shocksensor(0, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs7)
   abs7 = -(shocksensor(1, j, k)-shocksensor(0, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x1 = (shocksensor(2, j, k)-two*shocksensor(1, j, k)+shocksensor(&
   &         0, j, k))/(omega*(shocksensor(2, j, k)+two*shocksensor(1, j, k&
   &         )+shocksensor(0, j, k))+oneminomega*(abs1+abs7)+plim)
   IF (x1 .GE. 0.) THEN
   dp1 = x1
   CALL PUSHCONTROL1B(0)
   ELSE
   dp1 = -x1
   CALL PUSHCONTROL1B(1)
   END IF
   ! Loop in i-direction.
   DO i=1,il
   IF (shocksensor(i+2, j, k) - shocksensor(i+1, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs2)
   abs2 = shocksensor(i+2, j, k) - shocksensor(i+1, j, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs2)
   abs2 = -(shocksensor(i+2, j, k)-shocksensor(i+1, j, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i+1, j, k) - shocksensor(i, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs8)
   abs8 = shocksensor(i+1, j, k) - shocksensor(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs8)
   abs8 = -(shocksensor(i+1, j, k)-shocksensor(i, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x2 = (shocksensor(i+2, j, k)-two*shocksensor(i+1, j, k)+&
   &           shocksensor(i, j, k))/(omega*(shocksensor(i+2, j, k)+two*&
   &           shocksensor(i+1, j, k)+shocksensor(i, j, k))+oneminomega*(&
   &           abs2+abs8)+plim)
   IF (x2 .GE. 0.) THEN
   dp2 = x2
   CALL PUSHCONTROL1B(0)
   ELSE
   dp2 = -x2
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the dissipation coefficients for this face.
   CALL PUSHREAL8(ppor)
   ppor = zero
   IF (pori(i, j, k) .EQ. normalflux) ppor = one
   IF (dp1 .LT. dp2) THEN
   y1 = dp2
   CALL PUSHCONTROL1B(0)
   ELSE
   y1 = dp1
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dpmax .GT. y1) THEN
   min1 = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   min1 = dpmax
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*ppor*min1 + sigma*fis4*ppor
   ! Construct the vector of the first and third differences
   ! multiplied by the appropriate constants.
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
   CALL PUSHREAL8(dr)
   dr = dis2*ddw
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*&
   &           w(i, j, k, ivx)
   CALL PUSHREAL8(dru)
   dru = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*&
   &           w(i, j, k, ivy)
   CALL PUSHREAL8(drv)
   drv = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*&
   &           w(i, j, k, ivz)
   CALL PUSHREAL8(drw)
   drw = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
   CALL PUSHREAL8(dre)
   dre = dis2*ddw
   ! In case a k-equation is present, compute the difference
   ! of rhok and store the average value of k. If not present,
   ! set both these values to zero, such that later on no
   ! decision needs to be made anymore.
   IF (correctfork) THEN
   ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
   &             irho)*w(i, j, k, itu1)
   CALL PUSHREAL8(drk)
   drk = dis2*ddw
   CALL PUSHREAL8(kavg)
   kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(drk)
   drk = zero
   CALL PUSHREAL8(kavg)
   kavg = zero
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the average value of gamma and compute some
   ! expressions in which it occurs.
   gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   gm53 = gammaavg - five*third
   ! Compute the average state at the interface.
   uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
   vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
   wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
   CALL PUSHREAL8(a2avg)
   a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)&
   &           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
   CALL PUSHREAL8(sx)
   sx = si(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = si(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = si(i, j, k, 3)
   CALL PUSHREAL8(area)
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   CALL PUSHREAL8(max1)
   max1 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max1)
   max1 = 1.e-25_realType
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = one/max1
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   CALL PUSHREAL8(aavg)
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ! The mesh velocity if the face is moving. It must be
   ! divided by the area to obtain a true velocity.
   IF (addgridvelocities) THEN
   sface = sfacei(i, j, k)*tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   IF (unavg - sface + aavg .GE. 0.) THEN
   lam1 = unavg - sface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-sface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface - aavg .GE. 0.) THEN
   lam2 = unavg - sface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-sface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface .GE. 0.) THEN
   CALL PUSHREAL8(lam3)
   lam3 = unavg - sface
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(lam3)
   lam3 = -(unavg-sface)
   CALL PUSHCONTROL1B(1)
   END IF
   rrad = lam3 + aavg
   IF (lam1 .LT. epsacoustic*rrad) THEN
   lam1 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam1 = lam1
   END IF
   IF (lam2 .LT. epsacoustic*rrad) THEN
   lam2 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam2 = lam2
   END IF
   IF (lam3 .LT. epsshear*rrad) THEN
   lam3 = epsshear*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = lam3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   CALL PUSHREAL8(abv2)
   abv2 = half*(lam1-lam2)
   CALL PUSHREAL8(abv3)
   abv3 = abv1 - lam3
   CALL PUSHREAL8(abv4)
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
   &           *drk
   ! Compute and scatter the dissipative flux.
   ! Density.
   ! X-momentum.
   ! Y-momentum.
   ! Z-momentum.
   ! Energy.
   ! Set dp1 to dp2 for the next face.
   dp1 = dp2
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the j-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO i=2,il
   IF (shocksensor(i, 2, k) - shocksensor(i, 1, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs3)
   abs3 = shocksensor(i, 2, k) - shocksensor(i, 1, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs3)
   abs3 = -(shocksensor(i, 2, k)-shocksensor(i, 1, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, 1, k) - shocksensor(i, 0, k) .GE. 0.) THEN
   CALL PUSHREAL8(abs9)
   abs9 = shocksensor(i, 1, k) - shocksensor(i, 0, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs9)
   abs9 = -(shocksensor(i, 1, k)-shocksensor(i, 0, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x3 = (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+shocksensor(&
   &         i, 0, k))/(omega*(shocksensor(i, 2, k)+two*shocksensor(i, 1, k&
   &         )+shocksensor(i, 0, k))+oneminomega*(abs3+abs9)+plim)
   IF (x3 .GE. 0.) THEN
   dp1 = x3
   CALL PUSHCONTROL1B(0)
   ELSE
   dp1 = -x3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Loop in j-direction.
   DO j=1,jl
   IF (shocksensor(i, j+2, k) - shocksensor(i, j+1, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs4)
   abs4 = shocksensor(i, j+2, k) - shocksensor(i, j+1, k)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs4)
   abs4 = -(shocksensor(i, j+2, k)-shocksensor(i, j+1, k))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, j+1, k) - shocksensor(i, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs10)
   abs10 = shocksensor(i, j+1, k) - shocksensor(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs10)
   abs10 = -(shocksensor(i, j+1, k)-shocksensor(i, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x4 = (shocksensor(i, j+2, k)-two*shocksensor(i, j+1, k)+&
   &           shocksensor(i, j, k))/(omega*(shocksensor(i, j+2, k)+two*&
   &           shocksensor(i, j+1, k)+shocksensor(i, j, k))+oneminomega*(&
   &           abs4+abs10)+plim)
   IF (x4 .GE. 0.) THEN
   dp2 = x4
   CALL PUSHCONTROL1B(0)
   ELSE
   dp2 = -x4
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the dissipation coefficients for this face.
   CALL PUSHREAL8(ppor)
   ppor = zero
   IF (porj(i, j, k) .EQ. normalflux) ppor = one
   IF (dp1 .LT. dp2) THEN
   y2 = dp2
   CALL PUSHCONTROL1B(0)
   ELSE
   y2 = dp1
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dpmax .GT. y2) THEN
   min2 = y2
   CALL PUSHCONTROL1B(0)
   ELSE
   min2 = dpmax
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*ppor*min2 + sigma*fis4*ppor
   ! Construct the vector of the first and third differences
   ! multiplied by the appropriate constants.
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
   CALL PUSHREAL8(dr)
   dr = dis2*ddw
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*&
   &           w(i, j, k, ivx)
   CALL PUSHREAL8(dru)
   dru = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*&
   &           w(i, j, k, ivy)
   CALL PUSHREAL8(drv)
   drv = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*&
   &           w(i, j, k, ivz)
   CALL PUSHREAL8(drw)
   drw = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
   CALL PUSHREAL8(dre)
   dre = dis2*ddw
   ! In case a k-equation is present, compute the difference
   ! of rhok and store the average value of k. If not present,
   ! set both these values to zero, such that later on no
   ! decision needs to be made anymore.
   IF (correctfork) THEN
   ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
   &             irho)*w(i, j, k, itu1)
   CALL PUSHREAL8(drk)
   drk = dis2*ddw
   CALL PUSHREAL8(kavg)
   kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(drk)
   drk = zero
   CALL PUSHREAL8(kavg)
   kavg = zero
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the average value of gamma and compute some
   ! expressions in which it occurs.
   gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   gm53 = gammaavg - five*third
   ! Compute the average state at the interface.
   uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
   vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
   wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
   CALL PUSHREAL8(a2avg)
   a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)&
   &           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
   CALL PUSHREAL8(sx)
   sx = sj(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sj(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sj(i, j, k, 3)
   CALL PUSHREAL8(area)
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   CALL PUSHREAL8(max2)
   max2 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max2)
   max2 = 1.e-25_realType
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = one/max2
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   CALL PUSHREAL8(aavg)
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ! The mesh velocity if the face is moving. It must be
   ! divided by the area to obtain a true velocity.
   IF (addgridvelocities) THEN
   sface = sfacej(i, j, k)*tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   IF (unavg - sface + aavg .GE. 0.) THEN
   lam1 = unavg - sface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-sface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface - aavg .GE. 0.) THEN
   lam2 = unavg - sface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-sface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface .GE. 0.) THEN
   CALL PUSHREAL8(lam3)
   lam3 = unavg - sface
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(lam3)
   lam3 = -(unavg-sface)
   CALL PUSHCONTROL1B(1)
   END IF
   rrad = lam3 + aavg
   IF (lam1 .LT. epsacoustic*rrad) THEN
   lam1 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam1 = lam1
   END IF
   IF (lam2 .LT. epsacoustic*rrad) THEN
   lam2 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam2 = lam2
   END IF
   IF (lam3 .LT. epsshear*rrad) THEN
   lam3 = epsshear*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = lam3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   CALL PUSHREAL8(abv2)
   abv2 = half*(lam1-lam2)
   CALL PUSHREAL8(abv3)
   abv3 = abv1 - lam3
   CALL PUSHREAL8(abv4)
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
   &           *drk
   ! Compute and scatter the dissipative flux.
   ! Density.
   ! X-momentum.
   ! Y-momentum.
   ! Z-momentum.
   ! Energy.
   ! Set dp1 to dp2 for the next face.
   dp1 = dp2
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Dissipative fluxes in the k-direction.                         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO j=2,jl
   DO i=2,il
   IF (shocksensor(i, j, 2) - shocksensor(i, j, 1) .GE. 0.) THEN
   CALL PUSHREAL8(abs5)
   abs5 = shocksensor(i, j, 2) - shocksensor(i, j, 1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs5)
   abs5 = -(shocksensor(i, j, 2)-shocksensor(i, j, 1))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, j, 1) - shocksensor(i, j, 0) .GE. 0.) THEN
   CALL PUSHREAL8(abs11)
   abs11 = shocksensor(i, j, 1) - shocksensor(i, j, 0)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs11)
   abs11 = -(shocksensor(i, j, 1)-shocksensor(i, j, 0))
   CALL PUSHCONTROL1B(1)
   END IF
   x5 = (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+shocksensor(&
   &         i, j, 0))/(omega*(shocksensor(i, j, 2)+two*shocksensor(i, j, 1&
   &         )+shocksensor(i, j, 0))+oneminomega*(abs5+abs11)+plim)
   IF (x5 .GE. 0.) THEN
   dp1 = x5
   CALL PUSHCONTROL1B(0)
   ELSE
   dp1 = -x5
   CALL PUSHCONTROL1B(1)
   END IF
   ! Loop in k-direction.
   DO k=1,kl
   IF (shocksensor(i, j, k+2) - shocksensor(i, j, k+1) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs6)
   abs6 = shocksensor(i, j, k+2) - shocksensor(i, j, k+1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(abs6)
   abs6 = -(shocksensor(i, j, k+2)-shocksensor(i, j, k+1))
   CALL PUSHCONTROL1B(0)
   END IF
   IF (shocksensor(i, j, k+1) - shocksensor(i, j, k) .GE. 0.) &
   &         THEN
   CALL PUSHREAL8(abs12)
   abs12 = shocksensor(i, j, k+1) - shocksensor(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(abs12)
   abs12 = -(shocksensor(i, j, k+1)-shocksensor(i, j, k))
   CALL PUSHCONTROL1B(1)
   END IF
   x6 = (shocksensor(i, j, k+2)-two*shocksensor(i, j, k+1)+&
   &           shocksensor(i, j, k))/(omega*(shocksensor(i, j, k+2)+two*&
   &           shocksensor(i, j, k+1)+shocksensor(i, j, k))+oneminomega*(&
   &           abs6+abs12)+plim)
   IF (x6 .GE. 0.) THEN
   dp2 = x6
   CALL PUSHCONTROL1B(0)
   ELSE
   dp2 = -x6
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the dissipation coefficients for this face.
   CALL PUSHREAL8(ppor)
   ppor = zero
   IF (pork(i, j, k) .EQ. normalflux) ppor = one
   IF (dp1 .LT. dp2) THEN
   y3 = dp2
   CALL PUSHCONTROL1B(0)
   ELSE
   y3 = dp1
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dpmax .GT. y3) THEN
   min3 = y3
   CALL PUSHCONTROL1B(0)
   ELSE
   min3 = dpmax
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(dis2)
   dis2 = fis2*ppor*min3 + sigma*fis4*ppor
   ! Construct the vector of the first and third differences
   ! multiplied by the appropriate constants.
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
   CALL PUSHREAL8(dr)
   dr = dis2*ddw
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*&
   &           w(i, j, k, ivx)
   CALL PUSHREAL8(dru)
   dru = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*&
   &           w(i, j, k, ivy)
   CALL PUSHREAL8(drv)
   drv = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*&
   &           w(i, j, k, ivz)
   CALL PUSHREAL8(drw)
   drw = dis2*ddw
   CALL PUSHREAL8(ddw)
   ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
   CALL PUSHREAL8(dre)
   dre = dis2*ddw
   ! In case a k-equation is present, compute the difference
   ! of rhok and store the average value of k. If not present,
   ! set both these values to zero, such that later on no
   ! decision needs to be made anymore.
   IF (correctfork) THEN
   ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
   &             irho)*w(i, j, k, itu1)
   CALL PUSHREAL8(drk)
   drk = dis2*ddw
   CALL PUSHREAL8(kavg)
   kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHREAL8(drk)
   drk = zero
   CALL PUSHREAL8(kavg)
   kavg = zero
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the average value of gamma and compute some
   ! expressions in which it occurs.
   gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
   gm1 = gammaavg - one
   gm53 = gammaavg - five*third
   ! Compute the average state at the interface.
   uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
   vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
   wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
   CALL PUSHREAL8(a2avg)
   a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)&
   &           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
   CALL PUSHREAL8(sx)
   sx = sk(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sk(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sk(i, j, k, 3)
   CALL PUSHREAL8(area)
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   CALL PUSHREAL8(max3)
   max3 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max3)
   max3 = 1.e-25_realType
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = one/max3
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   CALL PUSHREAL8(aavg)
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ! The mesh velocity if the face is moving. It must be
   ! divided by the area to obtain a true velocity.
   IF (addgridvelocities) THEN
   sface = sfacek(i, j, k)*tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   IF (unavg - sface + aavg .GE. 0.) THEN
   lam1 = unavg - sface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-sface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface - aavg .GE. 0.) THEN
   lam2 = unavg - sface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-sface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - sface .GE. 0.) THEN
   CALL PUSHREAL8(lam3)
   lam3 = unavg - sface
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(lam3)
   lam3 = -(unavg-sface)
   CALL PUSHCONTROL1B(1)
   END IF
   rrad = lam3 + aavg
   IF (lam1 .LT. epsacoustic*rrad) THEN
   lam1 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam1 = lam1
   END IF
   IF (lam2 .LT. epsacoustic*rrad) THEN
   lam2 = epsacoustic*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   lam2 = lam2
   END IF
   IF (lam3 .LT. epsshear*rrad) THEN
   lam3 = epsshear*rrad
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = lam3
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   CALL PUSHREAL8(abv2)
   abv2 = half*(lam1-lam2)
   CALL PUSHREAL8(abv3)
   abv3 = abv1 - lam3
   CALL PUSHREAL8(abv4)
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
   &           *drk
   ! Compute and scatter the dissipative flux.
   ! Density.
   ! X-momentum.
   ! Y-momentum.
   ! Z-momentum.
   ! Energy.
   ! Set dp1 to dp2 for the next face.
   dp1 = dp2
   END DO
   END DO
   END DO
   plimb = 0.0_8
   sfaceb = 0.0_8
   DO j=jl,2,-1
   DO i=il,2,-1
   dp1b = 0.0_8
   DO k=kl,1,-1
   dp2b = dp1b
   fsb = fwb(i, j, k+1, irhoe) - fwb(i, j, k, irhoe)
   wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
   gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
   gm1 = gammaavg - one
   vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
   uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
   unavg = uavg*sx + vavg*sy + wavg*sz
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   gm53 = gammaavg - five*third
   ovaavg = one/aavg
   ova2avg = one/a2avg
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ovgm1 = one/gm1
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
   lam3b = dre*fsb
   dreb = lam3*fsb
   havgb = abv6*fsb
   abv6b = havg*fsb
   unavgb = abv7*fsb
   abv7b = unavg*fsb
   fsb = fwb(i, j, k+1, imz) - fwb(i, j, k, imz)
   lam3b = lam3b + drw*fsb
   drwb = lam3*fsb
   wavgb = abv6*fsb
   abv6b = abv6b + wavg*fsb
   szb = abv7*fsb
   abv7b = abv7b + sz*fsb
   fsb = fwb(i, j, k+1, imy) - fwb(i, j, k, imy)
   lam3b = lam3b + drv*fsb
   drvb = lam3*fsb
   vavgb = abv6*fsb
   abv6b = abv6b + vavg*fsb
   syb = abv7*fsb
   abv7b = abv7b + sy*fsb
   fsb = fwb(i, j, k+1, imx) - fwb(i, j, k, imx)
   lam3b = lam3b + dru*fsb
   drub = lam3*fsb
   uavgb = abv6*fsb
   abv6b = abv6b + uavg*fsb
   sxb = abv7*fsb
   abv7b = abv7b + sx*fsb
   fsb = fwb(i, j, k+1, irho) - fwb(i, j, k, irho)
   abv6b = abv6b + fsb
   abv2b = ovaavg*abv5*abv6b + ovaavg*abv4*abv7b
   abv4b = ova2avg*abv3*abv6b + ovaavg*abv2*abv7b
   ovaavgb = abv2*abv5*abv6b + abv2*abv4*abv7b
   abv3b = ova2avg*abv4*abv6b + abv5*abv7b
   lam3b = lam3b + dr*fsb - abv3b
   abv5b = ovaavg*abv2*abv6b + abv3*abv7b
   ova2avgb = abv3*abv4*abv6b
   sxb = sxb + dru*abv5b
   syb = syb + drv*abv5b
   szb = szb + drw*abv5b
   unavgb = unavgb - dr*abv5b
   CALL POPREAL8(abv4)
   tempb16 = gm1*abv4b
   drb = alphaavg*tempb16 - unavg*abv5b + lam3*fsb
   drub = drub + sx*abv5b - uavg*tempb16
   drvb = drvb + sy*abv5b - vavg*tempb16
   drwb = drwb + sz*abv5b - wavg*tempb16
   gm1b = (alphaavg*dr-uavg*dru-vavg*drv+dre-wavg*drw)*abv4b
   alphaavgb = dr*tempb16
   uavgb = uavgb - dru*tempb16
   vavgb = vavgb - drv*tempb16
   dreb = dreb + tempb16
   wavgb = wavgb - drw*tempb16
   gm53b = -(drk*abv4b)
   drkb = -(gm53*abv4b)
   CALL POPREAL8(abv3)
   abv1b = abv3b
   CALL POPREAL8(abv2)
   lam1b = half*abv1b + half*abv2b
   lam2b = half*abv1b - half*abv2b
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   areab = lam2*lam2b + lam1*lam1b + lam3*lam3b
   lam3b = area*lam3b
   lam2b = area*lam2b
   lam1b = area*lam1b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = epsshear*lam3b
   lam3b = 0.0_8
   ELSE
   rradb = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = rradb + epsacoustic*lam2b
   lam2b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = rradb + epsacoustic*lam1b
   lam1b = 0.0_8
   END IF
   lam3b = lam3b + rradb
   aavgb = rradb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   unavgb = unavgb + lam3b
   sfaceb = sfaceb - lam3b
   ELSE
   CALL POPREAL8(lam3)
   sfaceb = sfaceb + lam3b
   unavgb = unavgb - lam3b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam2b
   sfaceb = sfaceb - lam2b
   aavgb = aavgb - lam2b
   ELSE
   sfaceb = sfaceb + lam2b
   unavgb = unavgb - lam2b
   aavgb = aavgb + lam2b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam1b
   sfaceb = sfaceb - lam1b
   aavgb = aavgb + lam1b
   ELSE
   sfaceb = sfaceb + lam1b
   unavgb = unavgb - lam1b
   aavgb = aavgb - lam1b
   END IF
   tmp = one/max3
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tmpb = 0.0_8
   ELSE
   tmpb = sfacek(i, j, k)*sfaceb
   sfaceb = 0.0_8
   END IF
   alphaavgb = alphaavgb + havgb
   tempb15 = half*alphaavgb
   tempb14 = ovgm1*havgb
   aavgb = aavgb - one*ovaavgb/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgb = tempb14 - one*ova2avgb/a2avg**2
   ELSE
   a2avgb = aavgb/(2.0*SQRT(a2avg)) + tempb14 - one*ova2avgb/&
   &             a2avg**2
   END IF
   uavgb = uavgb + 2*uavg*tempb15 + sx*unavgb
   sxb = sxb + uavg*unavgb
   vavgb = vavgb + 2*vavg*tempb15 + sy*unavgb
   syb = syb + vavg*unavgb
   wavgb = wavgb + 2*wavg*tempb15 + sz*unavgb
   szb = szb + wavg*unavgb
   CALL POPREAL8(aavg)
   ovgm1b = (a2avg-gm53*kavg)*havgb
   gm53b = gm53b - kavg*tempb14
   kavgb = -(gm53*tempb14)
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tmpb = tmpb + sy*syb + sx*sxb + sz*szb
   szb = tmp*szb
   syb = tmp*syb
   sxb = tmp*sxb
   max3b = -(one*tmpb/max3**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max3)
   areab = areab + max3b
   ELSE
   CALL POPREAL8(max3)
   END IF
   gm1b = gm1b - one*ovgm1b/gm1**2
   CALL POPREAL8(area)
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempb11 = 0.0
   ELSE
   tempb11 = areab/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxb = sxb + 2*sx*tempb11
   syb = syb + 2*sy*tempb11
   szb = szb + 2*sz*tempb11
   CALL POPREAL8(sz)
   skb(i, j, k, 3) = skb(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   skb(i, j, k, 2) = skb(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   skb(i, j, k, 1) = skb(i, j, k, 1) + sxb
   CALL POPREAL8(a2avg)
   temp16 = w(i, j, k, irho)
   temp15 = w(i, j, k+1, irho)
   temp14 = p(i, j, k+1)
   temp13 = gamma(i, j, k+1)
   tempb12 = half*a2avgb/temp15
   tempb13 = half*a2avgb/temp16
   gammab(i, j, k+1) = gammab(i, j, k+1) + temp14*tempb12
   pb(i, j, k+1) = pb(i, j, k+1) + temp13*tempb12
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) - temp13*temp14*&
   &           tempb12/temp15
   gammab(i, j, k) = gammab(i, j, k) + p(i, j, k)*tempb13
   pb(i, j, k) = pb(i, j, k) + gamma(i, j, k)*tempb13
   wb(i, j, k, irho) = wb(i, j, k, irho) - gamma(i, j, k)*p(i, j&
   &           , k)*tempb13/temp16
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + half*wavgb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + half*wavgb
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + half*vavgb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + half*vavgb
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + half*uavgb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + half*uavgb
   gammaavgb = gm1b + gm53b
   gammab(i, j, k+1) = gammab(i, j, k+1) + half*gammaavgb
   gammab(i, j, k) = gammab(i, j, k) + half*gammaavgb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(kavg)
   CALL POPREAL8(drk)
   dis2b = 0.0_8
   ELSE
   CALL POPREAL8(kavg)
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + half*kavgb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*kavgb
   CALL POPREAL8(drk)
   dis2b = ddw*drkb
   ddwb = dis2*drkb
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + w(i, j, k+1, &
   &             itu1)*ddwb
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + w(i, j, k+1, &
   &             irho)*ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, itu1)*&
   &             ddwb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - w(i, j, k, irho)*&
   &             ddwb
   ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
   END IF
   CALL POPREAL8(dre)
   dis2b = dis2b + ddw*dreb
   ddwb = dis2*dreb
   CALL POPREAL8(ddw)
   wb(i, j, k+1, irhoe) = wb(i, j, k+1, irhoe) + ddwb
   wb(i, j, k, irhoe) = wb(i, j, k, irhoe) - ddwb
   CALL POPREAL8(drw)
   dis2b = dis2b + ddw*drwb
   ddwb = dis2*drwb
   CALL POPREAL8(ddw)
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
   &           ddwb
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + w(i, j, k+1, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivz)*ddwb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) - w(i, j, k, irho)*ddwb
   CALL POPREAL8(drv)
   dis2b = dis2b + ddw*drvb
   ddwb = dis2*drvb
   CALL POPREAL8(ddw)
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
   &           ddwb
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + w(i, j, k+1, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivy)*ddwb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) - w(i, j, k, irho)*ddwb
   CALL POPREAL8(dru)
   dis2b = dis2b + ddw*drub
   ddwb = dis2*drub
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
   &           ddwb
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + w(i, j, k+1, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivx)*ddwb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) - w(i, j, k, irho)*ddwb
   ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
   CALL POPREAL8(dr)
   dis2b = dis2b + ddw*drb
   ddwb = dis2*drb
   CALL POPREAL8(ddw)
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - ddwb
   CALL POPREAL8(dis2)
   min3b = fis2*ppor*dis2b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y3b = min3b
   ELSE
   y3b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dp2b = dp2b + y3b
   dp1b = 0.0_8
   ELSE
   dp1b = y3b
   END IF
   CALL POPREAL8(ppor)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x6b = dp2b
   ELSE
   x6b = -dp2b
   END IF
   temp12 = omega*(shocksensor(i, j, k+2)+two*shocksensor(i, j, k&
   &           +1)+shocksensor(i, j, k)) + oneminomega*(abs6+abs12) + plim
   plimb = plimb - (shocksensor(i, j, k+2)-two*shocksensor(i, j, &
   &           k+1)+shocksensor(i, j, k))*x6b/temp12**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs12)
   ELSE
   CALL POPREAL8(abs12)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs6)
   ELSE
   CALL POPREAL8(abs6)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x5b = dp1b
   ELSE
   x5b = -dp1b
   END IF
   temp11 = omega*(shocksensor(i, j, 2)+two*shocksensor(i, j, 1)+&
   &         shocksensor(i, j, 0)) + oneminomega*(abs5+abs11) + plim
   plimb = plimb - (shocksensor(i, j, 2)-two*shocksensor(i, j, 1)+&
   &         shocksensor(i, j, 0))*x5b/temp11**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs11)
   ELSE
   CALL POPREAL8(abs11)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs5)
   ELSE
   CALL POPREAL8(abs5)
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO i=il,2,-1
   dp1b = 0.0_8
   DO j=jl,1,-1
   dp2b = dp1b
   fsb = fwb(i, j+1, k, irhoe) - fwb(i, j, k, irhoe)
   wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
   gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
   uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
   unavg = uavg*sx + vavg*sy + wavg*sz
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   gm53 = gammaavg - five*third
   ovaavg = one/aavg
   ova2avg = one/a2avg
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ovgm1 = one/gm1
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
   lam3b = dre*fsb
   dreb = lam3*fsb
   havgb = abv6*fsb
   abv6b = havg*fsb
   unavgb = abv7*fsb
   abv7b = unavg*fsb
   fsb = fwb(i, j+1, k, imz) - fwb(i, j, k, imz)
   lam3b = lam3b + drw*fsb
   drwb = lam3*fsb
   wavgb = abv6*fsb
   abv6b = abv6b + wavg*fsb
   szb = abv7*fsb
   abv7b = abv7b + sz*fsb
   fsb = fwb(i, j+1, k, imy) - fwb(i, j, k, imy)
   lam3b = lam3b + drv*fsb
   drvb = lam3*fsb
   vavgb = abv6*fsb
   abv6b = abv6b + vavg*fsb
   syb = abv7*fsb
   abv7b = abv7b + sy*fsb
   fsb = fwb(i, j+1, k, imx) - fwb(i, j, k, imx)
   lam3b = lam3b + dru*fsb
   drub = lam3*fsb
   uavgb = abv6*fsb
   abv6b = abv6b + uavg*fsb
   sxb = abv7*fsb
   abv7b = abv7b + sx*fsb
   fsb = fwb(i, j+1, k, irho) - fwb(i, j, k, irho)
   abv6b = abv6b + fsb
   abv2b = ovaavg*abv5*abv6b + ovaavg*abv4*abv7b
   abv4b = ova2avg*abv3*abv6b + ovaavg*abv2*abv7b
   ovaavgb = abv2*abv5*abv6b + abv2*abv4*abv7b
   abv3b = ova2avg*abv4*abv6b + abv5*abv7b
   lam3b = lam3b + dr*fsb - abv3b
   abv5b = ovaavg*abv2*abv6b + abv3*abv7b
   ova2avgb = abv3*abv4*abv6b
   sxb = sxb + dru*abv5b
   syb = syb + drv*abv5b
   szb = szb + drw*abv5b
   unavgb = unavgb - dr*abv5b
   CALL POPREAL8(abv4)
   tempb10 = gm1*abv4b
   drb = alphaavg*tempb10 - unavg*abv5b + lam3*fsb
   drub = drub + sx*abv5b - uavg*tempb10
   drvb = drvb + sy*abv5b - vavg*tempb10
   drwb = drwb + sz*abv5b - wavg*tempb10
   gm1b = (alphaavg*dr-uavg*dru-vavg*drv+dre-wavg*drw)*abv4b
   alphaavgb = dr*tempb10
   uavgb = uavgb - dru*tempb10
   vavgb = vavgb - drv*tempb10
   dreb = dreb + tempb10
   wavgb = wavgb - drw*tempb10
   gm53b = -(drk*abv4b)
   drkb = -(gm53*abv4b)
   CALL POPREAL8(abv3)
   abv1b = abv3b
   CALL POPREAL8(abv2)
   lam1b = half*abv1b + half*abv2b
   lam2b = half*abv1b - half*abv2b
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   areab = lam2*lam2b + lam1*lam1b + lam3*lam3b
   lam3b = area*lam3b
   lam2b = area*lam2b
   lam1b = area*lam1b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = epsshear*lam3b
   lam3b = 0.0_8
   ELSE
   rradb = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = rradb + epsacoustic*lam2b
   lam2b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = rradb + epsacoustic*lam1b
   lam1b = 0.0_8
   END IF
   lam3b = lam3b + rradb
   aavgb = rradb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   unavgb = unavgb + lam3b
   sfaceb = sfaceb - lam3b
   ELSE
   CALL POPREAL8(lam3)
   sfaceb = sfaceb + lam3b
   unavgb = unavgb - lam3b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam2b
   sfaceb = sfaceb - lam2b
   aavgb = aavgb - lam2b
   ELSE
   sfaceb = sfaceb + lam2b
   unavgb = unavgb - lam2b
   aavgb = aavgb + lam2b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam1b
   sfaceb = sfaceb - lam1b
   aavgb = aavgb + lam1b
   ELSE
   sfaceb = sfaceb + lam1b
   unavgb = unavgb - lam1b
   aavgb = aavgb - lam1b
   END IF
   tmp = one/max2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tmpb = 0.0_8
   ELSE
   tmpb = sfacej(i, j, k)*sfaceb
   sfaceb = 0.0_8
   END IF
   alphaavgb = alphaavgb + havgb
   tempb9 = half*alphaavgb
   tempb8 = ovgm1*havgb
   aavgb = aavgb - one*ovaavgb/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgb = tempb8 - one*ova2avgb/a2avg**2
   ELSE
   a2avgb = aavgb/(2.0*SQRT(a2avg)) + tempb8 - one*ova2avgb/&
   &             a2avg**2
   END IF
   uavgb = uavgb + 2*uavg*tempb9 + sx*unavgb
   sxb = sxb + uavg*unavgb
   vavgb = vavgb + 2*vavg*tempb9 + sy*unavgb
   syb = syb + vavg*unavgb
   wavgb = wavgb + 2*wavg*tempb9 + sz*unavgb
   szb = szb + wavg*unavgb
   CALL POPREAL8(aavg)
   ovgm1b = (a2avg-gm53*kavg)*havgb
   gm53b = gm53b - kavg*tempb8
   kavgb = -(gm53*tempb8)
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tmpb = tmpb + sy*syb + sx*sxb + sz*szb
   szb = tmp*szb
   syb = tmp*syb
   sxb = tmp*sxb
   max2b = -(one*tmpb/max2**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max2)
   areab = areab + max2b
   ELSE
   CALL POPREAL8(max2)
   END IF
   gm1b = gm1b - one*ovgm1b/gm1**2
   CALL POPREAL8(area)
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempb5 = 0.0
   ELSE
   tempb5 = areab/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxb = sxb + 2*sx*tempb5
   syb = syb + 2*sy*tempb5
   szb = szb + 2*sz*tempb5
   CALL POPREAL8(sz)
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + sxb
   CALL POPREAL8(a2avg)
   temp10 = w(i, j, k, irho)
   temp9 = w(i, j+1, k, irho)
   temp8 = p(i, j+1, k)
   temp7 = gamma(i, j+1, k)
   tempb6 = half*a2avgb/temp9
   tempb7 = half*a2avgb/temp10
   gammab(i, j+1, k) = gammab(i, j+1, k) + temp8*tempb6
   pb(i, j+1, k) = pb(i, j+1, k) + temp7*tempb6
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) - temp7*temp8*tempb6&
   &           /temp9
   gammab(i, j, k) = gammab(i, j, k) + p(i, j, k)*tempb7
   pb(i, j, k) = pb(i, j, k) + gamma(i, j, k)*tempb7
   wb(i, j, k, irho) = wb(i, j, k, irho) - gamma(i, j, k)*p(i, j&
   &           , k)*tempb7/temp10
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + half*wavgb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + half*wavgb
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + half*vavgb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + half*vavgb
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + half*uavgb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + half*uavgb
   gammaavgb = gm1b + gm53b
   gammab(i, j+1, k) = gammab(i, j+1, k) + half*gammaavgb
   gammab(i, j, k) = gammab(i, j, k) + half*gammaavgb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(kavg)
   CALL POPREAL8(drk)
   dis2b = 0.0_8
   ELSE
   CALL POPREAL8(kavg)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*kavgb
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + half*kavgb
   CALL POPREAL8(drk)
   dis2b = ddw*drkb
   ddwb = dis2*drkb
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + w(i, j+1, k, &
   &             itu1)*ddwb
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + w(i, j+1, k, &
   &             irho)*ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, itu1)*&
   &             ddwb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - w(i, j, k, irho)*&
   &             ddwb
   ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
   END IF
   CALL POPREAL8(dre)
   dis2b = dis2b + ddw*dreb
   ddwb = dis2*dreb
   CALL POPREAL8(ddw)
   wb(i, j+1, k, irhoe) = wb(i, j+1, k, irhoe) + ddwb
   wb(i, j, k, irhoe) = wb(i, j, k, irhoe) - ddwb
   CALL POPREAL8(drw)
   dis2b = dis2b + ddw*drwb
   ddwb = dis2*drwb
   CALL POPREAL8(ddw)
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
   &           ddwb
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + w(i, j+1, k, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivz)*ddwb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) - w(i, j, k, irho)*ddwb
   CALL POPREAL8(drv)
   dis2b = dis2b + ddw*drvb
   ddwb = dis2*drvb
   CALL POPREAL8(ddw)
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
   &           ddwb
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + w(i, j+1, k, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivy)*ddwb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) - w(i, j, k, irho)*ddwb
   CALL POPREAL8(dru)
   dis2b = dis2b + ddw*drub
   ddwb = dis2*drub
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
   &           ddwb
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + w(i, j+1, k, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivx)*ddwb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) - w(i, j, k, irho)*ddwb
   ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
   CALL POPREAL8(dr)
   dis2b = dis2b + ddw*drb
   ddwb = dis2*drb
   CALL POPREAL8(ddw)
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - ddwb
   CALL POPREAL8(dis2)
   min2b = fis2*ppor*dis2b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y2b = min2b
   ELSE
   y2b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dp2b = dp2b + y2b
   dp1b = 0.0_8
   ELSE
   dp1b = y2b
   END IF
   CALL POPREAL8(ppor)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x4b = dp2b
   ELSE
   x4b = -dp2b
   END IF
   temp6 = omega*(shocksensor(i, j+2, k)+two*shocksensor(i, j+1, &
   &           k)+shocksensor(i, j, k)) + oneminomega*(abs4+abs10) + plim
   plimb = plimb - (shocksensor(i, j+2, k)-two*shocksensor(i, j+1&
   &           , k)+shocksensor(i, j, k))*x4b/temp6**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs10)
   ELSE
   CALL POPREAL8(abs10)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs4)
   ELSE
   CALL POPREAL8(abs4)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x3b = dp1b
   ELSE
   x3b = -dp1b
   END IF
   temp5 = omega*(shocksensor(i, 2, k)+two*shocksensor(i, 1, k)+&
   &         shocksensor(i, 0, k)) + oneminomega*(abs3+abs9) + plim
   plimb = plimb - (shocksensor(i, 2, k)-two*shocksensor(i, 1, k)+&
   &         shocksensor(i, 0, k))*x3b/temp5**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs9)
   ELSE
   CALL POPREAL8(abs9)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs3)
   ELSE
   CALL POPREAL8(abs3)
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   dp1b = 0.0_8
   DO i=il,1,-1
   dp2b = dp1b
   fsb = fwb(i+1, j, k, irhoe) - fwb(i, j, k, irhoe)
   wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
   gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
   gm1 = gammaavg - one
   vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
   uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
   unavg = uavg*sx + vavg*sy + wavg*sz
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   gm53 = gammaavg - five*third
   ovaavg = one/aavg
   ova2avg = one/a2avg
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ovgm1 = one/gm1
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
   lam3b = dre*fsb
   dreb = lam3*fsb
   havgb = abv6*fsb
   abv6b = havg*fsb
   unavgb = abv7*fsb
   abv7b = unavg*fsb
   fsb = fwb(i+1, j, k, imz) - fwb(i, j, k, imz)
   lam3b = lam3b + drw*fsb
   drwb = lam3*fsb
   wavgb = abv6*fsb
   abv6b = abv6b + wavg*fsb
   szb = abv7*fsb
   abv7b = abv7b + sz*fsb
   fsb = fwb(i+1, j, k, imy) - fwb(i, j, k, imy)
   lam3b = lam3b + drv*fsb
   drvb = lam3*fsb
   vavgb = abv6*fsb
   abv6b = abv6b + vavg*fsb
   syb = abv7*fsb
   abv7b = abv7b + sy*fsb
   fsb = fwb(i+1, j, k, imx) - fwb(i, j, k, imx)
   lam3b = lam3b + dru*fsb
   drub = lam3*fsb
   uavgb = abv6*fsb
   abv6b = abv6b + uavg*fsb
   sxb = abv7*fsb
   abv7b = abv7b + sx*fsb
   fsb = fwb(i+1, j, k, irho) - fwb(i, j, k, irho)
   abv6b = abv6b + fsb
   abv2b = ovaavg*abv5*abv6b + ovaavg*abv4*abv7b
   abv4b = ova2avg*abv3*abv6b + ovaavg*abv2*abv7b
   ovaavgb = abv2*abv5*abv6b + abv2*abv4*abv7b
   abv3b = ova2avg*abv4*abv6b + abv5*abv7b
   lam3b = lam3b + dr*fsb - abv3b
   abv5b = ovaavg*abv2*abv6b + abv3*abv7b
   ova2avgb = abv3*abv4*abv6b
   sxb = sxb + dru*abv5b
   syb = syb + drv*abv5b
   szb = szb + drw*abv5b
   unavgb = unavgb - dr*abv5b
   CALL POPREAL8(abv4)
   tempb4 = gm1*abv4b
   drb = alphaavg*tempb4 - unavg*abv5b + lam3*fsb
   drub = drub + sx*abv5b - uavg*tempb4
   drvb = drvb + sy*abv5b - vavg*tempb4
   drwb = drwb + sz*abv5b - wavg*tempb4
   gm1b = (alphaavg*dr-uavg*dru-vavg*drv+dre-wavg*drw)*abv4b
   alphaavgb = dr*tempb4
   uavgb = uavgb - dru*tempb4
   vavgb = vavgb - drv*tempb4
   dreb = dreb + tempb4
   wavgb = wavgb - drw*tempb4
   gm53b = -(drk*abv4b)
   drkb = -(gm53*abv4b)
   CALL POPREAL8(abv3)
   abv1b = abv3b
   CALL POPREAL8(abv2)
   lam1b = half*abv1b + half*abv2b
   lam2b = half*abv1b - half*abv2b
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   areab = lam2*lam2b + lam1*lam1b + lam3*lam3b
   lam3b = area*lam3b
   lam2b = area*lam2b
   lam1b = area*lam1b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = epsshear*lam3b
   lam3b = 0.0_8
   ELSE
   rradb = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = rradb + epsacoustic*lam2b
   lam2b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rradb = rradb + epsacoustic*lam1b
   lam1b = 0.0_8
   END IF
   lam3b = lam3b + rradb
   aavgb = rradb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   unavgb = unavgb + lam3b
   sfaceb = sfaceb - lam3b
   ELSE
   CALL POPREAL8(lam3)
   sfaceb = sfaceb + lam3b
   unavgb = unavgb - lam3b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam2b
   sfaceb = sfaceb - lam2b
   aavgb = aavgb - lam2b
   ELSE
   sfaceb = sfaceb + lam2b
   unavgb = unavgb - lam2b
   aavgb = aavgb + lam2b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam1b
   sfaceb = sfaceb - lam1b
   aavgb = aavgb + lam1b
   ELSE
   sfaceb = sfaceb + lam1b
   unavgb = unavgb - lam1b
   aavgb = aavgb - lam1b
   END IF
   tmp = one/max1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tmpb = 0.0_8
   ELSE
   tmpb = sfacei(i, j, k)*sfaceb
   sfaceb = 0.0_8
   END IF
   alphaavgb = alphaavgb + havgb
   tempb3 = half*alphaavgb
   tempb2 = ovgm1*havgb
   aavgb = aavgb - one*ovaavgb/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgb = tempb2 - one*ova2avgb/a2avg**2
   ELSE
   a2avgb = aavgb/(2.0*SQRT(a2avg)) + tempb2 - one*ova2avgb/&
   &             a2avg**2
   END IF
   uavgb = uavgb + 2*uavg*tempb3 + sx*unavgb
   sxb = sxb + uavg*unavgb
   vavgb = vavgb + 2*vavg*tempb3 + sy*unavgb
   syb = syb + vavg*unavgb
   wavgb = wavgb + 2*wavg*tempb3 + sz*unavgb
   szb = szb + wavg*unavgb
   CALL POPREAL8(aavg)
   ovgm1b = (a2avg-gm53*kavg)*havgb
   gm53b = gm53b - kavg*tempb2
   kavgb = -(gm53*tempb2)
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tmpb = tmpb + sy*syb + sx*sxb + sz*szb
   szb = tmp*szb
   syb = tmp*syb
   sxb = tmp*sxb
   max1b = -(one*tmpb/max1**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max1)
   areab = areab + max1b
   ELSE
   CALL POPREAL8(max1)
   END IF
   gm1b = gm1b - one*ovgm1b/gm1**2
   CALL POPREAL8(area)
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempb = 0.0
   ELSE
   tempb = areab/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxb = sxb + 2*sx*tempb
   syb = syb + 2*sy*tempb
   szb = szb + 2*sz*tempb
   CALL POPREAL8(sz)
   sib(i, j, k, 3) = sib(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   sib(i, j, k, 2) = sib(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   sib(i, j, k, 1) = sib(i, j, k, 1) + sxb
   CALL POPREAL8(a2avg)
   temp4 = w(i, j, k, irho)
   temp3 = w(i+1, j, k, irho)
   temp2 = p(i+1, j, k)
   temp1 = gamma(i+1, j, k)
   tempb0 = half*a2avgb/temp3
   tempb1 = half*a2avgb/temp4
   gammab(i+1, j, k) = gammab(i+1, j, k) + temp2*tempb0
   pb(i+1, j, k) = pb(i+1, j, k) + temp1*tempb0
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) - temp1*temp2*tempb0&
   &           /temp3
   gammab(i, j, k) = gammab(i, j, k) + p(i, j, k)*tempb1
   pb(i, j, k) = pb(i, j, k) + gamma(i, j, k)*tempb1
   wb(i, j, k, irho) = wb(i, j, k, irho) - gamma(i, j, k)*p(i, j&
   &           , k)*tempb1/temp4
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + half*wavgb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + half*wavgb
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + half*vavgb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + half*vavgb
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + half*uavgb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + half*uavgb
   gammaavgb = gm1b + gm53b
   gammab(i+1, j, k) = gammab(i+1, j, k) + half*gammaavgb
   gammab(i, j, k) = gammab(i, j, k) + half*gammaavgb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(kavg)
   CALL POPREAL8(drk)
   dis2b = 0.0_8
   ELSE
   CALL POPREAL8(kavg)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*kavgb
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + half*kavgb
   CALL POPREAL8(drk)
   dis2b = ddw*drkb
   ddwb = dis2*drkb
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + w(i+1, j, k, &
   &             itu1)*ddwb
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + w(i+1, j, k, &
   &             irho)*ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, itu1)*&
   &             ddwb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - w(i, j, k, irho)*&
   &             ddwb
   ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
   END IF
   CALL POPREAL8(dre)
   dis2b = dis2b + ddw*dreb
   ddwb = dis2*dreb
   CALL POPREAL8(ddw)
   wb(i+1, j, k, irhoe) = wb(i+1, j, k, irhoe) + ddwb
   wb(i, j, k, irhoe) = wb(i, j, k, irhoe) - ddwb
   CALL POPREAL8(drw)
   dis2b = dis2b + ddw*drwb
   ddwb = dis2*drwb
   CALL POPREAL8(ddw)
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
   &           ddwb
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + w(i+1, j, k, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivz)*ddwb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) - w(i, j, k, irho)*ddwb
   CALL POPREAL8(drv)
   dis2b = dis2b + ddw*drvb
   ddwb = dis2*drvb
   CALL POPREAL8(ddw)
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
   &           ddwb
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + w(i+1, j, k, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivy)*ddwb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) - w(i, j, k, irho)*ddwb
   CALL POPREAL8(dru)
   dis2b = dis2b + ddw*drub
   ddwb = dis2*drub
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
   &           ddwb
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + w(i+1, j, k, irho)*&
   &           ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - w(i, j, k, ivx)*ddwb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) - w(i, j, k, irho)*ddwb
   ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
   CALL POPREAL8(dr)
   dis2b = dis2b + ddw*drb
   ddwb = dis2*drb
   CALL POPREAL8(ddw)
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + ddwb
   wb(i, j, k, irho) = wb(i, j, k, irho) - ddwb
   CALL POPREAL8(dis2)
   min1b = fis2*ppor*dis2b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y1b = min1b
   ELSE
   y1b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dp2b = dp2b + y1b
   dp1b = 0.0_8
   ELSE
   dp1b = y1b
   END IF
   CALL POPREAL8(ppor)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x2b = dp2b
   ELSE
   x2b = -dp2b
   END IF
   temp0 = omega*(shocksensor(i+2, j, k)+two*shocksensor(i+1, j, &
   &           k)+shocksensor(i, j, k)) + oneminomega*(abs2+abs8) + plim
   plimb = plimb - (shocksensor(i+2, j, k)-two*shocksensor(i+1, j&
   &           , k)+shocksensor(i, j, k))*x2b/temp0**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs8)
   ELSE
   CALL POPREAL8(abs8)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs2)
   ELSE
   CALL POPREAL8(abs2)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x1b = dp1b
   ELSE
   x1b = -dp1b
   END IF
   temp = omega*(shocksensor(2, j, k)+two*shocksensor(1, j, k)+&
   &         shocksensor(0, j, k)) + oneminomega*(abs1+abs7) + plim
   plimb = plimb - (shocksensor(2, j, k)-two*shocksensor(1, j, k)+&
   &         shocksensor(0, j, k))*x1b/temp**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs7)
   ELSE
   CALL POPREAL8(abs7)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(abs1)
   ELSE
   CALL POPREAL8(abs1)
   END IF
   END DO
   END DO
   pinfcorrb = 0.001_realType*plimb
   END IF
   END SUBROUTINE INVISCIDDISSFLUXMATRIXAPPROX_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of sasolve in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *dw *w *rlv *vol *si *sj *sk
   !                (global)timeref
   !   with respect to varying inputs: *dw *w *rlv *vol *d2wall *si
   !                *sj *sk (global)timeref
   !   Plus diff mem management of: dw:in w:in rlv:in vol:in d2wall:in
   !                si:in sj:in sk:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          saSolve.f90                                     *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide,           *
   !      *                Steve Repsher (blanking)                        *
   !      * Starting date: 06-11-2003                                      *
   !      * Last modified: 07-05-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE SASOLVE_B(resonly)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * saSolve solves the turbulent transport equation for the        *
   !      * original Spalart-Allmaras model in a segregated manner using   *
   !      * a diagonal dominant ADI-scheme.                                *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE INPUTITERATION
   USE INPUTPHYSICS
   USE PARAMTURB
   USE TURBMOD
   IMPLICIT NONE
   ! Don't need the remainder for residual derivative
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: resonly
   !
   !      Local parameters.
   !
   REAL(kind=realtype), PARAMETER :: xminn=1.e-10_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, nn
   REAL(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
   REAL(kind=realtype) :: fv1, fv2, ft2
   REAL(kind=realtype) :: fv1d, fv2d, ft2d
   REAL(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
   REAL(kind=realtype) :: ssd, sstd, nud, dist2invd, chid, chi2d, chi3d
   REAL(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
   REAL(kind=realtype) :: rrd, ggd, gg6d, termfwd, fwsad, term1d, term2d
   REAL(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
   REAL(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
   REAL(kind=realtype) :: volid, volmid, volpid, xmd, ymd, zmd, xpd, ypd&
   & , zpd
   REAL(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
   REAL(kind=realtype) :: xad, yad, zad, ttmd, ttpd, cnudd, camd, capd
   REAL(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
   REAL(kind=realtype) :: nutmd, nutpd, numd, nupd, cdmd, cdpd
   REAL(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
   REAL(kind=realtype) :: c1md, c1pd, c10d
   REAL(kind=realtype) :: uu, um, up, factor, f, tu1p, rblank
   REAL(kind=realtype), DIMENSION(2:il, 2:jl, 2:kl) :: qq
   REAL(kind=realtype), DIMENSION(2:MAX(kl, il, jl)) :: bb, cc, dd, ff
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ddw, ww, ddvt
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
   LOGICAL, DIMENSION(2:jl, 2:kl), TARGET :: flagi2, flagil
   LOGICAL, DIMENSION(2:il, 2:kl), TARGET :: flagj2, flagjl
   LOGICAL, DIMENSION(2:il, 2:jl), TARGET :: flagk2, flagkl
   LOGICAL, DIMENSION(:, :), POINTER :: flag
   INTRINSIC MAX
   INTRINSIC SQRT
   INTRINSIC EXP
   INTRINSIC MIN
   INTRINSIC REAL
   REAL(kind=realtype) :: tmp
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: tempd14
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: tempd13
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: tempd12
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd11
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: temp17
   REAL(kind=realtype) :: temp16
   REAL(kind=realtype) :: temp15
   REAL(kind=realtype) :: temp14
   REAL(kind=realtype) :: temp13
   REAL(kind=realtype) :: temp12
   REAL(kind=realtype) :: temp11
   REAL(kind=realtype) :: temp10
   REAL(kind=realtype) :: tempd32
   REAL(kind=realtype) :: tempd31
   REAL(kind=realtype) :: tempd30
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tempd29
   REAL(kind=realtype) :: tempd28
   REAL(kind=realtype) :: tempd27
   REAL(kind=realtype) :: tempd26
   REAL(kind=realtype) :: tempd25
   REAL(kind=realtype) :: tempd24
   REAL(kind=realtype) :: tempd23
   REAL(kind=realtype) :: tempd22
   REAL(kind=realtype) :: tempd21
   REAL(kind=realtype) :: tempd20
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: tempd19
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: tempd18
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: tempd17
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: tempd16
   REAL(kind=realtype) :: temp4
   REAL(kind=realtype) :: tempd15
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Set model constants
   cv13 = rsacv1**3
   kar2inv = one/rsak**2
   cw36 = rsacw3**6
   cb3inv = one/rsacb3
   ! Set the pointer for dvt in dw, such that the code is more
   ! readable. Also set the pointers for the production term
   ! and vorticity.
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Production term.                                               *
   !      *                                                                *
   !      ******************************************************************
   !
   SELECT CASE  (turbprod) 
   CASE (strain) 
   CALL PRODSMAG2()
   CALL PUSHCONTROL2B(2)
   CASE (vorticity) 
   CALL PRODWMAG2()
   CALL PUSHCONTROL2B(1)
   CASE (katolaunder) 
   CALL PRODKATOLAUNDER()
   CALL PUSHCONTROL2B(0)
   CASE DEFAULT
   CALL PUSHCONTROL2B(3)
   END SELECT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Source terms.                                                  *
   !      *                                                                *
   !      * Determine the source term and its derivative w.r.t. nuTilde    *
   !      * for all internal cells of the block.                           *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! First take the square root of the production term to
   ! obtain the correct production term for spalart-allmaras.
   CALL PUSHREAL8(ss)
   ss = SQRT(dw(i, j, k, iprod))
   ! Compute the laminar kinematic viscosity, the inverse of
   ! wall distance squared, the ratio chi (ratio of nuTilde
   ! and nu) and the functions fv1 and fv2. The latter corrects
   ! the production term near a viscous wall.
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   dist2inv = one/d2wall(i, j, k)**2
   CALL PUSHREAL8(chi)
   chi = w(i, j, k, itu1)/nu
   CALL PUSHREAL8(chi2)
   chi2 = chi*chi
   CALL PUSHREAL8(chi3)
   chi3 = chi*chi2
   CALL PUSHREAL8(fv1)
   fv1 = chi3/(chi3+cv13)
   fv2 = one - chi/(one+chi*fv1)
   ! The function ft2, which is designed to keep a laminar
   ! solution laminar. When running in fully turbulent mode
   ! this function should be set to 0.0.
   CALL PUSHREAL8(ft2)
   ft2 = rsact3*EXP(-(rsact4*chi2))
   ! ft2 = zero
   ! Correct the production term to account for the influence
   ! of the wall. Make sure that this term remains positive
   ! (the function fv2 is negative between chi = 1 and 18.4,
   ! which can cause sst to go negative, which is undesirable).
   CALL PUSHREAL8(sst)
   sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
   IF (sst .LT. xminn) THEN
   sst = xminn
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   sst = sst
   END IF
   ! Compute the function fw. The argument rr is cut off at 10
   ! to avoid numerical problems. This is ok, because the
   ! asymptotical value of fw is then already reached.
   CALL PUSHREAL8(rr)
   rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
   IF (rr .GT. 10.0_realType) THEN
   rr = 10.0_realType
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   rr = rr
   END IF
   gg = rr + rsacw2*(rr**6-rr)
   gg6 = gg**6
   termfw = ((one+cw36)/(gg6+cw36))**sixth
   fwsa = gg*termfw
   ! Compute the source term; some terms are saved for the
   ! linearization. The source term is stored in dvt.
   term1 = rsacb1*(one-ft2)*ss
   term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
   &         )
   CALL PUSHREAL8(dw(i, j, k, idvt))
   dw(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, k, &
   &         itu1)
   ! Compute some derivatives w.r.t. nuTilde. These will occur
   ! in the left hand side, i.e. the matrix for the implicit
   ! treatment.
   dfv1 = three*chi2*cv13/(chi3+cv13)**2
   dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
   dft2 = -(two*rsact4*chi*ft2/nu)
   drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
   dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
   dfw = cw36/(gg6+cw36)*termfw*dgg
   ! Compute the source term jacobian. Note that the part
   ! containing term1 is treated explicitly. The reason is that
   ! implicit treatment of this part leads to a decrease of the
   ! diagonal dominance of the jacobian and it thus decreases
   ! the stability. You may want to play around and try to
   ! take this term into account in the jacobian.
   ! Note that -dsource/dnu is stored.
   qq(i, j, k) = -(two*term2*w(i, j, k, itu1)) - dist2inv*w(i, j, k&
   &         , itu1)*w(i, j, k, itu1)*(rsacb1*kar2inv*(dfv2-ft2*dfv2-fv2*&
   &         dft2+dft2)-rsacw1*dfw)
   IF (qq(i, j, k) .LT. zero) THEN
   qq(i, j, k) = zero
   ELSE
   qq(i, j, k) = qq(i, j, k)
   END IF
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Advection and unsteady terms.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   nn = itu1 - 1
   CALL PUSHREAL8ARRAY(dw, SIZE(dw, 1)*SIZE(dw, 2)*SIZE(dw, 3)*SIZE(dw, 4&
   &               ))
   CALL TURBADVECTION(1_intType, 1_intType, nn, qq)
   CALL UNSTEADYTURBTERM(1_intType, 1_intType, nn, qq)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in k-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in zeta-direction, i.e. along the
   ! line k = constant.
   CALL PUSHREAL8(voli)
   voli = one/vol(i, j, k)
   CALL PUSHREAL8(volmi)
   volmi = two/(vol(i, j, k)+vol(i, j, k-1))
   CALL PUSHREAL8(volpi)
   volpi = two/(vol(i, j, k)+vol(i, j, k+1))
   CALL PUSHREAL8(xm)
   xm = sk(i, j, k-1, 1)*volmi
   CALL PUSHREAL8(ym)
   ym = sk(i, j, k-1, 2)*volmi
   CALL PUSHREAL8(zm)
   zm = sk(i, j, k-1, 3)*volmi
   CALL PUSHREAL8(xp)
   xp = sk(i, j, k, 1)*volpi
   CALL PUSHREAL8(yp)
   yp = sk(i, j, k, 2)*volpi
   CALL PUSHREAL8(zp)
   zp = sk(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in zeta-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in zeta-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! k+1, k and k-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   CALL PUSHREAL8(cnud)
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   CALL PUSHREAL8(nutm)
   nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nutp)
   nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   CALL PUSHREAL8(num)
   num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
   CALL PUSHREAL8(nup)
   nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j, k-1, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in j-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in eta-direction, i.e. along the
   ! line j = constant.
   CALL PUSHREAL8(voli)
   voli = one/vol(i, j, k)
   CALL PUSHREAL8(volmi)
   volmi = two/(vol(i, j, k)+vol(i, j-1, k))
   CALL PUSHREAL8(volpi)
   volpi = two/(vol(i, j, k)+vol(i, j+1, k))
   CALL PUSHREAL8(xm)
   xm = sj(i, j-1, k, 1)*volmi
   CALL PUSHREAL8(ym)
   ym = sj(i, j-1, k, 2)*volmi
   CALL PUSHREAL8(zm)
   zm = sj(i, j-1, k, 3)*volmi
   CALL PUSHREAL8(xp)
   xp = sj(i, j, k, 1)*volpi
   CALL PUSHREAL8(yp)
   yp = sj(i, j, k, 2)*volpi
   CALL PUSHREAL8(zp)
   zp = sj(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in eta-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in eta-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! j+1, j and j-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   CALL PUSHREAL8(cnud)
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   CALL PUSHREAL8(nutm)
   nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nutp)
   nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   CALL PUSHREAL8(num)
   num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
   CALL PUSHREAL8(nup)
   nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j-1, k, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in i-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in xi-direction, i.e. along the
   ! line i = constant.
   CALL PUSHREAL8(voli)
   voli = one/vol(i, j, k)
   CALL PUSHREAL8(volmi)
   volmi = two/(vol(i, j, k)+vol(i-1, j, k))
   CALL PUSHREAL8(volpi)
   volpi = two/(vol(i, j, k)+vol(i+1, j, k))
   CALL PUSHREAL8(xm)
   xm = si(i-1, j, k, 1)*volmi
   CALL PUSHREAL8(ym)
   ym = si(i-1, j, k, 2)*volmi
   CALL PUSHREAL8(zm)
   zm = si(i-1, j, k, 3)*volmi
   CALL PUSHREAL8(xp)
   xp = si(i, j, k, 1)*volpi
   CALL PUSHREAL8(yp)
   yp = si(i, j, k, 2)*volpi
   CALL PUSHREAL8(zp)
   zp = si(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in xi-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in xi-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! i+1, i and i-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   CALL PUSHREAL8(cnud)
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   CALL PUSHREAL8(nutm)
   nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nutp)
   nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   CALL PUSHREAL8(num)
   num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
   CALL PUSHREAL8(nup)
   nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i-1, j, k, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   END DO
   END DO
   END DO
   ! Multiply the residual by the volume and store this in dw; this
   ! is done for monitoring reasons only. The multiplication with the
   ! volume is present to be consistent with the flow residuals; also
   ! the negative value is taken, again to be consistent with the
   ! flow equations. Also multiply by iblank so that no updates occur
   ! in holes or the overset boundary.
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   CALL PUSHREAL8(rblank)
   rblank = REAL(iblank(i, j, k), realtype)
   tmp = -(vol(i, j, k)*dw(i, j, k, idvt)*rblank)
   CALL PUSHREAL8(dw(i, j, k, itu1))
   dw(i, j, k, itu1) = tmp
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPREAL8(dw(i, j, k, itu1))
   tmpd = dwd(i, j, k, itu1)
   dwd(i, j, k, itu1) = 0.0_8
   vold(i, j, k) = vold(i, j, k) - rblank*dw(i, j, k, idvt)*tmpd
   dwd(i, j, k, idvt) = dwd(i, j, k, idvt) - rblank*vol(i, j, k)*&
   &         tmpd
   CALL POPREAL8(rblank)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   c1md = w(i-1, j, k, itu1)*dwd(i, j, k, idvt)
   wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + c1m*dwd(i, j, k, &
   &         idvt)
   c1pd = w(i+1, j, k, itu1)*dwd(i, j, k, idvt)
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + c1p*dwd(i, j, k, &
   &         idvt)
   c10d = -(w(i, j, k, itu1)*dwd(i, j, k, idvt))
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*dwd(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1md = c1md + c10d
   c1pd = c1pd + c10d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpd = 0.0_8
   capd = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpd = c1pd
   capd = c1pd
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmd = 0.0_8
   camd = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmd = c1md
   camd = c1md
   END IF
   tempd24 = cb3inv*cdpd
   nupd = ttp*tempd24
   nutpd = ttp*(one+rsacb2)*tempd24
   ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd24
   tempd25 = cb3inv*cdmd
   numd = ttm*tempd25
   nutmd = ttm*(one+rsacb2)*tempd25
   ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd25
   CALL POPREAL8(nup)
   temp17 = w(i+1, j, k, irho)
   tempd26 = half*nupd/temp17
   rlvd(i+1, j, k) = rlvd(i+1, j, k) + tempd26
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - rlv(i+1, j, k)*&
   &         tempd26/temp17
   nud = half*numd + half*nupd
   CALL POPREAL8(num)
   temp16 = w(i-1, j, k, irho)
   tempd27 = half*numd/temp16
   rlvd(i-1, j, k) = rlvd(i-1, j, k) + tempd27
   wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - rlv(i-1, j, k)*&
   &         tempd27/temp16
   CALL POPREAL8(nu)
   temp15 = w(i, j, k, irho)
   rlvd(i, j, k) = rlvd(i, j, k) + nud/temp15
   wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp15&
   &         **2
   CALL POPREAL8(nutp)
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*nutpd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
   CALL POPREAL8(nutm)
   wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + half*nutmd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
   cnudd = ttm*camd + ttp*capd
   CALL POPREAL8(cnud)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
   CALL POPREAL8(ttp)
   xpd = xa*ttpd
   xad = xm*ttmd + xp*ttpd
   ypd = ya*ttpd
   yad = ym*ttmd + yp*ttpd
   zpd = za*ttpd
   zad = zm*ttmd + zp*ttpd
   CALL POPREAL8(ttm)
   xmd = xa*ttmd
   ymd = ya*ttmd
   zmd = za*ttmd
   CALL POPREAL8(za)
   tempd28 = half*zad
   sid(i, j, k, 3) = sid(i, j, k, 3) + voli*tempd28
   sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*tempd28
   CALL POPREAL8(ya)
   tempd29 = half*yad
   sid(i, j, k, 2) = sid(i, j, k, 2) + voli*tempd29
   sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*tempd29
   CALL POPREAL8(xa)
   tempd30 = half*xad
   volid = (si(i, j, k, 2)+si(i-1, j, k, 2))*tempd29 + (si(i, j, k&
   &         , 1)+si(i-1, j, k, 1))*tempd30 + (si(i, j, k, 3)+si(i-1, j, k&
   &         , 3))*tempd28
   sid(i, j, k, 1) = sid(i, j, k, 1) + voli*tempd30
   sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*tempd30
   CALL POPREAL8(zp)
   sid(i, j, k, 3) = sid(i, j, k, 3) + volpi*zpd
   volpid = si(i, j, k, 2)*ypd + si(i, j, k, 1)*xpd + si(i, j, k, 3&
   &         )*zpd
   CALL POPREAL8(yp)
   sid(i, j, k, 2) = sid(i, j, k, 2) + volpi*ypd
   CALL POPREAL8(xp)
   sid(i, j, k, 1) = sid(i, j, k, 1) + volpi*xpd
   CALL POPREAL8(zm)
   sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + volmi*zmd
   volmid = si(i-1, j, k, 2)*ymd + si(i-1, j, k, 1)*xmd + si(i-1, j&
   &         , k, 3)*zmd
   CALL POPREAL8(ym)
   sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + volmi*ymd
   CALL POPREAL8(xm)
   sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + volmi*xmd
   CALL POPREAL8(volpi)
   temp14 = vol(i, j, k) + vol(i+1, j, k)
   tempd31 = -(two*volpid/temp14**2)
   vold(i, j, k) = vold(i, j, k) + tempd31
   vold(i+1, j, k) = vold(i+1, j, k) + tempd31
   CALL POPREAL8(volmi)
   temp13 = vol(i, j, k) + vol(i-1, j, k)
   tempd32 = -(two*volmid/temp13**2)
   vold(i, j, k) = vold(i, j, k) + tempd32
   vold(i-1, j, k) = vold(i-1, j, k) + tempd32
   CALL POPREAL8(voli)
   vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   c1md = w(i, j-1, k, itu1)*dwd(i, j, k, idvt)
   wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + c1m*dwd(i, j, k, &
   &         idvt)
   c1pd = w(i, j+1, k, itu1)*dwd(i, j, k, idvt)
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + c1p*dwd(i, j, k, &
   &         idvt)
   c10d = -(w(i, j, k, itu1)*dwd(i, j, k, idvt))
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*dwd(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1md = c1md + c10d
   c1pd = c1pd + c10d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpd = 0.0_8
   capd = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpd = c1pd
   capd = c1pd
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmd = 0.0_8
   camd = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmd = c1md
   camd = c1md
   END IF
   tempd15 = cb3inv*cdpd
   nupd = ttp*tempd15
   nutpd = ttp*(one+rsacb2)*tempd15
   ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd15
   tempd16 = cb3inv*cdmd
   numd = ttm*tempd16
   nutmd = ttm*(one+rsacb2)*tempd16
   ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd16
   CALL POPREAL8(nup)
   temp12 = w(i, j+1, k, irho)
   tempd17 = half*nupd/temp12
   rlvd(i, j+1, k) = rlvd(i, j+1, k) + tempd17
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - rlv(i, j+1, k)*&
   &         tempd17/temp12
   nud = half*numd + half*nupd
   CALL POPREAL8(num)
   temp11 = w(i, j-1, k, irho)
   tempd18 = half*numd/temp11
   rlvd(i, j-1, k) = rlvd(i, j-1, k) + tempd18
   wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - rlv(i, j-1, k)*&
   &         tempd18/temp11
   CALL POPREAL8(nu)
   temp10 = w(i, j, k, irho)
   rlvd(i, j, k) = rlvd(i, j, k) + nud/temp10
   wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp10&
   &         **2
   CALL POPREAL8(nutp)
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*nutpd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
   CALL POPREAL8(nutm)
   wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + half*nutmd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
   cnudd = ttm*camd + ttp*capd
   CALL POPREAL8(cnud)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
   CALL POPREAL8(ttp)
   xpd = xa*ttpd
   xad = xm*ttmd + xp*ttpd
   ypd = ya*ttpd
   yad = ym*ttmd + yp*ttpd
   zpd = za*ttpd
   zad = zm*ttmd + zp*ttpd
   CALL POPREAL8(ttm)
   xmd = xa*ttmd
   ymd = ya*ttmd
   zmd = za*ttmd
   CALL POPREAL8(za)
   tempd19 = half*zad
   sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*tempd19
   sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*tempd19
   CALL POPREAL8(ya)
   tempd20 = half*yad
   sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*tempd20
   sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*tempd20
   CALL POPREAL8(xa)
   tempd21 = half*xad
   volid = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempd20 + (sj(i, j, k&
   &         , 1)+sj(i, j-1, k, 1))*tempd21 + (sj(i, j, k, 3)+sj(i, j-1, k&
   &         , 3))*tempd19
   sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*tempd21
   sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*tempd21
   CALL POPREAL8(zp)
   sjd(i, j, k, 3) = sjd(i, j, k, 3) + volpi*zpd
   volpid = sj(i, j, k, 2)*ypd + sj(i, j, k, 1)*xpd + sj(i, j, k, 3&
   &         )*zpd
   CALL POPREAL8(yp)
   sjd(i, j, k, 2) = sjd(i, j, k, 2) + volpi*ypd
   CALL POPREAL8(xp)
   sjd(i, j, k, 1) = sjd(i, j, k, 1) + volpi*xpd
   CALL POPREAL8(zm)
   sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + volmi*zmd
   volmid = sj(i, j-1, k, 2)*ymd + sj(i, j-1, k, 1)*xmd + sj(i, j-1&
   &         , k, 3)*zmd
   CALL POPREAL8(ym)
   sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + volmi*ymd
   CALL POPREAL8(xm)
   sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + volmi*xmd
   CALL POPREAL8(volpi)
   temp9 = vol(i, j, k) + vol(i, j+1, k)
   tempd22 = -(two*volpid/temp9**2)
   vold(i, j, k) = vold(i, j, k) + tempd22
   vold(i, j+1, k) = vold(i, j+1, k) + tempd22
   CALL POPREAL8(volmi)
   temp8 = vol(i, j, k) + vol(i, j-1, k)
   tempd23 = -(two*volmid/temp8**2)
   vold(i, j, k) = vold(i, j, k) + tempd23
   vold(i, j-1, k) = vold(i, j-1, k) + tempd23
   CALL POPREAL8(voli)
   vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   c1md = w(i, j, k-1, itu1)*dwd(i, j, k, idvt)
   wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + c1m*dwd(i, j, k, &
   &         idvt)
   c1pd = w(i, j, k+1, itu1)*dwd(i, j, k, idvt)
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + c1p*dwd(i, j, k, &
   &         idvt)
   c10d = -(w(i, j, k, itu1)*dwd(i, j, k, idvt))
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*dwd(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1md = c1md + c10d
   c1pd = c1pd + c10d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpd = 0.0_8
   capd = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpd = c1pd
   capd = c1pd
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmd = 0.0_8
   camd = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmd = c1md
   camd = c1md
   END IF
   tempd6 = cb3inv*cdpd
   nupd = ttp*tempd6
   nutpd = ttp*(one+rsacb2)*tempd6
   ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd6
   tempd7 = cb3inv*cdmd
   numd = ttm*tempd7
   nutmd = ttm*(one+rsacb2)*tempd7
   ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd7
   CALL POPREAL8(nup)
   temp7 = w(i, j, k+1, irho)
   tempd8 = half*nupd/temp7
   rlvd(i, j, k+1) = rlvd(i, j, k+1) + tempd8
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - rlv(i, j, k+1)*&
   &         tempd8/temp7
   nud = half*numd + half*nupd
   CALL POPREAL8(num)
   temp6 = w(i, j, k-1, irho)
   tempd9 = half*numd/temp6
   rlvd(i, j, k-1) = rlvd(i, j, k-1) + tempd9
   wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - rlv(i, j, k-1)*&
   &         tempd9/temp6
   CALL POPREAL8(nu)
   temp5 = w(i, j, k, irho)
   rlvd(i, j, k) = rlvd(i, j, k) + nud/temp5
   wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp5**&
   &         2
   CALL POPREAL8(nutp)
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*nutpd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
   CALL POPREAL8(nutm)
   wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + half*nutmd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
   cnudd = ttm*camd + ttp*capd
   CALL POPREAL8(cnud)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
   CALL POPREAL8(ttp)
   xpd = xa*ttpd
   xad = xm*ttmd + xp*ttpd
   ypd = ya*ttpd
   yad = ym*ttmd + yp*ttpd
   zpd = za*ttpd
   zad = zm*ttmd + zp*ttpd
   CALL POPREAL8(ttm)
   xmd = xa*ttmd
   ymd = ya*ttmd
   zmd = za*ttmd
   CALL POPREAL8(za)
   tempd10 = half*zad
   skd(i, j, k, 3) = skd(i, j, k, 3) + voli*tempd10
   skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*tempd10
   CALL POPREAL8(ya)
   tempd11 = half*yad
   skd(i, j, k, 2) = skd(i, j, k, 2) + voli*tempd11
   skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*tempd11
   CALL POPREAL8(xa)
   tempd12 = half*xad
   volid = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempd11 + (sk(i, j, k&
   &         , 1)+sk(i, j, k-1, 1))*tempd12 + (sk(i, j, k, 3)+sk(i, j, k-1&
   &         , 3))*tempd10
   skd(i, j, k, 1) = skd(i, j, k, 1) + voli*tempd12
   skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*tempd12
   CALL POPREAL8(zp)
   skd(i, j, k, 3) = skd(i, j, k, 3) + volpi*zpd
   volpid = sk(i, j, k, 2)*ypd + sk(i, j, k, 1)*xpd + sk(i, j, k, 3&
   &         )*zpd
   CALL POPREAL8(yp)
   skd(i, j, k, 2) = skd(i, j, k, 2) + volpi*ypd
   CALL POPREAL8(xp)
   skd(i, j, k, 1) = skd(i, j, k, 1) + volpi*xpd
   CALL POPREAL8(zm)
   skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + volmi*zmd
   volmid = sk(i, j, k-1, 2)*ymd + sk(i, j, k-1, 1)*xmd + sk(i, j, &
   &         k-1, 3)*zmd
   CALL POPREAL8(ym)
   skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + volmi*ymd
   CALL POPREAL8(xm)
   skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + volmi*xmd
   CALL POPREAL8(volpi)
   temp4 = vol(i, j, k) + vol(i, j, k+1)
   tempd13 = -(two*volpid/temp4**2)
   vold(i, j, k) = vold(i, j, k) + tempd13
   vold(i, j, k+1) = vold(i, j, k+1) + tempd13
   CALL POPREAL8(volmi)
   temp3 = vol(i, j, k) + vol(i, j, k-1)
   tempd14 = -(two*volmid/temp3**2)
   vold(i, j, k) = vold(i, j, k) + tempd14
   vold(i, j, k-1) = vold(i, j, k-1) + tempd14
   CALL POPREAL8(voli)
   vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
   END DO
   END DO
   END DO
   CALL UNSTEADYTURBTERM_B(1_intType, 1_intType, nn, qq)
   CALL POPREAL8ARRAY(dw, SIZE(dw, 1)*SIZE(dw, 2)*SIZE(dw, 3)*SIZE(dw, 4)&
   &             )
   CALL TURBADVECTION_B(1_intType, 1_intType, nn, qq)
   d2walld = 0.0_8
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   gg = rr + rsacw2*(rr**6-rr)
   gg6 = gg**6
   termfw = ((one+cw36)/(gg6+cw36))**sixth
   fwsa = gg*termfw
   fv2 = one - chi/(one+chi*fv1)
   dist2inv = one/d2wall(i, j, k)**2
   term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
   &         )
   term1 = rsacb1*(one-ft2)*ss
   CALL POPREAL8(dw(i, j, k, idvt))
   tempd4 = w(i, j, k, itu1)*dwd(i, j, k, idvt)
   temp2 = w(i, j, k, itu1)
   term1d = tempd4
   term2d = temp2*tempd4
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + (term1+term2*temp2)*dwd(&
   &         i, j, k, idvt) + term2*tempd4
   dwd(i, j, k, idvt) = 0.0_8
   tempd5 = dist2inv*kar2inv*rsacb1*term2d
   dist2invd = (kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)*&
   &         term2d
   ft2d = (1.0_8-fv2)*tempd5 - ss*rsacb1*term1d
   fv2d = (one-ft2)*tempd5
   fwsad = -(dist2inv*rsacw1*term2d)
   ssd = rsacb1*(one-ft2)*term1d
   termfwd = gg*fwsad
   temp1 = (one+cw36)/(cw36+gg6)
   IF (temp1 .LE. 0.0_8 .AND. (sixth .EQ. 0.0_8 .OR. sixth .NE. INT&
   &           (sixth))) THEN
   gg6d = 0.0
   ELSE
   gg6d = -(sixth*temp1**(sixth-1)*temp1*termfwd/(cw36+gg6))
   END IF
   ggd = 6*gg**5*gg6d + termfw*fwsad
   rrd = (rsacw2*6*rr**5-rsacw2+1.0_8)*ggd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) rrd = 0.0_8
   CALL POPREAL8(rr)
   tempd3 = w(i, j, k, itu1)*kar2inv*rrd/sst
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*dist2inv*rrd/sst
   dist2invd = dist2invd + tempd3
   sstd = -(dist2inv*tempd3/sst)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) sstd = 0.0_8
   CALL POPREAL8(sst)
   tempd = kar2inv*w(i, j, k, itu1)*sstd
   ssd = ssd + sstd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*fv2*dist2inv*&
   &         sstd
   fv2d = fv2d + dist2inv*tempd
   dist2invd = dist2invd + fv2*tempd
   CALL POPREAL8(ft2)
   tempd0 = -(fv2d/(one+chi*fv1))
   tempd1 = -(chi*tempd0/(one+chi*fv1))
   fv1d = chi*tempd1
   tempd2 = fv1d/(cv13+chi3)
   chi3d = (1.0_8-chi3/(cv13+chi3))*tempd2
   chi2d = chi*chi3d - EXP(-(rsact4*chi2))*rsact3*rsact4*ft2d
   chid = chi2*chi3d + 2*chi*chi2d + fv1*tempd1 + tempd0
   CALL POPREAL8(fv1)
   CALL POPREAL8(chi3)
   CALL POPREAL8(chi2)
   CALL POPREAL8(chi)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + chid/nu
   nud = -(w(i, j, k, itu1)*chid/nu**2)
   temp0 = d2wall(i, j, k)
   d2walld(i, j, k) = d2walld(i, j, k) - one*2*dist2invd/temp0**3
   CALL POPREAL8(nu)
   temp = w(i, j, k, irho)
   rlvd(i, j, k) = rlvd(i, j, k) + nud/temp
   wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp**2
   CALL POPREAL8(ss)
   IF (.NOT.dw(i, j, k, iprod) .EQ. 0.0_8) dwd(i, j, k, iprod) = &
   &           dwd(i, j, k, iprod) + ssd/(2.0*SQRT(dw(i, j, k, iprod)))
   END DO
   END DO
   END DO
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   CALL PRODKATOLAUNDER_B()
   ELSE
   CALL PRODWMAG2_B()
   END IF
   ELSE IF (branch .EQ. 2) THEN
   CALL PRODSMAG2_B()
   END IF
   END SUBROUTINE SASOLVE_B

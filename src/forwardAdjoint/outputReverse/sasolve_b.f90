!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of sasolve in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *dw *w *rlv *vol *si *sj *sk
!                (global)timeref
!   with respect to varying inputs: *dw *w *rlv *vol *d2wall *si
!                *sj *sk (global)timeref
!   plus diff mem management of: dw:in w:in rlv:in vol:in d2wall:in
!                si:in sj:in sk:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          sasolve.f90                                     *
!      * author:        georgi kalitzin, edwin van der weide,           *
!      *                steve repsher (blanking)                        *
!      * starting date: 06-11-2003                                      *
!      * last modified: 07-05-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine sasolve_b(resonly)
!
!      ******************************************************************
!      *                                                                *
!      * sasolve solves the turbulent transport equation for the        *
!      * original spalart-allmaras model in a segregated manner using   *
!      * a diagonal dominant adi-scheme.                                *
!      *                                                                *
!      ******************************************************************
!
  use bctypes
  use blockpointers
  use constants
  use inputiteration
  use inputphysics
  use paramturb
  use turbmod
  implicit none
! don't need the remainder for residual derivative
!
!      subroutine arguments.
!
  logical, intent(in) :: resonly
!
!      local parameters.
!
  real(kind=realtype), parameter :: xminn=1.e-10_realtype
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, nn
  real(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
  real(kind=realtype) :: fv1, fv2, ft2
  real(kind=realtype) :: fv1d, fv2d, ft2d
  real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
  real(kind=realtype) :: ssd, sstd, nud, dist2invd, chid, chi2d, chi3d
  real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
  real(kind=realtype) :: rrd, ggd, gg6d, termfwd, fwsad, term1d, term2d
  real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
  real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
  real(kind=realtype) :: volid, volmid, volpid, xmd, ymd, zmd, xpd, ypd&
& , zpd
  real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
  real(kind=realtype) :: xad, yad, zad, ttmd, ttpd, cnudd, camd, capd
  real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
  real(kind=realtype) :: nutmd, nutpd, numd, nupd, cdmd, cdpd
  real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
  real(kind=realtype) :: c1md, c1pd, c10d
  real(kind=realtype) :: uu, um, up, factor, f, tu1p, rblank
  real(kind=realtype), dimension(2:il, 2:jl, 2:kl) :: qq
  real(kind=realtype), dimension(2:max(kl, il, jl)) :: bb, cc, dd, ff
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall
  logical, dimension(2:jl, 2:kl), target :: flagi2, flagil
  logical, dimension(2:il, 2:kl), target :: flagj2, flagjl
  logical, dimension(2:il, 2:jl), target :: flagk2, flagkl
  logical, dimension(:, :), pointer :: flag
  intrinsic max
  intrinsic sqrt
  intrinsic exp
  intrinsic min
  intrinsic real
  real(kind=realtype) :: tmp
  integer :: branch
  real(kind=realtype) :: temp3
  real(kind=realtype) :: tempd14
  real(kind=realtype) :: temp2
  real(kind=realtype) :: tempd13
  real(kind=realtype) :: temp1
  real(kind=realtype) :: tempd12
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: tmpd
  real(kind=realtype) :: temp17
  real(kind=realtype) :: temp16
  real(kind=realtype) :: temp15
  real(kind=realtype) :: temp14
  real(kind=realtype) :: temp13
  real(kind=realtype) :: temp12
  real(kind=realtype) :: temp11
  real(kind=realtype) :: temp10
  real(kind=realtype) :: tempd32
  real(kind=realtype) :: tempd31
  real(kind=realtype) :: tempd30
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: tempd29
  real(kind=realtype) :: tempd28
  real(kind=realtype) :: tempd27
  real(kind=realtype) :: tempd26
  real(kind=realtype) :: tempd25
  real(kind=realtype) :: tempd24
  real(kind=realtype) :: tempd23
  real(kind=realtype) :: tempd22
  real(kind=realtype) :: tempd21
  real(kind=realtype) :: tempd20
  real(kind=realtype) :: max6
  real(kind=realtype) :: max5
  real(kind=realtype) :: max4
  real(kind=realtype) :: temp
  real(kind=realtype) :: max3
  real(kind=realtype) :: max2
  real(kind=realtype) :: max1
  real(kind=realtype) :: temp9
  real(kind=realtype) :: temp8
  real(kind=realtype) :: tempd19
  real(kind=realtype) :: temp7
  real(kind=realtype) :: tempd18
  real(kind=realtype) :: temp6
  real(kind=realtype) :: tempd17
  real(kind=realtype) :: temp5
  real(kind=realtype) :: tempd16
  real(kind=realtype) :: temp4
  real(kind=realtype) :: tempd15
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! set model constants
  cv13 = rsacv1**3
  kar2inv = one/rsak**2
  cw36 = rsacw3**6
  cb3inv = one/rsacb3
! set the pointer for dvt in dw, such that the code is more
! readable. also set the pointers for the production term
! and vorticity.
!
!      ******************************************************************
!      *                                                                *
!      * production term.                                               *
!      *                                                                *
!      ******************************************************************
!
  select case  (turbprod) 
  case (strain) 
    call prodsmag2()
    call pushcontrol2b(2)
  case (vorticity) 
    call prodwmag2()
    call pushcontrol2b(1)
  case (katolaunder) 
    call prodkatolaunder()
    call pushcontrol2b(0)
  case default
    call pushcontrol2b(3)
  end select
!
!      ******************************************************************
!      *                                                                *
!      * source terms.                                                  *
!      *                                                                *
!      * determine the source term and its derivative w.r.t. nutilde    *
!      * for all internal cells of the block.                           *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
        call pushreal8(ss)
        ss = sqrt(dw(i, j, k, iprod))
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
        call pushreal8(nu)
        nu = rlv(i, j, k)/w(i, j, k, irho)
        dist2inv = one/d2wall(i, j, k)**2
        call pushreal8(chi)
        chi = w(i, j, k, itu1)/nu
        call pushreal8(chi2)
        chi2 = chi*chi
        call pushreal8(chi3)
        chi3 = chi*chi2
        call pushreal8(fv1)
        fv1 = chi3/(chi3+cv13)
        fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
        call pushreal8(ft2)
        ft2 = rsact3*exp(-(rsact4*chi2))
! ft2 = zero
! correct the production term to account for the influence
! of the wall. make sure that this term remains positive
! (the function fv2 is negative between chi = 1 and 18.4,
! which can cause sst to go negative, which is undesirable).
        call pushreal8(sst)
        sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
        if (sst .lt. xminn) then
          sst = xminn
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          sst = sst
        end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
        call pushreal8(rr)
        rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
        if (rr .gt. 10.0_realtype) then
          rr = 10.0_realtype
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          rr = rr
        end if
        gg = rr + rsacw2*(rr**6-rr)
        gg6 = gg**6
        termfw = ((one+cw36)/(gg6+cw36))**sixth
        fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
        term1 = rsacb1*(one-ft2)*ss
        term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
&         )
        call pushreal8(dw(i, j, k, idvt))
        dw(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, k, &
&         itu1)
! compute some derivatives w.r.t. nutilde. these will occur
! in the left hand side, i.e. the matrix for the implicit
! treatment.
        dfv1 = three*chi2*cv13/(chi3+cv13)**2
        dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
        dft2 = -(two*rsact4*chi*ft2/nu)
        drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
        dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
        dfw = cw36/(gg6+cw36)*termfw*dgg
! compute the source term jacobian. note that the part
! containing term1 is treated explicitly. the reason is that
! implicit treatment of this part leads to a decrease of the
! diagonal dominance of the jacobian and it thus decreases
! the stability. you may want to play around and try to
! take this term into account in the jacobian.
! note that -dsource/dnu is stored.
        qq(i, j, k) = -(two*term2*w(i, j, k, itu1)) - dist2inv*w(i, j, k&
&         , itu1)*w(i, j, k, itu1)*(rsacb1*kar2inv*(dfv2-ft2*dfv2-fv2*&
&         dft2+dft2)-rsacw1*dfw)
        if (qq(i, j, k) .lt. zero) then
          qq(i, j, k) = zero
        else
          qq(i, j, k) = qq(i, j, k)
        end if
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * advection and unsteady terms.                                  *
!      *                                                                *
!      ******************************************************************
!
  nn = itu1 - 1
  call pushreal8array(dw, size(dw, 1)*size(dw, 2)*size(dw, 3)*size(dw, 4&
&               ))
  call turbadvection(1_inttype, 1_inttype, nn, qq)
  call unsteadyturbterm(1_inttype, 1_inttype, nn, qq)
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in k-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
        call pushreal8(voli)
        voli = one/vol(i, j, k)
        call pushreal8(volmi)
        volmi = two/(vol(i, j, k)+vol(i, j, k-1))
        call pushreal8(volpi)
        volpi = two/(vol(i, j, k)+vol(i, j, k+1))
        call pushreal8(xm)
        xm = sk(i, j, k-1, 1)*volmi
        call pushreal8(ym)
        ym = sk(i, j, k-1, 2)*volmi
        call pushreal8(zm)
        zm = sk(i, j, k-1, 3)*volmi
        call pushreal8(xp)
        xp = sk(i, j, k, 1)*volpi
        call pushreal8(yp)
        yp = sk(i, j, k, 2)*volpi
        call pushreal8(zp)
        zp = sk(i, j, k, 3)*volpi
        call pushreal8(xa)
        xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
        call pushreal8(ya)
        ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
        call pushreal8(za)
        za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
        call pushreal8(ttm)
        ttm = xm*xa + ym*ya + zm*za
        call pushreal8(ttp)
        ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
        call pushreal8(cnud)
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        cam = ttm*cnud
        cap = ttp*cnud
        call pushreal8(nutm)
        nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
        call pushreal8(nutp)
        nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
        call pushreal8(nu)
        nu = rlv(i, j, k)/w(i, j, k, irho)
        call pushreal8(num)
        num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
        call pushreal8(nup)
        nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        if (cdm + cam .lt. zero) then
          call pushreal8(c1m)
          c1m = zero
          call pushcontrol1b(0)
        else
          call pushreal8(c1m)
          c1m = cdm + cam
          call pushcontrol1b(1)
        end if
        if (cdp + cap .lt. zero) then
          call pushreal8(c1p)
          c1p = zero
          call pushcontrol1b(0)
        else
          call pushreal8(c1p)
          c1p = cdp + cap
          call pushcontrol1b(1)
        end if
        call pushreal8(c10)
        c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j, k-1, itu1) -&
&         c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
! update the central jacobian. for nonboundary cells this
! is simply c1. for boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! the boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in j-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
        call pushreal8(voli)
        voli = one/vol(i, j, k)
        call pushreal8(volmi)
        volmi = two/(vol(i, j, k)+vol(i, j-1, k))
        call pushreal8(volpi)
        volpi = two/(vol(i, j, k)+vol(i, j+1, k))
        call pushreal8(xm)
        xm = sj(i, j-1, k, 1)*volmi
        call pushreal8(ym)
        ym = sj(i, j-1, k, 2)*volmi
        call pushreal8(zm)
        zm = sj(i, j-1, k, 3)*volmi
        call pushreal8(xp)
        xp = sj(i, j, k, 1)*volpi
        call pushreal8(yp)
        yp = sj(i, j, k, 2)*volpi
        call pushreal8(zp)
        zp = sj(i, j, k, 3)*volpi
        call pushreal8(xa)
        xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
        call pushreal8(ya)
        ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
        call pushreal8(za)
        za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
        call pushreal8(ttm)
        ttm = xm*xa + ym*ya + zm*za
        call pushreal8(ttp)
        ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
        call pushreal8(cnud)
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        cam = ttm*cnud
        cap = ttp*cnud
        call pushreal8(nutm)
        nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
        call pushreal8(nutp)
        nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
        call pushreal8(nu)
        nu = rlv(i, j, k)/w(i, j, k, irho)
        call pushreal8(num)
        num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
        call pushreal8(nup)
        nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        if (cdm + cam .lt. zero) then
          call pushreal8(c1m)
          c1m = zero
          call pushcontrol1b(0)
        else
          call pushreal8(c1m)
          c1m = cdm + cam
          call pushcontrol1b(1)
        end if
        if (cdp + cap .lt. zero) then
          call pushreal8(c1p)
          c1p = zero
          call pushcontrol1b(0)
        else
          call pushreal8(c1p)
          c1p = cdp + cap
          call pushcontrol1b(1)
        end if
        call pushreal8(c10)
        c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j-1, k, itu1) -&
&         c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
! update the central jacobian. for nonboundary cells this
! is simply c1. for boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! the boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in i-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
        call pushreal8(voli)
        voli = one/vol(i, j, k)
        call pushreal8(volmi)
        volmi = two/(vol(i, j, k)+vol(i-1, j, k))
        call pushreal8(volpi)
        volpi = two/(vol(i, j, k)+vol(i+1, j, k))
        call pushreal8(xm)
        xm = si(i-1, j, k, 1)*volmi
        call pushreal8(ym)
        ym = si(i-1, j, k, 2)*volmi
        call pushreal8(zm)
        zm = si(i-1, j, k, 3)*volmi
        call pushreal8(xp)
        xp = si(i, j, k, 1)*volpi
        call pushreal8(yp)
        yp = si(i, j, k, 2)*volpi
        call pushreal8(zp)
        zp = si(i, j, k, 3)*volpi
        call pushreal8(xa)
        xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
        call pushreal8(ya)
        ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
        call pushreal8(za)
        za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
        call pushreal8(ttm)
        ttm = xm*xa + ym*ya + zm*za
        call pushreal8(ttp)
        ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
        call pushreal8(cnud)
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        cam = ttm*cnud
        cap = ttp*cnud
        call pushreal8(nutm)
        nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
        call pushreal8(nutp)
        nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
        call pushreal8(nu)
        nu = rlv(i, j, k)/w(i, j, k, irho)
        call pushreal8(num)
        num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
        call pushreal8(nup)
        nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        if (cdm + cam .lt. zero) then
          call pushreal8(c1m)
          c1m = zero
          call pushcontrol1b(0)
        else
          call pushreal8(c1m)
          c1m = cdm + cam
          call pushcontrol1b(1)
        end if
        if (cdp + cap .lt. zero) then
          call pushreal8(c1p)
          c1p = zero
          call pushcontrol1b(0)
        else
          call pushreal8(c1p)
          c1p = cdp + cap
          call pushcontrol1b(1)
        end if
        call pushreal8(c10)
        c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i-1, j, k, itu1) -&
&         c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
! update the central jacobian. for nonboundary cells this
! is simply c1. for boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! the boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
      end do
    end do
  end do
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
  do k=2,kl
    do j=2,jl
      do i=2,il
        call pushreal8(rblank)
        rblank = real(iblank(i, j, k), realtype)
        tmp = -(vol(i, j, k)*dw(i, j, k, idvt)*rblank)
        call pushreal8(dw(i, j, k, itu1))
        dw(i, j, k, itu1) = tmp
      end do
    end do
  end do
  do k=kl,2,-1
    do j=jl,2,-1
      do i=il,2,-1
        call popreal8(dw(i, j, k, itu1))
        tmpd = dwd(i, j, k, itu1)
        dwd(i, j, k, itu1) = 0.0_8
        vold(i, j, k) = vold(i, j, k) - rblank*dw(i, j, k, idvt)*tmpd
        dwd(i, j, k, idvt) = dwd(i, j, k, idvt) - rblank*vol(i, j, k)*&
&         tmpd
        call popreal8(rblank)
      end do
    end do
  end do
  do k=kl,2,-1
    do j=jl,2,-1
      do i=il,2,-1
        c1md = w(i-1, j, k, itu1)*dwd(i, j, k, idvt)
        wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + c1m*dwd(i, j, k, &
&         idvt)
        c1pd = w(i+1, j, k, itu1)*dwd(i, j, k, idvt)
        wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + c1p*dwd(i, j, k, &
&         idvt)
        c10d = -(w(i, j, k, itu1)*dwd(i, j, k, idvt))
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*dwd(i, j, k, idvt)
        call popreal8(c10)
        c1md = c1md + c10d
        c1pd = c1pd + c10d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(c1p)
          cdpd = 0.0_8
          capd = 0.0_8
        else
          call popreal8(c1p)
          cdpd = c1pd
          capd = c1pd
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(c1m)
          cdmd = 0.0_8
          camd = 0.0_8
        else
          call popreal8(c1m)
          cdmd = c1md
          camd = c1md
        end if
        tempd24 = cb3inv*cdpd
        nupd = ttp*tempd24
        nutpd = ttp*(one+rsacb2)*tempd24
        ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd24
        tempd25 = cb3inv*cdmd
        numd = ttm*tempd25
        nutmd = ttm*(one+rsacb2)*tempd25
        ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd25
        call popreal8(nup)
        temp17 = w(i+1, j, k, irho)
        tempd26 = half*nupd/temp17
        rlvd(i+1, j, k) = rlvd(i+1, j, k) + tempd26
        wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - rlv(i+1, j, k)*&
&         tempd26/temp17
        nud = half*numd + half*nupd
        call popreal8(num)
        temp16 = w(i-1, j, k, irho)
        tempd27 = half*numd/temp16
        rlvd(i-1, j, k) = rlvd(i-1, j, k) + tempd27
        wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - rlv(i-1, j, k)*&
&         tempd27/temp16
        call popreal8(nu)
        temp15 = w(i, j, k, irho)
        rlvd(i, j, k) = rlvd(i, j, k) + nud/temp15
        wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp15&
&         **2
        call popreal8(nutp)
        wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*nutpd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
        call popreal8(nutm)
        wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) + half*nutmd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
        cnudd = ttm*camd + ttp*capd
        call popreal8(cnud)
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
        call popreal8(ttp)
        xpd = xa*ttpd
        xad = xm*ttmd + xp*ttpd
        ypd = ya*ttpd
        yad = ym*ttmd + yp*ttpd
        zpd = za*ttpd
        zad = zm*ttmd + zp*ttpd
        call popreal8(ttm)
        xmd = xa*ttmd
        ymd = ya*ttmd
        zmd = za*ttmd
        call popreal8(za)
        tempd28 = half*zad
        sid(i, j, k, 3) = sid(i, j, k, 3) + voli*tempd28
        sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*tempd28
        call popreal8(ya)
        tempd29 = half*yad
        sid(i, j, k, 2) = sid(i, j, k, 2) + voli*tempd29
        sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*tempd29
        call popreal8(xa)
        tempd30 = half*xad
        volid = (si(i, j, k, 2)+si(i-1, j, k, 2))*tempd29 + (si(i, j, k&
&         , 1)+si(i-1, j, k, 1))*tempd30 + (si(i, j, k, 3)+si(i-1, j, k&
&         , 3))*tempd28
        sid(i, j, k, 1) = sid(i, j, k, 1) + voli*tempd30
        sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*tempd30
        call popreal8(zp)
        sid(i, j, k, 3) = sid(i, j, k, 3) + volpi*zpd
        volpid = si(i, j, k, 2)*ypd + si(i, j, k, 1)*xpd + si(i, j, k, 3&
&         )*zpd
        call popreal8(yp)
        sid(i, j, k, 2) = sid(i, j, k, 2) + volpi*ypd
        call popreal8(xp)
        sid(i, j, k, 1) = sid(i, j, k, 1) + volpi*xpd
        call popreal8(zm)
        sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + volmi*zmd
        volmid = si(i-1, j, k, 2)*ymd + si(i-1, j, k, 1)*xmd + si(i-1, j&
&         , k, 3)*zmd
        call popreal8(ym)
        sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + volmi*ymd
        call popreal8(xm)
        sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + volmi*xmd
        call popreal8(volpi)
        temp14 = vol(i, j, k) + vol(i+1, j, k)
        tempd31 = -(two*volpid/temp14**2)
        vold(i, j, k) = vold(i, j, k) + tempd31
        vold(i+1, j, k) = vold(i+1, j, k) + tempd31
        call popreal8(volmi)
        temp13 = vol(i, j, k) + vol(i-1, j, k)
        tempd32 = -(two*volmid/temp13**2)
        vold(i, j, k) = vold(i, j, k) + tempd32
        vold(i-1, j, k) = vold(i-1, j, k) + tempd32
        call popreal8(voli)
        vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
      end do
    end do
  end do
  do k=kl,2,-1
    do j=jl,2,-1
      do i=il,2,-1
        c1md = w(i, j-1, k, itu1)*dwd(i, j, k, idvt)
        wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + c1m*dwd(i, j, k, &
&         idvt)
        c1pd = w(i, j+1, k, itu1)*dwd(i, j, k, idvt)
        wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + c1p*dwd(i, j, k, &
&         idvt)
        c10d = -(w(i, j, k, itu1)*dwd(i, j, k, idvt))
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*dwd(i, j, k, idvt)
        call popreal8(c10)
        c1md = c1md + c10d
        c1pd = c1pd + c10d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(c1p)
          cdpd = 0.0_8
          capd = 0.0_8
        else
          call popreal8(c1p)
          cdpd = c1pd
          capd = c1pd
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(c1m)
          cdmd = 0.0_8
          camd = 0.0_8
        else
          call popreal8(c1m)
          cdmd = c1md
          camd = c1md
        end if
        tempd15 = cb3inv*cdpd
        nupd = ttp*tempd15
        nutpd = ttp*(one+rsacb2)*tempd15
        ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd15
        tempd16 = cb3inv*cdmd
        numd = ttm*tempd16
        nutmd = ttm*(one+rsacb2)*tempd16
        ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd16
        call popreal8(nup)
        temp12 = w(i, j+1, k, irho)
        tempd17 = half*nupd/temp12
        rlvd(i, j+1, k) = rlvd(i, j+1, k) + tempd17
        wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - rlv(i, j+1, k)*&
&         tempd17/temp12
        nud = half*numd + half*nupd
        call popreal8(num)
        temp11 = w(i, j-1, k, irho)
        tempd18 = half*numd/temp11
        rlvd(i, j-1, k) = rlvd(i, j-1, k) + tempd18
        wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - rlv(i, j-1, k)*&
&         tempd18/temp11
        call popreal8(nu)
        temp10 = w(i, j, k, irho)
        rlvd(i, j, k) = rlvd(i, j, k) + nud/temp10
        wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp10&
&         **2
        call popreal8(nutp)
        wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*nutpd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
        call popreal8(nutm)
        wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) + half*nutmd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
        cnudd = ttm*camd + ttp*capd
        call popreal8(cnud)
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
        call popreal8(ttp)
        xpd = xa*ttpd
        xad = xm*ttmd + xp*ttpd
        ypd = ya*ttpd
        yad = ym*ttmd + yp*ttpd
        zpd = za*ttpd
        zad = zm*ttmd + zp*ttpd
        call popreal8(ttm)
        xmd = xa*ttmd
        ymd = ya*ttmd
        zmd = za*ttmd
        call popreal8(za)
        tempd19 = half*zad
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*tempd19
        sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*tempd19
        call popreal8(ya)
        tempd20 = half*yad
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*tempd20
        sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*tempd20
        call popreal8(xa)
        tempd21 = half*xad
        volid = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempd20 + (sj(i, j, k&
&         , 1)+sj(i, j-1, k, 1))*tempd21 + (sj(i, j, k, 3)+sj(i, j-1, k&
&         , 3))*tempd19
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*tempd21
        sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*tempd21
        call popreal8(zp)
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + volpi*zpd
        volpid = sj(i, j, k, 2)*ypd + sj(i, j, k, 1)*xpd + sj(i, j, k, 3&
&         )*zpd
        call popreal8(yp)
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + volpi*ypd
        call popreal8(xp)
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + volpi*xpd
        call popreal8(zm)
        sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + volmi*zmd
        volmid = sj(i, j-1, k, 2)*ymd + sj(i, j-1, k, 1)*xmd + sj(i, j-1&
&         , k, 3)*zmd
        call popreal8(ym)
        sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + volmi*ymd
        call popreal8(xm)
        sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + volmi*xmd
        call popreal8(volpi)
        temp9 = vol(i, j, k) + vol(i, j+1, k)
        tempd22 = -(two*volpid/temp9**2)
        vold(i, j, k) = vold(i, j, k) + tempd22
        vold(i, j+1, k) = vold(i, j+1, k) + tempd22
        call popreal8(volmi)
        temp8 = vol(i, j, k) + vol(i, j-1, k)
        tempd23 = -(two*volmid/temp8**2)
        vold(i, j, k) = vold(i, j, k) + tempd23
        vold(i, j-1, k) = vold(i, j-1, k) + tempd23
        call popreal8(voli)
        vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
      end do
    end do
  end do
  do k=kl,2,-1
    do j=jl,2,-1
      do i=il,2,-1
        c1md = w(i, j, k-1, itu1)*dwd(i, j, k, idvt)
        wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + c1m*dwd(i, j, k, &
&         idvt)
        c1pd = w(i, j, k+1, itu1)*dwd(i, j, k, idvt)
        wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + c1p*dwd(i, j, k, &
&         idvt)
        c10d = -(w(i, j, k, itu1)*dwd(i, j, k, idvt))
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - c10*dwd(i, j, k, idvt)
        call popreal8(c10)
        c1md = c1md + c10d
        c1pd = c1pd + c10d
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(c1p)
          cdpd = 0.0_8
          capd = 0.0_8
        else
          call popreal8(c1p)
          cdpd = c1pd
          capd = c1pd
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(c1m)
          cdmd = 0.0_8
          camd = 0.0_8
        else
          call popreal8(c1m)
          cdmd = c1md
          camd = c1md
        end if
        tempd6 = cb3inv*cdpd
        nupd = ttp*tempd6
        nutpd = ttp*(one+rsacb2)*tempd6
        ttpd = cnud*capd + (nup+(one+rsacb2)*nutp)*tempd6
        tempd7 = cb3inv*cdmd
        numd = ttm*tempd7
        nutmd = ttm*(one+rsacb2)*tempd7
        ttmd = cnud*camd + (num+(one+rsacb2)*nutm)*tempd7
        call popreal8(nup)
        temp7 = w(i, j, k+1, irho)
        tempd8 = half*nupd/temp7
        rlvd(i, j, k+1) = rlvd(i, j, k+1) + tempd8
        wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - rlv(i, j, k+1)*&
&         tempd8/temp7
        nud = half*numd + half*nupd
        call popreal8(num)
        temp6 = w(i, j, k-1, irho)
        tempd9 = half*numd/temp6
        rlvd(i, j, k-1) = rlvd(i, j, k-1) + tempd9
        wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - rlv(i, j, k-1)*&
&         tempd9/temp6
        call popreal8(nu)
        temp5 = w(i, j, k, irho)
        rlvd(i, j, k) = rlvd(i, j, k) + nud/temp5
        wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp5**&
&         2
        call popreal8(nutp)
        wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*nutpd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutpd
        call popreal8(nutm)
        wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) + half*nutmd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*nutmd
        cnudd = ttm*camd + ttp*capd
        call popreal8(cnud)
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - rsacb2*cb3inv*cnudd
        call popreal8(ttp)
        xpd = xa*ttpd
        xad = xm*ttmd + xp*ttpd
        ypd = ya*ttpd
        yad = ym*ttmd + yp*ttpd
        zpd = za*ttpd
        zad = zm*ttmd + zp*ttpd
        call popreal8(ttm)
        xmd = xa*ttmd
        ymd = ya*ttmd
        zmd = za*ttmd
        call popreal8(za)
        tempd10 = half*zad
        skd(i, j, k, 3) = skd(i, j, k, 3) + voli*tempd10
        skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*tempd10
        call popreal8(ya)
        tempd11 = half*yad
        skd(i, j, k, 2) = skd(i, j, k, 2) + voli*tempd11
        skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*tempd11
        call popreal8(xa)
        tempd12 = half*xad
        volid = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempd11 + (sk(i, j, k&
&         , 1)+sk(i, j, k-1, 1))*tempd12 + (sk(i, j, k, 3)+sk(i, j, k-1&
&         , 3))*tempd10
        skd(i, j, k, 1) = skd(i, j, k, 1) + voli*tempd12
        skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*tempd12
        call popreal8(zp)
        skd(i, j, k, 3) = skd(i, j, k, 3) + volpi*zpd
        volpid = sk(i, j, k, 2)*ypd + sk(i, j, k, 1)*xpd + sk(i, j, k, 3&
&         )*zpd
        call popreal8(yp)
        skd(i, j, k, 2) = skd(i, j, k, 2) + volpi*ypd
        call popreal8(xp)
        skd(i, j, k, 1) = skd(i, j, k, 1) + volpi*xpd
        call popreal8(zm)
        skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + volmi*zmd
        volmid = sk(i, j, k-1, 2)*ymd + sk(i, j, k-1, 1)*xmd + sk(i, j, &
&         k-1, 3)*zmd
        call popreal8(ym)
        skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + volmi*ymd
        call popreal8(xm)
        skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + volmi*xmd
        call popreal8(volpi)
        temp4 = vol(i, j, k) + vol(i, j, k+1)
        tempd13 = -(two*volpid/temp4**2)
        vold(i, j, k) = vold(i, j, k) + tempd13
        vold(i, j, k+1) = vold(i, j, k+1) + tempd13
        call popreal8(volmi)
        temp3 = vol(i, j, k) + vol(i, j, k-1)
        tempd14 = -(two*volmid/temp3**2)
        vold(i, j, k) = vold(i, j, k) + tempd14
        vold(i, j, k-1) = vold(i, j, k-1) + tempd14
        call popreal8(voli)
        vold(i, j, k) = vold(i, j, k) - one*volid/vol(i, j, k)**2
      end do
    end do
  end do
  call unsteadyturbterm_b(1_inttype, 1_inttype, nn, qq)
  call popreal8array(dw, size(dw, 1)*size(dw, 2)*size(dw, 3)*size(dw, 4)&
&             )
  call turbadvection_b(1_inttype, 1_inttype, nn, qq)
  d2walld = 0.0_8
  do k=kl,2,-1
    do j=jl,2,-1
      do i=il,2,-1
        gg = rr + rsacw2*(rr**6-rr)
        gg6 = gg**6
        termfw = ((one+cw36)/(gg6+cw36))**sixth
        fwsa = gg*termfw
        fv2 = one - chi/(one+chi*fv1)
        dist2inv = one/d2wall(i, j, k)**2
        term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
&         )
        term1 = rsacb1*(one-ft2)*ss
        call popreal8(dw(i, j, k, idvt))
        tempd4 = w(i, j, k, itu1)*dwd(i, j, k, idvt)
        temp2 = w(i, j, k, itu1)
        term1d = tempd4
        term2d = temp2*tempd4
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + (term1+term2*temp2)*dwd(&
&         i, j, k, idvt) + term2*tempd4
        dwd(i, j, k, idvt) = 0.0_8
        tempd5 = dist2inv*kar2inv*rsacb1*term2d
        dist2invd = (kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa)*&
&         term2d
        ft2d = (1.0_8-fv2)*tempd5 - ss*rsacb1*term1d
        fv2d = (one-ft2)*tempd5
        fwsad = -(dist2inv*rsacw1*term2d)
        ssd = rsacb1*(one-ft2)*term1d
        termfwd = gg*fwsad
        temp1 = (one+cw36)/(cw36+gg6)
        if (temp1 .le. 0.0_8 .and. (sixth .eq. 0.0_8 .or. sixth .ne. int&
&           (sixth))) then
          gg6d = 0.0
        else
          gg6d = -(sixth*temp1**(sixth-1)*temp1*termfwd/(cw36+gg6))
        end if
        ggd = 6*gg**5*gg6d + termfw*fwsad
        rrd = (rsacw2*6*rr**5-rsacw2+1.0_8)*ggd
        call popcontrol1b(branch)
        if (branch .eq. 0) rrd = 0.0_8
        call popreal8(rr)
        tempd3 = w(i, j, k, itu1)*kar2inv*rrd/sst
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*dist2inv*rrd/sst
        dist2invd = dist2invd + tempd3
        sstd = -(dist2inv*tempd3/sst)
        call popcontrol1b(branch)
        if (branch .eq. 0) sstd = 0.0_8
        call popreal8(sst)
        tempd = kar2inv*w(i, j, k, itu1)*sstd
        ssd = ssd + sstd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + kar2inv*fv2*dist2inv*&
&         sstd
        fv2d = fv2d + dist2inv*tempd
        dist2invd = dist2invd + fv2*tempd
        call popreal8(ft2)
        tempd0 = -(fv2d/(one+chi*fv1))
        tempd1 = -(chi*tempd0/(one+chi*fv1))
        fv1d = chi*tempd1
        tempd2 = fv1d/(cv13+chi3)
        chi3d = (1.0_8-chi3/(cv13+chi3))*tempd2
        chi2d = chi*chi3d - exp(-(rsact4*chi2))*rsact3*rsact4*ft2d
        chid = chi2*chi3d + 2*chi*chi2d + fv1*tempd1 + tempd0
        call popreal8(fv1)
        call popreal8(chi3)
        call popreal8(chi2)
        call popreal8(chi)
        wd(i, j, k, itu1) = wd(i, j, k, itu1) + chid/nu
        nud = -(w(i, j, k, itu1)*chid/nu**2)
        temp0 = d2wall(i, j, k)
        d2walld(i, j, k) = d2walld(i, j, k) - one*2*dist2invd/temp0**3
        call popreal8(nu)
        temp = w(i, j, k, irho)
        rlvd(i, j, k) = rlvd(i, j, k) + nud/temp
        wd(i, j, k, irho) = wd(i, j, k, irho) - rlv(i, j, k)*nud/temp**2
        call popreal8(ss)
        if (.not.dw(i, j, k, iprod) .eq. 0.0_8) dwd(i, j, k, iprod) = &
&           dwd(i, j, k, iprod) + ssd/(2.0*sqrt(dw(i, j, k, iprod)))
      end do
    end do
  end do
  call popcontrol2b(branch)
  if (branch .lt. 2) then
    if (branch .eq. 0) then
      call prodkatolaunder_b()
    else
      call prodwmag2_b()
    end if
  else if (branch .eq. 2) then
    call prodsmag2_b()
  end if
end subroutine sasolve_b

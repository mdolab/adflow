   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of sasolve in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *dw *w *rlv *vol *si *sj *sk
   !                (global)timeref
   !   with respect to varying inputs: *dw *w *rlv *vol *si *sj *sk
   !                (global)timeref
   !   Plus diff mem management of: dw:in w:in rlv:in vol:in si:in
   !                sj:in sk:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          saSolve.f90                                     *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide,           *
   !      *                Steve Repsher (blanking)                        *
   !      * Starting date: 06-11-2003                                      *
   !      * Last modified: 07-05-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE SASOLVE_B(resonly)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * saSolve solves the turbulent transport equation for the        *
   !      * original Spalart-Allmaras model in a segregated manner using   *
   !      * a diagonal dominant ADI-scheme.                                *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS_B
   USE CONSTANTS
   USE INPUTITERATION
   USE INPUTPHYSICS
   USE PARAMTURB
   USE TURBMOD
   IMPLICIT NONE
   ! Don't need the remainder for residual derivative
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: resonly
   !
   !      Local parameters.
   !
   REAL(kind=realtype), PARAMETER :: xminn=1.e-10_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, nn
   REAL(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
   REAL(kind=realtype) :: fv1, fv2, ft2
   REAL(kind=realtype) :: fv1b, fv2b, ft2b
   REAL(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
   REAL(kind=realtype) :: ssb, sstb, nub, chib, chi2b, chi3b
   REAL(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
   REAL(kind=realtype) :: rrb, ggb, gg6b, termfwb, fwsab, term1b, term2b
   REAL(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
   REAL(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
   REAL(kind=realtype) :: volib, volmib, volpib, xmb, ymb, zmb, xpb, ypb&
   & , zpb
   REAL(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
   REAL(kind=realtype) :: xab, yab, zab, ttmb, ttpb, cnudb, camb, capb
   REAL(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
   REAL(kind=realtype) :: nutmb, nutpb, numb, nupb, cdmb, cdpb
   REAL(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
   REAL(kind=realtype) :: c1mb, c1pb, c10b
   REAL(kind=realtype) :: uu, um, up, factor, f, tu1p, rblank
   REAL(kind=realtype), DIMENSION(2:il, 2:jl, 2:kl) :: qq
   REAL(kind=realtype), DIMENSION(2:MAX(kl, il, jl)) :: bb, cc, dd, ff
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ddw, ww, ddvt
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
   LOGICAL, DIMENSION(2:jl, 2:kl), TARGET :: flagi2, flagil
   LOGICAL, DIMENSION(2:il, 2:kl), TARGET :: flagj2, flagjl
   LOGICAL, DIMENSION(2:il, 2:jl), TARGET :: flagk2, flagkl
   LOGICAL, DIMENSION(:, :), POINTER :: flag
   INTRINSIC MAX
   INTRINSIC SQRT
   INTRINSIC EXP
   INTRINSIC MIN
   INTRINSIC REAL
   REAL(kind=realtype) :: tmp
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb19
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb18
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb17
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb16
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb15
   REAL(kind=realtype) :: tempb14
   REAL(kind=realtype) :: tempb13
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: tempb10
   REAL(kind=realtype) :: temp16
   REAL(kind=realtype) :: temp15
   REAL(kind=realtype) :: temp14
   REAL(kind=realtype) :: temp13
   REAL(kind=realtype) :: temp12
   REAL(kind=realtype) :: temp11
   REAL(kind=realtype) :: temp10
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: tempb32
   REAL(kind=realtype) :: tempb31
   REAL(kind=realtype) :: tempb30
   REAL(kind=realtype) :: tempb29
   REAL(kind=realtype) :: tempb28
   REAL(kind=realtype) :: tempb27
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: tempb26
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: tempb25
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: tempb24
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: tempb23
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: tempb22
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: tempb21
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: tempb20
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Set model constants
   cv13 = rsacv1**3
   kar2inv = one/rsak**2
   cw36 = rsacw3**6
   cb3inv = one/rsacb3
   ! Set the pointer for dvt in dw, such that the code is more
   ! readable. Also set the pointers for the production term
   ! and vorticity.
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Production term.                                               *
   !      *                                                                *
   !      ******************************************************************
   !
   SELECT CASE  (turbprod) 
   CASE (strain) 
   CALL PRODSMAG2()
   CALL PUSHCONTROL2B(2)
   CASE (vorticity) 
   CALL PRODWMAG2()
   CALL PUSHCONTROL2B(1)
   CASE (katolaunder) 
   CALL PRODKATOLAUNDER()
   CALL PUSHCONTROL2B(0)
   CASE DEFAULT
   CALL PUSHCONTROL2B(3)
   END SELECT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Source terms.                                                  *
   !      *                                                                *
   !      * Determine the source term and its derivative w.r.t. nuTilde    *
   !      * for all internal cells of the block.                           *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! First take the square root of the production term to
   ! obtain the correct production term for spalart-allmaras.
   CALL PUSHREAL8(ss)
   ss = SQRT(dw(i, j, k, iprod))
   ! Compute the laminar kinematic viscosity, the inverse of
   ! wall distance squared, the ratio chi (ratio of nuTilde
   ! and nu) and the functions fv1 and fv2. The latter corrects
   ! the production term near a viscous wall.
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   dist2inv = one/d2wall(i, j, k)**2
   CALL PUSHREAL8(chi)
   chi = w(i, j, k, itu1)/nu
   CALL PUSHREAL8(chi2)
   chi2 = chi*chi
   CALL PUSHREAL8(chi3)
   chi3 = chi*chi2
   CALL PUSHREAL8(fv1)
   fv1 = chi3/(chi3+cv13)
   fv2 = one - chi/(one+chi*fv1)
   ! The function ft2, which is designed to keep a laminar
   ! solution laminar. When running in fully turbulent mode
   ! this function should be set to 0.0.
   CALL PUSHREAL8(ft2)
   ft2 = rsact3*EXP(-(rsact4*chi2))
   ! ft2 = zero
   ! Correct the production term to account for the influence
   ! of the wall. Make sure that this term remains positive
   ! (the function fv2 is negative between chi = 1 and 18.4,
   ! which can cause sst to go negative, which is undesirable).
   CALL PUSHREAL8(sst)
   sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
   IF (sst .LT. xminn) THEN
   sst = xminn
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   sst = sst
   END IF
   ! Compute the function fw. The argument rr is cut off at 10
   ! to avoid numerical problems. This is ok, because the
   ! asymptotical value of fw is then already reached.
   CALL PUSHREAL8(rr)
   rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
   IF (rr .GT. 10.0_realType) THEN
   rr = 10.0_realType
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   rr = rr
   END IF
   gg = rr + rsacw2*(rr**6-rr)
   gg6 = gg**6
   termfw = ((one+cw36)/(gg6+cw36))**sixth
   fwsa = gg*termfw
   ! Compute the source term; some terms are saved for the
   ! linearization. The source term is stored in dvt.
   term1 = rsacb1*(one-ft2)*ss
   term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
   &         )
   CALL PUSHREAL8(dw(i, j, k, idvt))
   dw(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, k, &
   &         itu1)
   ! Compute some derivatives w.r.t. nuTilde. These will occur
   ! in the left hand side, i.e. the matrix for the implicit
   ! treatment.
   dfv1 = three*chi2*cv13/(chi3+cv13)**2
   dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
   dft2 = -(two*rsact4*chi*ft2/nu)
   drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
   dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
   dfw = cw36/(gg6+cw36)*termfw*dgg
   ! Compute the source term jacobian. Note that the part
   ! containing term1 is treated explicitly. The reason is that
   ! implicit treatment of this part leads to a decrease of the
   ! diagonal dominance of the jacobian and it thus decreases
   ! the stability. You may want to play around and try to
   ! take this term into account in the jacobian.
   ! Note that -dsource/dnu is stored.
   qq(i, j, k) = -(two*term2*w(i, j, k, itu1)) - dist2inv*w(i, j, k&
   &         , itu1)*w(i, j, k, itu1)*(rsacb1*kar2inv*(dfv2-ft2*dfv2-fv2*&
   &         dft2+dft2)-rsacw1*dfw)
   IF (qq(i, j, k) .LT. zero) THEN
   qq(i, j, k) = zero
   ELSE
   qq(i, j, k) = qq(i, j, k)
   END IF
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Advection and unsteady terms.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   nn = itu1 - 1
   CALL PUSHREAL8ARRAY(dw, SIZE(dw, 1)*SIZE(dw, 2)*SIZE(dw, 3)*SIZE(dw, 4&
   &               ))
   CALL TURBADVECTION(1_intType, 1_intType, nn, qq)
   CALL UNSTEADYTURBTERM(1_intType, 1_intType, nn, qq)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in k-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in zeta-direction, i.e. along the
   ! line k = constant.
   CALL PUSHREAL8(voli)
   voli = one/vol(i, j, k)
   CALL PUSHREAL8(volmi)
   volmi = two/(vol(i, j, k)+vol(i, j, k-1))
   CALL PUSHREAL8(volpi)
   volpi = two/(vol(i, j, k)+vol(i, j, k+1))
   CALL PUSHREAL8(xm)
   xm = sk(i, j, k-1, 1)*volmi
   CALL PUSHREAL8(ym)
   ym = sk(i, j, k-1, 2)*volmi
   CALL PUSHREAL8(zm)
   zm = sk(i, j, k-1, 3)*volmi
   CALL PUSHREAL8(xp)
   xp = sk(i, j, k, 1)*volpi
   CALL PUSHREAL8(yp)
   yp = sk(i, j, k, 2)*volpi
   CALL PUSHREAL8(zp)
   zp = sk(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in zeta-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in zeta-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! k+1, k and k-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   CALL PUSHREAL8(cnud)
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   CALL PUSHREAL8(nutm)
   nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nutp)
   nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   CALL PUSHREAL8(num)
   num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
   CALL PUSHREAL8(nup)
   nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j, k-1, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in j-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in eta-direction, i.e. along the
   ! line j = constant.
   CALL PUSHREAL8(voli)
   voli = one/vol(i, j, k)
   CALL PUSHREAL8(volmi)
   volmi = two/(vol(i, j, k)+vol(i, j-1, k))
   CALL PUSHREAL8(volpi)
   volpi = two/(vol(i, j, k)+vol(i, j+1, k))
   CALL PUSHREAL8(xm)
   xm = sj(i, j-1, k, 1)*volmi
   CALL PUSHREAL8(ym)
   ym = sj(i, j-1, k, 2)*volmi
   CALL PUSHREAL8(zm)
   zm = sj(i, j-1, k, 3)*volmi
   CALL PUSHREAL8(xp)
   xp = sj(i, j, k, 1)*volpi
   CALL PUSHREAL8(yp)
   yp = sj(i, j, k, 2)*volpi
   CALL PUSHREAL8(zp)
   zp = sj(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in eta-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in eta-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! j+1, j and j-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   CALL PUSHREAL8(cnud)
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   CALL PUSHREAL8(nutm)
   nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nutp)
   nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   CALL PUSHREAL8(num)
   num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
   CALL PUSHREAL8(nup)
   nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j-1, k, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in i-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in xi-direction, i.e. along the
   ! line i = constant.
   CALL PUSHREAL8(voli)
   voli = one/vol(i, j, k)
   CALL PUSHREAL8(volmi)
   volmi = two/(vol(i, j, k)+vol(i-1, j, k))
   CALL PUSHREAL8(volpi)
   volpi = two/(vol(i, j, k)+vol(i+1, j, k))
   CALL PUSHREAL8(xm)
   xm = si(i-1, j, k, 1)*volmi
   CALL PUSHREAL8(ym)
   ym = si(i-1, j, k, 2)*volmi
   CALL PUSHREAL8(zm)
   zm = si(i-1, j, k, 3)*volmi
   CALL PUSHREAL8(xp)
   xp = si(i, j, k, 1)*volpi
   CALL PUSHREAL8(yp)
   yp = si(i, j, k, 2)*volpi
   CALL PUSHREAL8(zp)
   zp = si(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in xi-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in xi-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! i+1, i and i-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   CALL PUSHREAL8(cnud)
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   CALL PUSHREAL8(nutm)
   nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nutp)
   nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
   CALL PUSHREAL8(nu)
   nu = rlv(i, j, k)/w(i, j, k, irho)
   CALL PUSHREAL8(num)
   num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
   CALL PUSHREAL8(nup)
   nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i-1, j, k, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   END DO
   END DO
   END DO
   ! Multiply the residual by the volume and store this in dw; this
   ! is done for monitoring reasons only. The multiplication with the
   ! volume is present to be consistent with the flow residuals; also
   ! the negative value is taken, again to be consistent with the
   ! flow equations. Also multiply by iblank so that no updates occur
   ! in holes or the overset boundary.
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   CALL PUSHREAL8(rblank)
   rblank = REAL(iblank(i, j, k), realtype)
   tmp = -(vol(i, j, k)*dw(i, j, k, idvt)*rblank)
   CALL PUSHREAL8(dw(i, j, k, itu1))
   dw(i, j, k, itu1) = tmp
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPREAL8(dw(i, j, k, itu1))
   tmpb = dwb(i, j, k, itu1)
   dwb(i, j, k, itu1) = 0.0_8
   volb(i, j, k) = volb(i, j, k) - rblank*dw(i, j, k, idvt)*tmpb
   dwb(i, j, k, idvt) = dwb(i, j, k, idvt) - rblank*vol(i, j, k)*&
   &         tmpb
   CALL POPREAL8(rblank)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   c1mb = w(i-1, j, k, itu1)*dwb(i, j, k, idvt)
   wb(i-1, j, k, itu1) = wb(i-1, j, k, itu1) + c1m*dwb(i, j, k, &
   &         idvt)
   c1pb = w(i+1, j, k, itu1)*dwb(i, j, k, idvt)
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + c1p*dwb(i, j, k, &
   &         idvt)
   c10b = -(w(i, j, k, itu1)*dwb(i, j, k, idvt))
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - c10*dwb(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1mb = c1mb + c10b
   c1pb = c1pb + c10b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb24 = cb3inv*cdpb
   nupb = ttp*tempb24
   nutpb = ttp*(one+rsacb2)*tempb24
   ttpb = cnud*capb + (nup+(one+rsacb2)*nutp)*tempb24
   tempb25 = cb3inv*cdmb
   numb = ttm*tempb25
   nutmb = ttm*(one+rsacb2)*tempb25
   ttmb = cnud*camb + (num+(one+rsacb2)*nutm)*tempb25
   CALL POPREAL8(nup)
   temp16 = w(i+1, j, k, irho)
   tempb26 = half*nupb/temp16
   rlvb(i+1, j, k) = rlvb(i+1, j, k) + tempb26
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) - rlv(i+1, j, k)*&
   &         tempb26/temp16
   nub = half*numb + half*nupb
   CALL POPREAL8(num)
   temp15 = w(i-1, j, k, irho)
   tempb27 = half*numb/temp15
   rlvb(i-1, j, k) = rlvb(i-1, j, k) + tempb27
   wb(i-1, j, k, irho) = wb(i-1, j, k, irho) - rlv(i-1, j, k)*&
   &         tempb27/temp15
   CALL POPREAL8(nu)
   temp14 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp14
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp14&
   &         **2
   CALL POPREAL8(nutp)
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   CALL POPREAL8(nutm)
   wb(i-1, j, k, itu1) = wb(i-1, j, k, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   CALL POPREAL8(cnud)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   xpb = xa*ttpb
   xab = xm*ttmb + xp*ttpb
   ypb = ya*ttpb
   yab = ym*ttmb + yp*ttpb
   zpb = za*ttpb
   zab = zm*ttmb + zp*ttpb
   CALL POPREAL8(ttm)
   xmb = xa*ttmb
   ymb = ya*ttmb
   zmb = za*ttmb
   CALL POPREAL8(za)
   tempb28 = half*zab
   sib(i, j, k, 3) = sib(i, j, k, 3) + voli*tempb28
   sib(i-1, j, k, 3) = sib(i-1, j, k, 3) + voli*tempb28
   CALL POPREAL8(ya)
   tempb29 = half*yab
   sib(i, j, k, 2) = sib(i, j, k, 2) + voli*tempb29
   sib(i-1, j, k, 2) = sib(i-1, j, k, 2) + voli*tempb29
   CALL POPREAL8(xa)
   tempb30 = half*xab
   volib = (si(i, j, k, 2)+si(i-1, j, k, 2))*tempb29 + (si(i, j, k&
   &         , 1)+si(i-1, j, k, 1))*tempb30 + (si(i, j, k, 3)+si(i-1, j, k&
   &         , 3))*tempb28
   sib(i, j, k, 1) = sib(i, j, k, 1) + voli*tempb30
   sib(i-1, j, k, 1) = sib(i-1, j, k, 1) + voli*tempb30
   CALL POPREAL8(zp)
   sib(i, j, k, 3) = sib(i, j, k, 3) + volpi*zpb
   volpib = si(i, j, k, 2)*ypb + si(i, j, k, 1)*xpb + si(i, j, k, 3&
   &         )*zpb
   CALL POPREAL8(yp)
   sib(i, j, k, 2) = sib(i, j, k, 2) + volpi*ypb
   CALL POPREAL8(xp)
   sib(i, j, k, 1) = sib(i, j, k, 1) + volpi*xpb
   CALL POPREAL8(zm)
   sib(i-1, j, k, 3) = sib(i-1, j, k, 3) + volmi*zmb
   volmib = si(i-1, j, k, 2)*ymb + si(i-1, j, k, 1)*xmb + si(i-1, j&
   &         , k, 3)*zmb
   CALL POPREAL8(ym)
   sib(i-1, j, k, 2) = sib(i-1, j, k, 2) + volmi*ymb
   CALL POPREAL8(xm)
   sib(i-1, j, k, 1) = sib(i-1, j, k, 1) + volmi*xmb
   CALL POPREAL8(volpi)
   temp13 = vol(i, j, k) + vol(i+1, j, k)
   tempb31 = -(two*volpib/temp13**2)
   volb(i, j, k) = volb(i, j, k) + tempb31
   volb(i+1, j, k) = volb(i+1, j, k) + tempb31
   CALL POPREAL8(volmi)
   temp12 = vol(i, j, k) + vol(i-1, j, k)
   tempb32 = -(two*volmib/temp12**2)
   volb(i, j, k) = volb(i, j, k) + tempb32
   volb(i-1, j, k) = volb(i-1, j, k) + tempb32
   CALL POPREAL8(voli)
   volb(i, j, k) = volb(i, j, k) - one*volib/vol(i, j, k)**2
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   c1mb = w(i, j-1, k, itu1)*dwb(i, j, k, idvt)
   wb(i, j-1, k, itu1) = wb(i, j-1, k, itu1) + c1m*dwb(i, j, k, &
   &         idvt)
   c1pb = w(i, j+1, k, itu1)*dwb(i, j, k, idvt)
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + c1p*dwb(i, j, k, &
   &         idvt)
   c10b = -(w(i, j, k, itu1)*dwb(i, j, k, idvt))
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - c10*dwb(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1mb = c1mb + c10b
   c1pb = c1pb + c10b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb15 = cb3inv*cdpb
   nupb = ttp*tempb15
   nutpb = ttp*(one+rsacb2)*tempb15
   ttpb = cnud*capb + (nup+(one+rsacb2)*nutp)*tempb15
   tempb16 = cb3inv*cdmb
   numb = ttm*tempb16
   nutmb = ttm*(one+rsacb2)*tempb16
   ttmb = cnud*camb + (num+(one+rsacb2)*nutm)*tempb16
   CALL POPREAL8(nup)
   temp11 = w(i, j+1, k, irho)
   tempb17 = half*nupb/temp11
   rlvb(i, j+1, k) = rlvb(i, j+1, k) + tempb17
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) - rlv(i, j+1, k)*&
   &         tempb17/temp11
   nub = half*numb + half*nupb
   CALL POPREAL8(num)
   temp10 = w(i, j-1, k, irho)
   tempb18 = half*numb/temp10
   rlvb(i, j-1, k) = rlvb(i, j-1, k) + tempb18
   wb(i, j-1, k, irho) = wb(i, j-1, k, irho) - rlv(i, j-1, k)*&
   &         tempb18/temp10
   CALL POPREAL8(nu)
   temp9 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp9
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp9**&
   &         2
   CALL POPREAL8(nutp)
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   CALL POPREAL8(nutm)
   wb(i, j-1, k, itu1) = wb(i, j-1, k, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   CALL POPREAL8(cnud)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   xpb = xa*ttpb
   xab = xm*ttmb + xp*ttpb
   ypb = ya*ttpb
   yab = ym*ttmb + yp*ttpb
   zpb = za*ttpb
   zab = zm*ttmb + zp*ttpb
   CALL POPREAL8(ttm)
   xmb = xa*ttmb
   ymb = ya*ttmb
   zmb = za*ttmb
   CALL POPREAL8(za)
   tempb19 = half*zab
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + voli*tempb19
   sjb(i, j-1, k, 3) = sjb(i, j-1, k, 3) + voli*tempb19
   CALL POPREAL8(ya)
   tempb20 = half*yab
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + voli*tempb20
   sjb(i, j-1, k, 2) = sjb(i, j-1, k, 2) + voli*tempb20
   CALL POPREAL8(xa)
   tempb21 = half*xab
   volib = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempb20 + (sj(i, j, k&
   &         , 1)+sj(i, j-1, k, 1))*tempb21 + (sj(i, j, k, 3)+sj(i, j-1, k&
   &         , 3))*tempb19
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + voli*tempb21
   sjb(i, j-1, k, 1) = sjb(i, j-1, k, 1) + voli*tempb21
   CALL POPREAL8(zp)
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + volpi*zpb
   volpib = sj(i, j, k, 2)*ypb + sj(i, j, k, 1)*xpb + sj(i, j, k, 3&
   &         )*zpb
   CALL POPREAL8(yp)
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + volpi*ypb
   CALL POPREAL8(xp)
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + volpi*xpb
   CALL POPREAL8(zm)
   sjb(i, j-1, k, 3) = sjb(i, j-1, k, 3) + volmi*zmb
   volmib = sj(i, j-1, k, 2)*ymb + sj(i, j-1, k, 1)*xmb + sj(i, j-1&
   &         , k, 3)*zmb
   CALL POPREAL8(ym)
   sjb(i, j-1, k, 2) = sjb(i, j-1, k, 2) + volmi*ymb
   CALL POPREAL8(xm)
   sjb(i, j-1, k, 1) = sjb(i, j-1, k, 1) + volmi*xmb
   CALL POPREAL8(volpi)
   temp8 = vol(i, j, k) + vol(i, j+1, k)
   tempb22 = -(two*volpib/temp8**2)
   volb(i, j, k) = volb(i, j, k) + tempb22
   volb(i, j+1, k) = volb(i, j+1, k) + tempb22
   CALL POPREAL8(volmi)
   temp7 = vol(i, j, k) + vol(i, j-1, k)
   tempb23 = -(two*volmib/temp7**2)
   volb(i, j, k) = volb(i, j, k) + tempb23
   volb(i, j-1, k) = volb(i, j-1, k) + tempb23
   CALL POPREAL8(voli)
   volb(i, j, k) = volb(i, j, k) - one*volib/vol(i, j, k)**2
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   c1mb = w(i, j, k-1, itu1)*dwb(i, j, k, idvt)
   wb(i, j, k-1, itu1) = wb(i, j, k-1, itu1) + c1m*dwb(i, j, k, &
   &         idvt)
   c1pb = w(i, j, k+1, itu1)*dwb(i, j, k, idvt)
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + c1p*dwb(i, j, k, &
   &         idvt)
   c10b = -(w(i, j, k, itu1)*dwb(i, j, k, idvt))
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - c10*dwb(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1mb = c1mb + c10b
   c1pb = c1pb + c10b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb6 = cb3inv*cdpb
   nupb = ttp*tempb6
   nutpb = ttp*(one+rsacb2)*tempb6
   ttpb = cnud*capb + (nup+(one+rsacb2)*nutp)*tempb6
   tempb7 = cb3inv*cdmb
   numb = ttm*tempb7
   nutmb = ttm*(one+rsacb2)*tempb7
   ttmb = cnud*camb + (num+(one+rsacb2)*nutm)*tempb7
   CALL POPREAL8(nup)
   temp6 = w(i, j, k+1, irho)
   tempb8 = half*nupb/temp6
   rlvb(i, j, k+1) = rlvb(i, j, k+1) + tempb8
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) - rlv(i, j, k+1)*&
   &         tempb8/temp6
   nub = half*numb + half*nupb
   CALL POPREAL8(num)
   temp5 = w(i, j, k-1, irho)
   tempb9 = half*numb/temp5
   rlvb(i, j, k-1) = rlvb(i, j, k-1) + tempb9
   wb(i, j, k-1, irho) = wb(i, j, k-1, irho) - rlv(i, j, k-1)*&
   &         tempb9/temp5
   CALL POPREAL8(nu)
   temp4 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp4
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp4**&
   &         2
   CALL POPREAL8(nutp)
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   CALL POPREAL8(nutm)
   wb(i, j, k-1, itu1) = wb(i, j, k-1, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   CALL POPREAL8(cnud)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   xpb = xa*ttpb
   xab = xm*ttmb + xp*ttpb
   ypb = ya*ttpb
   yab = ym*ttmb + yp*ttpb
   zpb = za*ttpb
   zab = zm*ttmb + zp*ttpb
   CALL POPREAL8(ttm)
   xmb = xa*ttmb
   ymb = ya*ttmb
   zmb = za*ttmb
   CALL POPREAL8(za)
   tempb10 = half*zab
   skb(i, j, k, 3) = skb(i, j, k, 3) + voli*tempb10
   skb(i, j, k-1, 3) = skb(i, j, k-1, 3) + voli*tempb10
   CALL POPREAL8(ya)
   tempb11 = half*yab
   skb(i, j, k, 2) = skb(i, j, k, 2) + voli*tempb11
   skb(i, j, k-1, 2) = skb(i, j, k-1, 2) + voli*tempb11
   CALL POPREAL8(xa)
   tempb12 = half*xab
   volib = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempb11 + (sk(i, j, k&
   &         , 1)+sk(i, j, k-1, 1))*tempb12 + (sk(i, j, k, 3)+sk(i, j, k-1&
   &         , 3))*tempb10
   skb(i, j, k, 1) = skb(i, j, k, 1) + voli*tempb12
   skb(i, j, k-1, 1) = skb(i, j, k-1, 1) + voli*tempb12
   CALL POPREAL8(zp)
   skb(i, j, k, 3) = skb(i, j, k, 3) + volpi*zpb
   volpib = sk(i, j, k, 2)*ypb + sk(i, j, k, 1)*xpb + sk(i, j, k, 3&
   &         )*zpb
   CALL POPREAL8(yp)
   skb(i, j, k, 2) = skb(i, j, k, 2) + volpi*ypb
   CALL POPREAL8(xp)
   skb(i, j, k, 1) = skb(i, j, k, 1) + volpi*xpb
   CALL POPREAL8(zm)
   skb(i, j, k-1, 3) = skb(i, j, k-1, 3) + volmi*zmb
   volmib = sk(i, j, k-1, 2)*ymb + sk(i, j, k-1, 1)*xmb + sk(i, j, &
   &         k-1, 3)*zmb
   CALL POPREAL8(ym)
   skb(i, j, k-1, 2) = skb(i, j, k-1, 2) + volmi*ymb
   CALL POPREAL8(xm)
   skb(i, j, k-1, 1) = skb(i, j, k-1, 1) + volmi*xmb
   CALL POPREAL8(volpi)
   temp3 = vol(i, j, k) + vol(i, j, k+1)
   tempb13 = -(two*volpib/temp3**2)
   volb(i, j, k) = volb(i, j, k) + tempb13
   volb(i, j, k+1) = volb(i, j, k+1) + tempb13
   CALL POPREAL8(volmi)
   temp2 = vol(i, j, k) + vol(i, j, k-1)
   tempb14 = -(two*volmib/temp2**2)
   volb(i, j, k) = volb(i, j, k) + tempb14
   volb(i, j, k-1) = volb(i, j, k-1) + tempb14
   CALL POPREAL8(voli)
   volb(i, j, k) = volb(i, j, k) - one*volib/vol(i, j, k)**2
   END DO
   END DO
   END DO
   CALL UNSTEADYTURBTERM_B(1_intType, 1_intType, nn, qq)
   CALL POPREAL8ARRAY(dw, SIZE(dw, 1)*SIZE(dw, 2)*SIZE(dw, 3)*SIZE(dw, 4)&
   &             )
   CALL TURBADVECTION_B(1_intType, 1_intType, nn, qq)
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   gg = rr + rsacw2*(rr**6-rr)
   gg6 = gg**6
   termfw = ((one+cw36)/(gg6+cw36))**sixth
   fwsa = gg*termfw
   fv2 = one - chi/(one+chi*fv1)
   dist2inv = one/d2wall(i, j, k)**2
   term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
   &         )
   term1 = rsacb1*(one-ft2)*ss
   CALL POPREAL8(dw(i, j, k, idvt))
   tempb4 = w(i, j, k, itu1)*dwb(i, j, k, idvt)
   temp1 = w(i, j, k, itu1)
   term1b = tempb4
   term2b = temp1*tempb4
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + (term1+term2*temp1)*dwb(&
   &         i, j, k, idvt) + term2*tempb4
   dwb(i, j, k, idvt) = 0.0_8
   tempb5 = dist2inv*kar2inv*rsacb1*term2b
   ft2b = (1.0_8-fv2)*tempb5 - ss*rsacb1*term1b
   fv2b = (one-ft2)*tempb5
   fwsab = -(dist2inv*rsacw1*term2b)
   ssb = rsacb1*(one-ft2)*term1b
   termfwb = gg*fwsab
   temp0 = (one+cw36)/(cw36+gg6)
   IF (temp0 .LE. 0.0_8 .AND. (sixth .EQ. 0.0_8 .OR. sixth .NE. INT&
   &           (sixth))) THEN
   gg6b = 0.0
   ELSE
   gg6b = -(sixth*temp0**(sixth-1)*temp0*termfwb/(cw36+gg6))
   END IF
   ggb = 6*gg**5*gg6b + termfw*fwsab
   rrb = (rsacw2*6*rr**5-rsacw2+1.0_8)*ggb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) rrb = 0.0_8
   CALL POPREAL8(rr)
   tempb3 = kar2inv*dist2inv*rrb/sst
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + tempb3
   sstb = -(w(i, j, k, itu1)*tempb3/sst)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) sstb = 0.0_8
   CALL POPREAL8(sst)
   tempb = kar2inv*dist2inv*sstb
   ssb = ssb + sstb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + fv2*tempb
   fv2b = fv2b + w(i, j, k, itu1)*tempb
   CALL POPREAL8(ft2)
   tempb0 = -(fv2b/(one+chi*fv1))
   tempb1 = -(chi*tempb0/(one+chi*fv1))
   fv1b = chi*tempb1
   tempb2 = fv1b/(cv13+chi3)
   chi3b = (1.0_8-chi3/(cv13+chi3))*tempb2
   chi2b = chi*chi3b - EXP(-(rsact4*chi2))*rsact3*rsact4*ft2b
   chib = chi2*chi3b + 2*chi*chi2b + fv1*tempb1 + tempb0
   CALL POPREAL8(fv1)
   CALL POPREAL8(chi3)
   CALL POPREAL8(chi2)
   CALL POPREAL8(chi)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + chib/nu
   nub = -(w(i, j, k, itu1)*chib/nu**2)
   CALL POPREAL8(nu)
   temp = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp**2
   CALL POPREAL8(ss)
   IF (.NOT.dw(i, j, k, iprod) .EQ. 0.0_8) dwb(i, j, k, iprod) = &
   &           dwb(i, j, k, iprod) + ssb/(2.0*SQRT(dw(i, j, k, iprod)))
   END DO
   END DO
   END DO
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   CALL PRODKATOLAUNDER_B()
   ELSE
   CALL PRODWMAG2_B()
   END IF
   ELSE IF (branch .EQ. 2) THEN
   CALL PRODSMAG2_B()
   END IF
   END SUBROUTINE SASOLVE_B

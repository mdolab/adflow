   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of sasolve in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *dw *w
   !   with respect to varying inputs: *dw *w *rlv
   !   Plus diff mem management of: dw:in w:in rlv:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          saSolve.f90                                     *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide,           *
   !      *                Steve Repsher (blanking)                        *
   !      * Starting date: 06-11-2003                                      *
   !      * Last modified: 07-05-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE SASOLVE_B(resonly)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * saSolve solves the turbulent transport equation for the        *
   !      * original Spalart-Allmaras model in a segregated manner using   *
   !      * a diagonal dominant ADI-scheme.                                *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS_B
   USE CONSTANTS
   USE INPUTITERATION
   USE INPUTPHYSICS
   USE PARAMTURB
   USE TURBMOD
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: resonly
   !
   !      Local parameters.
   !
   REAL(kind=realtype), PARAMETER :: xminn=1.e-10_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, nn
   REAL(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
   REAL(kind=realtype) :: fv1, fv2, ft2
   REAL(kind=realtype) :: fv1b, fv2b, ft2b
   REAL(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
   REAL(kind=realtype) :: ssb, sstb, nub, chib, chi2b, chi3b
   REAL(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
   REAL(kind=realtype) :: rrb, ggb, gg6b, termfwb, fwsab, term1b, term2b
   REAL(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
   REAL(kind=realtype) :: dfv1b, dfv2b, dft2b, drrb, dggb, dfwb
   REAL(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
   REAL(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
   REAL(kind=realtype) :: cnudb, camb, capb
   REAL(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
   REAL(kind=realtype) :: nutmb, nutpb, numb, nupb, cdmb, cdpb
   REAL(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
   REAL(kind=realtype) :: c1mb, c1pb, c10b, b1b, c1b, d1b
   REAL(kind=realtype) :: uu, um, up, factor, f, tu1p, rblank
   REAL(kind=realtype) :: uub, umb, upb, fb
   REAL(kind=realtype), DIMENSION(2:il, 2:jl, 2:kl) :: qq
   REAL(kind=realtype), DIMENSION(2:il, 2:jl, 2:kl) :: qqb
   REAL(kind=realtype), DIMENSION(2:MAX(kl, il, jl)) :: bb, cc, dd, ff
   REAL(kind=realtype), DIMENSION(2:MAX(kl, il, jl)) :: bbb, ccb, ddb, &
   & ffb
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ddw, ww, ddvt
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
   LOGICAL, DIMENSION(2:jl, 2:kl), TARGET :: flagi2, flagil
   LOGICAL, DIMENSION(2:il, 2:kl), TARGET :: flagj2, flagjl
   LOGICAL, DIMENSION(2:il, 2:jl), TARGET :: flagk2, flagkl
   LOGICAL, DIMENSION(:, :), POINTER :: flag
   INTRINSIC MAX
   INTRINSIC SQRT
   INTRINSIC EXP
   INTRINSIC MIN
   INTRINSIC REAL
   REAL(kind=realtype) :: tmp
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: temp23
   REAL(kind=realtype) :: temp22
   REAL(kind=realtype) :: temp21
   REAL(kind=realtype) :: temp20
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb19
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb18
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb17
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb16
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb15
   REAL(kind=realtype) :: tempb14
   REAL(kind=realtype) :: tempb13
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: tempb48
   REAL(kind=realtype) :: tempb10
   REAL(kind=realtype) :: tempb47
   REAL(kind=realtype) :: tempb46
   REAL(kind=realtype) :: tempb45
   REAL(kind=realtype) :: tempb44
   REAL(kind=realtype) :: tempb43
   REAL(kind=realtype) :: temp19
   REAL(kind=realtype) :: tempb42
   REAL(kind=realtype) :: temp18
   REAL(kind=realtype) :: tempb41
   REAL(kind=realtype) :: temp17
   REAL(kind=realtype) :: tempb40
   REAL(kind=realtype) :: temp16
   REAL(kind=realtype) :: temp15
   REAL(kind=realtype) :: temp14
   REAL(kind=realtype) :: temp13
   REAL(kind=realtype) :: temp12
   REAL(kind=realtype) :: temp11
   REAL(kind=realtype) :: temp10
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: tempb39
   REAL(kind=realtype) :: tempb38
   REAL(kind=realtype) :: tempb37
   REAL(kind=realtype) :: tempb36
   REAL(kind=realtype) :: tempb35
   REAL(kind=realtype) :: tempb34
   REAL(kind=realtype) :: tempb33
   REAL(kind=realtype) :: tempb32
   REAL(kind=realtype) :: tempb31
   REAL(kind=realtype) :: tempb30
   REAL(kind=realtype) :: tempb29
   REAL(kind=realtype) :: tempb28
   REAL(kind=realtype) :: tempb27
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: tempb26
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: tempb25
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: tempb24
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: tempb23
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: tempb22
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: tempb21
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: tempb20
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Set model constants
   cv13 = rsacv1**3
   kar2inv = one/rsak**2
   cw36 = rsacw3**6
   cb3inv = one/rsacb3
   ! Set the pointer for dvt in dw, such that the code is more
   ! readable. Also set the pointers for the production term
   ! and vorticity.
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Production term.                                               *
   !      *                                                                *
   !      ******************************************************************
   !
   SELECT CASE  (turbprod) 
   CASE (strain) 
   CALL PRODSMAG2()
   CALL PUSHCONTROL2B(2)
   CASE (vorticity) 
   CALL PRODWMAG2()
   CALL PUSHCONTROL2B(1)
   CASE (katolaunder) 
   CALL PRODKATOLAUNDER()
   CALL PUSHCONTROL2B(0)
   CASE DEFAULT
   CALL PUSHCONTROL2B(3)
   END SELECT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Source terms.                                                  *
   !      *                                                                *
   !      * Determine the source term and its derivative w.r.t. nuTilde    *
   !      * for all internal cells of the block.                           *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! First take the square root of the production term to
   ! obtain the correct production term for spalart-allmaras.
   CALL PUSHREAL8(ss)
   ss = SQRT(dw(i, j, k, iprod))
   ! Compute the laminar kinematic viscosity, the inverse of
   ! wall distance squared, the ratio chi (ratio of nuTilde
   ! and nu) and the functions fv1 and fv2. The latter corrects
   ! the production term near a viscous wall.
   nu = rlv(i, j, k)/w(i, j, k, irho)
   dist2inv = one/d2wall(i, j, k)**2
   chi = w(i, j, k, itu1)/nu
   chi2 = chi*chi
   chi3 = chi*chi2
   fv1 = chi3/(chi3+cv13)
   fv2 = one - chi/(one+chi*fv1)
   ! The function ft2, which is designed to keep a laminar
   ! solution laminar. When running in fully turbulent mode
   ! this function should be set to 0.0.
   CALL PUSHREAL8(ft2)
   ft2 = rsact3*EXP(-(rsact4*chi2))
   ! ft2 = zero
   ! Correct the production term to account for the influence
   ! of the wall. Make sure that this term remains positive
   ! (the function fv2 is negative between chi = 1 and 18.4,
   ! which can cause sst to go negative, which is undesirable).
   CALL PUSHREAL8(sst)
   sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
   IF (sst .LT. xminn) THEN
   sst = xminn
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   sst = sst
   END IF
   ! Compute the function fw. The argument rr is cut off at 10
   ! to avoid numerical problems. This is ok, because the
   ! asymptotical value of fw is then already reached.
   CALL PUSHREAL8(rr)
   rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
   IF (rr .GT. 10.0_realType) THEN
   rr = 10.0_realType
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   rr = rr
   END IF
   gg = rr + rsacw2*(rr**6-rr)
   gg6 = gg**6
   termfw = ((one+cw36)/(gg6+cw36))**sixth
   fwsa = gg*termfw
   ! Compute the source term; some terms are saved for the
   ! linearization. The source term is stored in dvt.
   term1 = rsacb1*(one-ft2)*ss
   term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
   &         )
   CALL PUSHREAL8(dw(i, j, k, idvt))
   dw(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, k, &
   &         itu1)
   ! Compute some derivatives w.r.t. nuTilde. These will occur
   ! in the left hand side, i.e. the matrix for the implicit
   ! treatment.
   dfv1 = three*chi2*cv13/(chi3+cv13)**2
   dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
   dft2 = -(two*rsact4*chi*ft2/nu)
   CALL PUSHREAL8(drr)
   drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
   dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
   dfw = cw36/(gg6+cw36)*termfw*dgg
   ! Compute the source term jacobian. Note that the part
   ! containing term1 is treated explicitly. The reason is that
   ! implicit treatment of this part leads to a decrease of the
   ! diagonal dominance of the jacobian and it thus decreases
   ! the stability. You may want to play around and try to
   ! take this term into account in the jacobian.
   ! Note that -dsource/dnu is stored.
   qq(i, j, k) = -(two*term2*w(i, j, k, itu1)) - dist2inv*w(i, j, k&
   &         , itu1)*w(i, j, k, itu1)*(rsacb1*kar2inv*(dfv2-ft2*dfv2-fv2*&
   &         dft2+dft2)-rsacw1*dfw)
   IF (qq(i, j, k) .LT. zero) THEN
   qq(i, j, k) = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   qq(i, j, k) = qq(i, j, k)
   END IF
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Advection and unsteady terms.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   nn = itu1 - 1
   CALL PUSHREAL8ARRAY(dw, SIZE(dw, 1)*SIZE(dw, 2)*SIZE(dw, 3)*SIZE(dw, 4&
   &               ))
   CALL TURBADVECTION(1_intType, 1_intType, nn, qq)
   CALL UNSTEADYTURBTERM(1_intType, 1_intType, nn, qq)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in k-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in zeta-direction, i.e. along the
   ! line k = constant.
   voli = one/vol(i, j, k)
   volmi = two/(vol(i, j, k)+vol(i, j, k-1))
   volpi = two/(vol(i, j, k)+vol(i, j, k+1))
   xm = sk(i, j, k-1, 1)*volmi
   ym = sk(i, j, k-1, 2)*volmi
   zm = sk(i, j, k-1, 3)*volmi
   xp = sk(i, j, k, 1)*volpi
   yp = sk(i, j, k, 2)*volpi
   zp = sk(i, j, k, 3)*volpi
   xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
   ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
   za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in zeta-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in zeta-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! k+1, k and k-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
   nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
   nu = rlv(i, j, k)/w(i, j, k, irho)
   num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
   nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j, k-1, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
   b1 = -c1m
   c1 = c10
   d1 = -c1p
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   IF (k .EQ. 2) THEN
   IF (bmtk1(i, j, itu1, itu1) .LT. zero) THEN
   CALL PUSHREAL8(max1)
   max1 = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max1)
   max1 = bmtk1(i, j, itu1, itu1)
   CALL PUSHCONTROL1B(1)
   END IF
   qq(i, j, k) = qq(i, j, k) + c1 - b1*max1
   CALL PUSHCONTROL2B(2)
   ELSE IF (k .EQ. kl) THEN
   IF (bmtk2(i, j, itu1, itu1) .LT. zero) THEN
   CALL PUSHREAL8(max2)
   max2 = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max2)
   max2 = bmtk2(i, j, itu1, itu1)
   CALL PUSHCONTROL1B(1)
   END IF
   qq(i, j, k) = qq(i, j, k) + c1 - d1*max2
   CALL PUSHCONTROL2B(1)
   ELSE
   qq(i, j, k) = qq(i, j, k) + c1
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in j-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in eta-direction, i.e. along the
   ! line j = constant.
   voli = one/vol(i, j, k)
   volmi = two/(vol(i, j, k)+vol(i, j-1, k))
   volpi = two/(vol(i, j, k)+vol(i, j+1, k))
   xm = sj(i, j-1, k, 1)*volmi
   ym = sj(i, j-1, k, 2)*volmi
   zm = sj(i, j-1, k, 3)*volmi
   xp = sj(i, j, k, 1)*volpi
   yp = sj(i, j, k, 2)*volpi
   zp = sj(i, j, k, 3)*volpi
   xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
   ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
   za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in eta-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in eta-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! j+1, j and j-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
   nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
   nu = rlv(i, j, k)/w(i, j, k, irho)
   num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
   nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j-1, k, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
   b1 = -c1m
   c1 = c10
   d1 = -c1p
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   IF (j .EQ. 2) THEN
   IF (bmtj1(i, k, itu1, itu1) .LT. zero) THEN
   CALL PUSHREAL8(max3)
   max3 = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max3)
   max3 = bmtj1(i, k, itu1, itu1)
   CALL PUSHCONTROL1B(1)
   END IF
   qq(i, j, k) = qq(i, j, k) + c1 - b1*max3
   CALL PUSHCONTROL2B(2)
   ELSE IF (j .EQ. jl) THEN
   IF (bmtj2(i, k, itu1, itu1) .LT. zero) THEN
   CALL PUSHREAL8(max4)
   max4 = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max4)
   max4 = bmtj2(i, k, itu1, itu1)
   CALL PUSHCONTROL1B(1)
   END IF
   qq(i, j, k) = qq(i, j, k) + c1 - d1*max4
   CALL PUSHCONTROL2B(1)
   ELSE
   qq(i, j, k) = qq(i, j, k) + c1
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Viscous terms in i-direction.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the metrics in xi-direction, i.e. along the
   ! line i = constant.
   voli = one/vol(i, j, k)
   volmi = two/(vol(i, j, k)+vol(i-1, j, k))
   volpi = two/(vol(i, j, k)+vol(i+1, j, k))
   xm = si(i-1, j, k, 1)*volmi
   ym = si(i-1, j, k, 2)*volmi
   zm = si(i-1, j, k, 3)*volmi
   xp = si(i, j, k, 1)*volpi
   yp = si(i, j, k, 2)*volpi
   zp = si(i, j, k, 3)*volpi
   xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
   ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
   za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   ! Computation of the viscous terms in xi-direction; note
   ! that cross-derivatives are neglected, i.e. the mesh is
   ! assumed to be orthogonal.
   ! Furthermore, the grad(nu)**2 has been rewritten as
   ! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
   ! The second derivative in xi-direction is constructed as
   ! the central difference of the first order derivatives, i.e.
   ! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
   ! In this way the metric can be taken into account.
   ! Compute the diffusion coefficients multiplying the nodes
   ! i+1, i and i-1 in the second derivative. Make sure that
   ! these coefficients are nonnegative.
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
   nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
   nu = rlv(i, j, k)/w(i, j, k, irho)
   num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
   nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(c10)
   c10 = c1m + c1p
   ! Update the residual for this cell and store the possible
   ! coefficients for the matrix in b1, c1 and d1.
   dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i-1, j, k, itu1) -&
   &         c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
   b1 = -c1m
   c1 = c10
   d1 = -c1p
   ! Update the central jacobian. For nonboundary cells this
   ! is simply c1. For boundary cells this is slightly more
   ! complicated, because the boundary conditions are treated
   ! implicitly and the off-diagonal terms b1 and d1 must be
   ! taken into account.
   ! The boundary conditions are only treated implicitly if
   ! the diagonal dominance of the matrix is increased.
   IF (i .EQ. 2) THEN
   IF (bmti1(j, k, itu1, itu1) .LT. zero) THEN
   CALL PUSHREAL8(max5)
   max5 = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max5)
   max5 = bmti1(j, k, itu1, itu1)
   CALL PUSHCONTROL1B(1)
   END IF
   qq(i, j, k) = qq(i, j, k) + c1 - b1*max5
   CALL PUSHCONTROL2B(2)
   ELSE IF (i .EQ. il) THEN
   IF (bmti2(j, k, itu1, itu1) .LT. zero) THEN
   CALL PUSHREAL8(max6)
   max6 = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max6)
   max6 = bmti2(j, k, itu1, itu1)
   CALL PUSHCONTROL1B(1)
   END IF
   qq(i, j, k) = qq(i, j, k) + c1 - d1*max6
   CALL PUSHCONTROL2B(1)
   ELSE
   qq(i, j, k) = qq(i, j, k) + c1
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   END DO
   END DO
   ! Multiply the residual by the volume and store this in dw; this
   ! is done for monitoring reasons only. The multiplication with the
   ! volume is present to be consistent with the flow residuals; also
   ! the negative value is taken, again to be consistent with the
   ! flow equations. Also multiply by iblank so that no updates occur
   ! in holes or the overset boundary.
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   CALL PUSHREAL8(rblank)
   rblank = REAL(iblank(i, j, k), realtype)
   tmp = -(vol(i, j, k)*dw(i, j, k, idvt)*rblank)
   dw(i, j, k, itu1) = tmp
   END DO
   END DO
   END DO
   ! Initialize the wall function flags to .false.
   flagi2 = .false.
   flagil = .false.
   flagj2 = .false.
   flagjl = .false.
   flagk2 = .false.
   flagkl = .false.
   ! Modify the rhs of the 1st internal cell, if wall functions
   ! are used; their value is determined by the table.
   ! Return if only the residual must be computed.
   IF (resonly) THEN
   rlvb = 0.0_8
   qqb = 0.0_8
   ELSE
   ! For implicit relaxation take the local time step into account,
   ! where dt is the inverse of the central jacobian times the cfl
   ! number. The following system is solved:
   ! (I/dt + cc + bb + dd)*dw = rhs, in which I/dt = cc/cfl. As in
   ! the rest of the algorithm only the modified central jacobian is
   ! used, stored it now.
   ! Compute the factor multiplying the central jacobian, which
   ! is 1 + 1/cfl (implicit relaxation only).
   factor = one
   IF (turbrelax .EQ. turbrelaximplicit) factor = one + (one-alfaturb)/&
   &       alfaturb
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   qq(i, j, k) = factor*qq(i, j, k)
   ! Set qq to 1 if the value is determined by the
   ! wall function table.
   IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
   &             flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
   &             .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
   &             , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) THEN
   qq(i, j, k) = one
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   END DO
   ! Initialize the grid velocity to zero. This value will be used
   ! if the block is not moving.
   qs = zero
   !
   !      ******************************************************************
   !      *                                                                *
   !      * dd-ADI step in j-direction. There is no particular reason to   *
   !      * start in j-direction, it just happened to be so. As we solve   *
   !      * in j-direction, the j-loop is the innermost loop.              *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO i=2,il
   DO j=2,jl
   ! More or less the same code is executed here as above when
   ! the residual was built. However, now the off-diagonal
   ! terms for the dd-ADI must be built and stored. This could
   ! have been done earlier, but then all the coefficients had
   ! to be stored. To save memory, they are recomputed.
   ! Consequently, see the j-loop to build the residual for
   ! the comments.
   voli = one/vol(i, j, k)
   volmi = two/(vol(i, j, k)+vol(i, j-1, k))
   volpi = two/(vol(i, j, k)+vol(i, j+1, k))
   xm = sj(i, j-1, k, 1)*volmi
   ym = sj(i, j-1, k, 2)*volmi
   zm = sj(i, j-1, k, 3)*volmi
   xp = sj(i, j, k, 1)*volpi
   yp = sj(i, j, k, 2)*volpi
   zp = sj(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   ! Off-diagonal terms due to the diffusion terms
   ! in j-direction.
   nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
   nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
   nu = rlv(i, j, k)/w(i, j, k, irho)
   num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
   nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(bb(j))
   bb(j) = -c1m
   CALL PUSHREAL8(dd(j))
   dd(j) = -c1p
   ! Compute the grid velocity if present.
   ! It is taken as the average of j and j-1,
   IF (addgridvelocities) qs = half*(sfacej(i, j, k)+sfacej(i, j-&
   &             1, k))*voli
   ! Off-diagonal terms due to the advection term in
   ! j-direction. First order approximation.
   uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
   &           ivz) - qs
   um = zero
   up = zero
   IF (uu .LT. zero) THEN
   um = uu
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (uu .GT. zero) THEN
   up = uu
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   bb(j) = bb(j) - up
   dd(j) = dd(j) + um
   ! Store the central jacobian and rhs in cc and ff.
   ! Multiply the off-diagonal terms and rhs by the iblank
   ! value so the update determined for iblank = 0 is zero.
   CALL PUSHREAL8(rblank)
   rblank = REAL(iblank(i, j, k), realtype)
   CALL PUSHREAL8(cc(j))
   cc(j) = qq(i, j, k)
   CALL PUSHREAL8(ff(j))
   ff(j) = dw(i, j, k, idvt)*rblank
   bb(j) = bb(j)*rblank
   dd(j) = dd(j)*rblank
   ! Set the off diagonal terms to zero if the wall is flagged.
   IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
   &             flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
   &             .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
   &             , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) THEN
   bb(j) = zero
   dd(j) = zero
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   ! Solve the tri-diagonal system in j-direction.
   ! First the backward sweep to eliMinate the upper diagonal dd.
   DO j=ny,2,-1
   CALL PUSHREAL8(f)
   f = dd(j)/cc(j+1)
   CALL PUSHREAL8(cc(j))
   cc(j) = cc(j) - f*bb(j+1)
   CALL PUSHREAL8(ff(j))
   ff(j) = ff(j) - f*ff(j+1)
   END DO
   ! The matrix is now in lower block bi-diagonal form.
   ! Perform a forward sweep to compute the solution.
   CALL PUSHREAL8(ff(2))
   ff(2) = ff(2)/cc(2)
   DO j=3,jl
   CALL PUSHREAL8(ff(j))
   ff(j) = ff(j) - bb(j)*ff(j-1)
   CALL PUSHREAL8(ff(j))
   ff(j) = ff(j)/cc(j)
   END DO
   ! Determine the new rhs for the next direction.
   DO j=2,jl
   dw(i, j, k, idvt) = ff(j)*qq(i, j, k)
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * dd-ADI step in i-direction. As we solve in i-direction, the    *
   !      * i-loop is the innermost loop.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! More or less the same code is executed here as above when
   ! the residual was built. However, now the off-diagonal
   ! terms for the dd-ADI must be built and stored. This could
   ! have been done earlier, but then all the coefficients had
   ! to be stored. To save memory, they are recomputed.
   ! Consequently, see the i-loop to build the residual for
   ! the comments.
   voli = one/vol(i, j, k)
   volmi = two/(vol(i, j, k)+vol(i-1, j, k))
   volpi = two/(vol(i, j, k)+vol(i+1, j, k))
   xm = si(i-1, j, k, 1)*volmi
   ym = si(i-1, j, k, 2)*volmi
   zm = si(i-1, j, k, 3)*volmi
   xp = si(i, j, k, 1)*volpi
   yp = si(i, j, k, 2)*volpi
   zp = si(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   ! Off-diagonal terms due to the diffusion terms
   ! in i-direction.
   nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
   nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
   nu = rlv(i, j, k)/w(i, j, k, irho)
   num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
   nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(bb(i))
   bb(i) = -c1m
   CALL PUSHREAL8(dd(i))
   dd(i) = -c1p
   ! Compute the grid velocity if present.
   ! It is taken as the average of i and i-1,
   IF (addgridvelocities) qs = half*(sfacei(i, j, k)+sfacei(i-1, &
   &             j, k))*voli
   ! Off-diagonal terms due to the advection term in
   ! i-direction. First order approximation.
   uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
   &           ivz) - qs
   um = zero
   up = zero
   IF (uu .LT. zero) THEN
   um = uu
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (uu .GT. zero) THEN
   up = uu
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   bb(i) = bb(i) - up
   dd(i) = dd(i) + um
   ! Store the central jacobian and rhs in cc and ff.
   ! Multiply the off-diagonal terms and rhs by the iblank
   ! value so the update determined for iblank = 0 is zero.
   CALL PUSHREAL8(rblank)
   rblank = REAL(iblank(i, j, k), realtype)
   CALL PUSHREAL8(cc(i))
   cc(i) = qq(i, j, k)
   CALL PUSHREAL8(ff(i))
   ff(i) = dw(i, j, k, idvt)*rblank
   bb(i) = bb(i)*rblank
   dd(i) = dd(i)*rblank
   ! Set the off diagonal terms to zero if the wall is flagged.
   IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
   &             flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
   &             .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
   &             , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) THEN
   bb(i) = zero
   dd(i) = zero
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   ! Solve the tri-diagonal system in i-direction.
   ! First the backward sweep to eliMinate the upper diagonal dd.
   DO i=nx,2,-1
   CALL PUSHREAL8(f)
   f = dd(i)/cc(i+1)
   CALL PUSHREAL8(cc(i))
   cc(i) = cc(i) - f*bb(i+1)
   CALL PUSHREAL8(ff(i))
   ff(i) = ff(i) - f*ff(i+1)
   END DO
   ! The matrix is now in lower block bi-diagonal form.
   ! Perform a forward sweep to compute the solution.
   CALL PUSHREAL8(ff(2))
   ff(2) = ff(2)/cc(2)
   DO i=3,il
   CALL PUSHREAL8(ff(i))
   ff(i) = ff(i) - bb(i)*ff(i-1)
   CALL PUSHREAL8(ff(i))
   ff(i) = ff(i)/cc(i)
   END DO
   ! Determine the new rhs for the next direction.
   DO i=2,il
   dw(i, j, k, idvt) = ff(i)*qq(i, j, k)
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * dd-ADI step in k-direction. As we solve in k-direction, the    *
   !      * k-loop is the innermost loop.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   DO j=2,jl
   DO i=2,il
   DO k=2,kl
   ! More or less the same code is executed here as above when
   ! the residual was built. However, now the off-diagonal
   ! terms for the dd-ADI must be built and stored. This could
   ! have been done earlier, but then all the coefficients had
   ! to be stored. To save memory, they are recomputed.
   ! Consequently, see the k-loop to build the residual for
   ! the comments.
   voli = one/vol(i, j, k)
   volmi = two/(vol(i, j, k)+vol(i, j, k-1))
   volpi = two/(vol(i, j, k)+vol(i, j, k+1))
   xm = sk(i, j, k-1, 1)*volmi
   ym = sk(i, j, k-1, 2)*volmi
   zm = sk(i, j, k-1, 3)*volmi
   xp = sk(i, j, k, 1)*volpi
   yp = sk(i, j, k, 2)*volpi
   zp = sk(i, j, k, 3)*volpi
   CALL PUSHREAL8(xa)
   xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
   CALL PUSHREAL8(ya)
   ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
   CALL PUSHREAL8(za)
   za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
   CALL PUSHREAL8(ttm)
   ttm = xm*xa + ym*ya + zm*za
   CALL PUSHREAL8(ttp)
   ttp = xp*xa + yp*ya + zp*za
   cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
   cam = ttm*cnud
   cap = ttp*cnud
   ! Off-diagonal terms due to the diffusion terms
   ! in k-direction.
   nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
   nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
   nu = rlv(i, j, k)/w(i, j, k, irho)
   num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
   nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
   cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
   cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
   IF (cdm + cam .LT. zero) THEN
   CALL PUSHREAL8(c1m)
   c1m = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1m)
   c1m = cdm + cam
   CALL PUSHCONTROL1B(1)
   END IF
   IF (cdp + cap .LT. zero) THEN
   CALL PUSHREAL8(c1p)
   c1p = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(c1p)
   c1p = cdp + cap
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(bb(k))
   bb(k) = -c1m
   CALL PUSHREAL8(dd(k))
   dd(k) = -c1p
   ! Compute the grid velocity if present.
   ! It is taken as the average of k and k-1,
   IF (addgridvelocities) qs = half*(sfacek(i, j, k)+sfacek(i, j&
   &             , k-1))*voli
   ! Off-diagonal terms due to the advection term in
   ! k-direction. First order approximation.
   uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
   &           ivz) - qs
   um = zero
   up = zero
   IF (uu .LT. zero) THEN
   um = uu
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (uu .GT. zero) THEN
   up = uu
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   bb(k) = bb(k) - up
   dd(k) = dd(k) + um
   ! Store the central jacobian and rhs in cc and ff.
   ! Multiply the off-diagonal terms and rhs by the iblank
   ! value so the update determined for iblank = 0 is zero.
   CALL PUSHREAL8(rblank)
   rblank = REAL(iblank(i, j, k), realtype)
   CALL PUSHREAL8(cc(k))
   cc(k) = qq(i, j, k)
   CALL PUSHREAL8(ff(k))
   ff(k) = dw(i, j, k, idvt)*rblank
   bb(k) = bb(k)*rblank
   dd(k) = dd(k)*rblank
   ! Set the off diagonal terms to zero if the wall is flagged.
   IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
   &             flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
   &             .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
   &             , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) THEN
   bb(k) = zero
   dd(k) = zero
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   ! Solve the tri-diagonal system in k-direction.
   ! First the backward sweep to eliMinate the upper diagonal dd.
   DO k=nz,2,-1
   CALL PUSHREAL8(f)
   f = dd(k)/cc(k+1)
   CALL PUSHREAL8(cc(k))
   cc(k) = cc(k) - f*bb(k+1)
   CALL PUSHREAL8(ff(k))
   ff(k) = ff(k) - f*ff(k+1)
   END DO
   ! The matrix is now in lower block bi-diagonal form.
   ! Perform a forward sweep to compute the solution.
   CALL PUSHREAL8(ff(2))
   ff(2) = ff(2)/cc(2)
   DO k=3,kl
   CALL PUSHREAL8(ff(k))
   ff(k) = ff(k) - bb(k)*ff(k-1)
   CALL PUSHREAL8(ff(k))
   ff(k) = ff(k)/cc(k)
   END DO
   ! Store the update in dvt.
   DO k=2,kl
   dw(i, j, k, idvt) = ff(k)
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Update the turbulent variables. For explicit relaxation the    *
   !      * update must be relaxed; for implicit relaxation this has been  *
   !      * done via the time step.                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   CALL PUSHREAL8(factor)
   factor = one
   IF (turbrelax .EQ. turbrelaxexplicit) factor = alfaturb
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   CALL PUSHREAL8(w(i, j, k, itu1))
   w(i, j, k, itu1) = w(i, j, k, itu1) + factor*dw(i, j, k, idvt)
   IF (w(i, j, k, itu1) .LT. zero) THEN
   CALL PUSHREAL8(w(i, j, k, itu1))
   w(i, j, k, itu1) = zero
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(w(i, j, k, itu1))
   w(i, j, k, itu1) = w(i, j, k, itu1)
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(w(i, j, k, itu1))
   wb(i, j, k, itu1) = 0.0_8
   ELSE
   CALL POPREAL8(w(i, j, k, itu1))
   END IF
   CALL POPREAL8(w(i, j, k, itu1))
   dwb(i, j, k, idvt) = dwb(i, j, k, idvt) + factor*wb(i, j, k, &
   &           itu1)
   END DO
   END DO
   END DO
   CALL POPREAL8(factor)
   rlvb = 0.0_8
   ddb = 0.0_8
   qqb = 0.0_8
   bbb = 0.0_8
   ffb = 0.0_8
   ccb = 0.0_8
   DO j=jl,2,-1
   DO i=il,2,-1
   DO k=kl,2,-1
   ffb(k) = ffb(k) + dwb(i, j, k, idvt)
   dwb(i, j, k, idvt) = 0.0_8
   END DO
   DO k=kl,3,-1
   CALL POPREAL8(ff(k))
   tempb48 = ffb(k)/cc(k)
   ccb(k) = ccb(k) - ff(k)*tempb48/cc(k)
   ffb(k) = tempb48
   CALL POPREAL8(ff(k))
   bbb(k) = bbb(k) - ff(k-1)*ffb(k)
   ffb(k-1) = ffb(k-1) - bb(k)*ffb(k)
   END DO
   CALL POPREAL8(ff(2))
   tempb47 = ffb(2)/cc(2)
   ccb(2) = ccb(2) - ff(2)*tempb47/cc(2)
   ffb(2) = tempb47
   DO k=2,nz,1
   CALL POPREAL8(ff(k))
   fb = -(bb(k+1)*ccb(k)) - ff(k+1)*ffb(k)
   ffb(k+1) = ffb(k+1) - f*ffb(k)
   CALL POPREAL8(cc(k))
   bbb(k+1) = bbb(k+1) - f*ccb(k)
   CALL POPREAL8(f)
   tempb46 = fb/cc(k+1)
   ddb(k) = ddb(k) + tempb46
   ccb(k+1) = ccb(k+1) - dd(k)*tempb46/cc(k+1)
   END DO
   DO k=kl,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ddb(k) = 0.0_8
   bbb(k) = 0.0_8
   END IF
   ddb(k) = rblank*ddb(k)
   bbb(k) = rblank*bbb(k)
   CALL POPREAL8(ff(k))
   dwb(i, j, k, idvt) = dwb(i, j, k, idvt) + rblank*ffb(k)
   ffb(k) = 0.0_8
   CALL POPREAL8(cc(k))
   qqb(i, j, k) = qqb(i, j, k) + ccb(k)
   ccb(k) = 0.0_8
   CALL POPREAL8(rblank)
   umb = ddb(k)
   upb = -bbb(k)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   uub = upb
   ELSE
   uub = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) uub = uub + umb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + xa*uub
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + ya*uub
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + za*uub
   CALL POPREAL8(dd(k))
   c1pb = -ddb(k)
   ddb(k) = 0.0_8
   CALL POPREAL8(bb(k))
   c1mb = -bbb(k)
   bbb(k) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb42 = ttp*cb3inv*cdpb
   nupb = tempb42
   nutpb = (one+rsacb2)*tempb42
   tempb43 = ttm*cb3inv*cdmb
   numb = tempb43
   nutmb = (one+rsacb2)*tempb43
   temp23 = w(i, j, k+1, irho)
   tempb44 = half*nupb/temp23
   rlvb(i, j, k+1) = rlvb(i, j, k+1) + tempb44
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) - rlv(i, j, k+1)*&
   &           tempb44/temp23
   nub = half*numb + half*nupb
   temp22 = w(i, j, k-1, irho)
   tempb45 = half*numb/temp22
   rlvb(i, j, k-1) = rlvb(i, j, k-1) + tempb45
   wb(i, j, k-1, irho) = wb(i, j, k-1, irho) - rlv(i, j, k-1)*&
   &           tempb45/temp22
   temp21 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp21
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/&
   &           temp21**2
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   wb(i, j, k-1, itu1) = wb(i, j, k-1, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   CALL POPREAL8(ttm)
   CALL POPREAL8(za)
   CALL POPREAL8(ya)
   CALL POPREAL8(xa)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   ffb(i) = ffb(i) + qq(i, j, k)*dwb(i, j, k, idvt)
   qqb(i, j, k) = qqb(i, j, k) + ff(i)*dwb(i, j, k, idvt)
   dwb(i, j, k, idvt) = 0.0_8
   END DO
   DO i=il,3,-1
   CALL POPREAL8(ff(i))
   tempb41 = ffb(i)/cc(i)
   ccb(i) = ccb(i) - ff(i)*tempb41/cc(i)
   ffb(i) = tempb41
   CALL POPREAL8(ff(i))
   bbb(i) = bbb(i) - ff(i-1)*ffb(i)
   ffb(i-1) = ffb(i-1) - bb(i)*ffb(i)
   END DO
   CALL POPREAL8(ff(2))
   tempb40 = ffb(2)/cc(2)
   ccb(2) = ccb(2) - ff(2)*tempb40/cc(2)
   ffb(2) = tempb40
   DO i=2,nx,1
   CALL POPREAL8(ff(i))
   fb = -(bb(i+1)*ccb(i)) - ff(i+1)*ffb(i)
   ffb(i+1) = ffb(i+1) - f*ffb(i)
   CALL POPREAL8(cc(i))
   bbb(i+1) = bbb(i+1) - f*ccb(i)
   CALL POPREAL8(f)
   tempb39 = fb/cc(i+1)
   ddb(i) = ddb(i) + tempb39
   ccb(i+1) = ccb(i+1) - dd(i)*tempb39/cc(i+1)
   END DO
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ddb(i) = 0.0_8
   bbb(i) = 0.0_8
   END IF
   ddb(i) = rblank*ddb(i)
   bbb(i) = rblank*bbb(i)
   CALL POPREAL8(ff(i))
   dwb(i, j, k, idvt) = dwb(i, j, k, idvt) + rblank*ffb(i)
   ffb(i) = 0.0_8
   CALL POPREAL8(cc(i))
   qqb(i, j, k) = qqb(i, j, k) + ccb(i)
   ccb(i) = 0.0_8
   CALL POPREAL8(rblank)
   umb = ddb(i)
   upb = -bbb(i)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   uub = upb
   ELSE
   uub = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) uub = uub + umb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + xa*uub
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + ya*uub
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + za*uub
   CALL POPREAL8(dd(i))
   c1pb = -ddb(i)
   ddb(i) = 0.0_8
   CALL POPREAL8(bb(i))
   c1mb = -bbb(i)
   bbb(i) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb35 = ttp*cb3inv*cdpb
   nupb = tempb35
   nutpb = (one+rsacb2)*tempb35
   tempb36 = ttm*cb3inv*cdmb
   numb = tempb36
   nutmb = (one+rsacb2)*tempb36
   temp20 = w(i+1, j, k, irho)
   tempb37 = half*nupb/temp20
   rlvb(i+1, j, k) = rlvb(i+1, j, k) + tempb37
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) - rlv(i+1, j, k)*&
   &           tempb37/temp20
   nub = half*numb + half*nupb
   temp19 = w(i-1, j, k, irho)
   tempb38 = half*numb/temp19
   rlvb(i-1, j, k) = rlvb(i-1, j, k) + tempb38
   wb(i-1, j, k, irho) = wb(i-1, j, k, irho) - rlv(i-1, j, k)*&
   &           tempb38/temp19
   temp18 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp18
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/&
   &           temp18**2
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   wb(i-1, j, k, itu1) = wb(i-1, j, k, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   CALL POPREAL8(ttm)
   CALL POPREAL8(za)
   CALL POPREAL8(ya)
   CALL POPREAL8(xa)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO i=il,2,-1
   DO j=jl,2,-1
   ffb(j) = ffb(j) + qq(i, j, k)*dwb(i, j, k, idvt)
   qqb(i, j, k) = qqb(i, j, k) + ff(j)*dwb(i, j, k, idvt)
   dwb(i, j, k, idvt) = 0.0_8
   END DO
   DO j=jl,3,-1
   CALL POPREAL8(ff(j))
   tempb34 = ffb(j)/cc(j)
   ccb(j) = ccb(j) - ff(j)*tempb34/cc(j)
   ffb(j) = tempb34
   CALL POPREAL8(ff(j))
   bbb(j) = bbb(j) - ff(j-1)*ffb(j)
   ffb(j-1) = ffb(j-1) - bb(j)*ffb(j)
   END DO
   CALL POPREAL8(ff(2))
   tempb33 = ffb(2)/cc(2)
   ccb(2) = ccb(2) - ff(2)*tempb33/cc(2)
   ffb(2) = tempb33
   DO j=2,ny,1
   CALL POPREAL8(ff(j))
   fb = -(bb(j+1)*ccb(j)) - ff(j+1)*ffb(j)
   ffb(j+1) = ffb(j+1) - f*ffb(j)
   CALL POPREAL8(cc(j))
   bbb(j+1) = bbb(j+1) - f*ccb(j)
   CALL POPREAL8(f)
   tempb32 = fb/cc(j+1)
   ddb(j) = ddb(j) + tempb32
   ccb(j+1) = ccb(j+1) - dd(j)*tempb32/cc(j+1)
   END DO
   DO j=jl,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ddb(j) = 0.0_8
   bbb(j) = 0.0_8
   END IF
   ddb(j) = rblank*ddb(j)
   bbb(j) = rblank*bbb(j)
   CALL POPREAL8(ff(j))
   dwb(i, j, k, idvt) = dwb(i, j, k, idvt) + rblank*ffb(j)
   ffb(j) = 0.0_8
   CALL POPREAL8(cc(j))
   qqb(i, j, k) = qqb(i, j, k) + ccb(j)
   ccb(j) = 0.0_8
   CALL POPREAL8(rblank)
   umb = ddb(j)
   upb = -bbb(j)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   uub = upb
   ELSE
   uub = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) uub = uub + umb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + xa*uub
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + ya*uub
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + za*uub
   CALL POPREAL8(dd(j))
   c1pb = -ddb(j)
   ddb(j) = 0.0_8
   CALL POPREAL8(bb(j))
   c1mb = -bbb(j)
   bbb(j) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb28 = ttp*cb3inv*cdpb
   nupb = tempb28
   nutpb = (one+rsacb2)*tempb28
   tempb29 = ttm*cb3inv*cdmb
   numb = tempb29
   nutmb = (one+rsacb2)*tempb29
   temp17 = w(i, j+1, k, irho)
   tempb30 = half*nupb/temp17
   rlvb(i, j+1, k) = rlvb(i, j+1, k) + tempb30
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) - rlv(i, j+1, k)*&
   &           tempb30/temp17
   nub = half*numb + half*nupb
   temp16 = w(i, j-1, k, irho)
   tempb31 = half*numb/temp16
   rlvb(i, j-1, k) = rlvb(i, j-1, k) + tempb31
   wb(i, j-1, k, irho) = wb(i, j-1, k, irho) - rlv(i, j-1, k)*&
   &           tempb31/temp16
   temp15 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp15
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/&
   &           temp15**2
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   wb(i, j-1, k, itu1) = wb(i, j-1, k, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   CALL POPREAL8(ttm)
   CALL POPREAL8(za)
   CALL POPREAL8(ya)
   CALL POPREAL8(xa)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) qqb(i, j, k) = 0.0_8
   qqb(i, j, k) = factor*qqb(i, j, k)
   END DO
   END DO
   END DO
   END IF
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   tmpb = dwb(i, j, k, itu1)
   dwb(i, j, k, itu1) = 0.0_8
   dwb(i, j, k, idvt) = dwb(i, j, k, idvt) - vol(i, j, k)*rblank*&
   &         tmpb
   CALL POPREAL8(rblank)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   c1b = qqb(i, j, k)
   d1b = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   c1b = qqb(i, j, k)
   d1b = -(max6*qqb(i, j, k))
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max6)
   ELSE
   CALL POPREAL8(max6)
   END IF
   ELSE
   c1b = qqb(i, j, k)
   b1b = -(max5*qqb(i, j, k))
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max5)
   ELSE
   CALL POPREAL8(max5)
   END IF
   d1b = 0.0_8
   GOTO 100
   END IF
   b1b = 0.0_8
   100    c1mb = w(i-1, j, k, itu1)*dwb(i, j, k, idvt) - b1b
   wb(i-1, j, k, itu1) = wb(i-1, j, k, itu1) + c1m*dwb(i, j, k, &
   &         idvt)
   c1pb = w(i+1, j, k, itu1)*dwb(i, j, k, idvt) - d1b
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + c1p*dwb(i, j, k, &
   &         idvt)
   c10b = c1b - w(i, j, k, itu1)*dwb(i, j, k, idvt)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - c10*dwb(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1mb = c1mb + c10b
   c1pb = c1pb + c10b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb24 = ttp*cb3inv*cdpb
   nupb = tempb24
   nutpb = (one+rsacb2)*tempb24
   tempb25 = ttm*cb3inv*cdmb
   numb = tempb25
   nutmb = (one+rsacb2)*tempb25
   temp14 = w(i+1, j, k, irho)
   tempb26 = half*nupb/temp14
   rlvb(i+1, j, k) = rlvb(i+1, j, k) + tempb26
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) - rlv(i+1, j, k)*&
   &         tempb26/temp14
   nub = half*numb + half*nupb
   temp13 = w(i-1, j, k, irho)
   tempb27 = half*numb/temp13
   rlvb(i-1, j, k) = rlvb(i-1, j, k) + tempb27
   wb(i-1, j, k, irho) = wb(i-1, j, k, irho) - rlv(i-1, j, k)*&
   &         tempb27/temp13
   temp12 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp12
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp12&
   &         **2
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   wb(i-1, j, k, itu1) = wb(i-1, j, k, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   CALL POPREAL8(ttm)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   c1b = qqb(i, j, k)
   d1b = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   c1b = qqb(i, j, k)
   d1b = -(max4*qqb(i, j, k))
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max4)
   ELSE
   CALL POPREAL8(max4)
   END IF
   ELSE
   c1b = qqb(i, j, k)
   b1b = -(max3*qqb(i, j, k))
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max3)
   ELSE
   CALL POPREAL8(max3)
   END IF
   d1b = 0.0_8
   GOTO 110
   END IF
   b1b = 0.0_8
   110    c1mb = w(i, j-1, k, itu1)*dwb(i, j, k, idvt) - b1b
   wb(i, j-1, k, itu1) = wb(i, j-1, k, itu1) + c1m*dwb(i, j, k, &
   &         idvt)
   c1pb = w(i, j+1, k, itu1)*dwb(i, j, k, idvt) - d1b
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + c1p*dwb(i, j, k, &
   &         idvt)
   c10b = c1b - w(i, j, k, itu1)*dwb(i, j, k, idvt)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - c10*dwb(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1mb = c1mb + c10b
   c1pb = c1pb + c10b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb20 = ttp*cb3inv*cdpb
   nupb = tempb20
   nutpb = (one+rsacb2)*tempb20
   tempb21 = ttm*cb3inv*cdmb
   numb = tempb21
   nutmb = (one+rsacb2)*tempb21
   temp11 = w(i, j+1, k, irho)
   tempb22 = half*nupb/temp11
   rlvb(i, j+1, k) = rlvb(i, j+1, k) + tempb22
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) - rlv(i, j+1, k)*&
   &         tempb22/temp11
   nub = half*numb + half*nupb
   temp10 = w(i, j-1, k, irho)
   tempb23 = half*numb/temp10
   rlvb(i, j-1, k) = rlvb(i, j-1, k) + tempb23
   wb(i, j-1, k, irho) = wb(i, j-1, k, irho) - rlv(i, j-1, k)*&
   &         tempb23/temp10
   temp9 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp9
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp9**&
   &         2
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   wb(i, j-1, k, itu1) = wb(i, j-1, k, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   CALL POPREAL8(ttm)
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   c1b = qqb(i, j, k)
   d1b = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   c1b = qqb(i, j, k)
   d1b = -(max2*qqb(i, j, k))
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max2)
   ELSE
   CALL POPREAL8(max2)
   END IF
   ELSE
   c1b = qqb(i, j, k)
   b1b = -(max1*qqb(i, j, k))
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max1)
   ELSE
   CALL POPREAL8(max1)
   END IF
   d1b = 0.0_8
   GOTO 120
   END IF
   b1b = 0.0_8
   120    c1mb = w(i, j, k-1, itu1)*dwb(i, j, k, idvt) - b1b
   wb(i, j, k-1, itu1) = wb(i, j, k-1, itu1) + c1m*dwb(i, j, k, &
   &         idvt)
   c1pb = w(i, j, k+1, itu1)*dwb(i, j, k, idvt) - d1b
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + c1p*dwb(i, j, k, &
   &         idvt)
   c10b = c1b - w(i, j, k, itu1)*dwb(i, j, k, idvt)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - c10*dwb(i, j, k, idvt)
   CALL POPREAL8(c10)
   c1mb = c1mb + c10b
   c1pb = c1pb + c10b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1p)
   cdpb = 0.0_8
   capb = 0.0_8
   ELSE
   CALL POPREAL8(c1p)
   cdpb = c1pb
   capb = c1pb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(c1m)
   cdmb = 0.0_8
   camb = 0.0_8
   ELSE
   CALL POPREAL8(c1m)
   cdmb = c1mb
   camb = c1mb
   END IF
   tempb16 = ttp*cb3inv*cdpb
   nupb = tempb16
   nutpb = (one+rsacb2)*tempb16
   tempb17 = ttm*cb3inv*cdmb
   numb = tempb17
   nutmb = (one+rsacb2)*tempb17
   temp8 = w(i, j, k+1, irho)
   tempb18 = half*nupb/temp8
   rlvb(i, j, k+1) = rlvb(i, j, k+1) + tempb18
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) - rlv(i, j, k+1)*&
   &         tempb18/temp8
   nub = half*numb + half*nupb
   temp7 = w(i, j, k-1, irho)
   tempb19 = half*numb/temp7
   rlvb(i, j, k-1) = rlvb(i, j, k-1) + tempb19
   wb(i, j, k-1, irho) = wb(i, j, k-1, irho) - rlv(i, j, k-1)*&
   &         tempb19/temp7
   temp6 = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp6
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp6**&
   &         2
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + half*nutpb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutpb
   wb(i, j, k-1, itu1) = wb(i, j, k-1, itu1) + half*nutmb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + half*nutmb
   cnudb = ttm*camb + ttp*capb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - rsacb2*cb3inv*cnudb
   CALL POPREAL8(ttp)
   CALL POPREAL8(ttm)
   END DO
   END DO
   END DO
   CALL UNSTEADYTURBTERM_B(1_intType, 1_intType, nn, qq, qqb)
   CALL POPREAL8ARRAY(dw, SIZE(dw, 1)*SIZE(dw, 2)*SIZE(dw, 3)*SIZE(dw, 4)&
   &             )
   CALL TURBADVECTION_B(1_intType, 1_intType, nn, qq, qqb)
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) qqb(i, j, k) = 0.0_8
   gg = rr + rsacw2*(rr**6-rr)
   gg6 = gg**6
   termfw = ((one+cw36)/(gg6+cw36))**sixth
   fwsa = gg*termfw
   nu = rlv(i, j, k)/w(i, j, k, irho)
   chi = w(i, j, k, itu1)/nu
   chi2 = chi*chi
   chi3 = chi*chi2
   fv1 = chi3/(chi3+cv13)
   fv2 = one - chi/(one+chi*fv1)
   dist2inv = one/d2wall(i, j, k)**2
   term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
   &         )
   dfv1 = three*chi2*cv13/(chi3+cv13)**2
   dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
   dft2 = -(two*rsact4*chi*ft2/nu)
   dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
   dfw = cw36/(gg6+cw36)*termfw*dgg
   temp5 = w(i, j, k, itu1)
   tempb4 = -(dist2inv*temp5**2*qqb(i, j, k))
   tempb5 = rsacb1*kar2inv*tempb4
   term2b = -(two*w(i, j, k, itu1)*qqb(i, j, k))
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + (-((rsacb1*kar2inv*(dfv2&
   &         -ft2*dfv2+dft2-fv2*dft2)-rsacw1*dfw)*dist2inv*2*temp5)-two*&
   &         term2)*qqb(i, j, k)
   dft2b = (1.0_8-fv2)*tempb5
   dfwb = -(rsacw1*tempb4)
   qqb(i, j, k) = 0.0_8
   tempb9 = cw36*dfwb/(cw36+gg6)
   dggb = termfw*tempb9
   rrb = six*rsacw2*drr*5*rr**4*dggb
   drrb = (one-rsacw2+six*rsacw2*rr**5)*dggb
   CALL POPREAL8(drr)
   temp4 = w(i, j, k, itu1)
   tempb10 = kar2inv*dist2inv*drrb/sst
   tempb6 = -(rr*tempb10)
   dfv2b = temp4*tempb6 + (1.0_8-ft2)*tempb5
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + dfv2*tempb6
   sstb = -((one-rr*(fv2+temp4*dfv2))*tempb10/sst)
   tempb7 = -(two*rsact4*dft2b/nu)
   temp3 = one + chi*fv1
   temp2 = nu*temp3**2
   tempb13 = dfv2b/temp2
   tempb12 = -((chi2*dfv1-one)*tempb13/temp2)
   nub = temp3**2*tempb12 - chi*ft2*tempb7/nu
   tempb11 = nu*2*temp3*tempb12
   chib = fv1*tempb11 + ft2*tempb7
   dfv1b = chi2*tempb13
   fv1b = chi*tempb11
   tempb14 = three*cv13*dfv1b/(cv13+chi3)**2
   chi2b = tempb14 + dfv1*tempb13
   chi3b = -(chi2*2*tempb14/(cv13+chi3))
   term1 = rsacb1*(one-ft2)*ss
   CALL POPREAL8(dw(i, j, k, idvt))
   tempb15 = w(i, j, k, itu1)*dwb(i, j, k, idvt)
   temp1 = w(i, j, k, itu1)
   term1b = tempb15
   term2b = term2b + temp1*tempb15
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + (term1+term2*temp1)*dwb(&
   &         i, j, k, idvt) + term2*tempb15
   dwb(i, j, k, idvt) = 0.0_8
   tempb8 = dist2inv*kar2inv*rsacb1*term2b
   ft2b = chi*tempb7 - ss*rsacb1*term1b + (1.0_8-fv2)*tempb8 - dfv2&
   &         *tempb5
   fv2b = tempb6 + (one-ft2)*tempb8 - dft2*tempb5
   fwsab = -(dist2inv*rsacw1*term2b)
   termfwb = gg*fwsab + dgg*tempb9
   ssb = rsacb1*(one-ft2)*term1b
   temp0 = (one+cw36)/(cw36+gg6)
   IF (temp0 .LE. 0.0_8 .AND. (sixth .EQ. 0.0_8 .OR. sixth .NE. INT&
   &           (sixth))) THEN
   gg6b = -(termfw*dgg*tempb9/(cw36+gg6))
   ELSE
   gg6b = -(sixth*temp0**(sixth-1)*temp0*termfwb/(cw36+gg6)) - &
   &           termfw*dgg*tempb9/(cw36+gg6)
   END IF
   ggb = 6*gg**5*gg6b + termfw*fwsab
   rrb = rrb + (rsacw2*6*rr**5-rsacw2+1.0_8)*ggb - (fv2+temp4*dfv2)&
   &         *tempb10
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) rrb = 0.0_8
   CALL POPREAL8(rr)
   tempb3 = kar2inv*dist2inv*rrb/sst
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + tempb3
   sstb = sstb - w(i, j, k, itu1)*tempb3/sst
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) sstb = 0.0_8
   CALL POPREAL8(sst)
   tempb = kar2inv*dist2inv*sstb
   ssb = ssb + sstb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + fv2*tempb
   fv2b = fv2b + w(i, j, k, itu1)*tempb
   CALL POPREAL8(ft2)
   tempb0 = -(fv2b/(one+chi*fv1))
   tempb1 = -(chi*tempb0/(one+chi*fv1))
   fv1b = fv1b + chi*tempb1
   tempb2 = fv1b/(cv13+chi3)
   chi3b = chi3b + (1.0_8-chi3/(cv13+chi3))*tempb2
   chi2b = chi2b + chi*chi3b - EXP(-(rsact4*chi2))*rsact3*rsact4*&
   &         ft2b
   chib = chib + chi2*chi3b + 2*chi*chi2b + fv1*tempb1 + tempb0
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + chib/nu
   nub = nub - w(i, j, k, itu1)*chib/nu**2
   temp = w(i, j, k, irho)
   rlvb(i, j, k) = rlvb(i, j, k) + nub/temp
   wb(i, j, k, irho) = wb(i, j, k, irho) - rlv(i, j, k)*nub/temp**2
   CALL POPREAL8(ss)
   IF (.NOT.dw(i, j, k, iprod) .EQ. 0.0_8) dwb(i, j, k, iprod) = &
   &           dwb(i, j, k, iprod) + ssb/(2.0*SQRT(dw(i, j, k, iprod)))
   END DO
   END DO
   END DO
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   CALL PRODKATOLAUNDER_B()
   ELSE
   CALL PRODWMAG2_B()
   END IF
   ELSE IF (branch .EQ. 2) THEN
   CALL PRODSMAG2_B()
   END IF
   END SUBROUTINE SASOLVE_B

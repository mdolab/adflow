   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcnswalladiabatic in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *bvtj1 *bvtj2 *p *gamma
   !                *w *rlv *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2 tref
   !                rgas
   !   with respect to varying inputs: *rev *p *w *rlv *d2wall tref
   !                rgas
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in p:in
   !                gamma:in w:in rlv:in bvtk1:in bvtk2:in d2wall:in
   !                bvti1:in bvti2:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcNsWallAdiabatic.f90                           *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-10-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCNSWALLADIABATIC_B(secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcNSWallAdiabatic applies the viscous adiabatic wall           *
   !      * boundary condition to a block. It is assumed that the pointers *
   !      * in blockPointers are already set to the correct block on the   *
   !      * correct grid level.                                            *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j
   REAL(kind=realtype) :: rhok
   REAL(kind=realtype) :: rhokd
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   REAL(kind=realtype) :: tmp3
   REAL(kind=realtype) :: tmp4
   REAL(kind=realtype) :: tmp5
   REAL(kind=realtype) :: tmp6
   REAL(kind=realtype) :: tmp7
   REAL(kind=realtype) :: tmp8
   REAL(kind=realtype) :: tmp9
   REAL(kind=realtype) :: tmp10
   REAL(kind=realtype) :: tmp11
   REAL(kind=realtype) :: tmp12
   REAL(kind=realtype) :: tmp13
   REAL(kind=realtype) :: tmp14
   REAL(kind=realtype) :: tmp15
   REAL(kind=realtype) :: tmp16
   REAL(kind=realtype) :: tmp17
   REAL(kind=realtype) :: tmp18
   REAL(kind=realtype) :: tmp19
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: ad_from5
   INTEGER :: ad_to5
   INTEGER :: ad_from6
   INTEGER :: ad_to6
   INTEGER :: ad_from7
   INTEGER :: ad_to7
   INTEGER :: ad_from8
   INTEGER :: ad_to8
   INTEGER :: ad_from9
   INTEGER :: ad_to9
   INTEGER :: ad_from10
   INTEGER :: ad_to10
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tmpd19
   REAL(kind=realtype) :: tmpd18
   REAL(kind=realtype) :: tmpd17
   REAL(kind=realtype) :: tmpd16
   REAL(kind=realtype) :: tmpd15
   REAL(kind=realtype) :: tmpd14
   REAL(kind=realtype) :: tmpd13
   REAL(kind=realtype) :: tmpd12
   REAL(kind=realtype) :: tmpd11
   REAL(kind=realtype) :: tmpd10
   REAL(kind=realtype) :: tmpd9
   REAL(kind=realtype) :: tmpd8
   REAL(kind=realtype) :: tmpd7
   REAL(kind=realtype) :: tmpd6
   REAL(kind=realtype) :: tmpd5
   REAL(kind=realtype) :: tmpd4
   REAL(kind=realtype) :: tmpd3
   REAL(kind=realtype) :: tmpd2
   REAL(kind=realtype) :: tmpd1
   REAL(kind=realtype) :: tmpd0
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   IF (turbcoupled) THEN
   CALL PUSHREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2&
   &                 , 3)*SIZE(bmtj2, 4))
   CALL PUSHREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1&
   &                 , 3)*SIZE(bmtj1, 4))
   CALL PUSHREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2&
   &                 , 3)*SIZE(bmti2, 4))
   CALL PUSHREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1&
   &                 , 3)*SIZE(bmti1, 4))
   CALL PUSHREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2&
   &                 , 3)*SIZE(bmtk2, 4))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1&
   &                 , 3)*SIZE(bmtk1, 4))
   CALL PUSHREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1&
   &                 , 3))
   CALL TURBBCNSWALL(.false.)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   ! Loop over the viscous subfaces of this block. Note that
   ! these are numbered first.
   bocos:DO nn=1,nviscbocos
   ! Check for adiabatic viscous wall boundary conditions.
   IF (bctype(nn) .EQ. nswalladiabatic) THEN
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   ad_from0 = bcdata(nn)%jcbeg
   DO j=ad_from0,bcdata(nn)%jcend
   ad_from = bcdata(nn)%icbeg
   DO i=ad_from,bcdata(nn)%icend
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) THEN
   rhok = w(2, i, j, irho)*w(2, i, j, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   CALL PUSHREAL8(w(1, i, j, irho))
   w(1, i, j, irho) = w(2, i, j, irho)
   CALL PUSHREAL8(w(1, i, j, ivx))
   w(1, i, j, ivx) = -w(2, i, j, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   CALL PUSHREAL8(w(1, i, j, ivy))
   w(1, i, j, ivy) = -w(2, i, j, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   CALL PUSHREAL8(w(1, i, j, ivz))
   w(1, i, j, ivz) = -w(2, i, j, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   CALL PUSHREAL8(p(1, i, j))
   p(1, i, j) = p(2, i, j) - four*third*rhok
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   CALL PUSHREAL8(rlv(1, i, j))
   rlv(1, i, j) = rlv(2, i, j)
   IF (eddymodel) THEN
   rev(1, i, j) = -rev(2, i, j)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL3B(1)
   CASE (imax) 
   ad_from2 = bcdata(nn)%jcbeg
   DO j=ad_from2,bcdata(nn)%jcend
   ad_from1 = bcdata(nn)%icbeg
   DO i=ad_from1,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(il, i, j, irho)*w(il, i, j, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = w(il, i, j, irho)
   CALL PUSHREAL8(w(ie, i, j, irho))
   w(ie, i, j, irho) = tmp
   tmp0 = -w(il, i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   CALL PUSHREAL8(w(ie, i, j, ivx))
   w(ie, i, j, ivx) = tmp0
   tmp1 = -w(il, i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   CALL PUSHREAL8(w(ie, i, j, ivy))
   w(ie, i, j, ivy) = tmp1
   tmp2 = -w(il, i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   CALL PUSHREAL8(w(ie, i, j, ivz))
   w(ie, i, j, ivz) = tmp2
   tmp3 = p(il, i, j) - four*third*rhok
   CALL PUSHREAL8(p(ie, i, j))
   p(ie, i, j) = tmp3
   tmp4 = rlv(il, i, j)
   CALL PUSHREAL8(rlv(ie, i, j))
   rlv(ie, i, j) = tmp4
   IF (eddymodel) THEN
   tmp5 = -rev(il, i, j)
   rev(ie, i, j) = tmp5
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from2)
   CALL PUSHCONTROL3B(2)
   CASE (jmin) 
   ad_from4 = bcdata(nn)%jcbeg
   DO j=ad_from4,bcdata(nn)%jcend
   ad_from3 = bcdata(nn)%icbeg
   DO i=ad_from3,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, 2, j, irho)*w(i, 2, j, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(w(i, 1, j, irho))
   w(i, 1, j, irho) = w(i, 2, j, irho)
   CALL PUSHREAL8(w(i, 1, j, ivx))
   w(i, 1, j, ivx) = -w(i, 2, j, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   CALL PUSHREAL8(w(i, 1, j, ivy))
   w(i, 1, j, ivy) = -w(i, 2, j, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   CALL PUSHREAL8(w(i, 1, j, ivz))
   w(i, 1, j, ivz) = -w(i, 2, j, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   CALL PUSHREAL8(p(i, 1, j))
   p(i, 1, j) = p(i, 2, j) - four*third*rhok
   CALL PUSHREAL8(rlv(i, 1, j))
   rlv(i, 1, j) = rlv(i, 2, j)
   IF (eddymodel) THEN
   rev(i, 1, j) = -rev(i, 2, j)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   ad_from6 = bcdata(nn)%jcbeg
   DO j=ad_from6,bcdata(nn)%jcend
   ad_from5 = bcdata(nn)%icbeg
   DO i=ad_from5,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, jl, j, irho)*w(i, jl, j, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   tmp6 = w(i, jl, j, irho)
   CALL PUSHREAL8(w(i, je, j, irho))
   w(i, je, j, irho) = tmp6
   tmp7 = -w(i, jl, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   CALL PUSHREAL8(w(i, je, j, ivx))
   w(i, je, j, ivx) = tmp7
   tmp8 = -w(i, jl, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   CALL PUSHREAL8(w(i, je, j, ivy))
   w(i, je, j, ivy) = tmp8
   tmp9 = -w(i, jl, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   CALL PUSHREAL8(w(i, je, j, ivz))
   w(i, je, j, ivz) = tmp9
   tmp10 = p(i, jl, j) - four*third*rhok
   CALL PUSHREAL8(p(i, je, j))
   p(i, je, j) = tmp10
   tmp11 = rlv(i, jl, j)
   CALL PUSHREAL8(rlv(i, je, j))
   rlv(i, je, j) = tmp11
   IF (eddymodel) THEN
   tmp12 = -rev(i, jl, j)
   rev(i, je, j) = tmp12
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from5)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from6)
   CALL PUSHCONTROL3B(4)
   CASE (kmin) 
   ad_from8 = bcdata(nn)%jcbeg
   DO j=ad_from8,bcdata(nn)%jcend
   ad_from7 = bcdata(nn)%icbeg
   DO i=ad_from7,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, j, 1, irho)*w(i, j, 1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(w(i, j, 1, irho))
   w(i, j, 1, irho) = w(i, j, 2, irho)
   CALL PUSHREAL8(w(i, j, 1, ivx))
   w(i, j, 1, ivx) = -w(i, j, 2, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   CALL PUSHREAL8(w(i, j, 1, ivy))
   w(i, j, 1, ivy) = -w(i, j, 2, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   CALL PUSHREAL8(w(i, j, 1, ivz))
   w(i, j, 1, ivz) = -w(i, j, 2, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   CALL PUSHREAL8(p(i, j, 1))
   p(i, j, 1) = p(i, j, 2) - four*third*rhok
   CALL PUSHREAL8(rlv(i, j, 1))
   rlv(i, j, 1) = rlv(i, j, 2)
   IF (eddymodel) THEN
   rev(i, j, 1) = -rev(i, j, 2)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from7)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from8)
   CALL PUSHCONTROL3B(5)
   CASE (kmax) 
   ad_from10 = bcdata(nn)%jcbeg
   DO j=ad_from10,bcdata(nn)%jcend
   ad_from9 = bcdata(nn)%icbeg
   DO i=ad_from9,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, j, 1, irho)*w(i, j, 1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   tmp13 = w(i, j, kl, irho)
   CALL PUSHREAL8(w(i, j, ke, irho))
   w(i, j, ke, irho) = tmp13
   tmp14 = -w(i, j, kl, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   CALL PUSHREAL8(w(i, j, ke, ivx))
   w(i, j, ke, ivx) = tmp14
   tmp15 = -w(i, j, kl, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   CALL PUSHREAL8(w(i, j, ke, ivy))
   w(i, j, ke, ivy) = tmp15
   tmp16 = -w(i, j, kl, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   CALL PUSHREAL8(w(i, j, ke, ivz))
   w(i, j, ke, ivz) = tmp16
   tmp17 = p(i, j, kl) - four*third*rhok
   CALL PUSHREAL8(p(i, j, ke))
   p(i, j, ke) = tmp17
   tmp18 = rlv(i, j, jl)
   CALL PUSHREAL8(rlv(i, j, ke))
   rlv(i, j, ke) = tmp18
   IF (eddymodel) THEN
   tmp19 = -rev(i, j, jl)
   rev(i, j, ke) = tmp19
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from9)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from10)
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4)&
   &                  )
   CALL COMPUTEETOT(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                   kcbeg(nn), kcend(nn), correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, &
   &                     4))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL EXTRAPOLATE2NDHALO(nn, correctfork)
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO bocos
   DO nn=nviscbocos,1,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4&
   &                    ))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL EXTRAPOLATE2NDHALO_B(nn, correctfork)
   END IF
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL COMPUTEETOT_B(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                  kcbeg(nn), kcend(nn), correctfork)
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .NE. 0) THEN
   IF (branch .EQ. 1) THEN
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   revd(2, i, j) = revd(2, i, j) - revd(1, i, j)
   revd(1, i, j) = 0.0_8
   END IF
   CALL POPREAL8(rlv(1, i, j))
   rlvd(2, i, j) = rlvd(2, i, j) + rlvd(1, i, j)
   rlvd(1, i, j) = 0.0_8
   CALL POPREAL8(p(1, i, j))
   pd(2, i, j) = pd(2, i, j) + pd(1, i, j)
   rhokd = rhokd - four*third*pd(1, i, j)
   pd(1, i, j) = 0.0_8
   CALL POPREAL8(w(1, i, j, ivz))
   wd(2, i, j, ivz) = wd(2, i, j, ivz) - wd(1, i, j, ivz)
   wd(1, i, j, ivz) = 0.0_8
   CALL POPREAL8(w(1, i, j, ivy))
   wd(2, i, j, ivy) = wd(2, i, j, ivy) - wd(1, i, j, ivy)
   wd(1, i, j, ivy) = 0.0_8
   CALL POPREAL8(w(1, i, j, ivx))
   wd(2, i, j, ivx) = wd(2, i, j, ivx) - wd(1, i, j, ivx)
   wd(1, i, j, ivx) = 0.0_8
   CALL POPREAL8(w(1, i, j, irho))
   wd(2, i, j, irho) = wd(2, i, j, irho) + wd(1, i, j, irho&
   &                 )
   wd(1, i, j, irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(2, i, j, irho) = wd(2, i, j, irho) + w(2, i, j, &
   &                   itu1)*rhokd
   wd(2, i, j, itu1) = wd(2, i, j, itu1) + w(2, i, j, &
   &                   irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO j=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd5 = revd(ie, i, j)
   revd(ie, i, j) = 0.0_8
   revd(il, i, j) = revd(il, i, j) - tmpd5
   END IF
   CALL POPREAL8(rlv(ie, i, j))
   tmpd = rlvd(ie, i, j)
   rlvd(ie, i, j) = 0.0_8
   rlvd(il, i, j) = rlvd(il, i, j) + tmpd
   CALL POPREAL8(p(ie, i, j))
   tmpd0 = pd(ie, i, j)
   pd(ie, i, j) = 0.0_8
   pd(il, i, j) = pd(il, i, j) + tmpd0
   rhokd = rhokd - four*third*tmpd0
   CALL POPREAL8(w(ie, i, j, ivz))
   tmpd1 = wd(ie, i, j, ivz)
   wd(ie, i, j, ivz) = 0.0_8
   wd(il, i, j, ivz) = wd(il, i, j, ivz) - tmpd1
   CALL POPREAL8(w(ie, i, j, ivy))
   tmpd2 = wd(ie, i, j, ivy)
   wd(ie, i, j, ivy) = 0.0_8
   wd(il, i, j, ivy) = wd(il, i, j, ivy) - tmpd2
   CALL POPREAL8(w(ie, i, j, ivx))
   tmpd3 = wd(ie, i, j, ivx)
   wd(ie, i, j, ivx) = 0.0_8
   wd(il, i, j, ivx) = wd(il, i, j, ivx) - tmpd3
   CALL POPREAL8(w(ie, i, j, irho))
   tmpd4 = wd(ie, i, j, irho)
   wd(ie, i, j, irho) = 0.0_8
   wd(il, i, j, irho) = wd(il, i, j, irho) + tmpd4
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(il, i, j, irho) = wd(il, i, j, irho) + w(il, i, j, &
   &                   itu1)*rhokd
   wd(il, i, j, itu1) = wd(il, i, j, itu1) + w(il, i, j, &
   &                   irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   END IF
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO i=ad_to3,ad_from3,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   revd(i, 2, j) = revd(i, 2, j) - revd(i, 1, j)
   revd(i, 1, j) = 0.0_8
   END IF
   CALL POPREAL8(rlv(i, 1, j))
   rlvd(i, 2, j) = rlvd(i, 2, j) + rlvd(i, 1, j)
   rlvd(i, 1, j) = 0.0_8
   CALL POPREAL8(p(i, 1, j))
   pd(i, 2, j) = pd(i, 2, j) + pd(i, 1, j)
   rhokd = rhokd - four*third*pd(i, 1, j)
   pd(i, 1, j) = 0.0_8
   CALL POPREAL8(w(i, 1, j, ivz))
   wd(i, 2, j, ivz) = wd(i, 2, j, ivz) - wd(i, 1, j, ivz)
   wd(i, 1, j, ivz) = 0.0_8
   CALL POPREAL8(w(i, 1, j, ivy))
   wd(i, 2, j, ivy) = wd(i, 2, j, ivy) - wd(i, 1, j, ivy)
   wd(i, 1, j, ivy) = 0.0_8
   CALL POPREAL8(w(i, 1, j, ivx))
   wd(i, 2, j, ivx) = wd(i, 2, j, ivx) - wd(i, 1, j, ivx)
   wd(i, 1, j, ivx) = 0.0_8
   CALL POPREAL8(w(i, 1, j, irho))
   wd(i, 2, j, irho) = wd(i, 2, j, irho) + wd(i, 1, j, irho)
   wd(i, 1, j, irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, 2, j, irho) = wd(i, 2, j, irho) + w(i, 2, j, itu1)&
   &                 *rhokd
   wd(i, 2, j, itu1) = wd(i, 2, j, itu1) + w(i, 2, j, irho)&
   &                 *rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO j=ad_to6,ad_from6,-1
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO i=ad_to5,ad_from5,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd12 = revd(i, je, j)
   revd(i, je, j) = 0.0_8
   revd(i, jl, j) = revd(i, jl, j) - tmpd12
   END IF
   CALL POPREAL8(rlv(i, je, j))
   tmpd6 = rlvd(i, je, j)
   rlvd(i, je, j) = 0.0_8
   rlvd(i, jl, j) = rlvd(i, jl, j) + tmpd6
   CALL POPREAL8(p(i, je, j))
   tmpd7 = pd(i, je, j)
   pd(i, je, j) = 0.0_8
   pd(i, jl, j) = pd(i, jl, j) + tmpd7
   rhokd = rhokd - four*third*tmpd7
   CALL POPREAL8(w(i, je, j, ivz))
   tmpd8 = wd(i, je, j, ivz)
   wd(i, je, j, ivz) = 0.0_8
   wd(i, jl, j, ivz) = wd(i, jl, j, ivz) - tmpd8
   CALL POPREAL8(w(i, je, j, ivy))
   tmpd9 = wd(i, je, j, ivy)
   wd(i, je, j, ivy) = 0.0_8
   wd(i, jl, j, ivy) = wd(i, jl, j, ivy) - tmpd9
   CALL POPREAL8(w(i, je, j, ivx))
   tmpd10 = wd(i, je, j, ivx)
   wd(i, je, j, ivx) = 0.0_8
   wd(i, jl, j, ivx) = wd(i, jl, j, ivx) - tmpd10
   CALL POPREAL8(w(i, je, j, irho))
   tmpd11 = wd(i, je, j, irho)
   wd(i, je, j, irho) = 0.0_8
   wd(i, jl, j, irho) = wd(i, jl, j, irho) + tmpd11
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, jl, j, irho) = wd(i, jl, j, irho) + w(i, jl, j, &
   &                 itu1)*rhokd
   wd(i, jl, j, itu1) = wd(i, jl, j, itu1) + w(i, jl, j, &
   &                 irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   END IF
   ELSE IF (branch .EQ. 5) THEN
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from8)
   CALL POPINTEGER4(ad_to8)
   DO j=ad_to8,ad_from8,-1
   CALL POPINTEGER4(ad_from7)
   CALL POPINTEGER4(ad_to7)
   DO i=ad_to7,ad_from7,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   revd(i, j, 2) = revd(i, j, 2) - revd(i, j, 1)
   revd(i, j, 1) = 0.0_8
   END IF
   CALL POPREAL8(rlv(i, j, 1))
   rlvd(i, j, 2) = rlvd(i, j, 2) + rlvd(i, j, 1)
   rlvd(i, j, 1) = 0.0_8
   CALL POPREAL8(p(i, j, 1))
   pd(i, j, 2) = pd(i, j, 2) + pd(i, j, 1)
   rhokd = rhokd - four*third*pd(i, j, 1)
   pd(i, j, 1) = 0.0_8
   CALL POPREAL8(w(i, j, 1, ivz))
   wd(i, j, 2, ivz) = wd(i, j, 2, ivz) - wd(i, j, 1, ivz)
   wd(i, j, 1, ivz) = 0.0_8
   CALL POPREAL8(w(i, j, 1, ivy))
   wd(i, j, 2, ivy) = wd(i, j, 2, ivy) - wd(i, j, 1, ivy)
   wd(i, j, 1, ivy) = 0.0_8
   CALL POPREAL8(w(i, j, 1, ivx))
   wd(i, j, 2, ivx) = wd(i, j, 2, ivx) - wd(i, j, 1, ivx)
   wd(i, j, 1, ivx) = 0.0_8
   CALL POPREAL8(w(i, j, 1, irho))
   wd(i, j, 2, irho) = wd(i, j, 2, irho) + wd(i, j, 1, irho)
   wd(i, j, 1, irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, j, 1, irho) = wd(i, j, 1, irho) + w(i, j, 1, itu1)*&
   &               rhokd
   wd(i, j, 1, itu1) = wd(i, j, 1, itu1) + w(i, j, 1, irho)*&
   &               rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from10)
   CALL POPINTEGER4(ad_to10)
   DO j=ad_to10,ad_from10,-1
   CALL POPINTEGER4(ad_from9)
   CALL POPINTEGER4(ad_to9)
   DO i=ad_to9,ad_from9,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd19 = revd(i, j, ke)
   revd(i, j, ke) = 0.0_8
   revd(i, j, jl) = revd(i, j, jl) - tmpd19
   END IF
   CALL POPREAL8(rlv(i, j, ke))
   tmpd13 = rlvd(i, j, ke)
   rlvd(i, j, ke) = 0.0_8
   rlvd(i, j, jl) = rlvd(i, j, jl) + tmpd13
   CALL POPREAL8(p(i, j, ke))
   tmpd14 = pd(i, j, ke)
   pd(i, j, ke) = 0.0_8
   pd(i, j, kl) = pd(i, j, kl) + tmpd14
   rhokd = rhokd - four*third*tmpd14
   CALL POPREAL8(w(i, j, ke, ivz))
   tmpd15 = wd(i, j, ke, ivz)
   wd(i, j, ke, ivz) = 0.0_8
   wd(i, j, kl, ivz) = wd(i, j, kl, ivz) - tmpd15
   CALL POPREAL8(w(i, j, ke, ivy))
   tmpd16 = wd(i, j, ke, ivy)
   wd(i, j, ke, ivy) = 0.0_8
   wd(i, j, kl, ivy) = wd(i, j, kl, ivy) - tmpd16
   CALL POPREAL8(w(i, j, ke, ivx))
   tmpd17 = wd(i, j, ke, ivx)
   wd(i, j, ke, ivx) = 0.0_8
   wd(i, j, kl, ivx) = wd(i, j, kl, ivx) - tmpd17
   CALL POPREAL8(w(i, j, ke, irho))
   tmpd18 = wd(i, j, ke, irho)
   wd(i, j, ke, irho) = 0.0_8
   wd(i, j, kl, irho) = wd(i, j, kl, irho) + tmpd18
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, j, 1, irho) = wd(i, j, 1, irho) + w(i, j, 1, itu1)*&
   &               rhokd
   wd(i, j, 1, itu1) = wd(i, j, 1, itu1) + w(i, j, 1, irho)*&
   &               rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   END IF
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1, &
   &                3))
   CALL POPREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2, &
   &                3))
   CALL POPREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1, &
   &                3)*SIZE(bmtk1, 4))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2, &
   &                3)*SIZE(bmtk2, 4))
   CALL POPREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1, &
   &                3))
   CALL POPREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2, &
   &                3))
   CALL POPREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1, &
   &                3)*SIZE(bmti1, 4))
   CALL POPREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2, &
   &                3)*SIZE(bmti2, 4))
   CALL POPREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1, &
   &                3))
   CALL POPREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2, &
   &                3))
   CALL POPREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1, &
   &                3)*SIZE(bmtj1, 4))
   CALL POPREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2, &
   &                3)*SIZE(bmtj2, 4))
   CALL TURBBCNSWALL_B(.false.)
   END IF
   END SUBROUTINE BCNSWALLADIABATIC_B

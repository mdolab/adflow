!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of eintarray in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: tref rgas p eint rho
!   with respect to varying inputs: tref rgas k p eint rho
!      ==================================================================
subroutine eintarray_b(rho, rhod, p, pd, k, kd, eint, eintd, correctfork&
& , kk)
!
!      ******************************************************************
!      *                                                                *
!      * eintarray computes the internal energy per unit mass from the  *
!      * given density and pressure (and possibly turbulent energy) for *
!      * the given kk elements of the arrays.                           *
!      * for a calorically and thermally perfect gas the well-known     *
!      * expression is used; for only a thermally perfect gas, cp is a  *
!      * function of temperature, curve fits are used and a more        *
!      * complex expression is obtained.                                *
!      *                                                                *
!      ******************************************************************
!
  use constants
  use cpcurvefits
  use flowvarrefstate
  use inputphysics
  implicit none
  integer(kind=inttype), intent(in) :: kk
!
!      subroutine arguments.
!
  real(kind=realtype), dimension(kk), intent(in) :: rho, p, k
  real(kind=realtype), dimension(kk) :: rhod, pd, kd
  real(kind=realtype), dimension(kk) :: eint
  real(kind=realtype), dimension(kk) :: eintd
  logical, intent(in) :: correctfork
!
!      local parameter.
!
  real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
  integer(kind=inttype) :: i, nn, mm, ii, start
  real(kind=realtype) :: ovgm1, factk, pp, t, t2, scale
  real(kind=realtype) :: ppd, td, t2d, scaled
  intrinsic log
  integer :: ad_count
  integer :: i0
  integer :: branch
  integer :: ad_to
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! determine the cp model used in the computation.
  select case  (cpmodel) 
  case (cpconstant) 
! abbreviate 1/(gamma -1) a bit easier.
    ovgm1 = one/(gammaconstant-one)
! second step. correct the energy in case a turbulent kinetic
! energy is present.
    if (correctfork) then
      factk = ovgm1*(five*third-gammaconstant)
      kd = 0.0_8
      do i=kk,1,-1
        kd(i) = kd(i) - factk*eintd(i)
      end do
    else
      kd = 0.0_8
    end if
    do i=kk,1,-1
      tempd = ovgm1*eintd(i)/rho(i)
      pd(i) = pd(i) + tempd
      rhod(i) = rhod(i) - p(i)*tempd/rho(i)
      eintd(i) = 0.0_8
    end do
  case (cptempcurvefits) 
!        ================================================================
! cp as function of the temperature is given via curve fits.
! store a scale factor to compute the nondimensional
! internal energy.
    scale = rgas/tref
! loop over the number of elements of the array
    do i=1,kk
! compute the dimensional temperature.
      call pushreal8(pp)
      pp = p(i)
      if (correctfork) then
        pp = pp - twothird*rho(i)*k(i)
        call pushcontrol1b(0)
      else
        call pushcontrol1b(1)
      end if
      t = tref*pp/(rgas*rho(i))
! determine the case we are having here.
      if (t .le. cptrange(0)) then
        call pushcontrol2b(0)
      else if (t .ge. cptrange(cpnparts)) then
        call pushcontrol2b(1)
      else
! temperature is in the curve fit range.
! first find the valid range.
        ii = cpnparts
        start = 1
        ad_count = 1
! next guess for the interval.
 100    call pushinteger4(nn)
        nn = start + ii/2
! determine the situation we are having here.
        if (t .gt. cptrange(nn)) then
          call pushcontrol1b(0)
! temperature is larger than the upper boundary of
! the current interval. update the lower boundary.
          start = nn + 1
          ii = ii - 1
        else if (t .ge. cptrange(nn-1)) then
          goto 110
        else
          call pushcontrol1b(1)
        end if
! this is the correct range. exit the do-loop.
! modify ii for the next branch to search.
        ii = ii/2
        ad_count = ad_count + 1
        goto 100
 110    call pushinteger4(ad_count)
! nn contains the correct curve fit interval.
! integrate cv to compute eint.
        call pushreal8(eint(i))
        eint(i) = cptempfit(nn)%eint0 - t
        do ii=1,cptempfit(nn)%nterm
          if (cptempfit(nn)%exponents(ii) .eq. -1) then
            eint(i) = eint(i) + cptempfit(nn)%constants(ii)*log(t)
            call pushcontrol1b(1)
          else
            call pushinteger4(mm)
            mm = cptempfit(nn)%exponents(ii) + 1
            t2 = t**mm
            eint(i) = eint(i) + cptempfit(nn)%constants(ii)*t2/mm
            call pushcontrol1b(0)
          end if
        end do
        call pushinteger4(ii - 1)
        call pushcontrol2b(2)
      end if
! add the turbulent energy if needed.
      if (correctfork) then
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
    end do
    kd = 0.0_8
    scaled = 0.0_8
    do i=kk,1,-1
      call popcontrol1b(branch)
      if (branch .ne. 0) kd(i) = kd(i) + eintd(i)
      call popcontrol2b(branch)
      if (branch .eq. 0) then
        t = tref*pp/(rgas*rho(i))
        scaled = scaled + (cpeint(0)+cv0*(t-cptrange(0)))*eintd(i)
        td = scale*cv0*eintd(i)
        eintd(i) = 0.0_8
      else if (branch .eq. 1) then
        t = tref*pp/(rgas*rho(i))
        scaled = scaled + (cpeint(cpnparts)+cvn*(t-cptrange(cpnparts)))*&
&         eintd(i)
        td = scale*cvn*eintd(i)
        eintd(i) = 0.0_8
      else
        scaled = scaled + eint(i)*eintd(i)
        eintd(i) = scale*eintd(i)
        t = tref*pp/(rgas*rho(i))
        td = 0.0_8
        call popinteger4(ad_to)
        do ii=ad_to,1,-1
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            t2d = cptempfit(nn)%constants(ii)*eintd(i)/mm
            if (.not.(t .le. 0.0_8 .and. (mm .eq. 0.0_8 .or. mm .ne. int&
&               (mm)))) td = td + mm*t**(mm-1)*t2d
            call popinteger4(mm)
          else
            td = td + cptempfit(nn)%constants(ii)*eintd(i)/t
          end if
        end do
        call popreal8(eint(i))
        td = td - eintd(i)
        eintd(i) = 0.0_8
        call popinteger4(ad_count)
        do i0=1,ad_count
          if (i0 .ne. 1) call popcontrol1b(branch)
          call popinteger4(nn)
        end do
      end if
      tempd0 = td/(rgas*rho(i))
      tempd1 = -(tref*pp*tempd0/(rgas*rho(i)))
      trefd = trefd + pp*tempd0
      ppd = tref*tempd0
      rgasd = rgasd + rho(i)*tempd1
      rhod(i) = rhod(i) + rgas*tempd1
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        rhod(i) = rhod(i) - twothird*k(i)*ppd
        kd(i) = kd(i) - twothird*rho(i)*ppd
      end if
      call popreal8(pp)
      pd(i) = pd(i) + ppd
    end do
    rgasd = rgasd + scaled/tref
    trefd = trefd - rgas*scaled/tref**2
  case default
    kd = 0.0_8
  end select
end subroutine eintarray_b

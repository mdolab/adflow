   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of eintarray in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: tref rgas p eint rho
   !   with respect to varying inputs: tref rgas k p eint rho
   !      ==================================================================
   SUBROUTINE EINTARRAY_B(rho, rhod, p, pd, k, kd, eint, eintd, correctfork&
   & , kk)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * EintArray computes the internal energy per unit mass from the  *
   !      * given density and pressure (and possibly turbulent energy) for *
   !      * the given kk elements of the arrays.                           *
   !      * For a calorically and thermally perfect gas the well-known     *
   !      * expression is used; for only a thermally perfect gas, cp is a  *
   !      * function of temperature, curve fits are used and a more        *
   !      * complex expression is obtained.                                *
   !      *                                                                *
   !      ******************************************************************
   !
   USE CONSTANTS
   USE CPCURVEFITS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: kk
   !
   !      Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(kk), INTENT(IN) :: rho, p, k
   REAL(kind=realtype), DIMENSION(kk) :: rhod, pd, kd
   REAL(kind=realtype), DIMENSION(kk) :: eint
   REAL(kind=realtype), DIMENSION(kk) :: eintd
   LOGICAL, INTENT(IN) :: correctfork
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: twothird=two*third
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, nn, mm, ii, start
   REAL(kind=realtype) :: ovgm1, factk, pp, t, t2, scale
   REAL(kind=realtype) :: ppd, td, t2d, scaled
   INTRINSIC LOG
   INTEGER :: ad_count
   INTEGER :: i0
   INTEGER :: branch
   INTEGER :: ad_to
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the cp model used in the computation.
   SELECT CASE  (cpmodel) 
   CASE (cpconstant) 
   ! Abbreviate 1/(gamma -1) a bit easier.
   ovgm1 = one/(gammaconstant-one)
   ! Second step. Correct the energy in case a turbulent kinetic
   ! energy is present.
   IF (correctfork) THEN
   factk = ovgm1*(five*third-gammaconstant)
   kd = 0.0_8
   DO i=kk,1,-1
   kd(i) = kd(i) - factk*eintd(i)
   END DO
   ELSE
   kd = 0.0_8
   END IF
   DO i=kk,1,-1
   tempd = ovgm1*eintd(i)/rho(i)
   pd(i) = pd(i) + tempd
   rhod(i) = rhod(i) - p(i)*tempd/rho(i)
   eintd(i) = 0.0_8
   END DO
   CASE (cptempcurvefits) 
   !        ================================================================
   ! Cp as function of the temperature is given via curve fits.
   ! Store a scale factor to compute the nonDimensional
   ! internal energy.
   scale = rgas/tref
   ! Loop over the number of elements of the array
   DO i=1,kk
   ! Compute the dimensional temperature.
   CALL PUSHREAL8(pp)
   pp = p(i)
   IF (correctfork) THEN
   pp = pp - twothird*rho(i)*k(i)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   t = tref*pp/(rgas*rho(i))
   ! Determine the case we are having here.
   IF (t .LE. cptrange(0)) THEN
   CALL PUSHCONTROL2B(0)
   ELSE IF (t .GE. cptrange(cpnparts)) THEN
   CALL PUSHCONTROL2B(1)
   ELSE
   ! Temperature is in the curve fit range.
   ! First find the valid range.
   ii = cpnparts
   start = 1
   ad_count = 1
   ! Next guess for the interval.
   100    CALL PUSHINTEGER4(nn)
   nn = start + ii/2
   ! Determine the situation we are having here.
   IF (t .GT. cptrange(nn)) THEN
   CALL PUSHCONTROL1B(0)
   ! Temperature is larger than the upper boundary of
   ! the current interval. Update the lower boundary.
   start = nn + 1
   ii = ii - 1
   ELSE IF (t .GE. cptrange(nn-1)) THEN
   GOTO 110
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! This is the correct range. Exit the do-loop.
   ! Modify ii for the next branch to search.
   ii = ii/2
   ad_count = ad_count + 1
   GOTO 100
   110    CALL PUSHINTEGER4(ad_count)
   ! Nn contains the correct curve fit interval.
   ! Integrate cv to compute eint.
   CALL PUSHREAL8(eint(i))
   eint(i) = cptempfit(nn)%eint0 - t
   DO ii=1,cptempfit(nn)%nterm
   IF (cptempfit(nn)%exponents(ii) .EQ. -1) THEN
   eint(i) = eint(i) + cptempfit(nn)%constants(ii)*LOG(t)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHINTEGER4(mm)
   mm = cptempfit(nn)%exponents(ii) + 1
   t2 = t**mm
   eint(i) = eint(i) + cptempfit(nn)%constants(ii)*t2/mm
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(ii - 1)
   CALL PUSHCONTROL2B(2)
   END IF
   ! Add the turbulent energy if needed.
   IF (correctfork) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   kd = 0.0_8
   scaled = 0.0_8
   DO i=kk,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) kd(i) = kd(i) + eintd(i)
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   t = tref*pp/(rgas*rho(i))
   scaled = scaled + (cpeint(0)+cv0*(t-cptrange(0)))*eintd(i)
   td = scale*cv0*eintd(i)
   eintd(i) = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   t = tref*pp/(rgas*rho(i))
   scaled = scaled + (cpeint(cpnparts)+cvn*(t-cptrange(cpnparts)))*&
   &         eintd(i)
   td = scale*cvn*eintd(i)
   eintd(i) = 0.0_8
   ELSE
   scaled = scaled + eint(i)*eintd(i)
   eintd(i) = scale*eintd(i)
   t = tref*pp/(rgas*rho(i))
   td = 0.0_8
   CALL POPINTEGER4(ad_to)
   DO ii=ad_to,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   t2d = cptempfit(nn)%constants(ii)*eintd(i)/mm
   IF (.NOT.(t .LE. 0.0_8 .AND. (mm .EQ. 0.0_8 .OR. mm .NE. INT&
   &               (mm)))) td = td + mm*t**(mm-1)*t2d
   CALL POPINTEGER4(mm)
   ELSE
   td = td + cptempfit(nn)%constants(ii)*eintd(i)/t
   END IF
   END DO
   CALL POPREAL8(eint(i))
   td = td - eintd(i)
   eintd(i) = 0.0_8
   CALL POPINTEGER4(ad_count)
   DO i0=1,ad_count
   IF (i0 .NE. 1) CALL POPCONTROL1B(branch)
   CALL POPINTEGER4(nn)
   END DO
   END IF
   tempd0 = td/(rgas*rho(i))
   tempd1 = -(tref*pp*tempd0/(rgas*rho(i)))
   trefd = trefd + pp*tempd0
   ppd = tref*tempd0
   rgasd = rgasd + rho(i)*tempd1
   rhod(i) = rhod(i) + rgas*tempd1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rhod(i) = rhod(i) - twothird*k(i)*ppd
   kd(i) = kd(i) - twothird*rho(i)*ppd
   END IF
   CALL POPREAL8(pp)
   pd(i) = pd(i) + ppd
   END DO
   rgasd = rgasd + scaled/tref
   trefd = trefd - rgas*scaled/tref**2
   CASE DEFAULT
   kd = 0.0_8
   END SELECT
   END SUBROUTINE EINTARRAY_B

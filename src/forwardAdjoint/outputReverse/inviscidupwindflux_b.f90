   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of inviscidupwindflux in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *p *gamma *w *si *sj *sk *fw
   !   with respect to varying inputs: *p *gamma *w *si *sj *sk tref
   !                rgas
   !   Plus diff mem management of: p:in gamma:in w:in si:in sj:in
   !                sk:in fw:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidUpwindFlux.f90                          *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-25-2003                                      *
   !      * Last modified: 10-29-2007                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDUPWINDFLUX_B(finegrid)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidUpwindFlux computes the artificial dissipation part of *
   !      * the Euler fluxes by means of an approximate solution of the 1D *
   !      * Riemann problem on the face. For first order schemes,          *
   !      * fineGrid == .false., the states in the cells are assumed to    *
   !      * be constant; for the second order schemes on the fine grid a   *
   !      * nonlinear reconstruction of the left and right state is done   *
   !      * for which several options exist.                               *
   !      * It is assumed that the pointers in blockPointers already       *
   !      * point to the correct block.                                    *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE CGNSGRID
   USE CONSTANTS
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: finegrid
   !
   !      Local variables.
   !
   INTEGER(kind=portype) :: por
   INTEGER(kind=inttype) :: nwint
   INTEGER(kind=inttype) :: i, j, k, ind
   INTEGER(kind=inttype) :: limused, riemannused
   REAL(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
   REAL(kind=realtype) :: sxb, syb, szb, gammafaceb
   REAL(kind=realtype) :: factminmod, sface
   REAL(kind=realtype), DIMENSION(nw) :: left, right
   REAL(kind=realtype), DIMENSION(nw) :: leftb, rightb
   REAL(kind=realtype), DIMENSION(nw) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(nw) :: du1b, du2b, du3b
   REAL(kind=realtype), DIMENSION(nwf) :: flux
   REAL(kind=realtype), DIMENSION(nwf) :: fluxb
   LOGICAL :: firstorderk, correctfork, rotationalperiodic
   INTRINSIC ABS
   INTRINSIC ASSOCIATED
   INTRINSIC MAX
   INTEGER :: branch
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: max1
   IF (rfil .GE. 0.) THEN
   abs0 = rfil
   ELSE
   abs0 = -rfil
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check if rFil == 0. If so, the dissipative flux needs not to
   ! be computed.
   IF (abs0 .LT. thresholdreal) THEN
   trefb = 0.0_8
   rgasb = 0.0_8
   ELSE
   ! Check if the formulation for rotational periodic problems
   ! must be used.
   IF (ASSOCIATED(rotmatrixi)) THEN
   rotationalperiodic = .true.
   ELSE
   rotationalperiodic = .false.
   END IF
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .EQ. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   IF (1.e-10_realType .LT. one - kappacoef) THEN
   max1 = one - kappacoef
   ELSE
   max1 = 1.e-10_realType
   END IF
   ! Compute the factor used in the minmod limiter.
   factminmod = (three-kappacoef)/max1
   ! Determine the limiter scheme to be used. On the fine grid the
   ! user specified scheme is used; on the coarse grid a first order
   ! scheme is computed.
   limused = firstorder
   IF (finegrid) limused = limiter
   ! Lumped diss is true for doing approx PC
   IF (lumpeddiss) limused = firstorder
   ! Determine the riemann solver which must be used.
   riemannused = riemanncoarse
   IF (finegrid) riemannused = riemann
   ! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
   omk = fourth*(one-kappacoef)
   opk = fourth*(one+kappacoef)
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set the number of variables to be interpolated depending
   ! whether or not a k-equation is present. If a k-equation is
   ! present also set the logical firstOrderK. This indicates
   ! whether or not only a first order approximation is to be used
   ! for the turbulent kinetic energy.
   IF (correctfork) THEN
   IF (orderturb .EQ. firstorder) THEN
   nwint = nwf
   firstorderk = .true.
   ELSE
   nwint = itu1
   firstorderk = .false.
   END IF
   ELSE
   nwint = nwf
   firstorderk = .false.
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Flux computation. A distinction is made between first and      *
   !      * second order schemes to avoid the overhead for the first order *
   !      * scheme.                                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   IF (limused .EQ. firstorder) THEN
   !
   !        ****************************************************************
   !        *                                                              *
   !        * First order reconstruction. The states in the cells are      *
   !        * constant. The left and right states are constructed easily.  *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   DO k=2,kl
   DO j=2,jl
   DO i=1,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = si(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = si(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = si(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacei(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the left and right state.
   CALL PUSHREAL8(left(irho))
   left(irho) = w(i, j, k, irho)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = w(i, j, k, ivx)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = w(i, j, k, ivy)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = w(i, j, k, ivz)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = w(i, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = w(i+1, j, k, irho)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = w(i+1, j, k, ivx)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = w(i+1, j, k, ivy)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = w(i+1, j, k, ivz)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = p(i+1, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = w(i+1, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in j-direction.
   DO k=2,kl
   DO j=1,jl
   DO i=2,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sj(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sj(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sj(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacej(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the left and right state.
   CALL PUSHREAL8(left(irho))
   left(irho) = w(i, j, k, irho)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = w(i, j, k, ivx)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = w(i, j, k, ivy)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = w(i, j, k, ivz)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = w(i, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = w(i, j+1, k, irho)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = w(i, j+1, k, ivx)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = w(i, j+1, k, ivy)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = w(i, j+1, k, ivz)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = p(i, j+1, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = w(i, j+1, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in k-direction.
   DO k=1,kl
   DO j=2,jl
   DO i=2,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sk(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sk(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sk(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacek(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the left and right state.
   CALL PUSHREAL8(left(irho))
   left(irho) = w(i, j, k, irho)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = w(i, j, k, ivx)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = w(i, j, k, ivy)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = w(i, j, k, ivz)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = w(i, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = w(i, j, k+1, irho)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = w(i, j, k+1, ivx)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = w(i, j, k+1, ivy)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = w(i, j, k+1, ivz)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = p(i, j, k+1)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = w(i, j, k+1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   trefb = 0.0_8
   rgasb = 0.0_8
   fluxb = 0.0_8
   leftb = 0.0_8
   rightb = 0.0_8
   DO k=kl,1,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   fluxb(irhoe) = fluxb(irhoe) - fwb(i, j, k+1, irhoe)
   fluxb(imz) = fluxb(imz) - fwb(i, j, k+1, imz)
   fluxb(imy) = fluxb(imy) - fwb(i, j, k+1, imy)
   fluxb(imx) = fluxb(imx) - fwb(i, j, k+1, imx)
   fluxb(irho) = fluxb(irho) - fwb(i, j, k+1, irho)
   fluxb(irhoe) = fluxb(irhoe) + fwb(i, j, k, irhoe)
   fluxb(imz) = fluxb(imz) + fwb(i, j, k, imz)
   fluxb(imy) = fluxb(imy) + fwb(i, j, k, imy)
   fluxb(imx) = fluxb(imx) + fwb(i, j, k, imx)
   fluxb(irho) = fluxb(irho) + fwb(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
   por = pork(i, j, k)
   CALL RIEMANNFLUX_B(left, leftb, right, rightb, flux, fluxb)
   gammab(i, j, k) = gammab(i, j, k) + half*gammafaceb
   gammab(i, j, k+1) = gammab(i, j, k+1) + half*gammafaceb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(right(itu1))
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + rightb(itu1)
   rightb(itu1) = 0.0_8
   END IF
   CALL POPREAL8(right(irhoe))
   pb(i, j, k+1) = pb(i, j, k+1) + rightb(irhoe)
   rightb(irhoe) = 0.0_8
   CALL POPREAL8(right(ivz))
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + rightb(ivz)
   rightb(ivz) = 0.0_8
   CALL POPREAL8(right(ivy))
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + rightb(ivy)
   rightb(ivy) = 0.0_8
   CALL POPREAL8(right(ivx))
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + rightb(ivx)
   rightb(ivx) = 0.0_8
   CALL POPREAL8(right(irho))
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + rightb(irho)
   rightb(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(left(itu1))
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + leftb(itu1)
   leftb(itu1) = 0.0_8
   END IF
   CALL POPREAL8(left(irhoe))
   pb(i, j, k) = pb(i, j, k) + leftb(irhoe)
   leftb(irhoe) = 0.0_8
   CALL POPREAL8(left(ivz))
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + leftb(ivz)
   leftb(ivz) = 0.0_8
   CALL POPREAL8(left(ivy))
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + leftb(ivy)
   leftb(ivy) = 0.0_8
   CALL POPREAL8(left(ivx))
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + leftb(ivx)
   leftb(ivx) = 0.0_8
   CALL POPREAL8(left(irho))
   wb(i, j, k, irho) = wb(i, j, k, irho) + leftb(irho)
   leftb(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   skb(i, j, k, 3) = skb(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   skb(i, j, k, 2) = skb(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   skb(i, j, k, 1) = skb(i, j, k, 1) + sxb
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,1,-1
   DO i=il,2,-1
   fluxb(irhoe) = fluxb(irhoe) - fwb(i, j+1, k, irhoe)
   fluxb(imz) = fluxb(imz) - fwb(i, j+1, k, imz)
   fluxb(imy) = fluxb(imy) - fwb(i, j+1, k, imy)
   fluxb(imx) = fluxb(imx) - fwb(i, j+1, k, imx)
   fluxb(irho) = fluxb(irho) - fwb(i, j+1, k, irho)
   fluxb(irhoe) = fluxb(irhoe) + fwb(i, j, k, irhoe)
   fluxb(imz) = fluxb(imz) + fwb(i, j, k, imz)
   fluxb(imy) = fluxb(imy) + fwb(i, j, k, imy)
   fluxb(imx) = fluxb(imx) + fwb(i, j, k, imx)
   fluxb(irho) = fluxb(irho) + fwb(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
   por = porj(i, j, k)
   CALL RIEMANNFLUX_B(left, leftb, right, rightb, flux, fluxb)
   gammab(i, j, k) = gammab(i, j, k) + half*gammafaceb
   gammab(i, j+1, k) = gammab(i, j+1, k) + half*gammafaceb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(right(itu1))
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + rightb(itu1)
   rightb(itu1) = 0.0_8
   END IF
   CALL POPREAL8(right(irhoe))
   pb(i, j+1, k) = pb(i, j+1, k) + rightb(irhoe)
   rightb(irhoe) = 0.0_8
   CALL POPREAL8(right(ivz))
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + rightb(ivz)
   rightb(ivz) = 0.0_8
   CALL POPREAL8(right(ivy))
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + rightb(ivy)
   rightb(ivy) = 0.0_8
   CALL POPREAL8(right(ivx))
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + rightb(ivx)
   rightb(ivx) = 0.0_8
   CALL POPREAL8(right(irho))
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + rightb(irho)
   rightb(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(left(itu1))
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + leftb(itu1)
   leftb(itu1) = 0.0_8
   END IF
   CALL POPREAL8(left(irhoe))
   pb(i, j, k) = pb(i, j, k) + leftb(irhoe)
   leftb(irhoe) = 0.0_8
   CALL POPREAL8(left(ivz))
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + leftb(ivz)
   leftb(ivz) = 0.0_8
   CALL POPREAL8(left(ivy))
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + leftb(ivy)
   leftb(ivy) = 0.0_8
   CALL POPREAL8(left(ivx))
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + leftb(ivx)
   leftb(ivx) = 0.0_8
   CALL POPREAL8(left(irho))
   wb(i, j, k, irho) = wb(i, j, k, irho) + leftb(irho)
   leftb(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + sxb
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,1,-1
   fluxb(irhoe) = fluxb(irhoe) - fwb(i+1, j, k, irhoe)
   fluxb(imz) = fluxb(imz) - fwb(i+1, j, k, imz)
   fluxb(imy) = fluxb(imy) - fwb(i+1, j, k, imy)
   fluxb(imx) = fluxb(imx) - fwb(i+1, j, k, imx)
   fluxb(irho) = fluxb(irho) - fwb(i+1, j, k, irho)
   fluxb(irhoe) = fluxb(irhoe) + fwb(i, j, k, irhoe)
   fluxb(imz) = fluxb(imz) + fwb(i, j, k, imz)
   fluxb(imy) = fluxb(imy) + fwb(i, j, k, imy)
   fluxb(imx) = fluxb(imx) + fwb(i, j, k, imx)
   fluxb(irho) = fluxb(irho) + fwb(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
   por = pori(i, j, k)
   CALL RIEMANNFLUX_B(left, leftb, right, rightb, flux, fluxb)
   gammab(i, j, k) = gammab(i, j, k) + half*gammafaceb
   gammab(i+1, j, k) = gammab(i+1, j, k) + half*gammafaceb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(right(itu1))
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + rightb(itu1)
   rightb(itu1) = 0.0_8
   END IF
   CALL POPREAL8(right(irhoe))
   pb(i+1, j, k) = pb(i+1, j, k) + rightb(irhoe)
   rightb(irhoe) = 0.0_8
   CALL POPREAL8(right(ivz))
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + rightb(ivz)
   rightb(ivz) = 0.0_8
   CALL POPREAL8(right(ivy))
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + rightb(ivy)
   rightb(ivy) = 0.0_8
   CALL POPREAL8(right(ivx))
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + rightb(ivx)
   rightb(ivx) = 0.0_8
   CALL POPREAL8(right(irho))
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + rightb(irho)
   rightb(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(left(itu1))
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + leftb(itu1)
   leftb(itu1) = 0.0_8
   END IF
   CALL POPREAL8(left(irhoe))
   pb(i, j, k) = pb(i, j, k) + leftb(irhoe)
   leftb(irhoe) = 0.0_8
   CALL POPREAL8(left(ivz))
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + leftb(ivz)
   leftb(ivz) = 0.0_8
   CALL POPREAL8(left(ivy))
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + leftb(ivy)
   leftb(ivy) = 0.0_8
   CALL POPREAL8(left(ivx))
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + leftb(ivx)
   leftb(ivx) = 0.0_8
   CALL POPREAL8(left(irho))
   wb(i, j, k, irho) = wb(i, j, k, irho) + leftb(irho)
   leftb(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sib(i, j, k, 3) = sib(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   sib(i, j, k, 2) = sib(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   sib(i, j, k, 1) = sib(i, j, k, 1) + sxb
   END DO
   END DO
   END DO
   ELSE
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   !      ==================================================================
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Second order reconstruction of the left and right state.     *
   !        * The three differences used in the, possibly nonlinear,       *
   !        * interpolation are constructed here; the actual left and      *
   !        * right states, or at least the differences from the first     *
   !        * order interpolation, are computed in the subroutine          *
   !        * leftRightState.                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   DO k=2,kl
   DO j=2,jl
   DO i=1,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
   du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
   du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
   du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
   du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
   du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
   du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
   du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
   du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
   du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
   du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
   du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
   du1(irhoe) = p(i, j, k) - p(i-1, j, k)
   du2(irhoe) = p(i+1, j, k) - p(i, j, k)
   du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
   IF (correctfork) THEN
   du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
   du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
   du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   CALL PUSHREAL8ARRAY(du3, nw)
   CALL PUSHREAL8ARRAY(du2, nw)
   CALL PUSHREAL8ARRAY(du1, nw)
   CALL LEFTRIGHTSTATE(du1, du2, du3, rotmatrixi, left, right)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + w(i, j, k, irho)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   left(irhoe) = left(irhoe) + p(i, j, k)
   right(irho) = right(irho) + w(i+1, j, k, irho)
   right(ivx) = right(ivx) + w(i+1, j, k, ivx)
   right(ivy) = right(ivy) + w(i+1, j, k, ivy)
   right(ivz) = right(ivz) + w(i+1, j, k, ivz)
   right(irhoe) = right(irhoe) + p(i+1, j, k)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   right(itu1) = right(itu1) + w(i+1, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = si(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = si(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = si(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacei(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in the j-direction.
   DO k=2,kl
   DO j=1,jl
   DO i=2,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
   du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
   du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
   du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
   du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
   du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
   du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
   du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
   du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
   du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
   du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
   du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
   du1(irhoe) = p(i, j, k) - p(i, j-1, k)
   du2(irhoe) = p(i, j+1, k) - p(i, j, k)
   du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
   IF (correctfork) THEN
   du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
   du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
   du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   CALL PUSHREAL8ARRAY(du3, nw)
   CALL PUSHREAL8ARRAY(du2, nw)
   CALL PUSHREAL8ARRAY(du1, nw)
   CALL LEFTRIGHTSTATE(du1, du2, du3, rotmatrixj, left, right)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + w(i, j, k, irho)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   left(irhoe) = left(irhoe) + p(i, j, k)
   right(irho) = right(irho) + w(i, j+1, k, irho)
   right(ivx) = right(ivx) + w(i, j+1, k, ivx)
   right(ivy) = right(ivy) + w(i, j+1, k, ivy)
   right(ivz) = right(ivz) + w(i, j+1, k, ivz)
   right(irhoe) = right(irhoe) + p(i, j+1, k)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   right(itu1) = right(itu1) + w(i, j+1, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sj(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sj(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sj(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacej(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in the k-direction.
   DO k=1,kl
   DO j=2,jl
   DO i=2,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
   du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
   du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
   du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
   du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
   du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
   du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
   du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
   du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
   du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
   du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
   du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
   du1(irhoe) = p(i, j, k) - p(i, j, k-1)
   du2(irhoe) = p(i, j, k+1) - p(i, j, k)
   du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
   IF (correctfork) THEN
   du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
   du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
   du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   CALL PUSHREAL8ARRAY(du3, nw)
   CALL PUSHREAL8ARRAY(du2, nw)
   CALL PUSHREAL8ARRAY(du1, nw)
   CALL LEFTRIGHTSTATE(du1, du2, du3, rotmatrixk, left, right)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + w(i, j, k, irho)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   left(irhoe) = left(irhoe) + p(i, j, k)
   right(irho) = right(irho) + w(i, j, k+1, irho)
   right(ivx) = right(ivx) + w(i, j, k+1, ivx)
   right(ivy) = right(ivy) + w(i, j, k+1, ivy)
   right(ivz) = right(ivz) + w(i, j, k+1, ivz)
   right(irhoe) = right(irhoe) + p(i, j, k+1)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   right(itu1) = right(itu1) + w(i, j, k+1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sk(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sk(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sk(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacek(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   trefb = 0.0_8
   rgasb = 0.0_8
   fluxb = 0.0_8
   leftb = 0.0_8
   rightb = 0.0_8
   du1b = 0.0_8
   du2b = 0.0_8
   du3b = 0.0_8
   DO k=kl,1,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   fluxb(irhoe) = fluxb(irhoe) - fwb(i, j, k+1, irhoe)
   fluxb(imz) = fluxb(imz) - fwb(i, j, k+1, imz)
   fluxb(imy) = fluxb(imy) - fwb(i, j, k+1, imy)
   fluxb(imx) = fluxb(imx) - fwb(i, j, k+1, imx)
   fluxb(irho) = fluxb(irho) - fwb(i, j, k+1, irho)
   fluxb(irhoe) = fluxb(irhoe) + fwb(i, j, k, irhoe)
   fluxb(imz) = fluxb(imz) + fwb(i, j, k, imz)
   fluxb(imy) = fluxb(imy) + fwb(i, j, k, imy)
   fluxb(imx) = fluxb(imx) + fwb(i, j, k, imx)
   fluxb(irho) = fluxb(irho) + fwb(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
   por = pork(i, j, k)
   CALL RIEMANNFLUX_B(left, leftb, right, rightb, flux, fluxb)
   gammab(i, j, k) = gammab(i, j, k) + half*gammafaceb
   gammab(i, j, k+1) = gammab(i, j, k+1) + half*gammafaceb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   skb(i, j, k, 3) = skb(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   skb(i, j, k, 2) = skb(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   skb(i, j, k, 1) = skb(i, j, k, 1) + sxb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + rightb(itu1)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + leftb(itu1)
   END IF
   pb(i, j, k+1) = pb(i, j, k+1) + rightb(irhoe)
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + rightb(ivz)
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + rightb(ivy)
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + rightb(ivx)
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + rightb(irho)
   pb(i, j, k) = pb(i, j, k) + leftb(irhoe)
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + leftb(ivz)
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + leftb(ivy)
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + leftb(ivx)
   wb(i, j, k, irho) = wb(i, j, k, irho) + leftb(irho)
   CALL POPREAL8ARRAY(du1, nw)
   CALL POPREAL8ARRAY(du2, nw)
   CALL POPREAL8ARRAY(du3, nw)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATE_B(du1, du1b, du2, du2b, du3, du3b, &
   &                           rotmatrixk, left, leftb, right, rightb)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wb(i, j, k+2, itu1) = wb(i, j, k+2, itu1) + du3b(itu1)
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) - du3b(itu1)
   du3b(itu1) = 0.0_8
   wb(i, j, k+1, itu1) = wb(i, j, k+1, itu1) + du2b(itu1)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - du2b(itu1)
   du2b(itu1) = 0.0_8
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + du1b(itu1)
   wb(i, j, k-1, itu1) = wb(i, j, k-1, itu1) - du1b(itu1)
   du1b(itu1) = 0.0_8
   END IF
   pb(i, j, k+2) = pb(i, j, k+2) + du3b(irhoe)
   pb(i, j, k+1) = pb(i, j, k+1) - du3b(irhoe)
   du3b(irhoe) = 0.0_8
   pb(i, j, k+1) = pb(i, j, k+1) + du2b(irhoe)
   pb(i, j, k) = pb(i, j, k) - du2b(irhoe)
   du2b(irhoe) = 0.0_8
   pb(i, j, k) = pb(i, j, k) + du1b(irhoe)
   pb(i, j, k-1) = pb(i, j, k-1) - du1b(irhoe)
   du1b(irhoe) = 0.0_8
   wb(i, j, k+2, ivz) = wb(i, j, k+2, ivz) + du3b(ivz)
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) - du3b(ivz)
   du3b(ivz) = 0.0_8
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + du2b(ivz)
   wb(i, j, k, ivz) = wb(i, j, k, ivz) - du2b(ivz)
   du2b(ivz) = 0.0_8
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + du1b(ivz)
   wb(i, j, k-1, ivz) = wb(i, j, k-1, ivz) - du1b(ivz)
   du1b(ivz) = 0.0_8
   wb(i, j, k+2, ivy) = wb(i, j, k+2, ivy) + du3b(ivy)
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) - du3b(ivy)
   du3b(ivy) = 0.0_8
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + du2b(ivy)
   wb(i, j, k, ivy) = wb(i, j, k, ivy) - du2b(ivy)
   du2b(ivy) = 0.0_8
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + du1b(ivy)
   wb(i, j, k-1, ivy) = wb(i, j, k-1, ivy) - du1b(ivy)
   du1b(ivy) = 0.0_8
   wb(i, j, k+2, ivx) = wb(i, j, k+2, ivx) + du3b(ivx)
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) - du3b(ivx)
   du3b(ivx) = 0.0_8
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + du2b(ivx)
   wb(i, j, k, ivx) = wb(i, j, k, ivx) - du2b(ivx)
   du2b(ivx) = 0.0_8
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + du1b(ivx)
   wb(i, j, k-1, ivx) = wb(i, j, k-1, ivx) - du1b(ivx)
   du1b(ivx) = 0.0_8
   wb(i, j, k+2, irho) = wb(i, j, k+2, irho) + du3b(irho)
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) - du3b(irho)
   du3b(irho) = 0.0_8
   wb(i, j, k+1, irho) = wb(i, j, k+1, irho) + du2b(irho)
   wb(i, j, k, irho) = wb(i, j, k, irho) - du2b(irho)
   du2b(irho) = 0.0_8
   wb(i, j, k, irho) = wb(i, j, k, irho) + du1b(irho)
   wb(i, j, k-1, irho) = wb(i, j, k-1, irho) - du1b(irho)
   du1b(irho) = 0.0_8
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,1,-1
   DO i=il,2,-1
   fluxb(irhoe) = fluxb(irhoe) - fwb(i, j+1, k, irhoe)
   fluxb(imz) = fluxb(imz) - fwb(i, j+1, k, imz)
   fluxb(imy) = fluxb(imy) - fwb(i, j+1, k, imy)
   fluxb(imx) = fluxb(imx) - fwb(i, j+1, k, imx)
   fluxb(irho) = fluxb(irho) - fwb(i, j+1, k, irho)
   fluxb(irhoe) = fluxb(irhoe) + fwb(i, j, k, irhoe)
   fluxb(imz) = fluxb(imz) + fwb(i, j, k, imz)
   fluxb(imy) = fluxb(imy) + fwb(i, j, k, imy)
   fluxb(imx) = fluxb(imx) + fwb(i, j, k, imx)
   fluxb(irho) = fluxb(irho) + fwb(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
   por = porj(i, j, k)
   CALL RIEMANNFLUX_B(left, leftb, right, rightb, flux, fluxb)
   gammab(i, j, k) = gammab(i, j, k) + half*gammafaceb
   gammab(i, j+1, k) = gammab(i, j+1, k) + half*gammafaceb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + sxb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + rightb(itu1)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + leftb(itu1)
   END IF
   pb(i, j+1, k) = pb(i, j+1, k) + rightb(irhoe)
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + rightb(ivz)
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + rightb(ivy)
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + rightb(ivx)
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + rightb(irho)
   pb(i, j, k) = pb(i, j, k) + leftb(irhoe)
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + leftb(ivz)
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + leftb(ivy)
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + leftb(ivx)
   wb(i, j, k, irho) = wb(i, j, k, irho) + leftb(irho)
   CALL POPREAL8ARRAY(du1, nw)
   CALL POPREAL8ARRAY(du2, nw)
   CALL POPREAL8ARRAY(du3, nw)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATE_B(du1, du1b, du2, du2b, du3, du3b, &
   &                           rotmatrixj, left, leftb, right, rightb)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wb(i, j+2, k, itu1) = wb(i, j+2, k, itu1) + du3b(itu1)
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) - du3b(itu1)
   du3b(itu1) = 0.0_8
   wb(i, j+1, k, itu1) = wb(i, j+1, k, itu1) + du2b(itu1)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - du2b(itu1)
   du2b(itu1) = 0.0_8
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + du1b(itu1)
   wb(i, j-1, k, itu1) = wb(i, j-1, k, itu1) - du1b(itu1)
   du1b(itu1) = 0.0_8
   END IF
   pb(i, j+2, k) = pb(i, j+2, k) + du3b(irhoe)
   pb(i, j+1, k) = pb(i, j+1, k) - du3b(irhoe)
   du3b(irhoe) = 0.0_8
   pb(i, j+1, k) = pb(i, j+1, k) + du2b(irhoe)
   pb(i, j, k) = pb(i, j, k) - du2b(irhoe)
   du2b(irhoe) = 0.0_8
   pb(i, j, k) = pb(i, j, k) + du1b(irhoe)
   pb(i, j-1, k) = pb(i, j-1, k) - du1b(irhoe)
   du1b(irhoe) = 0.0_8
   wb(i, j+2, k, ivz) = wb(i, j+2, k, ivz) + du3b(ivz)
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) - du3b(ivz)
   du3b(ivz) = 0.0_8
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + du2b(ivz)
   wb(i, j, k, ivz) = wb(i, j, k, ivz) - du2b(ivz)
   du2b(ivz) = 0.0_8
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + du1b(ivz)
   wb(i, j-1, k, ivz) = wb(i, j-1, k, ivz) - du1b(ivz)
   du1b(ivz) = 0.0_8
   wb(i, j+2, k, ivy) = wb(i, j+2, k, ivy) + du3b(ivy)
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) - du3b(ivy)
   du3b(ivy) = 0.0_8
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + du2b(ivy)
   wb(i, j, k, ivy) = wb(i, j, k, ivy) - du2b(ivy)
   du2b(ivy) = 0.0_8
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + du1b(ivy)
   wb(i, j-1, k, ivy) = wb(i, j-1, k, ivy) - du1b(ivy)
   du1b(ivy) = 0.0_8
   wb(i, j+2, k, ivx) = wb(i, j+2, k, ivx) + du3b(ivx)
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) - du3b(ivx)
   du3b(ivx) = 0.0_8
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + du2b(ivx)
   wb(i, j, k, ivx) = wb(i, j, k, ivx) - du2b(ivx)
   du2b(ivx) = 0.0_8
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + du1b(ivx)
   wb(i, j-1, k, ivx) = wb(i, j-1, k, ivx) - du1b(ivx)
   du1b(ivx) = 0.0_8
   wb(i, j+2, k, irho) = wb(i, j+2, k, irho) + du3b(irho)
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) - du3b(irho)
   du3b(irho) = 0.0_8
   wb(i, j+1, k, irho) = wb(i, j+1, k, irho) + du2b(irho)
   wb(i, j, k, irho) = wb(i, j, k, irho) - du2b(irho)
   du2b(irho) = 0.0_8
   wb(i, j, k, irho) = wb(i, j, k, irho) + du1b(irho)
   wb(i, j-1, k, irho) = wb(i, j-1, k, irho) - du1b(irho)
   du1b(irho) = 0.0_8
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,1,-1
   fluxb(irhoe) = fluxb(irhoe) - fwb(i+1, j, k, irhoe)
   fluxb(imz) = fluxb(imz) - fwb(i+1, j, k, imz)
   fluxb(imy) = fluxb(imy) - fwb(i+1, j, k, imy)
   fluxb(imx) = fluxb(imx) - fwb(i+1, j, k, imx)
   fluxb(irho) = fluxb(irho) - fwb(i+1, j, k, irho)
   fluxb(irhoe) = fluxb(irhoe) + fwb(i, j, k, irhoe)
   fluxb(imz) = fluxb(imz) + fwb(i, j, k, imz)
   fluxb(imy) = fluxb(imy) + fwb(i, j, k, imy)
   fluxb(imx) = fluxb(imx) + fwb(i, j, k, imx)
   fluxb(irho) = fluxb(irho) + fwb(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
   por = pori(i, j, k)
   CALL RIEMANNFLUX_B(left, leftb, right, rightb, flux, fluxb)
   gammab(i, j, k) = gammab(i, j, k) + half*gammafaceb
   gammab(i+1, j, k) = gammab(i+1, j, k) + half*gammafaceb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sib(i, j, k, 3) = sib(i, j, k, 3) + szb
   CALL POPREAL8(sy)
   sib(i, j, k, 2) = sib(i, j, k, 2) + syb
   CALL POPREAL8(sx)
   sib(i, j, k, 1) = sib(i, j, k, 1) + sxb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + rightb(itu1)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + leftb(itu1)
   END IF
   pb(i+1, j, k) = pb(i+1, j, k) + rightb(irhoe)
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + rightb(ivz)
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + rightb(ivy)
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + rightb(ivx)
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + rightb(irho)
   pb(i, j, k) = pb(i, j, k) + leftb(irhoe)
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + leftb(ivz)
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + leftb(ivy)
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + leftb(ivx)
   wb(i, j, k, irho) = wb(i, j, k, irho) + leftb(irho)
   CALL POPREAL8ARRAY(du1, nw)
   CALL POPREAL8ARRAY(du2, nw)
   CALL POPREAL8ARRAY(du3, nw)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATE_B(du1, du1b, du2, du2b, du3, du3b, &
   &                           rotmatrixi, left, leftb, right, rightb)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wb(i+2, j, k, itu1) = wb(i+2, j, k, itu1) + du3b(itu1)
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) - du3b(itu1)
   du3b(itu1) = 0.0_8
   wb(i+1, j, k, itu1) = wb(i+1, j, k, itu1) + du2b(itu1)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - du2b(itu1)
   du2b(itu1) = 0.0_8
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + du1b(itu1)
   wb(i-1, j, k, itu1) = wb(i-1, j, k, itu1) - du1b(itu1)
   du1b(itu1) = 0.0_8
   END IF
   pb(i+2, j, k) = pb(i+2, j, k) + du3b(irhoe)
   pb(i+1, j, k) = pb(i+1, j, k) - du3b(irhoe)
   du3b(irhoe) = 0.0_8
   pb(i+1, j, k) = pb(i+1, j, k) + du2b(irhoe)
   pb(i, j, k) = pb(i, j, k) - du2b(irhoe)
   du2b(irhoe) = 0.0_8
   pb(i, j, k) = pb(i, j, k) + du1b(irhoe)
   pb(i-1, j, k) = pb(i-1, j, k) - du1b(irhoe)
   du1b(irhoe) = 0.0_8
   wb(i+2, j, k, ivz) = wb(i+2, j, k, ivz) + du3b(ivz)
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) - du3b(ivz)
   du3b(ivz) = 0.0_8
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + du2b(ivz)
   wb(i, j, k, ivz) = wb(i, j, k, ivz) - du2b(ivz)
   du2b(ivz) = 0.0_8
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + du1b(ivz)
   wb(i-1, j, k, ivz) = wb(i-1, j, k, ivz) - du1b(ivz)
   du1b(ivz) = 0.0_8
   wb(i+2, j, k, ivy) = wb(i+2, j, k, ivy) + du3b(ivy)
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) - du3b(ivy)
   du3b(ivy) = 0.0_8
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + du2b(ivy)
   wb(i, j, k, ivy) = wb(i, j, k, ivy) - du2b(ivy)
   du2b(ivy) = 0.0_8
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + du1b(ivy)
   wb(i-1, j, k, ivy) = wb(i-1, j, k, ivy) - du1b(ivy)
   du1b(ivy) = 0.0_8
   wb(i+2, j, k, ivx) = wb(i+2, j, k, ivx) + du3b(ivx)
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) - du3b(ivx)
   du3b(ivx) = 0.0_8
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + du2b(ivx)
   wb(i, j, k, ivx) = wb(i, j, k, ivx) - du2b(ivx)
   du2b(ivx) = 0.0_8
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + du1b(ivx)
   wb(i-1, j, k, ivx) = wb(i-1, j, k, ivx) - du1b(ivx)
   du1b(ivx) = 0.0_8
   wb(i+2, j, k, irho) = wb(i+2, j, k, irho) + du3b(irho)
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) - du3b(irho)
   du3b(irho) = 0.0_8
   wb(i+1, j, k, irho) = wb(i+1, j, k, irho) + du2b(irho)
   wb(i, j, k, irho) = wb(i, j, k, irho) - du2b(irho)
   du2b(irho) = 0.0_8
   wb(i, j, k, irho) = wb(i, j, k, irho) + du1b(irho)
   wb(i-1, j, k, irho) = wb(i-1, j, k, irho) - du1b(irho)
   du1b(irho) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   END IF
      CONTAINS
   !  Differentiation of leftrightstate in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: left right du1 du2 du3
   !   with respect to varying inputs: left right du1 du2 du3
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATE_B(du1, du1b, du2, du2b, du3, du3b, rotmatrix&
   &   , left, leftb, right, rightb)
   IMPLICIT NONE
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1b
   REAL(kind=realtype), DIMENSION(:) :: left, right
   REAL(kind=realtype), DIMENSION(:) :: leftb, rightb
   REAL(kind=realtype), DIMENSION(:, :, :, :, :), POINTER :: rotmatrix
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
   REAL(kind=realtype) :: rl1b, rl2b, rr1b, rr2b, tmpb, dvxb, dvyb, &
   &   dvzb
   REAL(kind=realtype), DIMENSION(3, 3) :: rot
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC SIGN
   INTRINSIC MIN
   INTEGER :: branch
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du3b
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du2b
   REAL(kind=realtype) :: x3b
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: y1b
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: x6b
   REAL(kind=realtype) :: y4b
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: max2b
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: max5b
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x2b
   REAL(kind=realtype) :: x5b
   REAL(kind=realtype) :: y3b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: max4b
   REAL(kind=realtype) :: max7b
   REAL(kind=realtype) :: x1b
   REAL(kind=realtype) :: x4b
   REAL(kind=realtype) :: y2b
   REAL(kind=realtype) :: max3b
   REAL(kind=realtype) :: max7
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max6b
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: temp4
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Check if the velocity components should be transformed to
   ! the cylindrical frame.
   IF (rotationalperiodic) THEN
   ! Store the rotation matrix a bit easier. Note that the i,j,k
   ! come from the main subroutine.
   rot(1, 1) = rotmatrix(i, j, k, 1, 1)
   rot(1, 2) = rotmatrix(i, j, k, 1, 2)
   rot(1, 3) = rotmatrix(i, j, k, 1, 3)
   rot(2, 1) = rotmatrix(i, j, k, 2, 1)
   rot(2, 2) = rotmatrix(i, j, k, 2, 2)
   rot(2, 3) = rotmatrix(i, j, k, 2, 3)
   rot(3, 1) = rotmatrix(i, j, k, 3, 1)
   rot(3, 2) = rotmatrix(i, j, k, 3, 2)
   rot(3, 3) = rotmatrix(i, j, k, 3, 3)
   ! Apply the transformation to the velocity components
   ! of du1, du2 and du3.
   dvx = du1(ivx)
   dvy = du1(ivy)
   dvz = du1(ivz)
   du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du2(ivx)
   dvy = du2(ivy)
   dvz = du2(ivz)
   du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du3(ivx)
   dvy = du3(ivy)
   dvz = du3(ivz)
   du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the limiter used.
   SELECT CASE  (limused) 
   CASE (nolimiter) 
   CALL PUSHCONTROL2B(1)
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1 = du2(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x1 = -du2(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x1 .LT. epslim) THEN
   CALL PUSHREAL8(max2)
   max2 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max2)
   max2 = x1
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   CALL PUSHREAL8(tmp)
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3 = du1(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x3 = -du1(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x3 .LT. epslim) THEN
   CALL PUSHREAL8(max4)
   max4 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max4)
   max4 = x3
   CALL PUSHCONTROL1B(1)
   END IF
   y1 = du2(l)/SIGN(max4, du1(l))
   IF (zero .LT. y1) THEN
   CALL PUSHREAL8(rl1)
   rl1 = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl1)
   rl1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   CALL PUSHREAL8(rl2)
   rl2 = du1(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl2)
   rl2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   CALL PUSHREAL8(rr1)
   rr1 = du3(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr1)
   rr1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4 = du3(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x4 = -du3(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x4 .LT. epslim) THEN
   CALL PUSHREAL8(max5)
   max5 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max5)
   max5 = x4
   CALL PUSHCONTROL1B(1)
   END IF
   y2 = du2(l)/SIGN(max5, du3(l))
   IF (zero .LT. y2) THEN
   CALL PUSHREAL8(rr2)
   rr2 = y2
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr2)
   rr2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the corresponding limiter values.
   CALL PUSHREAL8(rl1)
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   CALL PUSHREAL8(rl2)
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   CALL PUSHREAL8(rr1)
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   CALL PUSHREAL8(rr2)
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   END DO
   CALL PUSHCONTROL2B(2)
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2 = du2(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x2 = -du2(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x2 .LT. epslim) THEN
   CALL PUSHREAL8(max3)
   max3 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max3)
   max3 = x2
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   CALL PUSHREAL8(tmp)
   tmp = one/SIGN(max3, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5 = du1(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x5 = -du1(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x5 .LT. epslim) THEN
   CALL PUSHREAL8(max6)
   max6 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max6)
   max6 = x5
   CALL PUSHCONTROL1B(1)
   END IF
   y3 = du2(l)/SIGN(max6, du1(l))
   IF (zero .LT. y3) THEN
   CALL PUSHREAL8(rl1)
   rl1 = y3
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl1)
   rl1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   CALL PUSHREAL8(rl2)
   rl2 = du1(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl2)
   rl2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   CALL PUSHREAL8(rr1)
   rr1 = du3(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr1)
   rr1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6 = du3(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x6 = -du3(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x6 .LT. epslim) THEN
   CALL PUSHREAL8(max7)
   max7 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max7)
   max7 = x6
   CALL PUSHCONTROL1B(1)
   END IF
   y4 = du2(l)/SIGN(max7, du3(l))
   IF (zero .LT. y4) THEN
   CALL PUSHREAL8(rr2)
   rr2 = y4
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr2)
   rr2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1 = factminmod*rl1
   CALL PUSHCONTROL1B(0)
   ELSE
   rl1 = one
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2 = factminmod*rl2
   CALL PUSHCONTROL1B(0)
   ELSE
   rl2 = one
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1 = factminmod*rr1
   CALL PUSHCONTROL1B(0)
   ELSE
   rr1 = one
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2 = factminmod*rr2
   CALL PUSHCONTROL1B(0)
   ELSE
   rr2 = one
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   CALL PUSHCONTROL2B(3)
   CASE DEFAULT
   CALL PUSHCONTROL2B(0)
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! For rotational periodic problems transform the velocity
   ! differences back to Cartesian again. Note that now the
   ! transpose of the rotation matrix must be used.
   IF (rotationalperiodic) THEN
   dvxb = rot(1, 3)*rightb(ivz)
   dvyb = rot(2, 3)*rightb(ivz)
   dvzb = rot(3, 3)*rightb(ivz)
   rightb(ivz) = 0.0_8
   dvxb = dvxb + rot(1, 2)*rightb(ivy)
   dvyb = dvyb + rot(2, 2)*rightb(ivy)
   dvzb = dvzb + rot(3, 2)*rightb(ivy)
   rightb(ivy) = 0.0_8
   dvxb = dvxb + rot(1, 1)*rightb(ivx)
   dvyb = dvyb + rot(2, 1)*rightb(ivx)
   dvzb = dvzb + rot(3, 1)*rightb(ivx)
   rightb(ivx) = 0.0_8
   rightb(ivz) = rightb(ivz) + dvzb
   rightb(ivy) = rightb(ivy) + dvyb
   rightb(ivx) = rightb(ivx) + dvxb
   dvxb = rot(1, 3)*leftb(ivz)
   dvyb = rot(2, 3)*leftb(ivz)
   dvzb = rot(3, 3)*leftb(ivz)
   leftb(ivz) = 0.0_8
   dvxb = dvxb + rot(1, 2)*leftb(ivy)
   dvyb = dvyb + rot(2, 2)*leftb(ivy)
   dvzb = dvzb + rot(3, 2)*leftb(ivy)
   leftb(ivy) = 0.0_8
   dvxb = dvxb + rot(1, 1)*leftb(ivx)
   dvyb = dvyb + rot(2, 1)*leftb(ivx)
   dvzb = dvzb + rot(3, 1)*leftb(ivx)
   leftb(ivx) = 0.0_8
   leftb(ivz) = leftb(ivz) + dvzb
   leftb(ivy) = leftb(ivy) + dvyb
   leftb(ivx) = leftb(ivx) + dvxb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rightb(itu1) = 0.0_8
   leftb(itu1) = 0.0_8
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .NE. 0) THEN
   DO l=nwint,1,-1
   du3b(l) = du3b(l) - omk*rightb(l)
   du2b(l) = du2b(l) + opk*leftb(l) - opk*rightb(l)
   rightb(l) = 0.0_8
   du1b(l) = du1b(l) + omk*leftb(l)
   leftb(l) = 0.0_8
   END DO
   END IF
   ELSE IF (branch .EQ. 2) THEN
   DO l=nwint,1,-1
   rr1b = -(opk*du2(l)*rightb(l))
   du2b(l) = du2b(l) + opk*rl2*leftb(l) - opk*rr1*rightb(l)
   rr2b = -(omk*du3(l)*rightb(l))
   du3b(l) = du3b(l) - omk*rr2*rightb(l)
   rightb(l) = 0.0_8
   rl1b = omk*du1(l)*leftb(l)
   du1b(l) = du1b(l) + omk*rl1*leftb(l)
   rl2b = opk*du2(l)*leftb(l)
   leftb(l) = 0.0_8
   CALL POPREAL8(rr2)
   tempb2 = rr2b/(one+rr2**2)
   rr2b = (2*rr2-rr2**2*(one+rr2)*2/(one+rr2**2)+one)*tempb2
   CALL POPREAL8(rr1)
   tempb3 = rr1b/(one+rr1**2)
   rr1b = (2*rr1-rr1**2*(one+rr1)*2/(one+rr1**2)+one)*tempb3
   CALL POPREAL8(rl2)
   tempb4 = rl2b/(one+rl2**2)
   rl2b = (2*rl2-rl2**2*(one+rl2)*2/(one+rl2**2)+one)*tempb4
   CALL POPREAL8(rl1)
   tempb5 = rl1b/(one+rl1**2)
   rl1b = (2*rl1-rl1**2*(one+rl1)*2/(one+rl1**2)+one)*tempb5
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr2)
   y2b = rr2b
   ELSE
   CALL POPREAL8(rr2)
   y2b = 0.0_8
   END IF
   temp1 = SIGN(max5, du3(l))
   tempb1 = -(du2(l)*y2b/temp1**2)
   du2b(l) = du2b(l) + y2b/temp1
   max5b = SIGN(1.d0, max5*du3(l))*tempb1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max5)
   x4b = 0.0_8
   ELSE
   CALL POPREAL8(max5)
   x4b = max5b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du3b(l) = du3b(l) + x4b
   ELSE
   du3b(l) = du3b(l) - x4b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr1)
   du3b(l) = du3b(l) + tmp*rr1b
   tmpb = du3(l)*rr1b
   ELSE
   CALL POPREAL8(rr1)
   tmpb = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl2)
   du1b(l) = du1b(l) + tmp*rl2b
   tmpb = tmpb + du1(l)*rl2b
   ELSE
   CALL POPREAL8(rl2)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl1)
   y1b = rl1b
   ELSE
   CALL POPREAL8(rl1)
   y1b = 0.0_8
   END IF
   temp0 = SIGN(max4, du1(l))
   tempb0 = -(du2(l)*y1b/temp0**2)
   du2b(l) = du2b(l) + y1b/temp0
   max4b = SIGN(1.d0, max4*du1(l))*tempb0
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max4)
   x3b = 0.0_8
   ELSE
   CALL POPREAL8(max4)
   x3b = max4b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du1b(l) = du1b(l) + x3b
   ELSE
   du1b(l) = du1b(l) - x3b
   END IF
   CALL POPREAL8(tmp)
   temp = SIGN(max2, du2(l))
   tempb = -(one*tmpb/temp**2)
   max2b = SIGN(1.d0, max2*du2(l))*tempb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max2)
   x1b = 0.0_8
   ELSE
   CALL POPREAL8(max2)
   x1b = max2b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du2b(l) = du2b(l) + x1b
   ELSE
   du2b(l) = du2b(l) - x1b
   END IF
   END DO
   ELSE
   DO l=nwint,1,-1
   rr1b = -(opk*du2(l)*rightb(l))
   du2b(l) = du2b(l) + opk*rl2*leftb(l) - opk*rr1*rightb(l)
   rr2b = -(omk*du3(l)*rightb(l))
   du3b(l) = du3b(l) - omk*rr2*rightb(l)
   rightb(l) = 0.0_8
   rl1b = omk*du1(l)*leftb(l)
   du1b(l) = du1b(l) + omk*rl1*leftb(l)
   rl2b = opk*du2(l)*leftb(l)
   leftb(l) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rr2b = factminmod*rr2b
   ELSE
   rr2b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rr1b = factminmod*rr1b
   ELSE
   rr1b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rl2b = factminmod*rl2b
   ELSE
   rl2b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rl1b = factminmod*rl1b
   ELSE
   rl1b = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr2)
   y4b = rr2b
   ELSE
   CALL POPREAL8(rr2)
   y4b = 0.0_8
   END IF
   temp4 = SIGN(max7, du3(l))
   tempb8 = -(du2(l)*y4b/temp4**2)
   du2b(l) = du2b(l) + y4b/temp4
   max7b = SIGN(1.d0, max7*du3(l))*tempb8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max7)
   x6b = 0.0_8
   ELSE
   CALL POPREAL8(max7)
   x6b = max7b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du3b(l) = du3b(l) + x6b
   ELSE
   du3b(l) = du3b(l) - x6b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr1)
   du3b(l) = du3b(l) + tmp*rr1b
   tmpb = du3(l)*rr1b
   ELSE
   CALL POPREAL8(rr1)
   tmpb = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl2)
   du1b(l) = du1b(l) + tmp*rl2b
   tmpb = tmpb + du1(l)*rl2b
   ELSE
   CALL POPREAL8(rl2)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl1)
   y3b = rl1b
   ELSE
   CALL POPREAL8(rl1)
   y3b = 0.0_8
   END IF
   temp3 = SIGN(max6, du1(l))
   tempb7 = -(du2(l)*y3b/temp3**2)
   du2b(l) = du2b(l) + y3b/temp3
   max6b = SIGN(1.d0, max6*du1(l))*tempb7
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max6)
   x5b = 0.0_8
   ELSE
   CALL POPREAL8(max6)
   x5b = max6b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du1b(l) = du1b(l) + x5b
   ELSE
   du1b(l) = du1b(l) - x5b
   END IF
   CALL POPREAL8(tmp)
   temp2 = SIGN(max3, du2(l))
   tempb6 = -(one*tmpb/temp2**2)
   max3b = SIGN(1.d0, max3*du2(l))*tempb6
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max3)
   x2b = 0.0_8
   ELSE
   CALL POPREAL8(max3)
   x2b = max3b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du2b(l) = du2b(l) + x2b
   ELSE
   du2b(l) = du2b(l) - x2b
   END IF
   END DO
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dvxb = rot(3, 1)*du3b(ivz)
   dvyb = rot(3, 2)*du3b(ivz)
   dvzb = rot(3, 3)*du3b(ivz)
   du3b(ivz) = 0.0_8
   dvxb = dvxb + rot(2, 1)*du3b(ivy)
   dvyb = dvyb + rot(2, 2)*du3b(ivy)
   dvzb = dvzb + rot(2, 3)*du3b(ivy)
   du3b(ivy) = 0.0_8
   dvxb = dvxb + rot(1, 1)*du3b(ivx)
   dvyb = dvyb + rot(1, 2)*du3b(ivx)
   dvzb = dvzb + rot(1, 3)*du3b(ivx)
   du3b(ivx) = 0.0_8
   du3b(ivz) = du3b(ivz) + dvzb
   du3b(ivy) = du3b(ivy) + dvyb
   du3b(ivx) = du3b(ivx) + dvxb
   dvxb = rot(3, 1)*du2b(ivz)
   dvyb = rot(3, 2)*du2b(ivz)
   dvzb = rot(3, 3)*du2b(ivz)
   du2b(ivz) = 0.0_8
   dvxb = dvxb + rot(2, 1)*du2b(ivy)
   dvyb = dvyb + rot(2, 2)*du2b(ivy)
   dvzb = dvzb + rot(2, 3)*du2b(ivy)
   du2b(ivy) = 0.0_8
   dvxb = dvxb + rot(1, 1)*du2b(ivx)
   dvyb = dvyb + rot(1, 2)*du2b(ivx)
   dvzb = dvzb + rot(1, 3)*du2b(ivx)
   du2b(ivx) = 0.0_8
   du2b(ivz) = du2b(ivz) + dvzb
   du2b(ivy) = du2b(ivy) + dvyb
   du2b(ivx) = du2b(ivx) + dvxb
   dvxb = rot(3, 1)*du1b(ivz)
   dvyb = rot(3, 2)*du1b(ivz)
   dvzb = rot(3, 3)*du1b(ivz)
   du1b(ivz) = 0.0_8
   dvxb = dvxb + rot(2, 1)*du1b(ivy)
   dvyb = dvyb + rot(2, 2)*du1b(ivy)
   dvzb = dvzb + rot(2, 3)*du1b(ivy)
   du1b(ivy) = 0.0_8
   dvxb = dvxb + rot(1, 1)*du1b(ivx)
   dvyb = dvyb + rot(1, 2)*du1b(ivx)
   dvzb = dvzb + rot(1, 3)*du1b(ivx)
   du1b(ivx) = 0.0_8
   du1b(ivz) = du1b(ivz) + dvzb
   du1b(ivy) = du1b(ivy) + dvyb
   du1b(ivx) = du1b(ivx) + dvxb
   END IF
   END SUBROUTINE LEFTRIGHTSTATE_B
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATE(du1, du2, du3, rotmatrix, left, right)
   IMPLICIT NONE
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(:), INTENT(OUT) :: left, right
   REAL(kind=realtype), DIMENSION(:, :, :, :, :), POINTER :: rotmatrix
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
   REAL(kind=realtype), DIMENSION(3, 3) :: rot
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC SIGN
   INTRINSIC MIN
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: max7
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: y1
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Check if the velocity components should be transformed to
   ! the cylindrical frame.
   IF (rotationalperiodic) THEN
   ! Store the rotation matrix a bit easier. Note that the i,j,k
   ! come from the main subroutine.
   rot(1, 1) = rotmatrix(i, j, k, 1, 1)
   rot(1, 2) = rotmatrix(i, j, k, 1, 2)
   rot(1, 3) = rotmatrix(i, j, k, 1, 3)
   rot(2, 1) = rotmatrix(i, j, k, 2, 1)
   rot(2, 2) = rotmatrix(i, j, k, 2, 2)
   rot(2, 3) = rotmatrix(i, j, k, 2, 3)
   rot(3, 1) = rotmatrix(i, j, k, 3, 1)
   rot(3, 2) = rotmatrix(i, j, k, 3, 2)
   rot(3, 3) = rotmatrix(i, j, k, 3, 3)
   ! Apply the transformation to the velocity components
   ! of du1, du2 and du3.
   dvx = du1(ivx)
   dvy = du1(ivy)
   dvz = du1(ivz)
   du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du2(ivx)
   dvy = du2(ivy)
   dvz = du2(ivz)
   du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du3(ivx)
   dvy = du3(ivy)
   dvz = du3(ivz)
   du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   END IF
   ! Determine the limiter used.
   SELECT CASE  (limused) 
   CASE (nolimiter) 
   ! Linear interpolation; no limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   left(l) = omk*du1(l) + opk*du2(l)
   right(l) = -(omk*du3(l)) - opk*du2(l)
   END DO
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1 = du2(l)
   ELSE
   x1 = -du2(l)
   END IF
   IF (x1 .LT. epslim) THEN
   max2 = epslim
   ELSE
   max2 = x1
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3 = du1(l)
   ELSE
   x3 = -du1(l)
   END IF
   IF (x3 .LT. epslim) THEN
   max4 = epslim
   ELSE
   max4 = x3
   END IF
   y1 = du2(l)/SIGN(max4, du1(l))
   IF (zero .LT. y1) THEN
   rl1 = y1
   ELSE
   rl1 = zero
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4 = du3(l)
   ELSE
   x4 = -du3(l)
   END IF
   IF (x4 .LT. epslim) THEN
   max5 = epslim
   ELSE
   max5 = x4
   END IF
   y2 = du2(l)/SIGN(max5, du3(l))
   IF (zero .LT. y2) THEN
   rr2 = y2
   ELSE
   rr2 = zero
   END IF
   ! Compute the corresponding limiter values.
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2 = du2(l)
   ELSE
   x2 = -du2(l)
   END IF
   IF (x2 .LT. epslim) THEN
   max3 = epslim
   ELSE
   max3 = x2
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max3, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5 = du1(l)
   ELSE
   x5 = -du1(l)
   END IF
   IF (x5 .LT. epslim) THEN
   max6 = epslim
   ELSE
   max6 = x5
   END IF
   y3 = du2(l)/SIGN(max6, du1(l))
   IF (zero .LT. y3) THEN
   rl1 = y3
   ELSE
   rl1 = zero
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6 = du3(l)
   ELSE
   x6 = -du3(l)
   END IF
   IF (x6 .LT. epslim) THEN
   max7 = epslim
   ELSE
   max7 = x6
   END IF
   y4 = du2(l)/SIGN(max7, du3(l))
   IF (zero .LT. y4) THEN
   rr2 = y4
   ELSE
   rr2 = zero
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1 = factminmod*rl1
   ELSE
   rl1 = one
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2 = factminmod*rl2
   ELSE
   rl2 = one
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1 = factminmod*rr1
   ELSE
   rr1 = one
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2 = factminmod*rr2
   ELSE
   rr2 = one
   END IF
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   left(itu1) = zero
   right(itu1) = zero
   END IF
   ! For rotational periodic problems transform the velocity
   ! differences back to Cartesian again. Note that now the
   ! transpose of the rotation matrix must be used.
   IF (rotationalperiodic) THEN
   ! Left state.
   dvx = left(ivx)
   dvy = left(ivy)
   dvz = left(ivz)
   left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   ! Right state.
   dvx = right(ivx)
   dvy = right(ivy)
   dvz = right(ivz)
   right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   END IF
   END SUBROUTINE LEFTRIGHTSTATE
   !  Differentiation of riemannflux in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: tref rgas flux left right
   !   with respect to varying inputs: tref rgas gammaface sx sy sz
   !                flux left right
   !        ================================================================
   SUBROUTINE RIEMANNFLUX_B(left, leftb, right, rightb, flux, fluxb)
   IMPLICIT NONE
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*) :: leftb, rightb
   REAL(kind=realtype), DIMENSION(*) :: flux
   REAL(kind=realtype), DIMENSION(*) :: fluxb
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: rfaceb
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: etlb, etrb, z1lb, z1rb, tmpb
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: drb, drub, drvb, drwb, dreb, drkb
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: uavgb, vavgb, wavgb, havgb, kavgb
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: alphaavgb, a2avgb, aavgb, unavgb
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: ovaavgb, ova2avgb, areab, etab
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: gm1b, gm53b
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: lam1b, lam2b, lam3b
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype) :: abv1b, abv2b, abv3b, abv4b, abv5b, abv6b, &
   &   abv7b
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: rhotmpb, utmpb, vtmpb, wtmpb
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   REAL(kind=realtype), DIMENSION(2) :: ptmpb, ktmpb, etmpb
   INTRINSIC SQRT
   INTRINSIC MAX
   INTRINSIC ABS
   INTEGER :: branch
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: abs1b
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: max2b
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb19
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb18
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb17
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb16
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb15
   REAL(kind=realtype) :: tempb14
   REAL(kind=realtype) :: tempb13
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: tempb10
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x2b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: x1b
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: abs2b
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max2
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Abbreviate some expressions in which gamma occurs.
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   z1l = SQRT(left(irho))
   z1r = SQRT(right(irho))
   tmp = one/(z1l+z1r)
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmp(1) = left(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   END IF
   ! Compute the total energy of the left and right state.
   rhotmp(1) = left(irho)
   rhotmp(2) = right(irho)
   utmp(1) = left(ivx)
   utmp(2) = right(ivx)
   vtmp(1) = left(ivy)
   vtmp(2) = right(ivy)
   wtmp(1) = left(ivz)
   wtmp(2) = right(ivz)
   ptmp(1) = left(irhoe)
   ptmp(2) = right(irhoe)
   CALL PUSHREAL8ARRAY(etmp, 2)
   CALL ETOTARRAY(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
   &                   correctfork, 2)
   etl = etmp(1)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   dr = right(irho) - left(irho)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   max2 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   max2 = 1.e-25_realType
   END IF
   tmp = one/max2
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   CALL PUSHCONTROL1B(0)
   ELSE
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   CALL PUSHCONTROL1B(1)
   END IF
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ovaavg = one/aavg
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) THEN
   unavg = rface
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
   &         left(ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1 = x1
   CALL PUSHCONTROL1B(1)
   ELSE
   abs1 = -x1
   CALL PUSHCONTROL1B(0)
   END IF
   x2 = SQRT(gammaface*left(irhoe)/left(irho)) - SQRT(gammaface*&
   &         right(irhoe)/right(irho))
   IF (x2 .GE. 0.) THEN
   abs2 = x2
   CALL PUSHCONTROL1B(0)
   ELSE
   abs2 = -x2
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1 = unavg - rface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-rface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2 = unavg - rface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-rface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3 = unavg - rface
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = -(unavg-rface)
   CALL PUSHCONTROL1B(1)
   END IF
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) THEN
   CALL PUSHREAL8(lam1)
   lam1 = eta + fourth*lam1*lam1/eta
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (lam2 .LT. tmp) THEN
   CALL PUSHREAL8(lam2)
   lam2 = eta + fourth*lam2*lam2/eta
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (lam3 .LT. tmp) THEN
   CALL PUSHREAL8(lam3)
   lam3 = eta + fourth*lam3*lam3/eta
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   abv2 = half*(lam1-lam2)
   abv3 = abv1 - lam3
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
   &         drk
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   tempb14 = -(porflux*fluxb(irhoe))
   havgb = abv6*tempb14
   fluxb(irhoe) = 0.0_8
   tempb15 = -(porflux*fluxb(imz))
   fluxb(imz) = 0.0_8
   tempb18 = -(porflux*fluxb(imy))
   fluxb(imy) = 0.0_8
   tempb16 = -(porflux*fluxb(imx))
   abv7b = sz*tempb15 + sx*tempb16 + sy*tempb18 + unavg*tempb14
   fluxb(imx) = 0.0_8
   tempb17 = -(porflux*fluxb(irho))
   abv6b = wavg*tempb15 + uavg*tempb16 + tempb17 + vavg*tempb18 + &
   &         havg*tempb14
   fluxb(irho) = 0.0_8
   abv2b = ovaavg*abv5*abv6b + ovaavg*abv4*abv7b
   abv4b = ova2avg*abv3*abv6b + ovaavg*abv2*abv7b
   ovaavgb = abv2*abv5*abv6b + abv2*abv4*abv7b
   abv3b = ova2avg*abv4*abv6b + abv5*abv7b
   lam3b = drw*tempb15 + dru*tempb16 - abv3b + dr*tempb17 + drv*&
   &         tempb18 + dre*tempb14
   abv5b = ovaavg*abv2*abv6b + abv3*abv7b
   unavgb = abv7*tempb14 - dr*abv5b
   szb = drw*abv5b + abv7*tempb15
   syb = drv*abv5b + abv7*tempb18
   sxb = dru*abv5b + abv7*tempb16
   ova2avgb = abv3*abv4*abv6b
   tempb19 = gm1*abv4b
   dreb = tempb19 + lam3*tempb14
   drwb = sz*abv5b - wavg*tempb19 + lam3*tempb15
   wavgb = abv6*tempb15 - drw*tempb19
   drvb = sy*abv5b - vavg*tempb19 + lam3*tempb18
   vavgb = abv6*tempb18 - drv*tempb19
   drub = sx*abv5b - uavg*tempb19 + lam3*tempb16
   uavgb = abv6*tempb16 - dru*tempb19
   drb = alphaavg*tempb19 - unavg*abv5b + lam3*tempb17
   gm1b = (alphaavg*dr-uavg*dru-vavg*drv+dre-wavg*drw)*abv4b
   alphaavgb = dr*tempb19
   gm53b = -(drk*abv4b)
   drkb = -(gm53*abv4b)
   abv1b = abv3b
   lam1b = half*abv1b + half*abv2b
   lam2b = half*abv1b - half*abv2b
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   areab = lam2*lam2b + lam1*lam1b + lam3*lam3b
   lam3b = area*lam3b
   lam2b = area*lam2b
   lam1b = area*lam1b
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   tempb13 = fourth*lam3b/eta
   etab = lam3b - lam3**2*tempb13/eta
   lam3b = 2*lam3*tempb13
   ELSE
   etab = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam2)
   tempb12 = fourth*lam2b/eta
   etab = etab + lam2b - lam2**2*tempb12/eta
   lam2b = 2*lam2*tempb12
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam1)
   tempb11 = fourth*lam1b/eta
   etab = etab + lam1b - lam1**2*tempb11/eta
   lam1b = 2*lam1*tempb11
   END IF
   tmp = one/max2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam3b
   rfaceb = -lam3b
   ELSE
   rfaceb = lam3b
   unavgb = unavgb - lam3b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam2b
   rfaceb = rfaceb - lam2b
   aavgb = -lam2b
   ELSE
   rfaceb = rfaceb + lam2b
   unavgb = unavgb - lam2b
   aavgb = lam2b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgb = unavgb + lam1b
   rfaceb = rfaceb - lam1b
   aavgb = aavgb + lam1b
   ELSE
   rfaceb = rfaceb + lam1b
   unavgb = unavgb - lam1b
   aavgb = aavgb - lam1b
   END IF
   abs1b = half*etab
   abs2b = half*etab
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x2b = abs2b
   ELSE
   x2b = -abs2b
   END IF
   temp1 = gammaface*left(irhoe)/left(irho)
   IF (temp1 .EQ. 0.0_8) THEN
   tempb9 = 0.0
   ELSE
   tempb9 = x2b/(2.0*SQRT(temp1)*left(irho))
   END IF
   temp2 = gammaface*right(irhoe)/right(irho)
   IF (temp2 .EQ. 0.0_8) THEN
   tempb10 = 0.0
   ELSE
   tempb10 = -(x2b/(2.0*SQRT(temp2)*right(irho)))
   END IF
   gammafaceb = right(irhoe)*tempb10 + left(irhoe)*tempb9
   leftb(irhoe) = leftb(irhoe) + gammaface*tempb9
   leftb(irho) = leftb(irho) - temp1*tempb9
   rightb(irhoe) = rightb(irhoe) + gammaface*tempb10
   rightb(irho) = rightb(irho) - temp2*tempb10
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x1b = -abs1b
   ELSE
   x1b = abs1b
   END IF
   leftb(ivx) = leftb(ivx) + sx*x1b
   rightb(ivx) = rightb(ivx) - sx*x1b
   sxb = sxb + (left(ivx)-right(ivx))*x1b
   leftb(ivy) = leftb(ivy) + sy*x1b
   rightb(ivy) = rightb(ivy) - sy*x1b
   syb = syb + (left(ivy)-right(ivy))*x1b
   leftb(ivz) = leftb(ivz) + sz*x1b
   rightb(ivz) = rightb(ivz) - sz*x1b
   szb = szb + (left(ivz)-right(ivz))*x1b
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   rfaceb = rfaceb + unavgb
   unavgb = 0.0_8
   END IF
   aavgb = aavgb - one*ovaavgb/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgb = -(one*ova2avgb/a2avg**2)
   ELSE
   a2avgb = aavgb/(2.0*SQRT(a2avg)) - one*ova2avgb/a2avg**2
   END IF
   uavgb = uavgb + sx*unavgb
   sxb = sxb + uavg*unavgb
   vavgb = vavgb + sy*unavgb
   syb = syb + vavg*unavgb
   wavgb = wavgb + sz*unavgb
   szb = szb + wavg*unavgb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   gm1b = gm1b + (havg-alphaavg)*a2avgb
   havgb = havgb + gm1*a2avgb
   alphaavgb = alphaavgb - gm1*a2avgb
   gm53b = gm53b - kavg*a2avgb
   kavgb = -(gm53*a2avgb)
   ELSE
   gm53b = gm53b + kavg*a2avgb
   kavgb = gm53*a2avgb
   gm1b = gm1b - (havg-alphaavg)*a2avgb
   havgb = havgb - gm1*a2avgb
   alphaavgb = alphaavgb + gm1*a2avgb
   END IF
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tempb8 = half*alphaavgb
   uavgb = uavgb + 2*uavg*tempb8
   vavgb = vavgb + 2*vavg*tempb8
   wavgb = wavgb + 2*wavg*tempb8
   tmpb = sz*szb + sx*sxb + sy*syb + sface*rfaceb
   szb = tmp*szb
   syb = tmp*syb
   sxb = tmp*sxb
   max2b = -(one*tmpb/max2**2)
   tmp = one/(z1l+z1r)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) areab = areab + max2b
   tempb6 = tmp*uavgb
   tempb7 = tmp*vavgb
   tempb5 = tmp*wavgb
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempb1 = 0.0
   ELSE
   tempb1 = areab/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxb = sxb + 2*sx*tempb1
   syb = syb + 2*sy*tempb1
   szb = szb + 2*sz*tempb1
   temp0 = (etr+right(irhoe))/z1r
   temp = (etl+left(irhoe))/z1l
   tempb2 = tmp*havgb
   tempb3 = tempb2/z1l
   tempb4 = tempb2/z1r
   tmpb = (z1l*left(ivz)+z1r*right(ivz))*wavgb + (z1l*left(ivx)+z1r&
   &         *right(ivx))*uavgb + (z1l*left(ivy)+z1r*right(ivy))*vavgb + (&
   &         temp+temp0)*havgb
   etlb = tempb3 - dreb
   leftb(irhoe) = leftb(irhoe) + tempb3
   z1lb = left(ivz)*tempb5 + left(ivx)*tempb6 + left(ivy)*tempb7 - &
   &         temp*tempb3
   etrb = dreb + tempb4
   rightb(irhoe) = rightb(irhoe) + tempb4
   z1rb = right(ivz)*tempb5 + right(ivx)*tempb6 + right(ivy)*tempb7&
   &         - temp0*tempb4
   leftb(ivz) = leftb(ivz) + z1l*tempb5
   rightb(ivz) = rightb(ivz) + z1r*tempb5
   leftb(ivy) = leftb(ivy) + z1l*tempb7
   rightb(ivy) = rightb(ivy) + z1r*tempb7
   leftb(ivx) = leftb(ivx) + z1l*tempb6
   rightb(ivx) = rightb(ivx) + z1r*tempb6
   rightb(irho) = rightb(irho) + right(ivz)*drwb
   rightb(ivz) = rightb(ivz) + right(irho)*drwb
   leftb(irho) = leftb(irho) - left(ivz)*drwb
   leftb(ivz) = leftb(ivz) - left(irho)*drwb
   rightb(irho) = rightb(irho) + right(ivy)*drvb
   rightb(ivy) = rightb(ivy) + right(irho)*drvb
   leftb(irho) = leftb(irho) - left(ivy)*drvb
   leftb(ivy) = leftb(ivy) - left(irho)*drvb
   rightb(irho) = rightb(irho) + right(ivx)*drub
   rightb(ivx) = rightb(ivx) + right(irho)*drub
   leftb(irho) = leftb(irho) - left(ivx)*drub
   leftb(ivx) = leftb(ivx) - left(irho)*drub
   rightb(irho) = rightb(irho) + drb
   leftb(irho) = leftb(irho) - drb
   etmpb = 0.0_8
   etmpb(2) = etmpb(2) + etrb
   etmpb(1) = etmpb(1) + etlb
   CALL POPREAL8ARRAY(etmp, 2)
   rhotmpb = 0.0_8
   ptmpb = 0.0_8
   CALL ETOTARRAY_B(rhotmp, rhotmpb, utmp, utmpb, vtmp, vtmpb, wtmp&
   &                  , wtmpb, ptmp, ptmpb, ktmp, ktmpb, etmp, etmpb, &
   &                  correctfork, 2)
   rightb(irhoe) = rightb(irhoe) + ptmpb(2)
   ptmpb(2) = 0.0_8
   leftb(irhoe) = leftb(irhoe) + ptmpb(1)
   rightb(ivz) = rightb(ivz) + wtmpb(2)
   wtmpb(2) = 0.0_8
   leftb(ivz) = leftb(ivz) + wtmpb(1)
   rightb(ivy) = rightb(ivy) + vtmpb(2)
   vtmpb(2) = 0.0_8
   leftb(ivy) = leftb(ivy) + vtmpb(1)
   rightb(ivx) = rightb(ivx) + utmpb(2)
   utmpb(2) = 0.0_8
   leftb(ivx) = leftb(ivx) + utmpb(1)
   rightb(irho) = rightb(irho) + rhotmpb(2)
   rhotmpb(2) = 0.0_8
   leftb(irho) = leftb(irho) + rhotmpb(1)
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tempb0 = tmp*kavgb
   tmpb = tmpb + (z1l*left(itu1)+z1r*right(itu1))*kavgb
   z1lb = z1lb + left(itu1)*tempb0
   leftb(itu1) = leftb(itu1) + z1l*tempb0
   z1rb = z1rb + right(itu1)*tempb0
   rightb(itu1) = rightb(itu1) + z1r*tempb0
   rightb(irho) = rightb(irho) + right(itu1)*drkb
   rightb(itu1) = rightb(itu1) + ktmpb(2) + right(irho)*drkb
   leftb(irho) = leftb(irho) - left(itu1)*drkb
   ktmpb(2) = 0.0_8
   leftb(itu1) = leftb(itu1) + ktmpb(1) - left(irho)*drkb
   END IF
   tempb = -(one*tmpb/(z1l+z1r)**2)
   z1lb = z1lb + tempb
   z1rb = z1rb + tempb
   IF (.NOT.right(irho) .EQ. 0.0_8) rightb(irho) = rightb(irho) + &
   &           z1rb/(2.0*SQRT(right(irho)))
   IF (.NOT.left(irho) .EQ. 0.0_8) leftb(irho) = leftb(irho) + z1lb&
   &           /(2.0*SQRT(left(irho)))
   CASE (turkel) 
   gammafaceb = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   gm1b = 0.0_8
   gm53b = 0.0_8
   CASE (choimerkle) 
   gammafaceb = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   gm1b = 0.0_8
   gm53b = 0.0_8
   CASE DEFAULT
   gammafaceb = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   gm1b = 0.0_8
   gm53b = 0.0_8
   END SELECT
   CASE (vanleer) 
   gammafaceb = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   gm1b = 0.0_8
   gm53b = 0.0_8
   CASE (ausmdv) 
   gammafaceb = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   gm1b = 0.0_8
   gm53b = 0.0_8
   CASE DEFAULT
   gammafaceb = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   gm1b = 0.0_8
   gm53b = 0.0_8
   END SELECT
   gammafaceb = gammafaceb + gm1b + gm53b
   END SUBROUTINE RIEMANNFLUX_B
   !        ================================================================
   SUBROUTINE RIEMANNFLUX(left, right, flux)
   IMPLICIT NONE
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: flux
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   INTRINSIC SQRT
   INTRINSIC MAX
   INTRINSIC ABS
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: max2
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Abbreviate some expressions in which gamma occurs.
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   z1l = SQRT(left(irho))
   z1r = SQRT(right(irho))
   tmp = one/(z1l+z1r)
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmp(1) = left(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   ELSE
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   END IF
   ! Compute the total energy of the left and right state.
   rhotmp(1) = left(irho)
   rhotmp(2) = right(irho)
   utmp(1) = left(ivx)
   utmp(2) = right(ivx)
   vtmp(1) = left(ivy)
   vtmp(2) = right(ivy)
   wtmp(1) = left(ivz)
   wtmp(2) = right(ivz)
   ptmp(1) = left(irhoe)
   ptmp(2) = right(irhoe)
   CALL ETOTARRAY(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
   &                   correctfork, 2)
   etl = etmp(1)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   dr = right(irho) - left(irho)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   ravg = fourth*(z1r+z1l)**2
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   max2 = area
   ELSE
   max2 = 1.e-25_realType
   END IF
   tmp = one/max2
   sx = sx*tmp
   sy = sy*tmp
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   ELSE
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   END IF
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ovaavg = one/aavg
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) unavg = rface
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
   &         left(ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1 = x1
   ELSE
   abs1 = -x1
   END IF
   x2 = SQRT(gammaface*left(irhoe)/left(irho)) - SQRT(gammaface*&
   &         right(irhoe)/right(irho))
   IF (x2 .GE. 0.) THEN
   abs2 = x2
   ELSE
   abs2 = -x2
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1 = unavg - rface + aavg
   ELSE
   lam1 = -(unavg-rface+aavg)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2 = unavg - rface - aavg
   ELSE
   lam2 = -(unavg-rface-aavg)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3 = unavg - rface
   ELSE
   lam3 = -(unavg-rface)
   END IF
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) lam1 = eta + fourth*lam1*lam1/eta
   IF (lam2 .LT. tmp) lam2 = eta + fourth*lam2*lam2/eta
   IF (lam3 .LT. tmp) lam3 = eta + fourth*lam3*lam3/eta
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   lam1 = lam1*area
   lam2 = lam2*area
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   abv2 = half*(lam1-lam2)
   abv3 = abv1 - lam3
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
   &         drk
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   flux(irho) = -(porflux*(lam3*dr+abv6))
   flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
   flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
   flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
   flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
   CASE (turkel) 
   !          tmp = max(lam1,lam2,lam3)
   !          flux(irho)  = -porFlux*(tmp*dr)
   !          flux(imx)   = -porFlux*(tmp*dru)
   !          flux(imy)   = -porFlux*(tmp*drv)
   !          flux(imz)   = -porFlux*(tmp*drw)
   !          flux(irhoE) = -porFlux*(tmp*drE)
   CALL TERMINATE('riemannFlux', &
   &                   'Turkel preconditioner not implemented yet')
   CASE (choimerkle) 
   CALL TERMINATE('riemannFlux', &
   &                   'choi merkle preconditioner not implemented yet')
   END SELECT
   CASE (vanleer) 
   CALL TERMINATE('riemannFlux', &
   &                 'van leer fvs not implemented yet')
   CASE (ausmdv) 
   CALL TERMINATE('riemannFlux', 'ausmdv fvs not implemented yet')
   END SELECT
   END SUBROUTINE RIEMANNFLUX
   END SUBROUTINE INVISCIDUPWINDFLUX_B

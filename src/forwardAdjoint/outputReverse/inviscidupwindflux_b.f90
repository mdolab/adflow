   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of inviscidupwindflux in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *p *w *si *sj *sk *fw
   !   with respect to varying inputs: tref rgas *p *w *si *sj *sk
   !   Plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidUpwindFlux.f90                          *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-25-2003                                      *
   !      * Last modified: 10-29-2007                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDUPWINDFLUX_B(finegrid)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidUpwindFlux computes the artificial dissipation part of *
   !      * the Euler fluxes by means of an approximate solution of the 1D *
   !      * Riemann problem on the face. For first order schemes,          *
   !      * fineGrid == .false., the states in the cells are assumed to    *
   !      * be constant; for the second order schemes on the fine grid a   *
   !      * nonlinear reconstruction of the left and right state is done   *
   !      * for which several options exist.                               *
   !      * It is assumed that the pointers in blockPointers already       *
   !      * point to the correct block.                                    *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE CGNSGRID
   USE CONSTANTS
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: finegrid
   !
   !      Local variables.
   !
   INTEGER(kind=portype) :: por
   INTEGER(kind=inttype) :: nwint
   INTEGER(kind=inttype) :: i, j, k, ind
   INTEGER(kind=inttype) :: limused, riemannused
   REAL(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
   REAL(kind=realtype) :: sxd, syd, szd
   REAL(kind=realtype) :: factminmod, sface
   REAL(kind=realtype), DIMENSION(nw) :: left, right
   REAL(kind=realtype), DIMENSION(nw) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(nw) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(nw) :: du1d, du2d, du3d
   REAL(kind=realtype), DIMENSION(nwf) :: flux
   REAL(kind=realtype), DIMENSION(nwf) :: fluxd
   LOGICAL :: firstorderk, correctfork, rotationalperiodic
   INTRINSIC ABS
   INTRINSIC ASSOCIATED
   INTRINSIC MAX
   INTEGER :: branch
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: max1
   IF (rfil .GE. 0.) THEN
   abs0 = rfil
   ELSE
   abs0 = -rfil
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check if rFil == 0. If so, the dissipative flux needs not to
   ! be computed.
   IF (abs0 .LT. thresholdreal) THEN
   trefd = 0.0_8
   rgasd = 0.0_8
   ELSE
   ! Check if the formulation for rotational periodic problems
   ! must be used.
   IF (ASSOCIATED(rotmatrixi)) THEN
   rotationalperiodic = .true.
   ELSE
   rotationalperiodic = .false.
   END IF
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .EQ. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   IF (1.e-10_realType .LT. one - kappacoef) THEN
   max1 = one - kappacoef
   ELSE
   max1 = 1.e-10_realType
   END IF
   ! Compute the factor used in the minmod limiter.
   factminmod = (three-kappacoef)/max1
   ! Determine the limiter scheme to be used. On the fine grid the
   ! user specified scheme is used; on the coarse grid a first order
   ! scheme is computed.
   limused = firstorder
   IF (finegrid) limused = limiter
   ! Lumped diss is true for doing approx PC
   IF (lumpeddiss) limused = firstorder
   ! Determine the riemann solver which must be used.
   riemannused = riemanncoarse
   IF (finegrid) riemannused = riemann
   ! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
   omk = fourth*(one-kappacoef)
   opk = fourth*(one+kappacoef)
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set the number of variables to be interpolated depending
   ! whether or not a k-equation is present. If a k-equation is
   ! present also set the logical firstOrderK. This indicates
   ! whether or not only a first order approximation is to be used
   ! for the turbulent kinetic energy.
   IF (correctfork) THEN
   IF (orderturb .EQ. firstorder) THEN
   nwint = nwf
   firstorderk = .true.
   ELSE
   nwint = itu1
   firstorderk = .false.
   END IF
   ELSE
   nwint = nwf
   firstorderk = .false.
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Flux computation. A distinction is made between first and      *
   !      * second order schemes to avoid the overhead for the first order *
   !      * scheme.                                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   IF (limused .EQ. firstorder) THEN
   !
   !        ****************************************************************
   !        *                                                              *
   !        * First order reconstruction. The states in the cells are      *
   !        * constant. The left and right states are constructed easily.  *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   DO k=2,kl
   DO j=2,jl
   DO i=1,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = si(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = si(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = si(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacei(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the left and right state.
   CALL PUSHREAL8(left(irho))
   left(irho) = w(i, j, k, irho)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = w(i, j, k, ivx)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = w(i, j, k, ivy)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = w(i, j, k, ivz)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = w(i, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = w(i+1, j, k, irho)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = w(i+1, j, k, ivx)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = w(i+1, j, k, ivy)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = w(i+1, j, k, ivz)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = p(i+1, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = w(i+1, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in j-direction.
   DO k=2,kl
   DO j=1,jl
   DO i=2,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sj(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sj(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sj(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacej(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the left and right state.
   CALL PUSHREAL8(left(irho))
   left(irho) = w(i, j, k, irho)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = w(i, j, k, ivx)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = w(i, j, k, ivy)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = w(i, j, k, ivz)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = w(i, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = w(i, j+1, k, irho)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = w(i, j+1, k, ivx)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = w(i, j+1, k, ivy)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = w(i, j+1, k, ivz)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = p(i, j+1, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = w(i, j+1, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in k-direction.
   DO k=1,kl
   DO j=2,jl
   DO i=2,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sk(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sk(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sk(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacek(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the left and right state.
   CALL PUSHREAL8(left(irho))
   left(irho) = w(i, j, k, irho)
   CALL PUSHREAL8(left(ivx))
   left(ivx) = w(i, j, k, ivx)
   CALL PUSHREAL8(left(ivy))
   left(ivy) = w(i, j, k, ivy)
   CALL PUSHREAL8(left(ivz))
   left(ivz) = w(i, j, k, ivz)
   CALL PUSHREAL8(left(irhoe))
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   CALL PUSHREAL8(left(itu1))
   left(itu1) = w(i, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(right(irho))
   right(irho) = w(i, j, k+1, irho)
   CALL PUSHREAL8(right(ivx))
   right(ivx) = w(i, j, k+1, ivx)
   CALL PUSHREAL8(right(ivy))
   right(ivy) = w(i, j, k+1, ivy)
   CALL PUSHREAL8(right(ivz))
   right(ivz) = w(i, j, k+1, ivz)
   CALL PUSHREAL8(right(irhoe))
   right(irhoe) = p(i, j, k+1)
   IF (correctfork) THEN
   CALL PUSHREAL8(right(itu1))
   right(itu1) = w(i, j, k+1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   trefd = 0.0_8
   rgasd = 0.0_8
   fluxd = 0.0_8
   leftd = 0.0_8
   rightd = 0.0_8
   DO k=kl,1,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   fluxd(irhoe) = fluxd(irhoe) - fwd(i, j, k+1, irhoe)
   fluxd(imz) = fluxd(imz) - fwd(i, j, k+1, imz)
   fluxd(imy) = fluxd(imy) - fwd(i, j, k+1, imy)
   fluxd(imx) = fluxd(imx) - fwd(i, j, k+1, imx)
   fluxd(irho) = fluxd(irho) - fwd(i, j, k+1, irho)
   fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
   fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
   fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
   fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
   fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
   por = pork(i, j, k)
   CALL RIEMANNFLUX_B(left, leftd, right, rightd, flux, fluxd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(right(itu1))
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + rightd(itu1)
   rightd(itu1) = 0.0_8
   END IF
   CALL POPREAL8(right(irhoe))
   pd(i, j, k+1) = pd(i, j, k+1) + rightd(irhoe)
   rightd(irhoe) = 0.0_8
   CALL POPREAL8(right(ivz))
   wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + rightd(ivz)
   rightd(ivz) = 0.0_8
   CALL POPREAL8(right(ivy))
   wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + rightd(ivy)
   rightd(ivy) = 0.0_8
   CALL POPREAL8(right(ivx))
   wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + rightd(ivx)
   rightd(ivx) = 0.0_8
   CALL POPREAL8(right(irho))
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + rightd(irho)
   rightd(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(left(itu1))
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
   leftd(itu1) = 0.0_8
   END IF
   CALL POPREAL8(left(irhoe))
   pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
   leftd(irhoe) = 0.0_8
   CALL POPREAL8(left(ivz))
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
   leftd(ivz) = 0.0_8
   CALL POPREAL8(left(ivy))
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
   leftd(ivy) = 0.0_8
   CALL POPREAL8(left(ivx))
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
   leftd(ivx) = 0.0_8
   CALL POPREAL8(left(irho))
   wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
   leftd(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   skd(i, j, k, 3) = skd(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   skd(i, j, k, 2) = skd(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,1,-1
   DO i=il,2,-1
   fluxd(irhoe) = fluxd(irhoe) - fwd(i, j+1, k, irhoe)
   fluxd(imz) = fluxd(imz) - fwd(i, j+1, k, imz)
   fluxd(imy) = fluxd(imy) - fwd(i, j+1, k, imy)
   fluxd(imx) = fluxd(imx) - fwd(i, j+1, k, imx)
   fluxd(irho) = fluxd(irho) - fwd(i, j+1, k, irho)
   fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
   fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
   fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
   fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
   fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
   por = porj(i, j, k)
   CALL RIEMANNFLUX_B(left, leftd, right, rightd, flux, fluxd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(right(itu1))
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + rightd(itu1)
   rightd(itu1) = 0.0_8
   END IF
   CALL POPREAL8(right(irhoe))
   pd(i, j+1, k) = pd(i, j+1, k) + rightd(irhoe)
   rightd(irhoe) = 0.0_8
   CALL POPREAL8(right(ivz))
   wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + rightd(ivz)
   rightd(ivz) = 0.0_8
   CALL POPREAL8(right(ivy))
   wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + rightd(ivy)
   rightd(ivy) = 0.0_8
   CALL POPREAL8(right(ivx))
   wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + rightd(ivx)
   rightd(ivx) = 0.0_8
   CALL POPREAL8(right(irho))
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + rightd(irho)
   rightd(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(left(itu1))
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
   leftd(itu1) = 0.0_8
   END IF
   CALL POPREAL8(left(irhoe))
   pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
   leftd(irhoe) = 0.0_8
   CALL POPREAL8(left(ivz))
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
   leftd(ivz) = 0.0_8
   CALL POPREAL8(left(ivy))
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
   leftd(ivy) = 0.0_8
   CALL POPREAL8(left(ivx))
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
   leftd(ivx) = 0.0_8
   CALL POPREAL8(left(irho))
   wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
   leftd(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,1,-1
   fluxd(irhoe) = fluxd(irhoe) - fwd(i+1, j, k, irhoe)
   fluxd(imz) = fluxd(imz) - fwd(i+1, j, k, imz)
   fluxd(imy) = fluxd(imy) - fwd(i+1, j, k, imy)
   fluxd(imx) = fluxd(imx) - fwd(i+1, j, k, imx)
   fluxd(irho) = fluxd(irho) - fwd(i+1, j, k, irho)
   fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
   fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
   fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
   fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
   fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
   por = pori(i, j, k)
   CALL RIEMANNFLUX_B(left, leftd, right, rightd, flux, fluxd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(right(itu1))
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + rightd(itu1)
   rightd(itu1) = 0.0_8
   END IF
   CALL POPREAL8(right(irhoe))
   pd(i+1, j, k) = pd(i+1, j, k) + rightd(irhoe)
   rightd(irhoe) = 0.0_8
   CALL POPREAL8(right(ivz))
   wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + rightd(ivz)
   rightd(ivz) = 0.0_8
   CALL POPREAL8(right(ivy))
   wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + rightd(ivy)
   rightd(ivy) = 0.0_8
   CALL POPREAL8(right(ivx))
   wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + rightd(ivx)
   rightd(ivx) = 0.0_8
   CALL POPREAL8(right(irho))
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + rightd(irho)
   rightd(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(left(itu1))
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
   leftd(itu1) = 0.0_8
   END IF
   CALL POPREAL8(left(irhoe))
   pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
   leftd(irhoe) = 0.0_8
   CALL POPREAL8(left(ivz))
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
   leftd(ivz) = 0.0_8
   CALL POPREAL8(left(ivy))
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
   leftd(ivy) = 0.0_8
   CALL POPREAL8(left(ivx))
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
   leftd(ivx) = 0.0_8
   CALL POPREAL8(left(irho))
   wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
   leftd(irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sid(i, j, k, 3) = sid(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   sid(i, j, k, 2) = sid(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
   END DO
   END DO
   END DO
   ELSE
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   !      ==================================================================
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Second order reconstruction of the left and right state.     *
   !        * The three differences used in the, possibly nonlinear,       *
   !        * interpolation are constructed here; the actual left and      *
   !        * right states, or at least the differences from the first     *
   !        * order interpolation, are computed in the subroutine          *
   !        * leftRightState.                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   DO k=2,kl
   DO j=2,jl
   DO i=1,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
   du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
   du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
   du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
   du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
   du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
   du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
   du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
   du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
   du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
   du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
   du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
   du1(irhoe) = p(i, j, k) - p(i-1, j, k)
   du2(irhoe) = p(i+1, j, k) - p(i, j, k)
   du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
   IF (correctfork) THEN
   du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
   du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
   du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   CALL PUSHREAL8ARRAY(du3, nw)
   CALL PUSHREAL8ARRAY(du2, nw)
   CALL PUSHREAL8ARRAY(du1, nw)
   CALL LEFTRIGHTSTATE(du1, du2, du3, rotmatrixi, left, right)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + w(i, j, k, irho)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   left(irhoe) = left(irhoe) + p(i, j, k)
   right(irho) = right(irho) + w(i+1, j, k, irho)
   right(ivx) = right(ivx) + w(i+1, j, k, ivx)
   right(ivy) = right(ivy) + w(i+1, j, k, ivy)
   right(ivz) = right(ivz) + w(i+1, j, k, ivz)
   right(irhoe) = right(irhoe) + p(i+1, j, k)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   right(itu1) = right(itu1) + w(i+1, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = si(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = si(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = si(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacei(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in the j-direction.
   DO k=2,kl
   DO j=1,jl
   DO i=2,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
   du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
   du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
   du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
   du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
   du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
   du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
   du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
   du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
   du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
   du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
   du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
   du1(irhoe) = p(i, j, k) - p(i, j-1, k)
   du2(irhoe) = p(i, j+1, k) - p(i, j, k)
   du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
   IF (correctfork) THEN
   du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
   du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
   du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   CALL PUSHREAL8ARRAY(du3, nw)
   CALL PUSHREAL8ARRAY(du2, nw)
   CALL PUSHREAL8ARRAY(du1, nw)
   CALL LEFTRIGHTSTATE(du1, du2, du3, rotmatrixj, left, right)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + w(i, j, k, irho)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   left(irhoe) = left(irhoe) + p(i, j, k)
   right(irho) = right(irho) + w(i, j+1, k, irho)
   right(ivx) = right(ivx) + w(i, j+1, k, ivx)
   right(ivy) = right(ivy) + w(i, j+1, k, ivy)
   right(ivz) = right(ivz) + w(i, j+1, k, ivz)
   right(irhoe) = right(irhoe) + p(i, j+1, k)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   right(itu1) = right(itu1) + w(i, j+1, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sj(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sj(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sj(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacej(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in the k-direction.
   DO k=1,kl
   DO j=2,jl
   DO i=2,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
   du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
   du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
   du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
   du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
   du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
   du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
   du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
   du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
   du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
   du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
   du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
   du1(irhoe) = p(i, j, k) - p(i, j, k-1)
   du2(irhoe) = p(i, j, k+1) - p(i, j, k)
   du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
   IF (correctfork) THEN
   du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
   du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
   du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL PUSHREAL8ARRAY(right, nw)
   CALL PUSHREAL8ARRAY(left, nw)
   CALL PUSHREAL8ARRAY(du3, nw)
   CALL PUSHREAL8ARRAY(du2, nw)
   CALL PUSHREAL8ARRAY(du1, nw)
   CALL LEFTRIGHTSTATE(du1, du2, du3, rotmatrixk, left, right)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   left(irho) = left(irho) + w(i, j, k, irho)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   left(irhoe) = left(irhoe) + p(i, j, k)
   right(irho) = right(irho) + w(i, j, k+1, irho)
   right(ivx) = right(ivx) + w(i, j, k+1, ivx)
   right(ivy) = right(ivy) + w(i, j, k+1, ivy)
   right(ivz) = right(ivz) + w(i, j, k+1, ivz)
   right(irhoe) = right(irhoe) + p(i, j, k+1)
   IF (correctfork) THEN
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   right(itu1) = right(itu1) + w(i, j, k+1, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   CALL PUSHREAL8(sx)
   sx = sk(i, j, k, 1)
   CALL PUSHREAL8(sy)
   sy = sk(i, j, k, 2)
   CALL PUSHREAL8(sz)
   sz = sk(i, j, k, 3)
   IF (addgridvelocities) THEN
   CALL PUSHREAL8(sface)
   sface = sfacek(i, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   trefd = 0.0_8
   rgasd = 0.0_8
   fluxd = 0.0_8
   leftd = 0.0_8
   rightd = 0.0_8
   du1d = 0.0_8
   du2d = 0.0_8
   du3d = 0.0_8
   DO k=kl,1,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   fluxd(irhoe) = fluxd(irhoe) - fwd(i, j, k+1, irhoe)
   fluxd(imz) = fluxd(imz) - fwd(i, j, k+1, imz)
   fluxd(imy) = fluxd(imy) - fwd(i, j, k+1, imy)
   fluxd(imx) = fluxd(imx) - fwd(i, j, k+1, imx)
   fluxd(irho) = fluxd(irho) - fwd(i, j, k+1, irho)
   fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
   fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
   fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
   fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
   fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
   por = pork(i, j, k)
   CALL RIEMANNFLUX_B(left, leftd, right, rightd, flux, fluxd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   skd(i, j, k, 3) = skd(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   skd(i, j, k, 2) = skd(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + rightd(itu1)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
   END IF
   pd(i, j, k+1) = pd(i, j, k+1) + rightd(irhoe)
   wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + rightd(ivz)
   wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + rightd(ivy)
   wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + rightd(ivx)
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + rightd(irho)
   pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
   wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
   CALL POPREAL8ARRAY(du1, nw)
   CALL POPREAL8ARRAY(du2, nw)
   CALL POPREAL8ARRAY(du3, nw)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATE_B(du1, du1d, du2, du2d, du3, du3d, &
   &                           rotmatrixk, left, leftd, right, rightd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, j, k+2, itu1) = wd(i, j, k+2, itu1) + du3d(itu1)
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) - du3d(itu1)
   du3d(itu1) = 0.0_8
   wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + du2d(itu1)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - du2d(itu1)
   du2d(itu1) = 0.0_8
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + du1d(itu1)
   wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) - du1d(itu1)
   du1d(itu1) = 0.0_8
   END IF
   pd(i, j, k+2) = pd(i, j, k+2) + du3d(irhoe)
   pd(i, j, k+1) = pd(i, j, k+1) - du3d(irhoe)
   du3d(irhoe) = 0.0_8
   pd(i, j, k+1) = pd(i, j, k+1) + du2d(irhoe)
   pd(i, j, k) = pd(i, j, k) - du2d(irhoe)
   du2d(irhoe) = 0.0_8
   pd(i, j, k) = pd(i, j, k) + du1d(irhoe)
   pd(i, j, k-1) = pd(i, j, k-1) - du1d(irhoe)
   du1d(irhoe) = 0.0_8
   wd(i, j, k+2, ivz) = wd(i, j, k+2, ivz) + du3d(ivz)
   wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) - du3d(ivz)
   du3d(ivz) = 0.0_8
   wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + du2d(ivz)
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - du2d(ivz)
   du2d(ivz) = 0.0_8
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + du1d(ivz)
   wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - du1d(ivz)
   du1d(ivz) = 0.0_8
   wd(i, j, k+2, ivy) = wd(i, j, k+2, ivy) + du3d(ivy)
   wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) - du3d(ivy)
   du3d(ivy) = 0.0_8
   wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + du2d(ivy)
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - du2d(ivy)
   du2d(ivy) = 0.0_8
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + du1d(ivy)
   wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - du1d(ivy)
   du1d(ivy) = 0.0_8
   wd(i, j, k+2, ivx) = wd(i, j, k+2, ivx) + du3d(ivx)
   wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) - du3d(ivx)
   du3d(ivx) = 0.0_8
   wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + du2d(ivx)
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - du2d(ivx)
   du2d(ivx) = 0.0_8
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + du1d(ivx)
   wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - du1d(ivx)
   du1d(ivx) = 0.0_8
   wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + du3d(irho)
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - du3d(irho)
   du3d(irho) = 0.0_8
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + du2d(irho)
   wd(i, j, k, irho) = wd(i, j, k, irho) - du2d(irho)
   du2d(irho) = 0.0_8
   wd(i, j, k, irho) = wd(i, j, k, irho) + du1d(irho)
   wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - du1d(irho)
   du1d(irho) = 0.0_8
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,1,-1
   DO i=il,2,-1
   fluxd(irhoe) = fluxd(irhoe) - fwd(i, j+1, k, irhoe)
   fluxd(imz) = fluxd(imz) - fwd(i, j+1, k, imz)
   fluxd(imy) = fluxd(imy) - fwd(i, j+1, k, imy)
   fluxd(imx) = fluxd(imx) - fwd(i, j+1, k, imx)
   fluxd(irho) = fluxd(irho) - fwd(i, j+1, k, irho)
   fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
   fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
   fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
   fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
   fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
   por = porj(i, j, k)
   CALL RIEMANNFLUX_B(left, leftd, right, rightd, flux, fluxd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + rightd(itu1)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
   END IF
   pd(i, j+1, k) = pd(i, j+1, k) + rightd(irhoe)
   wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + rightd(ivz)
   wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + rightd(ivy)
   wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + rightd(ivx)
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + rightd(irho)
   pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
   wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
   CALL POPREAL8ARRAY(du1, nw)
   CALL POPREAL8ARRAY(du2, nw)
   CALL POPREAL8ARRAY(du3, nw)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATE_B(du1, du1d, du2, du2d, du3, du3d, &
   &                           rotmatrixj, left, leftd, right, rightd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i, j+2, k, itu1) = wd(i, j+2, k, itu1) + du3d(itu1)
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) - du3d(itu1)
   du3d(itu1) = 0.0_8
   wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + du2d(itu1)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - du2d(itu1)
   du2d(itu1) = 0.0_8
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + du1d(itu1)
   wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) - du1d(itu1)
   du1d(itu1) = 0.0_8
   END IF
   pd(i, j+2, k) = pd(i, j+2, k) + du3d(irhoe)
   pd(i, j+1, k) = pd(i, j+1, k) - du3d(irhoe)
   du3d(irhoe) = 0.0_8
   pd(i, j+1, k) = pd(i, j+1, k) + du2d(irhoe)
   pd(i, j, k) = pd(i, j, k) - du2d(irhoe)
   du2d(irhoe) = 0.0_8
   pd(i, j, k) = pd(i, j, k) + du1d(irhoe)
   pd(i, j-1, k) = pd(i, j-1, k) - du1d(irhoe)
   du1d(irhoe) = 0.0_8
   wd(i, j+2, k, ivz) = wd(i, j+2, k, ivz) + du3d(ivz)
   wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) - du3d(ivz)
   du3d(ivz) = 0.0_8
   wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + du2d(ivz)
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - du2d(ivz)
   du2d(ivz) = 0.0_8
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + du1d(ivz)
   wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - du1d(ivz)
   du1d(ivz) = 0.0_8
   wd(i, j+2, k, ivy) = wd(i, j+2, k, ivy) + du3d(ivy)
   wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) - du3d(ivy)
   du3d(ivy) = 0.0_8
   wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + du2d(ivy)
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - du2d(ivy)
   du2d(ivy) = 0.0_8
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + du1d(ivy)
   wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - du1d(ivy)
   du1d(ivy) = 0.0_8
   wd(i, j+2, k, ivx) = wd(i, j+2, k, ivx) + du3d(ivx)
   wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) - du3d(ivx)
   du3d(ivx) = 0.0_8
   wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + du2d(ivx)
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - du2d(ivx)
   du2d(ivx) = 0.0_8
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + du1d(ivx)
   wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - du1d(ivx)
   du1d(ivx) = 0.0_8
   wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + du3d(irho)
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - du3d(irho)
   du3d(irho) = 0.0_8
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + du2d(irho)
   wd(i, j, k, irho) = wd(i, j, k, irho) - du2d(irho)
   du2d(irho) = 0.0_8
   wd(i, j, k, irho) = wd(i, j, k, irho) + du1d(irho)
   wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - du1d(irho)
   du1d(irho) = 0.0_8
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,1,-1
   fluxd(irhoe) = fluxd(irhoe) - fwd(i+1, j, k, irhoe)
   fluxd(imz) = fluxd(imz) - fwd(i+1, j, k, imz)
   fluxd(imy) = fluxd(imy) - fwd(i+1, j, k, imy)
   fluxd(imx) = fluxd(imx) - fwd(i+1, j, k, imx)
   fluxd(irho) = fluxd(irho) - fwd(i+1, j, k, irho)
   fluxd(irhoe) = fluxd(irhoe) + fwd(i, j, k, irhoe)
   fluxd(imz) = fluxd(imz) + fwd(i, j, k, imz)
   fluxd(imy) = fluxd(imy) + fwd(i, j, k, imy)
   fluxd(imx) = fluxd(imx) + fwd(i, j, k, imx)
   fluxd(irho) = fluxd(irho) + fwd(i, j, k, irho)
   gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
   por = pori(i, j, k)
   CALL RIEMANNFLUX_B(left, leftd, right, rightd, flux, fluxd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL POPREAL8(sface)
   CALL POPREAL8(sz)
   sid(i, j, k, 3) = sid(i, j, k, 3) + szd
   CALL POPREAL8(sy)
   sid(i, j, k, 2) = sid(i, j, k, 2) + syd
   CALL POPREAL8(sx)
   sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + rightd(itu1)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + leftd(itu1)
   END IF
   pd(i+1, j, k) = pd(i+1, j, k) + rightd(irhoe)
   wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + rightd(ivz)
   wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + rightd(ivy)
   wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + rightd(ivx)
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + rightd(irho)
   pd(i, j, k) = pd(i, j, k) + leftd(irhoe)
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + leftd(ivz)
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + leftd(ivy)
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + leftd(ivx)
   wd(i, j, k, irho) = wd(i, j, k, irho) + leftd(irho)
   CALL POPREAL8ARRAY(du1, nw)
   CALL POPREAL8ARRAY(du2, nw)
   CALL POPREAL8ARRAY(du3, nw)
   CALL POPREAL8ARRAY(left, nw)
   CALL POPREAL8ARRAY(right, nw)
   CALL LEFTRIGHTSTATE_B(du1, du1d, du2, du2d, du3, du3d, &
   &                           rotmatrixi, left, leftd, right, rightd)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wd(i+2, j, k, itu1) = wd(i+2, j, k, itu1) + du3d(itu1)
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) - du3d(itu1)
   du3d(itu1) = 0.0_8
   wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + du2d(itu1)
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - du2d(itu1)
   du2d(itu1) = 0.0_8
   wd(i, j, k, itu1) = wd(i, j, k, itu1) + du1d(itu1)
   wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) - du1d(itu1)
   du1d(itu1) = 0.0_8
   END IF
   pd(i+2, j, k) = pd(i+2, j, k) + du3d(irhoe)
   pd(i+1, j, k) = pd(i+1, j, k) - du3d(irhoe)
   du3d(irhoe) = 0.0_8
   pd(i+1, j, k) = pd(i+1, j, k) + du2d(irhoe)
   pd(i, j, k) = pd(i, j, k) - du2d(irhoe)
   du2d(irhoe) = 0.0_8
   pd(i, j, k) = pd(i, j, k) + du1d(irhoe)
   pd(i-1, j, k) = pd(i-1, j, k) - du1d(irhoe)
   du1d(irhoe) = 0.0_8
   wd(i+2, j, k, ivz) = wd(i+2, j, k, ivz) + du3d(ivz)
   wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) - du3d(ivz)
   du3d(ivz) = 0.0_8
   wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + du2d(ivz)
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - du2d(ivz)
   du2d(ivz) = 0.0_8
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + du1d(ivz)
   wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - du1d(ivz)
   du1d(ivz) = 0.0_8
   wd(i+2, j, k, ivy) = wd(i+2, j, k, ivy) + du3d(ivy)
   wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) - du3d(ivy)
   du3d(ivy) = 0.0_8
   wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + du2d(ivy)
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - du2d(ivy)
   du2d(ivy) = 0.0_8
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + du1d(ivy)
   wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - du1d(ivy)
   du1d(ivy) = 0.0_8
   wd(i+2, j, k, ivx) = wd(i+2, j, k, ivx) + du3d(ivx)
   wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) - du3d(ivx)
   du3d(ivx) = 0.0_8
   wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + du2d(ivx)
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - du2d(ivx)
   du2d(ivx) = 0.0_8
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + du1d(ivx)
   wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - du1d(ivx)
   du1d(ivx) = 0.0_8
   wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + du3d(irho)
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - du3d(irho)
   du3d(irho) = 0.0_8
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + du2d(irho)
   wd(i, j, k, irho) = wd(i, j, k, irho) - du2d(irho)
   du2d(irho) = 0.0_8
   wd(i, j, k, irho) = wd(i, j, k, irho) + du1d(irho)
   wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - du1d(irho)
   du1d(irho) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   END IF
      CONTAINS
   !  Differentiation of leftrightstate in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: left right du1 du2 du3
   !   with respect to varying inputs: left right du1 du2 du3
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATE_B(du1, du1d, du2, du2d, du3, du3d, rotmatrix&
   &   , left, leftd, right, rightd)
   IMPLICIT NONE
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1d
   REAL(kind=realtype), DIMENSION(:) :: left, right
   REAL(kind=realtype), DIMENSION(:) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(:, :, :, :, :), POINTER :: rotmatrix
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
   REAL(kind=realtype) :: rl1d, rl2d, rr1d, rr2d, tmpd, dvxd, dvyd, &
   &   dvzd
   REAL(kind=realtype), DIMENSION(3, 3) :: rot
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC SIGN
   INTRINSIC MIN
   INTEGER :: branch
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du3d
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du2d
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: x6d
   REAL(kind=realtype) :: y4d
   REAL(kind=realtype) :: max2d
   REAL(kind=realtype) :: max5d
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x5d
   REAL(kind=realtype) :: y3d
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: max4d
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: max7d
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: x4d
   REAL(kind=realtype) :: y2d
   REAL(kind=realtype) :: max3d
   REAL(kind=realtype) :: max7
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max6d
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: x3d
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: y1d
   REAL(kind=realtype) :: temp4
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Check if the velocity components should be transformed to
   ! the cylindrical frame.
   IF (rotationalperiodic) THEN
   ! Store the rotation matrix a bit easier. Note that the i,j,k
   ! come from the main subroutine.
   rot(1, 1) = rotmatrix(i, j, k, 1, 1)
   rot(1, 2) = rotmatrix(i, j, k, 1, 2)
   rot(1, 3) = rotmatrix(i, j, k, 1, 3)
   rot(2, 1) = rotmatrix(i, j, k, 2, 1)
   rot(2, 2) = rotmatrix(i, j, k, 2, 2)
   rot(2, 3) = rotmatrix(i, j, k, 2, 3)
   rot(3, 1) = rotmatrix(i, j, k, 3, 1)
   rot(3, 2) = rotmatrix(i, j, k, 3, 2)
   rot(3, 3) = rotmatrix(i, j, k, 3, 3)
   ! Apply the transformation to the velocity components
   ! of du1, du2 and du3.
   dvx = du1(ivx)
   dvy = du1(ivy)
   dvz = du1(ivz)
   du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du2(ivx)
   dvy = du2(ivy)
   dvz = du2(ivz)
   du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du3(ivx)
   dvy = du3(ivy)
   dvz = du3(ivz)
   du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the limiter used.
   SELECT CASE  (limused) 
   CASE (nolimiter) 
   CALL PUSHCONTROL2B(1)
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1 = du2(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x1 = -du2(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x1 .LT. epslim) THEN
   CALL PUSHREAL8(max2)
   max2 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max2)
   max2 = x1
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   CALL PUSHREAL8(tmp)
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3 = du1(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x3 = -du1(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x3 .LT. epslim) THEN
   CALL PUSHREAL8(max4)
   max4 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max4)
   max4 = x3
   CALL PUSHCONTROL1B(1)
   END IF
   y1 = du2(l)/SIGN(max4, du1(l))
   IF (zero .LT. y1) THEN
   CALL PUSHREAL8(rl1)
   rl1 = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl1)
   rl1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   CALL PUSHREAL8(rl2)
   rl2 = du1(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl2)
   rl2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   CALL PUSHREAL8(rr1)
   rr1 = du3(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr1)
   rr1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4 = du3(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x4 = -du3(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x4 .LT. epslim) THEN
   CALL PUSHREAL8(max5)
   max5 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max5)
   max5 = x4
   CALL PUSHCONTROL1B(1)
   END IF
   y2 = du2(l)/SIGN(max5, du3(l))
   IF (zero .LT. y2) THEN
   CALL PUSHREAL8(rr2)
   rr2 = y2
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr2)
   rr2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the corresponding limiter values.
   CALL PUSHREAL8(rl1)
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   CALL PUSHREAL8(rl2)
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   CALL PUSHREAL8(rr1)
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   CALL PUSHREAL8(rr2)
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   END DO
   CALL PUSHCONTROL2B(2)
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2 = du2(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x2 = -du2(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x2 .LT. epslim) THEN
   CALL PUSHREAL8(max3)
   max3 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max3)
   max3 = x2
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   CALL PUSHREAL8(tmp)
   tmp = one/SIGN(max3, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5 = du1(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x5 = -du1(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x5 .LT. epslim) THEN
   CALL PUSHREAL8(max6)
   max6 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max6)
   max6 = x5
   CALL PUSHCONTROL1B(1)
   END IF
   y3 = du2(l)/SIGN(max6, du1(l))
   IF (zero .LT. y3) THEN
   CALL PUSHREAL8(rl1)
   rl1 = y3
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl1)
   rl1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   CALL PUSHREAL8(rl2)
   rl2 = du1(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rl2)
   rl2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   CALL PUSHREAL8(rr1)
   rr1 = du3(l)*tmp
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr1)
   rr1 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6 = du3(l)
   CALL PUSHCONTROL1B(0)
   ELSE
   x6 = -du3(l)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (x6 .LT. epslim) THEN
   CALL PUSHREAL8(max7)
   max7 = epslim
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max7)
   max7 = x6
   CALL PUSHCONTROL1B(1)
   END IF
   y4 = du2(l)/SIGN(max7, du3(l))
   IF (zero .LT. y4) THEN
   CALL PUSHREAL8(rr2)
   rr2 = y4
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(rr2)
   rr2 = zero
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1 = factminmod*rl1
   CALL PUSHCONTROL1B(0)
   ELSE
   rl1 = one
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2 = factminmod*rl2
   CALL PUSHCONTROL1B(0)
   ELSE
   rl2 = one
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1 = factminmod*rr1
   CALL PUSHCONTROL1B(0)
   ELSE
   rr1 = one
   CALL PUSHCONTROL1B(1)
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2 = factminmod*rr2
   CALL PUSHCONTROL1B(0)
   ELSE
   rr2 = one
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   CALL PUSHCONTROL2B(3)
   CASE DEFAULT
   CALL PUSHCONTROL2B(0)
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! For rotational periodic problems transform the velocity
   ! differences back to Cartesian again. Note that now the
   ! transpose of the rotation matrix must be used.
   IF (rotationalperiodic) THEN
   dvxd = rot(1, 3)*rightd(ivz)
   dvyd = rot(2, 3)*rightd(ivz)
   dvzd = rot(3, 3)*rightd(ivz)
   rightd(ivz) = 0.0_8
   dvxd = dvxd + rot(1, 2)*rightd(ivy)
   dvyd = dvyd + rot(2, 2)*rightd(ivy)
   dvzd = dvzd + rot(3, 2)*rightd(ivy)
   rightd(ivy) = 0.0_8
   dvxd = dvxd + rot(1, 1)*rightd(ivx)
   dvyd = dvyd + rot(2, 1)*rightd(ivx)
   dvzd = dvzd + rot(3, 1)*rightd(ivx)
   rightd(ivx) = 0.0_8
   rightd(ivz) = rightd(ivz) + dvzd
   rightd(ivy) = rightd(ivy) + dvyd
   rightd(ivx) = rightd(ivx) + dvxd
   dvxd = rot(1, 3)*leftd(ivz)
   dvyd = rot(2, 3)*leftd(ivz)
   dvzd = rot(3, 3)*leftd(ivz)
   leftd(ivz) = 0.0_8
   dvxd = dvxd + rot(1, 2)*leftd(ivy)
   dvyd = dvyd + rot(2, 2)*leftd(ivy)
   dvzd = dvzd + rot(3, 2)*leftd(ivy)
   leftd(ivy) = 0.0_8
   dvxd = dvxd + rot(1, 1)*leftd(ivx)
   dvyd = dvyd + rot(2, 1)*leftd(ivx)
   dvzd = dvzd + rot(3, 1)*leftd(ivx)
   leftd(ivx) = 0.0_8
   leftd(ivz) = leftd(ivz) + dvzd
   leftd(ivy) = leftd(ivy) + dvyd
   leftd(ivx) = leftd(ivx) + dvxd
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rightd(itu1) = 0.0_8
   leftd(itu1) = 0.0_8
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .NE. 0) THEN
   DO l=nwint,1,-1
   du3d(l) = du3d(l) - omk*rightd(l)
   du2d(l) = du2d(l) + opk*leftd(l) - opk*rightd(l)
   rightd(l) = 0.0_8
   du1d(l) = du1d(l) + omk*leftd(l)
   leftd(l) = 0.0_8
   END DO
   END IF
   ELSE IF (branch .EQ. 2) THEN
   DO l=nwint,1,-1
   rr1d = -(opk*du2(l)*rightd(l))
   du2d(l) = du2d(l) + opk*rl2*leftd(l) - opk*rr1*rightd(l)
   rr2d = -(omk*du3(l)*rightd(l))
   du3d(l) = du3d(l) - omk*rr2*rightd(l)
   rightd(l) = 0.0_8
   rl1d = omk*du1(l)*leftd(l)
   du1d(l) = du1d(l) + omk*rl1*leftd(l)
   rl2d = opk*du2(l)*leftd(l)
   leftd(l) = 0.0_8
   CALL POPREAL8(rr2)
   tempd2 = rr2d/(one+rr2**2)
   rr2d = (2*rr2-rr2**2*(one+rr2)*2/(one+rr2**2)+one)*tempd2
   CALL POPREAL8(rr1)
   tempd3 = rr1d/(one+rr1**2)
   rr1d = (2*rr1-rr1**2*(one+rr1)*2/(one+rr1**2)+one)*tempd3
   CALL POPREAL8(rl2)
   tempd4 = rl2d/(one+rl2**2)
   rl2d = (2*rl2-rl2**2*(one+rl2)*2/(one+rl2**2)+one)*tempd4
   CALL POPREAL8(rl1)
   tempd5 = rl1d/(one+rl1**2)
   rl1d = (2*rl1-rl1**2*(one+rl1)*2/(one+rl1**2)+one)*tempd5
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr2)
   y2d = rr2d
   ELSE
   CALL POPREAL8(rr2)
   y2d = 0.0_8
   END IF
   temp1 = SIGN(max5, du3(l))
   tempd1 = -(du2(l)*y2d/temp1**2)
   du2d(l) = du2d(l) + y2d/temp1
   max5d = SIGN(1.d0, max5*du3(l))*tempd1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max5)
   x4d = 0.0_8
   ELSE
   CALL POPREAL8(max5)
   x4d = max5d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du3d(l) = du3d(l) + x4d
   ELSE
   du3d(l) = du3d(l) - x4d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr1)
   du3d(l) = du3d(l) + tmp*rr1d
   tmpd = du3(l)*rr1d
   ELSE
   CALL POPREAL8(rr1)
   tmpd = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl2)
   du1d(l) = du1d(l) + tmp*rl2d
   tmpd = tmpd + du1(l)*rl2d
   ELSE
   CALL POPREAL8(rl2)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl1)
   y1d = rl1d
   ELSE
   CALL POPREAL8(rl1)
   y1d = 0.0_8
   END IF
   temp0 = SIGN(max4, du1(l))
   tempd0 = -(du2(l)*y1d/temp0**2)
   du2d(l) = du2d(l) + y1d/temp0
   max4d = SIGN(1.d0, max4*du1(l))*tempd0
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max4)
   x3d = 0.0_8
   ELSE
   CALL POPREAL8(max4)
   x3d = max4d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du1d(l) = du1d(l) + x3d
   ELSE
   du1d(l) = du1d(l) - x3d
   END IF
   CALL POPREAL8(tmp)
   temp = SIGN(max2, du2(l))
   tempd = -(one*tmpd/temp**2)
   max2d = SIGN(1.d0, max2*du2(l))*tempd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max2)
   x1d = 0.0_8
   ELSE
   CALL POPREAL8(max2)
   x1d = max2d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du2d(l) = du2d(l) + x1d
   ELSE
   du2d(l) = du2d(l) - x1d
   END IF
   END DO
   ELSE
   DO l=nwint,1,-1
   rr1d = -(opk*du2(l)*rightd(l))
   du2d(l) = du2d(l) + opk*rl2*leftd(l) - opk*rr1*rightd(l)
   rr2d = -(omk*du3(l)*rightd(l))
   du3d(l) = du3d(l) - omk*rr2*rightd(l)
   rightd(l) = 0.0_8
   rl1d = omk*du1(l)*leftd(l)
   du1d(l) = du1d(l) + omk*rl1*leftd(l)
   rl2d = opk*du2(l)*leftd(l)
   leftd(l) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rr2d = factminmod*rr2d
   ELSE
   rr2d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rr1d = factminmod*rr1d
   ELSE
   rr1d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rl2d = factminmod*rl2d
   ELSE
   rl2d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rl1d = factminmod*rl1d
   ELSE
   rl1d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr2)
   y4d = rr2d
   ELSE
   CALL POPREAL8(rr2)
   y4d = 0.0_8
   END IF
   temp4 = SIGN(max7, du3(l))
   tempd8 = -(du2(l)*y4d/temp4**2)
   du2d(l) = du2d(l) + y4d/temp4
   max7d = SIGN(1.d0, max7*du3(l))*tempd8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max7)
   x6d = 0.0_8
   ELSE
   CALL POPREAL8(max7)
   x6d = max7d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du3d(l) = du3d(l) + x6d
   ELSE
   du3d(l) = du3d(l) - x6d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rr1)
   du3d(l) = du3d(l) + tmp*rr1d
   tmpd = du3(l)*rr1d
   ELSE
   CALL POPREAL8(rr1)
   tmpd = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl2)
   du1d(l) = du1d(l) + tmp*rl2d
   tmpd = tmpd + du1(l)*rl2d
   ELSE
   CALL POPREAL8(rl2)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(rl1)
   y3d = rl1d
   ELSE
   CALL POPREAL8(rl1)
   y3d = 0.0_8
   END IF
   temp3 = SIGN(max6, du1(l))
   tempd7 = -(du2(l)*y3d/temp3**2)
   du2d(l) = du2d(l) + y3d/temp3
   max6d = SIGN(1.d0, max6*du1(l))*tempd7
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max6)
   x5d = 0.0_8
   ELSE
   CALL POPREAL8(max6)
   x5d = max6d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du1d(l) = du1d(l) + x5d
   ELSE
   du1d(l) = du1d(l) - x5d
   END IF
   CALL POPREAL8(tmp)
   temp2 = SIGN(max3, du2(l))
   tempd6 = -(one*tmpd/temp2**2)
   max3d = SIGN(1.d0, max3*du2(l))*tempd6
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max3)
   x2d = 0.0_8
   ELSE
   CALL POPREAL8(max3)
   x2d = max3d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   du2d(l) = du2d(l) + x2d
   ELSE
   du2d(l) = du2d(l) - x2d
   END IF
   END DO
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dvxd = rot(3, 1)*du3d(ivz)
   dvyd = rot(3, 2)*du3d(ivz)
   dvzd = rot(3, 3)*du3d(ivz)
   du3d(ivz) = 0.0_8
   dvxd = dvxd + rot(2, 1)*du3d(ivy)
   dvyd = dvyd + rot(2, 2)*du3d(ivy)
   dvzd = dvzd + rot(2, 3)*du3d(ivy)
   du3d(ivy) = 0.0_8
   dvxd = dvxd + rot(1, 1)*du3d(ivx)
   dvyd = dvyd + rot(1, 2)*du3d(ivx)
   dvzd = dvzd + rot(1, 3)*du3d(ivx)
   du3d(ivx) = 0.0_8
   du3d(ivz) = du3d(ivz) + dvzd
   du3d(ivy) = du3d(ivy) + dvyd
   du3d(ivx) = du3d(ivx) + dvxd
   dvxd = rot(3, 1)*du2d(ivz)
   dvyd = rot(3, 2)*du2d(ivz)
   dvzd = rot(3, 3)*du2d(ivz)
   du2d(ivz) = 0.0_8
   dvxd = dvxd + rot(2, 1)*du2d(ivy)
   dvyd = dvyd + rot(2, 2)*du2d(ivy)
   dvzd = dvzd + rot(2, 3)*du2d(ivy)
   du2d(ivy) = 0.0_8
   dvxd = dvxd + rot(1, 1)*du2d(ivx)
   dvyd = dvyd + rot(1, 2)*du2d(ivx)
   dvzd = dvzd + rot(1, 3)*du2d(ivx)
   du2d(ivx) = 0.0_8
   du2d(ivz) = du2d(ivz) + dvzd
   du2d(ivy) = du2d(ivy) + dvyd
   du2d(ivx) = du2d(ivx) + dvxd
   dvxd = rot(3, 1)*du1d(ivz)
   dvyd = rot(3, 2)*du1d(ivz)
   dvzd = rot(3, 3)*du1d(ivz)
   du1d(ivz) = 0.0_8
   dvxd = dvxd + rot(2, 1)*du1d(ivy)
   dvyd = dvyd + rot(2, 2)*du1d(ivy)
   dvzd = dvzd + rot(2, 3)*du1d(ivy)
   du1d(ivy) = 0.0_8
   dvxd = dvxd + rot(1, 1)*du1d(ivx)
   dvyd = dvyd + rot(1, 2)*du1d(ivx)
   dvzd = dvzd + rot(1, 3)*du1d(ivx)
   du1d(ivx) = 0.0_8
   du1d(ivz) = du1d(ivz) + dvzd
   du1d(ivy) = du1d(ivy) + dvyd
   du1d(ivx) = du1d(ivx) + dvxd
   END IF
   END SUBROUTINE LEFTRIGHTSTATE_B
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATE(du1, du2, du3, rotmatrix, left, right)
   IMPLICIT NONE
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(:), INTENT(OUT) :: left, right
   REAL(kind=realtype), DIMENSION(:, :, :, :, :), POINTER :: rotmatrix
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
   REAL(kind=realtype), DIMENSION(3, 3) :: rot
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC SIGN
   INTRINSIC MIN
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: max7
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: y1
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Check if the velocity components should be transformed to
   ! the cylindrical frame.
   IF (rotationalperiodic) THEN
   ! Store the rotation matrix a bit easier. Note that the i,j,k
   ! come from the main subroutine.
   rot(1, 1) = rotmatrix(i, j, k, 1, 1)
   rot(1, 2) = rotmatrix(i, j, k, 1, 2)
   rot(1, 3) = rotmatrix(i, j, k, 1, 3)
   rot(2, 1) = rotmatrix(i, j, k, 2, 1)
   rot(2, 2) = rotmatrix(i, j, k, 2, 2)
   rot(2, 3) = rotmatrix(i, j, k, 2, 3)
   rot(3, 1) = rotmatrix(i, j, k, 3, 1)
   rot(3, 2) = rotmatrix(i, j, k, 3, 2)
   rot(3, 3) = rotmatrix(i, j, k, 3, 3)
   ! Apply the transformation to the velocity components
   ! of du1, du2 and du3.
   dvx = du1(ivx)
   dvy = du1(ivy)
   dvz = du1(ivz)
   du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du2(ivx)
   dvy = du2(ivy)
   dvz = du2(ivz)
   du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du3(ivx)
   dvy = du3(ivy)
   dvz = du3(ivz)
   du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   END IF
   ! Determine the limiter used.
   SELECT CASE  (limused) 
   CASE (nolimiter) 
   ! Linear interpolation; no limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   left(l) = omk*du1(l) + opk*du2(l)
   right(l) = -(omk*du3(l)) - opk*du2(l)
   END DO
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1 = du2(l)
   ELSE
   x1 = -du2(l)
   END IF
   IF (x1 .LT. epslim) THEN
   max2 = epslim
   ELSE
   max2 = x1
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3 = du1(l)
   ELSE
   x3 = -du1(l)
   END IF
   IF (x3 .LT. epslim) THEN
   max4 = epslim
   ELSE
   max4 = x3
   END IF
   y1 = du2(l)/SIGN(max4, du1(l))
   IF (zero .LT. y1) THEN
   rl1 = y1
   ELSE
   rl1 = zero
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4 = du3(l)
   ELSE
   x4 = -du3(l)
   END IF
   IF (x4 .LT. epslim) THEN
   max5 = epslim
   ELSE
   max5 = x4
   END IF
   y2 = du2(l)/SIGN(max5, du3(l))
   IF (zero .LT. y2) THEN
   rr2 = y2
   ELSE
   rr2 = zero
   END IF
   ! Compute the corresponding limiter values.
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2 = du2(l)
   ELSE
   x2 = -du2(l)
   END IF
   IF (x2 .LT. epslim) THEN
   max3 = epslim
   ELSE
   max3 = x2
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max3, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5 = du1(l)
   ELSE
   x5 = -du1(l)
   END IF
   IF (x5 .LT. epslim) THEN
   max6 = epslim
   ELSE
   max6 = x5
   END IF
   y3 = du2(l)/SIGN(max6, du1(l))
   IF (zero .LT. y3) THEN
   rl1 = y3
   ELSE
   rl1 = zero
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6 = du3(l)
   ELSE
   x6 = -du3(l)
   END IF
   IF (x6 .LT. epslim) THEN
   max7 = epslim
   ELSE
   max7 = x6
   END IF
   y4 = du2(l)/SIGN(max7, du3(l))
   IF (zero .LT. y4) THEN
   rr2 = y4
   ELSE
   rr2 = zero
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1 = factminmod*rl1
   ELSE
   rl1 = one
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2 = factminmod*rl2
   ELSE
   rl2 = one
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1 = factminmod*rr1
   ELSE
   rr1 = one
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2 = factminmod*rr2
   ELSE
   rr2 = one
   END IF
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   left(itu1) = zero
   right(itu1) = zero
   END IF
   ! For rotational periodic problems transform the velocity
   ! differences back to Cartesian again. Note that now the
   ! transpose of the rotation matrix must be used.
   IF (rotationalperiodic) THEN
   ! Left state.
   dvx = left(ivx)
   dvy = left(ivy)
   dvz = left(ivz)
   left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   ! Right state.
   dvx = right(ivx)
   dvy = right(ivy)
   dvz = right(ivz)
   right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   END IF
   END SUBROUTINE LEFTRIGHTSTATE
   !  Differentiation of riemannflux in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: tref rgas flux left right
   !   with respect to varying inputs: tref rgas sx sy sz flux left
   !                right
   !        ================================================================
   SUBROUTINE RIEMANNFLUX_B(left, leftd, right, rightd, flux, fluxd)
   IMPLICIT NONE
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(*) :: flux
   REAL(kind=realtype), DIMENSION(*) :: fluxd
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: rfaced
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: etld, etrd, z1ld, z1rd, tmpd
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: uavgd, vavgd, wavgd, havgd, kavgd
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: alphaavgd, a2avgd, aavgd, unavgd
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: ovaavgd, ova2avgd, aread, etad
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: lam1d, lam2d, lam3d
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
   &   abv7d
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: rhotmpd, utmpd, vtmpd, wtmpd
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   REAL(kind=realtype), DIMENSION(2) :: ptmpd, ktmpd, etmpd
   INTRINSIC SQRT
   INTRINSIC MAX
   INTRINSIC ABS
   INTEGER :: branch
   REAL(kind=realtype) :: tempd14
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: tempd13
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: tempd12
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd11
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: abs1d
   REAL(kind=realtype) :: max2d
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs2d
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: tempd19
   REAL(kind=realtype) :: tempd18
   REAL(kind=realtype) :: tempd17
   REAL(kind=realtype) :: tempd16
   REAL(kind=realtype) :: tempd15
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Abbreviate some expressions in which gamma occurs.
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   z1l = SQRT(left(irho))
   z1r = SQRT(right(irho))
   tmp = one/(z1l+z1r)
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmp(1) = left(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   END IF
   ! Compute the total energy of the left and right state.
   rhotmp(1) = left(irho)
   rhotmp(2) = right(irho)
   utmp(1) = left(ivx)
   utmp(2) = right(ivx)
   vtmp(1) = left(ivy)
   vtmp(2) = right(ivy)
   wtmp(1) = left(ivz)
   wtmp(2) = right(ivz)
   ptmp(1) = left(irhoe)
   ptmp(2) = right(irhoe)
   CALL PUSHREAL8ARRAY(etmp, 2)
   CALL ETOTARRAY(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
   &                   correctfork, 2)
   etl = etmp(1)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   dr = right(irho) - left(irho)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   max2 = area
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   max2 = 1.e-25_realType
   END IF
   tmp = one/max2
   CALL PUSHREAL8(sx)
   sx = sx*tmp
   CALL PUSHREAL8(sy)
   sy = sy*tmp
   CALL PUSHREAL8(sz)
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   CALL PUSHCONTROL1B(0)
   ELSE
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   CALL PUSHCONTROL1B(1)
   END IF
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ovaavg = one/aavg
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) THEN
   unavg = rface
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
   &         left(ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1 = x1
   CALL PUSHCONTROL1B(1)
   ELSE
   abs1 = -x1
   CALL PUSHCONTROL1B(0)
   END IF
   x2 = SQRT(gammaface*left(irhoe)/left(irho)) - SQRT(gammaface*&
   &         right(irhoe)/right(irho))
   IF (x2 .GE. 0.) THEN
   abs2 = x2
   CALL PUSHCONTROL1B(0)
   ELSE
   abs2 = -x2
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1 = unavg - rface + aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam1 = -(unavg-rface+aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2 = unavg - rface - aavg
   CALL PUSHCONTROL1B(0)
   ELSE
   lam2 = -(unavg-rface-aavg)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3 = unavg - rface
   CALL PUSHCONTROL1B(0)
   ELSE
   lam3 = -(unavg-rface)
   CALL PUSHCONTROL1B(1)
   END IF
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) THEN
   CALL PUSHREAL8(lam1)
   lam1 = eta + fourth*lam1*lam1/eta
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (lam2 .LT. tmp) THEN
   CALL PUSHREAL8(lam2)
   lam2 = eta + fourth*lam2*lam2/eta
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (lam3 .LT. tmp) THEN
   CALL PUSHREAL8(lam3)
   lam3 = eta + fourth*lam3*lam3/eta
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   CALL PUSHREAL8(lam1)
   lam1 = lam1*area
   CALL PUSHREAL8(lam2)
   lam2 = lam2*area
   CALL PUSHREAL8(lam3)
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   abv2 = half*(lam1-lam2)
   abv3 = abv1 - lam3
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
   &         drk
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   tempd14 = -(porflux*fluxd(irhoe))
   havgd = abv6*tempd14
   fluxd(irhoe) = 0.0_8
   tempd15 = -(porflux*fluxd(imz))
   fluxd(imz) = 0.0_8
   tempd18 = -(porflux*fluxd(imy))
   fluxd(imy) = 0.0_8
   tempd16 = -(porflux*fluxd(imx))
   abv7d = sz*tempd15 + sx*tempd16 + sy*tempd18 + unavg*tempd14
   fluxd(imx) = 0.0_8
   tempd17 = -(porflux*fluxd(irho))
   abv6d = wavg*tempd15 + uavg*tempd16 + tempd17 + vavg*tempd18 + &
   &         havg*tempd14
   fluxd(irho) = 0.0_8
   abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
   abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
   ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
   abv3d = ova2avg*abv4*abv6d + abv5*abv7d
   lam3d = drw*tempd15 + dru*tempd16 - abv3d + dr*tempd17 + drv*&
   &         tempd18 + dre*tempd14
   abv5d = ovaavg*abv2*abv6d + abv3*abv7d
   unavgd = abv7*tempd14 - dr*abv5d
   szd = drw*abv5d + abv7*tempd15
   syd = drv*abv5d + abv7*tempd18
   sxd = dru*abv5d + abv7*tempd16
   ova2avgd = abv3*abv4*abv6d
   tempd19 = gm1*abv4d
   dred = tempd19 + lam3*tempd14
   drwd = sz*abv5d - wavg*tempd19 + lam3*tempd15
   wavgd = abv6*tempd15 - drw*tempd19
   drvd = sy*abv5d - vavg*tempd19 + lam3*tempd18
   vavgd = abv6*tempd18 - drv*tempd19
   drud = sx*abv5d - uavg*tempd19 + lam3*tempd16
   uavgd = abv6*tempd16 - dru*tempd19
   drd = alphaavg*tempd19 - unavg*abv5d + lam3*tempd17
   alphaavgd = dr*tempd19
   drkd = -(gm53*abv4d)
   abv1d = abv3d
   lam1d = half*abv1d + half*abv2d
   lam2d = half*abv1d - half*abv2d
   CALL POPREAL8(lam3)
   CALL POPREAL8(lam2)
   CALL POPREAL8(lam1)
   aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
   lam3d = area*lam3d
   lam2d = area*lam2d
   lam1d = area*lam1d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam3)
   tempd13 = fourth*lam3d/eta
   etad = lam3d - lam3**2*tempd13/eta
   lam3d = 2*lam3*tempd13
   ELSE
   etad = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam2)
   tempd12 = fourth*lam2d/eta
   etad = etad + lam2d - lam2**2*tempd12/eta
   lam2d = 2*lam2*tempd12
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(lam1)
   tempd11 = fourth*lam1d/eta
   etad = etad + lam1d - lam1**2*tempd11/eta
   lam1d = 2*lam1*tempd11
   END IF
   tmp = one/max2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam3d
   rfaced = -lam3d
   ELSE
   rfaced = lam3d
   unavgd = unavgd - lam3d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam2d
   rfaced = rfaced - lam2d
   aavgd = -lam2d
   ELSE
   rfaced = rfaced + lam2d
   unavgd = unavgd - lam2d
   aavgd = lam2d
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   unavgd = unavgd + lam1d
   rfaced = rfaced - lam1d
   aavgd = aavgd + lam1d
   ELSE
   rfaced = rfaced + lam1d
   unavgd = unavgd - lam1d
   aavgd = aavgd - lam1d
   END IF
   abs1d = half*etad
   abs2d = half*etad
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x2d = abs2d
   ELSE
   x2d = -abs2d
   END IF
   temp1 = left(irhoe)/left(irho)
   IF (gammaface*temp1 .EQ. 0.0_8) THEN
   tempd9 = 0.0
   ELSE
   tempd9 = gammaface*x2d/(2.0*SQRT(gammaface*temp1)*left(irho))
   END IF
   temp2 = right(irhoe)/right(irho)
   IF (gammaface*temp2 .EQ. 0.0_8) THEN
   tempd10 = 0.0
   ELSE
   tempd10 = -(gammaface*x2d/(2.0*SQRT(gammaface*temp2)*right(&
   &           irho)))
   END IF
   leftd(irhoe) = leftd(irhoe) + tempd9
   leftd(irho) = leftd(irho) - temp1*tempd9
   rightd(irhoe) = rightd(irhoe) + tempd10
   rightd(irho) = rightd(irho) - temp2*tempd10
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x1d = -abs1d
   ELSE
   x1d = abs1d
   END IF
   leftd(ivx) = leftd(ivx) + sx*x1d
   rightd(ivx) = rightd(ivx) - sx*x1d
   sxd = sxd + (left(ivx)-right(ivx))*x1d
   leftd(ivy) = leftd(ivy) + sy*x1d
   rightd(ivy) = rightd(ivy) - sy*x1d
   syd = syd + (left(ivy)-right(ivy))*x1d
   leftd(ivz) = leftd(ivz) + sz*x1d
   rightd(ivz) = rightd(ivz) - sz*x1d
   szd = szd + (left(ivz)-right(ivz))*x1d
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   rfaced = rfaced + unavgd
   unavgd = 0.0_8
   END IF
   aavgd = aavgd - one*ovaavgd/aavg**2
   IF (a2avg .EQ. 0.0_8) THEN
   a2avgd = -(one*ova2avgd/a2avg**2)
   ELSE
   a2avgd = aavgd/(2.0*SQRT(a2avg)) - one*ova2avgd/a2avg**2
   END IF
   uavgd = uavgd + sx*unavgd
   sxd = sxd + uavg*unavgd
   vavgd = vavgd + sy*unavgd
   syd = syd + vavg*unavgd
   wavgd = wavgd + sz*unavgd
   szd = szd + wavg*unavgd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   havgd = havgd + gm1*a2avgd
   alphaavgd = alphaavgd - gm1*a2avgd
   kavgd = -(gm53*a2avgd)
   ELSE
   kavgd = gm53*a2avgd
   havgd = havgd - gm1*a2avgd
   alphaavgd = alphaavgd + gm1*a2avgd
   END IF
   CALL POPREAL8(sz)
   CALL POPREAL8(sy)
   CALL POPREAL8(sx)
   tempd8 = half*alphaavgd
   uavgd = uavgd + 2*uavg*tempd8
   vavgd = vavgd + 2*vavg*tempd8
   wavgd = wavgd + 2*wavg*tempd8
   tmpd = sz*szd + sx*sxd + sy*syd + sface*rfaced
   szd = tmp*szd
   syd = tmp*syd
   sxd = tmp*sxd
   max2d = -(one*tmpd/max2**2)
   tmp = one/(z1l+z1r)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) aread = aread + max2d
   tempd6 = tmp*uavgd
   tempd7 = tmp*vavgd
   tempd5 = tmp*wavgd
   IF (sx**2 + sy**2 + sz**2 .EQ. 0.0_8) THEN
   tempd1 = 0.0
   ELSE
   tempd1 = aread/(2.0*SQRT(sx**2+sy**2+sz**2))
   END IF
   sxd = sxd + 2*sx*tempd1
   syd = syd + 2*sy*tempd1
   szd = szd + 2*sz*tempd1
   temp0 = (etr+right(irhoe))/z1r
   temp = (etl+left(irhoe))/z1l
   tempd2 = tmp*havgd
   tempd3 = tempd2/z1l
   tempd4 = tempd2/z1r
   tmpd = (z1l*left(ivz)+z1r*right(ivz))*wavgd + (z1l*left(ivx)+z1r&
   &         *right(ivx))*uavgd + (z1l*left(ivy)+z1r*right(ivy))*vavgd + (&
   &         temp+temp0)*havgd
   etld = tempd3 - dred
   leftd(irhoe) = leftd(irhoe) + tempd3
   z1ld = left(ivz)*tempd5 + left(ivx)*tempd6 + left(ivy)*tempd7 - &
   &         temp*tempd3
   etrd = dred + tempd4
   rightd(irhoe) = rightd(irhoe) + tempd4
   z1rd = right(ivz)*tempd5 + right(ivx)*tempd6 + right(ivy)*tempd7&
   &         - temp0*tempd4
   leftd(ivz) = leftd(ivz) + z1l*tempd5
   rightd(ivz) = rightd(ivz) + z1r*tempd5
   leftd(ivy) = leftd(ivy) + z1l*tempd7
   rightd(ivy) = rightd(ivy) + z1r*tempd7
   leftd(ivx) = leftd(ivx) + z1l*tempd6
   rightd(ivx) = rightd(ivx) + z1r*tempd6
   rightd(irho) = rightd(irho) + right(ivz)*drwd
   rightd(ivz) = rightd(ivz) + right(irho)*drwd
   leftd(irho) = leftd(irho) - left(ivz)*drwd
   leftd(ivz) = leftd(ivz) - left(irho)*drwd
   rightd(irho) = rightd(irho) + right(ivy)*drvd
   rightd(ivy) = rightd(ivy) + right(irho)*drvd
   leftd(irho) = leftd(irho) - left(ivy)*drvd
   leftd(ivy) = leftd(ivy) - left(irho)*drvd
   rightd(irho) = rightd(irho) + right(ivx)*drud
   rightd(ivx) = rightd(ivx) + right(irho)*drud
   leftd(irho) = leftd(irho) - left(ivx)*drud
   leftd(ivx) = leftd(ivx) - left(irho)*drud
   rightd(irho) = rightd(irho) + drd
   leftd(irho) = leftd(irho) - drd
   etmpd = 0.0_8
   etmpd(2) = etmpd(2) + etrd
   etmpd(1) = etmpd(1) + etld
   CALL POPREAL8ARRAY(etmp, 2)
   rhotmpd = 0.0_8
   ptmpd = 0.0_8
   CALL ETOTARRAY_B(rhotmp, rhotmpd, utmp, utmpd, vtmp, vtmpd, wtmp&
   &                  , wtmpd, ptmp, ptmpd, ktmp, ktmpd, etmp, etmpd, &
   &                  correctfork, 2)
   rightd(irhoe) = rightd(irhoe) + ptmpd(2)
   ptmpd(2) = 0.0_8
   leftd(irhoe) = leftd(irhoe) + ptmpd(1)
   rightd(ivz) = rightd(ivz) + wtmpd(2)
   wtmpd(2) = 0.0_8
   leftd(ivz) = leftd(ivz) + wtmpd(1)
   rightd(ivy) = rightd(ivy) + vtmpd(2)
   vtmpd(2) = 0.0_8
   leftd(ivy) = leftd(ivy) + vtmpd(1)
   rightd(ivx) = rightd(ivx) + utmpd(2)
   utmpd(2) = 0.0_8
   leftd(ivx) = leftd(ivx) + utmpd(1)
   rightd(irho) = rightd(irho) + rhotmpd(2)
   rhotmpd(2) = 0.0_8
   leftd(irho) = leftd(irho) + rhotmpd(1)
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tempd0 = tmp*kavgd
   tmpd = tmpd + (z1l*left(itu1)+z1r*right(itu1))*kavgd
   z1ld = z1ld + left(itu1)*tempd0
   leftd(itu1) = leftd(itu1) + z1l*tempd0
   z1rd = z1rd + right(itu1)*tempd0
   rightd(itu1) = rightd(itu1) + z1r*tempd0
   rightd(irho) = rightd(irho) + right(itu1)*drkd
   rightd(itu1) = rightd(itu1) + ktmpd(2) + right(irho)*drkd
   leftd(irho) = leftd(irho) - left(itu1)*drkd
   ktmpd(2) = 0.0_8
   leftd(itu1) = leftd(itu1) + ktmpd(1) - left(irho)*drkd
   END IF
   tempd = -(one*tmpd/(z1l+z1r)**2)
   z1ld = z1ld + tempd
   z1rd = z1rd + tempd
   IF (.NOT.right(irho) .EQ. 0.0_8) rightd(irho) = rightd(irho) + &
   &           z1rd/(2.0*SQRT(right(irho)))
   IF (.NOT.left(irho) .EQ. 0.0_8) leftd(irho) = leftd(irho) + z1ld&
   &           /(2.0*SQRT(left(irho)))
   CASE (turkel) 
   sxd = 0.0_8
   syd = 0.0_8
   szd = 0.0_8
   CASE (choimerkle) 
   sxd = 0.0_8
   syd = 0.0_8
   szd = 0.0_8
   CASE DEFAULT
   sxd = 0.0_8
   syd = 0.0_8
   szd = 0.0_8
   END SELECT
   CASE (vanleer) 
   sxd = 0.0_8
   syd = 0.0_8
   szd = 0.0_8
   CASE (ausmdv) 
   sxd = 0.0_8
   syd = 0.0_8
   szd = 0.0_8
   CASE DEFAULT
   sxd = 0.0_8
   syd = 0.0_8
   szd = 0.0_8
   END SELECT
   END SUBROUTINE RIEMANNFLUX_B
   !        ================================================================
   SUBROUTINE RIEMANNFLUX(left, right, flux)
   IMPLICIT NONE
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: flux
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   INTRINSIC SQRT
   INTRINSIC MAX
   INTRINSIC ABS
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: max2
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Abbreviate some expressions in which gamma occurs.
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   z1l = SQRT(left(irho))
   z1r = SQRT(right(irho))
   tmp = one/(z1l+z1r)
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmp(1) = left(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   ELSE
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   END IF
   ! Compute the total energy of the left and right state.
   rhotmp(1) = left(irho)
   rhotmp(2) = right(irho)
   utmp(1) = left(ivx)
   utmp(2) = right(ivx)
   vtmp(1) = left(ivy)
   vtmp(2) = right(ivy)
   wtmp(1) = left(ivz)
   wtmp(2) = right(ivz)
   ptmp(1) = left(irhoe)
   ptmp(2) = right(irhoe)
   CALL ETOTARRAY(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
   &                   correctfork, 2)
   etl = etmp(1)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   dr = right(irho) - left(irho)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   ravg = fourth*(z1r+z1l)**2
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   area = SQRT(sx**2 + sy**2 + sz**2)
   IF (1.e-25_realType .LT. area) THEN
   max2 = area
   ELSE
   max2 = 1.e-25_realType
   END IF
   tmp = one/max2
   sx = sx*tmp
   sy = sy*tmp
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   ELSE
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   END IF
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ovaavg = one/aavg
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) unavg = rface
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
   &         left(ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1 = x1
   ELSE
   abs1 = -x1
   END IF
   x2 = SQRT(gammaface*left(irhoe)/left(irho)) - SQRT(gammaface*&
   &         right(irhoe)/right(irho))
   IF (x2 .GE. 0.) THEN
   abs2 = x2
   ELSE
   abs2 = -x2
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1 = unavg - rface + aavg
   ELSE
   lam1 = -(unavg-rface+aavg)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2 = unavg - rface - aavg
   ELSE
   lam2 = -(unavg-rface-aavg)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3 = unavg - rface
   ELSE
   lam3 = -(unavg-rface)
   END IF
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) lam1 = eta + fourth*lam1*lam1/eta
   IF (lam2 .LT. tmp) lam2 = eta + fourth*lam2*lam2/eta
   IF (lam3 .LT. tmp) lam3 = eta + fourth*lam3*lam3/eta
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   lam1 = lam1*area
   lam2 = lam2*area
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   abv2 = half*(lam1-lam2)
   abv3 = abv1 - lam3
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
   &         drk
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   flux(irho) = -(porflux*(lam3*dr+abv6))
   flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
   flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
   flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
   flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
   CASE (turkel) 
   !          tmp = max(lam1,lam2,lam3)
   !          flux(irho)  = -porFlux*(tmp*dr)
   !          flux(imx)   = -porFlux*(tmp*dru)
   !          flux(imy)   = -porFlux*(tmp*drv)
   !          flux(imz)   = -porFlux*(tmp*drw)
   !          flux(irhoE) = -porFlux*(tmp*drE)
   CALL TERMINATE('riemannFlux', &
   &                   'Turkel preconditioner not implemented yet')
   CASE (choimerkle) 
   CALL TERMINATE('riemannFlux', &
   &                   'choi merkle preconditioner not implemented yet')
   END SELECT
   CASE (vanleer) 
   CALL TERMINATE('riemannFlux', &
   &                 'van leer fvs not implemented yet')
   CASE (ausmdv) 
   CALL TERMINATE('riemannFlux', 'ausmdv fvs not implemented yet')
   END SELECT
   END SUBROUTINE RIEMANNFLUX
   END SUBROUTINE INVISCIDUPWINDFLUX_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
   !
   !  Differentiation of normalvelocities_block in reverse (adjoint) mode:
   !   gradient     of useful results: *sfacei *sfacej *sfacek *si
   !                *sj *sk *(*bcdata.rface)
   !   with respect to varying inputs: *sfacei *sfacej *sfacek *si
   !                *sj *sk
   !   Plus diff mem management of: sfacei:in sfacej:in sfacek:in
   !                si:in sj:in sk:in bcdata:in *bcdata.rface:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          normalVelocities.f90                            *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 02-23-2004                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE NORMALVELOCITIES_BLOCK_B(sps)
   USE BLOCKPOINTERS_B
   USE BCTYPES
   USE ITERATION
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * normalVelocitiesAllLevels computes the normal grid             *
   !      * velocities of some boundary faces of the moving blocks for     *
   !      * spectral mode sps. All grid levels from ground level to the    *
   !      * coarsest level are considered.                                 *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: sps
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm
   INTEGER(kind=inttype) :: i, j
   REAL(kind=realtype) :: weight, mult
   REAL(kind=realtype) :: weightb
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: sface
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: sfaceb
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssb
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   REAL(kind=realtype) :: tempb
   INTRINSIC ASSOCIATED
   INTRINSIC SQRT
   INTERFACE 
   SUBROUTINE PUSHPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE PUSHPOINTER4
   SUBROUTINE LOOKPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE LOOKPOINTER4
   SUBROUTINE POPPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE POPPOINTER4
   END INTERFACE
      !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check for a moving block. As it is possible that in a
   ! multidisicplinary environment additional grid velocities
   ! are set, the test should be done on addGridVelocities
   ! and not on blockIsMoving.
   IF (addgridvelocities) THEN
   !
   !            ************************************************************
   !            *                                                          *
   !            * Determine the normal grid velocities of the boundaries.  *
   !            * As these values are based on the unit normal. A division *
   !            * by the length of the normal is needed.                   *
   !            * Furthermore the boundary unit normals are per definition *
   !            * outward pointing, while on the iMin, jMin and kMin       *
   !            * boundaries the face normals are inward pointing. This    *
   !            * is taken into account by the factor mult.                *
   !            *                                                          *
   !            ************************************************************
   !
   ! Loop over the boundary subfaces.
   bocoloop:DO mm=1,nbocos
   ! Check whether rFace is allocated.
   IF (ASSOCIATED(bcdata(mm)%rface)) THEN
   ! Determine the block face on which the subface is
   ! located and set some variables accordingly.
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHPOINTER4(ss)
   ss => si(1, :, :, :)
   CALL PUSHPOINTER4(sfaceb)
   sfaceb => sfaceib(1, :, :)
   CALL PUSHPOINTER4(sface)
   sface => sfacei(1, :, :)
   CALL PUSHCONTROL3B(5)
   CASE (imax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHPOINTER4(ss)
   ss => si(il, :, :, :)
   CALL PUSHPOINTER4(sfaceb)
   sfaceb => sfaceib(il, :, :)
   CALL PUSHPOINTER4(sface)
   sface => sfacei(il, :, :)
   CALL PUSHCONTROL3B(4)
   CASE (jmin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHPOINTER4(ss)
   ss => sj(:, 1, :, :)
   CALL PUSHPOINTER4(sfaceb)
   sfaceb => sfacejb(:, 1, :)
   CALL PUSHPOINTER4(sface)
   sface => sfacej(:, 1, :)
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHPOINTER4(ss)
   ss => sj(:, jl, :, :)
   CALL PUSHPOINTER4(sfaceb)
   sfaceb => sfacejb(:, jl, :)
   CALL PUSHPOINTER4(sface)
   sface => sfacej(:, jl, :)
   CALL PUSHCONTROL3B(2)
   CASE (kmin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, 1, :)
   CALL PUSHPOINTER4(sfaceb)
   sfaceb => sfacekb(:, :, 1)
   CALL PUSHPOINTER4(sface)
   sface => sfacek(:, :, 1)
   CALL PUSHCONTROL3B(1)
   CASE (kmax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, kl, :)
   CALL PUSHPOINTER4(sfaceb)
   sfaceb => sfacekb(:, :, kl)
   CALL PUSHPOINTER4(sface)
   sface => sfacek(:, :, kl)
   CALL PUSHCONTROL3B(0)
   CASE DEFAULT
   CALL PUSHCONTROL3B(6)
   END SELECT
   ad_from0 = bcdata(mm)%jcbeg
   ! Loop over the faces of the subface.
   DO j=ad_from0,bcdata(mm)%jcend
   ad_from = bcdata(mm)%icbeg
   DO i=ad_from,bcdata(mm)%icend
   CALL PUSHREAL8(weight)
   ! Compute the inverse of the length of the normal
   ! vector and possibly correct for inward pointing.
   weight = SQRT(ss(i, j, 1)**2 + ss(i, j, 2)**2 + ss(i, j, 3)&
   &              **2)
   IF (weight .GT. zero) THEN
   CALL PUSHREAL8(weight)
   weight = mult/weight
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO bocoloop
   DO mm=nbocos,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   weightb = sface(i, j)*bcdatab(mm)%rface(i, j)
   sfaceb(i, j) = sfaceb(i, j) + weight*bcdatab(mm)%rface(i, j)
   bcdatab(mm)%rface(i, j) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(weight)
   weightb = -(mult*weightb/weight**2)
   END IF
   CALL POPREAL8(weight)
   IF (ss(i, j, 1)**2 + ss(i, j, 2)**2 + ss(i, j, 3)**2 .EQ. &
   &                0.0) THEN
   tempb = 0.0
   ELSE
   tempb = weightb/(2.0*SQRT(ss(i, j, 1)**2+ss(i, j, 2)**2+ss&
   &                (i, j, 3)**2))
   END IF
   ssb(i, j, 1) = ssb(i, j, 1) + 2*ss(i, j, 1)*tempb
   ssb(i, j, 2) = ssb(i, j, 2) + 2*ss(i, j, 2)*tempb
   ssb(i, j, 3) = ssb(i, j, 3) + 2*ss(i, j, 3)*tempb
   END DO
   END DO
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .EQ. 0) THEN
   CALL POPPOINTER4(sface)
   CALL POPPOINTER4(sfaceb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(mult)
   ELSE IF (branch .EQ. 1) THEN
   CALL POPPOINTER4(sface)
   CALL POPPOINTER4(sfaceb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(mult)
   ELSE
   CALL POPPOINTER4(sface)
   CALL POPPOINTER4(sfaceb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL POPPOINTER4(sface)
   CALL POPPOINTER4(sfaceb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(mult)
   ELSE
   CALL POPPOINTER4(sface)
   CALL POPPOINTER4(sfaceb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .EQ. 5) THEN
   CALL POPPOINTER4(sface)
   CALL POPPOINTER4(sfaceb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(mult)
   END IF
   END IF
   END DO
   END IF
   END SUBROUTINE NORMALVELOCITIES_BLOCK_B

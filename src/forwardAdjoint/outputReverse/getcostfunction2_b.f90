   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of getcostfunction2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: funcvalues moment force cavitation
   !                sepsensor
   !   with respect to varying inputs: machgrid lengthref machcoef
   !                dragdirection liftdirection pointref gammainf
   !                pinf rhoinfdim pinfdim pref moment force cavitation
   !                sepsensor
   SUBROUTINE GETCOSTFUNCTION2_B(force, forceb, moment, momentb, sepsensor&
   & , sepsensorb, cavitation, cavitationb, alpha, beta, liftindex)
   ! Compute the value of the actual objective function based on the
   ! (summed) forces and moments and any other "extra" design
   ! variables. The index of the objective is determined by 'iDV'. This
   ! function is intended to be AD'ed in reverse mode. 
   USE INPUTTIMESPECTRAL
   USE COSTFUNCTIONS
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   USE INPUTTSSTABDERIV
   IMPLICIT NONE
   ! Input 
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral), INTENT(IN) &
   & :: force, moment
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral) :: forceb, &
   & momentb
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral), INTENT(IN) :: &
   & sepsensor, cavitation
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: sepsensorb, &
   & cavitationb
   REAL(kind=realtype), INTENT(IN) :: alpha, beta
   ! Working
   REAL(kind=realtype) :: fact, factmoment, scaledim, ovrnts
   REAL(kind=realtype) :: factb, factmomentb, scaledimb
   REAL(kind=realtype), DIMENSION(3) :: cf, cm
   REAL(kind=realtype), DIMENSION(3) :: cfb, cmb
   REAL(kind=realtype) :: elasticmomentx, elasticmomenty, elasticmomentz
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: basecoef
   REAL(kind=realtype), DIMENSION(8) :: coef0, dcdalpha, dcdalphadot, &
   & dcdq, dcdqdot
   REAL(kind=realtype), DIMENSION(8) :: coef0b, dcdalphab, dcdalphadotb
   REAL(kind=realtype) :: bendingmoment
   REAL(kind=realtype) :: bendingmomentb
   INTEGER(kind=inttype) :: sps
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   REAL(kind=realtype) :: tmp3
   REAL(kind=realtype) :: tmp4
   REAL(kind=realtype) :: tmp5
   REAL(kind=realtype) :: tmp6
   REAL(kind=realtype) :: tmp7
   REAL(kind=realtype) :: tmp8
   INTEGER :: branch
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tmpb8
   REAL(kind=realtype) :: tmpb7
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tmpb6
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tmpb5
   REAL(kind=realtype) :: tmpb4
   REAL(kind=realtype) :: tmpb3
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tmpb2
   REAL(kind=realtype) :: tmpb1
   REAL(kind=realtype) :: tmpb0
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: temp
   ! Generate constants
   scaledim = pref/pinf
   fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
   factmoment = fact/(lengthref*lref)
   ovrnts = one/ntimeintervalsspectral
   ! Pre-compute TS stability info if required:
   IF (tsstability) THEN
   CALL PUSHINTEGER4(liftindex)
   CALL COMPUTETSDERIVATIVES(force, moment, liftindex, coef0, &
   &                          dcdalpha, dcdalphadot, dcdq, dcdqdot)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   funcvalues = zero
   ! Now we just compute each cost function:
   DO sps=1,ntimeintervalsspectral
   funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
   &     force(1, sps)
   funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
   &     force(2, sps)
   funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
   &     force(3, sps)
   funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*moment(&
   &     1, sps)
   funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*moment(&
   &     2, sps)
   funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*moment(&
   &     3, sps)
   funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
   &     ovrnts*sepsensor(sps)
   funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
   &     ovrnts*cavitation(sps)
   ! Bending moment calc
   cm = factmoment*moment(:, sps)
   cf = fact*force(:, sps)
   CALL COMPUTEROOTBENDINGMOMENT(cf, cm, liftindex, bendingmoment)
   funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) + &
   &     ovrnts*bendingmoment
   END DO
   tmp = funcvalues(costfuncforcex)*fact
   CALL PUSHREAL8(funcvalues(costfuncforcexcoef))
   funcvalues(costfuncforcexcoef) = tmp
   tmp0 = funcvalues(costfuncforcey)*fact
   CALL PUSHREAL8(funcvalues(costfuncforceycoef))
   funcvalues(costfuncforceycoef) = tmp0
   tmp1 = funcvalues(costfuncforcez)*fact
   CALL PUSHREAL8(funcvalues(costfuncforcezcoef))
   funcvalues(costfuncforcezcoef) = tmp1
   tmp2 = funcvalues(costfuncmomx)*factmoment
   CALL PUSHREAL8(funcvalues(costfuncmomxcoef))
   funcvalues(costfuncmomxcoef) = tmp2
   tmp3 = funcvalues(costfuncmomy)*factmoment
   CALL PUSHREAL8(funcvalues(costfuncmomycoef))
   funcvalues(costfuncmomycoef) = tmp3
   tmp4 = funcvalues(costfuncmomz)*factmoment
   CALL PUSHREAL8(funcvalues(costfuncmomzcoef))
   funcvalues(costfuncmomzcoef) = tmp4
   tmp5 = funcvalues(costfuncforcex)*liftdirection(1) + funcvalues(&
   &   costfuncforcey)*liftdirection(2) + funcvalues(costfuncforcez)*&
   &   liftdirection(3)
   CALL PUSHREAL8(funcvalues(costfunclift))
   funcvalues(costfunclift) = tmp5
   tmp6 = funcvalues(costfuncforcex)*dragdirection(1) + funcvalues(&
   &   costfuncforcey)*dragdirection(2) + funcvalues(costfuncforcez)*&
   &   dragdirection(3)
   CALL PUSHREAL8(funcvalues(costfuncdrag))
   funcvalues(costfuncdrag) = tmp6
   tmp7 = funcvalues(costfunclift)*fact
   CALL PUSHREAL8(funcvalues(costfuncliftcoef))
   funcvalues(costfuncliftcoef) = tmp7
   ! -------------------- Time Spectral Objectives ------------------
   funcvaluesb(costfunccmzqdot) = 0.0_8
   funcvaluesb(costfunccdqdot) = 0.0_8
   funcvaluesb(costfuncclqdot) = 0.0_8
   funcvaluesb(costfunccmzq) = 0.0_8
   funcvaluesb(costfunccdq) = 0.0_8
   funcvaluesb(costfuncclq) = 0.0_8
   dcdalphadotb = 0.0_8
   dcdalphadotb(8) = dcdalphadotb(8) + funcvaluesb(costfunccmzalphadot)
   funcvaluesb(costfunccmzalphadot) = 0.0_8
   dcdalphadotb(2) = dcdalphadotb(2) + funcvaluesb(costfunccdalphadot)
   funcvaluesb(costfunccdalphadot) = 0.0_8
   dcdalphadotb(1) = dcdalphadotb(1) + funcvaluesb(costfuncclalphadot)
   funcvaluesb(costfuncclalphadot) = 0.0_8
   dcdalphab = 0.0_8
   dcdalphab(8) = dcdalphab(8) + funcvaluesb(costfunccmzalpha)
   funcvaluesb(costfunccmzalpha) = 0.0_8
   dcdalphab(2) = dcdalphab(2) + funcvaluesb(costfunccdalpha)
   funcvaluesb(costfunccdalpha) = 0.0_8
   dcdalphab(1) = dcdalphab(1) + funcvaluesb(costfuncclalpha)
   funcvaluesb(costfuncclalpha) = 0.0_8
   coef0b = 0.0_8
   coef0b(8) = coef0b(8) + funcvaluesb(costfunccm0)
   funcvaluesb(costfunccm0) = 0.0_8
   coef0b(2) = coef0b(2) + funcvaluesb(costfunccd0)
   funcvaluesb(costfunccd0) = 0.0_8
   coef0b(1) = coef0b(1) + funcvaluesb(costfunccl0)
   funcvaluesb(costfunccl0) = 0.0_8
   tmpb = funcvaluesb(costfuncdragcoef)
   funcvaluesb(costfuncdragcoef) = 0.0_8
   funcvaluesb(costfuncdrag) = funcvaluesb(costfuncdrag) + fact*tmpb
   factb = funcvalues(costfuncdrag)*tmpb
   CALL POPREAL8(funcvalues(costfuncliftcoef))
   tmpb0 = funcvaluesb(costfuncliftcoef)
   funcvaluesb(costfuncliftcoef) = 0.0_8
   funcvaluesb(costfunclift) = funcvaluesb(costfunclift) + fact*tmpb0
   factb = factb + funcvalues(costfunclift)*tmpb0
   dragdirectionb = 0.0_8
   CALL POPREAL8(funcvalues(costfuncdrag))
   tmpb1 = funcvaluesb(costfuncdrag)
   funcvaluesb(costfuncdrag) = 0.0_8
   dragdirectionb = 0.0_8
   funcvaluesb(costfuncforcex) = funcvaluesb(costfuncforcex) + &
   &   dragdirection(1)*tmpb1
   dragdirectionb(1) = dragdirectionb(1) + funcvalues(costfuncforcex)*&
   &   tmpb1
   funcvaluesb(costfuncforcey) = funcvaluesb(costfuncforcey) + &
   &   dragdirection(2)*tmpb1
   dragdirectionb(2) = dragdirectionb(2) + funcvalues(costfuncforcey)*&
   &   tmpb1
   funcvaluesb(costfuncforcez) = funcvaluesb(costfuncforcez) + &
   &   dragdirection(3)*tmpb1
   dragdirectionb(3) = dragdirectionb(3) + funcvalues(costfuncforcez)*&
   &   tmpb1
   liftdirectionb = 0.0_8
   CALL POPREAL8(funcvalues(costfunclift))
   tmpb2 = funcvaluesb(costfunclift)
   funcvaluesb(costfunclift) = 0.0_8
   liftdirectionb = 0.0_8
   funcvaluesb(costfuncforcex) = funcvaluesb(costfuncforcex) + &
   &   liftdirection(1)*tmpb2
   liftdirectionb(1) = liftdirectionb(1) + funcvalues(costfuncforcex)*&
   &   tmpb2
   funcvaluesb(costfuncforcey) = funcvaluesb(costfuncforcey) + &
   &   liftdirection(2)*tmpb2
   liftdirectionb(2) = liftdirectionb(2) + funcvalues(costfuncforcey)*&
   &   tmpb2
   funcvaluesb(costfuncforcez) = funcvaluesb(costfuncforcez) + &
   &   liftdirection(3)*tmpb2
   liftdirectionb(3) = liftdirectionb(3) + funcvalues(costfuncforcez)*&
   &   tmpb2
   CALL POPREAL8(funcvalues(costfuncmomzcoef))
   tmpb3 = funcvaluesb(costfuncmomzcoef)
   funcvaluesb(costfuncmomzcoef) = 0.0_8
   funcvaluesb(costfuncmomz) = funcvaluesb(costfuncmomz) + factmoment*&
   &   tmpb3
   factmomentb = funcvalues(costfuncmomz)*tmpb3
   CALL POPREAL8(funcvalues(costfuncmomycoef))
   tmpb4 = funcvaluesb(costfuncmomycoef)
   funcvaluesb(costfuncmomycoef) = 0.0_8
   funcvaluesb(costfuncmomy) = funcvaluesb(costfuncmomy) + factmoment*&
   &   tmpb4
   factmomentb = factmomentb + funcvalues(costfuncmomy)*tmpb4
   CALL POPREAL8(funcvalues(costfuncmomxcoef))
   tmpb5 = funcvaluesb(costfuncmomxcoef)
   funcvaluesb(costfuncmomxcoef) = 0.0_8
   funcvaluesb(costfuncmomx) = funcvaluesb(costfuncmomx) + factmoment*&
   &   tmpb5
   factmomentb = factmomentb + funcvalues(costfuncmomx)*tmpb5
   CALL POPREAL8(funcvalues(costfuncforcezcoef))
   tmpb6 = funcvaluesb(costfuncforcezcoef)
   funcvaluesb(costfuncforcezcoef) = 0.0_8
   funcvaluesb(costfuncforcez) = funcvaluesb(costfuncforcez) + fact*tmpb6
   factb = factb + funcvalues(costfuncforcez)*tmpb6
   CALL POPREAL8(funcvalues(costfuncforceycoef))
   tmpb7 = funcvaluesb(costfuncforceycoef)
   funcvaluesb(costfuncforceycoef) = 0.0_8
   funcvaluesb(costfuncforcey) = funcvaluesb(costfuncforcey) + fact*tmpb7
   factb = factb + funcvalues(costfuncforcey)*tmpb7
   CALL POPREAL8(funcvalues(costfuncforcexcoef))
   tmpb8 = funcvaluesb(costfuncforcexcoef)
   funcvaluesb(costfuncforcexcoef) = 0.0_8
   funcvaluesb(costfuncforcex) = funcvaluesb(costfuncforcex) + fact*tmpb8
   factb = factb + funcvalues(costfuncforcex)*tmpb8
   lengthrefb = 0.0_8
   pointrefb = 0.0_8
   DO sps=ntimeintervalsspectral,1,-1
   bendingmomentb = ovrnts*funcvaluesb(costfuncbendingcoef)
   cf = fact*force(:, sps)
   cm = factmoment*moment(:, sps)
   CALL COMPUTEROOTBENDINGMOMENT_B(cf, cfb, cm, cmb, liftindex, &
   &                             bendingmoment, bendingmomentb)
   factb = factb + SUM(force(:, sps)*cfb)
   forceb(:, sps) = forceb(:, sps) + fact*cfb
   factmomentb = factmomentb + SUM(moment(:, sps)*cmb)
   momentb(:, sps) = momentb(:, sps) + factmoment*cmb
   cavitationb(sps) = cavitationb(sps) + ovrnts*funcvaluesb(&
   &     costfunccavitation)
   sepsensorb(sps) = sepsensorb(sps) + ovrnts*funcvaluesb(&
   &     costfuncsepsensor)
   momentb(3, sps) = momentb(3, sps) + ovrnts*funcvaluesb(costfuncmomz)
   momentb(2, sps) = momentb(2, sps) + ovrnts*funcvaluesb(costfuncmomy)
   momentb(1, sps) = momentb(1, sps) + ovrnts*funcvaluesb(costfuncmomx)
   forceb(3, sps) = forceb(3, sps) + ovrnts*funcvaluesb(costfuncforcez)
   forceb(2, sps) = forceb(2, sps) + ovrnts*funcvaluesb(costfuncforcey)
   forceb(1, sps) = forceb(1, sps) + ovrnts*funcvaluesb(costfuncforcex)
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(liftindex)
   CALL COMPUTETSDERIVATIVES_B(force, forceb, moment, momentb, &
   &                         liftindex, coef0, coef0b, dcdalpha, dcdalphab&
   &                         , dcdalphadot, dcdalphadotb, dcdq, dcdqdot)
   ELSE
   machgridb = 0.0_8
   machcoefb = 0.0_8
   gammainfb = 0.0_8
   pinfb = 0.0_8
   rhoinfdimb = 0.0_8
   pinfdimb = 0.0_8
   prefb = 0.0_8
   END IF
   tempb = factmomentb/(lref*lengthref)
   factb = factb + tempb
   lengthrefb = lengthrefb - fact*tempb/lengthref
   temp1 = machcoef**2*scaledim
   temp0 = surfaceref*lref**2
   temp = temp0*gammainf*pinf
   tempb0 = -(two*factb/(temp**2*temp1**2))
   tempb1 = temp1*temp0*tempb0
   gammainfb = gammainfb + pinf*tempb1
   machcoefb = machcoefb + scaledim*temp*2*machcoef*tempb0
   scaledimb = temp*machcoef**2*tempb0
   pinfb = pinfb + gammainf*tempb1 - pref*scaledimb/pinf**2
   prefb = prefb + scaledimb/pinf
   END SUBROUTINE GETCOSTFUNCTION2_B

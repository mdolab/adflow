   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of getcostfunction2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: funcvalues moment force cavitation
   !                sepsensor
   !   with respect to varying inputs: gammainf pinf rhoinfdim pinfdim
   !                pref machgrid lengthref machcoef dragdirection
   !                liftdirection pointref moment force cavitation
   !                sepsensor
   SUBROUTINE GETCOSTFUNCTION2_B(force, forced, moment, momentd, sepsensor&
   & , sepsensord, cavitation, cavitationd, alpha, beta, liftindex)
   ! Compute the value of the actual objective function based on the
   ! (summed) forces and moments and any other "extra" design
   ! variables. The index of the objective is determined by 'iDV'. This
   ! function is intended to be AD'ed in reverse mode. 
   USE INPUTTIMESPECTRAL
   USE COSTFUNCTIONS
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   USE INPUTTSSTABDERIV
   IMPLICIT NONE
   ! Input 
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral), INTENT(IN) &
   & :: force, moment
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral) :: forced, &
   & momentd
   REAL(kind=realtype), INTENT(IN) :: sepsensor, cavitation
   REAL(kind=realtype) :: sepsensord, cavitationd
   REAL(kind=realtype), INTENT(IN) :: alpha, beta
   ! Working
   REAL(kind=realtype) :: fact, factmoment, scaledim, ovrnts
   REAL(kind=realtype) :: factd, factmomentd, scaledimd
   REAL(kind=realtype), DIMENSION(3) :: cf, cm
   REAL(kind=realtype), DIMENSION(3) :: cfd, cmd
   REAL(kind=realtype) :: elasticmomentx, elasticmomenty, elasticmomentz
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: basecoef
   REAL(kind=realtype), DIMENSION(8) :: coef0, dcdalpha, dcdalphadot, &
   & dcdq, dcdqdot
   REAL(kind=realtype), DIMENSION(8) :: coef0d, dcdalphad, dcdalphadotd
   REAL(kind=realtype) :: bendingmoment
   REAL(kind=realtype) :: bendingmomentd
   INTEGER(kind=inttype) :: sps
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   REAL(kind=realtype) :: tmp3
   REAL(kind=realtype) :: tmp4
   REAL(kind=realtype) :: tmp5
   REAL(kind=realtype) :: tmp6
   REAL(kind=realtype) :: tmp7
   REAL(kind=realtype) :: tmp8
   INTEGER :: branch
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tmpd8
   REAL(kind=realtype) :: tmpd7
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tmpd6
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tmpd5
   REAL(kind=realtype) :: tmpd4
   REAL(kind=realtype) :: tmpd3
   REAL(kind=realtype) :: tmpd2
   REAL(kind=realtype) :: tmpd1
   REAL(kind=realtype) :: tmpd0
   REAL(kind=realtype) :: temp
   ! Generate constants
   scaledim = pref/pinf
   fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
   factmoment = fact/(lengthref*lref)
   ovrnts = one/ntimeintervalsspectral
   ! Pre-compute TS stability info if required:
   IF (tsstability) THEN
   CALL PUSHINTEGER4(liftindex)
   CALL COMPUTETSDERIVATIVES(force, moment, liftindex, coef0, &
   &                          dcdalpha, dcdalphadot, dcdq, dcdqdot)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   funcvalues = zero
   ! Now we just compute each cost function:
   DO sps=1,ntimeintervalsspectral
   funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
   &     force(1, sps)
   funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
   &     force(2, sps)
   funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
   &     force(3, sps)
   funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*moment(&
   &     1, sps)
   funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*moment(&
   &     2, sps)
   funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*moment(&
   &     3, sps)
   funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
   &     ovrnts*sepsensor
   funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
   &     ovrnts*cavitation
   ! Bending moment calc
   cm = factmoment*moment(:, sps)
   cf = fact*force(:, sps)
   CALL COMPUTEROOTBENDINGMOMENT(cf, cm, liftindex, bendingmoment)
   funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) + &
   &     ovrnts*bendingmoment
   END DO
   tmp = funcvalues(costfuncforcex)*fact
   CALL PUSHREAL8(funcvalues(costfuncforcexcoef))
   funcvalues(costfuncforcexcoef) = tmp
   tmp0 = funcvalues(costfuncforcey)*fact
   CALL PUSHREAL8(funcvalues(costfuncforceycoef))
   funcvalues(costfuncforceycoef) = tmp0
   tmp1 = funcvalues(costfuncforcez)*fact
   CALL PUSHREAL8(funcvalues(costfuncforcezcoef))
   funcvalues(costfuncforcezcoef) = tmp1
   tmp2 = funcvalues(costfuncmomx)*factmoment
   CALL PUSHREAL8(funcvalues(costfuncmomxcoef))
   funcvalues(costfuncmomxcoef) = tmp2
   tmp3 = funcvalues(costfuncmomy)*factmoment
   CALL PUSHREAL8(funcvalues(costfuncmomycoef))
   funcvalues(costfuncmomycoef) = tmp3
   tmp4 = funcvalues(costfuncmomz)*factmoment
   CALL PUSHREAL8(funcvalues(costfuncmomzcoef))
   funcvalues(costfuncmomzcoef) = tmp4
   tmp5 = funcvalues(costfuncforcex)*liftdirection(1) + funcvalues(&
   &   costfuncforcey)*liftdirection(2) + funcvalues(costfuncforcez)*&
   &   liftdirection(3)
   CALL PUSHREAL8(funcvalues(costfunclift))
   funcvalues(costfunclift) = tmp5
   tmp6 = funcvalues(costfuncforcex)*dragdirection(1) + funcvalues(&
   &   costfuncforcey)*dragdirection(2) + funcvalues(costfuncforcez)*&
   &   dragdirection(3)
   CALL PUSHREAL8(funcvalues(costfuncdrag))
   funcvalues(costfuncdrag) = tmp6
   tmp7 = funcvalues(costfunclift)*fact
   CALL PUSHREAL8(funcvalues(costfuncliftcoef))
   funcvalues(costfuncliftcoef) = tmp7
   ! -------------------- Time Spectral Objectives ------------------
   funcvaluesd(costfunccmzqdot) = 0.0_8
   funcvaluesd(costfunccdqdot) = 0.0_8
   funcvaluesd(costfuncclqdot) = 0.0_8
   funcvaluesd(costfunccmzq) = 0.0_8
   funcvaluesd(costfunccdq) = 0.0_8
   funcvaluesd(costfuncclq) = 0.0_8
   dcdalphadotd = 0.0_8
   dcdalphadotd(8) = dcdalphadotd(8) + funcvaluesd(costfunccmzalphadot)
   funcvaluesd(costfunccmzalphadot) = 0.0_8
   dcdalphadotd(2) = dcdalphadotd(2) + funcvaluesd(costfunccdalphadot)
   funcvaluesd(costfunccdalphadot) = 0.0_8
   dcdalphadotd(1) = dcdalphadotd(1) + funcvaluesd(costfuncclalphadot)
   funcvaluesd(costfuncclalphadot) = 0.0_8
   dcdalphad = 0.0_8
   dcdalphad(8) = dcdalphad(8) + funcvaluesd(costfunccmzalpha)
   funcvaluesd(costfunccmzalpha) = 0.0_8
   dcdalphad(2) = dcdalphad(2) + funcvaluesd(costfunccdalpha)
   funcvaluesd(costfunccdalpha) = 0.0_8
   dcdalphad(1) = dcdalphad(1) + funcvaluesd(costfuncclalpha)
   funcvaluesd(costfuncclalpha) = 0.0_8
   coef0d = 0.0_8
   coef0d(8) = coef0d(8) + funcvaluesd(costfunccm0)
   funcvaluesd(costfunccm0) = 0.0_8
   coef0d(2) = coef0d(2) + funcvaluesd(costfunccd0)
   funcvaluesd(costfunccd0) = 0.0_8
   coef0d(1) = coef0d(1) + funcvaluesd(costfunccl0)
   funcvaluesd(costfunccl0) = 0.0_8
   tmpd = funcvaluesd(costfuncdragcoef)
   funcvaluesd(costfuncdragcoef) = 0.0_8
   funcvaluesd(costfuncdrag) = funcvaluesd(costfuncdrag) + fact*tmpd
   factd = funcvalues(costfuncdrag)*tmpd
   CALL POPREAL8(funcvalues(costfuncliftcoef))
   tmpd0 = funcvaluesd(costfuncliftcoef)
   funcvaluesd(costfuncliftcoef) = 0.0_8
   funcvaluesd(costfunclift) = funcvaluesd(costfunclift) + fact*tmpd0
   factd = factd + funcvalues(costfunclift)*tmpd0
   dragdirectiond = 0.0_8
   CALL POPREAL8(funcvalues(costfuncdrag))
   tmpd1 = funcvaluesd(costfuncdrag)
   funcvaluesd(costfuncdrag) = 0.0_8
   dragdirectiond = 0.0_8
   funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + &
   &   dragdirection(1)*tmpd1
   dragdirectiond(1) = dragdirectiond(1) + funcvalues(costfuncforcex)*&
   &   tmpd1
   funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + &
   &   dragdirection(2)*tmpd1
   dragdirectiond(2) = dragdirectiond(2) + funcvalues(costfuncforcey)*&
   &   tmpd1
   funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + &
   &   dragdirection(3)*tmpd1
   dragdirectiond(3) = dragdirectiond(3) + funcvalues(costfuncforcez)*&
   &   tmpd1
   liftdirectiond = 0.0_8
   CALL POPREAL8(funcvalues(costfunclift))
   tmpd2 = funcvaluesd(costfunclift)
   funcvaluesd(costfunclift) = 0.0_8
   liftdirectiond = 0.0_8
   funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + &
   &   liftdirection(1)*tmpd2
   liftdirectiond(1) = liftdirectiond(1) + funcvalues(costfuncforcex)*&
   &   tmpd2
   funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + &
   &   liftdirection(2)*tmpd2
   liftdirectiond(2) = liftdirectiond(2) + funcvalues(costfuncforcey)*&
   &   tmpd2
   funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + &
   &   liftdirection(3)*tmpd2
   liftdirectiond(3) = liftdirectiond(3) + funcvalues(costfuncforcez)*&
   &   tmpd2
   CALL POPREAL8(funcvalues(costfuncmomzcoef))
   tmpd3 = funcvaluesd(costfuncmomzcoef)
   funcvaluesd(costfuncmomzcoef) = 0.0_8
   funcvaluesd(costfuncmomz) = funcvaluesd(costfuncmomz) + factmoment*&
   &   tmpd3
   factmomentd = funcvalues(costfuncmomz)*tmpd3
   CALL POPREAL8(funcvalues(costfuncmomycoef))
   tmpd4 = funcvaluesd(costfuncmomycoef)
   funcvaluesd(costfuncmomycoef) = 0.0_8
   funcvaluesd(costfuncmomy) = funcvaluesd(costfuncmomy) + factmoment*&
   &   tmpd4
   factmomentd = factmomentd + funcvalues(costfuncmomy)*tmpd4
   CALL POPREAL8(funcvalues(costfuncmomxcoef))
   tmpd5 = funcvaluesd(costfuncmomxcoef)
   funcvaluesd(costfuncmomxcoef) = 0.0_8
   funcvaluesd(costfuncmomx) = funcvaluesd(costfuncmomx) + factmoment*&
   &   tmpd5
   factmomentd = factmomentd + funcvalues(costfuncmomx)*tmpd5
   CALL POPREAL8(funcvalues(costfuncforcezcoef))
   tmpd6 = funcvaluesd(costfuncforcezcoef)
   funcvaluesd(costfuncforcezcoef) = 0.0_8
   funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + fact*tmpd6
   factd = factd + funcvalues(costfuncforcez)*tmpd6
   CALL POPREAL8(funcvalues(costfuncforceycoef))
   tmpd7 = funcvaluesd(costfuncforceycoef)
   funcvaluesd(costfuncforceycoef) = 0.0_8
   funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + fact*tmpd7
   factd = factd + funcvalues(costfuncforcey)*tmpd7
   CALL POPREAL8(funcvalues(costfuncforcexcoef))
   tmpd8 = funcvaluesd(costfuncforcexcoef)
   funcvaluesd(costfuncforcexcoef) = 0.0_8
   funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + fact*tmpd8
   factd = factd + funcvalues(costfuncforcex)*tmpd8
   lengthrefd = 0.0_8
   pointrefd = 0.0_8
   DO sps=ntimeintervalsspectral,1,-1
   bendingmomentd = ovrnts*funcvaluesd(costfuncbendingcoef)
   cf = fact*force(:, sps)
   cm = factmoment*moment(:, sps)
   CALL COMPUTEROOTBENDINGMOMENT_B(cf, cfd, cm, cmd, liftindex, &
   &                             bendingmoment, bendingmomentd)
   factd = factd + SUM(force(:, sps)*cfd)
   forced(:, sps) = forced(:, sps) + fact*cfd
   factmomentd = factmomentd + SUM(moment(:, sps)*cmd)
   momentd(:, sps) = momentd(:, sps) + factmoment*cmd
   cavitationd = cavitationd + ovrnts*funcvaluesd(costfunccavitation)
   sepsensord = sepsensord + ovrnts*funcvaluesd(costfuncsepsensor)
   momentd(3, sps) = momentd(3, sps) + ovrnts*funcvaluesd(costfuncmomz)
   momentd(2, sps) = momentd(2, sps) + ovrnts*funcvaluesd(costfuncmomy)
   momentd(1, sps) = momentd(1, sps) + ovrnts*funcvaluesd(costfuncmomx)
   forced(3, sps) = forced(3, sps) + ovrnts*funcvaluesd(costfuncforcez)
   forced(2, sps) = forced(2, sps) + ovrnts*funcvaluesd(costfuncforcey)
   forced(1, sps) = forced(1, sps) + ovrnts*funcvaluesd(costfuncforcex)
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(liftindex)
   CALL COMPUTETSDERIVATIVES_B(force, forced, moment, momentd, &
   &                         liftindex, coef0, coef0d, dcdalpha, dcdalphad&
   &                         , dcdalphadot, dcdalphadotd, dcdq, dcdqdot)
   ELSE
   gammainfd = 0.0_8
   pinfd = 0.0_8
   rhoinfdimd = 0.0_8
   pinfdimd = 0.0_8
   prefd = 0.0_8
   machgridd = 0.0_8
   machcoefd = 0.0_8
   END IF
   tempd = factmomentd/(lref*lengthref)
   factd = factd + tempd
   lengthrefd = lengthrefd - fact*tempd/lengthref
   temp1 = machcoef**2*scaledim
   temp0 = surfaceref*lref**2
   temp = temp0*gammainf*pinf
   tempd0 = -(two*factd/(temp**2*temp1**2))
   tempd1 = temp1*temp0*tempd0
   gammainfd = gammainfd + pinf*tempd1
   machcoefd = machcoefd + scaledim*temp*2*machcoef*tempd0
   scaledimd = temp*machcoef**2*tempd0
   pinfd = pinfd + gammainf*tempd1 - pref*scaledimd/pinf**2
   prefd = prefd + scaledimd/pinf
   END SUBROUTINE GETCOSTFUNCTION2_B

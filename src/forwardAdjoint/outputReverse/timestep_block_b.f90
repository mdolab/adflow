   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of timestep_block in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: gammainf rhoinf pinfcorr *p
   !                *w *si *sj *sk *radi *radj *radk
   !   with respect to varying inputs: gammainf rhoinf pinfcorr *p
   !                *w *si *sj *sk
   !   Plus diff mem management of: p:in w:in si:in sj:in sk:in radi:in
   !                radj:in radk:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          timeStep.f90                                    *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-17-2003                                      *
   !      * Last modified: 06-28-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE TIMESTEP_BLOCK_B(onlyradii)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * timeStep computes the time step, or more precisely the time    *
   !      * step divided by the volume per unit CFL, in the owned cells.   *
   !      * However, for the artificial dissipation schemes, the spectral  *
   !      * radIi in the halo's are needed. Therefore the loop is taken    *
   !      * over the the first level of halo cells. The spectral radIi are *
   !      * stored and possibly modified for high aspect ratio cells.      *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTITERATION
   USE INPUTPHYSICS
   USE INPUTTIMESPECTRAL
   USE ITERATION
   USE SECTION
   IMPLICIT NONE
   ! The rest of this file can be skipped if only the spectral
   ! radii need to be computed.
   !
   !      Subroutine argument.
   !
   LOGICAL, INTENT(IN) :: onlyradii
   !
   !      Local parameters.
   !
   REAL(kind=realtype), PARAMETER :: b=2.0_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ii
   REAL(kind=realtype) :: plim, rlim, clim2
   REAL(kind=realtype) :: clim2d
   REAL(kind=realtype) :: uux, uuy, uuz, cc2, qsi, qsj, qsk, sx, sy, sz, &
   & rmu
   REAL(kind=realtype) :: uuxd, uuyd, uuzd, cc2d, qsid, qsjd, qskd, sxd, &
   & syd, szd
   REAL(kind=realtype) :: ri, rj, rk, rij, rjk, rki
   REAL(kind=realtype) :: rid, rjd, rkd, rijd, rjkd, rkid
   REAL(kind=realtype) :: vsi, vsj, vsk, rfl, dpi, dpj, dpk
   REAL(kind=realtype) :: sface, tmp
   LOGICAL :: radiineeded, doscaling
   INTRINSIC MOD
   INTRINSIC MAX
   INTRINSIC ABS
   INTRINSIC SQRT
   INTEGER :: branch
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: tempd12
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd11
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: abs1d
   REAL(kind=realtype) :: abs0d
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs2d
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: temp
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine whether or not the spectral radii are needed for the
   ! flux computation.
   radiineeded = radiineededcoarse
   IF (currentlevel .LE. groundlevel) radiineeded = radiineededfine
   ! Return immediately if only the spectral radii must be computed
   ! and these are not needed for the flux computation.
   IF (.NOT.(onlyradii .AND. (.NOT.radiineeded))) THEN
   ! Set the value of plim. To be fully consistent this must have
   ! the dimension of a pressure. Therefore a fraction of pInfCorr
   ! is used. Idem for rlim; compute clim2 as well.
   clim2 = 0.000001_realType*gammainf*pinfcorr/rhoinf
   doscaling = dirscaling .AND. currentlevel .LE. groundlevel
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   !
   !          **************************************************************
   !          *                                                            *
   !          * Inviscid contribution, depending on the preconditioner.    *
   !          * Compute the cell centered values of the spectral radii.    *
   !          *                                                            *
   !          **************************************************************
   !
   SELECT CASE  (precond) 
   CASE (noprecond) 
   clim2d = 0.0_8
   DO ii=0,ie*je*ke-1
   i = MOD(ii, ie) + 1
   j = MOD(ii/ie, je) + 1
   k = ii/(ie*je) + 1
   ! Compute the velocities and speed of sound squared.
   uux = w(i, j, k, ivx)
   uuy = w(i, j, k, ivy)
   uuz = w(i, j, k, ivz)
   cc2 = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
   IF (cc2 .LT. clim2) THEN
   cc2 = clim2
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   cc2 = cc2
   END IF
   ! Set the dot product of the grid velocity and the
   ! normal in i-direction for a moving face. To avoid
   ! a number of multiplications by 0.5 simply the sum
   ! is taken.
   IF (addgridvelocities) sface = sfacei(i-1, j, k) + sfacei(i, j, &
   &           k)
   ! Spectral radius in i-direction.
   sx = si(i-1, j, k, 1) + si(i, j, k, 1)
   sy = si(i-1, j, k, 2) + si(i, j, k, 2)
   sz = si(i-1, j, k, 3) + si(i, j, k, 3)
   qsi = uux*sx + uuy*sy + uuz*sz - sface
   IF (qsi .GE. 0.) THEN
   abs0 = qsi
   CALL PUSHCONTROL1B(0)
   ELSE
   abs0 = -qsi
   CALL PUSHCONTROL1B(1)
   END IF
   radi(i, j, k) = half*(abs0+SQRT(cc2*(sx**2+sy**2+sz**2)))
   ! The grid velocity in j-direction.
   IF (addgridvelocities) sface = sfacej(i, j-1, k) + sfacej(i, j, &
   &           k)
   ! Spectral radius in j-direction.
   sx = sj(i, j-1, k, 1) + sj(i, j, k, 1)
   sy = sj(i, j-1, k, 2) + sj(i, j, k, 2)
   sz = sj(i, j-1, k, 3) + sj(i, j, k, 3)
   qsj = uux*sx + uuy*sy + uuz*sz - sface
   IF (qsj .GE. 0.) THEN
   abs1 = qsj
   CALL PUSHCONTROL1B(0)
   ELSE
   abs1 = -qsj
   CALL PUSHCONTROL1B(1)
   END IF
   radj(i, j, k) = half*(abs1+SQRT(cc2*(sx**2+sy**2+sz**2)))
   ! The grid velocity in k-direction.
   IF (addgridvelocities) sface = sfacek(i, j, k-1) + sfacek(i, j, &
   &           k)
   ! Spectral radius in k-direction.
   sx = sk(i, j, k-1, 1) + sk(i, j, k, 1)
   sy = sk(i, j, k-1, 2) + sk(i, j, k, 2)
   sz = sk(i, j, k-1, 3) + sk(i, j, k, 3)
   qsk = uux*sx + uuy*sy + uuz*sz - sface
   IF (qsk .GE. 0.) THEN
   abs2 = qsk
   CALL PUSHCONTROL1B(0)
   ELSE
   abs2 = -qsk
   CALL PUSHCONTROL1B(1)
   END IF
   radk(i, j, k) = half*(abs2+SQRT(cc2*(sx**2+sy**2+sz**2)))
   ! Compute the inviscid contribution to the time step.
   !
   !          **************************************************************
   !          *                                                            *
   !          * Adapt the spectral radii if directional scaling must be    *
   !          * applied.                                                   *
   !          *                                                            *
   !          **************************************************************
   !
   IF (doscaling) THEN
   IF (radi(i, j, k) .LT. eps) THEN
   CALL PUSHCONTROL1B(0)
   ri = eps
   ELSE
   ri = radi(i, j, k)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (radj(i, j, k) .LT. eps) THEN
   CALL PUSHCONTROL1B(0)
   rj = eps
   ELSE
   rj = radj(i, j, k)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (radk(i, j, k) .LT. eps) THEN
   CALL PUSHCONTROL1B(0)
   rk = eps
   ELSE
   rk = radk(i, j, k)
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the scaling in the three coordinate
   ! directions.
   rij = (ri/rj)**adis
   rjk = (rj/rk)**adis
   rki = (rk/ri)**adis
   ! Create the scaled versions of the aspect ratios.
   ! Note that the multiplication is done with radi, radJ
   ! and radK, such that the influence of the clipping
   ! is negligible.
   tempd7 = radk(i, j, k)*radkd(i, j, k)
   radkd(i, j, k) = (one+one/rki+rjk)*radkd(i, j, k)
   tempd9 = radj(i, j, k)*radjd(i, j, k)
   rjkd = tempd7 - one*tempd9/rjk**2
   radjd(i, j, k) = (one+one/rjk+rij)*radjd(i, j, k)
   tempd8 = radi(i, j, k)*radid(i, j, k)
   rkid = tempd8 - one*tempd7/rki**2
   rijd = tempd9 - one*tempd8/rij**2
   radid(i, j, k) = (one+one/rij+rki)*radid(i, j, k)
   IF (rk/ri .LE. 0.0_8 .AND. (adis .EQ. 0.0_8 .OR. adis .NE. INT&
   &             (adis))) THEN
   tempd10 = 0.0
   ELSE
   tempd10 = adis*(rk/ri)**(adis-1)*rkid/ri
   END IF
   IF (rj/rk .LE. 0.0_8 .AND. (adis .EQ. 0.0_8 .OR. adis .NE. INT&
   &             (adis))) THEN
   tempd11 = 0.0
   ELSE
   tempd11 = adis*(rj/rk)**(adis-1)*rjkd/rk
   END IF
   rkd = tempd10 - rj*tempd11/rk
   IF (ri/rj .LE. 0.0_8 .AND. (adis .EQ. 0.0_8 .OR. adis .NE. INT&
   &             (adis))) THEN
   tempd12 = 0.0
   ELSE
   tempd12 = adis*(ri/rj)**(adis-1)*rijd/rj
   END IF
   rid = tempd12 - rk*tempd10/ri
   rjd = tempd11 - ri*tempd12/rj
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) radkd(i, j, k) = radkd(i, j, k) + rkd
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) radjd(i, j, k) = radjd(i, j, k) + rjd
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) radid(i, j, k) = radid(i, j, k) + rid
   END IF
   temp2 = sx**2 + sy**2 + sz**2
   IF (cc2*temp2 .EQ. 0.0_8) THEN
   tempd5 = 0.0
   ELSE
   tempd5 = half*radkd(i, j, k)/(2.0*SQRT(cc2*temp2))
   END IF
   tempd6 = cc2*tempd5
   abs2d = half*radkd(i, j, k)
   cc2d = temp2*tempd5
   sxd = 2*sx*tempd6
   syd = 2*sy*tempd6
   szd = 2*sz*tempd6
   radkd(i, j, k) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   qskd = abs2d
   ELSE
   qskd = -abs2d
   END IF
   uuxd = sx*qskd
   sxd = sxd + uux*qskd
   uuyd = sy*qskd
   syd = syd + uuy*qskd
   uuzd = sz*qskd
   szd = szd + uuz*qskd
   skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + szd
   skd(i, j, k, 3) = skd(i, j, k, 3) + szd
   skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + syd
   skd(i, j, k, 2) = skd(i, j, k, 2) + syd
   skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + sxd
   skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
   sx = sj(i, j-1, k, 1) + sj(i, j, k, 1)
   sy = sj(i, j-1, k, 2) + sj(i, j, k, 2)
   sz = sj(i, j-1, k, 3) + sj(i, j, k, 3)
   temp1 = sx**2 + sy**2 + sz**2
   IF (cc2*temp1 .EQ. 0.0_8) THEN
   tempd3 = 0.0
   ELSE
   tempd3 = half*radjd(i, j, k)/(2.0*SQRT(cc2*temp1))
   END IF
   tempd4 = cc2*tempd3
   abs1d = half*radjd(i, j, k)
   cc2d = cc2d + temp1*tempd3
   sxd = 2*sx*tempd4
   syd = 2*sy*tempd4
   szd = 2*sz*tempd4
   radjd(i, j, k) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   qsjd = abs1d
   ELSE
   qsjd = -abs1d
   END IF
   uuxd = uuxd + sx*qsjd
   sxd = sxd + uux*qsjd
   uuyd = uuyd + sy*qsjd
   syd = syd + uuy*qsjd
   uuzd = uuzd + sz*qsjd
   szd = szd + uuz*qsjd
   sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + szd
   sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
   sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + syd
   sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
   sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + sxd
   sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
   sx = si(i-1, j, k, 1) + si(i, j, k, 1)
   sy = si(i-1, j, k, 2) + si(i, j, k, 2)
   sz = si(i-1, j, k, 3) + si(i, j, k, 3)
   temp0 = sx**2 + sy**2 + sz**2
   IF (cc2*temp0 .EQ. 0.0_8) THEN
   tempd1 = 0.0
   ELSE
   tempd1 = half*radid(i, j, k)/(2.0*SQRT(cc2*temp0))
   END IF
   tempd2 = cc2*tempd1
   abs0d = half*radid(i, j, k)
   cc2d = cc2d + temp0*tempd1
   sxd = 2*sx*tempd2
   syd = 2*sy*tempd2
   szd = 2*sz*tempd2
   radid(i, j, k) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   qsid = abs0d
   ELSE
   qsid = -abs0d
   END IF
   uuxd = uuxd + sx*qsid
   sxd = sxd + uux*qsid
   uuyd = uuyd + sy*qsid
   syd = syd + uuy*qsid
   uuzd = uuzd + sz*qsid
   szd = szd + uuz*qsid
   sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + szd
   sid(i, j, k, 3) = sid(i, j, k, 3) + szd
   sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + syd
   sid(i, j, k, 2) = sid(i, j, k, 2) + syd
   sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + sxd
   sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   clim2d = clim2d + cc2d
   cc2d = 0.0_8
   END IF
   temp = w(i, j, k, irho)
   tempd0 = gamma(i, j, k)*cc2d/temp
   pd(i, j, k) = pd(i, j, k) + tempd0
   wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd0/temp
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + uuzd
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + uuyd
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + uuxd
   END DO
   CASE (turkel) 
   clim2d = 0.0_8
   CASE (choimerkle) 
   clim2d = 0.0_8
   CASE DEFAULT
   clim2d = 0.0_8
   END SELECT
   tempd = 0.000001_realType*clim2d/rhoinf
   gammainfd = gammainfd + pinfcorr*tempd
   pinfcorrd = pinfcorrd + gammainf*tempd
   rhoinfd = rhoinfd - gammainf*pinfcorr*tempd/rhoinf
   END IF
   END SUBROUTINE TIMESTEP_BLOCK_B

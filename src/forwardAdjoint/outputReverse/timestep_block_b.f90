!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of timestep_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: gammainf rhoinf pinfcorr *p
!                *w *si *sj *sk *radi *radj *radk
!   with respect to varying inputs: gammainf rhoinf pinfcorr *p
!                *w *si *sj *sk
!   plus diff mem management of: p:in w:in si:in sj:in sk:in radi:in
!                radj:in radk:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          timestep.f90                                    *
!      * author:        edwin van der weide                             *
!      * starting date: 03-17-2003                                      *
!      * last modified: 06-28-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine timestep_block_b(onlyradii)
!
!      ******************************************************************
!      *                                                                *
!      * timestep computes the time step, or more precisely the time    *
!      * step divided by the volume per unit cfl, in the owned cells.   *
!      * however, for the artificial dissipation schemes, the spectral  *
!      * radii in the halo's are needed. therefore the loop is taken    *
!      * over the the first level of halo cells. the spectral radii are *
!      * stored and possibly modified for high aspect ratio cells.      *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use constants
  use flowvarrefstate
  use inputdiscretization
  use inputiteration
  use inputphysics
  use inputtimespectral
  use iteration
  use section
  implicit none
! the rest of this file can be skipped if only the spectral
! radii need to be computed.
!
!      subroutine argument.
!
  logical, intent(in) :: onlyradii
!
!      local parameters.
!
  real(kind=realtype), parameter :: b=2.0_realtype
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ii
  real(kind=realtype) :: plim, rlim, clim2
  real(kind=realtype) :: clim2d
  real(kind=realtype) :: uux, uuy, uuz, cc2, qsi, qsj, qsk, sx, sy, sz, &
& rmu
  real(kind=realtype) :: uuxd, uuyd, uuzd, cc2d, qsid, qsjd, qskd, sxd, &
& syd, szd
  real(kind=realtype) :: ri, rj, rk, rij, rjk, rki
  real(kind=realtype) :: rid, rjd, rkd, rijd, rjkd, rkid
  real(kind=realtype) :: vsi, vsj, vsk, rfl, dpi, dpj, dpk
  real(kind=realtype) :: sface, tmp
  logical :: radiineeded, doscaling
  intrinsic mod
  intrinsic max
  intrinsic abs
  intrinsic sqrt
  integer :: branch
  real(kind=realtype) :: temp2
  real(kind=realtype) :: temp1
  real(kind=realtype) :: tempd12
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: abs1d
  real(kind=realtype) :: abs0d
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: abs2
  real(kind=realtype) :: abs2d
  real(kind=realtype) :: abs1
  real(kind=realtype) :: abs0
  real(kind=realtype) :: temp
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! determine whether or not the spectral radii are needed for the
! flux computation.
  radiineeded = radiineededcoarse
  if (currentlevel .le. groundlevel) radiineeded = radiineededfine
! return immediately if only the spectral radii must be computed
! and these are not needed for the flux computation.
  if (.not.(onlyradii .and. (.not.radiineeded))) then
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used. idem for rlim; compute clim2 as well.
    clim2 = 0.000001_realtype*gammainf*pinfcorr/rhoinf
    doscaling = dirscaling .and. currentlevel .le. groundlevel
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
!
!          **************************************************************
!          *                                                            *
!          * inviscid contribution, depending on the preconditioner.    *
!          * compute the cell centered values of the spectral radii.    *
!          *                                                            *
!          **************************************************************
!
    select case  (precond) 
    case (noprecond) 
      clim2d = 0.0_8
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
! compute the velocities and speed of sound squared.
        uux = w(i, j, k, ivx)
        uuy = w(i, j, k, ivy)
        uuz = w(i, j, k, ivz)
        cc2 = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
        if (cc2 .lt. clim2) then
          cc2 = clim2
          call pushcontrol1b(0)
        else
          call pushcontrol1b(1)
          cc2 = cc2
        end if
! set the dot product of the grid velocity and the
! normal in i-direction for a moving face. to avoid
! a number of multiplications by 0.5 simply the sum
! is taken.
        if (addgridvelocities) sface = sfacei(i-1, j, k) + sfacei(i, j, &
&           k)
! spectral radius in i-direction.
        sx = si(i-1, j, k, 1) + si(i, j, k, 1)
        sy = si(i-1, j, k, 2) + si(i, j, k, 2)
        sz = si(i-1, j, k, 3) + si(i, j, k, 3)
        qsi = uux*sx + uuy*sy + uuz*sz - sface
        if (qsi .ge. 0.) then
          abs0 = qsi
          call pushcontrol1b(0)
        else
          abs0 = -qsi
          call pushcontrol1b(1)
        end if
        radi(i, j, k) = half*(abs0+sqrt(cc2*(sx**2+sy**2+sz**2)))
! the grid velocity in j-direction.
        if (addgridvelocities) sface = sfacej(i, j-1, k) + sfacej(i, j, &
&           k)
! spectral radius in j-direction.
        sx = sj(i, j-1, k, 1) + sj(i, j, k, 1)
        sy = sj(i, j-1, k, 2) + sj(i, j, k, 2)
        sz = sj(i, j-1, k, 3) + sj(i, j, k, 3)
        qsj = uux*sx + uuy*sy + uuz*sz - sface
        if (qsj .ge. 0.) then
          abs1 = qsj
          call pushcontrol1b(0)
        else
          abs1 = -qsj
          call pushcontrol1b(1)
        end if
        radj(i, j, k) = half*(abs1+sqrt(cc2*(sx**2+sy**2+sz**2)))
! the grid velocity in k-direction.
        if (addgridvelocities) sface = sfacek(i, j, k-1) + sfacek(i, j, &
&           k)
! spectral radius in k-direction.
        sx = sk(i, j, k-1, 1) + sk(i, j, k, 1)
        sy = sk(i, j, k-1, 2) + sk(i, j, k, 2)
        sz = sk(i, j, k-1, 3) + sk(i, j, k, 3)
        qsk = uux*sx + uuy*sy + uuz*sz - sface
        if (qsk .ge. 0.) then
          abs2 = qsk
          call pushcontrol1b(0)
        else
          abs2 = -qsk
          call pushcontrol1b(1)
        end if
        radk(i, j, k) = half*(abs2+sqrt(cc2*(sx**2+sy**2+sz**2)))
! compute the inviscid contribution to the time step.
!
!          **************************************************************
!          *                                                            *
!          * adapt the spectral radii if directional scaling must be    *
!          * applied.                                                   *
!          *                                                            *
!          **************************************************************
!
        if (doscaling) then
          if (radi(i, j, k) .lt. eps) then
            call pushcontrol1b(0)
            ri = eps
          else
            ri = radi(i, j, k)
            call pushcontrol1b(1)
          end if
          if (radj(i, j, k) .lt. eps) then
            call pushcontrol1b(0)
            rj = eps
          else
            rj = radj(i, j, k)
            call pushcontrol1b(1)
          end if
          if (radk(i, j, k) .lt. eps) then
            call pushcontrol1b(0)
            rk = eps
          else
            rk = radk(i, j, k)
            call pushcontrol1b(1)
          end if
! compute the scaling in the three coordinate
! directions.
          rij = (ri/rj)**adis
          rjk = (rj/rk)**adis
          rki = (rk/ri)**adis
! create the scaled versions of the aspect ratios.
! note that the multiplication is done with radi, radj
! and radk, such that the influence of the clipping
! is negligible.
          tempd7 = radk(i, j, k)*radkd(i, j, k)
          radkd(i, j, k) = (one+one/rki+rjk)*radkd(i, j, k)
          tempd9 = radj(i, j, k)*radjd(i, j, k)
          rjkd = tempd7 - one*tempd9/rjk**2
          radjd(i, j, k) = (one+one/rjk+rij)*radjd(i, j, k)
          tempd8 = radi(i, j, k)*radid(i, j, k)
          rkid = tempd8 - one*tempd7/rki**2
          rijd = tempd9 - one*tempd8/rij**2
          radid(i, j, k) = (one+one/rij+rki)*radid(i, j, k)
          if (rk/ri .le. 0.0_8 .and. (adis .eq. 0.0_8 .or. adis .ne. int&
&             (adis))) then
            tempd10 = 0.0
          else
            tempd10 = adis*(rk/ri)**(adis-1)*rkid/ri
          end if
          if (rj/rk .le. 0.0_8 .and. (adis .eq. 0.0_8 .or. adis .ne. int&
&             (adis))) then
            tempd11 = 0.0
          else
            tempd11 = adis*(rj/rk)**(adis-1)*rjkd/rk
          end if
          rkd = tempd10 - rj*tempd11/rk
          if (ri/rj .le. 0.0_8 .and. (adis .eq. 0.0_8 .or. adis .ne. int&
&             (adis))) then
            tempd12 = 0.0
          else
            tempd12 = adis*(ri/rj)**(adis-1)*rijd/rj
          end if
          rid = tempd12 - rk*tempd10/ri
          rjd = tempd11 - ri*tempd12/rj
          call popcontrol1b(branch)
          if (branch .ne. 0) radkd(i, j, k) = radkd(i, j, k) + rkd
          call popcontrol1b(branch)
          if (branch .ne. 0) radjd(i, j, k) = radjd(i, j, k) + rjd
          call popcontrol1b(branch)
          if (branch .ne. 0) radid(i, j, k) = radid(i, j, k) + rid
        end if
        temp2 = sx**2 + sy**2 + sz**2
        if (cc2*temp2 .eq. 0.0_8) then
          tempd5 = 0.0
        else
          tempd5 = half*radkd(i, j, k)/(2.0*sqrt(cc2*temp2))
        end if
        tempd6 = cc2*tempd5
        abs2d = half*radkd(i, j, k)
        cc2d = temp2*tempd5
        sxd = 2*sx*tempd6
        syd = 2*sy*tempd6
        szd = 2*sz*tempd6
        radkd(i, j, k) = 0.0_8
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          qskd = abs2d
        else
          qskd = -abs2d
        end if
        uuxd = sx*qskd
        sxd = sxd + uux*qskd
        uuyd = sy*qskd
        syd = syd + uuy*qskd
        uuzd = sz*qskd
        szd = szd + uuz*qskd
        skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + szd
        skd(i, j, k, 3) = skd(i, j, k, 3) + szd
        skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + syd
        skd(i, j, k, 2) = skd(i, j, k, 2) + syd
        skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + sxd
        skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
        sx = sj(i, j-1, k, 1) + sj(i, j, k, 1)
        sy = sj(i, j-1, k, 2) + sj(i, j, k, 2)
        sz = sj(i, j-1, k, 3) + sj(i, j, k, 3)
        temp1 = sx**2 + sy**2 + sz**2
        if (cc2*temp1 .eq. 0.0_8) then
          tempd3 = 0.0
        else
          tempd3 = half*radjd(i, j, k)/(2.0*sqrt(cc2*temp1))
        end if
        tempd4 = cc2*tempd3
        abs1d = half*radjd(i, j, k)
        cc2d = cc2d + temp1*tempd3
        sxd = 2*sx*tempd4
        syd = 2*sy*tempd4
        szd = 2*sz*tempd4
        radjd(i, j, k) = 0.0_8
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          qsjd = abs1d
        else
          qsjd = -abs1d
        end if
        uuxd = uuxd + sx*qsjd
        sxd = sxd + uux*qsjd
        uuyd = uuyd + sy*qsjd
        syd = syd + uuy*qsjd
        uuzd = uuzd + sz*qsjd
        szd = szd + uuz*qsjd
        sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + szd
        sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
        sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + syd
        sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
        sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + sxd
        sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
        sx = si(i-1, j, k, 1) + si(i, j, k, 1)
        sy = si(i-1, j, k, 2) + si(i, j, k, 2)
        sz = si(i-1, j, k, 3) + si(i, j, k, 3)
        temp0 = sx**2 + sy**2 + sz**2
        if (cc2*temp0 .eq. 0.0_8) then
          tempd1 = 0.0
        else
          tempd1 = half*radid(i, j, k)/(2.0*sqrt(cc2*temp0))
        end if
        tempd2 = cc2*tempd1
        abs0d = half*radid(i, j, k)
        cc2d = cc2d + temp0*tempd1
        sxd = 2*sx*tempd2
        syd = 2*sy*tempd2
        szd = 2*sz*tempd2
        radid(i, j, k) = 0.0_8
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          qsid = abs0d
        else
          qsid = -abs0d
        end if
        uuxd = uuxd + sx*qsid
        sxd = sxd + uux*qsid
        uuyd = uuyd + sy*qsid
        syd = syd + uuy*qsid
        uuzd = uuzd + sz*qsid
        szd = szd + uuz*qsid
        sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + szd
        sid(i, j, k, 3) = sid(i, j, k, 3) + szd
        sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + syd
        sid(i, j, k, 2) = sid(i, j, k, 2) + syd
        sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + sxd
        sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          clim2d = clim2d + cc2d
          cc2d = 0.0_8
        end if
        temp = w(i, j, k, irho)
        tempd0 = gamma(i, j, k)*cc2d/temp
        pd(i, j, k) = pd(i, j, k) + tempd0
        wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd0/temp
        wd(i, j, k, ivz) = wd(i, j, k, ivz) + uuzd
        wd(i, j, k, ivy) = wd(i, j, k, ivy) + uuyd
        wd(i, j, k, ivx) = wd(i, j, k, ivx) + uuxd
      end do
    case (turkel) 
      clim2d = 0.0_8
    case (choimerkle) 
      clim2d = 0.0_8
    case default
      clim2d = 0.0_8
    end select
    tempd = 0.000001_realtype*clim2d/rhoinf
    gammainfd = gammainfd + pinfcorr*tempd
    pinfcorrd = pinfcorrd + gammainf*tempd
    rhoinfd = rhoinfd - gammainf*pinfcorr*tempd/rhoinf
  end if
end subroutine timestep_block_b

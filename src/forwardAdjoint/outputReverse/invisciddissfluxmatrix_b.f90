!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of invisciddissfluxmatrix in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *p *w *si *sj *sk *fw
!   with respect to varying inputs: pinfcorr *p *w *si *sj *sk
!   plus diff mem management of: p:in w:in si:in sj:in sk:in fw:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          invisciddissfluxmatrix.f90                      *
!      * author:        edwin van der weide                             *
!      * starting date: 03-25-2003                                      *
!      * last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine invisciddissfluxmatrix_b()
!
!      ******************************************************************
!      *                                                                *
!      * invisciddissfluxmatrix computes the matrix artificial          *
!      * dissipation term. instead of the spectral radius, as used in   *
!      * the scalar dissipation scheme, the absolute value of the flux  *
!      * jacobian is used. this leads to a less diffusive and           *
!      * consequently more accurate scheme. it is assumed that the      *
!      * pointers in blockpointers already point to the correct block.  *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use cgnsgrid
  use constants
  use flowvarrefstate
  use inputdiscretization
  use inputphysics
  use iteration
  implicit none
!
!      local parameters.
!
  real(kind=realtype), parameter :: dpmax=0.25_realtype
  real(kind=realtype), parameter :: epsacoustic=0.25_realtype
  real(kind=realtype), parameter :: epsshear=0.025_realtype
  real(kind=realtype), parameter :: omega=0.5_realtype
  real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ind
  real(kind=realtype) :: plim, sface
  real(kind=realtype) :: plimd, sfaced
  real(kind=realtype) :: sfil, fis2, fis4
  real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
  real(kind=realtype) :: ppor, rrad, dis2, dis4
  real(kind=realtype) :: rradd, dis2d, dis4d
  real(kind=realtype) :: dp1, dp2, ddw, tmp, fs
  real(kind=realtype) :: dp1d, dp2d, ddwd, tmpd, fsd
  real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
  real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd, sxd, syd, &
& szd
  real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
  real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
  real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
  real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
  real(kind=realtype) :: kavg, lam1, lam2, lam3, area
  real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d, aread
  real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
  real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, abv7d
  logical :: correctfork
  intrinsic abs
  intrinsic max
  intrinsic min
  real(kind=realtype) :: dim
  intrinsic sqrt
  real(kind=realtype) :: arg1
  real(kind=realtype) :: arg1d
  integer :: branch
  real(kind=realtype) :: temp3
  real(kind=realtype) :: tempd14
  real(kind=realtype) :: temp29
  real(kind=realtype) :: temp2
  real(kind=realtype) :: tempd13
  real(kind=realtype) :: temp28
  real(kind=realtype) :: temp1
  real(kind=realtype) :: tempd12
  real(kind=realtype) :: temp27
  real(kind=realtype) :: min5d
  real(kind=realtype) :: tempd49
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd11
  real(kind=realtype) :: temp26
  real(kind=realtype) :: tempd48
  real(kind=realtype) :: tempd10
  real(kind=realtype) :: temp25
  real(kind=realtype) :: tempd47
  real(kind=realtype) :: temp24
  real(kind=realtype) :: x6d
  real(kind=realtype) :: tempd46
  real(kind=realtype) :: y4d
  real(kind=realtype) :: temp23
  real(kind=realtype) :: tempd45
  real(kind=realtype) :: temp22
  real(kind=realtype) :: tempd44
  real(kind=realtype) :: temp21
  real(kind=realtype) :: tempd43
  real(kind=realtype) :: temp58
  real(kind=realtype) :: temp20
  real(kind=realtype) :: tempd42
  real(kind=realtype) :: temp57
  real(kind=realtype) :: abs1d
  real(kind=realtype) :: tempd41
  real(kind=realtype) :: temp56
  real(kind=realtype) :: min6
  real(kind=realtype) :: tempd40
  real(kind=realtype) :: temp55
  real(kind=realtype) :: min5
  real(kind=realtype) :: temp54
  real(kind=realtype) :: min4
  real(kind=realtype) :: max2d
  real(kind=realtype) :: temp53
  real(kind=realtype) :: min3
  real(kind=realtype) :: temp52
  real(kind=realtype) :: min2
  real(kind=realtype) :: temp51
  real(kind=realtype) :: min1
  real(kind=realtype) :: temp50
  real(kind=realtype) :: abs4d
  real(kind=realtype) :: abs11d
  real(kind=realtype) :: abs7d
  real(kind=realtype) :: x6
  real(kind=realtype) :: x5
  real(kind=realtype) :: min1d
  real(kind=realtype) :: x4
  real(kind=realtype) :: x3
  real(kind=realtype) :: x2
  real(kind=realtype) :: x2d
  real(kind=realtype) :: x1
  real(kind=realtype) :: temp19
  real(kind=realtype) :: temp18
  real(kind=realtype) :: temp17
  real(kind=realtype) :: min4d
  real(kind=realtype) :: tempd39
  real(kind=realtype) :: temp16
  real(kind=realtype) :: tempd38
  real(kind=realtype) :: temp15
  real(kind=realtype) :: tempd37
  real(kind=realtype) :: temp14
  real(kind=realtype) :: x5d
  real(kind=realtype) :: tempd36
  real(kind=realtype) :: temp13
  real(kind=realtype) :: y3d
  real(kind=realtype) :: tempd35
  real(kind=realtype) :: temp12
  real(kind=realtype) :: tempd34
  real(kind=realtype) :: temp49
  real(kind=realtype) :: temp11
  real(kind=realtype) :: tempd33
  real(kind=realtype) :: temp48
  real(kind=realtype) :: temp10
  real(kind=realtype) :: tempd32
  real(kind=realtype) :: temp47
  real(kind=realtype) :: tempd31
  real(kind=realtype) :: temp46
  real(kind=realtype) :: tempd30
  real(kind=realtype) :: temp45
  real(kind=realtype) :: temp44
  real(kind=realtype) :: max1d
  real(kind=realtype) :: y6d
  real(kind=realtype) :: temp43
  real(kind=realtype) :: temp42
  real(kind=realtype) :: temp41
  real(kind=realtype) :: temp40
  real(kind=realtype) :: abs3d
  real(kind=realtype) :: abs10d
  real(kind=realtype) :: tempd9
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd8
  real(kind=realtype) :: tempd7
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: abs6d
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: abs12
  real(kind=realtype) :: x1d
  real(kind=realtype) :: abs11
  real(kind=realtype) :: abs10
  real(kind=realtype) :: abs9d
  real(kind=realtype) :: min3d
  real(kind=realtype) :: tempd29
  real(kind=realtype) :: tempd28
  real(kind=realtype) :: tempd27
  real(kind=realtype) :: x4d
  real(kind=realtype) :: tempd26
  real(kind=realtype) :: y2d
  real(kind=realtype) :: tempd25
  real(kind=realtype) :: tempd24
  real(kind=realtype) :: temp39
  real(kind=realtype) :: tempd23
  real(kind=realtype) :: temp38
  real(kind=realtype) :: tempd22
  real(kind=realtype) :: temp37
  real(kind=realtype) :: min6d
  real(kind=realtype) :: abs9
  real(kind=realtype) :: tempd21
  real(kind=realtype) :: temp36
  real(kind=realtype) :: abs8
  real(kind=realtype) :: tempd20
  real(kind=realtype) :: temp35
  real(kind=realtype) :: abs7
  real(kind=realtype) :: temp34
  real(kind=realtype) :: abs6
  real(kind=realtype) :: temp33
  real(kind=realtype) :: y5d
  real(kind=realtype) :: abs5
  real(kind=realtype) :: temp32
  real(kind=realtype) :: abs4
  real(kind=realtype) :: temp31
  real(kind=realtype) :: abs3
  real(kind=realtype) :: temp30
  real(kind=realtype) :: abs2
  real(kind=realtype) :: abs2d
  real(kind=realtype) :: abs1
  real(kind=realtype) :: abs0
  real(kind=realtype) :: max3d
  real(kind=realtype) :: abs5d
  real(kind=realtype) :: abs12d
  real(kind=realtype) :: temp
  real(kind=realtype) :: max3
  real(kind=realtype) :: max2
  real(kind=realtype) :: abs8d
  real(kind=realtype) :: y6
  real(kind=realtype) :: max1
  real(kind=realtype) :: temp9
  real(kind=realtype) :: y5
  real(kind=realtype) :: min2d
  real(kind=realtype) :: temp8
  real(kind=realtype) :: tempd19
  real(kind=realtype) :: y4
  real(kind=realtype) :: temp7
  real(kind=realtype) :: tempd18
  real(kind=realtype) :: y3
  real(kind=realtype) :: temp6
  real(kind=realtype) :: tempd17
  real(kind=realtype) :: y2
  real(kind=realtype) :: temp5
  real(kind=realtype) :: x3d
  real(kind=realtype) :: tempd16
  real(kind=realtype) :: y1
  real(kind=realtype) :: y1d
  real(kind=realtype) :: temp4
  real(kind=realtype) :: tempd15
  if (rfil .ge. 0.) then
    abs0 = rfil
  else
    abs0 = -rfil
  end if
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
  if (abs0 .lt. thresholdreal) then
    pinfcorrd = 0.0_8
  else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
    plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .eq. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
! set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the i-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do j=2,jl
        if (p(2, j, k) - p(1, j, k) .ge. 0.) then
          call pushreal8(abs1)
          abs1 = p(2, j, k) - p(1, j, k)
          call pushcontrol1b(1)
        else
          call pushreal8(abs1)
          abs1 = -(p(2, j, k)-p(1, j, k))
          call pushcontrol1b(0)
        end if
        if (p(1, j, k) - p(0, j, k) .ge. 0.) then
          call pushreal8(abs7)
          abs7 = p(1, j, k) - p(0, j, k)
          call pushcontrol1b(0)
        else
          call pushreal8(abs7)
          abs7 = -(p(1, j, k)-p(0, j, k))
          call pushcontrol1b(1)
        end if
        x1 = (p(2, j, k)-two*p(1, j, k)+p(0, j, k))/(omega*(p(2, j, k)+&
&         two*p(1, j, k)+p(0, j, k))+oneminomega*(abs1+abs7)+plim)
        if (x1 .ge. 0.) then
          dp1 = x1
          call pushcontrol1b(0)
        else
          dp1 = -x1
          call pushcontrol1b(1)
        end if
! loop in i-direction.
        do i=1,il
          if (p(i+2, j, k) - p(i+1, j, k) .ge. 0.) then
            call pushreal8(abs2)
            abs2 = p(i+2, j, k) - p(i+1, j, k)
            call pushcontrol1b(1)
          else
            call pushreal8(abs2)
            abs2 = -(p(i+2, j, k)-p(i+1, j, k))
            call pushcontrol1b(0)
          end if
          if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
            call pushreal8(abs8)
            abs8 = p(i+1, j, k) - p(i, j, k)
            call pushcontrol1b(0)
          else
            call pushreal8(abs8)
            abs8 = -(p(i+1, j, k)-p(i, j, k))
            call pushcontrol1b(1)
          end if
          x2 = (p(i+2, j, k)-two*p(i+1, j, k)+p(i, j, k))/(omega*(p(i+2&
&           , j, k)+two*p(i+1, j, k)+p(i, j, k))+oneminomega*(abs2+abs8)&
&           +plim)
          if (x2 .ge. 0.) then
            dp2 = x2
            call pushcontrol1b(0)
          else
            dp2 = -x2
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (pori(i, j, k) .eq. normalflux) ppor = one
          if (lumpeddiss) then
            if (dp1 .lt. dp2) then
              y1 = dp2
              call pushcontrol1b(0)
            else
              y1 = dp1
              call pushcontrol1b(1)
            end if
            if (dpmax .gt. y1) then
              min1 = y1
              call pushcontrol1b(0)
            else
              min1 = dpmax
              call pushcontrol1b(1)
            end if
            call pushreal8(dis2)
            dis2 = fis2*ppor*min1 + sigma*fis4*ppor
            call pushreal8(dis4)
            dis4 = 0.0
            call pushcontrol1b(0)
          else
            if (dp1 .lt. dp2) then
              y2 = dp2
              call pushcontrol1b(0)
            else
              y2 = dp1
              call pushcontrol1b(1)
            end if
            if (dpmax .gt. y2) then
              min2 = y2
              call pushcontrol1b(0)
            else
              min2 = dpmax
              call pushcontrol1b(1)
            end if
            call pushreal8(dis2)
            dis2 = ppor*fis2*min2
            arg1 = ppor*fis4
            call pushreal8(dis4)
            dis4 = dim(arg1, dis2)
            call pushcontrol1b(1)
          end if
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          call pushreal8(dr)
          dr = dis2*ddw - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-&
&           three*ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          call pushreal8(dru)
          dru = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(&
&           i-1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          call pushreal8(drv)
          drv = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(&
&           i-1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          call pushreal8(drw)
          drw = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(&
&           i-1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          call pushreal8(dre)
          dre = dis2*ddw - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)&
&           -three*ddw)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drk = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw)
            kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
            call pushcontrol1b(1)
          else
            drk = zero
            kavg = zero
            call pushcontrol1b(0)
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
          call pushreal8(a2avg)
          a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          call pushreal8(sx)
          sx = si(i, j, k, 1)
          call pushreal8(sy)
          sy = si(i, j, k, 2)
          call pushreal8(sz)
          sz = si(i, j, k, 3)
          call pushreal8(area)
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            call pushreal8(max1)
            max1 = area
            call pushcontrol1b(0)
          else
            call pushreal8(max1)
            max1 = 1.e-25_realtype
            call pushcontrol1b(1)
          end if
          tmp = one/max1
          call pushreal8(sx)
          sx = sx*tmp
          call pushreal8(sy)
          sy = sy*tmp
          call pushreal8(sz)
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call pushreal8(havg)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          call pushreal8(aavg)
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sface = sfacei(i, j, k)*tmp
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1 = unavg - sface + aavg
            call pushcontrol1b(0)
          else
            lam1 = -(unavg-sface+aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2 = unavg - sface - aavg
            call pushcontrol1b(0)
          else
            lam2 = -(unavg-sface-aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface .ge. 0.) then
            call pushreal8(lam3)
            lam3 = unavg - sface
            call pushcontrol1b(0)
          else
            call pushreal8(lam3)
            lam3 = -(unavg-sface)
            call pushcontrol1b(1)
          end if
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3 = epsshear*rrad
            call pushcontrol1b(0)
          else
            lam3 = lam3
            call pushcontrol1b(1)
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          call pushreal8(lam1)
          lam1 = lam1*area
          call pushreal8(lam2)
          lam2 = lam2*area
          call pushreal8(lam3)
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          call pushreal8(abv2)
          abv2 = half*(lam1-lam2)
          call pushreal8(abv3)
          abv3 = abv1 - lam3
          call pushreal8(abv4)
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
          dp1 = dp2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the j-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do i=2,il
        if (p(i, 2, k) - p(i, 1, k) .ge. 0.) then
          call pushreal8(abs3)
          abs3 = p(i, 2, k) - p(i, 1, k)
          call pushcontrol1b(1)
        else
          call pushreal8(abs3)
          abs3 = -(p(i, 2, k)-p(i, 1, k))
          call pushcontrol1b(0)
        end if
        if (p(i, 1, k) - p(i, 0, k) .ge. 0.) then
          call pushreal8(abs9)
          abs9 = p(i, 1, k) - p(i, 0, k)
          call pushcontrol1b(0)
        else
          call pushreal8(abs9)
          abs9 = -(p(i, 1, k)-p(i, 0, k))
          call pushcontrol1b(1)
        end if
        x3 = (p(i, 2, k)-two*p(i, 1, k)+p(i, 0, k))/(omega*(p(i, 2, k)+&
&         two*p(i, 1, k)+p(i, 0, k))+oneminomega*(abs3+abs9)+plim)
        if (x3 .ge. 0.) then
          dp1 = x3
          call pushcontrol1b(0)
        else
          dp1 = -x3
          call pushcontrol1b(1)
        end if
! loop in j-direction.
        do j=1,jl
          if (p(i, j+2, k) - p(i, j+1, k) .ge. 0.) then
            call pushreal8(abs4)
            abs4 = p(i, j+2, k) - p(i, j+1, k)
            call pushcontrol1b(1)
          else
            call pushreal8(abs4)
            abs4 = -(p(i, j+2, k)-p(i, j+1, k))
            call pushcontrol1b(0)
          end if
          if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
            call pushreal8(abs10)
            abs10 = p(i, j+1, k) - p(i, j, k)
            call pushcontrol1b(0)
          else
            call pushreal8(abs10)
            abs10 = -(p(i, j+1, k)-p(i, j, k))
            call pushcontrol1b(1)
          end if
          x4 = (p(i, j+2, k)-two*p(i, j+1, k)+p(i, j, k))/(omega*(p(i, j&
&           +2, k)+two*p(i, j+1, k)+p(i, j, k))+oneminomega*(abs4+abs10)&
&           +plim)
          if (x4 .ge. 0.) then
            dp2 = x4
            call pushcontrol1b(0)
          else
            dp2 = -x4
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (porj(i, j, k) .eq. normalflux) ppor = one
          if (lumpeddiss) then
            if (dp1 .lt. dp2) then
              y3 = dp2
              call pushcontrol1b(0)
            else
              y3 = dp1
              call pushcontrol1b(1)
            end if
            if (dpmax .gt. y3) then
              min3 = y3
              call pushcontrol1b(0)
            else
              min3 = dpmax
              call pushcontrol1b(1)
            end if
            call pushreal8(dis2)
            dis2 = fis2*ppor*min3 + sigma*fis4*ppor
            call pushreal8(dis4)
            dis4 = 0.0
            call pushcontrol1b(0)
          else
            if (dp1 .lt. dp2) then
              y4 = dp2
              call pushcontrol1b(0)
            else
              y4 = dp1
              call pushcontrol1b(1)
            end if
            if (dpmax .gt. y4) then
              min4 = y4
              call pushcontrol1b(0)
            else
              min4 = dpmax
              call pushcontrol1b(1)
            end if
            call pushreal8(dis2)
            dis2 = ppor*fis2*min4
            arg1 = ppor*fis4
            call pushreal8(dis4)
            dis4 = dim(arg1, dis2)
            call pushcontrol1b(1)
          end if
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          call pushreal8(dr)
          dr = dis2*ddw - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-&
&           three*ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          call pushreal8(dru)
          dru = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(&
&           i, j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          call pushreal8(drv)
          drv = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(&
&           i, j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          call pushreal8(drw)
          drw = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(&
&           i, j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          call pushreal8(dre)
          dre = dis2*ddw - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)&
&           -three*ddw)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drk = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw)
            kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
            call pushcontrol1b(1)
          else
            drk = zero
            kavg = zero
            call pushcontrol1b(0)
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
          call pushreal8(a2avg)
          a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          call pushreal8(sx)
          sx = sj(i, j, k, 1)
          call pushreal8(sy)
          sy = sj(i, j, k, 2)
          call pushreal8(sz)
          sz = sj(i, j, k, 3)
          call pushreal8(area)
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            call pushreal8(max2)
            max2 = area
            call pushcontrol1b(0)
          else
            call pushreal8(max2)
            max2 = 1.e-25_realtype
            call pushcontrol1b(1)
          end if
          tmp = one/max2
          call pushreal8(sx)
          sx = sx*tmp
          call pushreal8(sy)
          sy = sy*tmp
          call pushreal8(sz)
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call pushreal8(havg)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          call pushreal8(aavg)
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sface = sfacej(i, j, k)*tmp
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1 = unavg - sface + aavg
            call pushcontrol1b(0)
          else
            lam1 = -(unavg-sface+aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2 = unavg - sface - aavg
            call pushcontrol1b(0)
          else
            lam2 = -(unavg-sface-aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface .ge. 0.) then
            call pushreal8(lam3)
            lam3 = unavg - sface
            call pushcontrol1b(0)
          else
            call pushreal8(lam3)
            lam3 = -(unavg-sface)
            call pushcontrol1b(1)
          end if
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3 = epsshear*rrad
            call pushcontrol1b(0)
          else
            lam3 = lam3
            call pushcontrol1b(1)
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          call pushreal8(lam1)
          lam1 = lam1*area
          call pushreal8(lam2)
          lam2 = lam2*area
          call pushreal8(lam3)
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          call pushreal8(abv2)
          abv2 = half*(lam1-lam2)
          call pushreal8(abv3)
          abv3 = abv1 - lam3
          call pushreal8(abv4)
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
          dp1 = dp2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the k-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do j=2,jl
      do i=2,il
        if (p(i, j, 2) - p(i, j, 1) .ge. 0.) then
          call pushreal8(abs5)
          abs5 = p(i, j, 2) - p(i, j, 1)
          call pushcontrol1b(1)
        else
          call pushreal8(abs5)
          abs5 = -(p(i, j, 2)-p(i, j, 1))
          call pushcontrol1b(0)
        end if
        if (p(i, j, 1) - p(i, j, 0) .ge. 0.) then
          call pushreal8(abs11)
          abs11 = p(i, j, 1) - p(i, j, 0)
          call pushcontrol1b(0)
        else
          call pushreal8(abs11)
          abs11 = -(p(i, j, 1)-p(i, j, 0))
          call pushcontrol1b(1)
        end if
        x5 = (p(i, j, 2)-two*p(i, j, 1)+p(i, j, 0))/(omega*(p(i, j, 2)+&
&         two*p(i, j, 1)+p(i, j, 0))+oneminomega*(abs5+abs11)+plim)
        if (x5 .ge. 0.) then
          dp1 = x5
          call pushcontrol1b(0)
        else
          dp1 = -x5
          call pushcontrol1b(1)
        end if
! loop in k-direction.
        do k=1,kl
          if (p(i, j, k+2) - p(i, j, k+1) .ge. 0.) then
            call pushreal8(abs6)
            abs6 = p(i, j, k+2) - p(i, j, k+1)
            call pushcontrol1b(1)
          else
            call pushreal8(abs6)
            abs6 = -(p(i, j, k+2)-p(i, j, k+1))
            call pushcontrol1b(0)
          end if
          if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
            call pushreal8(abs12)
            abs12 = p(i, j, k+1) - p(i, j, k)
            call pushcontrol1b(0)
          else
            call pushreal8(abs12)
            abs12 = -(p(i, j, k+1)-p(i, j, k))
            call pushcontrol1b(1)
          end if
          x6 = (p(i, j, k+2)-two*p(i, j, k+1)+p(i, j, k))/(omega*(p(i, j&
&           , k+2)+two*p(i, j, k+1)+p(i, j, k))+oneminomega*(abs6+abs12)&
&           +plim)
          if (x6 .ge. 0.) then
            dp2 = x6
            call pushcontrol1b(0)
          else
            dp2 = -x6
            call pushcontrol1b(1)
          end if
! compute the dissipation coefficients for this face.
          call pushreal8(ppor)
          ppor = zero
          if (pork(i, j, k) .eq. normalflux) ppor = one
          if (lumpeddiss) then
            if (dp1 .lt. dp2) then
              y5 = dp2
              call pushcontrol1b(0)
            else
              y5 = dp1
              call pushcontrol1b(1)
            end if
            if (dpmax .gt. y5) then
              min5 = y5
              call pushcontrol1b(0)
            else
              min5 = dpmax
              call pushcontrol1b(1)
            end if
            call pushreal8(dis2)
            dis2 = fis2*ppor*min5 + sigma*fis4*ppor
            call pushreal8(dis4)
            dis4 = 0.0
            call pushcontrol1b(0)
          else
            if (dp1 .lt. dp2) then
              y6 = dp2
              call pushcontrol1b(0)
            else
              y6 = dp1
              call pushcontrol1b(1)
            end if
            if (dpmax .gt. y6) then
              min6 = y6
              call pushcontrol1b(0)
            else
              min6 = dpmax
              call pushcontrol1b(1)
            end if
            call pushreal8(dis2)
            dis2 = ppor*fis2*min6
            arg1 = ppor*fis4
            call pushreal8(dis4)
            dis4 = dim(arg1, dis2)
            call pushcontrol1b(1)
          end if
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          call pushreal8(dr)
          dr = dis2*ddw - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)-&
&           three*ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          call pushreal8(dru)
          dru = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)-w(&
&           i, j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          call pushreal8(drv)
          drv = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)-w(&
&           i, j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          call pushreal8(drw)
          drw = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)-w(&
&           i, j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw)
          call pushreal8(ddw)
          ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          call pushreal8(dre)
          dre = dis2*ddw - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, irhoe)&
&           -three*ddw)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drk = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, itu1)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw)
            kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
            call pushcontrol1b(1)
          else
            drk = zero
            kavg = zero
            call pushcontrol1b(0)
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
          call pushreal8(a2avg)
          a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          call pushreal8(sx)
          sx = sk(i, j, k, 1)
          call pushreal8(sy)
          sy = sk(i, j, k, 2)
          call pushreal8(sz)
          sz = sk(i, j, k, 3)
          call pushreal8(area)
          area = sqrt(sx**2 + sy**2 + sz**2)
          if (1.e-25_realtype .lt. area) then
            call pushreal8(max3)
            max3 = area
            call pushcontrol1b(0)
          else
            call pushreal8(max3)
            max3 = 1.e-25_realtype
            call pushcontrol1b(1)
          end if
          tmp = one/max3
          call pushreal8(sx)
          sx = sx*tmp
          call pushreal8(sy)
          sy = sy*tmp
          call pushreal8(sz)
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call pushreal8(havg)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          call pushreal8(aavg)
          aavg = sqrt(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sface = sfacek(i, j, k)*tmp
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1 = unavg - sface + aavg
            call pushcontrol1b(0)
          else
            lam1 = -(unavg-sface+aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2 = unavg - sface - aavg
            call pushcontrol1b(0)
          else
            lam2 = -(unavg-sface-aavg)
            call pushcontrol1b(1)
          end if
          if (unavg - sface .ge. 0.) then
            call pushreal8(lam3)
            lam3 = unavg - sface
            call pushcontrol1b(0)
          else
            call pushreal8(lam3)
            lam3 = -(unavg-sface)
            call pushcontrol1b(1)
          end if
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2 = epsacoustic*rrad
            call pushcontrol1b(0)
          else
            call pushcontrol1b(1)
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3 = epsshear*rrad
            call pushcontrol1b(0)
          else
            lam3 = lam3
            call pushcontrol1b(1)
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          call pushreal8(lam1)
          lam1 = lam1*area
          call pushreal8(lam2)
          lam2 = lam2*area
          call pushreal8(lam3)
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          call pushreal8(abv2)
          abv2 = half*(lam1-lam2)
          call pushreal8(abv3)
          abv3 = abv1 - lam3
          call pushreal8(abv4)
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
! compute and scatter the dissipative flux.
! density.
! x-momentum.
! y-momentum.
! z-momentum.
! energy.
! set dp1 to dp2 for the next face.
          dp1 = dp2
        end do
      end do
    end do
    plimd = 0.0_8
    sfaced = 0.0_8
    do j=jl,2,-1
      do i=il,2,-1
        dp1d = 0.0_8
        do k=kl,1,-1
          dp2d = dp1d
          fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
          wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
          vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
          uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
          unavg = uavg*sx + vavg*sy + wavg*sz
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          ovaavg = one/aavg
          ova2avg = one/a2avg
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
          lam3d = dre*fsd
          dred = lam3*fsd
          havgd = abv6*fsd
          abv6d = havg*fsd
          unavgd = abv7*fsd
          abv7d = unavg*fsd
          fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
          lam3d = lam3d + drw*fsd
          drwd = lam3*fsd
          wavgd = abv6*fsd
          abv6d = abv6d + wavg*fsd
          szd = abv7*fsd
          abv7d = abv7d + sz*fsd
          fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
          lam3d = lam3d + drv*fsd
          drvd = lam3*fsd
          vavgd = abv6*fsd
          abv6d = abv6d + vavg*fsd
          syd = abv7*fsd
          abv7d = abv7d + sy*fsd
          fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
          lam3d = lam3d + dru*fsd
          drud = lam3*fsd
          uavgd = abv6*fsd
          abv6d = abv6d + uavg*fsd
          sxd = abv7*fsd
          abv7d = abv7d + sx*fsd
          fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
          abv6d = abv6d + fsd
          abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
          abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
          ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
          abv3d = ova2avg*abv4*abv6d + abv5*abv7d
          lam3d = lam3d + dr*fsd - abv3d
          abv5d = ovaavg*abv2*abv6d + abv3*abv7d
          ova2avgd = abv3*abv4*abv6d
          sxd = sxd + dru*abv5d
          syd = syd + drv*abv5d
          szd = szd + drw*abv5d
          unavgd = unavgd - dr*abv5d
          gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
          gm1 = gammaavg - one
          gm53 = gammaavg - five*third
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call popreal8(abv4)
          tempd49 = gm1*abv4d
          drd = alphaavg*tempd49 - unavg*abv5d + lam3*fsd
          drud = drud + sx*abv5d - uavg*tempd49
          drvd = drvd + sy*abv5d - vavg*tempd49
          drwd = drwd + sz*abv5d - wavg*tempd49
          alphaavgd = dr*tempd49
          uavgd = uavgd - dru*tempd49
          vavgd = vavgd - drv*tempd49
          dred = dred + tempd49
          wavgd = wavgd - drw*tempd49
          drkd = -(gm53*abv4d)
          call popreal8(abv3)
          abv1d = abv3d
          call popreal8(abv2)
          lam1d = half*abv1d + half*abv2d
          lam2d = half*abv1d - half*abv2d
          call popreal8(lam3)
          call popreal8(lam2)
          call popreal8(lam1)
          aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
          lam3d = area*lam3d
          lam2d = area*lam2d
          lam1d = area*lam1d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = epsshear*lam3d
            lam3d = 0.0_8
          else
            rradd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam2d
            lam2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam1d
            lam1d = 0.0_8
          end if
          lam3d = lam3d + rradd
          aavgd = rradd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam3)
            unavgd = unavgd + lam3d
            sfaced = sfaced - lam3d
          else
            call popreal8(lam3)
            sfaced = sfaced + lam3d
            unavgd = unavgd - lam3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam2d
            sfaced = sfaced - lam2d
            aavgd = aavgd - lam2d
          else
            sfaced = sfaced + lam2d
            unavgd = unavgd - lam2d
            aavgd = aavgd + lam2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam1d
            sfaced = sfaced - lam1d
            aavgd = aavgd + lam1d
          else
            sfaced = sfaced + lam1d
            unavgd = unavgd - lam1d
            aavgd = aavgd - lam1d
          end if
          tmp = one/max3
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            tmpd = 0.0_8
          else
            tmpd = sfacek(i, j, k)*sfaced
            sfaced = 0.0_8
          end if
          alphaavgd = alphaavgd + havgd
          tempd48 = half*alphaavgd
          ovgm1 = one/gm1
          aavgd = aavgd - one*ovaavgd/aavg**2
          if (a2avg .eq. 0.0_8) then
            a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
          else
            a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&             ova2avgd/a2avg**2
          end if
          uavgd = uavgd + 2*uavg*tempd48 + sx*unavgd
          sxd = sxd + uavg*unavgd
          vavgd = vavgd + 2*vavg*tempd48 + sy*unavgd
          syd = syd + vavg*unavgd
          wavgd = wavgd + 2*wavg*tempd48 + sz*unavgd
          szd = szd + wavg*unavgd
          call popreal8(aavg)
          call popreal8(havg)
          kavgd = -(ovgm1*gm53*havgd)
          call popreal8(sz)
          call popreal8(sy)
          call popreal8(sx)
          tmpd = tmpd + sy*syd + sx*sxd + sz*szd
          szd = tmp*szd
          syd = tmp*syd
          sxd = tmp*sxd
          max3d = -(one*tmpd/max3**2)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max3)
            aread = aread + max3d
          else
            call popreal8(max3)
          end if
          call popreal8(area)
          if (sx**2 + sy**2 + sz**2 .eq. 0.0_8) then
            tempd45 = 0.0
          else
            tempd45 = aread/(2.0*sqrt(sx**2+sy**2+sz**2))
          end if
          sxd = sxd + 2*sx*tempd45
          syd = syd + 2*sy*tempd45
          szd = szd + 2*sz*tempd45
          call popreal8(sz)
          skd(i, j, k, 3) = skd(i, j, k, 3) + szd
          call popreal8(sy)
          skd(i, j, k, 2) = skd(i, j, k, 2) + syd
          call popreal8(sx)
          skd(i, j, k, 1) = skd(i, j, k, 1) + sxd
          call popreal8(a2avg)
          temp58 = w(i, j, k, irho)
          temp57 = w(i, j, k+1, irho)
          tempd46 = gamma(i, j, k+1)*half*a2avgd/temp57
          tempd47 = gamma(i, j, k)*half*a2avgd/temp58
          pd(i, j, k+1) = pd(i, j, k+1) + tempd46
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) - p(i, j, k+1)*&
&           tempd46/temp57
          pd(i, j, k) = pd(i, j, k) + tempd47
          wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd47/&
&           temp58
          wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + half*wavgd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
          wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + half*vavgd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
          wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + half*uavgd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dis2d = 0.0_8
            dis4d = 0.0_8
          else
            wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + half*kavgd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
            temp56 = w(i, j, k-1, itu1)
            temp55 = w(i, j, k-1, irho)
            temp54 = w(i, j, k+2, itu1)
            temp53 = w(i, j, k+2, irho)
            tempd44 = -(dis4*drkd)
            dis2d = ddw*drkd
            ddwd = dis2*drkd - three*tempd44
            dis4d = -((temp53*temp54-temp55*temp56-three*ddw)*drkd)
            wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp54*tempd44
            wd(i, j, k+2, itu1) = wd(i, j, k+2, itu1) + temp53*tempd44
            wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp56*tempd44
            wd(i, j, k-1, itu1) = wd(i, j, k-1, itu1) - temp55*tempd44
            wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, &
&             itu1)*ddwd
            wd(i, j, k+1, itu1) = wd(i, j, k+1, itu1) + w(i, j, k+1, &
&             irho)*ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&             ddwd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&             ddwd
          end if
          ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          call popreal8(dre)
          tempd39 = -(dis4*dred)
          dis2d = dis2d + ddw*dred
          ddwd = dis2*dred - three*tempd39
          dis4d = dis4d - (w(i, j, k+2, irhoe)-w(i, j, k-1, irhoe)-three&
&           *ddw)*dred
          wd(i, j, k+2, irhoe) = wd(i, j, k+2, irhoe) + tempd39
          wd(i, j, k-1, irhoe) = wd(i, j, k-1, irhoe) - tempd39
          call popreal8(ddw)
          wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          call popreal8(drw)
          temp52 = w(i, j, k-1, ivz)
          temp51 = w(i, j, k-1, irho)
          temp50 = w(i, j, k+2, ivz)
          temp49 = w(i, j, k+2, irho)
          tempd40 = -(dis4*drwd)
          dis2d = dis2d + ddw*drwd
          ddwd = dis2*drwd - three*tempd40
          dis4d = dis4d - (temp49*temp50-temp51*temp52-three*ddw)*drwd
          wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp50*tempd40
          wd(i, j, k+2, ivz) = wd(i, j, k+2, ivz) + temp49*tempd40
          wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp52*tempd40
          wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - temp51*tempd40
          call popreal8(ddw)
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
&           ddwd
          wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
          call popreal8(drv)
          temp48 = w(i, j, k-1, ivy)
          temp47 = w(i, j, k-1, irho)
          temp46 = w(i, j, k+2, ivy)
          temp45 = w(i, j, k+2, irho)
          tempd41 = -(dis4*drvd)
          dis2d = dis2d + ddw*drvd
          ddwd = dis2*drvd - three*tempd41
          dis4d = dis4d - (temp45*temp46-temp47*temp48-three*ddw)*drvd
          wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp46*tempd41
          wd(i, j, k+2, ivy) = wd(i, j, k+2, ivy) + temp45*tempd41
          wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp48*tempd41
          wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - temp47*tempd41
          call popreal8(ddw)
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
&           ddwd
          wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
          call popreal8(dru)
          temp44 = w(i, j, k-1, ivx)
          temp43 = w(i, j, k-1, irho)
          temp42 = w(i, j, k+2, ivx)
          temp41 = w(i, j, k+2, irho)
          tempd42 = -(dis4*drud)
          dis2d = dis2d + ddw*drud
          ddwd = dis2*drud - three*tempd42
          dis4d = dis4d - (temp41*temp42-temp43*temp44-three*ddw)*drud
          wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp42*tempd42
          wd(i, j, k+2, ivx) = wd(i, j, k+2, ivx) + temp41*tempd42
          wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp44*tempd42
          wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - temp43*tempd42
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
&           ddwd
          wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          call popreal8(dr)
          tempd43 = -(dis4*drd)
          dis2d = dis2d + ddw*drd
          ddwd = dis2*drd - three*tempd43
          dis4d = dis4d - (w(i, j, k+2, irho)-w(i, j, k-1, irho)-three*&
&           ddw)*drd
          wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + tempd43
          wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - tempd43
          call popreal8(ddw)
          wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(dis4)
            call popreal8(dis2)
            min5d = fis2*ppor*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              y5d = min5d
            else
              y5d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              dp2d = dp2d + y5d
              dp1d = 0.0_8
            else
              dp1d = y5d
            end if
          else
            arg1 = ppor*fis4
            call popreal8(dis4)
            arg1d = 0.0_8
            call dim_b(arg1, arg1d, dis2, dis2d, dis4d)
            call popreal8(dis2)
            min6d = ppor*fis2*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              y6d = min6d
            else
              y6d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              dp2d = dp2d + y6d
              dp1d = 0.0_8
            else
              dp1d = y6d
            end if
          end if
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x6d = dp2d
          else
            x6d = -dp2d
          end if
          temp40 = omega*(p(i, j, k+2)+two*p(i, j, k+1)+p(i, j, k)) + &
&           oneminomega*(abs6+abs12) + plim
          tempd36 = x6d/temp40
          tempd37 = -((p(i, j, k+2)-two*p(i, j, k+1)+p(i, j, k))*tempd36&
&           /temp40)
          tempd38 = omega*tempd37
          pd(i, j, k+2) = pd(i, j, k+2) + tempd38 + tempd36
          pd(i, j, k+1) = pd(i, j, k+1) + two*tempd38 - two*tempd36
          pd(i, j, k) = pd(i, j, k) + tempd38 + tempd36
          abs6d = oneminomega*tempd37
          abs12d = oneminomega*tempd37
          plimd = plimd + tempd37
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs12)
            pd(i, j, k+1) = pd(i, j, k+1) + abs12d
            pd(i, j, k) = pd(i, j, k) - abs12d
          else
            call popreal8(abs12)
            pd(i, j, k) = pd(i, j, k) + abs12d
            pd(i, j, k+1) = pd(i, j, k+1) - abs12d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs6)
            pd(i, j, k+1) = pd(i, j, k+1) + abs6d
            pd(i, j, k+2) = pd(i, j, k+2) - abs6d
          else
            call popreal8(abs6)
            pd(i, j, k+2) = pd(i, j, k+2) + abs6d
            pd(i, j, k+1) = pd(i, j, k+1) - abs6d
          end if
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x5d = dp1d
        else
          x5d = -dp1d
        end if
        temp39 = omega*(p(i, j, 2)+two*p(i, j, 1)+p(i, j, 0)) + &
&         oneminomega*(abs5+abs11) + plim
        tempd33 = x5d/temp39
        tempd34 = -((p(i, j, 2)-two*p(i, j, 1)+p(i, j, 0))*tempd33/&
&         temp39)
        tempd35 = omega*tempd34
        pd(i, j, 2) = pd(i, j, 2) + tempd35 + tempd33
        pd(i, j, 1) = pd(i, j, 1) + two*tempd35 - two*tempd33
        pd(i, j, 0) = pd(i, j, 0) + tempd35 + tempd33
        abs5d = oneminomega*tempd34
        abs11d = oneminomega*tempd34
        plimd = plimd + tempd34
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs11)
          pd(i, j, 1) = pd(i, j, 1) + abs11d
          pd(i, j, 0) = pd(i, j, 0) - abs11d
        else
          call popreal8(abs11)
          pd(i, j, 0) = pd(i, j, 0) + abs11d
          pd(i, j, 1) = pd(i, j, 1) - abs11d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs5)
          pd(i, j, 1) = pd(i, j, 1) + abs5d
          pd(i, j, 2) = pd(i, j, 2) - abs5d
        else
          call popreal8(abs5)
          pd(i, j, 2) = pd(i, j, 2) + abs5d
          pd(i, j, 1) = pd(i, j, 1) - abs5d
        end if
      end do
    end do
    do k=kl,2,-1
      do i=il,2,-1
        dp1d = 0.0_8
        do j=jl,1,-1
          dp2d = dp1d
          fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
          wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
          vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
          uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
          unavg = uavg*sx + vavg*sy + wavg*sz
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          ovaavg = one/aavg
          ova2avg = one/a2avg
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
          lam3d = dre*fsd
          dred = lam3*fsd
          havgd = abv6*fsd
          abv6d = havg*fsd
          unavgd = abv7*fsd
          abv7d = unavg*fsd
          fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
          lam3d = lam3d + drw*fsd
          drwd = lam3*fsd
          wavgd = abv6*fsd
          abv6d = abv6d + wavg*fsd
          szd = abv7*fsd
          abv7d = abv7d + sz*fsd
          fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
          lam3d = lam3d + drv*fsd
          drvd = lam3*fsd
          vavgd = abv6*fsd
          abv6d = abv6d + vavg*fsd
          syd = abv7*fsd
          abv7d = abv7d + sy*fsd
          fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
          lam3d = lam3d + dru*fsd
          drud = lam3*fsd
          uavgd = abv6*fsd
          abv6d = abv6d + uavg*fsd
          sxd = abv7*fsd
          abv7d = abv7d + sx*fsd
          fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
          abv6d = abv6d + fsd
          abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
          abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
          ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
          abv3d = ova2avg*abv4*abv6d + abv5*abv7d
          lam3d = lam3d + dr*fsd - abv3d
          abv5d = ovaavg*abv2*abv6d + abv3*abv7d
          ova2avgd = abv3*abv4*abv6d
          sxd = sxd + dru*abv5d
          syd = syd + drv*abv5d
          szd = szd + drw*abv5d
          unavgd = unavgd - dr*abv5d
          gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          gm53 = gammaavg - five*third
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call popreal8(abv4)
          tempd32 = gm1*abv4d
          drd = alphaavg*tempd32 - unavg*abv5d + lam3*fsd
          drud = drud + sx*abv5d - uavg*tempd32
          drvd = drvd + sy*abv5d - vavg*tempd32
          drwd = drwd + sz*abv5d - wavg*tempd32
          alphaavgd = dr*tempd32
          uavgd = uavgd - dru*tempd32
          vavgd = vavgd - drv*tempd32
          dred = dred + tempd32
          wavgd = wavgd - drw*tempd32
          drkd = -(gm53*abv4d)
          call popreal8(abv3)
          abv1d = abv3d
          call popreal8(abv2)
          lam1d = half*abv1d + half*abv2d
          lam2d = half*abv1d - half*abv2d
          call popreal8(lam3)
          call popreal8(lam2)
          call popreal8(lam1)
          aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
          lam3d = area*lam3d
          lam2d = area*lam2d
          lam1d = area*lam1d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = epsshear*lam3d
            lam3d = 0.0_8
          else
            rradd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam2d
            lam2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam1d
            lam1d = 0.0_8
          end if
          lam3d = lam3d + rradd
          aavgd = rradd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam3)
            unavgd = unavgd + lam3d
            sfaced = sfaced - lam3d
          else
            call popreal8(lam3)
            sfaced = sfaced + lam3d
            unavgd = unavgd - lam3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam2d
            sfaced = sfaced - lam2d
            aavgd = aavgd - lam2d
          else
            sfaced = sfaced + lam2d
            unavgd = unavgd - lam2d
            aavgd = aavgd + lam2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam1d
            sfaced = sfaced - lam1d
            aavgd = aavgd + lam1d
          else
            sfaced = sfaced + lam1d
            unavgd = unavgd - lam1d
            aavgd = aavgd - lam1d
          end if
          tmp = one/max2
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            tmpd = 0.0_8
          else
            tmpd = sfacej(i, j, k)*sfaced
            sfaced = 0.0_8
          end if
          alphaavgd = alphaavgd + havgd
          tempd31 = half*alphaavgd
          ovgm1 = one/gm1
          aavgd = aavgd - one*ovaavgd/aavg**2
          if (a2avg .eq. 0.0_8) then
            a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
          else
            a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&             ova2avgd/a2avg**2
          end if
          uavgd = uavgd + 2*uavg*tempd31 + sx*unavgd
          sxd = sxd + uavg*unavgd
          vavgd = vavgd + 2*vavg*tempd31 + sy*unavgd
          syd = syd + vavg*unavgd
          wavgd = wavgd + 2*wavg*tempd31 + sz*unavgd
          szd = szd + wavg*unavgd
          call popreal8(aavg)
          call popreal8(havg)
          kavgd = -(ovgm1*gm53*havgd)
          call popreal8(sz)
          call popreal8(sy)
          call popreal8(sx)
          tmpd = tmpd + sy*syd + sx*sxd + sz*szd
          szd = tmp*szd
          syd = tmp*syd
          sxd = tmp*sxd
          max2d = -(one*tmpd/max2**2)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max2)
            aread = aread + max2d
          else
            call popreal8(max2)
          end if
          call popreal8(area)
          if (sx**2 + sy**2 + sz**2 .eq. 0.0_8) then
            tempd28 = 0.0
          else
            tempd28 = aread/(2.0*sqrt(sx**2+sy**2+sz**2))
          end if
          sxd = sxd + 2*sx*tempd28
          syd = syd + 2*sy*tempd28
          szd = szd + 2*sz*tempd28
          call popreal8(sz)
          sjd(i, j, k, 3) = sjd(i, j, k, 3) + szd
          call popreal8(sy)
          sjd(i, j, k, 2) = sjd(i, j, k, 2) + syd
          call popreal8(sx)
          sjd(i, j, k, 1) = sjd(i, j, k, 1) + sxd
          call popreal8(a2avg)
          temp38 = w(i, j, k, irho)
          temp37 = w(i, j+1, k, irho)
          tempd29 = gamma(i, j+1, k)*half*a2avgd/temp37
          tempd30 = gamma(i, j, k)*half*a2avgd/temp38
          pd(i, j+1, k) = pd(i, j+1, k) + tempd29
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) - p(i, j+1, k)*&
&           tempd29/temp37
          pd(i, j, k) = pd(i, j, k) + tempd30
          wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd30/&
&           temp38
          wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + half*wavgd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
          wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + half*vavgd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
          wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + half*uavgd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dis2d = 0.0_8
            dis4d = 0.0_8
          else
            wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
            wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + half*kavgd
            temp36 = w(i, j-1, k, itu1)
            temp35 = w(i, j-1, k, irho)
            temp34 = w(i, j+2, k, itu1)
            temp33 = w(i, j+2, k, irho)
            tempd27 = -(dis4*drkd)
            dis2d = ddw*drkd
            ddwd = dis2*drkd - three*tempd27
            dis4d = -((temp33*temp34-temp35*temp36-three*ddw)*drkd)
            wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp34*tempd27
            wd(i, j+2, k, itu1) = wd(i, j+2, k, itu1) + temp33*tempd27
            wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp36*tempd27
            wd(i, j-1, k, itu1) = wd(i, j-1, k, itu1) - temp35*tempd27
            wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, &
&             itu1)*ddwd
            wd(i, j+1, k, itu1) = wd(i, j+1, k, itu1) + w(i, j+1, k, &
&             irho)*ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&             ddwd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&             ddwd
          end if
          ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          call popreal8(dre)
          tempd22 = -(dis4*dred)
          dis2d = dis2d + ddw*dred
          ddwd = dis2*dred - three*tempd22
          dis4d = dis4d - (w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)-three&
&           *ddw)*dred
          wd(i, j+2, k, irhoe) = wd(i, j+2, k, irhoe) + tempd22
          wd(i, j-1, k, irhoe) = wd(i, j-1, k, irhoe) - tempd22
          call popreal8(ddw)
          wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          call popreal8(drw)
          temp32 = w(i, j-1, k, ivz)
          temp31 = w(i, j-1, k, irho)
          temp30 = w(i, j+2, k, ivz)
          temp29 = w(i, j+2, k, irho)
          tempd23 = -(dis4*drwd)
          dis2d = dis2d + ddw*drwd
          ddwd = dis2*drwd - three*tempd23
          dis4d = dis4d - (temp29*temp30-temp31*temp32-three*ddw)*drwd
          wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp30*tempd23
          wd(i, j+2, k, ivz) = wd(i, j+2, k, ivz) + temp29*tempd23
          wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp32*tempd23
          wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - temp31*tempd23
          call popreal8(ddw)
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
&           ddwd
          wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
          call popreal8(drv)
          temp28 = w(i, j-1, k, ivy)
          temp27 = w(i, j-1, k, irho)
          temp26 = w(i, j+2, k, ivy)
          temp25 = w(i, j+2, k, irho)
          tempd24 = -(dis4*drvd)
          dis2d = dis2d + ddw*drvd
          ddwd = dis2*drvd - three*tempd24
          dis4d = dis4d - (temp25*temp26-temp27*temp28-three*ddw)*drvd
          wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp26*tempd24
          wd(i, j+2, k, ivy) = wd(i, j+2, k, ivy) + temp25*tempd24
          wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp28*tempd24
          wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - temp27*tempd24
          call popreal8(ddw)
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
&           ddwd
          wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
          call popreal8(dru)
          temp24 = w(i, j-1, k, ivx)
          temp23 = w(i, j-1, k, irho)
          temp22 = w(i, j+2, k, ivx)
          temp21 = w(i, j+2, k, irho)
          tempd25 = -(dis4*drud)
          dis2d = dis2d + ddw*drud
          ddwd = dis2*drud - three*tempd25
          dis4d = dis4d - (temp21*temp22-temp23*temp24-three*ddw)*drud
          wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp22*tempd25
          wd(i, j+2, k, ivx) = wd(i, j+2, k, ivx) + temp21*tempd25
          wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp24*tempd25
          wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - temp23*tempd25
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
&           ddwd
          wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          call popreal8(dr)
          tempd26 = -(dis4*drd)
          dis2d = dis2d + ddw*drd
          ddwd = dis2*drd - three*tempd26
          dis4d = dis4d - (w(i, j+2, k, irho)-w(i, j-1, k, irho)-three*&
&           ddw)*drd
          wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + tempd26
          wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - tempd26
          call popreal8(ddw)
          wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(dis4)
            call popreal8(dis2)
            min3d = fis2*ppor*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              y3d = min3d
            else
              y3d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              dp2d = dp2d + y3d
              dp1d = 0.0_8
            else
              dp1d = y3d
            end if
          else
            arg1 = ppor*fis4
            call popreal8(dis4)
            arg1d = 0.0_8
            call dim_b(arg1, arg1d, dis2, dis2d, dis4d)
            call popreal8(dis2)
            min4d = ppor*fis2*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              y4d = min4d
            else
              y4d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              dp2d = dp2d + y4d
              dp1d = 0.0_8
            else
              dp1d = y4d
            end if
          end if
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x4d = dp2d
          else
            x4d = -dp2d
          end if
          temp20 = omega*(p(i, j+2, k)+two*p(i, j+1, k)+p(i, j, k)) + &
&           oneminomega*(abs4+abs10) + plim
          tempd19 = x4d/temp20
          tempd20 = -((p(i, j+2, k)-two*p(i, j+1, k)+p(i, j, k))*tempd19&
&           /temp20)
          tempd21 = omega*tempd20
          pd(i, j+2, k) = pd(i, j+2, k) + tempd21 + tempd19
          pd(i, j+1, k) = pd(i, j+1, k) + two*tempd21 - two*tempd19
          pd(i, j, k) = pd(i, j, k) + tempd21 + tempd19
          abs4d = oneminomega*tempd20
          abs10d = oneminomega*tempd20
          plimd = plimd + tempd20
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs10)
            pd(i, j+1, k) = pd(i, j+1, k) + abs10d
            pd(i, j, k) = pd(i, j, k) - abs10d
          else
            call popreal8(abs10)
            pd(i, j, k) = pd(i, j, k) + abs10d
            pd(i, j+1, k) = pd(i, j+1, k) - abs10d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs4)
            pd(i, j+1, k) = pd(i, j+1, k) + abs4d
            pd(i, j+2, k) = pd(i, j+2, k) - abs4d
          else
            call popreal8(abs4)
            pd(i, j+2, k) = pd(i, j+2, k) + abs4d
            pd(i, j+1, k) = pd(i, j+1, k) - abs4d
          end if
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x3d = dp1d
        else
          x3d = -dp1d
        end if
        temp19 = omega*(p(i, 2, k)+two*p(i, 1, k)+p(i, 0, k)) + &
&         oneminomega*(abs3+abs9) + plim
        tempd16 = x3d/temp19
        tempd17 = -((p(i, 2, k)-two*p(i, 1, k)+p(i, 0, k))*tempd16/&
&         temp19)
        tempd18 = omega*tempd17
        pd(i, 2, k) = pd(i, 2, k) + tempd18 + tempd16
        pd(i, 1, k) = pd(i, 1, k) + two*tempd18 - two*tempd16
        pd(i, 0, k) = pd(i, 0, k) + tempd18 + tempd16
        abs3d = oneminomega*tempd17
        abs9d = oneminomega*tempd17
        plimd = plimd + tempd17
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs9)
          pd(i, 1, k) = pd(i, 1, k) + abs9d
          pd(i, 0, k) = pd(i, 0, k) - abs9d
        else
          call popreal8(abs9)
          pd(i, 0, k) = pd(i, 0, k) + abs9d
          pd(i, 1, k) = pd(i, 1, k) - abs9d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs3)
          pd(i, 1, k) = pd(i, 1, k) + abs3d
          pd(i, 2, k) = pd(i, 2, k) - abs3d
        else
          call popreal8(abs3)
          pd(i, 2, k) = pd(i, 2, k) + abs3d
          pd(i, 1, k) = pd(i, 1, k) - abs3d
        end if
      end do
    end do
    do k=kl,2,-1
      do j=jl,2,-1
        dp1d = 0.0_8
        do i=il,1,-1
          dp2d = dp1d
          fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
          wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
          vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
          uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
          unavg = uavg*sx + vavg*sy + wavg*sz
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          ovaavg = one/aavg
          ova2avg = one/a2avg
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
          lam3d = dre*fsd
          dred = lam3*fsd
          havgd = abv6*fsd
          abv6d = havg*fsd
          unavgd = abv7*fsd
          abv7d = unavg*fsd
          fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
          lam3d = lam3d + drw*fsd
          drwd = lam3*fsd
          wavgd = abv6*fsd
          abv6d = abv6d + wavg*fsd
          szd = abv7*fsd
          abv7d = abv7d + sz*fsd
          fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
          lam3d = lam3d + drv*fsd
          drvd = lam3*fsd
          vavgd = abv6*fsd
          abv6d = abv6d + vavg*fsd
          syd = abv7*fsd
          abv7d = abv7d + sy*fsd
          fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
          lam3d = lam3d + dru*fsd
          drud = lam3*fsd
          uavgd = abv6*fsd
          abv6d = abv6d + uavg*fsd
          sxd = abv7*fsd
          abv7d = abv7d + sx*fsd
          fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
          abv6d = abv6d + fsd
          abv2d = ovaavg*abv5*abv6d + ovaavg*abv4*abv7d
          abv4d = ova2avg*abv3*abv6d + ovaavg*abv2*abv7d
          ovaavgd = abv2*abv5*abv6d + abv2*abv4*abv7d
          abv3d = ova2avg*abv4*abv6d + abv5*abv7d
          lam3d = lam3d + dr*fsd - abv3d
          abv5d = ovaavg*abv2*abv6d + abv3*abv7d
          ova2avgd = abv3*abv4*abv6d
          sxd = sxd + dru*abv5d
          syd = syd + drv*abv5d
          szd = szd + drw*abv5d
          unavgd = unavgd - dr*abv5d
          gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          gm53 = gammaavg - five*third
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          call popreal8(abv4)
          tempd15 = gm1*abv4d
          drd = alphaavg*tempd15 - unavg*abv5d + lam3*fsd
          drud = drud + sx*abv5d - uavg*tempd15
          drvd = drvd + sy*abv5d - vavg*tempd15
          drwd = drwd + sz*abv5d - wavg*tempd15
          alphaavgd = dr*tempd15
          uavgd = uavgd - dru*tempd15
          vavgd = vavgd - drv*tempd15
          dred = dred + tempd15
          wavgd = wavgd - drw*tempd15
          drkd = -(gm53*abv4d)
          call popreal8(abv3)
          abv1d = abv3d
          call popreal8(abv2)
          lam1d = half*abv1d + half*abv2d
          lam2d = half*abv1d - half*abv2d
          call popreal8(lam3)
          call popreal8(lam2)
          call popreal8(lam1)
          aread = lam2*lam2d + lam1*lam1d + lam3*lam3d
          lam3d = area*lam3d
          lam2d = area*lam2d
          lam1d = area*lam1d
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = epsshear*lam3d
            lam3d = 0.0_8
          else
            rradd = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam2d
            lam2d = 0.0_8
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            rradd = rradd + epsacoustic*lam1d
            lam1d = 0.0_8
          end if
          lam3d = lam3d + rradd
          aavgd = rradd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(lam3)
            unavgd = unavgd + lam3d
            sfaced = sfaced - lam3d
          else
            call popreal8(lam3)
            sfaced = sfaced + lam3d
            unavgd = unavgd - lam3d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam2d
            sfaced = sfaced - lam2d
            aavgd = aavgd - lam2d
          else
            sfaced = sfaced + lam2d
            unavgd = unavgd - lam2d
            aavgd = aavgd + lam2d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            unavgd = unavgd + lam1d
            sfaced = sfaced - lam1d
            aavgd = aavgd + lam1d
          else
            sfaced = sfaced + lam1d
            unavgd = unavgd - lam1d
            aavgd = aavgd - lam1d
          end if
          tmp = one/max1
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            tmpd = 0.0_8
          else
            tmpd = sfacei(i, j, k)*sfaced
            sfaced = 0.0_8
          end if
          alphaavgd = alphaavgd + havgd
          tempd14 = half*alphaavgd
          ovgm1 = one/gm1
          aavgd = aavgd - one*ovaavgd/aavg**2
          if (a2avg .eq. 0.0_8) then
            a2avgd = ovgm1*havgd - one*ova2avgd/a2avg**2
          else
            a2avgd = aavgd/(2.0*sqrt(a2avg)) + ovgm1*havgd - one*&
&             ova2avgd/a2avg**2
          end if
          uavgd = uavgd + 2*uavg*tempd14 + sx*unavgd
          sxd = sxd + uavg*unavgd
          vavgd = vavgd + 2*vavg*tempd14 + sy*unavgd
          syd = syd + vavg*unavgd
          wavgd = wavgd + 2*wavg*tempd14 + sz*unavgd
          szd = szd + wavg*unavgd
          call popreal8(aavg)
          call popreal8(havg)
          kavgd = -(ovgm1*gm53*havgd)
          call popreal8(sz)
          call popreal8(sy)
          call popreal8(sx)
          tmpd = tmpd + sy*syd + sx*sxd + sz*szd
          szd = tmp*szd
          syd = tmp*syd
          sxd = tmp*sxd
          max1d = -(one*tmpd/max1**2)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(max1)
            aread = aread + max1d
          else
            call popreal8(max1)
          end if
          call popreal8(area)
          if (sx**2 + sy**2 + sz**2 .eq. 0.0_8) then
            tempd11 = 0.0
          else
            tempd11 = aread/(2.0*sqrt(sx**2+sy**2+sz**2))
          end if
          sxd = sxd + 2*sx*tempd11
          syd = syd + 2*sy*tempd11
          szd = szd + 2*sz*tempd11
          call popreal8(sz)
          sid(i, j, k, 3) = sid(i, j, k, 3) + szd
          call popreal8(sy)
          sid(i, j, k, 2) = sid(i, j, k, 2) + syd
          call popreal8(sx)
          sid(i, j, k, 1) = sid(i, j, k, 1) + sxd
          call popreal8(a2avg)
          temp18 = w(i, j, k, irho)
          temp17 = w(i+1, j, k, irho)
          tempd12 = gamma(i+1, j, k)*half*a2avgd/temp17
          tempd13 = gamma(i, j, k)*half*a2avgd/temp18
          pd(i+1, j, k) = pd(i+1, j, k) + tempd12
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) - p(i+1, j, k)*&
&           tempd12/temp17
          pd(i, j, k) = pd(i, j, k) + tempd13
          wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd13/&
&           temp18
          wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + half*wavgd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) + half*wavgd
          wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + half*vavgd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) + half*vavgd
          wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + half*uavgd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) + half*uavgd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            dis2d = 0.0_8
            dis4d = 0.0_8
          else
            wd(i, j, k, itu1) = wd(i, j, k, itu1) + half*kavgd
            wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + half*kavgd
            temp16 = w(i-1, j, k, itu1)
            temp15 = w(i-1, j, k, irho)
            temp14 = w(i+2, j, k, itu1)
            temp13 = w(i+2, j, k, irho)
            tempd10 = -(dis4*drkd)
            dis2d = ddw*drkd
            ddwd = dis2*drkd - three*tempd10
            dis4d = -((temp13*temp14-temp15*temp16-three*ddw)*drkd)
            wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp14*tempd10
            wd(i+2, j, k, itu1) = wd(i+2, j, k, itu1) + temp13*tempd10
            wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp16*tempd10
            wd(i-1, j, k, itu1) = wd(i-1, j, k, itu1) - temp15*tempd10
            wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, &
&             itu1)*ddwd
            wd(i+1, j, k, itu1) = wd(i+1, j, k, itu1) + w(i+1, j, k, &
&             irho)*ddwd
            wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, itu1)*&
&             ddwd
            wd(i, j, k, itu1) = wd(i, j, k, itu1) - w(i, j, k, irho)*&
&             ddwd
          end if
          ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          call popreal8(dre)
          tempd5 = -(dis4*dred)
          dis2d = dis2d + ddw*dred
          ddwd = dis2*dred - three*tempd5
          dis4d = dis4d - (w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)-three&
&           *ddw)*dred
          wd(i+2, j, k, irhoe) = wd(i+2, j, k, irhoe) + tempd5
          wd(i-1, j, k, irhoe) = wd(i-1, j, k, irhoe) - tempd5
          call popreal8(ddw)
          wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddwd
          wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddwd
          call popreal8(drw)
          temp12 = w(i-1, j, k, ivz)
          temp11 = w(i-1, j, k, irho)
          temp10 = w(i+2, j, k, ivz)
          temp9 = w(i+2, j, k, irho)
          tempd6 = -(dis4*drwd)
          dis2d = dis2d + ddw*drwd
          ddwd = dis2*drwd - three*tempd6
          dis4d = dis4d - (temp9*temp10-temp11*temp12-three*ddw)*drwd
          wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp10*tempd6
          wd(i+2, j, k, ivz) = wd(i+2, j, k, ivz) + temp9*tempd6
          wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp12*tempd6
          wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - temp11*tempd6
          call popreal8(ddw)
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
&           ddwd
          wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddwd
          wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddwd
          call popreal8(drv)
          temp8 = w(i-1, j, k, ivy)
          temp7 = w(i-1, j, k, irho)
          temp6 = w(i+2, j, k, ivy)
          temp5 = w(i+2, j, k, irho)
          tempd7 = -(dis4*drvd)
          dis2d = dis2d + ddw*drvd
          ddwd = dis2*drvd - three*tempd7
          dis4d = dis4d - (temp5*temp6-temp7*temp8-three*ddw)*drvd
          wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp6*tempd7
          wd(i+2, j, k, ivy) = wd(i+2, j, k, ivy) + temp5*tempd7
          wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp8*tempd7
          wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - temp7*tempd7
          call popreal8(ddw)
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
&           ddwd
          wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddwd
          wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddwd
          call popreal8(dru)
          temp4 = w(i-1, j, k, ivx)
          temp3 = w(i-1, j, k, irho)
          temp2 = w(i+2, j, k, ivx)
          temp1 = w(i+2, j, k, irho)
          tempd8 = -(dis4*drud)
          dis2d = dis2d + ddw*drud
          ddwd = dis2*drud - three*tempd8
          dis4d = dis4d - (temp1*temp2-temp3*temp4-three*ddw)*drud
          wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp2*tempd8
          wd(i+2, j, k, ivx) = wd(i+2, j, k, ivx) + temp1*tempd8
          wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp4*tempd8
          wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - temp3*tempd8
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
&           ddwd
          wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)*&
&           ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddwd
          wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddwd
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          call popreal8(dr)
          tempd9 = -(dis4*drd)
          dis2d = dis2d + ddw*drd
          ddwd = dis2*drd - three*tempd9
          dis4d = dis4d - (w(i+2, j, k, irho)-w(i-1, j, k, irho)-three*&
&           ddw)*drd
          wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + tempd9
          wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - tempd9
          call popreal8(ddw)
          wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddwd
          wd(i, j, k, irho) = wd(i, j, k, irho) - ddwd
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(dis4)
            call popreal8(dis2)
            min1d = fis2*ppor*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              y1d = min1d
            else
              y1d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              dp2d = dp2d + y1d
              dp1d = 0.0_8
            else
              dp1d = y1d
            end if
          else
            arg1 = ppor*fis4
            call popreal8(dis4)
            arg1d = 0.0_8
            call dim_b(arg1, arg1d, dis2, dis2d, dis4d)
            call popreal8(dis2)
            min2d = ppor*fis2*dis2d
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              y2d = min2d
            else
              y2d = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              dp2d = dp2d + y2d
              dp1d = 0.0_8
            else
              dp1d = y2d
            end if
          end if
          call popreal8(ppor)
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            x2d = dp2d
          else
            x2d = -dp2d
          end if
          temp0 = omega*(p(i+2, j, k)+two*p(i+1, j, k)+p(i, j, k)) + &
&           oneminomega*(abs2+abs8) + plim
          tempd2 = x2d/temp0
          tempd3 = -((p(i+2, j, k)-two*p(i+1, j, k)+p(i, j, k))*tempd2/&
&           temp0)
          tempd4 = omega*tempd3
          pd(i+2, j, k) = pd(i+2, j, k) + tempd4 + tempd2
          pd(i+1, j, k) = pd(i+1, j, k) + two*tempd4 - two*tempd2
          pd(i, j, k) = pd(i, j, k) + tempd4 + tempd2
          abs2d = oneminomega*tempd3
          abs8d = oneminomega*tempd3
          plimd = plimd + tempd3
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs8)
            pd(i+1, j, k) = pd(i+1, j, k) + abs8d
            pd(i, j, k) = pd(i, j, k) - abs8d
          else
            call popreal8(abs8)
            pd(i, j, k) = pd(i, j, k) + abs8d
            pd(i+1, j, k) = pd(i+1, j, k) - abs8d
          end if
          call popcontrol1b(branch)
          if (branch .eq. 0) then
            call popreal8(abs2)
            pd(i+1, j, k) = pd(i+1, j, k) + abs2d
            pd(i+2, j, k) = pd(i+2, j, k) - abs2d
          else
            call popreal8(abs2)
            pd(i+2, j, k) = pd(i+2, j, k) + abs2d
            pd(i+1, j, k) = pd(i+1, j, k) - abs2d
          end if
        end do
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          x1d = dp1d
        else
          x1d = -dp1d
        end if
        temp = omega*(p(2, j, k)+two*p(1, j, k)+p(0, j, k)) + &
&         oneminomega*(abs1+abs7) + plim
        tempd = x1d/temp
        tempd0 = -((p(2, j, k)-two*p(1, j, k)+p(0, j, k))*tempd/temp)
        tempd1 = omega*tempd0
        pd(2, j, k) = pd(2, j, k) + tempd1 + tempd
        pd(1, j, k) = pd(1, j, k) + two*tempd1 - two*tempd
        pd(0, j, k) = pd(0, j, k) + tempd1 + tempd
        abs1d = oneminomega*tempd0
        abs7d = oneminomega*tempd0
        plimd = plimd + tempd0
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs7)
          pd(1, j, k) = pd(1, j, k) + abs7d
          pd(0, j, k) = pd(0, j, k) - abs7d
        else
          call popreal8(abs7)
          pd(0, j, k) = pd(0, j, k) + abs7d
          pd(1, j, k) = pd(1, j, k) - abs7d
        end if
        call popcontrol1b(branch)
        if (branch .eq. 0) then
          call popreal8(abs1)
          pd(1, j, k) = pd(1, j, k) + abs1d
          pd(2, j, k) = pd(2, j, k) - abs1d
        else
          call popreal8(abs1)
          pd(2, j, k) = pd(2, j, k) + abs1d
          pd(1, j, k) = pd(1, j, k) - abs1d
        end if
      end do
    end do
    pinfcorrd = 0.001_realtype*plimd
  end if
end subroutine invisciddissfluxmatrix_b

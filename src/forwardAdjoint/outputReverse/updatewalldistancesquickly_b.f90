   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of updatewalldistancesquickly in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *x *d2wall
   !   with respect to varying inputs: *xsurf *x
   !   Plus diff mem management of: xsurf:in x:in d2wall:in
   SUBROUTINE UPDATEWALLDISTANCESQUICKLY_B(nn, level, sps)
   ! This is the actual update routine that uses xSurf. It is done on
   ! block-level-sps basis.  This is the used to update the wall
   ! distance. Most importantly, this routine is included in the
   ! reverse mode AD routines, but NOT the forward mode. Since it is
   ! done on a per-block basis, it is assumed that the required block
   ! pointers are already set. 
   USE BLOCKPOINTERS_B
   USE WALLDISTANCEDATA
   IMPLICIT NONE
   ! Subroutine arguments
   INTEGER(kind=inttype) :: nn, level, sps
   ! Local Variables
   INTEGER(kind=inttype) :: i, j, k, faceid
   REAL(kind=realtype) :: xp(3), xc(3), u, v
   REAL(kind=realtype) :: xpb(3), xcb(3)
   INTRINSIC SQRT
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Extract elemID and u-v position for the association of
   ! this cell:
   faceid = flowdoms(nn, level, sps)%elemid(i, j, k)
   u = flowdoms(nn, level, sps)%uv(1, i, j, k)
   v = flowdoms(nn, level, sps)%uv(2, i, j, k)
   ! Now we have the 4 corners, use bi-linear shape
   ! functions o to get target: (CCW ordering remember!)
   CALL PUSHREAL8ARRAY(xp, 3)
   xp(:) = (one-u)*(one-v)*xsurf(12*(faceid-1)+1:12*(faceid-1)+3) +&
   &         u*(one-v)*xsurf(12*(faceid-1)+4:12*(faceid-1)+6) + u*v*xsurf(&
   &         12*(faceid-1)+7:12*(faceid-1)+9) + (one-u)*v*xsurf(12*(faceid-&
   &         1)+10:12*(faceid-1)+12)
   ! Get the cell center
   CALL PUSHREAL8(xc(1))
   xc(1) = eighth*(x(i-1, j-1, k-1, 1)+x(i, j-1, k-1, 1)+x(i-1, j, &
   &         k-1, 1)+x(i, j, k-1, 1)+x(i-1, j-1, k, 1)+x(i, j-1, k, 1)+x(i-&
   &         1, j, k, 1)+x(i, j, k, 1))
   CALL PUSHREAL8(xc(2))
   xc(2) = eighth*(x(i-1, j-1, k-1, 2)+x(i, j-1, k-1, 2)+x(i-1, j, &
   &         k-1, 2)+x(i, j, k-1, 2)+x(i-1, j-1, k, 2)+x(i, j-1, k, 2)+x(i-&
   &         1, j, k, 2)+x(i, j, k, 2))
   CALL PUSHREAL8(xc(3))
   xc(3) = eighth*(x(i-1, j-1, k-1, 3)+x(i, j-1, k-1, 3)+x(i-1, j, &
   &         k-1, 3)+x(i, j, k-1, 3)+x(i-1, j-1, k, 3)+x(i, j-1, k, 3)+x(i-&
   &         1, j, k, 3)+x(i, j, k, 3))
   ! Now we have the two points...just take the norm of the
   ! distance between them
   END DO
   END DO
   END DO
   xsurfb = 0.0_8
   xcb = 0.0_8
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   xpb = 0.0_8
   IF ((xc(1)-xp(1))**2 + (xc(2)-xp(2))**2 + (xc(3)-xp(3))**2 .EQ. &
   &           0.0_8) THEN
   tempb = 0.0
   ELSE
   tempb = d2wallb(i, j, k)/(2.0*SQRT((xc(1)-xp(1))**2+(xc(2)-xp(&
   &           2))**2+(xc(3)-xp(3))**2))
   END IF
   tempb0 = 2*(xc(1)-xp(1))*tempb
   tempb1 = 2*(xc(2)-xp(2))*tempb
   tempb2 = 2*(xc(3)-xp(3))*tempb
   xcb(1) = xcb(1) + tempb0
   xpb(1) = xpb(1) - tempb0
   xcb(2) = xcb(2) + tempb1
   xpb(2) = xpb(2) - tempb1
   xcb(3) = xcb(3) + tempb2
   xpb(3) = xpb(3) - tempb2
   d2wallb(i, j, k) = 0.0_8
   CALL POPREAL8(xc(3))
   tempb3 = eighth*xcb(3)
   xb(i-1, j-1, k-1, 3) = xb(i-1, j-1, k-1, 3) + tempb3
   xb(i, j-1, k-1, 3) = xb(i, j-1, k-1, 3) + tempb3
   xb(i-1, j, k-1, 3) = xb(i-1, j, k-1, 3) + tempb3
   xb(i, j, k-1, 3) = xb(i, j, k-1, 3) + tempb3
   xb(i-1, j-1, k, 3) = xb(i-1, j-1, k, 3) + tempb3
   xb(i, j-1, k, 3) = xb(i, j-1, k, 3) + tempb3
   xb(i-1, j, k, 3) = xb(i-1, j, k, 3) + tempb3
   xb(i, j, k, 3) = xb(i, j, k, 3) + tempb3
   xcb(3) = 0.0_8
   CALL POPREAL8(xc(2))
   tempb4 = eighth*xcb(2)
   xb(i-1, j-1, k-1, 2) = xb(i-1, j-1, k-1, 2) + tempb4
   xb(i, j-1, k-1, 2) = xb(i, j-1, k-1, 2) + tempb4
   xb(i-1, j, k-1, 2) = xb(i-1, j, k-1, 2) + tempb4
   xb(i, j, k-1, 2) = xb(i, j, k-1, 2) + tempb4
   xb(i-1, j-1, k, 2) = xb(i-1, j-1, k, 2) + tempb4
   xb(i, j-1, k, 2) = xb(i, j-1, k, 2) + tempb4
   xb(i-1, j, k, 2) = xb(i-1, j, k, 2) + tempb4
   xb(i, j, k, 2) = xb(i, j, k, 2) + tempb4
   xcb(2) = 0.0_8
   CALL POPREAL8(xc(1))
   tempb5 = eighth*xcb(1)
   xb(i-1, j-1, k-1, 1) = xb(i-1, j-1, k-1, 1) + tempb5
   xb(i, j-1, k-1, 1) = xb(i, j-1, k-1, 1) + tempb5
   xb(i-1, j, k-1, 1) = xb(i-1, j, k-1, 1) + tempb5
   xb(i, j, k-1, 1) = xb(i, j, k-1, 1) + tempb5
   xb(i-1, j-1, k, 1) = xb(i-1, j-1, k, 1) + tempb5
   xb(i, j-1, k, 1) = xb(i, j-1, k, 1) + tempb5
   xb(i-1, j, k, 1) = xb(i-1, j, k, 1) + tempb5
   xb(i, j, k, 1) = xb(i, j, k, 1) + tempb5
   xcb(1) = 0.0_8
   u = flowdoms(nn, level, sps)%uv(1, i, j, k)
   v = flowdoms(nn, level, sps)%uv(2, i, j, k)
   faceid = flowdoms(nn, level, sps)%elemid(i, j, k)
   CALL POPREAL8ARRAY(xp, 3)
   xsurfb(12*(faceid-1)+1:12*(faceid-1)+3) = xsurfb(12*(faceid-1)+1&
   &         :12*(faceid-1)+3) + (one-u)*(one-v)*xpb
   xsurfb(12*(faceid-1)+4:12*(faceid-1)+6) = xsurfb(12*(faceid-1)+4&
   &         :12*(faceid-1)+6) + u*(one-v)*xpb
   xsurfb(12*(faceid-1)+7:12*(faceid-1)+9) = xsurfb(12*(faceid-1)+7&
   &         :12*(faceid-1)+9) + u*v*xpb
   xsurfb(12*(faceid-1)+10:12*(faceid-1)+12) = xsurfb(12*(faceid-1)&
   &         +10:12*(faceid-1)+12) + (one-u)*v*xpb
   END DO
   END DO
   END DO
   END SUBROUTINE UPDATEWALLDISTANCESQUICKLY_B

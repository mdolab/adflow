   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of computetsderivatives in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: lengthref dragdirection liftdirection
   !                moment dcdalphadot coef0 force dcdalpha
   !   with respect to varying inputs: machgrid lengthref machcoef
   !                dragdirection liftdirection gammainf pinf rhoinfdim
   !                pinfdim pref moment force
   !
   !     ******************************************************************
   !     *                                                                *
   !     * File:          computeTSDerivatives.f90                        *
   !     * Author:        C.A.(Sandy) Mader, G. Kenway                    *
   !     * Starting date: 11-25-2009                                      *
   !     * Last modified: 11-26-2009                                      *
   !     *                                                                *
   !     ******************************************************************
   !
   SUBROUTINE COMPUTETSDERIVATIVES_B(force, forced, moment, momentd, &
   & liftindex, coef0, coef0d, dcdalpha, dcdalphad, dcdalphadot, &
   & dcdalphadotd, dcdq, dcdqdot)
   !
   !     ******************************************************************
   !     *                                                                *
   !     * Computes the stability derivatives based on the time spectral  *
   !     * solution of a given mesh. Takes in the force coefficients at   *
   !     * all time instantces and computes the agregate parameters       *
   !     *                                                                *
   !     ******************************************************************
   !
   USE COMMUNICATION
   USE INPUTPHYSICS
   USE INPUTTIMESPECTRAL
   USE INPUTTSSTABDERIV
   USE FLOWVARREFSTATE
   USE MONITOR
   USE SECTION
   USE INPUTMOTION
   IMPLICIT NONE
   !
   !     Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral) :: force, &
   & moment
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral) :: forced, &
   & momentd
   REAL(kind=realtype), DIMENSION(8) :: dcdq, dcdqdot
   REAL(kind=realtype), DIMENSION(8) :: dcdalpha, dcdalphadot
   REAL(kind=realtype), DIMENSION(8) :: dcdalphad, dcdalphadotd
   REAL(kind=realtype), DIMENSION(8) :: coef0
   REAL(kind=realtype), DIMENSION(8) :: coef0d
   INTEGER(kind=inttype) :: liftindex
   ! Working Variables
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: basecoef
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: basecoefd
   REAL(kind=realtype), DIMENSION(8) :: coef0dot
   REAL(kind=realtype), DIMENSION(8) :: coef0dotd
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: &
   & resbasecoef
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: &
   & resbasecoefd
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: &
   & intervalalpha, intervalalphadot
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: intervalmach&
   & , intervalmachdot
   REAL(kind=realtype), DIMENSION(nsections) :: t
   REAL(kind=realtype) :: alpha, beta
   INTEGER(kind=inttype) :: i, sps, nn
   !speed of sound: for normalization of q derivatives
   REAL(kind=realtype) :: a
   REAL(kind=realtype) :: ad
   REAL(kind=realtype) :: scaledim, fact, factmoment
   REAL(kind=realtype) :: scaledimd, factd, factmomentd
   ! Functions
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: dphix, dphiy&
   & , dphiz
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral) :: dphixdot, &
   & dphiydot, dphizdot
   REAL(kind=realtype) :: derivativerigidrotangle, &
   & secondderivativerigidrotangle
   REAL(kind=realtype) :: TSALPHA, TSALPHADOT
   INTRINSIC SQRT
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4(8)
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: temp
   !
   !     ******************************************************************
   !     *                                                                *
   !     * Begin execution.                                               *
   !     *                                                                *
   !     ******************************************************************
   !
   scaledim = pref/pinf
   fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
   factmoment = fact/(lengthref*lref)
   IF (tsqmode) THEN
   STOP
   ! !q is pitch
   ! do sps =1,nTimeIntervalsSpectral
   !    !compute the time of this intervavc
   !    t = timeUnsteadyRestart
   !    if(equationMode == timeSpectral) then
   !       do nn=1,nSections
   !          t(nn) = t(nn) + (sps-1)*sections(nn)%timePeriod &
   !               /         (nTimeIntervalsSpectral*1.0)
   !       enddo
   !    endif
   !    ! Compute the time derivative of the rotation angles around the
   !    ! z-axis. i.e. compute q
   !    dphiZ(sps) = derivativeRigidRotAngle(degreePolZRot,   &
   !         coefPolZRot,     &
   !         degreeFourZRot,  &
   !         omegaFourZRot,   &
   !         cosCoefFourZRot, &
   !         sinCoefFourZRot, t)
   !    ! add in q_dot computation
   !    dphiZdot(sps) = secondDerivativeRigidRotAngle(degreePolZRot,   &
   !         coefPolZRot,     &
   !         degreeFourZRot,  &
   !         omegaFourZRot,   &
   !         cosCoefFourZRot, &
   !         sinCoefFourZRot, t)
   ! end do
   ! !now compute dCl/dq
   ! do i =1,8
   !    call computeLeastSquaresRegression(BaseCoef(:,i),dphiz,nTimeIntervalsSpectral,dcdq(i),coef0(i))
   ! end do
   ! ! now subtract off estimated cl,cmz and use remainder to compute 
   ! ! clqdot and cmzqdot.
   ! do i = 1,8
   !    do sps = 1,nTimeIntervalsSpectral
   !       ResBaseCoef(sps,i) = BaseCoef(sps,i)-(dcdq(i)*dphiz(sps)+Coef0(i))
   !    enddo
   ! enddo
   ! !now normalize the results...
   ! a  = sqrt(gammaInf*pInfDim/rhoInfDim)
   ! dcdq = dcdq*timeRef*2*(machGrid*a)/lengthRef
   ! !now compute dCl/dpdot
   ! do i = 1,8
   !    call computeLeastSquaresRegression(ResBaseCoef(:,i),dphizdot,nTimeIntervalsSpectral,dcdqdot(i),Coef0dot(i))
   ! enddo
   ELSE
   IF (tsalphamode) THEN
   DO sps=1,ntimeintervalsspectral
   !compute the time of this interval
   t = timeunsteadyrestart
   IF (equationmode .EQ. timespectral) THEN
   DO nn=1,nsections
   t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/(&
   &             ntimeintervalsspectral*1.0)
   END DO
   END IF
   intervalalpha(sps) = TSALPHA(degreepolalpha, coefpolalpha, &
   &         degreefouralpha, omegafouralpha, coscoeffouralpha, &
   &         sincoeffouralpha, t)
   intervalalphadot(sps) = TSALPHADOT(degreepolalpha, &
   &         coefpolalpha, degreefouralpha, omegafouralpha, &
   &         coscoeffouralpha, sincoeffouralpha, t)
   basecoef(sps, 1) = fact*(force(1, sps)*liftdirection(1)+force(2&
   &         , sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
   basecoef(sps, 2) = fact*(force(1, sps)*dragdirection(1)+force(2&
   &         , sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
   basecoef(sps, 3) = force(1, sps)*fact
   basecoef(sps, 4) = force(2, sps)*fact
   basecoef(sps, 5) = force(3, sps)*fact
   basecoef(sps, 6) = moment(1, sps)*factmoment
   basecoef(sps, 7) = moment(2, sps)*factmoment
   basecoef(sps, 8) = moment(3, sps)*factmoment
   END DO
   !now compute dCl/dalpha
   DO i=1,8
   CALL COMPUTELEASTSQUARESREGRESSION(basecoef(:, i), &
   &                                       intervalalpha, &
   &                                       ntimeintervalsspectral, dcdalpha&
   &                                       (i), coef0(i))
   END DO
   ! now subtract off estimated cl,cmz and use remainder to compute 
   ! clalphadot and cmzalphadot.
   DO i=1,8
   DO sps=1,ntimeintervalsspectral
   resbasecoef(sps, i) = basecoef(sps, i) - (dcdalpha(i)*&
   &           intervalalpha(sps)+coef0(i))
   END DO
   END DO
   !now compute dCi/dalphadot
   DO i=1,8
   CALL COMPUTELEASTSQUARESREGRESSION(resbasecoef(:, i), &
   &                                       intervalalphadot, &
   &                                       ntimeintervalsspectral, &
   &                                       dcdalphadot(i), coef0dot(i))
   END DO
   a = SQRT(gammainf*pinfdim/rhoinfdim)
   tempd4 = 2*a*dcdalphadotd/lengthref
   tempd5 = 2*SUM(dcdalphadot*machgrid*dcdalphadotd)/lengthref
   machgridd = SUM(dcdalphadot*tempd4)
   ad = tempd5
   lengthrefd = lengthrefd - a*tempd5/lengthref
   dcdalphadotd = machgrid*tempd4
   temp2 = gammainf*pinfdim/rhoinfdim
   IF (temp2 .EQ. 0.0_8) THEN
   tempd6 = 0.0
   ELSE
   tempd6 = ad/(2.0*SQRT(temp2)*rhoinfdim)
   END IF
   gammainfd = pinfdim*tempd6
   pinfdimd = gammainf*tempd6
   rhoinfdimd = -(temp2*tempd6)
   resbasecoefd = 0.0_8
   DO i=8,1,-1
   coef0dotd = 0.0_8
   CALL COMPUTELEASTSQUARESREGRESSION_B(resbasecoef(:, i), &
   &                                      resbasecoefd(:, i), &
   &                                      intervalalphadot, &
   &                                      ntimeintervalsspectral, &
   &                                      dcdalphadot(i), dcdalphadotd(i), &
   &                                      coef0dot(i), coef0dotd(i))
   dcdalphadotd(i) = 0.0_8
   coef0dotd(i) = 0.0_8
   END DO
   basecoefd = 0.0_8
   DO i=8,1,-1
   DO sps=ntimeintervalsspectral,1,-1
   basecoefd(sps, i) = basecoefd(sps, i) + resbasecoefd(sps, i)
   dcdalphad(i) = dcdalphad(i) - intervalalpha(sps)*resbasecoefd(&
   &           sps, i)
   coef0d(i) = coef0d(i) - resbasecoefd(sps, i)
   resbasecoefd(sps, i) = 0.0_8
   END DO
   END DO
   DO i=8,1,-1
   CALL COMPUTELEASTSQUARESREGRESSION_B(basecoef(:, i), basecoefd(:&
   &                                      , i), intervalalpha, &
   &                                      ntimeintervalsspectral, dcdalpha(&
   &                                      i), dcdalphad(i), coef0(i), &
   &                                      coef0d(i))
   dcdalphad(i) = 0.0_8
   coef0d(i) = 0.0_8
   END DO
   factmomentd = 0.0_8
   factd = 0.0_8
   DO sps=ntimeintervalsspectral,1,-1
   momentd(3, sps) = momentd(3, sps) + factmoment*basecoefd(sps, 8)
   factmomentd = factmomentd + moment(3, sps)*basecoefd(sps, 8)
   basecoefd(sps, 8) = 0.0_8
   momentd(2, sps) = momentd(2, sps) + factmoment*basecoefd(sps, 7)
   factmomentd = factmomentd + moment(2, sps)*basecoefd(sps, 7)
   basecoefd(sps, 7) = 0.0_8
   momentd(1, sps) = momentd(1, sps) + factmoment*basecoefd(sps, 6)
   factmomentd = factmomentd + moment(1, sps)*basecoefd(sps, 6)
   basecoefd(sps, 6) = 0.0_8
   forced(3, sps) = forced(3, sps) + fact*basecoefd(sps, 5)
   factd = factd + force(3, sps)*basecoefd(sps, 5)
   basecoefd(sps, 5) = 0.0_8
   forced(2, sps) = forced(2, sps) + fact*basecoefd(sps, 4)
   factd = factd + force(2, sps)*basecoefd(sps, 4)
   basecoefd(sps, 4) = 0.0_8
   forced(1, sps) = forced(1, sps) + fact*basecoefd(sps, 3)
   factd = factd + force(1, sps)*basecoefd(sps, 3)
   basecoefd(sps, 3) = 0.0_8
   tempd2 = fact*basecoefd(sps, 2)
   factd = factd + (force(1, sps)*dragdirection(1)+force(2, sps)*&
   &         dragdirection(2)+force(3, sps)*dragdirection(3))*basecoefd(sps&
   &         , 2)
   forced(1, sps) = forced(1, sps) + dragdirection(1)*tempd2
   dragdirectiond(1) = dragdirectiond(1) + force(1, sps)*tempd2
   forced(2, sps) = forced(2, sps) + dragdirection(2)*tempd2
   dragdirectiond(2) = dragdirectiond(2) + force(2, sps)*tempd2
   forced(3, sps) = forced(3, sps) + dragdirection(3)*tempd2
   dragdirectiond(3) = dragdirectiond(3) + force(3, sps)*tempd2
   basecoefd(sps, 2) = 0.0_8
   tempd3 = fact*basecoefd(sps, 1)
   factd = factd + (force(1, sps)*liftdirection(1)+force(2, sps)*&
   &         liftdirection(2)+force(3, sps)*liftdirection(3))*basecoefd(sps&
   &         , 1)
   forced(1, sps) = forced(1, sps) + liftdirection(1)*tempd3
   liftdirectiond(1) = liftdirectiond(1) + force(1, sps)*tempd3
   forced(2, sps) = forced(2, sps) + liftdirection(2)*tempd3
   liftdirectiond(2) = liftdirectiond(2) + force(2, sps)*tempd3
   forced(3, sps) = forced(3, sps) + liftdirection(3)*tempd3
   liftdirectiond(3) = liftdirectiond(3) + force(3, sps)*tempd3
   basecoefd(sps, 1) = 0.0_8
   END DO
   ELSE
   machgridd = 0.0_8
   gammainfd = 0.0_8
   rhoinfdimd = 0.0_8
   pinfdimd = 0.0_8
   factmomentd = 0.0_8
   factd = 0.0_8
   END IF
   tempd = factmomentd/(lref*lengthref)
   factd = factd + tempd
   lengthrefd = lengthrefd - fact*tempd/lengthref
   temp1 = machcoef**2*scaledim
   temp0 = surfaceref*lref**2
   temp = temp0*gammainf*pinf
   tempd0 = -(two*factd/(temp**2*temp1**2))
   tempd1 = temp1*temp0*tempd0
   gammainfd = gammainfd + pinf*tempd1
   machcoefd = scaledim*temp*2*machcoef*tempd0
   scaledimd = temp*machcoef**2*tempd0
   pinfd = gammainf*tempd1 - pref*scaledimd/pinf**2
   prefd = scaledimd/pinf
   END IF
   END SUBROUTINE COMPUTETSDERIVATIVES_B

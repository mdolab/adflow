   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
   !
   !  Differentiation of curveupre in reverse (adjoint) mode:
   !   gradient     of useful results: curveupre
   !   with respect to varying inputs: *up3 *up2 *up1 *up0 *ret re
   !   Plus diff mem management of: up3:in up2:in up1:in up0:in ret:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          curveFit.f90                                    *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 03-02-2004                                      *
   !      * Last modified: 04-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE CURVEUPRE_B(re, reb, curveupreb)
   USE PARAMTURB
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * curveUpRe determines the value of the nonDimensional           *
   !      * tangential velocity (made nonDimensional with the skin         *
   !      * friction velocity) for the given Reynolds number.              *
   !      * This data has been curve fitted with cubic splines.            *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Function type.
   !
   REAL(kind=realtype) :: curveupre
   REAL(kind=realtype) :: curveupreb
   !
   !      Function arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: re
   REAL(kind=realtype) :: reb
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: ii, nn, start
   REAL(kind=realtype) :: x, x2, x3, upre
   REAL(kind=realtype) :: xb, x2b, x3b, upreb
   INTEGER :: branch
   INTRINSIC SQRT
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the situation we are dealing with.
   IF (re .LE. ret(0)) THEN
   CALL PUSHCONTROL2B(0)
   ELSE IF (re .GE. ret(nfit)) THEN
   CALL PUSHCONTROL2B(1)
   ELSE
   ! Reynolds number is in the range of the curve fits.
   ! First find the correct interval.
   ii = nfit
   start = 1
   ! Next guess for the interval.
   100 nn = start + ii/2
   ! Determine the situation we are having here.
   IF (re .GT. ret(nn)) THEN
   ! Reynoldls number is larger than the upper boundary of
   ! the current interval. Update the lower boundary.
   start = nn + 1
   ii = ii - 1
   ELSE IF (re .GE. ret(nn-1)) THEN
   GOTO 110
   END IF
   ! This is the correct range. Exit the do-loop.
   ! Modify ii for the next branch to search.
   ii = ii/2
   GOTO 100
   ! Compute upRe using the cubic polynomial for this interval.
   110 x = re - ret(nn-1)
   x2 = x*x
   CALL PUSHCONTROL2B(2)
   END IF
   upreb = curveupreb
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   xb = up0(1)*upreb
   IF (re/ret(0) .EQ. 0.0) THEN
   reb = 0.0
   ELSE
   reb = xb/(2.0*SQRT(re/ret(0))*ret(0))
   END IF
   ELSE IF (branch .EQ. 1) THEN
   reb = 0.0_8
   ELSE
   x3b = up3(nn)*upreb
   x2b = x*x3b + up2(nn)*upreb
   xb = x2*x3b + 2*x*x2b + up1(nn)*upreb
   reb = xb
   END IF
   up3b = 0.0_8
   up2b = 0.0_8
   up1b = 0.0_8
   up0b = 0.0_8
   retb = 0.0_8
   END SUBROUTINE CURVEUPRE_B

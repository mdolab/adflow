!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of bceddynowall in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev
!   with respect to varying inputs: *rev
!   plus diff mem management of: rev:in bcdata:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          bceddynowall.f90                                *
!      * author:        georgi kalitzin, edwin van der weide            *
!      * starting date: 06-11-2003                                      *
!      * last modified: 04-11-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine bceddynowall_b(nn)
!
!      ******************************************************************
!      *                                                                *
!      * bceddynowall sets the eddy viscosity in the halo cells of      *
!      * subface nn of the block given in blockpointers. the boundary   *
!      * condition on the subface can be anything but a viscous wall.   *
!      * a homogeneous neumann condition is applied, which means that   *
!      * the eddy viscosity is simply copied from the interior cell.    *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use bctypes
  implicit none
!
!      subroutine arguments.
!
  integer(kind=inttype), intent(in) :: nn
!
!      local variables.
!
  integer(kind=inttype) :: i, j
  real(kind=realtype) :: tmp
  real(kind=realtype) :: tmp0
  real(kind=realtype) :: tmp1
  real(kind=realtype) :: tmpd
  real(kind=realtype) :: tmpd1
  real(kind=realtype) :: tmpd0
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! determine the face id on which the subface and copy
  select case  (bcfaceid(nn)) 
  case (imin) 
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        revd(2, i, j) = revd(2, i, j) + revd(1, i, j)
        revd(1, i, j) = 0.0_8
      end do
    end do
  case (imax) 
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        tmpd = revd(ie, i, j)
        revd(ie, i, j) = 0.0_8
        revd(il, i, j) = revd(il, i, j) + tmpd
      end do
    end do
  case (jmin) 
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        revd(i, 2, j) = revd(i, 2, j) + revd(i, 1, j)
        revd(i, 1, j) = 0.0_8
      end do
    end do
  case (jmax) 
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        tmpd0 = revd(i, je, j)
        revd(i, je, j) = 0.0_8
        revd(i, jl, j) = revd(i, jl, j) + tmpd0
      end do
    end do
  case (kmin) 
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        revd(i, j, 2) = revd(i, j, 2) + revd(i, j, 1)
        revd(i, j, 1) = 0.0_8
      end do
    end do
  case (kmax) 
    do j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
      do i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
        tmpd1 = revd(i, j, ke)
        revd(i, j, ke) = 0.0_8
        revd(i, j, kl) = revd(i, j, kl) + tmpd1
      end do
    end do
  end select
end subroutine bceddynowall_b

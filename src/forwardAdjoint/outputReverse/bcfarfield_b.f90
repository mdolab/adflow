   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcfarfield in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *p *gamma *w *rlv *(*bcdata.norm)
   !                gammainf tref winf pinfcorr rgas
   !   with respect to varying inputs: *rev *p *gamma *w *rlv *(*bcdata.norm)
   !                gammainf tref winf pinfcorr rgas
   !   Plus diff mem management of: rev:in p:in gamma:in w:in rlv:in
   !                bcdata:in *bcdata.norm:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcFarfield.f90                                  *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-10-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCFARFIELD_B(secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcFarfield applies the farfield boundary condition to a block. *
   !      * It is assumed that the pointers in blockPointers are already   *
   !      * set to the correct block on the correct grid level.            *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !close (UNIT=unitx)
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j, k, l
   REAL(kind=realtype) :: nnx, nny, nnz
   REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
   REAL(kind=realtype) :: gm1b, ovgm1b, ac1b, ac2b
   REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
   REAL(kind=realtype) :: r0b, u0b, v0b, w0b, qn0b, c0b, s0b
   REAL(kind=realtype) :: re, ue, ve, we, qne, ce
   REAL(kind=realtype) :: reb, ueb, veb, web, qneb, ceb
   REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
   REAL(kind=realtype) :: qnfb, cfb, ufb, vfb, wfb, sfb, ccb
   ! Variables Added for forward AD
   REAL(kind=realtype) :: rho, sf2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww1, ww2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww1b, ww2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp1, pp2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp1b, pp2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: gamma1, gamma2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: gamma1b, gamma2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv1b, rlv2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rev1, rev2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rev1b, rev2b
   INTRINSIC SQRT
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: tempb10
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Some constants needed to compute the riemann inVariants.
   gm1 = gammainf - one
   ovgm1 = one/gm1
   ! Compute the three velocity components, the speed of sound and
   ! the entropy of the free stream.
   r0 = one/winf(irho)
   u0 = winf(ivx)
   v0 = winf(ivy)
   w0 = winf(ivz)
   c0 = SQRT(gammainf*pinfcorr*r0)
   s0 = winf(irho)**gammainf/pinfcorr
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nn=1,nbocos
   ! Check for farfield boundary conditions.
   IF (bctype(nn) .EQ. farfield) THEN
   ! Nullify the pointers and set them to the correct subface.
   ! They are nullified first, because some compilers require
   ! that.
   !nullify(ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, rev2)
   CALL PUSHREAL8ARRAY(pp2, imaxdim*jmaxdim)
   CALL PUSHREAL8ARRAY(ww2, imaxdim*jmaxdim*nw)
   CALL PUSHREAL8ARRAY(ww1, imaxdim*jmaxdim*nw)
   CALL SETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, rev1&
   &                        , rev2, 0)
   ! Set the additional pointer for gamma2.
   CALL PUSHREAL8ARRAY(gamma2, imaxdim*jmaxdim)
   CALL SETGAMMABWD(nn, gamma1, gamma2)
   ad_from0 = bcdata(nn)%jcbeg
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO j=ad_from0,bcdata(nn)%jcend
   ad_from = bcdata(nn)%icbeg
   DO i=ad_from,bcdata(nn)%icend
   ! Store the three components of the unit normal a
   ! bit easier.
   ! replace with actual BCData - Peter Lyu 
   !nnx = BCData(nn)%norm(i,j,1)
   !nny = BCData(nn)%norm(i,j,2)
   !nnz = BCData(nn)%norm(i,j,3)
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   CALL PUSHREAL8(qn0)
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2&
   &           ) + w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   re = one/ww2(i, j, irho)
   CALL PUSHREAL8(ue)
   ue = ww2(i, j, ivx)
   CALL PUSHREAL8(ve)
   ve = ww2(i, j, ivy)
   CALL PUSHREAL8(we)
   we = ww2(i, j, ivz)
   CALL PUSHREAL8(qne)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2&
   &           ) + we*bcdata(nn)%norm(i, j, 3)
   CALL PUSHREAL8(ce)
   ce = SQRT(gamma2(i, j)*pp2(i, j)*re)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   CALL PUSHREAL8(ac1)
   ac1 = qne + two*ovgm1*ce
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Supersonic inflow.
   CALL PUSHREAL8(ac1)
   ac1 = qn0 + two*ovgm1*c0
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   CALL PUSHREAL8(ac2)
   ac2 = qne - two*ovgm1*ce
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Inflow or subsonic outflow.
   CALL PUSHREAL8(ac2)
   ac2 = qn0 - two*ovgm1*c0
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(qnf)
   qnf = half*(ac1+ac2)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   !Intermediate rho variable added to fix AD bug,ww2
   ! was not getting picked up here. Tapenade 3.6 Does
   ! this properly and this is not required:
   ! rho = ww2(i,j,irho) 
   ! sf = rho**gamma2(i,j)/pp2(i,j) 
   CALL PUSHREAL8(sf)
   sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Inflow
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   CALL PUSHREAL8(sf)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = winf(l)
   END DO
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   cc = cf*cf/gamma2(i, j)
   ww1(i, j, irho) = (sf*cc)**ovgm1
   ww1(i, j, ivx) = uf
   ww1(i, j, ivy) = vf
   ww1(i, j, ivz) = wf
   pp1(i, j) = ww1(i, j, irho)*cc
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) THEN
   rlv1(i, j) = rlv2(i, j)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev1(i, j) = rev2(i, j)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL RESETGAMMABWD(nn, gamma1, gamma2)
   ! deallocation all pointer
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL RESETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
   &                          rev1, rev2, 0)
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4)&
   &                  )
   CALL COMPUTEETOT(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                   kcbeg(nn), kcend(nn), correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, &
   &                     4))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL EXTRAPOLATE2NDHALO(nn, correctfork)
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO bocos
   v0b = 0.0_8
   gm1b = 0.0_8
   s0b = 0.0_8
   c0b = 0.0_8
   gamma1b = 0.0_8
   gamma2b = 0.0_8
   w0b = 0.0_8
   u0b = 0.0_8
   ovgm1b = 0.0_8
   DO nn=nbocos,1,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4&
   &                    ))
   CALL EXTRAPOLATE2NDHALO_B(nn, correctfork)
   END IF
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL COMPUTEETOT_B(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                  kcbeg(nn), kcend(nn), correctfork)
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL RESETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2&
   &                         , pp2b, rlv1, rlv1b, rlv2, rlv2b, rev1, rev1b&
   &                         , rev2, rev2b, 0)
   CALL RESETGAMMABWD_B(nn, gamma1, gamma1b, gamma2, gamma2b)
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   rev2b(i, j) = rev2b(i, j) + rev1b(i, j)
   rev1b(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2b(i, j) = rlv2b(i, j) + rlv1b(i, j)
   rlv1b(i, j) = 0.0_8
   END IF
   cf = fourth*(ac1-ac2)*gm1
   cc = cf*cf/gamma2(i, j)
   ww1b(i, j, irho) = ww1b(i, j, irho) + cc*pp1b(i, j)
   wfb = ww1b(i, j, ivz)
   ww1b(i, j, ivz) = 0.0_8
   vfb = ww1b(i, j, ivy)
   ww1b(i, j, ivy) = 0.0_8
   ufb = ww1b(i, j, ivx)
   ww1b(i, j, ivx) = 0.0_8
   temp4 = sf*cc
   IF (temp4 .LE. 0.0_8 .AND. (ovgm1 .EQ. 0.0_8 .OR. ovgm1 .NE. &
   &             INT(ovgm1))) THEN
   tempb11 = 0.0
   ELSE
   tempb11 = ovgm1*temp4**(ovgm1-1)*ww1b(i, j, irho)
   END IF
   ccb = sf*tempb11 + ww1(i, j, irho)*pp1b(i, j)
   pp1b(i, j) = 0.0_8
   sfb = cc*tempb11
   IF (.NOT.temp4 .LE. 0.0_8) ovgm1b = ovgm1b + temp4**ovgm1*LOG(&
   &             temp4)*ww1b(i, j, irho)
   ww1b(i, j, irho) = 0.0_8
   tempb12 = ccb/gamma2(i, j)
   cfb = 2*cf*tempb12
   gamma2b(i, j) = gamma2b(i, j) - cf**2*tempb12/gamma2(i, j)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   DO l=nt2mg,nt1mg,-1
   ww2b(i, j, l) = ww2b(i, j, l) + ww1b(i, j, l)
   ww1b(i, j, l) = 0.0_8
   END DO
   tempb7 = bcdata(nn)%norm(i, j, 1)*ufb
   tempb6 = bcdata(nn)%norm(i, j, 2)*vfb
   CALL POPREAL8(sf)
   tempb4 = sfb/pp2(i, j)
   temp3 = ww2(i, j, irho)
   temp2 = gamma2(i, j)
   temp1 = temp3**temp2
   IF (.NOT.(temp3 .LE. 0.0_8 .AND. (temp2 .EQ. 0.0_8 .OR. &
   &               temp2 .NE. INT(temp2)))) ww2b(i, j, irho) = ww2b(i, j, &
   &               irho) + temp2*temp3**(temp2-1)*tempb4
   IF (.NOT.temp3 .LE. 0.0_8) gamma2b(i, j) = gamma2b(i, j) + &
   &               temp1*LOG(temp3)*tempb4
   pp2b(i, j) = pp2b(i, j) - temp1*tempb4/pp2(i, j)
   tempb5 = bcdata(nn)%norm(i, j, 3)*wfb
   web = wfb
   qnfb = tempb6 + tempb7 + tempb5
   qneb = -tempb6 - tempb7 - tempb5
   bcdatab(nn)%norm(i, j, 3) = bcdatab(nn)%norm(i, j, 3) + (qnf&
   &             -qne)*wfb
   veb = vfb
   bcdatab(nn)%norm(i, j, 2) = bcdatab(nn)%norm(i, j, 2) + (qnf&
   &             -qne)*vfb
   ueb = ufb
   bcdatab(nn)%norm(i, j, 1) = bcdatab(nn)%norm(i, j, 1) + (qnf&
   &             -qne)*ufb
   qn0b = 0.0_8
   ELSE
   DO l=nt2mg,nt1mg,-1
   winfb(l) = winfb(l) + ww1b(i, j, l)
   ww1b(i, j, l) = 0.0_8
   END DO
   tempb10 = bcdata(nn)%norm(i, j, 1)*ufb
   tempb9 = bcdata(nn)%norm(i, j, 2)*vfb
   CALL POPREAL8(sf)
   s0b = s0b + sfb
   tempb8 = bcdata(nn)%norm(i, j, 3)*wfb
   w0b = w0b + wfb
   qnfb = tempb9 + tempb10 + tempb8
   qn0b = -tempb9 - tempb10 - tempb8
   bcdatab(nn)%norm(i, j, 3) = bcdatab(nn)%norm(i, j, 3) + (qnf&
   &             -qn0)*wfb
   v0b = v0b + vfb
   bcdatab(nn)%norm(i, j, 2) = bcdatab(nn)%norm(i, j, 2) + (qnf&
   &             -qn0)*vfb
   u0b = u0b + ufb
   bcdatab(nn)%norm(i, j, 1) = bcdatab(nn)%norm(i, j, 1) + (qnf&
   &             -qn0)*ufb
   ue = ww2(i, j, ivx)
   ve = ww2(i, j, ivy)
   we = ww2(i, j, ivz)
   qneb = 0.0_8
   ueb = 0.0_8
   veb = 0.0_8
   web = 0.0_8
   END IF
   tempb3 = fourth*cfb
   ac1b = half*qnfb + gm1*tempb3
   ac2b = half*qnfb - gm1*tempb3
   gm1b = gm1b + (ac1-ac2)*tempb3
   CALL POPREAL8(qnf)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(ac2)
   qneb = qneb + ac2b
   ovgm1b = ovgm1b - two*ce*ac2b
   ceb = -(two*ovgm1*ac2b)
   ELSE
   CALL POPREAL8(ac2)
   qn0b = qn0b + ac2b
   ovgm1b = ovgm1b - two*c0*ac2b
   c0b = c0b - two*ovgm1*ac2b
   ceb = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(ac1)
   qneb = qneb + ac1b
   ovgm1b = ovgm1b + two*ce*ac1b
   ceb = ceb + two*ovgm1*ac1b
   ELSE
   CALL POPREAL8(ac1)
   qn0b = qn0b + ac1b
   ovgm1b = ovgm1b + two*c0*ac1b
   c0b = c0b + two*ovgm1*ac1b
   END IF
   re = one/ww2(i, j, irho)
   CALL POPREAL8(ce)
   temp0 = gamma2(i, j)*re
   IF (temp0*pp2(i, j) .EQ. 0.0_8) THEN
   tempb1 = 0.0
   ELSE
   tempb1 = ceb/(2.0*SQRT(temp0*pp2(i, j)))
   END IF
   tempb2 = pp2(i, j)*tempb1
   gamma2b(i, j) = gamma2b(i, j) + re*tempb2
   reb = gamma2(i, j)*tempb2
   pp2b(i, j) = pp2b(i, j) + temp0*tempb1
   CALL POPREAL8(qne)
   ueb = ueb + bcdata(nn)%norm(i, j, 1)*qneb
   bcdatab(nn)%norm(i, j, 1) = bcdatab(nn)%norm(i, j, 1) + ue*&
   &           qneb
   veb = veb + bcdata(nn)%norm(i, j, 2)*qneb
   bcdatab(nn)%norm(i, j, 2) = bcdatab(nn)%norm(i, j, 2) + ve*&
   &           qneb
   web = web + bcdata(nn)%norm(i, j, 3)*qneb
   bcdatab(nn)%norm(i, j, 3) = bcdatab(nn)%norm(i, j, 3) + we*&
   &           qneb
   CALL POPREAL8(we)
   ww2b(i, j, ivz) = ww2b(i, j, ivz) + web
   CALL POPREAL8(ve)
   ww2b(i, j, ivy) = ww2b(i, j, ivy) + veb
   CALL POPREAL8(ue)
   ww2b(i, j, ivx) = ww2b(i, j, ivx) + ueb
   ww2b(i, j, irho) = ww2b(i, j, irho) - one*reb/ww2(i, j, irho)&
   &           **2
   CALL POPREAL8(qn0)
   u0b = u0b + bcdata(nn)%norm(i, j, 1)*qn0b
   bcdatab(nn)%norm(i, j, 1) = bcdatab(nn)%norm(i, j, 1) + u0*&
   &           qn0b
   v0b = v0b + bcdata(nn)%norm(i, j, 2)*qn0b
   bcdatab(nn)%norm(i, j, 2) = bcdatab(nn)%norm(i, j, 2) + v0*&
   &           qn0b
   w0b = w0b + bcdata(nn)%norm(i, j, 3)*qn0b
   bcdatab(nn)%norm(i, j, 3) = bcdatab(nn)%norm(i, j, 3) + w0*&
   &           qn0b
   END DO
   END DO
   CALL POPREAL8ARRAY(gamma2, imaxdim*jmaxdim)
   CALL SETGAMMABWD_B(nn, gamma1, gamma1b, gamma2, gamma2b)
   CALL POPREAL8ARRAY(ww1, imaxdim*jmaxdim*nw)
   CALL POPREAL8ARRAY(ww2, imaxdim*jmaxdim*nw)
   CALL POPREAL8ARRAY(pp2, imaxdim*jmaxdim)
   CALL SETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2, &
   &                       pp2b, rlv1, rlv1b, rlv2, rlv2b, rev1, rev1b, &
   &                       rev2, rev2b, 0)
   END IF
   END DO
   gm1b = gm1b - one*ovgm1b/gm1**2
   IF (gammainf*pinfcorr*r0 .EQ. 0.0_8) THEN
   tempb0 = 0.0
   ELSE
   tempb0 = c0b/(2.0*SQRT(gammainf*pinfcorr*r0))
   END IF
   tempb = s0b/pinfcorr
   temp = winf(irho)**gammainf
   IF (.NOT.(winf(irho) .LE. 0.0_8 .AND. (gammainf .EQ. 0.0_8 .OR. &
   &     gammainf .NE. INT(gammainf)))) winfb(irho) = winfb(irho) + &
   &     gammainf*winf(irho)**(gammainf-1)*tempb
   IF (winf(irho) .LE. 0.0_8) THEN
   gammainfb = gammainfb + r0*pinfcorr*tempb0 + gm1b
   ELSE
   gammainfb = gammainfb + r0*pinfcorr*tempb0 + gm1b + temp*LOG(winf(&
   &     irho))*tempb
   END IF
   pinfcorrb = pinfcorrb + r0*gammainf*tempb0 - temp*tempb/pinfcorr
   r0b = gammainf*pinfcorr*tempb0
   winfb(ivz) = winfb(ivz) + w0b
   winfb(ivy) = winfb(ivy) + v0b
   winfb(ivx) = winfb(ivx) + u0b
   winfb(irho) = winfb(irho) - one*r0b/winf(irho)**2
   END SUBROUTINE BCFARFIELD_B

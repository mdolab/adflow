   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of turbbcnswall in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *bvtj1 *bvtj2 *w *rlv
   !                *bvtk1 *bvtk2 *bvti1 *bvti2
   !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *w *rlv
   !                *bvtk1 *bvtk2 *bvti1 *bvti2
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
   !                rlv:in bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          turbBCNSWall.f90                                *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 05-30-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE TURBBCNSWALL_B(secondhalo)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * turbBCNSWall applies the viscous wall boundary conditions      *
   !      * of the turbulent transport equations to a block. It is assumed *
   !      * that the pointers in blockPointers are already set to the      *
   !      * correct block on the correct grid level.                       *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS_B
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !
   !      Subroutine argument.
   !
   LOGICAL, INTENT(IN) :: secondhalo
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j, l, m
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   REAL(kind=realtype) :: tmp3
   REAL(kind=realtype) :: tmp4
   REAL(kind=realtype) :: tmp5
   REAL(kind=realtype) :: tmp6
   REAL(kind=realtype) :: tmp7
   REAL(kind=realtype) :: tmp8
   REAL(kind=realtype) :: tmp9
   REAL(kind=realtype) :: tmp10
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: ad_from5
   INTEGER :: ad_to5
   INTEGER :: ad_from6
   INTEGER :: ad_to6
   INTEGER :: ad_from7
   INTEGER :: ad_to7
   INTEGER :: ad_from8
   INTEGER :: ad_to8
   INTEGER :: ad_from9
   INTEGER :: ad_to9
   INTEGER :: ad_from10
   INTEGER :: ad_to10
   REAL(kind=realtype) :: tmpb9
   REAL(kind=realtype) :: tmpb8
   REAL(kind=realtype) :: tmpb7
   REAL(kind=realtype) :: tmpb6
   REAL(kind=realtype) :: tmpb5
   REAL(kind=realtype) :: tmpb4
   REAL(kind=realtype) :: tmpb3
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tmpb2
   REAL(kind=realtype) :: tmpb1
   REAL(kind=realtype) :: tmpb0
   REAL(kind=realtype) :: tmpb10
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Loop over the viscous subfaces of this block.
   bocos:DO nn=1,nviscbocos
   ! Set the corresponding arrays.
   CALL PUSHREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2&
   &                 , 3)*SIZE(bmtj2, 4))
   CALL PUSHREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1&
   &                 , 3)*SIZE(bmtj1, 4))
   CALL PUSHREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2&
   &                 , 3)*SIZE(bmti2, 4))
   CALL PUSHREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1&
   &                 , 3)*SIZE(bmti1, 4))
   CALL PUSHREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2&
   &                 , 3)*SIZE(bmtk2, 4))
   CALL PUSHREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1&
   &                 , 3)*SIZE(bmtk1, 4))
   CALL BCTURBWALL(nn)
   ! Loop over the faces and set the state in
   ! the turbulent halo cells.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   ad_from0 = bcdata(nn)%jcbeg
   DO j=ad_from0,bcdata(nn)%jcend
   ad_from = bcdata(nn)%icbeg
   DO i=ad_from,bcdata(nn)%icend
   DO l=nt1,nt2
   CALL PUSHREAL8(w(1, i, j, l))
   w(1, i, j, l) = bvti1(i, j, l)
   DO m=nt1,nt2
   CALL PUSHREAL8(w(1, i, j, l))
   w(1, i, j, l) = w(1, i, j, l) - bmti1(i, j, l, m)*w(2, i, &
   &               j, m)
   END DO
   IF (secondhalo) THEN
   CALL PUSHREAL8(w(0, i, j, l))
   w(0, i, j, l) = w(1, i, j, l)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   IF (eddymodel) THEN
   IF (secondhalo) THEN
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL3B(5)
   CASE (imax) 
   ad_from2 = bcdata(nn)%jcbeg
   DO j=ad_from2,bcdata(nn)%jcend
   ad_from1 = bcdata(nn)%icbeg
   DO i=ad_from1,bcdata(nn)%icend
   DO l=nt1,nt2
   CALL PUSHREAL8(w(ie, i, j, l))
   w(ie, i, j, l) = bvti2(i, j, l)
   DO m=nt1,nt2
   tmp = w(ie, i, j, l) - bmti2(i, j, l, m)*w(il, i, j, m)
   CALL PUSHREAL8(w(ie, i, j, l))
   w(ie, i, j, l) = tmp
   END DO
   IF (secondhalo) THEN
   tmp0 = w(ie, i, j, l)
   CALL PUSHREAL8(w(ib, i, j, l))
   w(ib, i, j, l) = tmp0
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   IF (eddymodel) THEN
   IF (secondhalo) THEN
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from2)
   CALL PUSHCONTROL3B(4)
   CASE (jmin) 
   ad_from4 = bcdata(nn)%jcbeg
   DO j=ad_from4,bcdata(nn)%jcend
   ad_from3 = bcdata(nn)%icbeg
   DO i=ad_from3,bcdata(nn)%icend
   DO l=nt1,nt2
   CALL PUSHREAL8(w(i, 1, j, l))
   w(i, 1, j, l) = bvtj1(i, j, l)
   DO m=nt1,nt2
   CALL PUSHREAL8(w(i, 1, j, l))
   w(i, 1, j, l) = w(i, 1, j, l) - bmtj1(i, j, l, m)*w(i, 2, &
   &               j, m)
   END DO
   IF (secondhalo) THEN
   CALL PUSHREAL8(w(i, 0, j, l))
   w(i, 0, j, l) = w(i, 1, j, l)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   IF (eddymodel) THEN
   IF (secondhalo) THEN
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   ad_from6 = bcdata(nn)%jcbeg
   DO j=ad_from6,bcdata(nn)%jcend
   ad_from5 = bcdata(nn)%icbeg
   DO i=ad_from5,bcdata(nn)%icend
   DO l=nt1,nt2
   CALL PUSHREAL8(w(i, je, j, l))
   w(i, je, j, l) = bvtj2(i, j, l)
   DO m=nt1,nt2
   tmp3 = w(i, je, j, l) - bmtj2(i, j, l, m)*w(i, jl, j, m)
   CALL PUSHREAL8(w(i, je, j, l))
   w(i, je, j, l) = tmp3
   END DO
   IF (secondhalo) THEN
   tmp4 = w(i, je, j, l)
   CALL PUSHREAL8(w(i, jb, j, l))
   w(i, jb, j, l) = tmp4
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   IF (eddymodel) THEN
   IF (secondhalo) THEN
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from5)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from6)
   CALL PUSHCONTROL3B(2)
   CASE (kmin) 
   ad_from8 = bcdata(nn)%jcbeg
   DO j=ad_from8,bcdata(nn)%jcend
   ad_from7 = bcdata(nn)%icbeg
   DO i=ad_from7,bcdata(nn)%icend
   DO l=nt1,nt2
   CALL PUSHREAL8(w(i, j, 1, l))
   w(i, j, 1, l) = bvtk1(i, j, l)
   DO m=nt1,nt2
   CALL PUSHREAL8(w(i, j, 1, l))
   w(i, j, 1, l) = w(i, j, 1, l) - bmtk1(i, j, l, m)*w(i, j, &
   &               2, m)
   END DO
   IF (secondhalo) THEN
   CALL PUSHREAL8(w(i, j, 0, l))
   w(i, j, 0, l) = w(i, j, 1, l)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   IF (eddymodel) THEN
   IF (secondhalo) THEN
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from7)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from8)
   CALL PUSHCONTROL3B(1)
   CASE (kmax) 
   ad_from10 = bcdata(nn)%jcbeg
   DO j=ad_from10,bcdata(nn)%jcend
   ad_from9 = bcdata(nn)%icbeg
   DO i=ad_from9,bcdata(nn)%icend
   DO l=nt1,nt2
   CALL PUSHREAL8(w(i, j, ke, l))
   w(i, j, ke, l) = bvtk2(i, j, l)
   DO m=nt1,nt2
   tmp7 = w(i, j, ke, l) - bmtk2(i, j, l, m)*w(i, j, kl, m)
   CALL PUSHREAL8(w(i, j, ke, l))
   w(i, j, ke, l) = tmp7
   END DO
   IF (secondhalo) THEN
   tmp8 = w(i, j, ke, l)
   CALL PUSHREAL8(w(i, j, kb, l))
   w(i, j, kb, l) = tmp8
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   IF (eddymodel) THEN
   IF (secondhalo) THEN
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from9)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from10)
   CALL PUSHCONTROL3B(0)
   CASE DEFAULT
   CALL PUSHCONTROL3B(6)
   END SELECT
   END DO bocos
   DO nn=nviscbocos,1,-1
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ad_from10)
   CALL POPINTEGER4(ad_to10)
   DO j=ad_to10,ad_from10,-1
   CALL POPINTEGER4(ad_from9)
   CALL POPINTEGER4(ad_to9)
   DO i=ad_to9,ad_from9,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   tmpb10 = revb(i, j, kb)
   revb(i, j, kb) = 0.0_8
   revb(i, j, ke) = revb(i, j, ke) + tmpb10
   END IF
   tmpb9 = revb(i, j, ke)
   revb(i, j, ke) = 0.0_8
   revb(i, j, kl) = revb(i, j, kl) - tmpb9
   END IF
   DO l=nt2,nt1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8(w(i, j, kb, l))
   tmpb8 = wb(i, j, kb, l)
   wb(i, j, kb, l) = 0.0_8
   wb(i, j, ke, l) = wb(i, j, ke, l) + tmpb8
   END IF
   DO m=nt2,nt1,-1
   CALL POPREAL8(w(i, j, ke, l))
   tmpb7 = wb(i, j, ke, l)
   wb(i, j, ke, l) = tmpb7
   wb(i, j, kl, m) = wb(i, j, kl, m) - bmtk2(i, j, l, m)*&
   &                 tmpb7
   END DO
   CALL POPREAL8(w(i, j, ke, l))
   bvtk2b(i, j, l) = bvtk2b(i, j, l) + wb(i, j, ke, l)
   wb(i, j, ke, l) = 0.0_8
   END DO
   END DO
   END DO
   ELSE IF (branch .EQ. 1) THEN
   CALL POPINTEGER4(ad_from8)
   CALL POPINTEGER4(ad_to8)
   DO j=ad_to8,ad_from8,-1
   CALL POPINTEGER4(ad_from7)
   CALL POPINTEGER4(ad_to7)
   DO i=ad_to7,ad_from7,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   revb(i, j, 1) = revb(i, j, 1) + revb(i, j, 0)
   revb(i, j, 0) = 0.0_8
   END IF
   revb(i, j, 2) = revb(i, j, 2) - revb(i, j, 1)
   revb(i, j, 1) = 0.0_8
   END IF
   DO l=nt2,nt1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8(w(i, j, 0, l))
   wb(i, j, 1, l) = wb(i, j, 1, l) + wb(i, j, 0, l)
   wb(i, j, 0, l) = 0.0_8
   END IF
   DO m=nt2,nt1,-1
   CALL POPREAL8(w(i, j, 1, l))
   wb(i, j, 2, m) = wb(i, j, 2, m) - bmtk1(i, j, l, m)*wb(i&
   &                 , j, 1, l)
   END DO
   CALL POPREAL8(w(i, j, 1, l))
   bvtk1b(i, j, l) = bvtk1b(i, j, l) + wb(i, j, 1, l)
   wb(i, j, 1, l) = 0.0_8
   END DO
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO j=ad_to6,ad_from6,-1
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO i=ad_to5,ad_from5,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   tmpb6 = revb(i, jb, j)
   revb(i, jb, j) = 0.0_8
   revb(i, je, j) = revb(i, je, j) + tmpb6
   END IF
   tmpb5 = revb(i, je, j)
   revb(i, je, j) = 0.0_8
   revb(i, jl, j) = revb(i, jl, j) - tmpb5
   END IF
   DO l=nt2,nt1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8(w(i, jb, j, l))
   tmpb4 = wb(i, jb, j, l)
   wb(i, jb, j, l) = 0.0_8
   wb(i, je, j, l) = wb(i, je, j, l) + tmpb4
   END IF
   DO m=nt2,nt1,-1
   CALL POPREAL8(w(i, je, j, l))
   tmpb3 = wb(i, je, j, l)
   wb(i, je, j, l) = tmpb3
   wb(i, jl, j, m) = wb(i, jl, j, m) - bmtj2(i, j, l, m)*&
   &                 tmpb3
   END DO
   CALL POPREAL8(w(i, je, j, l))
   bvtj2b(i, j, l) = bvtj2b(i, j, l) + wb(i, je, j, l)
   wb(i, je, j, l) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO i=ad_to3,ad_from3,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   revb(i, 1, j) = revb(i, 1, j) + revb(i, 0, j)
   revb(i, 0, j) = 0.0_8
   END IF
   revb(i, 2, j) = revb(i, 2, j) - revb(i, 1, j)
   revb(i, 1, j) = 0.0_8
   END IF
   DO l=nt2,nt1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8(w(i, 0, j, l))
   wb(i, 1, j, l) = wb(i, 1, j, l) + wb(i, 0, j, l)
   wb(i, 0, j, l) = 0.0_8
   END IF
   DO m=nt2,nt1,-1
   CALL POPREAL8(w(i, 1, j, l))
   wb(i, 2, j, m) = wb(i, 2, j, m) - bmtj1(i, j, l, m)*wb(i&
   &                 , 1, j, l)
   END DO
   CALL POPREAL8(w(i, 1, j, l))
   bvtj1b(i, j, l) = bvtj1b(i, j, l) + wb(i, 1, j, l)
   wb(i, 1, j, l) = 0.0_8
   END DO
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO j=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   tmpb2 = revb(ib, i, j)
   revb(ib, i, j) = 0.0_8
   revb(ie, i, j) = revb(ie, i, j) + tmpb2
   END IF
   tmpb1 = revb(ie, i, j)
   revb(ie, i, j) = 0.0_8
   revb(il, i, j) = revb(il, i, j) - tmpb1
   END IF
   DO l=nt2,nt1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8(w(ib, i, j, l))
   tmpb0 = wb(ib, i, j, l)
   wb(ib, i, j, l) = 0.0_8
   wb(ie, i, j, l) = wb(ie, i, j, l) + tmpb0
   END IF
   DO m=nt2,nt1,-1
   CALL POPREAL8(w(ie, i, j, l))
   tmpb = wb(ie, i, j, l)
   wb(ie, i, j, l) = tmpb
   wb(il, i, j, m) = wb(il, i, j, m) - bmti2(i, j, l, m)*&
   &                 tmpb
   END DO
   CALL POPREAL8(w(ie, i, j, l))
   bvti2b(i, j, l) = bvti2b(i, j, l) + wb(ie, i, j, l)
   wb(ie, i, j, l) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   ELSE IF (branch .EQ. 5) THEN
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   revb(1, i, j) = revb(1, i, j) + revb(0, i, j)
   revb(0, i, j) = 0.0_8
   END IF
   revb(2, i, j) = revb(2, i, j) - revb(1, i, j)
   revb(1, i, j) = 0.0_8
   END IF
   DO l=nt2,nt1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8(w(0, i, j, l))
   wb(1, i, j, l) = wb(1, i, j, l) + wb(0, i, j, l)
   wb(0, i, j, l) = 0.0_8
   END IF
   DO m=nt2,nt1,-1
   CALL POPREAL8(w(1, i, j, l))
   wb(2, i, j, m) = wb(2, i, j, m) - bmti1(i, j, l, m)*wb(1, &
   &               i, j, l)
   END DO
   CALL POPREAL8(w(1, i, j, l))
   bvti1b(i, j, l) = bvti1b(i, j, l) + wb(1, i, j, l)
   wb(1, i, j, l) = 0.0_8
   END DO
   END DO
   END DO
   END IF
   CALL POPREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1, &
   &                3)*SIZE(bmtk1, 4))
   CALL POPREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2, &
   &                3)*SIZE(bmtk2, 4))
   CALL POPREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1, &
   &                3)*SIZE(bmti1, 4))
   CALL POPREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2, &
   &                3)*SIZE(bmti2, 4))
   CALL POPREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1, &
   &                3)*SIZE(bmtj1, 4))
   CALL POPREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2, &
   &                3)*SIZE(bmtj2, 4))
   CALL BCTURBWALL_B(nn)
   END DO
   END SUBROUTINE TURBBCNSWALL_B

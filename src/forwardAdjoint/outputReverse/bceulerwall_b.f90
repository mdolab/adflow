   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bceulerwall in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *p *w *rlv
   !   with respect to varying inputs: *p *w *rlv
   !   Plus diff mem management of: p:in w:in rlv:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcEulerWall.f90                                 *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-07-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCEULERWALL_B(secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcEulerWall applies the inviscid wall boundary condition to    *
   !      * a block. It is assumed that the pointers in blockPointers are  *
   !      * already set to the correct block on the correct grid level.    *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, j, k, l
   INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
   INTEGER(kind=inttype) :: walltreatment
   REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
   REAL(kind=realtype) :: skxa, skya, skza, a1, b1
   REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
   REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
   REAL(kind=realtype) :: vnb
   REAL(kind=realtype) :: ux, uy, uz
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww1, ww2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww1b, ww2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp1, pp2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp1b, pp2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp3, pp4
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv1b, rlv2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rev1, rev2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, 3) :: ssi, ssj, ssk
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, 3) :: ss
   REAL(kind=realtype) :: DIM
   REAL(kind=realtype) :: tmp
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: branch
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tempb
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Make sure that on the coarser grids the constant pressure
   ! boundary condition is used.
   walltreatment = wallbctreatment
   IF (currentlevel .GT. groundlevel) walltreatment = constantpressure
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nn=1,nbocos
   ! Check for Euler wall boundary condition.
   IF (bctype(nn) .EQ. eulerwall) THEN
   ! Set the pointers for the unit normal and the normal
   ! velocity to make the code more readable.
   !norm  => BCData(nn)%norm
   !rface => BCData(nn)%rface
   ! Nullify the pointers and set them to the correct subface.
   ! They are nullified first, because some compilers require
   ! that.
   !nullify(ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, rev2)
   CALL PUSHREAL8ARRAY(pp2, imaxdim*jmaxdim)
   CALL SETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, rev1&
   &                        , rev2, 0)
   !!$
   !!$             !===========================================================
   !!$
   !!$             case (linExtrapolPressure)
   !!$
   !!$               ! Linear extrapolation. First set the additional pointer
   !!$               ! for pp3, depending on the block face.
   !!$
   !!$#ifndef 1
   !!$               call setpp3pp4(nn, pp3, pp4)
   !!$#else
   !!$               call setpp3pp4Bwd(nn, pp3, pp4)
   !!$#endif
   !!$               ! Compute the gradient.
   !!$
   !!$               do k=BCData(nn)%jcBeg, BCData(nn)%jcEnd
   !!$                 do j=BCData(nn)%icBeg, BCData(nn)%icEnd
   !!$                   pp1(j,k) = pp3(j,k) - pp2(j,k)
   !!$                 enddo
   !!$               enddo
   !!$
   !!$#ifndef 1
   !!$               call resetpp3pp4(nn, pp3, pp4)
   !!$#else
   !!$               call resetpp3pp4Bwd(nn, pp3, pp4)
   !!$#endif
   !!$
   !!$
   !!$             !===========================================================
   !!$
   !!$             case (quadExtrapolPressure)
   !!$
   !!$               ! Quadratic extrapolation. First set the additional
   !!$               ! pointers for pp3 and pp4, depending on the block face.
   !!$
   !!$#ifndef 1
   !!$               call setpp3pp4(nn, pp3, pp4)
   !!$#else
   !!$               call setpp3pp4Bwd(nn, pp3, pp4)
   !!$#endif
   !!$
   !!$               ! Compute the gradient.
   !!$
   !!$               do k=BCData(nn)%jcBeg, BCData(nn)%jcEnd
   !!$                 do j=BCData(nn)%icBeg, BCData(nn)%icEnd
   !!$                   pp1(j,k) = two*pp3(j,k) - 1.5_realType*pp2(j,k) &
   !!$                            - half*pp4(j,k)
   !!$                 enddo
   !!$               enddo
   !!$
   !!$#ifndef 1
   !!$               call resetpp3pp4(nn, pp3, pp4)
   !!$#else
   !!$               call resetpp3pp4Bwd(nn, pp3, pp4)
   !!$#endif
   !!$
   !!$             !===========================================================
   !!$
   !!$             case (normalMomentum)
   !!$
   !!$               ! Pressure gradient is computed using the normal momentum
   !!$               ! equation. First set a couple of additional variables for
   !!$               ! the normals, depending on the block face. Note that the
   !!$               ! construction 1: should not be used in these pointers,
   !!$               ! because element 0 is needed. Consequently there will be
   !!$               ! an offset of 1 for these normals. This is commented in
   !!$               ! the code. For moving faces also the grid velocity of
   !!$               ! the 1st cell center from the wall is needed.
   !!$
   !!$#ifndef 1
   !!$               call setss(nn, ssi, ssj, ssk, ss)
   !!$#else
   !!$               call setssBwd(nn, ssi, ssj, ssk, ss)
   !!$#endif
   !!$
   !!$
   !!$               ! Loop over the faces of the generic subface.
   !!$
   !!$               do k=BCData(nn)%jcBeg, BCData(nn)%jcEnd
   !!$
   !!$                 ! Store the indices k+1, k-1 a bit easier and make
   !!$                 ! sure that they do not exceed the range of the arrays.
   !!$
   !!$                 km1 = k-1; km1 = max(BCData(nn)%jcBeg,km1)
   !!$                 kp1 = k+1; kp1 = min(BCData(nn)%jcEnd,kp1)
   !!$
   !!$                 ! Compute the scaling factor for the central difference
   !!$                 ! in the k-direction.
   !!$
   !!$                 b1 = one/max(1_intType,(kp1-km1))
   !!$
   !!$                 ! The j-loop.
   !!$
   !!$                 do j=BCData(nn)%icBeg, BCData(nn)%icEnd
   !!$
   !!$                   ! The indices j+1 and j-1. Make sure that they
   !!$                   ! do not exceed the range of the arrays.
   !!$
   !!$                   jm1 = j-1; jm1 = max(BCData(nn)%icBeg,jm1)
   !!$                   jp1 = j+1; jp1 = min(BCData(nn)%icEnd,jp1)
   !!$
   !!$                   ! Compute the scaling factor for the central
   !!$                   ! difference in the j-direction.
   !!$
   !!$                   a1 = one/max(1_intType,(jp1-jm1))
   !!$
   !!$                   ! Compute (twice) the average normal in the generic i,
   !!$                   ! j and k-direction. Note that in j and k-direction
   !!$                   ! the average in the original indices should be taken
   !!$                   ! using j-1 and j (and k-1 and k). However due to the
   !!$                   ! usage of pointers ssj and ssk there is an offset in
   !!$                   ! the indices of 1 and therefore now the correct
   !!$                   ! average is obtained with the indices j and j+1
   !!$                   ! (k and k+1).
   !!$
   !!$                   sixa = two*ssi(j,k,1)
   !!$                   siya = two*ssi(j,k,2)
   !!$                   siza = two*ssi(j,k,3)
   !!$
   !!$                   sjxa = ssj(j,k,1) + ssj(j+1,k,1)
   !!$                   sjya = ssj(j,k,2) + ssj(j+1,k,2)
   !!$                   sjza = ssj(j,k,3) + ssj(j+1,k,3)
   !!$
   !!$                   skxa = ssk(j,k,1) + ssk(j,k+1,1)
   !!$                   skya = ssk(j,k,2) + ssk(j,k+1,2)
   !!$                   skza = ssk(j,k,3) + ssk(j,k+1,3)
   !!$
   !!$                   ! Compute the difference of the normal vector and
   !!$                   ! pressure in j and k-direction. As the indices are
   !!$                   ! restricted to the 1st halo-layer, the computation
   !!$                   ! of the internal halo values is not consistent;
   !!$                   ! however this is not really a problem, because these
   !!$                   ! values are overwritten in the communication pattern.
   !!$
   !!$                   rxj = a1*(BCData(nn)%norm(jp1,k,1) - BCData(nn)%norm(jm1,k,1))
   !!$                   ryj = a1*(BCData(nn)%norm(jp1,k,2) - BCData(nn)%norm(jm1,k,2))
   !!$                   rzj = a1*(BCData(nn)%norm(jp1,k,3) - BCData(nn)%norm(jm1,k,3))
   !!$                   dpj = a1*(pp2(jp1,k)    - pp2(jm1,k))
   !!$
   !!$                   rxk = b1*(BCData(nn)%norm(j,kp1,1) - BCData(nn)%norm(j,km1,1))
   !!$                   ryk = b1*(BCData(nn)%norm(j,kp1,2) - BCData(nn)%norm(j,km1,2))
   !!$                   rzk = b1*(BCData(nn)%norm(j,kp1,3) - BCData(nn)%norm(j,km1,3))
   !!$                   dpk = b1*(pp2(j,kp1)    - pp2(j,km1))
   !!$
   !!$                   ! Compute the dot product between the unit vector
   !!$                   ! and the normal vectors in i, j and k-direction.
   !!$
   !!$                   ri = BCData(nn)%norm(j,k,1)*sixa + BCData(nn)%norm(j,k,2)*siya &
   !!$                      + BCData(nn)%norm(j,k,3)*siza
   !!$                   rj = BCData(nn)%norm(j,k,1)*sjxa + BCData(nn)%norm(j,k,2)*sjya &
   !!$                      + BCData(nn)%norm(j,k,3)*sjza
   !!$                   rk = BCData(nn)%norm(j,k,1)*skxa + BCData(nn)%norm(j,k,2)*skya &
   !!$                      + BCData(nn)%norm(j,k,3)*skza
   !!$
   !!$                   ! Store the velocity components in ux, uy and uz and
   !!$                   ! subtract the mesh velocity if the face is moving.
   !!$
   !!$                   ux = ww2(j,k,ivx)
   !!$                   uy = ww2(j,k,ivy)
   !!$                   uz = ww2(j,k,ivz)
   !!$
   !!$                   if( addGridVelocities ) then
   !!$                     ux = ux - ss(j,k,1)
   !!$                     uy = uy - ss(j,k,2)
   !!$                     uz = uz - ss(j,k,3)
   !!$                   endif
   !!$
   !!$                   ! Compute the velocity components in j and
   !!$                   ! k-direction.
   !!$
   !!$                   qj = ux*sjxa + uy*sjya + uz*sjza
   !!$                   qk = ux*skxa + uy*skya + uz*skza
   !!$
   !!$                   ! Compute the pressure gradient, which is stored
   !!$                   ! in pp1. I'm not entirely sure whether this
   !!$                   ! formulation is correct for moving meshes. It could
   !!$                   ! be that an additional term is needed there.
   !!$
   !!$                   pp1(j,k) = ((qj*(ux*rxj + uy*ryj + uz*rzj)      &
   !!$                            +   qk*(ux*rxk + uy*ryk + uz*rzk))     &
   !!$                            *  ww2(j,k,irho) - rj*dpj - rk*dpk)/ri
   !!$                 enddo
   !!$               enddo
   !!$
   !!$#ifndef 1
   !!$               call resetss(nn, ssi, ssj, ssk, ss)
   !!$#else
   !!$               call resetssBwd(nn, ssi, ssj, ssk, ss)
   !!$#endif
   !
   !          **************************************************************
   !          *                                                            *
   !          * Determine the boundary condition treatment and compute the *
   !          * undivided pressure gradient accordingly. This gradient is  *
   !          * temporarily stored in the halo pressure.                   *
   !          *                                                            *
   !          **************************************************************
   !
   SELECT CASE  (walltreatment) 
   CASE (constantpressure) 
   ad_from0 = bcdata(nn)%jcbeg
   ! Constant pressure. Set the gradient to zero.
   DO k=ad_from0,bcdata(nn)%jcend
   ad_from = bcdata(nn)%icbeg
   DO j=ad_from,bcdata(nn)%icend
   pp1(j, k) = zero
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL1B(0)
   CASE DEFAULT
   CALL PUSHCONTROL1B(1)
   END SELECT
   ad_from2 = bcdata(nn)%jcbeg
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO k=ad_from2,bcdata(nn)%jcend
   ad_from1 = bcdata(nn)%icbeg
   DO j=ad_from1,bcdata(nn)%icend
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   tmp = DIM(pp2(j, k), pp1(j, k))
   CALL PUSHREAL8(pp1(j, k))
   pp1(j, k) = tmp
   vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%&
   &           norm(j, k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j&
   &           , k, ivz)*bcdata(nn)%norm(j, k, 3))
   ww1(j, k, irho) = ww2(j, k, irho)
   ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
   ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
   ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   ww1(j, k, l) = ww2(j, k, l)
   END DO
   ! The laminar and eddy viscosity, if present.
   IF (viscous) THEN
   rlv1(j, k) = rlv2(j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) rev1(j, k) = rev2(j, k)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(k - 1)
   CALL PUSHINTEGER4(ad_from2)
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4)&
   &                  )
   CALL COMPUTEETOT(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                   kcbeg(nn), kcend(nn), correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, &
   &                     4))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL EXTRAPOLATE2NDHALO(nn, correctfork)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! deallocation all pointer
   !           call resetNormRfaceBwd(nn,norm,rface)
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL RESETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
   &                          rev1, rev2, 0)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO bocos
   pp1b = 0.0_8
   pp2b = 0.0_8
   rlv1b = 0.0_8
   rlv2b = 0.0_8
   ww1b = 0.0_8
   ww2b = 0.0_8
   DO nn=nbocos,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL RESETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2&
   &                         , pp2b, rlv1, rlv1b, rlv2, rlv2b, rev1, rev2, &
   &                         0)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4&
   &                    ))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL EXTRAPOLATE2NDHALO_B(nn, correctfork)
   END IF
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL COMPUTEETOT_B(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                  kcbeg(nn), kcend(nn), correctfork)
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO k=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO j=ad_to1,ad_from1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2b(j, k) = rlv2b(j, k) + rlv1b(j, k)
   rlv1b(j, k) = 0.0_8
   END IF
   DO l=nt2mg,nt1mg,-1
   ww2b(j, k, l) = ww2b(j, k, l) + ww1b(j, k, l)
   ww1b(j, k, l) = 0.0_8
   END DO
   ww2b(j, k, ivz) = ww2b(j, k, ivz) + ww1b(j, k, ivz)
   vnb = bcdata(nn)%norm(j, k, 3)*ww1b(j, k, ivz)
   ww1b(j, k, ivz) = 0.0_8
   ww2b(j, k, ivy) = ww2b(j, k, ivy) + ww1b(j, k, ivy)
   vnb = vnb + bcdata(nn)%norm(j, k, 2)*ww1b(j, k, ivy)
   ww1b(j, k, ivy) = 0.0_8
   ww2b(j, k, ivx) = ww2b(j, k, ivx) + ww1b(j, k, ivx)
   vnb = vnb + bcdata(nn)%norm(j, k, 1)*ww1b(j, k, ivx)
   ww1b(j, k, ivx) = 0.0_8
   ww2b(j, k, irho) = ww2b(j, k, irho) + ww1b(j, k, irho)
   ww1b(j, k, irho) = 0.0_8
   tempb = two*vnb
   ww2b(j, k, ivx) = ww2b(j, k, ivx) - bcdata(nn)%norm(j, k, 1)*&
   &           tempb
   ww2b(j, k, ivy) = ww2b(j, k, ivy) - bcdata(nn)%norm(j, k, 2)*&
   &           tempb
   ww2b(j, k, ivz) = ww2b(j, k, ivz) - bcdata(nn)%norm(j, k, 3)*&
   &           tempb
   CALL POPREAL8(pp1(j, k))
   tmpb = pp1b(j, k)
   pp1b(j, k) = 0.0_8
   CALL DIM_B(pp2(j, k), pp2b(j, k), pp1(j, k), pp1b(j, k), tmpb)
   END DO
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO k=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO j=ad_to,ad_from,-1
   pp1b(j, k) = 0.0_8
   END DO
   END DO
   END IF
   CALL POPREAL8ARRAY(pp2, imaxdim*jmaxdim)
   CALL SETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2, &
   &                       pp2b, rlv1, rlv1b, rlv2, rlv2b, rev1, rev2, 0)
   END IF
   END DO
   END SUBROUTINE BCEULERWALL_B

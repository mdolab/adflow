   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcnswallisothermal in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *bvtj1 *bvtj2 *p *gamma
   !                *w *rlv *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2 tref
   !                rgas
   !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *p *gamma
   !                *w *rlv *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2 tref
   !                rgas
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in p:in
   !                gamma:in w:in rlv:in bvtk1:in bvtk2:in d2wall:in
   !                bvti1:in bvti2:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcNSWallIsothermal.f90                          *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-10-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCNSWALLISOTHERMAL_B(secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcNSWallAdiabatic applies the viscous isothermal wall          *
   !      * boundary condition to a block. It is assumed that the pointers *
   !      * in blockPointers are already set to the correct block on the   *
   !      * correct grid level.                                            *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j
   REAL(kind=realtype) :: rhok, t2, t1
   REAL(kind=realtype) :: rhokd, t2d, t1d
   INTRINSIC MAX
   INTRINSIC MIN
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   REAL(kind=realtype) :: tmp3
   REAL(kind=realtype) :: tmp4
   REAL(kind=realtype) :: tmp5
   REAL(kind=realtype) :: tmp6
   REAL(kind=realtype) :: tmp7
   REAL(kind=realtype) :: tmp8
   REAL(kind=realtype) :: tmp9
   REAL(kind=realtype) :: tmp10
   REAL(kind=realtype) :: tmp11
   REAL(kind=realtype) :: tmp12
   REAL(kind=realtype) :: tmp13
   REAL(kind=realtype) :: tmp14
   REAL(kind=realtype) :: tmp15
   REAL(kind=realtype) :: tmp16
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: ad_from5
   INTEGER :: ad_to5
   INTEGER :: ad_from6
   INTEGER :: ad_to6
   INTEGER :: ad_from7
   INTEGER :: ad_to7
   INTEGER :: ad_from8
   INTEGER :: ad_to8
   INTEGER :: ad_from9
   INTEGER :: ad_to9
   INTEGER :: ad_from10
   INTEGER :: ad_to10
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: tempd14
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: tempd13
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: tempd12
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd11
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tmpd16
   REAL(kind=realtype) :: tmpd15
   REAL(kind=realtype) :: tmpd14
   REAL(kind=realtype) :: tmpd13
   REAL(kind=realtype) :: tmpd12
   REAL(kind=realtype) :: tmpd11
   REAL(kind=realtype) :: tmpd10
   REAL(kind=realtype) :: temp10
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tmpd9
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tmpd8
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tmpd7
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tmpd6
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tmpd5
   REAL(kind=realtype) :: tmpd4
   REAL(kind=realtype) :: tmpd3
   REAL(kind=realtype) :: tmpd2
   REAL(kind=realtype) :: tmpd1
   REAL(kind=realtype) :: tmpd0
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: tempd16
   REAL(kind=realtype) :: temp4
   REAL(kind=realtype) :: tempd15
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   ! We turn off the turbulence BCwall for now. This needs
   ! to be added and correct the pointers to use full turbulence.
   ! It should be okay for frozen turbulence assumption.
   IF (turbcoupled) THEN
   CALL PUSHREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2&
   &                 , 3)*SIZE(bmtj2, 4))
   CALL PUSHREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1&
   &                 , 3)*SIZE(bmtj1, 4))
   CALL PUSHREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2&
   &                 , 3)*SIZE(bmti2, 4))
   CALL PUSHREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1&
   &                 , 3)*SIZE(bmti1, 4))
   CALL PUSHREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2&
   &                 , 3)*SIZE(bmtk2, 4))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1&
   &                 , 3)*SIZE(bmtk1, 4))
   CALL PUSHREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1&
   &                 , 3))
   CALL TURBBCNSWALL(.false.)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   ! Loop over the viscous subfaces of this block. Note that
   ! these are numbered first.
   bocos:DO nn=1,nviscbocos
   ! Check for isothermal viscous wall boundary conditions.
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   ad_from0 = bcdata(nn)%jcbeg
   DO j=ad_from0,bcdata(nn)%jcend
   ad_from = bcdata(nn)%icbeg
   DO i=ad_from,bcdata(nn)%icend
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) THEN
   rhok = w(1, i, j, irho)*w(2, i, j, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2 = p(2, i, j)/(rgas*w(2, i, j, irho))
   CALL PUSHREAL8(t1)
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   CALL PUSHREAL8(p(1, i, j))
   p(1, i, j) = p(2, i, j) - four*third*rhok
   CALL PUSHREAL8(w(1, i, j, irho))
   w(1, i, j, irho) = p(1, i, j)/(rgas*t1)
   CALL PUSHREAL8(w(1, i, j, ivx))
   w(1, i, j, ivx) = -w(2, i, j, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   CALL PUSHREAL8(w(1, i, j, ivy))
   w(1, i, j, ivy) = -w(2, i, j, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   CALL PUSHREAL8(w(1, i, j, ivz))
   w(1, i, j, ivz) = -w(2, i, j, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   CALL PUSHREAL8(rlv(1, i, j))
   rlv(1, i, j) = rlv(2, i, j)
   IF (eddymodel) THEN
   rev(1, i, j) = -rev(2, i, j)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL3B(1)
   CASE (imax) 
   ad_from2 = bcdata(nn)%jcbeg
   DO j=ad_from2,bcdata(nn)%jcend
   ad_from1 = bcdata(nn)%icbeg
   DO i=ad_from1,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(il, i, j, irho)*w(il, i, j, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   t2 = p(il, i, j)/(rgas*w(il, i, j, irho))
   CALL PUSHREAL8(t1)
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   tmp = p(il, i, j) - four*third*rhok
   CALL PUSHREAL8(p(ie, i, j))
   p(ie, i, j) = tmp
   CALL PUSHREAL8(w(ie, i, j, irho))
   w(ie, i, j, irho) = p(ie, i, j)/(rgas*t1)
   tmp0 = -w(il, i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   CALL PUSHREAL8(w(ie, i, j, ivx))
   w(ie, i, j, ivx) = tmp0
   tmp1 = -w(il, i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   CALL PUSHREAL8(w(ie, i, j, ivy))
   w(ie, i, j, ivy) = tmp1
   tmp2 = -w(il, i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   CALL PUSHREAL8(w(ie, i, j, ivz))
   w(ie, i, j, ivz) = tmp2
   tmp3 = rlv(il, i, j)
   CALL PUSHREAL8(rlv(ie, i, j))
   rlv(ie, i, j) = tmp3
   IF (eddymodel) THEN
   tmp4 = -rev(il, i, j)
   rev(ie, i, j) = tmp4
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from2)
   CALL PUSHCONTROL3B(2)
   CASE (jmin) 
   ad_from4 = bcdata(nn)%jcbeg
   DO j=ad_from4,bcdata(nn)%jcend
   ad_from3 = bcdata(nn)%icbeg
   DO i=ad_from3,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, 2, j, irho)*w(i, 2, j, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   t2 = p(i, 2, j)/(rgas*w(i, 2, j, irho))
   CALL PUSHREAL8(t1)
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(p(i, 1, j))
   p(i, 1, j) = p(i, 2, j) - four*third*rhok
   CALL PUSHREAL8(w(i, 1, j, irho))
   w(i, 1, j, irho) = p(i, 1, j)/(rgas*t1)
   CALL PUSHREAL8(w(i, 1, j, ivx))
   w(i, 1, j, ivx) = -w(i, 2, j, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   CALL PUSHREAL8(w(i, 1, j, ivy))
   w(i, 1, j, ivy) = -w(i, 2, j, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   CALL PUSHREAL8(w(i, 1, j, ivz))
   w(i, 1, j, ivz) = -w(i, 2, j, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   CALL PUSHREAL8(rlv(i, 1, j))
   rlv(i, 1, j) = rlv(i, 2, j)
   IF (eddymodel) THEN
   rev(i, 1, j) = -rev(i, 2, j)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   ad_from6 = bcdata(nn)%jcbeg
   DO j=ad_from6,bcdata(nn)%jcend
   ad_from5 = bcdata(nn)%icbeg
   DO i=ad_from5,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, jl, j, irho)*w(i, jl, j, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   t2 = p(i, jl, j)/(rgas*w(i, jl, j, irho))
   CALL PUSHREAL8(t1)
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   tmp5 = p(i, jl, j) - four*third*rhok
   CALL PUSHREAL8(p(i, je, j))
   p(i, je, j) = tmp5
   CALL PUSHREAL8(w(i, je, j, irho))
   w(i, je, j, irho) = p(i, je, j)/(rgas*t1)
   tmp6 = -w(i, jl, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   CALL PUSHREAL8(w(i, je, j, ivx))
   w(i, je, j, ivx) = tmp6
   tmp7 = -w(i, jl, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   CALL PUSHREAL8(w(i, je, j, ivy))
   w(i, je, j, ivy) = tmp7
   tmp8 = -w(i, jl, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   CALL PUSHREAL8(w(i, je, j, ivz))
   w(i, je, j, ivz) = tmp8
   tmp9 = rlv(i, jl, j)
   CALL PUSHREAL8(rlv(i, je, j))
   rlv(i, je, j) = tmp9
   IF (eddymodel) THEN
   tmp10 = -rev(i, jl, j)
   rev(i, je, j) = tmp10
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from5)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from6)
   CALL PUSHCONTROL3B(4)
   CASE (kmin) 
   ad_from8 = bcdata(nn)%jcbeg
   DO j=ad_from8,bcdata(nn)%jcend
   ad_from7 = bcdata(nn)%icbeg
   DO i=ad_from7,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, j, 2, irho)*w(i, j, 2, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   t2 = p(i, j, 2)/(rgas*w(i, j, 2, irho))
   CALL PUSHREAL8(t1)
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(p(i, j, 1))
   p(i, j, 1) = p(i, j, 2) - four*third*rhok
   CALL PUSHREAL8(w(i, j, 1, irho))
   w(i, j, 1, irho) = p(i, j, 1)/(rgas*t1)
   CALL PUSHREAL8(w(i, j, 1, ivx))
   w(i, j, 1, ivx) = -w(i, j, 2, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   CALL PUSHREAL8(w(i, j, 1, ivy))
   w(i, j, 1, ivy) = -w(i, j, 2, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   CALL PUSHREAL8(w(i, j, 1, ivz))
   w(i, j, 1, ivz) = -w(i, j, 2, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   CALL PUSHREAL8(rlv(i, j, 1))
   rlv(i, j, 1) = rlv(i, j, 2)
   IF (eddymodel) THEN
   rev(i, j, 1) = -rev(i, j, 2)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from7)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from8)
   CALL PUSHCONTROL3B(5)
   CASE (kmax) 
   ad_from10 = bcdata(nn)%jcbeg
   DO j=ad_from10,bcdata(nn)%jcend
   ad_from9 = bcdata(nn)%icbeg
   DO i=ad_from9,bcdata(nn)%icend
   IF (correctfork) THEN
   rhok = w(i, j, kl, irho)*w(i, j, kl, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   t2 = p(i, j, kl)/(rgas*w(i, j, kl, irho))
   CALL PUSHREAL8(t1)
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   tmp11 = p(i, j, kl) - four*third*rhok
   CALL PUSHREAL8(p(i, j, ke))
   p(i, j, ke) = tmp11
   CALL PUSHREAL8(w(i, j, ke, irho))
   w(i, j, ke, irho) = p(i, j, ke)/(rgas*t1)
   tmp12 = -w(i, j, kl, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   CALL PUSHREAL8(w(i, j, ke, ivx))
   w(i, j, ke, ivx) = tmp12
   tmp13 = -w(i, j, kl, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   CALL PUSHREAL8(w(i, j, ke, ivy))
   w(i, j, ke, ivy) = tmp13
   tmp14 = -w(i, j, kl, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   CALL PUSHREAL8(w(i, j, ke, ivz))
   w(i, j, ke, ivz) = tmp14
   tmp15 = rlv(i, j, kl)
   CALL PUSHREAL8(rlv(i, j, ke))
   rlv(i, j, ke) = tmp15
   IF (eddymodel) THEN
   tmp16 = -rev(i, j, kl)
   rev(i, j, ke) = tmp16
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from9)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from10)
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4)&
   &                  )
   CALL COMPUTEETOT(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                   kcbeg(nn), kcend(nn), correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) THEN
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, &
   &                     4))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL EXTRAPOLATE2NDHALO(nn, correctfork)
   CALL PUSHCONTROL2B(2)
   ELSE
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(0)
   END IF
   END DO bocos
   DO nn=nviscbocos,1,-1
   CALL POPCONTROL2B(branch)
   IF (branch .NE. 0) THEN
   IF (branch .NE. 1) THEN
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4&
   &                    ))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL EXTRAPOLATE2NDHALO_B(nn, correctfork)
   END IF
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL COMPUTEETOT_B(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                  kcbeg(nn), kcend(nn), correctfork)
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .NE. 0) THEN
   IF (branch .EQ. 1) THEN
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   revd(2, i, j) = revd(2, i, j) - revd(1, i, j)
   revd(1, i, j) = 0.0_8
   END IF
   CALL POPREAL8(rlv(1, i, j))
   rlvd(2, i, j) = rlvd(2, i, j) + rlvd(1, i, j)
   rlvd(1, i, j) = 0.0_8
   CALL POPREAL8(w(1, i, j, ivz))
   wd(2, i, j, ivz) = wd(2, i, j, ivz) - wd(1, i, j, ivz)
   wd(1, i, j, ivz) = 0.0_8
   CALL POPREAL8(w(1, i, j, ivy))
   wd(2, i, j, ivy) = wd(2, i, j, ivy) - wd(1, i, j, ivy)
   wd(1, i, j, ivy) = 0.0_8
   CALL POPREAL8(w(1, i, j, ivx))
   wd(2, i, j, ivx) = wd(2, i, j, ivx) - wd(1, i, j, ivx)
   wd(1, i, j, ivx) = 0.0_8
   CALL POPREAL8(w(1, i, j, irho))
   tempd0 = wd(1, i, j, irho)/(rgas*t1)
   tempd1 = -(p(1, i, j)*tempd0/(rgas*t1))
   pd(1, i, j) = pd(1, i, j) + tempd0
   rgasd = rgasd + t1*tempd1
   t1d = rgas*tempd1
   wd(1, i, j, irho) = 0.0_8
   CALL POPREAL8(p(1, i, j))
   pd(2, i, j) = pd(2, i, j) + pd(1, i, j)
   rhokd = rhokd - four*third*pd(1, i, j)
   pd(1, i, j) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPREAL8(t1)
   t2d = -t1d
   temp0 = w(2, i, j, irho)
   temp = rgas*temp0
   tempd = -(p(2, i, j)*t2d/temp**2)
   pd(2, i, j) = pd(2, i, j) + t2d/temp
   rgasd = rgasd + temp0*tempd
   wd(2, i, j, irho) = wd(2, i, j, irho) + rgas*tempd
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   wd(1, i, j, irho) = wd(1, i, j, irho) + w(2, i, j, &
   &                   itu1)*rhokd
   wd(2, i, j, itu1) = wd(2, i, j, itu1) + w(1, i, j, &
   &                   irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO j=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd4 = revd(ie, i, j)
   revd(ie, i, j) = 0.0_8
   revd(il, i, j) = revd(il, i, j) - tmpd4
   END IF
   CALL POPREAL8(rlv(ie, i, j))
   tmpd = rlvd(ie, i, j)
   rlvd(ie, i, j) = 0.0_8
   rlvd(il, i, j) = rlvd(il, i, j) + tmpd
   CALL POPREAL8(w(ie, i, j, ivz))
   tmpd0 = wd(ie, i, j, ivz)
   wd(ie, i, j, ivz) = 0.0_8
   wd(il, i, j, ivz) = wd(il, i, j, ivz) - tmpd0
   CALL POPREAL8(w(ie, i, j, ivy))
   tmpd1 = wd(ie, i, j, ivy)
   wd(ie, i, j, ivy) = 0.0_8
   wd(il, i, j, ivy) = wd(il, i, j, ivy) - tmpd1
   CALL POPREAL8(w(ie, i, j, ivx))
   tmpd2 = wd(ie, i, j, ivx)
   wd(ie, i, j, ivx) = 0.0_8
   wd(il, i, j, ivx) = wd(il, i, j, ivx) - tmpd2
   CALL POPREAL8(w(ie, i, j, irho))
   tempd3 = wd(ie, i, j, irho)/(rgas*t1)
   tempd4 = -(p(ie, i, j)*tempd3/(rgas*t1))
   pd(ie, i, j) = pd(ie, i, j) + tempd3
   rgasd = rgasd + t1*tempd4
   t1d = rgas*tempd4
   wd(ie, i, j, irho) = 0.0_8
   CALL POPREAL8(p(ie, i, j))
   tmpd3 = pd(ie, i, j)
   pd(ie, i, j) = 0.0_8
   pd(il, i, j) = pd(il, i, j) + tmpd3
   rhokd = rhokd - four*third*tmpd3
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPREAL8(t1)
   t2d = -t1d
   temp2 = w(il, i, j, irho)
   temp1 = rgas*temp2
   tempd2 = -(p(il, i, j)*t2d/temp1**2)
   pd(il, i, j) = pd(il, i, j) + t2d/temp1
   rgasd = rgasd + temp2*tempd2
   wd(il, i, j, irho) = wd(il, i, j, irho) + rgas*tempd2
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   wd(il, i, j, irho) = wd(il, i, j, irho) + w(il, i, j, &
   &                   itu1)*rhokd
   wd(il, i, j, itu1) = wd(il, i, j, itu1) + w(il, i, j, &
   &                   irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   END IF
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO i=ad_to3,ad_from3,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   revd(i, 2, j) = revd(i, 2, j) - revd(i, 1, j)
   revd(i, 1, j) = 0.0_8
   END IF
   CALL POPREAL8(rlv(i, 1, j))
   rlvd(i, 2, j) = rlvd(i, 2, j) + rlvd(i, 1, j)
   rlvd(i, 1, j) = 0.0_8
   CALL POPREAL8(w(i, 1, j, ivz))
   wd(i, 2, j, ivz) = wd(i, 2, j, ivz) - wd(i, 1, j, ivz)
   wd(i, 1, j, ivz) = 0.0_8
   CALL POPREAL8(w(i, 1, j, ivy))
   wd(i, 2, j, ivy) = wd(i, 2, j, ivy) - wd(i, 1, j, ivy)
   wd(i, 1, j, ivy) = 0.0_8
   CALL POPREAL8(w(i, 1, j, ivx))
   wd(i, 2, j, ivx) = wd(i, 2, j, ivx) - wd(i, 1, j, ivx)
   wd(i, 1, j, ivx) = 0.0_8
   CALL POPREAL8(w(i, 1, j, irho))
   tempd6 = wd(i, 1, j, irho)/(rgas*t1)
   tempd7 = -(p(i, 1, j)*tempd6/(rgas*t1))
   pd(i, 1, j) = pd(i, 1, j) + tempd6
   rgasd = rgasd + t1*tempd7
   t1d = rgas*tempd7
   wd(i, 1, j, irho) = 0.0_8
   CALL POPREAL8(p(i, 1, j))
   pd(i, 2, j) = pd(i, 2, j) + pd(i, 1, j)
   rhokd = rhokd - four*third*pd(i, 1, j)
   pd(i, 1, j) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPREAL8(t1)
   t2d = -t1d
   temp4 = w(i, 2, j, irho)
   temp3 = rgas*temp4
   tempd5 = -(p(i, 2, j)*t2d/temp3**2)
   pd(i, 2, j) = pd(i, 2, j) + t2d/temp3
   rgasd = rgasd + temp4*tempd5
   wd(i, 2, j, irho) = wd(i, 2, j, irho) + rgas*tempd5
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   wd(i, 2, j, irho) = wd(i, 2, j, irho) + w(i, 2, j, itu1)&
   &                 *rhokd
   wd(i, 2, j, itu1) = wd(i, 2, j, itu1) + w(i, 2, j, irho)&
   &                 *rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO j=ad_to6,ad_from6,-1
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO i=ad_to5,ad_from5,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd10 = revd(i, je, j)
   revd(i, je, j) = 0.0_8
   revd(i, jl, j) = revd(i, jl, j) - tmpd10
   END IF
   CALL POPREAL8(rlv(i, je, j))
   tmpd5 = rlvd(i, je, j)
   rlvd(i, je, j) = 0.0_8
   rlvd(i, jl, j) = rlvd(i, jl, j) + tmpd5
   CALL POPREAL8(w(i, je, j, ivz))
   tmpd6 = wd(i, je, j, ivz)
   wd(i, je, j, ivz) = 0.0_8
   wd(i, jl, j, ivz) = wd(i, jl, j, ivz) - tmpd6
   CALL POPREAL8(w(i, je, j, ivy))
   tmpd7 = wd(i, je, j, ivy)
   wd(i, je, j, ivy) = 0.0_8
   wd(i, jl, j, ivy) = wd(i, jl, j, ivy) - tmpd7
   CALL POPREAL8(w(i, je, j, ivx))
   tmpd8 = wd(i, je, j, ivx)
   wd(i, je, j, ivx) = 0.0_8
   wd(i, jl, j, ivx) = wd(i, jl, j, ivx) - tmpd8
   CALL POPREAL8(w(i, je, j, irho))
   tempd9 = wd(i, je, j, irho)/(rgas*t1)
   tempd10 = -(p(i, je, j)*tempd9/(rgas*t1))
   pd(i, je, j) = pd(i, je, j) + tempd9
   rgasd = rgasd + t1*tempd10
   t1d = rgas*tempd10
   wd(i, je, j, irho) = 0.0_8
   CALL POPREAL8(p(i, je, j))
   tmpd9 = pd(i, je, j)
   pd(i, je, j) = 0.0_8
   pd(i, jl, j) = pd(i, jl, j) + tmpd9
   rhokd = rhokd - four*third*tmpd9
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPREAL8(t1)
   t2d = -t1d
   temp6 = w(i, jl, j, irho)
   temp5 = rgas*temp6
   tempd8 = -(p(i, jl, j)*t2d/temp5**2)
   pd(i, jl, j) = pd(i, jl, j) + t2d/temp5
   rgasd = rgasd + temp6*tempd8
   wd(i, jl, j, irho) = wd(i, jl, j, irho) + rgas*tempd8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   wd(i, jl, j, irho) = wd(i, jl, j, irho) + w(i, jl, j, &
   &                 itu1)*rhokd
   wd(i, jl, j, itu1) = wd(i, jl, j, itu1) + w(i, jl, j, &
   &                 irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   END IF
   ELSE IF (branch .EQ. 5) THEN
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from8)
   CALL POPINTEGER4(ad_to8)
   DO j=ad_to8,ad_from8,-1
   CALL POPINTEGER4(ad_from7)
   CALL POPINTEGER4(ad_to7)
   DO i=ad_to7,ad_from7,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   revd(i, j, 2) = revd(i, j, 2) - revd(i, j, 1)
   revd(i, j, 1) = 0.0_8
   END IF
   CALL POPREAL8(rlv(i, j, 1))
   rlvd(i, j, 2) = rlvd(i, j, 2) + rlvd(i, j, 1)
   rlvd(i, j, 1) = 0.0_8
   CALL POPREAL8(w(i, j, 1, ivz))
   wd(i, j, 2, ivz) = wd(i, j, 2, ivz) - wd(i, j, 1, ivz)
   wd(i, j, 1, ivz) = 0.0_8
   CALL POPREAL8(w(i, j, 1, ivy))
   wd(i, j, 2, ivy) = wd(i, j, 2, ivy) - wd(i, j, 1, ivy)
   wd(i, j, 1, ivy) = 0.0_8
   CALL POPREAL8(w(i, j, 1, ivx))
   wd(i, j, 2, ivx) = wd(i, j, 2, ivx) - wd(i, j, 1, ivx)
   wd(i, j, 1, ivx) = 0.0_8
   CALL POPREAL8(w(i, j, 1, irho))
   tempd12 = wd(i, j, 1, irho)/(rgas*t1)
   tempd13 = -(p(i, j, 1)*tempd12/(rgas*t1))
   pd(i, j, 1) = pd(i, j, 1) + tempd12
   rgasd = rgasd + t1*tempd13
   t1d = rgas*tempd13
   wd(i, j, 1, irho) = 0.0_8
   CALL POPREAL8(p(i, j, 1))
   pd(i, j, 2) = pd(i, j, 2) + pd(i, j, 1)
   rhokd = rhokd - four*third*pd(i, j, 1)
   pd(i, j, 1) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPREAL8(t1)
   t2d = -t1d
   temp8 = w(i, j, 2, irho)
   temp7 = rgas*temp8
   tempd11 = -(p(i, j, 2)*t2d/temp7**2)
   pd(i, j, 2) = pd(i, j, 2) + t2d/temp7
   rgasd = rgasd + temp8*tempd11
   wd(i, j, 2, irho) = wd(i, j, 2, irho) + rgas*tempd11
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   wd(i, j, 2, irho) = wd(i, j, 2, irho) + w(i, j, 2, itu1)*&
   &               rhokd
   wd(i, j, 2, itu1) = wd(i, j, 2, itu1) + w(i, j, 2, irho)*&
   &               rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   rhokd = 0.0_8
   CALL POPINTEGER4(ad_from10)
   CALL POPINTEGER4(ad_to10)
   DO j=ad_to10,ad_from10,-1
   CALL POPINTEGER4(ad_from9)
   CALL POPINTEGER4(ad_to9)
   DO i=ad_to9,ad_from9,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd16 = revd(i, j, ke)
   revd(i, j, ke) = 0.0_8
   revd(i, j, kl) = revd(i, j, kl) - tmpd16
   END IF
   CALL POPREAL8(rlv(i, j, ke))
   tmpd11 = rlvd(i, j, ke)
   rlvd(i, j, ke) = 0.0_8
   rlvd(i, j, kl) = rlvd(i, j, kl) + tmpd11
   CALL POPREAL8(w(i, j, ke, ivz))
   tmpd12 = wd(i, j, ke, ivz)
   wd(i, j, ke, ivz) = 0.0_8
   wd(i, j, kl, ivz) = wd(i, j, kl, ivz) - tmpd12
   CALL POPREAL8(w(i, j, ke, ivy))
   tmpd13 = wd(i, j, ke, ivy)
   wd(i, j, ke, ivy) = 0.0_8
   wd(i, j, kl, ivy) = wd(i, j, kl, ivy) - tmpd13
   CALL POPREAL8(w(i, j, ke, ivx))
   tmpd14 = wd(i, j, ke, ivx)
   wd(i, j, ke, ivx) = 0.0_8
   wd(i, j, kl, ivx) = wd(i, j, kl, ivx) - tmpd14
   CALL POPREAL8(w(i, j, ke, irho))
   tempd15 = wd(i, j, ke, irho)/(rgas*t1)
   tempd16 = -(p(i, j, ke)*tempd15/(rgas*t1))
   pd(i, j, ke) = pd(i, j, ke) + tempd15
   rgasd = rgasd + t1*tempd16
   t1d = rgas*tempd16
   wd(i, j, ke, irho) = 0.0_8
   CALL POPREAL8(p(i, j, ke))
   tmpd15 = pd(i, j, ke)
   pd(i, j, ke) = 0.0_8
   pd(i, j, kl) = pd(i, j, kl) + tmpd15
   rhokd = rhokd - four*third*tmpd15
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPREAL8(t1)
   t2d = -t1d
   temp10 = w(i, j, kl, irho)
   temp9 = rgas*temp10
   tempd14 = -(p(i, j, kl)*t2d/temp9**2)
   pd(i, j, kl) = pd(i, j, kl) + t2d/temp9
   rgasd = rgasd + temp10*tempd14
   wd(i, j, kl, irho) = wd(i, j, kl, irho) + rgas*tempd14
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   wd(i, j, kl, irho) = wd(i, j, kl, irho) + w(i, j, kl, itu1&
   &               )*rhokd
   wd(i, j, kl, itu1) = wd(i, j, kl, itu1) + w(i, j, kl, irho&
   &               )*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END DO
   END IF
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1, &
   &                3))
   CALL POPREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2, &
   &                3))
   CALL POPREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1, &
   &                3)*SIZE(bmtk1, 4))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2, &
   &                3)*SIZE(bmtk2, 4))
   CALL POPREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1, &
   &                3))
   CALL POPREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2, &
   &                3))
   CALL POPREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1, &
   &                3)*SIZE(bmti1, 4))
   CALL POPREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2, &
   &                3)*SIZE(bmti2, 4))
   CALL POPREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1, &
   &                3))
   CALL POPREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2, &
   &                3))
   CALL POPREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1, &
   &                3)*SIZE(bmtj1, 4))
   CALL POPREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2, &
   &                3)*SIZE(bmtj2, 4))
   CALL TURBBCNSWALL_B(.false.)
   END IF
   END SUBROUTINE BCNSWALLISOTHERMAL_B

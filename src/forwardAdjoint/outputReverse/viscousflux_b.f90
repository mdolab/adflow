   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
   !
   !  Differentiation of viscousflux in reverse (adjoint) mode:
   !   gradient     of useful results: *w *x *fw
   !   with respect to varying inputs: *rev *p *w *rlv *x *vol *si
   !                *sj *sk *fw *(*bcdata.norm) prandtlturb prandtl
   !   Plus diff mem management of: rev:in p:in w:in rlv:in x:in vol:in
   !                d2wall:in si:in sj:in sk:in fw:in viscsubface:in
   !                *viscsubface.tau:in *viscsubface.utau:in bcdata:in
   !                *bcdata.norm:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          viscousFlux.f90                                 *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-21-2003                                      *
   !      * Last modified: 04-18-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE VISCOUSFLUX_B()
   USE BLOCKPOINTERS_B
   USE INPUTPHYSICS
   USE ITERATION
   USE FLOWVARREFSTATE
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * viscousFlux computes the viscous fluxes using a central        *
   !      * difference scheme for a block.                                 *
   !      * It is assumed that the pointers in block pointer already point *
   !      * to the correct block.                                          *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: twothird=two*third
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, nn
   INTEGER(kind=inttype) :: k1, k2, kk
   REAL(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
   REAL(kind=realtype) :: mulb, mueb, mutb, heatcoefb
   REAL(kind=realtype) :: gm1, factlamheat, factturbheat
   REAL(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
   REAL(kind=realtype) :: u_xb, u_yb, u_zb, v_xb, v_yb, v_zb, w_xb, w_yb&
   &  , w_zb
   REAL(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
   REAL(kind=realtype) :: q_xb, q_yb, q_zb, ubarb, vbarb, wbarb
   REAL(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
   REAL(kind=realtype) :: corrb, ssxb, ssyb, sszb, ssb, fracdivb
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxb, tauyyb, tauzzb
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyb, tauxzb, tauyzb
   REAL(kind=realtype) :: fmx, fmy, fmz, frhoe
   REAL(kind=realtype) :: fmxb, fmyb, fmzb, frhoeb
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: ux, uy, uz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: uxb, uyb, uzb
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: vx, vy, vz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: vxb, vyb, vzb
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: wx, wy, wz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: wxb, wyb, wzb
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: qx, qy, qz
   REAL(kind=realtype), DIMENSION(il, jl, 2) :: qxb, qyb, qzb
   LOGICAL :: correctfork, storewalltensor
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: temp4b9
   REAL(kind=realtype) :: temp6b18
   REAL(kind=realtype) :: temp4b8
   REAL(kind=realtype) :: temp6b17
   REAL(kind=realtype) :: temp4b7
   REAL(kind=realtype) :: temp6b16
   REAL(kind=realtype) :: temp4b6
   REAL(kind=realtype) :: temp6b15
   REAL(kind=realtype) :: temp4b5
   REAL(kind=realtype) :: temp6b14
   REAL(kind=realtype) :: temp4b4
   REAL(kind=realtype) :: temp6b13
   REAL(kind=realtype) :: temp4b3
   REAL(kind=realtype) :: temp6b12
   REAL(kind=realtype) :: temp4b2
   REAL(kind=realtype) :: temp6b11
   REAL(kind=realtype) :: temp4b1
   REAL(kind=realtype) :: temp6b10
   REAL(kind=realtype) :: temp4b0
   REAL(kind=realtype) :: temp0b
   REAL(kind=realtype) :: temp2b9
   REAL(kind=realtype) :: temp2b8
   REAL(kind=realtype) :: temp2b7
   INTRINSIC ABS
   REAL(kind=realtype) :: temp2b6
   REAL(kind=realtype) :: temp2b5
   REAL(kind=realtype) :: temp2b4
   REAL(kind=realtype) :: temp2b3
   REAL(kind=realtype) :: temp2b2
   REAL(kind=realtype) :: temp2b1
   REAL(kind=realtype) :: temp2b0
   REAL(kind=realtype) :: temp6b
   REAL(kind=realtype) :: temp0b9
   REAL(kind=realtype) :: temp0b8
   REAL(kind=realtype) :: temp0b7
   REAL(kind=realtype) :: temp0b6
   REAL(kind=realtype) :: temp0b5
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: temp0b4
   REAL(kind=realtype) :: temp0b3
   REAL(kind=realtype) :: temp0b14
   REAL(kind=realtype) :: temp0b2
   REAL(kind=realtype) :: temp0b13
   REAL(kind=realtype) :: temp0b1
   REAL(kind=realtype) :: temp0b12
   REAL(kind=realtype) :: temp0b0
   REAL(kind=realtype) :: temp0b11
   REAL(kind=realtype) :: temp0b10
   REAL(kind=realtype) :: temp2b
   REAL(kind=realtype) :: temp8b2
   REAL(kind=realtype) :: temp2b18
   REAL(kind=realtype) :: temp8b1
   REAL(kind=realtype) :: temp2b17
   REAL(kind=realtype) :: temp8b0
   REAL(kind=realtype) :: temp2b16
   REAL(kind=realtype) :: temp2b15
   REAL(kind=realtype) :: temp2b14
   REAL(kind=realtype) :: temp2b13
   REAL(kind=realtype) :: temp8b
   REAL(kind=realtype) :: temp2b12
   REAL(kind=realtype) :: temp2b11
   REAL(kind=realtype) :: temp2b10
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: temp6b9
   REAL(kind=realtype) :: temp6b8
   REAL(kind=realtype) :: temp6b7
   REAL(kind=realtype) :: temp6b6
   REAL(kind=realtype) :: temp4b18
   REAL(kind=realtype) :: temp6b5
   REAL(kind=realtype) :: temp4b17
   REAL(kind=realtype) :: temp6b4
   REAL(kind=realtype) :: temp4b16
   REAL(kind=realtype) :: temp6b3
   REAL(kind=realtype) :: temp6b2
   REAL(kind=realtype) :: temp4b15
   REAL(kind=realtype) :: temp6b1
   REAL(kind=realtype) :: temp4b14
   INTEGER :: ii1
   INTRINSIC SQRT
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: temp6b0
   REAL(kind=realtype) :: temp4b13
   REAL(kind=realtype) :: temp4b12
   REAL(kind=realtype) :: temp4b11
   REAL(kind=realtype) :: temp4b10
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: temp4b
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   ! 
   ! Set rFilv to rFil to indicate that this is the viscous part.
   ! If rFilv == 0 the viscous residuals need not to be computed
   ! and a return can be made.
   rfilv = rfil
   IF (rfilv .GE. 0.) THEN
   abs0 = rfilv
   ELSE
   abs0 = -rfilv
   END IF
   IF (abs0 .LT. thresholdreal) THEN
   revb = 0.0_8
   pb = 0.0_8
   rlvb = 0.0_8
   volb = 0.0_8
   sib = 0.0_8
   sjb = 0.0_8
   skb = 0.0_8
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatab(ii1)%norm = 0.0_8
   END DO
   ELSE
   ! Determine whether or not the pressure must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   ! Determine whether or not the wall stress tensor and wall heat
   ! flux must be stored for viscous walls.
   storewalltensor = .false.
   IF (wallfunctions) THEN
   storewalltensor = .true.
   ELSE IF (rkstage .EQ. 0 .AND. currentlevel .EQ. groundlevel) THEN
   storewalltensor = .true.
   END IF
   ! Store the speed of sound squared instead of the pressure.
   ! To be 100 percent correct, substract 2/3*rho*k (if present)
   ! from the pressure to obtain the true presssure. First layer of
   ! halo's, because that's what is needed by the viscous stencil.
   DO k=1,ke
   DO j=1,je
   DO i=1,ie
   IF (correctfork) THEN
   CALL PUSHREAL8(p(i, j, k))
   p(i, j, k) = p(i, j, k) - twothird*w(i, j, k, irho)*w(i, j, &
   &              k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(p(i, j, k))
   p(i, j, k) = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
   END DO
   END DO
   END DO
   ! Compute the nodal gradients for the nodes in the plane k = 1.
   k = 1
   k1 = 1
   k2 = 2
   CALL PUSHREAL8ARRAY(qz, il*jl*2)
   CALL PUSHREAL8ARRAY(qy, il*jl*2)
   CALL PUSHREAL8ARRAY(qx, il*jl*2)
   CALL PUSHREAL8ARRAY(wz, il*jl*2)
   CALL PUSHREAL8ARRAY(wy, il*jl*2)
   CALL PUSHREAL8ARRAY(wx, il*jl*2)
   CALL PUSHREAL8ARRAY(vz, il*jl*2)
   CALL PUSHREAL8ARRAY(vy, il*jl*2)
   CALL PUSHREAL8ARRAY(vx, il*jl*2)
   CALL PUSHREAL8ARRAY(uz, il*jl*2)
   CALL PUSHREAL8ARRAY(uy, il*jl*2)
   CALL PUSHREAL8ARRAY(ux, il*jl*2)
   CALL NODALGRADIENTS(ux, uy, uz, vx, vy, vz, wx, wy, wz, qx, qy, qz)
   ! Compute the viscous fluxes for the faces k == 1 and update
   ! the residuals for the cells k == 2.
   mue = zero
   DO j=2,jl
   DO i=2,il
   CALL PUSHREAL8(por)
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pork(i, j, 1) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   mul = por*(rlv(i, j, 1)+rlv(i, j, 2))
   IF (eddymodel) THEN
   mue = por*(rev(i, j, 1)+rev(i, j, 2))
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(mut)
   mut = mul + mue
   gm1 = half*(gamma(i, j, 1)+gamma(i, j, 2)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL PUSHREAL8(heatcoef)
   heatcoef = mul*factlamheat + mue*factturbheat
   CALL PUSHREAL8(u_x)
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_x = fourth*(ux(i-1, j-1, k1)+ux(i, j-1, k1)+ux(i-1, j, k1)+ux(&
   &          i, j, k1))
   CALL PUSHREAL8(u_y)
   u_y = fourth*(uy(i-1, j-1, k1)+uy(i, j-1, k1)+uy(i-1, j, k1)+uy(&
   &          i, j, k1))
   CALL PUSHREAL8(u_z)
   u_z = fourth*(uz(i-1, j-1, k1)+uz(i, j-1, k1)+uz(i-1, j, k1)+uz(&
   &          i, j, k1))
   CALL PUSHREAL8(v_x)
   v_x = fourth*(vx(i-1, j-1, k1)+vx(i, j-1, k1)+vx(i-1, j, k1)+vx(&
   &          i, j, k1))
   CALL PUSHREAL8(v_y)
   v_y = fourth*(vy(i-1, j-1, k1)+vy(i, j-1, k1)+vy(i-1, j, k1)+vy(&
   &          i, j, k1))
   CALL PUSHREAL8(v_z)
   v_z = fourth*(vz(i-1, j-1, k1)+vz(i, j-1, k1)+vz(i-1, j, k1)+vz(&
   &          i, j, k1))
   CALL PUSHREAL8(w_x)
   w_x = fourth*(wx(i-1, j-1, k1)+wx(i, j-1, k1)+wx(i-1, j, k1)+wx(&
   &          i, j, k1))
   CALL PUSHREAL8(w_y)
   w_y = fourth*(wy(i-1, j-1, k1)+wy(i, j-1, k1)+wy(i-1, j, k1)+wy(&
   &          i, j, k1))
   CALL PUSHREAL8(w_z)
   w_z = fourth*(wz(i-1, j-1, k1)+wz(i, j-1, k1)+wz(i-1, j, k1)+wz(&
   &          i, j, k1))
   CALL PUSHREAL8(q_x)
   q_x = fourth*(qx(i-1, j-1, k1)+qx(i, j-1, k1)+qx(i-1, j, k1)+qx(&
   &          i, j, k1))
   CALL PUSHREAL8(q_y)
   q_y = fourth*(qy(i-1, j-1, k1)+qy(i, j-1, k1)+qy(i-1, j, k1)+qy(&
   &          i, j, k1))
   CALL PUSHREAL8(q_z)
   q_z = fourth*(qz(i-1, j-1, k1)+qz(i, j-1, k1)+qz(i-1, j, k1)+qz(&
   &          i, j, k1))
   CALL PUSHREAL8(ssx)
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center k to cell center k+1.
   ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j, &
   &          k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1, 1)+&
   &          x(i, j, k+1, 1)-x(i, j, k-1, 1))
   CALL PUSHREAL8(ssy)
   ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j, &
   &          k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1, 2)+&
   &          x(i, j, k+1, 2)-x(i, j, k-1, 2))
   CALL PUSHREAL8(ssz)
   ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j, &
   &          k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1, 3)+&
   &          x(i, j, k+1, 3)-x(i, j, k-1, 3))
   CALL PUSHREAL8(ss)
   ! Determine the length of this vector and create the
   ! unit normal.
   ss = one/SQRT(ssx*ssx+ssy*ssy+ssz*ssz)
   CALL PUSHREAL8(ssx)
   ssx = ss*ssx
   CALL PUSHREAL8(ssy)
   ssy = ss*ssy
   CALL PUSHREAL8(ssz)
   ssz = ss*ssz
   CALL PUSHREAL8(corr)
   ! Correct the gradients.
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j, &
   &          k, ivx))*ss
   CALL PUSHREAL8(u_x)
   u_x = u_x - corr*ssx
   CALL PUSHREAL8(u_y)
   u_y = u_y - corr*ssy
   CALL PUSHREAL8(u_z)
   u_z = u_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j, &
   &          k, ivy))*ss
   CALL PUSHREAL8(v_x)
   v_x = v_x - corr*ssx
   CALL PUSHREAL8(v_y)
   v_y = v_y - corr*ssy
   CALL PUSHREAL8(v_z)
   v_z = v_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j, &
   &          k, ivz))*ss
   CALL PUSHREAL8(w_x)
   w_x = w_x - corr*ssx
   CALL PUSHREAL8(w_y)
   w_y = w_y - corr*ssy
   CALL PUSHREAL8(w_z)
   w_z = w_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j, k+1)-p(i, j, k))*&
   &          ss
   CALL PUSHREAL8(q_x)
   q_x = q_x - corr*ssx
   CALL PUSHREAL8(q_y)
   q_y = q_y - corr*ssy
   CALL PUSHREAL8(q_z)
   q_z = q_z - corr*ssz
   CALL PUSHREAL8(fracdiv)
   ! Compute the stress tensor and the heat flux vector.
   fracdiv = twothird*(u_x+v_y+w_z)
   CALL PUSHREAL8(tauxx)
   tauxx = mut*(two*u_x-fracdiv)
   CALL PUSHREAL8(tauyy)
   tauyy = mut*(two*v_y-fracdiv)
   CALL PUSHREAL8(tauzz)
   tauzz = mut*(two*w_z-fracdiv)
   CALL PUSHREAL8(tauxy)
   tauxy = mut*(u_y+v_x)
   CALL PUSHREAL8(tauxz)
   tauxz = mut*(u_z+w_x)
   CALL PUSHREAL8(tauyz)
   tauyz = mut*(v_z+w_y)
   CALL PUSHREAL8(q_x)
   q_x = heatcoef*q_x
   CALL PUSHREAL8(q_y)
   q_y = heatcoef*q_y
   CALL PUSHREAL8(q_z)
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubar = half*(w(i, j, 1, ivx)+w(i, j, 2, ivx))
   vbar = half*(w(i, j, 1, ivy)+w(i, j, 2, ivy))
   wbar = half*(w(i, j, 1, ivz)+w(i, j, 2, ivz))
   ! Compute the viscous fluxes for this k-face.
   fmx = tauxx*sk(i, j, 1, 1) + tauxy*sk(i, j, 1, 2) + tauxz*sk(i, &
   &          j, 1, 3)
   fmy = tauxy*sk(i, j, 1, 1) + tauyy*sk(i, j, 1, 2) + tauyz*sk(i, &
   &          j, 1, 3)
   fmz = tauxz*sk(i, j, 1, 1) + tauyz*sk(i, j, 1, 2) + tauzz*sk(i, &
   &          j, 1, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, 1, 1) + (&
   &          ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, 1, 2) + (ubar*tauxz&
   &          +vbar*tauyz+wbar*tauzz)*sk(i, j, 1, 3) - q_x*sk(i, j, 1, 1) - &
   &          q_y*sk(i, j, 1, 2) - q_z*sk(i, j, 1, 3)
   ! Update the residuals of cell k == 2.
   fw(i, j, 2, imx) = fw(i, j, 2, imx) + fmx
   fw(i, j, 2, imy) = fw(i, j, 2, imy) + fmy
   fw(i, j, 2, imz) = fw(i, j, 2, imz) + fmz
   fw(i, j, 2, irhoe) = fw(i, j, 2, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface.
   IF (storewalltensor .AND. visckminpointer(i, j) .GT. 0) THEN
   viscsubface(nn)%tau(i, j, 1) = tauxx
   viscsubface(nn)%tau(i, j, 2) = tauyy
   viscsubface(nn)%tau(i, j, 3) = tauzz
   viscsubface(nn)%tau(i, j, 4) = tauxy
   viscsubface(nn)%tau(i, j, 5) = tauxz
   viscsubface(nn)%tau(i, j, 6) = tauyz
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   CALL PUSHINTEGER4(k)
   ! Loop over the k-planes.
   kloop:DO k=2,kl
   ! Switch the indices k1 and k2.
   kk = k1
   CALL PUSHINTEGER4(k1)
   k1 = k2
   CALL PUSHINTEGER4(k2)
   k2 = kk
   CALL PUSHREAL8ARRAY(qz, il*jl*2)
   CALL PUSHREAL8ARRAY(qy, il*jl*2)
   CALL PUSHREAL8ARRAY(qx, il*jl*2)
   CALL PUSHREAL8ARRAY(wz, il*jl*2)
   CALL PUSHREAL8ARRAY(wy, il*jl*2)
   CALL PUSHREAL8ARRAY(wx, il*jl*2)
   CALL PUSHREAL8ARRAY(vz, il*jl*2)
   CALL PUSHREAL8ARRAY(vy, il*jl*2)
   CALL PUSHREAL8ARRAY(vx, il*jl*2)
   CALL PUSHREAL8ARRAY(uz, il*jl*2)
   CALL PUSHREAL8ARRAY(uy, il*jl*2)
   CALL PUSHREAL8ARRAY(ux, il*jl*2)
   ! Compute the nodal gradients for the nodes in this k-plane.
   ! The results are stored in ux(:,:,k1), etc.
   CALL NODALGRADIENTS(ux, uy, uz, vx, vy, vz, wx, wy, wz, qx, qy, qz&
   &                   )
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the k-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   DO j=2,jl
   DO i=2,il
   CALL PUSHREAL8(por)
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pork(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
   IF (eddymodel) THEN
   mue = por*(rev(i, j, k)+rev(i, j, k+1))
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(mut)
   mut = mul + mue
   gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL PUSHREAL8(heatcoef)
   heatcoef = mul*factlamheat + mue*factturbheat
   CALL PUSHREAL8(u_x)
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_x = fourth*(ux(i-1, j-1, k1)+ux(i, j-1, k1)+ux(i-1, j, k1)+&
   &            ux(i, j, k1))
   CALL PUSHREAL8(u_y)
   u_y = fourth*(uy(i-1, j-1, k1)+uy(i, j-1, k1)+uy(i-1, j, k1)+&
   &            uy(i, j, k1))
   CALL PUSHREAL8(u_z)
   u_z = fourth*(uz(i-1, j-1, k1)+uz(i, j-1, k1)+uz(i-1, j, k1)+&
   &            uz(i, j, k1))
   CALL PUSHREAL8(v_x)
   v_x = fourth*(vx(i-1, j-1, k1)+vx(i, j-1, k1)+vx(i-1, j, k1)+&
   &            vx(i, j, k1))
   CALL PUSHREAL8(v_y)
   v_y = fourth*(vy(i-1, j-1, k1)+vy(i, j-1, k1)+vy(i-1, j, k1)+&
   &            vy(i, j, k1))
   CALL PUSHREAL8(v_z)
   v_z = fourth*(vz(i-1, j-1, k1)+vz(i, j-1, k1)+vz(i-1, j, k1)+&
   &            vz(i, j, k1))
   CALL PUSHREAL8(w_x)
   w_x = fourth*(wx(i-1, j-1, k1)+wx(i, j-1, k1)+wx(i-1, j, k1)+&
   &            wx(i, j, k1))
   CALL PUSHREAL8(w_y)
   w_y = fourth*(wy(i-1, j-1, k1)+wy(i, j-1, k1)+wy(i-1, j, k1)+&
   &            wy(i, j, k1))
   CALL PUSHREAL8(w_z)
   w_z = fourth*(wz(i-1, j-1, k1)+wz(i, j-1, k1)+wz(i-1, j, k1)+&
   &            wz(i, j, k1))
   CALL PUSHREAL8(q_x)
   q_x = fourth*(qx(i-1, j-1, k1)+qx(i, j-1, k1)+qx(i-1, j, k1)+&
   &            qx(i, j, k1))
   CALL PUSHREAL8(q_y)
   q_y = fourth*(qy(i-1, j-1, k1)+qy(i, j-1, k1)+qy(i-1, j, k1)+&
   &            qy(i, j, k1))
   CALL PUSHREAL8(q_z)
   q_z = fourth*(qz(i-1, j-1, k1)+qz(i, j-1, k1)+qz(i-1, j, k1)+&
   &            qz(i, j, k1))
   CALL PUSHREAL8(ssx)
   !!$             write(unitvf,*) i,j,k, u_x, u_y, u_z
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center k to cell center k+1.
   ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
   &            , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
   &            , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
   CALL PUSHREAL8(ssy)
   ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
   &            , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
   &            , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
   CALL PUSHREAL8(ssz)
   ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
   &            , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
   &            , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
   CALL PUSHREAL8(ss)
   ! Determine the length of this vector and create the
   ! unit normal.
   ss = one/SQRT(ssx*ssx+ssy*ssy+ssz*ssz)
   CALL PUSHREAL8(ssx)
   ssx = ss*ssx
   CALL PUSHREAL8(ssy)
   ssy = ss*ssy
   CALL PUSHREAL8(ssz)
   ssz = ss*ssz
   CALL PUSHREAL8(corr)
   ! Correct the gradients.
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j&
   &            , k, ivx))*ss
   CALL PUSHREAL8(u_x)
   u_x = u_x - corr*ssx
   CALL PUSHREAL8(u_y)
   u_y = u_y - corr*ssy
   CALL PUSHREAL8(u_z)
   u_z = u_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j&
   &            , k, ivy))*ss
   CALL PUSHREAL8(v_x)
   v_x = v_x - corr*ssx
   CALL PUSHREAL8(v_y)
   v_y = v_y - corr*ssy
   CALL PUSHREAL8(v_z)
   v_z = v_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j&
   &            , k, ivz))*ss
   CALL PUSHREAL8(w_x)
   w_x = w_x - corr*ssx
   CALL PUSHREAL8(w_y)
   w_y = w_y - corr*ssy
   CALL PUSHREAL8(w_z)
   w_z = w_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j, k+1)-p(i, j, k))&
   &            *ss
   CALL PUSHREAL8(q_x)
   q_x = q_x - corr*ssx
   CALL PUSHREAL8(q_y)
   q_y = q_y - corr*ssy
   CALL PUSHREAL8(q_z)
   q_z = q_z - corr*ssz
   CALL PUSHREAL8(fracdiv)
   ! Compute the stress tensor and the heat flux vector.
   fracdiv = twothird*(u_x+v_y+w_z)
   CALL PUSHREAL8(tauxx)
   tauxx = mut*(two*u_x-fracdiv)
   CALL PUSHREAL8(tauyy)
   tauyy = mut*(two*v_y-fracdiv)
   CALL PUSHREAL8(tauzz)
   tauzz = mut*(two*w_z-fracdiv)
   CALL PUSHREAL8(tauxy)
   tauxy = mut*(u_y+v_x)
   CALL PUSHREAL8(tauxz)
   tauxz = mut*(u_z+w_x)
   CALL PUSHREAL8(tauyz)
   tauyz = mut*(v_z+w_y)
   CALL PUSHREAL8(q_x)
   q_x = heatcoef*q_x
   CALL PUSHREAL8(q_y)
   q_y = heatcoef*q_y
   CALL PUSHREAL8(q_z)
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
   vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
   wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
   ! Compute the viscous fluxes for this k-face.
   fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i&
   &            , j, k, 3)
   fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i&
   &            , j, k, 3)
   fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i&
   &            , j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1) + (&
   &            ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k, 2) + (ubar*&
   &            tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k, 3) - q_x*sk(i, j, k&
   &            , 1) - q_y*sk(i, j, k, 2) - q_z*sk(i, j, k, 3)
   ! Update the residuals of cell k and k+1.
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
   fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
   fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
   fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface.
   IF (k .EQ. kl .AND. storewalltensor .AND. visckmaxpointer(i, j&
   &              ) .GT. 0) THEN
   viscsubface(nn)%tau(i, j, 1) = tauxx
   viscsubface(nn)%tau(i, j, 2) = tauyy
   viscsubface(nn)%tau(i, j, 3) = tauzz
   viscsubface(nn)%tau(i, j, 4) = tauxy
   viscsubface(nn)%tau(i, j, 5) = tauxz
   viscsubface(nn)%tau(i, j, 6) = tauyz
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the j-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   DO j=1,jl
   DO i=2,il
   CALL PUSHREAL8(por)
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (porj(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
   IF (eddymodel) THEN
   mue = por*(rev(i, j, k)+rev(i, j+1, k))
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(mut)
   mut = mul + mue
   gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL PUSHREAL8(heatcoef)
   heatcoef = mul*factlamheat + mue*factturbheat
   CALL PUSHREAL8(u_x)
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_x = fourth*(ux(i-1, j, k1)+ux(i, j, k1)+ux(i-1, j, k2)+ux(i&
   &            , j, k2))
   CALL PUSHREAL8(u_y)
   u_y = fourth*(uy(i-1, j, k1)+uy(i, j, k1)+uy(i-1, j, k2)+uy(i&
   &            , j, k2))
   CALL PUSHREAL8(u_z)
   u_z = fourth*(uz(i-1, j, k1)+uz(i, j, k1)+uz(i-1, j, k2)+uz(i&
   &            , j, k2))
   CALL PUSHREAL8(v_x)
   v_x = fourth*(vx(i-1, j, k1)+vx(i, j, k1)+vx(i-1, j, k2)+vx(i&
   &            , j, k2))
   CALL PUSHREAL8(v_y)
   v_y = fourth*(vy(i-1, j, k1)+vy(i, j, k1)+vy(i-1, j, k2)+vy(i&
   &            , j, k2))
   CALL PUSHREAL8(v_z)
   v_z = fourth*(vz(i-1, j, k1)+vz(i, j, k1)+vz(i-1, j, k2)+vz(i&
   &            , j, k2))
   CALL PUSHREAL8(w_x)
   w_x = fourth*(wx(i-1, j, k1)+wx(i, j, k1)+wx(i-1, j, k2)+wx(i&
   &            , j, k2))
   CALL PUSHREAL8(w_y)
   w_y = fourth*(wy(i-1, j, k1)+wy(i, j, k1)+wy(i-1, j, k2)+wy(i&
   &            , j, k2))
   CALL PUSHREAL8(w_z)
   w_z = fourth*(wz(i-1, j, k1)+wz(i, j, k1)+wz(i-1, j, k2)+wz(i&
   &            , j, k2))
   CALL PUSHREAL8(q_x)
   q_x = fourth*(qx(i-1, j, k1)+qx(i, j, k1)+qx(i-1, j, k2)+qx(i&
   &            , j, k2))
   CALL PUSHREAL8(q_y)
   q_y = fourth*(qy(i-1, j, k1)+qy(i, j, k1)+qy(i-1, j, k2)+qy(i&
   &            , j, k2))
   CALL PUSHREAL8(q_z)
   q_z = fourth*(qz(i-1, j, k1)+qz(i, j, k1)+qz(i-1, j, k2)+qz(i&
   &            , j, k2))
   CALL PUSHREAL8(ssx)
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center j to cell center j+1.
   ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
   &            +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
   &            , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
   CALL PUSHREAL8(ssy)
   ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
   &            +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
   &            , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
   CALL PUSHREAL8(ssz)
   ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
   &            +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
   &            , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
   CALL PUSHREAL8(ss)
   ! Determine the length of this vector and create the
   ! unit normal.
   ss = one/SQRT(ssx*ssx+ssy*ssy+ssz*ssz)
   CALL PUSHREAL8(ssx)
   ssx = ss*ssx
   CALL PUSHREAL8(ssy)
   ssy = ss*ssy
   CALL PUSHREAL8(ssz)
   ssz = ss*ssz
   CALL PUSHREAL8(corr)
   ! Correct the gradients.
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j&
   &            , k, ivx))*ss
   CALL PUSHREAL8(u_x)
   u_x = u_x - corr*ssx
   CALL PUSHREAL8(u_y)
   u_y = u_y - corr*ssy
   CALL PUSHREAL8(u_z)
   u_z = u_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j&
   &            , k, ivy))*ss
   CALL PUSHREAL8(v_x)
   v_x = v_x - corr*ssx
   CALL PUSHREAL8(v_y)
   v_y = v_y - corr*ssy
   CALL PUSHREAL8(v_z)
   v_z = v_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j&
   &            , k, ivz))*ss
   CALL PUSHREAL8(w_x)
   w_x = w_x - corr*ssx
   CALL PUSHREAL8(w_y)
   w_y = w_y - corr*ssy
   CALL PUSHREAL8(w_z)
   w_z = w_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j+1, k)-p(i, j, k))&
   &            *ss
   CALL PUSHREAL8(q_x)
   q_x = q_x - corr*ssx
   CALL PUSHREAL8(q_y)
   q_y = q_y - corr*ssy
   CALL PUSHREAL8(q_z)
   q_z = q_z - corr*ssz
   CALL PUSHREAL8(fracdiv)
   ! Compute the stress tensor and the heat flux vector.
   fracdiv = twothird*(u_x+v_y+w_z)
   CALL PUSHREAL8(tauxx)
   tauxx = mut*(two*u_x-fracdiv)
   CALL PUSHREAL8(tauyy)
   tauyy = mut*(two*v_y-fracdiv)
   CALL PUSHREAL8(tauzz)
   tauzz = mut*(two*w_z-fracdiv)
   CALL PUSHREAL8(tauxy)
   tauxy = mut*(u_y+v_x)
   CALL PUSHREAL8(tauxz)
   tauxz = mut*(u_z+w_x)
   CALL PUSHREAL8(tauyz)
   tauyz = mut*(v_z+w_y)
   CALL PUSHREAL8(q_x)
   q_x = heatcoef*q_x
   CALL PUSHREAL8(q_y)
   q_y = heatcoef*q_y
   CALL PUSHREAL8(q_z)
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
   vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
   wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
   ! Compute the viscous fluxes for this j-face.
   fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i&
   &            , j, k, 3)
   fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i&
   &            , j, k, 3)
   fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i&
   &            , j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
   &            ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
   &            tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k&
   &            , 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
   ! Update the residuals of cell j and j+1.
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
   fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
   fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
   fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface. Both the cases j == 1
   ! and j == jl must be tested.
   IF (j .EQ. 1 .AND. storewalltensor .AND. viscjminpointer(i, k)&
   &              .GT. 0) THEN
   viscsubface(nn)%tau(i, k, 1) = tauxx
   viscsubface(nn)%tau(i, k, 2) = tauyy
   viscsubface(nn)%tau(i, k, 3) = tauzz
   viscsubface(nn)%tau(i, k, 4) = tauxy
   viscsubface(nn)%tau(i, k, 5) = tauxz
   viscsubface(nn)%tau(i, k, 6) = tauyz
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! And the j == jl case.
   IF (j .EQ. jl .AND. storewalltensor .AND. viscjmaxpointer(i, k&
   &              ) .GT. 0) THEN
   viscsubface(nn)%tau(i, k, 1) = tauxx
   viscsubface(nn)%tau(i, k, 2) = tauyy
   viscsubface(nn)%tau(i, k, 3) = tauzz
   viscsubface(nn)%tau(i, k, 4) = tauxy
   viscsubface(nn)%tau(i, k, 5) = tauxz
   viscsubface(nn)%tau(i, k, 6) = tauyz
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the i-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   DO j=2,jl
   DO i=1,il
   CALL PUSHREAL8(por)
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pori(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
   IF (eddymodel) THEN
   mue = por*(rev(i, j, k)+rev(i+1, j, k))
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(mut)
   mut = mul + mue
   gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL PUSHREAL8(heatcoef)
   heatcoef = mul*factlamheat + mue*factturbheat
   CALL PUSHREAL8(u_x)
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_x = fourth*(ux(i, j-1, k1)+ux(i, j, k1)+ux(i, j-1, k2)+ux(i&
   &            , j, k2))
   CALL PUSHREAL8(u_y)
   u_y = fourth*(uy(i, j-1, k1)+uy(i, j, k1)+uy(i, j-1, k2)+uy(i&
   &            , j, k2))
   CALL PUSHREAL8(u_z)
   u_z = fourth*(uz(i, j-1, k1)+uz(i, j, k1)+uz(i, j-1, k2)+uz(i&
   &            , j, k2))
   CALL PUSHREAL8(v_x)
   v_x = fourth*(vx(i, j-1, k1)+vx(i, j, k1)+vx(i, j-1, k2)+vx(i&
   &            , j, k2))
   CALL PUSHREAL8(v_y)
   v_y = fourth*(vy(i, j-1, k1)+vy(i, j, k1)+vy(i, j-1, k2)+vy(i&
   &            , j, k2))
   CALL PUSHREAL8(v_z)
   v_z = fourth*(vz(i, j-1, k1)+vz(i, j, k1)+vz(i, j-1, k2)+vz(i&
   &            , j, k2))
   CALL PUSHREAL8(w_x)
   w_x = fourth*(wx(i, j-1, k1)+wx(i, j, k1)+wx(i, j-1, k2)+wx(i&
   &            , j, k2))
   CALL PUSHREAL8(w_y)
   w_y = fourth*(wy(i, j-1, k1)+wy(i, j, k1)+wy(i, j-1, k2)+wy(i&
   &            , j, k2))
   CALL PUSHREAL8(w_z)
   w_z = fourth*(wz(i, j-1, k1)+wz(i, j, k1)+wz(i, j-1, k2)+wz(i&
   &            , j, k2))
   CALL PUSHREAL8(q_x)
   q_x = fourth*(qx(i, j-1, k1)+qx(i, j, k1)+qx(i, j-1, k2)+qx(i&
   &            , j, k2))
   CALL PUSHREAL8(q_y)
   q_y = fourth*(qy(i, j-1, k1)+qy(i, j, k1)+qy(i, j-1, k2)+qy(i&
   &            , j, k2))
   CALL PUSHREAL8(q_z)
   q_z = fourth*(qz(i, j-1, k1)+qz(i, j, k1)+qz(i, j-1, k2)+qz(i&
   &            , j, k2))
   CALL PUSHREAL8(ssx)
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center i to cell center i+1.
   ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
   &            -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
   &            , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
   CALL PUSHREAL8(ssy)
   ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
   &            -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
   &            , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
   CALL PUSHREAL8(ssz)
   ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
   &            -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
   &            , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
   CALL PUSHREAL8(ss)
   ! Determine the length of this vector and create the
   ! unit normal.
   ss = one/SQRT(ssx*ssx+ssy*ssy+ssz*ssz)
   CALL PUSHREAL8(ssx)
   ssx = ss*ssx
   CALL PUSHREAL8(ssy)
   ssy = ss*ssy
   CALL PUSHREAL8(ssz)
   ssz = ss*ssz
   CALL PUSHREAL8(corr)
   ! Correct the gradients.
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j&
   &            , k, ivx))*ss
   CALL PUSHREAL8(u_x)
   u_x = u_x - corr*ssx
   CALL PUSHREAL8(u_y)
   u_y = u_y - corr*ssy
   CALL PUSHREAL8(u_z)
   u_z = u_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j&
   &            , k, ivy))*ss
   CALL PUSHREAL8(v_x)
   v_x = v_x - corr*ssx
   CALL PUSHREAL8(v_y)
   v_y = v_y - corr*ssy
   CALL PUSHREAL8(v_z)
   v_z = v_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j&
   &            , k, ivz))*ss
   CALL PUSHREAL8(w_x)
   w_x = w_x - corr*ssx
   CALL PUSHREAL8(w_y)
   w_y = w_y - corr*ssy
   CALL PUSHREAL8(w_z)
   w_z = w_z - corr*ssz
   CALL PUSHREAL8(corr)
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i+1, j, k)-p(i, j, k))&
   &            *ss
   CALL PUSHREAL8(q_x)
   q_x = q_x - corr*ssx
   CALL PUSHREAL8(q_y)
   q_y = q_y - corr*ssy
   CALL PUSHREAL8(q_z)
   q_z = q_z - corr*ssz
   CALL PUSHREAL8(fracdiv)
   ! Compute the stress tensor and the heat flux vector.
   fracdiv = twothird*(u_x+v_y+w_z)
   CALL PUSHREAL8(tauxx)
   tauxx = mut*(two*u_x-fracdiv)
   CALL PUSHREAL8(tauyy)
   tauyy = mut*(two*v_y-fracdiv)
   CALL PUSHREAL8(tauzz)
   tauzz = mut*(two*w_z-fracdiv)
   CALL PUSHREAL8(tauxy)
   tauxy = mut*(u_y+v_x)
   CALL PUSHREAL8(tauxz)
   tauxz = mut*(u_z+w_x)
   CALL PUSHREAL8(tauyz)
   tauyz = mut*(v_z+w_y)
   CALL PUSHREAL8(q_x)
   q_x = heatcoef*q_x
   CALL PUSHREAL8(q_y)
   q_y = heatcoef*q_y
   CALL PUSHREAL8(q_z)
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
   vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
   wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
   ! Compute the viscous fluxes for this i-face.
   fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i&
   &            , j, k, 3)
   fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i&
   &            , j, k, 3)
   fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i&
   &            , j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
   &            ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
   &            tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k&
   &            , 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
   ! Update the residuals of cell i and i+1.
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
   fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
   fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
   fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface. Both the cases i == 1
   ! and i == il must be tested.
   IF (i .EQ. 1 .AND. storewalltensor .AND. visciminpointer(j, k)&
   &              .GT. 0) THEN
   viscsubface(nn)%tau(j, k, 1) = tauxx
   viscsubface(nn)%tau(j, k, 2) = tauyy
   viscsubface(nn)%tau(j, k, 3) = tauzz
   viscsubface(nn)%tau(j, k, 4) = tauxy
   viscsubface(nn)%tau(j, k, 5) = tauxz
   viscsubface(nn)%tau(j, k, 6) = tauyz
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! And the i == il case.
   IF (i .EQ. il .AND. storewalltensor .AND. viscimaxpointer(j, k&
   &              ) .GT. 0) THEN
   viscsubface(nn)%tau(j, k, 1) = tauxx
   viscsubface(nn)%tau(j, k, 2) = tauyy
   viscsubface(nn)%tau(j, k, 3) = tauzz
   viscsubface(nn)%tau(j, k, 4) = tauxy
   viscsubface(nn)%tau(j, k, 5) = tauxz
   viscsubface(nn)%tau(j, k, 6) = tauyz
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   END DO kloop
   CALL UTAUWF_B(rfilv)
   revb = 0.0_8
   pb = 0.0_8
   volb = 0.0_8
   wxb = 0.0_8
   wyb = 0.0_8
   wzb = 0.0_8
   qxb = 0.0_8
   qyb = 0.0_8
   qzb = 0.0_8
   uxb = 0.0_8
   uyb = 0.0_8
   uzb = 0.0_8
   mueb = 0.0_8
   vxb = 0.0_8
   vyb = 0.0_8
   vzb = 0.0_8
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tauzzb = 0.0_8
   tauxxb = 0.0_8
   tauxyb = 0.0_8
   tauxzb = 0.0_8
   tauyyb = 0.0_8
   tauyzb = 0.0_8
   ELSE
   tauyz = mut*(v_z+w_y)
   tauyzb = viscsubfaceb(nn)%tau(j, k, 6)
   viscsubfaceb(nn)%tau(j, k, 6) = 0.0_8
   tauxz = mut*(u_z+w_x)
   tauxzb = viscsubfaceb(nn)%tau(j, k, 5)
   viscsubfaceb(nn)%tau(j, k, 5) = 0.0_8
   tauxy = mut*(u_y+v_x)
   tauxyb = viscsubfaceb(nn)%tau(j, k, 4)
   viscsubfaceb(nn)%tau(j, k, 4) = 0.0_8
   tauzz = mut*(two*w_z-fracdiv)
   tauzzb = viscsubfaceb(nn)%tau(j, k, 3)
   viscsubfaceb(nn)%tau(j, k, 3) = 0.0_8
   tauyy = mut*(two*v_y-fracdiv)
   tauyyb = viscsubfaceb(nn)%tau(j, k, 2)
   viscsubfaceb(nn)%tau(j, k, 2) = 0.0_8
   tauxx = mut*(two*u_x-fracdiv)
   tauxxb = viscsubfaceb(nn)%tau(j, k, 1)
   viscsubfaceb(nn)%tau(j, k, 1) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tauyzb = tauyzb + viscsubfaceb(nn)%tau(j, k, 6)
   viscsubfaceb(nn)%tau(j, k, 6) = 0.0_8
   tauxzb = tauxzb + viscsubfaceb(nn)%tau(j, k, 5)
   viscsubfaceb(nn)%tau(j, k, 5) = 0.0_8
   tauxyb = tauxyb + viscsubfaceb(nn)%tau(j, k, 4)
   viscsubfaceb(nn)%tau(j, k, 4) = 0.0_8
   tauzzb = tauzzb + viscsubfaceb(nn)%tau(j, k, 3)
   viscsubfaceb(nn)%tau(j, k, 3) = 0.0_8
   tauyyb = tauyyb + viscsubfaceb(nn)%tau(j, k, 2)
   viscsubfaceb(nn)%tau(j, k, 2) = 0.0_8
   tauxxb = tauxxb + viscsubfaceb(nn)%tau(j, k, 1)
   viscsubfaceb(nn)%tau(j, k, 1) = 0.0_8
   END IF
   frhoeb = fwb(i+1, j, k, irhoe) - fwb(i, j, k, irhoe)
   fmzb = fwb(i+1, j, k, imz) - fwb(i, j, k, imz)
   fmyb = fwb(i+1, j, k, imy) - fwb(i, j, k, imy)
   fmxb = fwb(i+1, j, k, imx) - fwb(i, j, k, imx)
   wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
   vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
   ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
   temp8b = si(i, j, k, 1)*frhoeb
   temp8b0 = si(i, j, k, 2)*frhoeb
   temp8b1 = si(i, j, k, 3)*frhoeb
   ubarb = tauxz*temp8b1 + tauxy*temp8b0 + tauxx*temp8b
   tauxxb = tauxxb + si(i, j, k, 1)*fmxb + ubar*temp8b
   vbarb = tauyz*temp8b1 + tauyy*temp8b0 + tauxy*temp8b
   tauxyb = tauxyb + si(i, j, k, 1)*fmyb + si(i, j, k, 2)*fmxb + &
   &            ubar*temp8b0 + vbar*temp8b
   wbarb = tauzz*temp8b1 + tauyz*temp8b0 + tauxz*temp8b
   tauxzb = tauxzb + si(i, j, k, 1)*fmzb + si(i, j, k, 3)*fmxb + &
   &            ubar*temp8b1 + wbar*temp8b
   sib(i, j, k, 1) = sib(i, j, k, 1) + (ubar*tauxx-q_x+vbar*tauxy&
   &            +wbar*tauxz)*frhoeb
   tauyyb = tauyyb + si(i, j, k, 2)*fmyb + vbar*temp8b0
   tauyzb = tauyzb + si(i, j, k, 2)*fmzb + si(i, j, k, 3)*fmyb + &
   &            vbar*temp8b1 + wbar*temp8b0
   sib(i, j, k, 2) = sib(i, j, k, 2) + (ubar*tauxy-q_y+vbar*tauyy&
   &            +wbar*tauyz)*frhoeb
   tauzzb = tauzzb + si(i, j, k, 3)*fmzb + wbar*temp8b1
   sib(i, j, k, 3) = sib(i, j, k, 3) + (ubar*tauxz-q_z+vbar*tauyz&
   &            +wbar*tauzz)*frhoeb
   q_xb = -(si(i, j, k, 1)*frhoeb)
   q_yb = -(si(i, j, k, 2)*frhoeb)
   q_zb = -(si(i, j, k, 3)*frhoeb)
   sib(i, j, k, 1) = sib(i, j, k, 1) + tauxz*fmzb
   sib(i, j, k, 2) = sib(i, j, k, 2) + tauyz*fmzb
   sib(i, j, k, 3) = sib(i, j, k, 3) + tauzz*fmzb
   sib(i, j, k, 1) = sib(i, j, k, 1) + tauxy*fmyb
   sib(i, j, k, 2) = sib(i, j, k, 2) + tauyy*fmyb
   sib(i, j, k, 3) = sib(i, j, k, 3) + tauyz*fmyb
   sib(i, j, k, 1) = sib(i, j, k, 1) + tauxx*fmxb
   sib(i, j, k, 2) = sib(i, j, k, 2) + tauxy*fmxb
   sib(i, j, k, 3) = sib(i, j, k, 3) + tauxz*fmxb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + half*wbarb
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + half*wbarb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + half*vbarb
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + half*vbarb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + half*ubarb
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + half*ubarb
   CALL POPREAL8(q_z)
   CALL POPREAL8(q_y)
   CALL POPREAL8(q_x)
   heatcoefb = q_y*q_yb + q_x*q_xb + q_z*q_zb
   q_zb = heatcoef*q_zb
   q_yb = heatcoef*q_yb
   q_xb = heatcoef*q_xb
   CALL POPREAL8(tauyz)
   mutb = (u_z+w_x)*tauxzb + (two*w_z-fracdiv)*tauzzb + (two*u_x-&
   &            fracdiv)*tauxxb + (two*v_y-fracdiv)*tauyyb + (u_y+v_x)*&
   &            tauxyb + (v_z+w_y)*tauyzb
   v_zb = mut*tauyzb
   w_yb = mut*tauyzb
   CALL POPREAL8(tauxz)
   u_zb = mut*tauxzb
   w_xb = mut*tauxzb
   CALL POPREAL8(tauxy)
   u_yb = mut*tauxyb
   v_xb = mut*tauxyb
   CALL POPREAL8(tauzz)
   fracdivb = -(mut*tauyyb) - mut*tauxxb - mut*tauzzb
   CALL POPREAL8(tauyy)
   CALL POPREAL8(tauxx)
   CALL POPREAL8(fracdiv)
   temp8b2 = twothird*fracdivb
   w_zb = temp8b2 + mut*two*tauzzb
   v_yb = temp8b2 + mut*two*tauyyb
   u_xb = temp8b2 + mut*two*tauxxb
   CALL POPREAL8(q_z)
   corrb = -(ssy*q_yb) - ssx*q_xb - ssz*q_zb
   sszb = q_z*corrb - corr*q_zb
   CALL POPREAL8(q_y)
   ssyb = q_y*corrb - corr*q_yb
   CALL POPREAL8(q_x)
   ssxb = q_x*corrb - corr*q_xb
   CALL POPREAL8(corr)
   q_xb = q_xb + ssx*corrb
   q_yb = q_yb + ssy*corrb
   q_zb = q_zb + ssz*corrb
   pb(i+1, j, k) = pb(i+1, j, k) + ss*corrb
   pb(i, j, k) = pb(i, j, k) - ss*corrb
   ssb = (p(i+1, j, k)-p(i, j, k))*corrb
   CALL POPREAL8(w_z)
   corrb = -(ssy*w_yb) - ssx*w_xb - ssz*w_zb
   sszb = sszb + w_z*corrb - corr*w_zb
   CALL POPREAL8(w_y)
   ssyb = ssyb + w_y*corrb - corr*w_yb
   CALL POPREAL8(w_x)
   ssxb = ssxb + w_x*corrb - corr*w_xb
   CALL POPREAL8(corr)
   w_xb = w_xb + ssx*corrb
   w_yb = w_yb + ssy*corrb
   w_zb = w_zb + ssz*corrb
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) - ss*corrb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + ss*corrb
   ssb = ssb - (w(i+1, j, k, ivz)-w(i, j, k, ivz))*corrb
   CALL POPREAL8(v_z)
   corrb = -(ssy*v_yb) - ssx*v_xb - ssz*v_zb
   sszb = sszb + v_z*corrb - corr*v_zb
   CALL POPREAL8(v_y)
   ssyb = ssyb + v_y*corrb - corr*v_yb
   CALL POPREAL8(v_x)
   ssxb = ssxb + v_x*corrb - corr*v_xb
   CALL POPREAL8(corr)
   v_xb = v_xb + ssx*corrb
   v_yb = v_yb + ssy*corrb
   v_zb = v_zb + ssz*corrb
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) - ss*corrb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + ss*corrb
   ssb = ssb - (w(i+1, j, k, ivy)-w(i, j, k, ivy))*corrb
   CALL POPREAL8(u_z)
   corrb = -(ssy*u_yb) - ssx*u_xb - ssz*u_zb
   sszb = sszb + u_z*corrb - corr*u_zb
   CALL POPREAL8(u_y)
   ssyb = ssyb + u_y*corrb - corr*u_yb
   CALL POPREAL8(u_x)
   ssxb = ssxb + u_x*corrb - corr*u_xb
   CALL POPREAL8(corr)
   u_xb = u_xb + ssx*corrb
   u_yb = u_yb + ssy*corrb
   u_zb = u_zb + ssz*corrb
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) - ss*corrb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + ss*corrb
   CALL POPREAL8(ssz)
   CALL POPREAL8(ssy)
   CALL POPREAL8(ssx)
   ssb = ssb + ssz*sszb + ssx*ssxb + ssy*ssyb - (w(i+1, j, k, ivx&
   &            )-w(i, j, k, ivx))*corrb
   temp6 = ssx**2 + ssy**2 + ssz**2
   temp7 = SQRT(temp6)
   IF (temp6 .EQ. 0.0) THEN
   temp6b3 = 0.0
   ELSE
   temp6b3 = -(one*ssb/(temp7**3*2.0))
   END IF
   sszb = 2*ssz*temp6b3 + ss*sszb
   ssyb = 2*ssy*temp6b3 + ss*ssyb
   ssxb = 2*ssx*temp6b3 + ss*ssxb
   CALL POPREAL8(ss)
   CALL POPREAL8(ssz)
   temp6b4 = eighth*sszb
   xb(i+1, j-1, k-1, 3) = xb(i+1, j-1, k-1, 3) + temp6b4
   xb(i-1, j-1, k-1, 3) = xb(i-1, j-1, k-1, 3) - temp6b4
   xb(i+1, j-1, k, 3) = xb(i+1, j-1, k, 3) + temp6b4
   xb(i-1, j-1, k, 3) = xb(i-1, j-1, k, 3) - temp6b4
   xb(i+1, j, k-1, 3) = xb(i+1, j, k-1, 3) + temp6b4
   xb(i-1, j, k-1, 3) = xb(i-1, j, k-1, 3) - temp6b4
   xb(i+1, j, k, 3) = xb(i+1, j, k, 3) + temp6b4
   xb(i-1, j, k, 3) = xb(i-1, j, k, 3) - temp6b4
   CALL POPREAL8(ssy)
   temp6b5 = eighth*ssyb
   xb(i+1, j-1, k-1, 2) = xb(i+1, j-1, k-1, 2) + temp6b5
   xb(i-1, j-1, k-1, 2) = xb(i-1, j-1, k-1, 2) - temp6b5
   xb(i+1, j-1, k, 2) = xb(i+1, j-1, k, 2) + temp6b5
   xb(i-1, j-1, k, 2) = xb(i-1, j-1, k, 2) - temp6b5
   xb(i+1, j, k-1, 2) = xb(i+1, j, k-1, 2) + temp6b5
   xb(i-1, j, k-1, 2) = xb(i-1, j, k-1, 2) - temp6b5
   xb(i+1, j, k, 2) = xb(i+1, j, k, 2) + temp6b5
   xb(i-1, j, k, 2) = xb(i-1, j, k, 2) - temp6b5
   CALL POPREAL8(ssx)
   temp6b6 = eighth*ssxb
   xb(i+1, j-1, k-1, 1) = xb(i+1, j-1, k-1, 1) + temp6b6
   xb(i-1, j-1, k-1, 1) = xb(i-1, j-1, k-1, 1) - temp6b6
   xb(i+1, j-1, k, 1) = xb(i+1, j-1, k, 1) + temp6b6
   xb(i-1, j-1, k, 1) = xb(i-1, j-1, k, 1) - temp6b6
   xb(i+1, j, k-1, 1) = xb(i+1, j, k-1, 1) + temp6b6
   xb(i-1, j, k-1, 1) = xb(i-1, j, k-1, 1) - temp6b6
   xb(i+1, j, k, 1) = xb(i+1, j, k, 1) + temp6b6
   xb(i-1, j, k, 1) = xb(i-1, j, k, 1) - temp6b6
   CALL POPREAL8(q_z)
   temp6b7 = fourth*q_zb
   qzb(i, j-1, k1) = qzb(i, j-1, k1) + temp6b7
   qzb(i, j, k1) = qzb(i, j, k1) + temp6b7
   qzb(i, j-1, k2) = qzb(i, j-1, k2) + temp6b7
   qzb(i, j, k2) = qzb(i, j, k2) + temp6b7
   CALL POPREAL8(q_y)
   temp6b8 = fourth*q_yb
   qyb(i, j-1, k1) = qyb(i, j-1, k1) + temp6b8
   qyb(i, j, k1) = qyb(i, j, k1) + temp6b8
   qyb(i, j-1, k2) = qyb(i, j-1, k2) + temp6b8
   qyb(i, j, k2) = qyb(i, j, k2) + temp6b8
   CALL POPREAL8(q_x)
   temp6b9 = fourth*q_xb
   qxb(i, j-1, k1) = qxb(i, j-1, k1) + temp6b9
   qxb(i, j, k1) = qxb(i, j, k1) + temp6b9
   qxb(i, j-1, k2) = qxb(i, j-1, k2) + temp6b9
   qxb(i, j, k2) = qxb(i, j, k2) + temp6b9
   CALL POPREAL8(w_z)
   temp6b10 = fourth*w_zb
   wzb(i, j-1, k1) = wzb(i, j-1, k1) + temp6b10
   wzb(i, j, k1) = wzb(i, j, k1) + temp6b10
   wzb(i, j-1, k2) = wzb(i, j-1, k2) + temp6b10
   wzb(i, j, k2) = wzb(i, j, k2) + temp6b10
   CALL POPREAL8(w_y)
   temp6b11 = fourth*w_yb
   wyb(i, j-1, k1) = wyb(i, j-1, k1) + temp6b11
   wyb(i, j, k1) = wyb(i, j, k1) + temp6b11
   wyb(i, j-1, k2) = wyb(i, j-1, k2) + temp6b11
   wyb(i, j, k2) = wyb(i, j, k2) + temp6b11
   CALL POPREAL8(w_x)
   temp6b12 = fourth*w_xb
   wxb(i, j-1, k1) = wxb(i, j-1, k1) + temp6b12
   wxb(i, j, k1) = wxb(i, j, k1) + temp6b12
   wxb(i, j-1, k2) = wxb(i, j-1, k2) + temp6b12
   wxb(i, j, k2) = wxb(i, j, k2) + temp6b12
   CALL POPREAL8(v_z)
   temp6b13 = fourth*v_zb
   vzb(i, j-1, k1) = vzb(i, j-1, k1) + temp6b13
   vzb(i, j, k1) = vzb(i, j, k1) + temp6b13
   vzb(i, j-1, k2) = vzb(i, j-1, k2) + temp6b13
   vzb(i, j, k2) = vzb(i, j, k2) + temp6b13
   CALL POPREAL8(v_y)
   temp6b14 = fourth*v_yb
   vyb(i, j-1, k1) = vyb(i, j-1, k1) + temp6b14
   vyb(i, j, k1) = vyb(i, j, k1) + temp6b14
   vyb(i, j-1, k2) = vyb(i, j-1, k2) + temp6b14
   vyb(i, j, k2) = vyb(i, j, k2) + temp6b14
   CALL POPREAL8(v_x)
   temp6b15 = fourth*v_xb
   vxb(i, j-1, k1) = vxb(i, j-1, k1) + temp6b15
   vxb(i, j, k1) = vxb(i, j, k1) + temp6b15
   vxb(i, j-1, k2) = vxb(i, j-1, k2) + temp6b15
   vxb(i, j, k2) = vxb(i, j, k2) + temp6b15
   CALL POPREAL8(u_z)
   temp6b16 = fourth*u_zb
   uzb(i, j-1, k1) = uzb(i, j-1, k1) + temp6b16
   uzb(i, j, k1) = uzb(i, j, k1) + temp6b16
   uzb(i, j-1, k2) = uzb(i, j-1, k2) + temp6b16
   uzb(i, j, k2) = uzb(i, j, k2) + temp6b16
   CALL POPREAL8(u_y)
   temp6b17 = fourth*u_yb
   uyb(i, j-1, k1) = uyb(i, j-1, k1) + temp6b17
   uyb(i, j, k1) = uyb(i, j, k1) + temp6b17
   uyb(i, j-1, k2) = uyb(i, j-1, k2) + temp6b17
   uyb(i, j, k2) = uyb(i, j, k2) + temp6b17
   CALL POPREAL8(u_x)
   temp6b18 = fourth*u_xb
   uxb(i, j-1, k1) = uxb(i, j-1, k1) + temp6b18
   uxb(i, j, k1) = uxb(i, j, k1) + temp6b18
   uxb(i, j-1, k2) = uxb(i, j-1, k2) + temp6b18
   uxb(i, j, k2) = uxb(i, j, k2) + temp6b18
   gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL POPREAL8(heatcoef)
   mulb = mutb + factlamheat*heatcoefb
   mueb = mueb + mutb + factturbheat*heatcoefb
   CALL POPREAL8(mut)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   revb(i, j, k) = revb(i, j, k) + por*mueb
   revb(i+1, j, k) = revb(i+1, j, k) + por*mueb
   mueb = 0.0_8
   END IF
   rlvb(i, j, k) = rlvb(i, j, k) + por*mulb
   rlvb(i+1, j, k) = rlvb(i+1, j, k) + por*mulb
   CALL POPREAL8(por)
   END DO
   END DO
   DO j=jl,1,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tauzzb = 0.0_8
   tauxxb = 0.0_8
   tauxyb = 0.0_8
   tauxzb = 0.0_8
   tauyyb = 0.0_8
   tauyzb = 0.0_8
   ELSE
   tauyz = mut*(v_z+w_y)
   tauyzb = viscsubfaceb(nn)%tau(i, k, 6)
   viscsubfaceb(nn)%tau(i, k, 6) = 0.0_8
   tauxz = mut*(u_z+w_x)
   tauxzb = viscsubfaceb(nn)%tau(i, k, 5)
   viscsubfaceb(nn)%tau(i, k, 5) = 0.0_8
   tauxy = mut*(u_y+v_x)
   tauxyb = viscsubfaceb(nn)%tau(i, k, 4)
   viscsubfaceb(nn)%tau(i, k, 4) = 0.0_8
   tauzz = mut*(two*w_z-fracdiv)
   tauzzb = viscsubfaceb(nn)%tau(i, k, 3)
   viscsubfaceb(nn)%tau(i, k, 3) = 0.0_8
   tauyy = mut*(two*v_y-fracdiv)
   tauyyb = viscsubfaceb(nn)%tau(i, k, 2)
   viscsubfaceb(nn)%tau(i, k, 2) = 0.0_8
   tauxx = mut*(two*u_x-fracdiv)
   tauxxb = viscsubfaceb(nn)%tau(i, k, 1)
   viscsubfaceb(nn)%tau(i, k, 1) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tauyzb = tauyzb + viscsubfaceb(nn)%tau(i, k, 6)
   viscsubfaceb(nn)%tau(i, k, 6) = 0.0_8
   tauxzb = tauxzb + viscsubfaceb(nn)%tau(i, k, 5)
   viscsubfaceb(nn)%tau(i, k, 5) = 0.0_8
   tauxyb = tauxyb + viscsubfaceb(nn)%tau(i, k, 4)
   viscsubfaceb(nn)%tau(i, k, 4) = 0.0_8
   tauzzb = tauzzb + viscsubfaceb(nn)%tau(i, k, 3)
   viscsubfaceb(nn)%tau(i, k, 3) = 0.0_8
   tauyyb = tauyyb + viscsubfaceb(nn)%tau(i, k, 2)
   viscsubfaceb(nn)%tau(i, k, 2) = 0.0_8
   tauxxb = tauxxb + viscsubfaceb(nn)%tau(i, k, 1)
   viscsubfaceb(nn)%tau(i, k, 1) = 0.0_8
   END IF
   frhoeb = fwb(i, j+1, k, irhoe) - fwb(i, j, k, irhoe)
   fmzb = fwb(i, j+1, k, imz) - fwb(i, j, k, imz)
   fmyb = fwb(i, j+1, k, imy) - fwb(i, j, k, imy)
   fmxb = fwb(i, j+1, k, imx) - fwb(i, j, k, imx)
   wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
   vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
   ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
   temp6b = sj(i, j, k, 1)*frhoeb
   temp6b0 = sj(i, j, k, 2)*frhoeb
   temp6b1 = sj(i, j, k, 3)*frhoeb
   ubarb = tauxz*temp6b1 + tauxy*temp6b0 + tauxx*temp6b
   tauxxb = tauxxb + sj(i, j, k, 1)*fmxb + ubar*temp6b
   vbarb = tauyz*temp6b1 + tauyy*temp6b0 + tauxy*temp6b
   tauxyb = tauxyb + sj(i, j, k, 1)*fmyb + sj(i, j, k, 2)*fmxb + &
   &            ubar*temp6b0 + vbar*temp6b
   wbarb = tauzz*temp6b1 + tauyz*temp6b0 + tauxz*temp6b
   tauxzb = tauxzb + sj(i, j, k, 1)*fmzb + sj(i, j, k, 3)*fmxb + &
   &            ubar*temp6b1 + wbar*temp6b
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + (ubar*tauxx-q_x+vbar*tauxy&
   &            +wbar*tauxz)*frhoeb
   tauyyb = tauyyb + sj(i, j, k, 2)*fmyb + vbar*temp6b0
   tauyzb = tauyzb + sj(i, j, k, 2)*fmzb + sj(i, j, k, 3)*fmyb + &
   &            vbar*temp6b1 + wbar*temp6b0
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + (ubar*tauxy-q_y+vbar*tauyy&
   &            +wbar*tauyz)*frhoeb
   tauzzb = tauzzb + sj(i, j, k, 3)*fmzb + wbar*temp6b1
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + (ubar*tauxz-q_z+vbar*tauyz&
   &            +wbar*tauzz)*frhoeb
   q_xb = -(sj(i, j, k, 1)*frhoeb)
   q_yb = -(sj(i, j, k, 2)*frhoeb)
   q_zb = -(sj(i, j, k, 3)*frhoeb)
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + tauxz*fmzb
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + tauyz*fmzb
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + tauzz*fmzb
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + tauxy*fmyb
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + tauyy*fmyb
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + tauyz*fmyb
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + tauxx*fmxb
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + tauxy*fmxb
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + tauxz*fmxb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + half*wbarb
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + half*wbarb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + half*vbarb
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + half*vbarb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + half*ubarb
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + half*ubarb
   CALL POPREAL8(q_z)
   CALL POPREAL8(q_y)
   CALL POPREAL8(q_x)
   heatcoefb = q_y*q_yb + q_x*q_xb + q_z*q_zb
   q_zb = heatcoef*q_zb
   q_yb = heatcoef*q_yb
   q_xb = heatcoef*q_xb
   CALL POPREAL8(tauyz)
   mutb = (u_z+w_x)*tauxzb + (two*w_z-fracdiv)*tauzzb + (two*u_x-&
   &            fracdiv)*tauxxb + (two*v_y-fracdiv)*tauyyb + (u_y+v_x)*&
   &            tauxyb + (v_z+w_y)*tauyzb
   v_zb = mut*tauyzb
   w_yb = mut*tauyzb
   CALL POPREAL8(tauxz)
   u_zb = mut*tauxzb
   w_xb = mut*tauxzb
   CALL POPREAL8(tauxy)
   u_yb = mut*tauxyb
   v_xb = mut*tauxyb
   CALL POPREAL8(tauzz)
   fracdivb = -(mut*tauyyb) - mut*tauxxb - mut*tauzzb
   CALL POPREAL8(tauyy)
   CALL POPREAL8(tauxx)
   CALL POPREAL8(fracdiv)
   temp6b2 = twothird*fracdivb
   w_zb = temp6b2 + mut*two*tauzzb
   v_yb = temp6b2 + mut*two*tauyyb
   u_xb = temp6b2 + mut*two*tauxxb
   CALL POPREAL8(q_z)
   corrb = -(ssy*q_yb) - ssx*q_xb - ssz*q_zb
   sszb = q_z*corrb - corr*q_zb
   CALL POPREAL8(q_y)
   ssyb = q_y*corrb - corr*q_yb
   CALL POPREAL8(q_x)
   ssxb = q_x*corrb - corr*q_xb
   CALL POPREAL8(corr)
   q_xb = q_xb + ssx*corrb
   q_yb = q_yb + ssy*corrb
   q_zb = q_zb + ssz*corrb
   pb(i, j+1, k) = pb(i, j+1, k) + ss*corrb
   pb(i, j, k) = pb(i, j, k) - ss*corrb
   ssb = (p(i, j+1, k)-p(i, j, k))*corrb
   CALL POPREAL8(w_z)
   corrb = -(ssy*w_yb) - ssx*w_xb - ssz*w_zb
   sszb = sszb + w_z*corrb - corr*w_zb
   CALL POPREAL8(w_y)
   ssyb = ssyb + w_y*corrb - corr*w_yb
   CALL POPREAL8(w_x)
   ssxb = ssxb + w_x*corrb - corr*w_xb
   CALL POPREAL8(corr)
   w_xb = w_xb + ssx*corrb
   w_yb = w_yb + ssy*corrb
   w_zb = w_zb + ssz*corrb
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) - ss*corrb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + ss*corrb
   ssb = ssb - (w(i, j+1, k, ivz)-w(i, j, k, ivz))*corrb
   CALL POPREAL8(v_z)
   corrb = -(ssy*v_yb) - ssx*v_xb - ssz*v_zb
   sszb = sszb + v_z*corrb - corr*v_zb
   CALL POPREAL8(v_y)
   ssyb = ssyb + v_y*corrb - corr*v_yb
   CALL POPREAL8(v_x)
   ssxb = ssxb + v_x*corrb - corr*v_xb
   CALL POPREAL8(corr)
   v_xb = v_xb + ssx*corrb
   v_yb = v_yb + ssy*corrb
   v_zb = v_zb + ssz*corrb
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) - ss*corrb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + ss*corrb
   ssb = ssb - (w(i, j+1, k, ivy)-w(i, j, k, ivy))*corrb
   CALL POPREAL8(u_z)
   corrb = -(ssy*u_yb) - ssx*u_xb - ssz*u_zb
   sszb = sszb + u_z*corrb - corr*u_zb
   CALL POPREAL8(u_y)
   ssyb = ssyb + u_y*corrb - corr*u_yb
   CALL POPREAL8(u_x)
   ssxb = ssxb + u_x*corrb - corr*u_xb
   CALL POPREAL8(corr)
   u_xb = u_xb + ssx*corrb
   u_yb = u_yb + ssy*corrb
   u_zb = u_zb + ssz*corrb
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) - ss*corrb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + ss*corrb
   CALL POPREAL8(ssz)
   CALL POPREAL8(ssy)
   CALL POPREAL8(ssx)
   ssb = ssb + ssz*sszb + ssx*ssxb + ssy*ssyb - (w(i, j+1, k, ivx&
   &            )-w(i, j, k, ivx))*corrb
   temp4 = ssx**2 + ssy**2 + ssz**2
   temp5 = SQRT(temp4)
   IF (temp4 .EQ. 0.0) THEN
   temp4b3 = 0.0
   ELSE
   temp4b3 = -(one*ssb/(temp5**3*2.0))
   END IF
   sszb = 2*ssz*temp4b3 + ss*sszb
   ssyb = 2*ssy*temp4b3 + ss*ssyb
   ssxb = 2*ssx*temp4b3 + ss*ssxb
   CALL POPREAL8(ss)
   CALL POPREAL8(ssz)
   temp4b4 = eighth*sszb
   xb(i-1, j+1, k-1, 3) = xb(i-1, j+1, k-1, 3) + temp4b4
   xb(i-1, j-1, k-1, 3) = xb(i-1, j-1, k-1, 3) - temp4b4
   xb(i-1, j+1, k, 3) = xb(i-1, j+1, k, 3) + temp4b4
   xb(i-1, j-1, k, 3) = xb(i-1, j-1, k, 3) - temp4b4
   xb(i, j+1, k-1, 3) = xb(i, j+1, k-1, 3) + temp4b4
   xb(i, j-1, k-1, 3) = xb(i, j-1, k-1, 3) - temp4b4
   xb(i, j+1, k, 3) = xb(i, j+1, k, 3) + temp4b4
   xb(i, j-1, k, 3) = xb(i, j-1, k, 3) - temp4b4
   CALL POPREAL8(ssy)
   temp4b5 = eighth*ssyb
   xb(i-1, j+1, k-1, 2) = xb(i-1, j+1, k-1, 2) + temp4b5
   xb(i-1, j-1, k-1, 2) = xb(i-1, j-1, k-1, 2) - temp4b5
   xb(i-1, j+1, k, 2) = xb(i-1, j+1, k, 2) + temp4b5
   xb(i-1, j-1, k, 2) = xb(i-1, j-1, k, 2) - temp4b5
   xb(i, j+1, k-1, 2) = xb(i, j+1, k-1, 2) + temp4b5
   xb(i, j-1, k-1, 2) = xb(i, j-1, k-1, 2) - temp4b5
   xb(i, j+1, k, 2) = xb(i, j+1, k, 2) + temp4b5
   xb(i, j-1, k, 2) = xb(i, j-1, k, 2) - temp4b5
   CALL POPREAL8(ssx)
   temp4b6 = eighth*ssxb
   xb(i-1, j+1, k-1, 1) = xb(i-1, j+1, k-1, 1) + temp4b6
   xb(i-1, j-1, k-1, 1) = xb(i-1, j-1, k-1, 1) - temp4b6
   xb(i-1, j+1, k, 1) = xb(i-1, j+1, k, 1) + temp4b6
   xb(i-1, j-1, k, 1) = xb(i-1, j-1, k, 1) - temp4b6
   xb(i, j+1, k-1, 1) = xb(i, j+1, k-1, 1) + temp4b6
   xb(i, j-1, k-1, 1) = xb(i, j-1, k-1, 1) - temp4b6
   xb(i, j+1, k, 1) = xb(i, j+1, k, 1) + temp4b6
   xb(i, j-1, k, 1) = xb(i, j-1, k, 1) - temp4b6
   CALL POPREAL8(q_z)
   temp4b7 = fourth*q_zb
   qzb(i-1, j, k1) = qzb(i-1, j, k1) + temp4b7
   qzb(i, j, k1) = qzb(i, j, k1) + temp4b7
   qzb(i-1, j, k2) = qzb(i-1, j, k2) + temp4b7
   qzb(i, j, k2) = qzb(i, j, k2) + temp4b7
   CALL POPREAL8(q_y)
   temp4b8 = fourth*q_yb
   qyb(i-1, j, k1) = qyb(i-1, j, k1) + temp4b8
   qyb(i, j, k1) = qyb(i, j, k1) + temp4b8
   qyb(i-1, j, k2) = qyb(i-1, j, k2) + temp4b8
   qyb(i, j, k2) = qyb(i, j, k2) + temp4b8
   CALL POPREAL8(q_x)
   temp4b9 = fourth*q_xb
   qxb(i-1, j, k1) = qxb(i-1, j, k1) + temp4b9
   qxb(i, j, k1) = qxb(i, j, k1) + temp4b9
   qxb(i-1, j, k2) = qxb(i-1, j, k2) + temp4b9
   qxb(i, j, k2) = qxb(i, j, k2) + temp4b9
   CALL POPREAL8(w_z)
   temp4b10 = fourth*w_zb
   wzb(i-1, j, k1) = wzb(i-1, j, k1) + temp4b10
   wzb(i, j, k1) = wzb(i, j, k1) + temp4b10
   wzb(i-1, j, k2) = wzb(i-1, j, k2) + temp4b10
   wzb(i, j, k2) = wzb(i, j, k2) + temp4b10
   CALL POPREAL8(w_y)
   temp4b11 = fourth*w_yb
   wyb(i-1, j, k1) = wyb(i-1, j, k1) + temp4b11
   wyb(i, j, k1) = wyb(i, j, k1) + temp4b11
   wyb(i-1, j, k2) = wyb(i-1, j, k2) + temp4b11
   wyb(i, j, k2) = wyb(i, j, k2) + temp4b11
   CALL POPREAL8(w_x)
   temp4b12 = fourth*w_xb
   wxb(i-1, j, k1) = wxb(i-1, j, k1) + temp4b12
   wxb(i, j, k1) = wxb(i, j, k1) + temp4b12
   wxb(i-1, j, k2) = wxb(i-1, j, k2) + temp4b12
   wxb(i, j, k2) = wxb(i, j, k2) + temp4b12
   CALL POPREAL8(v_z)
   temp4b13 = fourth*v_zb
   vzb(i-1, j, k1) = vzb(i-1, j, k1) + temp4b13
   vzb(i, j, k1) = vzb(i, j, k1) + temp4b13
   vzb(i-1, j, k2) = vzb(i-1, j, k2) + temp4b13
   vzb(i, j, k2) = vzb(i, j, k2) + temp4b13
   CALL POPREAL8(v_y)
   temp4b14 = fourth*v_yb
   vyb(i-1, j, k1) = vyb(i-1, j, k1) + temp4b14
   vyb(i, j, k1) = vyb(i, j, k1) + temp4b14
   vyb(i-1, j, k2) = vyb(i-1, j, k2) + temp4b14
   vyb(i, j, k2) = vyb(i, j, k2) + temp4b14
   CALL POPREAL8(v_x)
   temp4b15 = fourth*v_xb
   vxb(i-1, j, k1) = vxb(i-1, j, k1) + temp4b15
   vxb(i, j, k1) = vxb(i, j, k1) + temp4b15
   vxb(i-1, j, k2) = vxb(i-1, j, k2) + temp4b15
   vxb(i, j, k2) = vxb(i, j, k2) + temp4b15
   CALL POPREAL8(u_z)
   temp4b16 = fourth*u_zb
   uzb(i-1, j, k1) = uzb(i-1, j, k1) + temp4b16
   uzb(i, j, k1) = uzb(i, j, k1) + temp4b16
   uzb(i-1, j, k2) = uzb(i-1, j, k2) + temp4b16
   uzb(i, j, k2) = uzb(i, j, k2) + temp4b16
   CALL POPREAL8(u_y)
   temp4b17 = fourth*u_yb
   uyb(i-1, j, k1) = uyb(i-1, j, k1) + temp4b17
   uyb(i, j, k1) = uyb(i, j, k1) + temp4b17
   uyb(i-1, j, k2) = uyb(i-1, j, k2) + temp4b17
   uyb(i, j, k2) = uyb(i, j, k2) + temp4b17
   CALL POPREAL8(u_x)
   temp4b18 = fourth*u_xb
   uxb(i-1, j, k1) = uxb(i-1, j, k1) + temp4b18
   uxb(i, j, k1) = uxb(i, j, k1) + temp4b18
   uxb(i-1, j, k2) = uxb(i-1, j, k2) + temp4b18
   uxb(i, j, k2) = uxb(i, j, k2) + temp4b18
   gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL POPREAL8(heatcoef)
   mulb = mutb + factlamheat*heatcoefb
   mueb = mueb + mutb + factturbheat*heatcoefb
   CALL POPREAL8(mut)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   revb(i, j, k) = revb(i, j, k) + por*mueb
   revb(i, j+1, k) = revb(i, j+1, k) + por*mueb
   mueb = 0.0_8
   END IF
   rlvb(i, j, k) = rlvb(i, j, k) + por*mulb
   rlvb(i, j+1, k) = rlvb(i, j+1, k) + por*mulb
   CALL POPREAL8(por)
   END DO
   END DO
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tauzzb = 0.0_8
   tauxxb = 0.0_8
   tauxyb = 0.0_8
   tauxzb = 0.0_8
   tauyyb = 0.0_8
   tauyzb = 0.0_8
   ELSE
   tauyz = mut*(v_z+w_y)
   tauyzb = viscsubfaceb(nn)%tau(i, j, 6)
   viscsubfaceb(nn)%tau(i, j, 6) = 0.0_8
   tauxz = mut*(u_z+w_x)
   tauxzb = viscsubfaceb(nn)%tau(i, j, 5)
   viscsubfaceb(nn)%tau(i, j, 5) = 0.0_8
   tauxy = mut*(u_y+v_x)
   tauxyb = viscsubfaceb(nn)%tau(i, j, 4)
   viscsubfaceb(nn)%tau(i, j, 4) = 0.0_8
   tauzz = mut*(two*w_z-fracdiv)
   tauzzb = viscsubfaceb(nn)%tau(i, j, 3)
   viscsubfaceb(nn)%tau(i, j, 3) = 0.0_8
   tauyy = mut*(two*v_y-fracdiv)
   tauyyb = viscsubfaceb(nn)%tau(i, j, 2)
   viscsubfaceb(nn)%tau(i, j, 2) = 0.0_8
   tauxx = mut*(two*u_x-fracdiv)
   tauxxb = viscsubfaceb(nn)%tau(i, j, 1)
   viscsubfaceb(nn)%tau(i, j, 1) = 0.0_8
   END IF
   frhoeb = fwb(i, j, k+1, irhoe) - fwb(i, j, k, irhoe)
   fmzb = fwb(i, j, k+1, imz) - fwb(i, j, k, imz)
   fmyb = fwb(i, j, k+1, imy) - fwb(i, j, k, imy)
   fmxb = fwb(i, j, k+1, imx) - fwb(i, j, k, imx)
   wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
   vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
   ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
   temp4b = sk(i, j, k, 1)*frhoeb
   temp4b0 = sk(i, j, k, 2)*frhoeb
   temp4b1 = sk(i, j, k, 3)*frhoeb
   ubarb = tauxz*temp4b1 + tauxy*temp4b0 + tauxx*temp4b
   tauxxb = tauxxb + sk(i, j, k, 1)*fmxb + ubar*temp4b
   vbarb = tauyz*temp4b1 + tauyy*temp4b0 + tauxy*temp4b
   tauxyb = tauxyb + sk(i, j, k, 1)*fmyb + sk(i, j, k, 2)*fmxb + &
   &            ubar*temp4b0 + vbar*temp4b
   wbarb = tauzz*temp4b1 + tauyz*temp4b0 + tauxz*temp4b
   tauxzb = tauxzb + sk(i, j, k, 1)*fmzb + sk(i, j, k, 3)*fmxb + &
   &            ubar*temp4b1 + wbar*temp4b
   skb(i, j, k, 1) = skb(i, j, k, 1) + (ubar*tauxx-q_x+vbar*tauxy&
   &            +wbar*tauxz)*frhoeb
   tauyyb = tauyyb + sk(i, j, k, 2)*fmyb + vbar*temp4b0
   tauyzb = tauyzb + sk(i, j, k, 2)*fmzb + sk(i, j, k, 3)*fmyb + &
   &            vbar*temp4b1 + wbar*temp4b0
   skb(i, j, k, 2) = skb(i, j, k, 2) + (ubar*tauxy-q_y+vbar*tauyy&
   &            +wbar*tauyz)*frhoeb
   tauzzb = tauzzb + sk(i, j, k, 3)*fmzb + wbar*temp4b1
   skb(i, j, k, 3) = skb(i, j, k, 3) + (ubar*tauxz-q_z+vbar*tauyz&
   &            +wbar*tauzz)*frhoeb
   q_xb = -(sk(i, j, k, 1)*frhoeb)
   q_yb = -(sk(i, j, k, 2)*frhoeb)
   q_zb = -(sk(i, j, k, 3)*frhoeb)
   skb(i, j, k, 1) = skb(i, j, k, 1) + tauxz*fmzb
   skb(i, j, k, 2) = skb(i, j, k, 2) + tauyz*fmzb
   skb(i, j, k, 3) = skb(i, j, k, 3) + tauzz*fmzb
   skb(i, j, k, 1) = skb(i, j, k, 1) + tauxy*fmyb
   skb(i, j, k, 2) = skb(i, j, k, 2) + tauyy*fmyb
   skb(i, j, k, 3) = skb(i, j, k, 3) + tauyz*fmyb
   skb(i, j, k, 1) = skb(i, j, k, 1) + tauxx*fmxb
   skb(i, j, k, 2) = skb(i, j, k, 2) + tauxy*fmxb
   skb(i, j, k, 3) = skb(i, j, k, 3) + tauxz*fmxb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + half*wbarb
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + half*wbarb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + half*vbarb
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + half*vbarb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + half*ubarb
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + half*ubarb
   CALL POPREAL8(q_z)
   CALL POPREAL8(q_y)
   CALL POPREAL8(q_x)
   heatcoefb = q_y*q_yb + q_x*q_xb + q_z*q_zb
   q_zb = heatcoef*q_zb
   q_yb = heatcoef*q_yb
   q_xb = heatcoef*q_xb
   CALL POPREAL8(tauyz)
   mutb = (u_z+w_x)*tauxzb + (two*w_z-fracdiv)*tauzzb + (two*u_x-&
   &            fracdiv)*tauxxb + (two*v_y-fracdiv)*tauyyb + (u_y+v_x)*&
   &            tauxyb + (v_z+w_y)*tauyzb
   v_zb = mut*tauyzb
   w_yb = mut*tauyzb
   CALL POPREAL8(tauxz)
   u_zb = mut*tauxzb
   w_xb = mut*tauxzb
   CALL POPREAL8(tauxy)
   u_yb = mut*tauxyb
   v_xb = mut*tauxyb
   CALL POPREAL8(tauzz)
   fracdivb = -(mut*tauyyb) - mut*tauxxb - mut*tauzzb
   CALL POPREAL8(tauyy)
   CALL POPREAL8(tauxx)
   CALL POPREAL8(fracdiv)
   temp4b2 = twothird*fracdivb
   w_zb = temp4b2 + mut*two*tauzzb
   v_yb = temp4b2 + mut*two*tauyyb
   u_xb = temp4b2 + mut*two*tauxxb
   CALL POPREAL8(q_z)
   corrb = -(ssy*q_yb) - ssx*q_xb - ssz*q_zb
   sszb = q_z*corrb - corr*q_zb
   CALL POPREAL8(q_y)
   ssyb = q_y*corrb - corr*q_yb
   CALL POPREAL8(q_x)
   ssxb = q_x*corrb - corr*q_xb
   CALL POPREAL8(corr)
   q_xb = q_xb + ssx*corrb
   q_yb = q_yb + ssy*corrb
   q_zb = q_zb + ssz*corrb
   pb(i, j, k+1) = pb(i, j, k+1) + ss*corrb
   pb(i, j, k) = pb(i, j, k) - ss*corrb
   ssb = (p(i, j, k+1)-p(i, j, k))*corrb
   CALL POPREAL8(w_z)
   corrb = -(ssy*w_yb) - ssx*w_xb - ssz*w_zb
   sszb = sszb + w_z*corrb - corr*w_zb
   CALL POPREAL8(w_y)
   ssyb = ssyb + w_y*corrb - corr*w_yb
   CALL POPREAL8(w_x)
   ssxb = ssxb + w_x*corrb - corr*w_xb
   CALL POPREAL8(corr)
   w_xb = w_xb + ssx*corrb
   w_yb = w_yb + ssy*corrb
   w_zb = w_zb + ssz*corrb
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) - ss*corrb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + ss*corrb
   ssb = ssb - (w(i, j, k+1, ivz)-w(i, j, k, ivz))*corrb
   CALL POPREAL8(v_z)
   corrb = -(ssy*v_yb) - ssx*v_xb - ssz*v_zb
   sszb = sszb + v_z*corrb - corr*v_zb
   CALL POPREAL8(v_y)
   ssyb = ssyb + v_y*corrb - corr*v_yb
   CALL POPREAL8(v_x)
   ssxb = ssxb + v_x*corrb - corr*v_xb
   CALL POPREAL8(corr)
   v_xb = v_xb + ssx*corrb
   v_yb = v_yb + ssy*corrb
   v_zb = v_zb + ssz*corrb
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) - ss*corrb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + ss*corrb
   ssb = ssb - (w(i, j, k+1, ivy)-w(i, j, k, ivy))*corrb
   CALL POPREAL8(u_z)
   corrb = -(ssy*u_yb) - ssx*u_xb - ssz*u_zb
   sszb = sszb + u_z*corrb - corr*u_zb
   CALL POPREAL8(u_y)
   ssyb = ssyb + u_y*corrb - corr*u_yb
   CALL POPREAL8(u_x)
   ssxb = ssxb + u_x*corrb - corr*u_xb
   CALL POPREAL8(corr)
   u_xb = u_xb + ssx*corrb
   u_yb = u_yb + ssy*corrb
   u_zb = u_zb + ssz*corrb
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) - ss*corrb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + ss*corrb
   CALL POPREAL8(ssz)
   CALL POPREAL8(ssy)
   CALL POPREAL8(ssx)
   ssb = ssb + ssz*sszb + ssx*ssxb + ssy*ssyb - (w(i, j, k+1, ivx&
   &            )-w(i, j, k, ivx))*corrb
   temp2 = ssx**2 + ssy**2 + ssz**2
   temp3 = SQRT(temp2)
   IF (temp2 .EQ. 0.0) THEN
   temp2b3 = 0.0
   ELSE
   temp2b3 = -(one*ssb/(temp3**3*2.0))
   END IF
   sszb = 2*ssz*temp2b3 + ss*sszb
   ssyb = 2*ssy*temp2b3 + ss*ssyb
   ssxb = 2*ssx*temp2b3 + ss*ssxb
   CALL POPREAL8(ss)
   CALL POPREAL8(ssz)
   temp2b4 = eighth*sszb
   xb(i-1, j-1, k+1, 3) = xb(i-1, j-1, k+1, 3) + temp2b4
   xb(i-1, j-1, k-1, 3) = xb(i-1, j-1, k-1, 3) - temp2b4
   xb(i-1, j, k+1, 3) = xb(i-1, j, k+1, 3) + temp2b4
   xb(i-1, j, k-1, 3) = xb(i-1, j, k-1, 3) - temp2b4
   xb(i, j-1, k+1, 3) = xb(i, j-1, k+1, 3) + temp2b4
   xb(i, j-1, k-1, 3) = xb(i, j-1, k-1, 3) - temp2b4
   xb(i, j, k+1, 3) = xb(i, j, k+1, 3) + temp2b4
   xb(i, j, k-1, 3) = xb(i, j, k-1, 3) - temp2b4
   CALL POPREAL8(ssy)
   temp2b5 = eighth*ssyb
   xb(i-1, j-1, k+1, 2) = xb(i-1, j-1, k+1, 2) + temp2b5
   xb(i-1, j-1, k-1, 2) = xb(i-1, j-1, k-1, 2) - temp2b5
   xb(i-1, j, k+1, 2) = xb(i-1, j, k+1, 2) + temp2b5
   xb(i-1, j, k-1, 2) = xb(i-1, j, k-1, 2) - temp2b5
   xb(i, j-1, k+1, 2) = xb(i, j-1, k+1, 2) + temp2b5
   xb(i, j-1, k-1, 2) = xb(i, j-1, k-1, 2) - temp2b5
   xb(i, j, k+1, 2) = xb(i, j, k+1, 2) + temp2b5
   xb(i, j, k-1, 2) = xb(i, j, k-1, 2) - temp2b5
   CALL POPREAL8(ssx)
   temp2b6 = eighth*ssxb
   xb(i-1, j-1, k+1, 1) = xb(i-1, j-1, k+1, 1) + temp2b6
   xb(i-1, j-1, k-1, 1) = xb(i-1, j-1, k-1, 1) - temp2b6
   xb(i-1, j, k+1, 1) = xb(i-1, j, k+1, 1) + temp2b6
   xb(i-1, j, k-1, 1) = xb(i-1, j, k-1, 1) - temp2b6
   xb(i, j-1, k+1, 1) = xb(i, j-1, k+1, 1) + temp2b6
   xb(i, j-1, k-1, 1) = xb(i, j-1, k-1, 1) - temp2b6
   xb(i, j, k+1, 1) = xb(i, j, k+1, 1) + temp2b6
   xb(i, j, k-1, 1) = xb(i, j, k-1, 1) - temp2b6
   CALL POPREAL8(q_z)
   temp2b7 = fourth*q_zb
   qzb(i-1, j-1, k1) = qzb(i-1, j-1, k1) + temp2b7
   qzb(i, j-1, k1) = qzb(i, j-1, k1) + temp2b7
   qzb(i-1, j, k1) = qzb(i-1, j, k1) + temp2b7
   qzb(i, j, k1) = qzb(i, j, k1) + temp2b7
   CALL POPREAL8(q_y)
   temp2b8 = fourth*q_yb
   qyb(i-1, j-1, k1) = qyb(i-1, j-1, k1) + temp2b8
   qyb(i, j-1, k1) = qyb(i, j-1, k1) + temp2b8
   qyb(i-1, j, k1) = qyb(i-1, j, k1) + temp2b8
   qyb(i, j, k1) = qyb(i, j, k1) + temp2b8
   CALL POPREAL8(q_x)
   temp2b9 = fourth*q_xb
   qxb(i-1, j-1, k1) = qxb(i-1, j-1, k1) + temp2b9
   qxb(i, j-1, k1) = qxb(i, j-1, k1) + temp2b9
   qxb(i-1, j, k1) = qxb(i-1, j, k1) + temp2b9
   qxb(i, j, k1) = qxb(i, j, k1) + temp2b9
   CALL POPREAL8(w_z)
   temp2b10 = fourth*w_zb
   wzb(i-1, j-1, k1) = wzb(i-1, j-1, k1) + temp2b10
   wzb(i, j-1, k1) = wzb(i, j-1, k1) + temp2b10
   wzb(i-1, j, k1) = wzb(i-1, j, k1) + temp2b10
   wzb(i, j, k1) = wzb(i, j, k1) + temp2b10
   CALL POPREAL8(w_y)
   temp2b11 = fourth*w_yb
   wyb(i-1, j-1, k1) = wyb(i-1, j-1, k1) + temp2b11
   wyb(i, j-1, k1) = wyb(i, j-1, k1) + temp2b11
   wyb(i-1, j, k1) = wyb(i-1, j, k1) + temp2b11
   wyb(i, j, k1) = wyb(i, j, k1) + temp2b11
   CALL POPREAL8(w_x)
   temp2b12 = fourth*w_xb
   wxb(i-1, j-1, k1) = wxb(i-1, j-1, k1) + temp2b12
   wxb(i, j-1, k1) = wxb(i, j-1, k1) + temp2b12
   wxb(i-1, j, k1) = wxb(i-1, j, k1) + temp2b12
   wxb(i, j, k1) = wxb(i, j, k1) + temp2b12
   CALL POPREAL8(v_z)
   temp2b13 = fourth*v_zb
   vzb(i-1, j-1, k1) = vzb(i-1, j-1, k1) + temp2b13
   vzb(i, j-1, k1) = vzb(i, j-1, k1) + temp2b13
   vzb(i-1, j, k1) = vzb(i-1, j, k1) + temp2b13
   vzb(i, j, k1) = vzb(i, j, k1) + temp2b13
   CALL POPREAL8(v_y)
   temp2b14 = fourth*v_yb
   vyb(i-1, j-1, k1) = vyb(i-1, j-1, k1) + temp2b14
   vyb(i, j-1, k1) = vyb(i, j-1, k1) + temp2b14
   vyb(i-1, j, k1) = vyb(i-1, j, k1) + temp2b14
   vyb(i, j, k1) = vyb(i, j, k1) + temp2b14
   CALL POPREAL8(v_x)
   temp2b15 = fourth*v_xb
   vxb(i-1, j-1, k1) = vxb(i-1, j-1, k1) + temp2b15
   vxb(i, j-1, k1) = vxb(i, j-1, k1) + temp2b15
   vxb(i-1, j, k1) = vxb(i-1, j, k1) + temp2b15
   vxb(i, j, k1) = vxb(i, j, k1) + temp2b15
   CALL POPREAL8(u_z)
   temp2b16 = fourth*u_zb
   uzb(i-1, j-1, k1) = uzb(i-1, j-1, k1) + temp2b16
   uzb(i, j-1, k1) = uzb(i, j-1, k1) + temp2b16
   uzb(i-1, j, k1) = uzb(i-1, j, k1) + temp2b16
   uzb(i, j, k1) = uzb(i, j, k1) + temp2b16
   CALL POPREAL8(u_y)
   temp2b17 = fourth*u_yb
   uyb(i-1, j-1, k1) = uyb(i-1, j-1, k1) + temp2b17
   uyb(i, j-1, k1) = uyb(i, j-1, k1) + temp2b17
   uyb(i-1, j, k1) = uyb(i-1, j, k1) + temp2b17
   uyb(i, j, k1) = uyb(i, j, k1) + temp2b17
   CALL POPREAL8(u_x)
   temp2b18 = fourth*u_xb
   uxb(i-1, j-1, k1) = uxb(i-1, j-1, k1) + temp2b18
   uxb(i, j-1, k1) = uxb(i, j-1, k1) + temp2b18
   uxb(i-1, j, k1) = uxb(i-1, j, k1) + temp2b18
   uxb(i, j, k1) = uxb(i, j, k1) + temp2b18
   gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL POPREAL8(heatcoef)
   mulb = mutb + factlamheat*heatcoefb
   mueb = mueb + mutb + factturbheat*heatcoefb
   CALL POPREAL8(mut)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   revb(i, j, k) = revb(i, j, k) + por*mueb
   revb(i, j, k+1) = revb(i, j, k+1) + por*mueb
   mueb = 0.0_8
   END IF
   rlvb(i, j, k) = rlvb(i, j, k) + por*mulb
   rlvb(i, j, k+1) = rlvb(i, j, k+1) + por*mulb
   CALL POPREAL8(por)
   END DO
   END DO
   CALL POPREAL8ARRAY(ux, il*jl*2)
   CALL POPREAL8ARRAY(uy, il*jl*2)
   CALL POPREAL8ARRAY(uz, il*jl*2)
   CALL POPREAL8ARRAY(vx, il*jl*2)
   CALL POPREAL8ARRAY(vy, il*jl*2)
   CALL POPREAL8ARRAY(vz, il*jl*2)
   CALL POPREAL8ARRAY(wx, il*jl*2)
   CALL POPREAL8ARRAY(wy, il*jl*2)
   CALL POPREAL8ARRAY(wz, il*jl*2)
   CALL POPREAL8ARRAY(qx, il*jl*2)
   CALL POPREAL8ARRAY(qy, il*jl*2)
   CALL POPREAL8ARRAY(qz, il*jl*2)
   CALL NODALGRADIENTS_B(ux, uxb, uy, uyb, uz, uzb, vx, vxb, vy, vyb&
   &                      , vz, vzb, wx, wxb, wy, wyb, wz, wzb, qx, qxb, qy&
   &                      , qyb, qz, qzb)
   CALL POPINTEGER4(k2)
   CALL POPINTEGER4(k1)
   END DO
   CALL POPINTEGER4(k)
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   tauzzb = 0.0_8
   tauxxb = 0.0_8
   tauxyb = 0.0_8
   tauxzb = 0.0_8
   tauyyb = 0.0_8
   tauyzb = 0.0_8
   ELSE
   tauyz = mut*(v_z+w_y)
   tauyzb = viscsubfaceb(nn)%tau(i, j, 6)
   viscsubfaceb(nn)%tau(i, j, 6) = 0.0_8
   tauxz = mut*(u_z+w_x)
   tauxzb = viscsubfaceb(nn)%tau(i, j, 5)
   viscsubfaceb(nn)%tau(i, j, 5) = 0.0_8
   tauxy = mut*(u_y+v_x)
   tauxyb = viscsubfaceb(nn)%tau(i, j, 4)
   viscsubfaceb(nn)%tau(i, j, 4) = 0.0_8
   tauzz = mut*(two*w_z-fracdiv)
   tauzzb = viscsubfaceb(nn)%tau(i, j, 3)
   viscsubfaceb(nn)%tau(i, j, 3) = 0.0_8
   tauyy = mut*(two*v_y-fracdiv)
   tauyyb = viscsubfaceb(nn)%tau(i, j, 2)
   viscsubfaceb(nn)%tau(i, j, 2) = 0.0_8
   tauxx = mut*(two*u_x-fracdiv)
   tauxxb = viscsubfaceb(nn)%tau(i, j, 1)
   viscsubfaceb(nn)%tau(i, j, 1) = 0.0_8
   END IF
   frhoeb = fwb(i, j, 2, irhoe)
   fmzb = fwb(i, j, 2, imz)
   fmyb = fwb(i, j, 2, imy)
   fmxb = fwb(i, j, 2, imx)
   wbar = half*(w(i, j, 1, ivz)+w(i, j, 2, ivz))
   vbar = half*(w(i, j, 1, ivy)+w(i, j, 2, ivy))
   ubar = half*(w(i, j, 1, ivx)+w(i, j, 2, ivx))
   temp2b = sk(i, j, 1, 1)*frhoeb
   temp2b0 = sk(i, j, 1, 2)*frhoeb
   temp2b1 = sk(i, j, 1, 3)*frhoeb
   ubarb = tauxz*temp2b1 + tauxy*temp2b0 + tauxx*temp2b
   tauxxb = tauxxb + sk(i, j, 1, 1)*fmxb + ubar*temp2b
   vbarb = tauyz*temp2b1 + tauyy*temp2b0 + tauxy*temp2b
   tauxyb = tauxyb + sk(i, j, 1, 1)*fmyb + sk(i, j, 1, 2)*fmxb + &
   &          ubar*temp2b0 + vbar*temp2b
   wbarb = tauzz*temp2b1 + tauyz*temp2b0 + tauxz*temp2b
   tauxzb = tauxzb + sk(i, j, 1, 1)*fmzb + sk(i, j, 1, 3)*fmxb + &
   &          ubar*temp2b1 + wbar*temp2b
   skb(i, j, 1, 1) = skb(i, j, 1, 1) + (ubar*tauxx-q_x+vbar*tauxy+&
   &          wbar*tauxz)*frhoeb
   tauyyb = tauyyb + sk(i, j, 1, 2)*fmyb + vbar*temp2b0
   tauyzb = tauyzb + sk(i, j, 1, 2)*fmzb + sk(i, j, 1, 3)*fmyb + &
   &          vbar*temp2b1 + wbar*temp2b0
   skb(i, j, 1, 2) = skb(i, j, 1, 2) + (ubar*tauxy-q_y+vbar*tauyy+&
   &          wbar*tauyz)*frhoeb
   tauzzb = tauzzb + sk(i, j, 1, 3)*fmzb + wbar*temp2b1
   skb(i, j, 1, 3) = skb(i, j, 1, 3) + (ubar*tauxz-q_z+vbar*tauyz+&
   &          wbar*tauzz)*frhoeb
   q_xb = -(sk(i, j, 1, 1)*frhoeb)
   q_yb = -(sk(i, j, 1, 2)*frhoeb)
   q_zb = -(sk(i, j, 1, 3)*frhoeb)
   skb(i, j, 1, 1) = skb(i, j, 1, 1) + tauxz*fmzb
   skb(i, j, 1, 2) = skb(i, j, 1, 2) + tauyz*fmzb
   skb(i, j, 1, 3) = skb(i, j, 1, 3) + tauzz*fmzb
   skb(i, j, 1, 1) = skb(i, j, 1, 1) + tauxy*fmyb
   skb(i, j, 1, 2) = skb(i, j, 1, 2) + tauyy*fmyb
   skb(i, j, 1, 3) = skb(i, j, 1, 3) + tauyz*fmyb
   skb(i, j, 1, 1) = skb(i, j, 1, 1) + tauxx*fmxb
   skb(i, j, 1, 2) = skb(i, j, 1, 2) + tauxy*fmxb
   skb(i, j, 1, 3) = skb(i, j, 1, 3) + tauxz*fmxb
   wb(i, j, 1, ivz) = wb(i, j, 1, ivz) + half*wbarb
   wb(i, j, 2, ivz) = wb(i, j, 2, ivz) + half*wbarb
   wb(i, j, 1, ivy) = wb(i, j, 1, ivy) + half*vbarb
   wb(i, j, 2, ivy) = wb(i, j, 2, ivy) + half*vbarb
   wb(i, j, 1, ivx) = wb(i, j, 1, ivx) + half*ubarb
   wb(i, j, 2, ivx) = wb(i, j, 2, ivx) + half*ubarb
   CALL POPREAL8(q_z)
   CALL POPREAL8(q_y)
   CALL POPREAL8(q_x)
   heatcoefb = q_y*q_yb + q_x*q_xb + q_z*q_zb
   q_zb = heatcoef*q_zb
   q_yb = heatcoef*q_yb
   q_xb = heatcoef*q_xb
   CALL POPREAL8(tauyz)
   mutb = (u_z+w_x)*tauxzb + (two*w_z-fracdiv)*tauzzb + (two*u_x-&
   &          fracdiv)*tauxxb + (two*v_y-fracdiv)*tauyyb + (u_y+v_x)*tauxyb &
   &          + (v_z+w_y)*tauyzb
   v_zb = mut*tauyzb
   w_yb = mut*tauyzb
   CALL POPREAL8(tauxz)
   u_zb = mut*tauxzb
   w_xb = mut*tauxzb
   CALL POPREAL8(tauxy)
   u_yb = mut*tauxyb
   v_xb = mut*tauxyb
   CALL POPREAL8(tauzz)
   fracdivb = -(mut*tauyyb) - mut*tauxxb - mut*tauzzb
   CALL POPREAL8(tauyy)
   CALL POPREAL8(tauxx)
   CALL POPREAL8(fracdiv)
   temp2b2 = twothird*fracdivb
   w_zb = temp2b2 + mut*two*tauzzb
   v_yb = temp2b2 + mut*two*tauyyb
   u_xb = temp2b2 + mut*two*tauxxb
   CALL POPREAL8(q_z)
   corrb = -(ssy*q_yb) - ssx*q_xb - ssz*q_zb
   sszb = q_z*corrb - corr*q_zb
   CALL POPREAL8(q_y)
   ssyb = q_y*corrb - corr*q_yb
   CALL POPREAL8(q_x)
   ssxb = q_x*corrb - corr*q_xb
   CALL POPREAL8(corr)
   q_xb = q_xb + ssx*corrb
   q_yb = q_yb + ssy*corrb
   q_zb = q_zb + ssz*corrb
   pb(i, j, k+1) = pb(i, j, k+1) + ss*corrb
   pb(i, j, k) = pb(i, j, k) - ss*corrb
   ssb = (p(i, j, k+1)-p(i, j, k))*corrb
   CALL POPREAL8(w_z)
   corrb = -(ssy*w_yb) - ssx*w_xb - ssz*w_zb
   sszb = sszb + w_z*corrb - corr*w_zb
   CALL POPREAL8(w_y)
   ssyb = ssyb + w_y*corrb - corr*w_yb
   CALL POPREAL8(w_x)
   ssxb = ssxb + w_x*corrb - corr*w_xb
   CALL POPREAL8(corr)
   w_xb = w_xb + ssx*corrb
   w_yb = w_yb + ssy*corrb
   w_zb = w_zb + ssz*corrb
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) - ss*corrb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + ss*corrb
   ssb = ssb - (w(i, j, k+1, ivz)-w(i, j, k, ivz))*corrb
   CALL POPREAL8(v_z)
   corrb = -(ssy*v_yb) - ssx*v_xb - ssz*v_zb
   sszb = sszb + v_z*corrb - corr*v_zb
   CALL POPREAL8(v_y)
   ssyb = ssyb + v_y*corrb - corr*v_yb
   CALL POPREAL8(v_x)
   ssxb = ssxb + v_x*corrb - corr*v_xb
   CALL POPREAL8(corr)
   v_xb = v_xb + ssx*corrb
   v_yb = v_yb + ssy*corrb
   v_zb = v_zb + ssz*corrb
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) - ss*corrb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + ss*corrb
   ssb = ssb - (w(i, j, k+1, ivy)-w(i, j, k, ivy))*corrb
   CALL POPREAL8(u_z)
   corrb = -(ssy*u_yb) - ssx*u_xb - ssz*u_zb
   sszb = sszb + u_z*corrb - corr*u_zb
   CALL POPREAL8(u_y)
   ssyb = ssyb + u_y*corrb - corr*u_yb
   CALL POPREAL8(u_x)
   ssxb = ssxb + u_x*corrb - corr*u_xb
   CALL POPREAL8(corr)
   u_xb = u_xb + ssx*corrb
   u_yb = u_yb + ssy*corrb
   u_zb = u_zb + ssz*corrb
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) - ss*corrb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + ss*corrb
   CALL POPREAL8(ssz)
   CALL POPREAL8(ssy)
   CALL POPREAL8(ssx)
   ssb = ssb + ssz*sszb + ssx*ssxb + ssy*ssyb - (w(i, j, k+1, ivx)-&
   &          w(i, j, k, ivx))*corrb
   temp0 = ssx**2 + ssy**2 + ssz**2
   temp1 = SQRT(temp0)
   IF (temp0 .EQ. 0.0) THEN
   temp0b = 0.0
   ELSE
   temp0b = -(one*ssb/(temp1**3*2.0))
   END IF
   sszb = 2*ssz*temp0b + ss*sszb
   ssyb = 2*ssy*temp0b + ss*ssyb
   ssxb = 2*ssx*temp0b + ss*ssxb
   CALL POPREAL8(ss)
   CALL POPREAL8(ssz)
   temp0b0 = eighth*sszb
   xb(i-1, j-1, k+1, 3) = xb(i-1, j-1, k+1, 3) + temp0b0
   xb(i-1, j-1, k-1, 3) = xb(i-1, j-1, k-1, 3) - temp0b0
   xb(i-1, j, k+1, 3) = xb(i-1, j, k+1, 3) + temp0b0
   xb(i-1, j, k-1, 3) = xb(i-1, j, k-1, 3) - temp0b0
   xb(i, j-1, k+1, 3) = xb(i, j-1, k+1, 3) + temp0b0
   xb(i, j-1, k-1, 3) = xb(i, j-1, k-1, 3) - temp0b0
   xb(i, j, k+1, 3) = xb(i, j, k+1, 3) + temp0b0
   xb(i, j, k-1, 3) = xb(i, j, k-1, 3) - temp0b0
   CALL POPREAL8(ssy)
   temp0b1 = eighth*ssyb
   xb(i-1, j-1, k+1, 2) = xb(i-1, j-1, k+1, 2) + temp0b1
   xb(i-1, j-1, k-1, 2) = xb(i-1, j-1, k-1, 2) - temp0b1
   xb(i-1, j, k+1, 2) = xb(i-1, j, k+1, 2) + temp0b1
   xb(i-1, j, k-1, 2) = xb(i-1, j, k-1, 2) - temp0b1
   xb(i, j-1, k+1, 2) = xb(i, j-1, k+1, 2) + temp0b1
   xb(i, j-1, k-1, 2) = xb(i, j-1, k-1, 2) - temp0b1
   xb(i, j, k+1, 2) = xb(i, j, k+1, 2) + temp0b1
   xb(i, j, k-1, 2) = xb(i, j, k-1, 2) - temp0b1
   CALL POPREAL8(ssx)
   temp0b2 = eighth*ssxb
   xb(i-1, j-1, k+1, 1) = xb(i-1, j-1, k+1, 1) + temp0b2
   xb(i-1, j-1, k-1, 1) = xb(i-1, j-1, k-1, 1) - temp0b2
   xb(i-1, j, k+1, 1) = xb(i-1, j, k+1, 1) + temp0b2
   xb(i-1, j, k-1, 1) = xb(i-1, j, k-1, 1) - temp0b2
   xb(i, j-1, k+1, 1) = xb(i, j-1, k+1, 1) + temp0b2
   xb(i, j-1, k-1, 1) = xb(i, j-1, k-1, 1) - temp0b2
   xb(i, j, k+1, 1) = xb(i, j, k+1, 1) + temp0b2
   xb(i, j, k-1, 1) = xb(i, j, k-1, 1) - temp0b2
   CALL POPREAL8(q_z)
   temp0b3 = fourth*q_zb
   qzb(i-1, j-1, k1) = qzb(i-1, j-1, k1) + temp0b3
   qzb(i, j-1, k1) = qzb(i, j-1, k1) + temp0b3
   qzb(i-1, j, k1) = qzb(i-1, j, k1) + temp0b3
   qzb(i, j, k1) = qzb(i, j, k1) + temp0b3
   CALL POPREAL8(q_y)
   temp0b4 = fourth*q_yb
   qyb(i-1, j-1, k1) = qyb(i-1, j-1, k1) + temp0b4
   qyb(i, j-1, k1) = qyb(i, j-1, k1) + temp0b4
   qyb(i-1, j, k1) = qyb(i-1, j, k1) + temp0b4
   qyb(i, j, k1) = qyb(i, j, k1) + temp0b4
   CALL POPREAL8(q_x)
   temp0b5 = fourth*q_xb
   qxb(i-1, j-1, k1) = qxb(i-1, j-1, k1) + temp0b5
   qxb(i, j-1, k1) = qxb(i, j-1, k1) + temp0b5
   qxb(i-1, j, k1) = qxb(i-1, j, k1) + temp0b5
   qxb(i, j, k1) = qxb(i, j, k1) + temp0b5
   CALL POPREAL8(w_z)
   temp0b6 = fourth*w_zb
   wzb(i-1, j-1, k1) = wzb(i-1, j-1, k1) + temp0b6
   wzb(i, j-1, k1) = wzb(i, j-1, k1) + temp0b6
   wzb(i-1, j, k1) = wzb(i-1, j, k1) + temp0b6
   wzb(i, j, k1) = wzb(i, j, k1) + temp0b6
   CALL POPREAL8(w_y)
   temp0b7 = fourth*w_yb
   wyb(i-1, j-1, k1) = wyb(i-1, j-1, k1) + temp0b7
   wyb(i, j-1, k1) = wyb(i, j-1, k1) + temp0b7
   wyb(i-1, j, k1) = wyb(i-1, j, k1) + temp0b7
   wyb(i, j, k1) = wyb(i, j, k1) + temp0b7
   CALL POPREAL8(w_x)
   temp0b8 = fourth*w_xb
   wxb(i-1, j-1, k1) = wxb(i-1, j-1, k1) + temp0b8
   wxb(i, j-1, k1) = wxb(i, j-1, k1) + temp0b8
   wxb(i-1, j, k1) = wxb(i-1, j, k1) + temp0b8
   wxb(i, j, k1) = wxb(i, j, k1) + temp0b8
   CALL POPREAL8(v_z)
   temp0b9 = fourth*v_zb
   vzb(i-1, j-1, k1) = vzb(i-1, j-1, k1) + temp0b9
   vzb(i, j-1, k1) = vzb(i, j-1, k1) + temp0b9
   vzb(i-1, j, k1) = vzb(i-1, j, k1) + temp0b9
   vzb(i, j, k1) = vzb(i, j, k1) + temp0b9
   CALL POPREAL8(v_y)
   temp0b10 = fourth*v_yb
   vyb(i-1, j-1, k1) = vyb(i-1, j-1, k1) + temp0b10
   vyb(i, j-1, k1) = vyb(i, j-1, k1) + temp0b10
   vyb(i-1, j, k1) = vyb(i-1, j, k1) + temp0b10
   vyb(i, j, k1) = vyb(i, j, k1) + temp0b10
   CALL POPREAL8(v_x)
   temp0b11 = fourth*v_xb
   vxb(i-1, j-1, k1) = vxb(i-1, j-1, k1) + temp0b11
   vxb(i, j-1, k1) = vxb(i, j-1, k1) + temp0b11
   vxb(i-1, j, k1) = vxb(i-1, j, k1) + temp0b11
   vxb(i, j, k1) = vxb(i, j, k1) + temp0b11
   CALL POPREAL8(u_z)
   temp0b12 = fourth*u_zb
   uzb(i-1, j-1, k1) = uzb(i-1, j-1, k1) + temp0b12
   uzb(i, j-1, k1) = uzb(i, j-1, k1) + temp0b12
   uzb(i-1, j, k1) = uzb(i-1, j, k1) + temp0b12
   uzb(i, j, k1) = uzb(i, j, k1) + temp0b12
   CALL POPREAL8(u_y)
   temp0b13 = fourth*u_yb
   uyb(i-1, j-1, k1) = uyb(i-1, j-1, k1) + temp0b13
   uyb(i, j-1, k1) = uyb(i, j-1, k1) + temp0b13
   uyb(i-1, j, k1) = uyb(i-1, j, k1) + temp0b13
   uyb(i, j, k1) = uyb(i, j, k1) + temp0b13
   CALL POPREAL8(u_x)
   temp0b14 = fourth*u_xb
   uxb(i-1, j-1, k1) = uxb(i-1, j-1, k1) + temp0b14
   uxb(i, j-1, k1) = uxb(i, j-1, k1) + temp0b14
   uxb(i-1, j, k1) = uxb(i-1, j, k1) + temp0b14
   uxb(i, j, k1) = uxb(i, j, k1) + temp0b14
   gm1 = half*(gamma(i, j, 1)+gamma(i, j, 2)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   CALL POPREAL8(heatcoef)
   mulb = mutb + factlamheat*heatcoefb
   mueb = mueb + mutb + factturbheat*heatcoefb
   CALL POPREAL8(mut)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   revb(i, j, 1) = revb(i, j, 1) + por*mueb
   revb(i, j, 2) = revb(i, j, 2) + por*mueb
   mueb = 0.0_8
   END IF
   rlvb(i, j, 1) = rlvb(i, j, 1) + por*mulb
   rlvb(i, j, 2) = rlvb(i, j, 2) + por*mulb
   CALL POPREAL8(por)
   END DO
   END DO
   CALL POPREAL8ARRAY(ux, il*jl*2)
   CALL POPREAL8ARRAY(uy, il*jl*2)
   CALL POPREAL8ARRAY(uz, il*jl*2)
   CALL POPREAL8ARRAY(vx, il*jl*2)
   CALL POPREAL8ARRAY(vy, il*jl*2)
   CALL POPREAL8ARRAY(vz, il*jl*2)
   CALL POPREAL8ARRAY(wx, il*jl*2)
   CALL POPREAL8ARRAY(wy, il*jl*2)
   CALL POPREAL8ARRAY(wz, il*jl*2)
   CALL POPREAL8ARRAY(qx, il*jl*2)
   CALL POPREAL8ARRAY(qy, il*jl*2)
   CALL POPREAL8ARRAY(qz, il*jl*2)
   CALL NODALGRADIENTS_B(ux, uxb, uy, uyb, uz, uzb, vx, vxb, vy, vyb, &
   &                    vz, vzb, wx, wxb, wy, wyb, wz, wzb, qx, qxb, qy, qyb&
   &                    , qz, qzb)
   DO k=ke,1,-1
   DO j=je,1,-1
   DO i=ie,1,-1
   CALL POPREAL8(p(i, j, k))
   temp = w(i, j, k, irho)
   tempb = gamma(i, j, k)*pb(i, j, k)/temp
   wb(i, j, k, irho) = wb(i, j, k, irho) - p(i, j, k)*tempb/temp
   pb(i, j, k) = tempb
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(p(i, j, k))
   wb(i, j, k, irho) = wb(i, j, k, irho) - twothird*w(i, j, k, &
   &              itu1)*pb(i, j, k)
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - twothird*w(i, j, k, &
   &              irho)*pb(i, j, k)
   END IF
   END DO
   END DO
   END DO
   END IF
   prandtlturbb = 0.0_8
   prandtlb = 0.0_8
      CONTAINS
   !  Differentiation of nodalgradients in reverse (adjoint) mode:
   !   gradient     of useful results: *p *w *vol *si *sj *sk wx wy
   !                wz qx qy qz ux uy uz vx vy vz
   !   with respect to varying inputs: *p *w *vol *si *sj *sk wx wy
   !                wz qx qy qz ux uy uz vx vy vz
   !   Plus diff mem management of: p:in w:in vol:in si:in sj:in sk:in
   SUBROUTINE NODALGRADIENTS_B(ux, uxb, uy, uyb, uz, uzb, vx, vxb, vy, &
   &    vyb, vz, vzb, wx, wxb, wy, wyb, wz, wzb, qx, qxb, qy, qyb, qz, qzb)
   IMPLICIT NONE
   !
   !        Subroutine arguments
   !
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: ux, uy, &
   &    uz, vx, vy, vz, wx, wy, wz, qx, qy, qz
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: uxb
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: oneoverv, ubar, vbar, wbar, a2
   REAL(kind=realtype) :: oneovervb, ubarb, vbarb, wbarb, a2b
   REAL(kind=realtype) :: sx, sx1, sy, sy1, sz, sz1
   REAL(kind=realtype) :: sxb, sx1b, syb, sy1b, szb, sz1b
   INTEGER :: branch
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: wyb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: qxb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: vxb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: uzb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: wzb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: qyb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: vyb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: qzb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: wxb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: vzb
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: uyb
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb15
   REAL(kind=realtype) :: tempb14
   REAL(kind=realtype) :: tempb13
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: tempb10
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: temp
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! First part. Contribution in the k-direction. As the viscous
   ! fluxes are computed per k-plane, the values of the surface
   ! integrals in gauss's theorem are only scattered to one node.
   ! Consequently this part is an initialization as well.
   ! Loop over the j and i direction.
   DO j=1,jl
   DO i=1,il
   ! Store 8 times the average normal for the contribution from
   ! the k-layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sx1 = sk(i, j, k, 1) + sk(i+1, j, k, 1) + sk(i, j+1, k, 1) + sk(&
   &          i+1, j+1, k, 1)
   sy1 = sk(i, j, k, 2) + sk(i+1, j, k, 2) + sk(i, j+1, k, 2) + sk(&
   &          i+1, j+1, k, 2)
   sz1 = sk(i, j, k, 3) + sk(i+1, j, k, 3) + sk(i, j+1, k, 3) + sk(&
   &          i+1, j+1, k, 3)
   CALL PUSHREAL8(sx)
   sx = sx1 + sk(i, j, k-1, 1) + sk(i+1, j, k-1, 1) + sk(i, j+1, k-&
   &          1, 1) + sk(i+1, j+1, k-1, 1)
   CALL PUSHREAL8(sy)
   sy = sy1 + sk(i, j, k-1, 2) + sk(i+1, j, k-1, 2) + sk(i, j+1, k-&
   &          1, 2) + sk(i+1, j+1, k-1, 2)
   CALL PUSHREAL8(sz)
   sz = sz1 + sk(i, j, k-1, 3) + sk(i+1, j, k-1, 3) + sk(i, j+1, k-&
   &          1, 3) + sk(i+1, j+1, k-1, 3)
   CALL PUSHREAL8(ubar)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j+1, k, &
   &          ivx)+w(i+1, j+1, k, ivx))
   CALL PUSHREAL8(vbar)
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j+1, k, &
   &          ivy)+w(i+1, j+1, k, ivy))
   CALL PUSHREAL8(wbar)
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j+1, k, &
   &          ivz)+w(i+1, j+1, k, ivz))
   CALL PUSHREAL8(a2)
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j+1, k)+p(i+1, j+1, k)&
   &          )
   ! Set the velocity and speed of sound square gradients.
   ! The minus sign is there, because these normals are inward
   ! pointing for the nodal k-layer. The exception is a2,
   ! because the gradient of -a2 is stored, as this is needed
   ! in the heat fluxes.
   ux(i, j, k1) = -(ubar*sx)
   uy(i, j, k1) = -(ubar*sy)
   uz(i, j, k1) = -(ubar*sz)
   vx(i, j, k1) = -(vbar*sx)
   vy(i, j, k1) = -(vbar*sy)
   vz(i, j, k1) = -(vbar*sz)
   wx(i, j, k1) = -(wbar*sx)
   wy(i, j, k1) = -(wbar*sy)
   wz(i, j, k1) = -(wbar*sz)
   qx(i, j, k1) = a2*sx
   qy(i, j, k1) = a2*sy
   qz(i, j, k1) = a2*sz
   CALL PUSHREAL8(sx)
   ! Store 8 times the average normal for the contribution from
   ! the k+1 layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sx = sx1 + sk(i, j, k+1, 1) + sk(i+1, j, k+1, 1) + sk(i, j+1, k+&
   &          1, 1) + sk(i+1, j+1, k+1, 1)
   CALL PUSHREAL8(sy)
   sy = sy1 + sk(i, j, k+1, 2) + sk(i+1, j, k+1, 2) + sk(i, j+1, k+&
   &          1, 2) + sk(i+1, j+1, k+1, 2)
   CALL PUSHREAL8(sz)
   sz = sz1 + sk(i, j, k+1, 3) + sk(i+1, j, k+1, 3) + sk(i, j+1, k+&
   &          1, 3) + sk(i+1, j+1, k+1, 3)
   CALL PUSHREAL8(ubar)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k+1, ivx)+w(i+1, j, k+1, ivx)+w(i, j+1, k&
   &          +1, ivx)+w(i+1, j+1, k+1, ivx))
   CALL PUSHREAL8(vbar)
   vbar = fourth*(w(i, j, k+1, ivy)+w(i+1, j, k+1, ivy)+w(i, j+1, k&
   &          +1, ivy)+w(i+1, j+1, k+1, ivy))
   CALL PUSHREAL8(wbar)
   wbar = fourth*(w(i, j, k+1, ivz)+w(i+1, j, k+1, ivz)+w(i, j+1, k&
   &          +1, ivz)+w(i+1, j+1, k+1, ivz))
   CALL PUSHREAL8(a2)
   a2 = fourth*(p(i, j, k+1)+p(i+1, j, k+1)+p(i, j+1, k+1)+p(i+1, j&
   &          +1, k+1))
   ! Update the velocity and (minus) the speed of sound
   ! gradients. As the normals are now outward pointing for
   ! the nodes in the k-layer, there is a plus sign for the
   ! velocity gradients and a minus sign for minus the speed
   ! of sound squared.
   ux(i, j, k1) = ux(i, j, k1) + ubar*sx
   uy(i, j, k1) = uy(i, j, k1) + ubar*sy
   uz(i, j, k1) = uz(i, j, k1) + ubar*sz
   vx(i, j, k1) = vx(i, j, k1) + vbar*sx
   vy(i, j, k1) = vy(i, j, k1) + vbar*sy
   vz(i, j, k1) = vz(i, j, k1) + vbar*sz
   wx(i, j, k1) = wx(i, j, k1) + wbar*sx
   wy(i, j, k1) = wy(i, j, k1) + wbar*sy
   wz(i, j, k1) = wz(i, j, k1) + wbar*sz
   qx(i, j, k1) = qx(i, j, k1) - a2*sx
   qy(i, j, k1) = qy(i, j, k1) - a2*sy
   qz(i, j, k1) = qz(i, j, k1) - a2*sz
   END DO
   END DO
   ! Second part. Contribution in the j-direction.
   ! The contribution is scattered to both the left and right node
   ! in j-direction.
   DO j=1,je
   DO i=1,il
   CALL PUSHREAL8(sx)
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sx = sj(i, j-1, k, 1) + sj(i+1, j-1, k, 1) + sj(i, j-1, k+1, 1) &
   &          + sj(i+1, j-1, k+1, 1) + sj(i, j, k, 1) + sj(i+1, j, k, 1) + &
   &          sj(i, j, k+1, 1) + sj(i+1, j, k+1, 1)
   CALL PUSHREAL8(sy)
   sy = sj(i, j-1, k, 2) + sj(i+1, j-1, k, 2) + sj(i, j-1, k+1, 2) &
   &          + sj(i+1, j-1, k+1, 2) + sj(i, j, k, 2) + sj(i+1, j, k, 2) + &
   &          sj(i, j, k+1, 2) + sj(i+1, j, k+1, 2)
   CALL PUSHREAL8(sz)
   sz = sj(i, j-1, k, 3) + sj(i+1, j-1, k, 3) + sj(i, j-1, k+1, 3) &
   &          + sj(i+1, j-1, k+1, 3) + sj(i, j, k, 3) + sj(i+1, j, k, 3) + &
   &          sj(i, j, k+1, 3) + sj(i+1, j, k+1, 3)
   CALL PUSHREAL8(ubar)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i+1, j, k+1, ivx))
   CALL PUSHREAL8(vbar)
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i+1, j, k+1, ivy))
   CALL PUSHREAL8(wbar)
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i+1, j, k+1, ivz))
   CALL PUSHREAL8(a2)
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j, k+1)+p(i+1, j, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (j .GT. 1) THEN
   ux(i, j-1, k1) = ux(i, j-1, k1) + ubar*sx
   uy(i, j-1, k1) = uy(i, j-1, k1) + ubar*sy
   uz(i, j-1, k1) = uz(i, j-1, k1) + ubar*sz
   vx(i, j-1, k1) = vx(i, j-1, k1) + vbar*sx
   vy(i, j-1, k1) = vy(i, j-1, k1) + vbar*sy
   vz(i, j-1, k1) = vz(i, j-1, k1) + vbar*sz
   wx(i, j-1, k1) = wx(i, j-1, k1) + wbar*sx
   wy(i, j-1, k1) = wy(i, j-1, k1) + wbar*sy
   wz(i, j-1, k1) = wz(i, j-1, k1) + wbar*sz
   qx(i, j-1, k1) = qx(i, j-1, k1) - a2*sx
   qy(i, j-1, k1) = qy(i, j-1, k1) - a2*sy
   qz(i, j-1, k1) = qz(i, j-1, k1) - a2*sz
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (j .LT. je) THEN
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Third part. Contribution in the i-direction.
   ! The contribution is scattered to both the left and right node
   ! in i-direction.
   DO j=1,jl
   DO i=1,ie
   CALL PUSHREAL8(sx)
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sx = si(i-1, j, k, 1) + si(i-1, j+1, k, 1) + si(i-1, j, k+1, 1) &
   &          + si(i-1, j+1, k+1, 1) + si(i, j, k, 1) + si(i, j+1, k, 1) + &
   &          si(i, j, k+1, 1) + si(i, j+1, k+1, 1)
   CALL PUSHREAL8(sy)
   sy = si(i-1, j, k, 2) + si(i-1, j+1, k, 2) + si(i-1, j, k+1, 2) &
   &          + si(i-1, j+1, k+1, 2) + si(i, j, k, 2) + si(i, j+1, k, 2) + &
   &          si(i, j, k+1, 2) + si(i, j+1, k+1, 2)
   CALL PUSHREAL8(sz)
   sz = si(i-1, j, k, 3) + si(i-1, j+1, k, 3) + si(i-1, j, k+1, 3) &
   &          + si(i-1, j+1, k+1, 3) + si(i, j, k, 3) + si(i, j+1, k, 3) + &
   &          si(i, j, k+1, 3) + si(i, j+1, k+1, 3)
   CALL PUSHREAL8(ubar)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i, j+1, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i, j+1, k+1, ivx))
   CALL PUSHREAL8(vbar)
   vbar = fourth*(w(i, j, k, ivy)+w(i, j+1, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i, j+1, k+1, ivy))
   CALL PUSHREAL8(wbar)
   wbar = fourth*(w(i, j, k, ivz)+w(i, j+1, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i, j+1, k+1, ivz))
   CALL PUSHREAL8(a2)
   a2 = fourth*(p(i, j, k)+p(i, j+1, k)+p(i, j, k+1)+p(i, j+1, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (i .GT. 1) THEN
   ux(i-1, j, k1) = ux(i-1, j, k1) + ubar*sx
   uy(i-1, j, k1) = uy(i-1, j, k1) + ubar*sy
   uz(i-1, j, k1) = uz(i-1, j, k1) + ubar*sz
   vx(i-1, j, k1) = vx(i-1, j, k1) + vbar*sx
   vy(i-1, j, k1) = vy(i-1, j, k1) + vbar*sy
   vz(i-1, j, k1) = vz(i-1, j, k1) + vbar*sz
   wx(i-1, j, k1) = wx(i-1, j, k1) + wbar*sx
   wy(i-1, j, k1) = wy(i-1, j, k1) + wbar*sy
   wz(i-1, j, k1) = wz(i-1, j, k1) + wbar*sz
   qx(i-1, j, k1) = qx(i-1, j, k1) - a2*sx
   qy(i-1, j, k1) = qy(i-1, j, k1) - a2*sy
   qz(i-1, j, k1) = qz(i-1, j, k1) - a2*sz
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (i .LT. ie) THEN
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Divide by 8 times the volume to obtain the correct gradients.
   DO j=1,jl
   DO i=1,il
   CALL PUSHREAL8(oneoverv)
   ! Compute the inverse of 8 times the volume for this node.
   oneoverv = one/(vol(i, j, k)+vol(i, j, k+1)+vol(i+1, j, k)+vol(i&
   &          +1, j, k+1)+vol(i, j+1, k)+vol(i, j+1, k+1)+vol(i+1, j+1, k)+&
   &          vol(i+1, j+1, k+1))
   ! Compute the correct velocity gradients and "unit" heat
   ! fluxes. The velocity gradients are stored in ux, etc.
   END DO
   END DO
   DO j=jl,1,-1
   DO i=il,1,-1
   oneovervb = qy(i, j, k1)*qyb(i, j, k1) + wz(i, j, k1)*wzb(i, j, &
   &          k1) + wx(i, j, k1)*wxb(i, j, k1) + vy(i, j, k1)*vyb(i, j, k1) &
   &          + uz(i, j, k1)*uzb(i, j, k1) + ux(i, j, k1)*uxb(i, j, k1) + uy&
   &          (i, j, k1)*uyb(i, j, k1) + vx(i, j, k1)*vxb(i, j, k1) + vz(i, &
   &          j, k1)*vzb(i, j, k1) + wy(i, j, k1)*wyb(i, j, k1) + qx(i, j, &
   &          k1)*qxb(i, j, k1) + qz(i, j, k1)*qzb(i, j, k1)
   qzb(i, j, k1) = oneoverv*qzb(i, j, k1)
   qyb(i, j, k1) = oneoverv*qyb(i, j, k1)
   qxb(i, j, k1) = oneoverv*qxb(i, j, k1)
   wzb(i, j, k1) = oneoverv*wzb(i, j, k1)
   wyb(i, j, k1) = oneoverv*wyb(i, j, k1)
   wxb(i, j, k1) = oneoverv*wxb(i, j, k1)
   vzb(i, j, k1) = oneoverv*vzb(i, j, k1)
   vyb(i, j, k1) = oneoverv*vyb(i, j, k1)
   vxb(i, j, k1) = oneoverv*vxb(i, j, k1)
   uzb(i, j, k1) = oneoverv*uzb(i, j, k1)
   uyb(i, j, k1) = oneoverv*uyb(i, j, k1)
   uxb(i, j, k1) = oneoverv*uxb(i, j, k1)
   CALL POPREAL8(oneoverv)
   temp = vol(i, j, k) + vol(i, j, k+1) + vol(i+1, j, k) + vol(i+1&
   &          , j, k+1) + vol(i, j+1, k) + vol(i, j+1, k+1) + vol(i+1, j+1, &
   &          k) + vol(i+1, j+1, k+1)
   tempb15 = -(one*oneovervb/temp**2)
   volb(i, j, k) = volb(i, j, k) + tempb15
   volb(i, j, k+1) = volb(i, j, k+1) + tempb15
   volb(i+1, j, k) = volb(i+1, j, k) + tempb15
   volb(i+1, j, k+1) = volb(i+1, j, k+1) + tempb15
   volb(i, j+1, k) = volb(i, j+1, k) + tempb15
   volb(i, j+1, k+1) = volb(i, j+1, k+1) + tempb15
   volb(i+1, j+1, k) = volb(i+1, j+1, k) + tempb15
   volb(i+1, j+1, k+1) = volb(i+1, j+1, k+1) + tempb15
   END DO
   END DO
   DO j=jl,1,-1
   DO i=ie,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wbarb = 0.0_8
   vbarb = 0.0_8
   ubarb = 0.0_8
   a2b = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   ELSE
   a2b = sy*qyb(i, j, k1) + sx*qxb(i, j, k1) + sz*qzb(i, j, k1)
   szb = a2*qzb(i, j, k1) - ubar*uzb(i, j, k1) - vbar*vzb(i, j, &
   &            k1) - wbar*wzb(i, j, k1)
   syb = a2*qyb(i, j, k1) - ubar*uyb(i, j, k1) - vbar*vyb(i, j, &
   &            k1) - wbar*wyb(i, j, k1)
   sxb = a2*qxb(i, j, k1) - ubar*uxb(i, j, k1) - vbar*vxb(i, j, &
   &            k1) - wbar*wxb(i, j, k1)
   wbarb = -(sy*wyb(i, j, k1)) - sx*wxb(i, j, k1) - sz*wzb(i, j, &
   &            k1)
   vbarb = -(sy*vyb(i, j, k1)) - sx*vxb(i, j, k1) - sz*vzb(i, j, &
   &            k1)
   ubarb = -(sy*uyb(i, j, k1)) - sx*uxb(i, j, k1) - sz*uzb(i, j, &
   &            k1)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   a2b = a2b - sy*qyb(i-1, j, k1) - sx*qxb(i-1, j, k1) - sz*qzb(i&
   &            -1, j, k1)
   szb = szb + wbar*wzb(i-1, j, k1) + ubar*uzb(i-1, j, k1) + vbar&
   &            *vzb(i-1, j, k1) - a2*qzb(i-1, j, k1)
   syb = syb + wbar*wyb(i-1, j, k1) + ubar*uyb(i-1, j, k1) + vbar&
   &            *vyb(i-1, j, k1) - a2*qyb(i-1, j, k1)
   sxb = sxb + wbar*wxb(i-1, j, k1) + ubar*uxb(i-1, j, k1) + vbar&
   &            *vxb(i-1, j, k1) - a2*qxb(i-1, j, k1)
   wbarb = wbarb + sy*wyb(i-1, j, k1) + sx*wxb(i-1, j, k1) + sz*&
   &            wzb(i-1, j, k1)
   vbarb = vbarb + sy*vyb(i-1, j, k1) + sx*vxb(i-1, j, k1) + sz*&
   &            vzb(i-1, j, k1)
   ubarb = ubarb + sy*uyb(i-1, j, k1) + sx*uxb(i-1, j, k1) + sz*&
   &            uzb(i-1, j, k1)
   END IF
   CALL POPREAL8(a2)
   tempb11 = fourth*a2b
   pb(i, j, k) = pb(i, j, k) + tempb11
   pb(i, j+1, k) = pb(i, j+1, k) + tempb11
   pb(i, j, k+1) = pb(i, j, k+1) + tempb11
   pb(i, j+1, k+1) = pb(i, j+1, k+1) + tempb11
   CALL POPREAL8(wbar)
   tempb12 = fourth*wbarb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + tempb12
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + tempb12
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + tempb12
   wb(i, j+1, k+1, ivz) = wb(i, j+1, k+1, ivz) + tempb12
   CALL POPREAL8(vbar)
   tempb13 = fourth*vbarb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + tempb13
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + tempb13
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + tempb13
   wb(i, j+1, k+1, ivy) = wb(i, j+1, k+1, ivy) + tempb13
   CALL POPREAL8(ubar)
   tempb14 = fourth*ubarb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + tempb14
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + tempb14
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + tempb14
   wb(i, j+1, k+1, ivx) = wb(i, j+1, k+1, ivx) + tempb14
   CALL POPREAL8(sz)
   sib(i-1, j, k, 3) = sib(i-1, j, k, 3) + szb
   sib(i-1, j+1, k, 3) = sib(i-1, j+1, k, 3) + szb
   sib(i-1, j, k+1, 3) = sib(i-1, j, k+1, 3) + szb
   sib(i-1, j+1, k+1, 3) = sib(i-1, j+1, k+1, 3) + szb
   sib(i, j, k, 3) = sib(i, j, k, 3) + szb
   sib(i, j+1, k, 3) = sib(i, j+1, k, 3) + szb
   sib(i, j, k+1, 3) = sib(i, j, k+1, 3) + szb
   sib(i, j+1, k+1, 3) = sib(i, j+1, k+1, 3) + szb
   CALL POPREAL8(sy)
   sib(i-1, j, k, 2) = sib(i-1, j, k, 2) + syb
   sib(i-1, j+1, k, 2) = sib(i-1, j+1, k, 2) + syb
   sib(i-1, j, k+1, 2) = sib(i-1, j, k+1, 2) + syb
   sib(i-1, j+1, k+1, 2) = sib(i-1, j+1, k+1, 2) + syb
   sib(i, j, k, 2) = sib(i, j, k, 2) + syb
   sib(i, j+1, k, 2) = sib(i, j+1, k, 2) + syb
   sib(i, j, k+1, 2) = sib(i, j, k+1, 2) + syb
   sib(i, j+1, k+1, 2) = sib(i, j+1, k+1, 2) + syb
   CALL POPREAL8(sx)
   sib(i-1, j, k, 1) = sib(i-1, j, k, 1) + sxb
   sib(i-1, j+1, k, 1) = sib(i-1, j+1, k, 1) + sxb
   sib(i-1, j, k+1, 1) = sib(i-1, j, k+1, 1) + sxb
   sib(i-1, j+1, k+1, 1) = sib(i-1, j+1, k+1, 1) + sxb
   sib(i, j, k, 1) = sib(i, j, k, 1) + sxb
   sib(i, j+1, k, 1) = sib(i, j+1, k, 1) + sxb
   sib(i, j, k+1, 1) = sib(i, j, k+1, 1) + sxb
   sib(i, j+1, k+1, 1) = sib(i, j+1, k+1, 1) + sxb
   END DO
   END DO
   DO j=je,1,-1
   DO i=il,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wbarb = 0.0_8
   vbarb = 0.0_8
   ubarb = 0.0_8
   a2b = 0.0_8
   sxb = 0.0_8
   syb = 0.0_8
   szb = 0.0_8
   ELSE
   a2b = sy*qyb(i, j, k1) + sx*qxb(i, j, k1) + sz*qzb(i, j, k1)
   szb = a2*qzb(i, j, k1) - ubar*uzb(i, j, k1) - vbar*vzb(i, j, &
   &            k1) - wbar*wzb(i, j, k1)
   syb = a2*qyb(i, j, k1) - ubar*uyb(i, j, k1) - vbar*vyb(i, j, &
   &            k1) - wbar*wyb(i, j, k1)
   sxb = a2*qxb(i, j, k1) - ubar*uxb(i, j, k1) - vbar*vxb(i, j, &
   &            k1) - wbar*wxb(i, j, k1)
   wbarb = -(sy*wyb(i, j, k1)) - sx*wxb(i, j, k1) - sz*wzb(i, j, &
   &            k1)
   vbarb = -(sy*vyb(i, j, k1)) - sx*vxb(i, j, k1) - sz*vzb(i, j, &
   &            k1)
   ubarb = -(sy*uyb(i, j, k1)) - sx*uxb(i, j, k1) - sz*uzb(i, j, &
   &            k1)
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   a2b = a2b - sy*qyb(i, j-1, k1) - sx*qxb(i, j-1, k1) - sz*qzb(i&
   &            , j-1, k1)
   szb = szb + wbar*wzb(i, j-1, k1) + ubar*uzb(i, j-1, k1) + vbar&
   &            *vzb(i, j-1, k1) - a2*qzb(i, j-1, k1)
   syb = syb + wbar*wyb(i, j-1, k1) + ubar*uyb(i, j-1, k1) + vbar&
   &            *vyb(i, j-1, k1) - a2*qyb(i, j-1, k1)
   sxb = sxb + wbar*wxb(i, j-1, k1) + ubar*uxb(i, j-1, k1) + vbar&
   &            *vxb(i, j-1, k1) - a2*qxb(i, j-1, k1)
   wbarb = wbarb + sy*wyb(i, j-1, k1) + sx*wxb(i, j-1, k1) + sz*&
   &            wzb(i, j-1, k1)
   vbarb = vbarb + sy*vyb(i, j-1, k1) + sx*vxb(i, j-1, k1) + sz*&
   &            vzb(i, j-1, k1)
   ubarb = ubarb + sy*uyb(i, j-1, k1) + sx*uxb(i, j-1, k1) + sz*&
   &            uzb(i, j-1, k1)
   END IF
   CALL POPREAL8(a2)
   tempb7 = fourth*a2b
   pb(i, j, k) = pb(i, j, k) + tempb7
   pb(i+1, j, k) = pb(i+1, j, k) + tempb7
   pb(i, j, k+1) = pb(i, j, k+1) + tempb7
   pb(i+1, j, k+1) = pb(i+1, j, k+1) + tempb7
   CALL POPREAL8(wbar)
   tempb8 = fourth*wbarb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + tempb8
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + tempb8
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + tempb8
   wb(i+1, j, k+1, ivz) = wb(i+1, j, k+1, ivz) + tempb8
   CALL POPREAL8(vbar)
   tempb9 = fourth*vbarb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + tempb9
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + tempb9
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + tempb9
   wb(i+1, j, k+1, ivy) = wb(i+1, j, k+1, ivy) + tempb9
   CALL POPREAL8(ubar)
   tempb10 = fourth*ubarb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + tempb10
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + tempb10
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + tempb10
   wb(i+1, j, k+1, ivx) = wb(i+1, j, k+1, ivx) + tempb10
   CALL POPREAL8(sz)
   sjb(i, j-1, k, 3) = sjb(i, j-1, k, 3) + szb
   sjb(i+1, j-1, k, 3) = sjb(i+1, j-1, k, 3) + szb
   sjb(i, j-1, k+1, 3) = sjb(i, j-1, k+1, 3) + szb
   sjb(i+1, j-1, k+1, 3) = sjb(i+1, j-1, k+1, 3) + szb
   sjb(i, j, k, 3) = sjb(i, j, k, 3) + szb
   sjb(i+1, j, k, 3) = sjb(i+1, j, k, 3) + szb
   sjb(i, j, k+1, 3) = sjb(i, j, k+1, 3) + szb
   sjb(i+1, j, k+1, 3) = sjb(i+1, j, k+1, 3) + szb
   CALL POPREAL8(sy)
   sjb(i, j-1, k, 2) = sjb(i, j-1, k, 2) + syb
   sjb(i+1, j-1, k, 2) = sjb(i+1, j-1, k, 2) + syb
   sjb(i, j-1, k+1, 2) = sjb(i, j-1, k+1, 2) + syb
   sjb(i+1, j-1, k+1, 2) = sjb(i+1, j-1, k+1, 2) + syb
   sjb(i, j, k, 2) = sjb(i, j, k, 2) + syb
   sjb(i+1, j, k, 2) = sjb(i+1, j, k, 2) + syb
   sjb(i, j, k+1, 2) = sjb(i, j, k+1, 2) + syb
   sjb(i+1, j, k+1, 2) = sjb(i+1, j, k+1, 2) + syb
   CALL POPREAL8(sx)
   sjb(i, j-1, k, 1) = sjb(i, j-1, k, 1) + sxb
   sjb(i+1, j-1, k, 1) = sjb(i+1, j-1, k, 1) + sxb
   sjb(i, j-1, k+1, 1) = sjb(i, j-1, k+1, 1) + sxb
   sjb(i+1, j-1, k+1, 1) = sjb(i+1, j-1, k+1, 1) + sxb
   sjb(i, j, k, 1) = sjb(i, j, k, 1) + sxb
   sjb(i+1, j, k, 1) = sjb(i+1, j, k, 1) + sxb
   sjb(i, j, k+1, 1) = sjb(i, j, k+1, 1) + sxb
   sjb(i+1, j, k+1, 1) = sjb(i+1, j, k+1, 1) + sxb
   END DO
   END DO
   DO j=jl,1,-1
   DO i=il,1,-1
   a2b = -(sy*qyb(i, j, k1)) - sx*qxb(i, j, k1) - sz*qzb(i, j, k1)
   szb = wbar*wzb(i, j, k1) + ubar*uzb(i, j, k1) + vbar*vzb(i, j, &
   &          k1) - a2*qzb(i, j, k1)
   syb = wbar*wyb(i, j, k1) + ubar*uyb(i, j, k1) + vbar*vyb(i, j, &
   &          k1) - a2*qyb(i, j, k1)
   sxb = wbar*wxb(i, j, k1) + ubar*uxb(i, j, k1) + vbar*vxb(i, j, &
   &          k1) - a2*qxb(i, j, k1)
   wbarb = sy*wyb(i, j, k1) + sx*wxb(i, j, k1) + sz*wzb(i, j, k1)
   vbarb = sy*vyb(i, j, k1) + sx*vxb(i, j, k1) + sz*vzb(i, j, k1)
   ubarb = sy*uyb(i, j, k1) + sx*uxb(i, j, k1) + sz*uzb(i, j, k1)
   CALL POPREAL8(a2)
   tempb = fourth*a2b
   pb(i, j, k+1) = pb(i, j, k+1) + tempb
   pb(i+1, j, k+1) = pb(i+1, j, k+1) + tempb
   pb(i, j+1, k+1) = pb(i, j+1, k+1) + tempb
   pb(i+1, j+1, k+1) = pb(i+1, j+1, k+1) + tempb
   CALL POPREAL8(wbar)
   tempb0 = fourth*wbarb
   wb(i, j, k+1, ivz) = wb(i, j, k+1, ivz) + tempb0
   wb(i+1, j, k+1, ivz) = wb(i+1, j, k+1, ivz) + tempb0
   wb(i, j+1, k+1, ivz) = wb(i, j+1, k+1, ivz) + tempb0
   wb(i+1, j+1, k+1, ivz) = wb(i+1, j+1, k+1, ivz) + tempb0
   CALL POPREAL8(vbar)
   tempb1 = fourth*vbarb
   wb(i, j, k+1, ivy) = wb(i, j, k+1, ivy) + tempb1
   wb(i+1, j, k+1, ivy) = wb(i+1, j, k+1, ivy) + tempb1
   wb(i, j+1, k+1, ivy) = wb(i, j+1, k+1, ivy) + tempb1
   wb(i+1, j+1, k+1, ivy) = wb(i+1, j+1, k+1, ivy) + tempb1
   CALL POPREAL8(ubar)
   tempb2 = fourth*ubarb
   wb(i, j, k+1, ivx) = wb(i, j, k+1, ivx) + tempb2
   wb(i+1, j, k+1, ivx) = wb(i+1, j, k+1, ivx) + tempb2
   wb(i, j+1, k+1, ivx) = wb(i, j+1, k+1, ivx) + tempb2
   wb(i+1, j+1, k+1, ivx) = wb(i+1, j+1, k+1, ivx) + tempb2
   CALL POPREAL8(sz)
   sz1b = szb
   skb(i, j, k+1, 3) = skb(i, j, k+1, 3) + szb
   skb(i+1, j, k+1, 3) = skb(i+1, j, k+1, 3) + szb
   skb(i, j+1, k+1, 3) = skb(i, j+1, k+1, 3) + szb
   skb(i+1, j+1, k+1, 3) = skb(i+1, j+1, k+1, 3) + szb
   CALL POPREAL8(sy)
   sy1b = syb
   skb(i, j, k+1, 2) = skb(i, j, k+1, 2) + syb
   skb(i+1, j, k+1, 2) = skb(i+1, j, k+1, 2) + syb
   skb(i, j+1, k+1, 2) = skb(i, j+1, k+1, 2) + syb
   skb(i+1, j+1, k+1, 2) = skb(i+1, j+1, k+1, 2) + syb
   CALL POPREAL8(sx)
   sx1b = sxb
   skb(i, j, k+1, 1) = skb(i, j, k+1, 1) + sxb
   skb(i+1, j, k+1, 1) = skb(i+1, j, k+1, 1) + sxb
   skb(i, j+1, k+1, 1) = skb(i, j+1, k+1, 1) + sxb
   skb(i+1, j+1, k+1, 1) = skb(i+1, j+1, k+1, 1) + sxb
   a2b = sy*qyb(i, j, k1) + sx*qxb(i, j, k1) + sz*qzb(i, j, k1)
   szb = a2*qzb(i, j, k1) - ubar*uzb(i, j, k1) - vbar*vzb(i, j, k1)&
   &          - wbar*wzb(i, j, k1)
   qzb(i, j, k1) = 0.0_8
   syb = a2*qyb(i, j, k1) - ubar*uyb(i, j, k1) - vbar*vyb(i, j, k1)&
   &          - wbar*wyb(i, j, k1)
   qyb(i, j, k1) = 0.0_8
   sxb = a2*qxb(i, j, k1) - ubar*uxb(i, j, k1) - vbar*vxb(i, j, k1)&
   &          - wbar*wxb(i, j, k1)
   qxb(i, j, k1) = 0.0_8
   wbarb = -(sy*wyb(i, j, k1)) - sx*wxb(i, j, k1) - sz*wzb(i, j, k1&
   &          )
   wzb(i, j, k1) = 0.0_8
   wyb(i, j, k1) = 0.0_8
   wxb(i, j, k1) = 0.0_8
   vbarb = -(sy*vyb(i, j, k1)) - sx*vxb(i, j, k1) - sz*vzb(i, j, k1&
   &          )
   vzb(i, j, k1) = 0.0_8
   vyb(i, j, k1) = 0.0_8
   vxb(i, j, k1) = 0.0_8
   ubarb = -(sy*uyb(i, j, k1)) - sx*uxb(i, j, k1) - sz*uzb(i, j, k1&
   &          )
   uzb(i, j, k1) = 0.0_8
   uyb(i, j, k1) = 0.0_8
   uxb(i, j, k1) = 0.0_8
   CALL POPREAL8(a2)
   tempb3 = fourth*a2b
   pb(i, j, k) = pb(i, j, k) + tempb3
   pb(i+1, j, k) = pb(i+1, j, k) + tempb3
   pb(i, j+1, k) = pb(i, j+1, k) + tempb3
   pb(i+1, j+1, k) = pb(i+1, j+1, k) + tempb3
   CALL POPREAL8(wbar)
   tempb4 = fourth*wbarb
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + tempb4
   wb(i+1, j, k, ivz) = wb(i+1, j, k, ivz) + tempb4
   wb(i, j+1, k, ivz) = wb(i, j+1, k, ivz) + tempb4
   wb(i+1, j+1, k, ivz) = wb(i+1, j+1, k, ivz) + tempb4
   CALL POPREAL8(vbar)
   tempb5 = fourth*vbarb
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + tempb5
   wb(i+1, j, k, ivy) = wb(i+1, j, k, ivy) + tempb5
   wb(i, j+1, k, ivy) = wb(i, j+1, k, ivy) + tempb5
   wb(i+1, j+1, k, ivy) = wb(i+1, j+1, k, ivy) + tempb5
   CALL POPREAL8(ubar)
   tempb6 = fourth*ubarb
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + tempb6
   wb(i+1, j, k, ivx) = wb(i+1, j, k, ivx) + tempb6
   wb(i, j+1, k, ivx) = wb(i, j+1, k, ivx) + tempb6
   wb(i+1, j+1, k, ivx) = wb(i+1, j+1, k, ivx) + tempb6
   CALL POPREAL8(sz)
   sz1b = sz1b + szb
   skb(i, j, k-1, 3) = skb(i, j, k-1, 3) + szb
   skb(i+1, j, k-1, 3) = skb(i+1, j, k-1, 3) + szb
   skb(i, j+1, k-1, 3) = skb(i, j+1, k-1, 3) + szb
   skb(i+1, j+1, k-1, 3) = skb(i+1, j+1, k-1, 3) + szb
   CALL POPREAL8(sy)
   sy1b = sy1b + syb
   skb(i, j, k-1, 2) = skb(i, j, k-1, 2) + syb
   skb(i+1, j, k-1, 2) = skb(i+1, j, k-1, 2) + syb
   skb(i, j+1, k-1, 2) = skb(i, j+1, k-1, 2) + syb
   skb(i+1, j+1, k-1, 2) = skb(i+1, j+1, k-1, 2) + syb
   CALL POPREAL8(sx)
   sx1b = sx1b + sxb
   skb(i, j, k-1, 1) = skb(i, j, k-1, 1) + sxb
   skb(i+1, j, k-1, 1) = skb(i+1, j, k-1, 1) + sxb
   skb(i, j+1, k-1, 1) = skb(i, j+1, k-1, 1) + sxb
   skb(i+1, j+1, k-1, 1) = skb(i+1, j+1, k-1, 1) + sxb
   skb(i, j, k, 3) = skb(i, j, k, 3) + sz1b
   skb(i+1, j, k, 3) = skb(i+1, j, k, 3) + sz1b
   skb(i, j+1, k, 3) = skb(i, j+1, k, 3) + sz1b
   skb(i+1, j+1, k, 3) = skb(i+1, j+1, k, 3) + sz1b
   skb(i, j, k, 2) = skb(i, j, k, 2) + sy1b
   skb(i+1, j, k, 2) = skb(i+1, j, k, 2) + sy1b
   skb(i, j+1, k, 2) = skb(i, j+1, k, 2) + sy1b
   skb(i+1, j+1, k, 2) = skb(i+1, j+1, k, 2) + sy1b
   skb(i, j, k, 1) = skb(i, j, k, 1) + sx1b
   skb(i+1, j, k, 1) = skb(i+1, j, k, 1) + sx1b
   skb(i, j+1, k, 1) = skb(i, j+1, k, 1) + sx1b
   skb(i+1, j+1, k, 1) = skb(i+1, j+1, k, 1) + sx1b
   END DO
   END DO
   END SUBROUTINE NODALGRADIENTS_B
   SUBROUTINE NODALGRADIENTS(ux, uy, uz, vx, vy, vz, wx, wy, wz, qx, qy, &
   &    qz)
   IMPLICIT NONE
   !
   !        Subroutine arguments
   !
   REAL(kind=realtype), DIMENSION(il, jl, 2), INTENT(INOUT) :: ux, uy, &
   &    uz, vx, vy, vz, wx, wy, wz, qx, qy, qz
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: oneoverv, ubar, vbar, wbar, a2
   REAL(kind=realtype) :: sx, sx1, sy, sy1, sz, sz1
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! First part. Contribution in the k-direction. As the viscous
   ! fluxes are computed per k-plane, the values of the surface
   ! integrals in gauss's theorem are only scattered to one node.
   ! Consequently this part is an initialization as well.
   ! Loop over the j and i direction.
   DO j=1,jl
   DO i=1,il
   ! Store 8 times the average normal for the contribution from
   ! the k-layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sx1 = sk(i, j, k, 1) + sk(i+1, j, k, 1) + sk(i, j+1, k, 1) + sk(&
   &          i+1, j+1, k, 1)
   sy1 = sk(i, j, k, 2) + sk(i+1, j, k, 2) + sk(i, j+1, k, 2) + sk(&
   &          i+1, j+1, k, 2)
   sz1 = sk(i, j, k, 3) + sk(i+1, j, k, 3) + sk(i, j+1, k, 3) + sk(&
   &          i+1, j+1, k, 3)
   sx = sx1 + sk(i, j, k-1, 1) + sk(i+1, j, k-1, 1) + sk(i, j+1, k-&
   &          1, 1) + sk(i+1, j+1, k-1, 1)
   sy = sy1 + sk(i, j, k-1, 2) + sk(i+1, j, k-1, 2) + sk(i, j+1, k-&
   &          1, 2) + sk(i+1, j+1, k-1, 2)
   sz = sz1 + sk(i, j, k-1, 3) + sk(i+1, j, k-1, 3) + sk(i, j+1, k-&
   &          1, 3) + sk(i+1, j+1, k-1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j+1, k, &
   &          ivx)+w(i+1, j+1, k, ivx))
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j+1, k, &
   &          ivy)+w(i+1, j+1, k, ivy))
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j+1, k, &
   &          ivz)+w(i+1, j+1, k, ivz))
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j+1, k)+p(i+1, j+1, k)&
   &          )
   ! Set the velocity and speed of sound square gradients.
   ! The minus sign is there, because these normals are inward
   ! pointing for the nodal k-layer. The exception is a2,
   ! because the gradient of -a2 is stored, as this is needed
   ! in the heat fluxes.
   ux(i, j, k1) = -(ubar*sx)
   uy(i, j, k1) = -(ubar*sy)
   uz(i, j, k1) = -(ubar*sz)
   vx(i, j, k1) = -(vbar*sx)
   vy(i, j, k1) = -(vbar*sy)
   vz(i, j, k1) = -(vbar*sz)
   wx(i, j, k1) = -(wbar*sx)
   wy(i, j, k1) = -(wbar*sy)
   wz(i, j, k1) = -(wbar*sz)
   qx(i, j, k1) = a2*sx
   qy(i, j, k1) = a2*sy
   qz(i, j, k1) = a2*sz
   ! Store 8 times the average normal for the contribution from
   ! the k+1 layer of cells. The factor 8 drops out later when
   ! dividing by the volume.
   sx = sx1 + sk(i, j, k+1, 1) + sk(i+1, j, k+1, 1) + sk(i, j+1, k+&
   &          1, 1) + sk(i+1, j+1, k+1, 1)
   sy = sy1 + sk(i, j, k+1, 2) + sk(i+1, j, k+1, 2) + sk(i, j+1, k+&
   &          1, 2) + sk(i+1, j+1, k+1, 2)
   sz = sz1 + sk(i, j, k+1, 3) + sk(i+1, j, k+1, 3) + sk(i, j+1, k+&
   &          1, 3) + sk(i+1, j+1, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k+1, ivx)+w(i+1, j, k+1, ivx)+w(i, j+1, k&
   &          +1, ivx)+w(i+1, j+1, k+1, ivx))
   vbar = fourth*(w(i, j, k+1, ivy)+w(i+1, j, k+1, ivy)+w(i, j+1, k&
   &          +1, ivy)+w(i+1, j+1, k+1, ivy))
   wbar = fourth*(w(i, j, k+1, ivz)+w(i+1, j, k+1, ivz)+w(i, j+1, k&
   &          +1, ivz)+w(i+1, j+1, k+1, ivz))
   a2 = fourth*(p(i, j, k+1)+p(i+1, j, k+1)+p(i, j+1, k+1)+p(i+1, j&
   &          +1, k+1))
   ! Update the velocity and (minus) the speed of sound
   ! gradients. As the normals are now outward pointing for
   ! the nodes in the k-layer, there is a plus sign for the
   ! velocity gradients and a minus sign for minus the speed
   ! of sound squared.
   ux(i, j, k1) = ux(i, j, k1) + ubar*sx
   uy(i, j, k1) = uy(i, j, k1) + ubar*sy
   uz(i, j, k1) = uz(i, j, k1) + ubar*sz
   vx(i, j, k1) = vx(i, j, k1) + vbar*sx
   vy(i, j, k1) = vy(i, j, k1) + vbar*sy
   vz(i, j, k1) = vz(i, j, k1) + vbar*sz
   wx(i, j, k1) = wx(i, j, k1) + wbar*sx
   wy(i, j, k1) = wy(i, j, k1) + wbar*sy
   wz(i, j, k1) = wz(i, j, k1) + wbar*sz
   qx(i, j, k1) = qx(i, j, k1) - a2*sx
   qy(i, j, k1) = qy(i, j, k1) - a2*sy
   qz(i, j, k1) = qz(i, j, k1) - a2*sz
   END DO
   END DO
   ! Second part. Contribution in the j-direction.
   ! The contribution is scattered to both the left and right node
   ! in j-direction.
   DO j=1,je
   DO i=1,il
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sx = sj(i, j-1, k, 1) + sj(i+1, j-1, k, 1) + sj(i, j-1, k+1, 1) &
   &          + sj(i+1, j-1, k+1, 1) + sj(i, j, k, 1) + sj(i+1, j, k, 1) + &
   &          sj(i, j, k+1, 1) + sj(i+1, j, k+1, 1)
   sy = sj(i, j-1, k, 2) + sj(i+1, j-1, k, 2) + sj(i, j-1, k+1, 2) &
   &          + sj(i+1, j-1, k+1, 2) + sj(i, j, k, 2) + sj(i+1, j, k, 2) + &
   &          sj(i, j, k+1, 2) + sj(i+1, j, k+1, 2)
   sz = sj(i, j-1, k, 3) + sj(i+1, j-1, k, 3) + sj(i, j-1, k+1, 3) &
   &          + sj(i+1, j-1, k+1, 3) + sj(i, j, k, 3) + sj(i+1, j, k, 3) + &
   &          sj(i, j, k+1, 3) + sj(i+1, j, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i+1, j, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i+1, j, k+1, ivx))
   vbar = fourth*(w(i, j, k, ivy)+w(i+1, j, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i+1, j, k+1, ivy))
   wbar = fourth*(w(i, j, k, ivz)+w(i+1, j, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i+1, j, k+1, ivz))
   a2 = fourth*(p(i, j, k)+p(i+1, j, k)+p(i, j, k+1)+p(i+1, j, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (j .GT. 1) THEN
   ux(i, j-1, k1) = ux(i, j-1, k1) + ubar*sx
   uy(i, j-1, k1) = uy(i, j-1, k1) + ubar*sy
   uz(i, j-1, k1) = uz(i, j-1, k1) + ubar*sz
   vx(i, j-1, k1) = vx(i, j-1, k1) + vbar*sx
   vy(i, j-1, k1) = vy(i, j-1, k1) + vbar*sy
   vz(i, j-1, k1) = vz(i, j-1, k1) + vbar*sz
   wx(i, j-1, k1) = wx(i, j-1, k1) + wbar*sx
   wy(i, j-1, k1) = wy(i, j-1, k1) + wbar*sy
   wz(i, j-1, k1) = wz(i, j-1, k1) + wbar*sz
   qx(i, j-1, k1) = qx(i, j-1, k1) - a2*sx
   qy(i, j-1, k1) = qy(i, j-1, k1) - a2*sy
   qz(i, j-1, k1) = qz(i, j-1, k1) - a2*sz
   END IF
   IF (j .LT. je) THEN
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   END IF
   END DO
   END DO
   ! Third part. Contribution in the i-direction.
   ! The contribution is scattered to both the left and right node
   ! in i-direction.
   DO j=1,jl
   DO i=1,ie
   ! Compute 8 times the average normal for this part of
   ! the control volume. The factor 8 is taken care of later
   ! on when the division by the volume takes place.
   sx = si(i-1, j, k, 1) + si(i-1, j+1, k, 1) + si(i-1, j, k+1, 1) &
   &          + si(i-1, j+1, k+1, 1) + si(i, j, k, 1) + si(i, j+1, k, 1) + &
   &          si(i, j, k+1, 1) + si(i, j+1, k+1, 1)
   sy = si(i-1, j, k, 2) + si(i-1, j+1, k, 2) + si(i-1, j, k+1, 2) &
   &          + si(i-1, j+1, k+1, 2) + si(i, j, k, 2) + si(i, j+1, k, 2) + &
   &          si(i, j, k+1, 2) + si(i, j+1, k+1, 2)
   sz = si(i-1, j, k, 3) + si(i-1, j+1, k, 3) + si(i-1, j, k+1, 3) &
   &          + si(i-1, j+1, k+1, 3) + si(i, j, k, 3) + si(i, j+1, k, 3) + &
   &          si(i, j, k+1, 3) + si(i, j+1, k+1, 3)
   ! Compute the average velocities and speed of sound squared
   ! for this integration point. Node that these variables are
   ! stored in w(ivx), w(ivy), w(ivz) and p.
   ubar = fourth*(w(i, j, k, ivx)+w(i, j+1, k, ivx)+w(i, j, k+1, &
   &          ivx)+w(i, j+1, k+1, ivx))
   vbar = fourth*(w(i, j, k, ivy)+w(i, j+1, k, ivy)+w(i, j, k+1, &
   &          ivy)+w(i, j+1, k+1, ivy))
   wbar = fourth*(w(i, j, k, ivz)+w(i, j+1, k, ivz)+w(i, j, k+1, &
   &          ivz)+w(i, j+1, k+1, ivz))
   a2 = fourth*(p(i, j, k)+p(i, j+1, k)+p(i, j, k+1)+p(i, j+1, k+1)&
   &          )
   ! Add the contributions to the surface integral to the node
   ! j-1 and substract it from the node j. For the heat flux it
   ! is reversed, because the negative of the gradient of the
   ! speed of sound must be computed.
   IF (i .GT. 1) THEN
   ux(i-1, j, k1) = ux(i-1, j, k1) + ubar*sx
   uy(i-1, j, k1) = uy(i-1, j, k1) + ubar*sy
   uz(i-1, j, k1) = uz(i-1, j, k1) + ubar*sz
   vx(i-1, j, k1) = vx(i-1, j, k1) + vbar*sx
   vy(i-1, j, k1) = vy(i-1, j, k1) + vbar*sy
   vz(i-1, j, k1) = vz(i-1, j, k1) + vbar*sz
   wx(i-1, j, k1) = wx(i-1, j, k1) + wbar*sx
   wy(i-1, j, k1) = wy(i-1, j, k1) + wbar*sy
   wz(i-1, j, k1) = wz(i-1, j, k1) + wbar*sz
   qx(i-1, j, k1) = qx(i-1, j, k1) - a2*sx
   qy(i-1, j, k1) = qy(i-1, j, k1) - a2*sy
   qz(i-1, j, k1) = qz(i-1, j, k1) - a2*sz
   END IF
   IF (i .LT. ie) THEN
   ux(i, j, k1) = ux(i, j, k1) - ubar*sx
   uy(i, j, k1) = uy(i, j, k1) - ubar*sy
   uz(i, j, k1) = uz(i, j, k1) - ubar*sz
   vx(i, j, k1) = vx(i, j, k1) - vbar*sx
   vy(i, j, k1) = vy(i, j, k1) - vbar*sy
   vz(i, j, k1) = vz(i, j, k1) - vbar*sz
   wx(i, j, k1) = wx(i, j, k1) - wbar*sx
   wy(i, j, k1) = wy(i, j, k1) - wbar*sy
   wz(i, j, k1) = wz(i, j, k1) - wbar*sz
   qx(i, j, k1) = qx(i, j, k1) + a2*sx
   qy(i, j, k1) = qy(i, j, k1) + a2*sy
   qz(i, j, k1) = qz(i, j, k1) + a2*sz
   END IF
   END DO
   END DO
   ! Divide by 8 times the volume to obtain the correct gradients.
   DO j=1,jl
   DO i=1,il
   ! Compute the inverse of 8 times the volume for this node.
   oneoverv = one/(vol(i, j, k)+vol(i, j, k+1)+vol(i+1, j, k)+vol(i&
   &          +1, j, k+1)+vol(i, j+1, k)+vol(i, j+1, k+1)+vol(i+1, j+1, k)+&
   &          vol(i+1, j+1, k+1))
   ! Compute the correct velocity gradients and "unit" heat
   ! fluxes. The velocity gradients are stored in ux, etc.
   ux(i, j, k1) = ux(i, j, k1)*oneoverv
   uy(i, j, k1) = uy(i, j, k1)*oneoverv
   uz(i, j, k1) = uz(i, j, k1)*oneoverv
   vx(i, j, k1) = vx(i, j, k1)*oneoverv
   vy(i, j, k1) = vy(i, j, k1)*oneoverv
   vz(i, j, k1) = vz(i, j, k1)*oneoverv
   wx(i, j, k1) = wx(i, j, k1)*oneoverv
   wy(i, j, k1) = wy(i, j, k1)*oneoverv
   wz(i, j, k1) = wz(i, j, k1)*oneoverv
   qx(i, j, k1) = qx(i, j, k1)*oneoverv
   qy(i, j, k1) = qy(i, j, k1)*oneoverv
   qz(i, j, k1) = qz(i, j, k1)*oneoverv
   END DO
   END DO
   END SUBROUTINE NODALGRADIENTS
   END SUBROUTINE VISCOUSFLUX_B

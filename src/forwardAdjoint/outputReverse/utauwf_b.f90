   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of utauwf in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *w *fw
   !   with respect to varying inputs: *w *rlv *fw *(*viscsubface.tau)
   !   Plus diff mem management of: w:in rlv:in fw:in viscsubface:in
   !                *viscsubface.tau:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          utauWF.f90                                      *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 10-01-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE UTAUWF_B(rfilv)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * utauWF substitutes the wall shear stress with values from a    *
   !      * look-up table, if desired.                                     *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS_B
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !      Subroutine argument.
   !
   REAL(kind=realtype), INTENT(IN) :: rfilv
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, nn
   REAL(kind=realtype) :: fact
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxb, tauyyb, tauzzb
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyb, tauxzb, tauyzb
   REAL(kind=realtype) :: rbar, ubar, vbar, wbar, vx, vy, vz
   REAL(kind=realtype) :: rbarb, ubarb, vbarb, wbarb, vxb, vyb, vzb
   REAL(kind=realtype) :: fmx, fmy, fmz, frhoe
   REAL(kind=realtype) :: fmxb, fmyb, fmzb, frhoeb
   REAL(kind=realtype) :: veln, velnx, velny, velnz, tx, ty, tz
   REAL(kind=realtype) :: velnb, velnxb, velnyb, velnzb, txb, tyb, tzb
   REAL(kind=realtype) :: veltx, velty, veltz, veltmag
   REAL(kind=realtype) :: veltxb, veltyb, veltzb, veltmagb
   REAL(kind=realtype) :: txnx, txny, txnz, tynx, tyny, tynz
   REAL(kind=realtype) :: txnxb, txnyb, txnzb, tynxb, tynyb, tynzb
   REAL(kind=realtype) :: tznx, tzny, tznz
   REAL(kind=realtype) :: tznxb, tznyb, tznzb
   REAL(kind=realtype) :: tautn, tauwall, utau, re
   REAL(kind=realtype) :: tautnb, tauwallb, utaub, reb
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1b, ww2b
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss, rres
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: rresb
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: norm
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv2, dd2wall2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv2b
   !
   !      Function definition.
   !
   REAL(kind=realtype) :: CURVEUPRE
   INTRINSIC SQRT
   INTRINSIC MAX
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTERFACE 
   SUBROUTINE PUSHPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE PUSHPOINTER4
   SUBROUTINE LOOKPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE LOOKPOINTER4
   SUBROUTINE POPPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE POPPOINTER4
   END INTERFACE
      REAL(kind=realtype) :: y1b
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: max1b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: x1b
   INTEGER :: ii1
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: y1
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately if no wall functions must be used.
   IF (.NOT.wallfunctions) THEN
   rlvb = 0.0_8
   DO ii1=1,SIZE(viscsubfaceb(ii1)%tau, 1)
   viscsubfaceb(ii1)%tau = 0.0_8
   END DO
   ELSE
   ! Loop over the viscous subfaces of this block.
   viscsubfaces:DO nn=1,nviscbocos
   ! Set a bunch of variables depending on the face id to make
   ! a generic treatment possible.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   CALL PUSHREAL8(fact)
   fact = -one
   CALL PUSHPOINTER4(ss)
   ss => si(1, :, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(2, 1:, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(2, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(2, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(2, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1, 1:, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(2, :, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(2, 1:, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(2, 1:, 1:)
   CALL PUSHCONTROL3B(1)
   CASE (imax) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = one
   CALL PUSHPOINTER4(ss)
   ss => si(il, :, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(il, 1:, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(il, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(il, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(il, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(ie, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(ie, 1:, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(il, :, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(il, 1:, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(il, 1:, 1:)
   CALL PUSHCONTROL3B(2)
   CASE (jmin) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = -one
   CALL PUSHPOINTER4(ss)
   ss => sj(:, 1, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, 2, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, 2, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, 2, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, 2, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, 1, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, 1, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, 2, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, 2, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, 2, 1:)
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = one
   CALL PUSHPOINTER4(ss)
   ss => sj(:, jl, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, jl, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, jl, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, jl, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, jl, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, je, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, je, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, jl, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, jl, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, jl, 1:)
   CALL PUSHCONTROL3B(4)
   CASE (kmin) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = -one
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, 1, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, 1:, 2, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, 1:, 2, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, 1:, 2, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, 1:, 2, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, 1:, 1, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, 1:, 1, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, :, 2)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, 1:, 2)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, 1:, 2)
   CALL PUSHCONTROL3B(5)
   CASE (kmax) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = one
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, kl, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, 1:, kl, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, 1:, kl, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, 1:, kl, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, 1:, kl, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, 1:, ke, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, 1:, ke, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, :, kl)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, 1:, kl)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, 1:, kl)
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ! Set the pointer for the unit outward normals.
   CALL PUSHPOINTER4(norm)
   norm => bcdata(nn)%norm
   ad_from0 = bcdata(nn)%jnbeg + 1
   ! Loop over the quadrilateral faces of the subface. Note
   ! that the nodal range of BCData must be used and not the
   ! cell range, because the latter may include the halo's in i
   ! and j-direction. The offset +1 is there, because inBeg and
   ! jnBeg refer to nodal ranges and not to cell ranges.
   DO j=ad_from0,bcdata(nn)%jnend
   ad_from = bcdata(nn)%inbeg + 1
   DO i=ad_from,bcdata(nn)%inend
   ! Store the viscous stress tensor a bit easier.
   tauxx = viscsubface(nn)%tau(i, j, 1)
   tauyy = viscsubface(nn)%tau(i, j, 2)
   tauzz = viscsubface(nn)%tau(i, j, 3)
   tauxy = viscsubface(nn)%tau(i, j, 4)
   tauxz = viscsubface(nn)%tau(i, j, 5)
   tauyz = viscsubface(nn)%tau(i, j, 6)
   ! Compute the velocities at the wall face; these are only
   ! non-zero for moving a block. Also compute the density,
   ! which is needed to compute the wall shear stress via
   ! wall functions.
   CALL PUSHREAL8(rbar)
   rbar = half*(ww2(i, j, irho)+ww1(i, j, irho))
   CALL PUSHREAL8(ubar)
   ubar = half*(ww2(i, j, ivx)+ww1(i, j, ivx))
   CALL PUSHREAL8(vbar)
   vbar = half*(ww2(i, j, ivy)+ww1(i, j, ivy))
   CALL PUSHREAL8(wbar)
   wbar = half*(ww2(i, j, ivz)+ww1(i, j, ivz))
   ! Compute the velocity difference between the internal cell
   ! and the wall.
   vx = ww2(i, j, ivx) - ubar
   vy = ww2(i, j, ivy) - vbar
   vz = ww2(i, j, ivz) - wbar
   ! Compute the normal velocity of the internal cell.
   veln = vx*norm(i, j, 1) + vy*norm(i, j, 2) + vz*norm(i, j, 3)
   velnx = veln*norm(i, j, 1)
   velny = veln*norm(i, j, 2)
   velnz = veln*norm(i, j, 3)
   ! Compute the tangential velocity, its magnitude and its
   ! unit vector of the internal cell.
   CALL PUSHREAL8(veltx)
   veltx = vx - velnx
   CALL PUSHREAL8(velty)
   velty = vy - velny
   CALL PUSHREAL8(veltz)
   veltz = vz - velnz
   y1 = SQRT(veltx**2 + velty**2 + veltz**2)
   IF (eps .LT. y1) THEN
   CALL PUSHREAL8(veltmag)
   veltmag = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(veltmag)
   veltmag = eps
   CALL PUSHCONTROL1B(1)
   END IF
   tx = veltx/veltmag
   ty = velty/veltmag
   tz = veltz/veltmag
   ! Compute some coefficients needed for the transformation
   ! between the cartesian frame and the frame defined by the
   ! tangential direction (tx,ty,tz) and the normal direction.
   ! The minus sign is present, because for this transformation
   ! the normal direction should be inward pointing and norm
   ! is outward pointing.
   txnx = -(tx*norm(i, j, 1))
   txny = -(tx*norm(i, j, 2))
   txnz = -(tx*norm(i, j, 3))
   tynx = -(ty*norm(i, j, 1))
   tyny = -(ty*norm(i, j, 2))
   tynz = -(ty*norm(i, j, 3))
   tznx = -(tz*norm(i, j, 1))
   tzny = -(tz*norm(i, j, 2))
   tznz = -(tz*norm(i, j, 3))
   ! Compute the tn component of the wall shear stress
   ! tensor. Normally this is the only nonzero shear
   ! stress component in the t-n frame.
   CALL PUSHREAL8(tautn)
   tautn = tauxx*txnx + tauyy*tyny + tauzz*tznz + tauxy*(txny+&
   &           tynx) + tauxz*(txnz+tznx) + tauyz*(tynz+tzny)
   ! Compute the Reynolds number using the velocity, density,
   ! laminar viscosity and wall distance. Note that an offset
   ! of -1 must be used in dd2Wall2, because the original array
   ! d2Wall starts at 2.
   CALL PUSHREAL8(re)
   re = ww2(i, j, irho)*veltmag*dd2wall2(i-1, j-1)/rrlv2(i, j)
   x1 = CURVEUPRE(re)
   IF (x1 .LT. eps) THEN
   CALL PUSHREAL8(max1)
   max1 = eps
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max1)
   max1 = x1
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the friction velocity from the table and
   ! compute the wall shear stress from it.
   CALL PUSHREAL8(utau)
   utau = veltmag/max1
   tauwall = rbar*utau*utau
   ! Compute the correction to the wall shear stress tautn and
   ! transform this correction back to the cartesian frame.
   ! Take rFilv into account, such that the correction to the
   ! stress tensor is computed correctly.
   tautn = rfilv*tauwall - tautn
   CALL PUSHREAL8(tauxx)
   tauxx = two*tautn*txnx
   CALL PUSHREAL8(tauyy)
   tauyy = two*tautn*tyny
   CALL PUSHREAL8(tauzz)
   tauzz = two*tautn*tznz
   CALL PUSHREAL8(tauxy)
   tauxy = tautn*(txny+tynx)
   CALL PUSHREAL8(tauxz)
   tauxz = tautn*(txnz+tznx)
   CALL PUSHREAL8(tauyz)
   tauyz = tautn*(tynz+tzny)
   ! Compute the correction to the viscous flux at the wall.
   fmx = tauxx*ss(i, j, 1) + tauxy*ss(i, j, 2) + tauxz*ss(i, j, 3&
   &           )
   fmy = tauxy*ss(i, j, 1) + tauyy*ss(i, j, 2) + tauyz*ss(i, j, 3&
   &           )
   fmz = tauxz*ss(i, j, 1) + tauyz*ss(i, j, 2) + tauzz*ss(i, j, 3&
   &           )
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*ss(i, j, 1) + (ubar&
   &           *tauxy+vbar*tauyy+wbar*tauyz)*ss(i, j, 2) + (ubar*tauxz+vbar&
   &           *tauyz+wbar*tauzz)*ss(i, j, 3)
   ! Add them to the residual. Note that now the factor rFilv
   ! is already taken into account via tau. Fact is present to
   ! take inward/outward pointing normals into account
   rres(i, j, imx) = rres(i, j, imx) - fact*fmx
   rres(i, j, imy) = rres(i, j, imy) - fact*fmy
   rres(i, j, imz) = rres(i, j, imz) - fact*fmz
   rres(i, j, irhoe) = rres(i, j, irhoe) - fact*frhoe
   ! Store the friction velocity for later use.
   ! Also add the correction to the wall stress tensor.
   viscsubface(nn)%tau(i, j, 1) = viscsubface(nn)%tau(i, j, 1) + &
   &           tauxx
   viscsubface(nn)%tau(i, j, 2) = viscsubface(nn)%tau(i, j, 2) + &
   &           tauyy
   viscsubface(nn)%tau(i, j, 3) = viscsubface(nn)%tau(i, j, 3) + &
   &           tauzz
   viscsubface(nn)%tau(i, j, 4) = viscsubface(nn)%tau(i, j, 4) + &
   &           tauxy
   viscsubface(nn)%tau(i, j, 5) = viscsubface(nn)%tau(i, j, 5) + &
   &           tauxz
   viscsubface(nn)%tau(i, j, 6) = viscsubface(nn)%tau(i, j, 6) + &
   &           tauyz
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO viscsubfaces
   rlvb = 0.0_8
   DO ii1=1,SIZE(viscsubfaceb(ii1)%tau, 1)
   viscsubfaceb(ii1)%tau = 0.0_8
   END DO
   DO nn=nviscbocos,1,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   frhoeb = -(fact*rresb(i, j, irhoe))
   fmzb = -(fact*rresb(i, j, imz))
   fmyb = -(fact*rresb(i, j, imy))
   fmxb = -(fact*rresb(i, j, imx))
   tempb4 = ss(i, j, 1)*frhoeb
   tempb2 = ss(i, j, 2)*frhoeb
   tempb3 = ss(i, j, 3)*frhoeb
   ty = velty/veltmag
   tz = veltz/veltmag
   tzny = -(tz*norm(i, j, 2))
   tynz = -(ty*norm(i, j, 3))
   tauyz = tautn*(tynz+tzny)
   tauyzb = wbar*tempb2 + vbar*tempb3 + ss(i, j, 3)*fmyb + ss(i, &
   &           j, 2)*fmzb + viscsubfaceb(nn)%tau(i, j, 6)
   tx = veltx/veltmag
   txnz = -(tx*norm(i, j, 3))
   tznx = -(tz*norm(i, j, 1))
   tauxz = tautn*(txnz+tznx)
   tauxzb = wbar*tempb4 + ubar*tempb3 + ss(i, j, 3)*fmxb + ss(i, &
   &           j, 1)*fmzb + viscsubfaceb(nn)%tau(i, j, 5)
   txny = -(tx*norm(i, j, 2))
   tynx = -(ty*norm(i, j, 1))
   tauxy = tautn*(txny+tynx)
   tauxyb = vbar*tempb4 + ubar*tempb2 + ss(i, j, 2)*fmxb + ss(i, &
   &           j, 1)*fmyb + viscsubfaceb(nn)%tau(i, j, 4)
   tznz = -(tz*norm(i, j, 3))
   tauzz = two*tautn*tznz
   tauzzb = wbar*tempb3 + ss(i, j, 3)*fmzb + viscsubfaceb(nn)%tau&
   &           (i, j, 3)
   tyny = -(ty*norm(i, j, 2))
   tauyy = two*tautn*tyny
   tauyyb = vbar*tempb2 + ss(i, j, 2)*fmyb + viscsubfaceb(nn)%tau&
   &           (i, j, 2)
   txnx = -(tx*norm(i, j, 1))
   tauxx = two*tautn*txnx
   tauxxb = ubar*tempb4 + ss(i, j, 1)*fmxb + viscsubfaceb(nn)%tau&
   &           (i, j, 1)
   ubarb = tauxz*tempb3 + tauxy*tempb2 + tauxx*tempb4
   vbarb = tauyz*tempb3 + tauyy*tempb2 + tauxy*tempb4
   wbarb = tauzz*tempb3 + tauyz*tempb2 + tauxz*tempb4
   CALL POPREAL8(tauyz)
   tautnb = (txnz+tznx)*tauxzb + two*tznz*tauzzb + two*txnx*&
   &           tauxxb + two*tyny*tauyyb + (txny+tynx)*tauxyb + (tynz+tzny)*&
   &           tauyzb
   tynzb = tautn*tauyzb
   tznyb = tautn*tauyzb
   CALL POPREAL8(tauxz)
   txnzb = tautn*tauxzb
   tznxb = tautn*tauxzb
   CALL POPREAL8(tauxy)
   txnyb = tautn*tauxyb
   tynxb = tautn*tauxyb
   CALL POPREAL8(tauzz)
   tznzb = two*tautn*tauzzb
   CALL POPREAL8(tauyy)
   tynyb = two*tautn*tauyyb
   CALL POPREAL8(tauxx)
   txnxb = two*tautn*tauxxb
   tauwallb = rfilv*tautnb
   tautnb = -tautnb
   rbarb = utau**2*tauwallb
   utaub = rbar*2*utau*tauwallb
   CALL POPREAL8(utau)
   veltmagb = utaub/max1
   max1b = -(veltmag*utaub/max1**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max1)
   x1b = 0.0_8
   ELSE
   CALL POPREAL8(max1)
   x1b = max1b
   END IF
   txnxb = txnxb + tauxx*tautnb
   tynyb = tynyb + tauyy*tautnb
   tznzb = tznzb + tauzz*tautnb
   txnyb = txnyb + tauxy*tautnb
   tynxb = tynxb + tauxy*tautnb
   txnzb = txnzb + tauxz*tautnb
   tznxb = tznxb + tauxz*tautnb
   tynzb = tynzb + tauyz*tautnb
   tznyb = tznyb + tauyz*tautnb
   tzb = -(norm(i, j, 2)*tznyb) - norm(i, j, 1)*tznxb - norm(i, j&
   &           , 3)*tznzb
   tyb = -(norm(i, j, 2)*tynyb) - norm(i, j, 1)*tynxb - norm(i, j&
   &           , 3)*tynzb
   txb = -(norm(i, j, 2)*txnyb) - norm(i, j, 1)*txnxb - norm(i, j&
   &           , 3)*txnzb
   CALL CURVEUPRE_B(re, reb, x1b)
   CALL POPREAL8(re)
   temp0 = rrlv2(i, j)
   temp = veltmag/temp0
   tempb0 = dd2wall2(i-1, j-1)*reb
   tempb1 = ww2(i, j, irho)*tempb0/temp0
   ww2b(i, j, irho) = ww2b(i, j, irho) + temp*tempb0
   veltmagb = veltmagb + tempb1 - veltx*txb/veltmag**2 - velty*&
   &           tyb/veltmag**2 - veltz*tzb/veltmag**2
   rrlv2b(i, j) = rrlv2b(i, j) - temp*tempb1
   CALL POPREAL8(tautn)
   tauxxb = txnx*tautnb
   tauyyb = tyny*tautnb
   tauzzb = tznz*tautnb
   tauxyb = (txny+tynx)*tautnb
   tauxzb = (txnz+tznx)*tautnb
   tauyzb = (tynz+tzny)*tautnb
   veltzb = tzb/veltmag
   veltyb = tyb/veltmag
   veltxb = txb/veltmag
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(veltmag)
   y1b = veltmagb
   ELSE
   CALL POPREAL8(veltmag)
   y1b = 0.0_8
   END IF
   IF (veltx**2 + velty**2 + veltz**2 .EQ. 0.0_8) THEN
   tempb = 0.0
   ELSE
   tempb = y1b/(2.0*SQRT(veltx**2+velty**2+veltz**2))
   END IF
   veltxb = veltxb + 2*veltx*tempb
   veltyb = veltyb + 2*velty*tempb
   veltzb = veltzb + 2*veltz*tempb
   CALL POPREAL8(veltz)
   velnzb = -veltzb
   CALL POPREAL8(velty)
   velnyb = -veltyb
   CALL POPREAL8(veltx)
   velnxb = -veltxb
   velnb = norm(i, j, 2)*velnyb + norm(i, j, 1)*velnxb + norm(i, &
   &           j, 3)*velnzb
   vzb = norm(i, j, 3)*velnb + veltzb
   vyb = norm(i, j, 2)*velnb + veltyb
   vxb = norm(i, j, 1)*velnb + veltxb
   ww2b(i, j, ivz) = ww2b(i, j, ivz) + vzb
   wbarb = wbarb - vzb
   ww2b(i, j, ivy) = ww2b(i, j, ivy) + vyb
   vbarb = vbarb - vyb
   ww2b(i, j, ivx) = ww2b(i, j, ivx) + vxb
   ubarb = ubarb - vxb
   CALL POPREAL8(wbar)
   ww2b(i, j, ivz) = ww2b(i, j, ivz) + half*wbarb
   ww1b(i, j, ivz) = ww1b(i, j, ivz) + half*wbarb
   CALL POPREAL8(vbar)
   ww2b(i, j, ivy) = ww2b(i, j, ivy) + half*vbarb
   ww1b(i, j, ivy) = ww1b(i, j, ivy) + half*vbarb
   CALL POPREAL8(ubar)
   ww2b(i, j, ivx) = ww2b(i, j, ivx) + half*ubarb
   ww1b(i, j, ivx) = ww1b(i, j, ivx) + half*ubarb
   CALL POPREAL8(rbar)
   ww2b(i, j, irho) = ww2b(i, j, irho) + half*rbarb
   ww1b(i, j, irho) = ww1b(i, j, irho) + half*rbarb
   viscsubfaceb(nn)%tau(i, j, 6) = viscsubfaceb(nn)%tau(i, j, 6) &
   &           + tauyzb
   viscsubfaceb(nn)%tau(i, j, 5) = viscsubfaceb(nn)%tau(i, j, 5) &
   &           + tauxzb
   viscsubfaceb(nn)%tau(i, j, 4) = viscsubfaceb(nn)%tau(i, j, 4) &
   &           + tauxyb
   viscsubfaceb(nn)%tau(i, j, 3) = viscsubfaceb(nn)%tau(i, j, 3) &
   &           + tauzzb
   viscsubfaceb(nn)%tau(i, j, 2) = viscsubfaceb(nn)%tau(i, j, 2) &
   &           + tauyyb
   viscsubfaceb(nn)%tau(i, j, 1) = viscsubfaceb(nn)%tau(i, j, 1) &
   &           + tauxxb
   END DO
   END DO
   CALL POPPOINTER4(norm)
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .NE. 0) THEN
   IF (branch .EQ. 1) THEN
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(fact)
   ELSE
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(fact)
   END IF
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(fact)
   ELSE
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(fact)
   END IF
   ELSE IF (branch .EQ. 5) THEN
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(fact)
   ELSE
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPREAL8(fact)
   END IF
   END DO
   END IF
   END SUBROUTINE UTAUWF_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of computegamma in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: gamma t
   !   with respect to varying inputs: t
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          computeGamma.f90                                *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 09-16-2003                                      *
   !      * Last modified: 03-23-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE COMPUTEGAMMA_B(t, td, gamma, gammad, mm)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * computeGamma computes the corresponding values of gamma for    *
   !      * the given dimensional temperatures.                            *
   !      *                                                                *
   !      ******************************************************************
   !
   USE CONSTANTS
   USE CPCURVEFITS
   USE INPUTPHYSICS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: mm
   !
   !      Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(mm), INTENT(IN) :: t
   REAL(kind=realtype), DIMENSION(mm) :: td
   REAL(kind=realtype), DIMENSION(mm) :: gamma
   REAL(kind=realtype), DIMENSION(mm) :: gammad
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, ii, nn, start
   REAL(kind=realtype) :: cp, t2
   REAL(kind=realtype) :: cpd, t2d
   INTEGER :: ad_count
   INTEGER :: i0
   INTEGER :: branch
   INTEGER :: ad_to
   REAL(kind=realtype) :: tempd
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the cp model used in the computation.
   SELECT CASE  (cpmodel) 
   CASE (cpconstant) 
      CASE (cptempcurvefits) 
   !        ================================================================
   ! Cp as function of the temperature is given via curve fits.
   DO i=1,mm
   ! Determine the case we are having here.
   IF (t(i) .LE. cptrange(0)) THEN
   CALL PUSHCONTROL2B(2)
   ELSE IF (t(i) .GE. cptrange(cpnparts)) THEN
   CALL PUSHCONTROL2B(1)
   ELSE
   ! Temperature is in the curve fit range.
   ! First find the valid range.
   ii = cpnparts
   start = 1
   ad_count = 1
   ! Next guess for the interval.
   100    CALL PUSHINTEGER4(nn)
   nn = start + ii/2
   ! Determine the situation we are having here.
   IF (t(i) .GT. cptrange(nn)) THEN
   CALL PUSHCONTROL1B(0)
   ! Temperature is larger than the upper boundary of
   ! the current interval. Update the lower boundary.
   start = nn + 1
   ii = ii - 1
   ELSE IF (t(i) .GE. cptrange(nn-1)) THEN
   GOTO 110
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! This is the correct range. Exit the do-loop.
   ! Modify ii for the next branch to search.
   ii = ii/2
   ad_count = ad_count + 1
   GOTO 100
   110    CALL PUSHINTEGER4(ad_count)
   ! Nn contains the correct curve fit interval.
   ! Compute the value of cp.
   CALL PUSHREAL8(cp)
   cp = zero
   DO ii=1,cptempfit(nn)%nterm
   t2 = t(i)**cptempfit(nn)%exponents(ii)
   cp = cp + cptempfit(nn)%constants(ii)*t2
   END DO
   CALL PUSHINTEGER4(ii - 1)
   CALL PUSHCONTROL2B(0)
   END IF
   END DO
   DO i=mm,1,-1
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   tempd = gammad(i)/(cp-one)
   cpd = (1.0_8-cp/(cp-one))*tempd
   gammad(i) = 0.0_8
   CALL POPINTEGER4(ad_to)
   DO ii=ad_to,1,-1
   t2d = cptempfit(nn)%constants(ii)*cpd
   IF (.NOT.(t(i) .LE. 0.0_8 .AND. (cptempfit(nn)%exponents(ii) &
   &             .EQ. 0.0_8 .OR. cptempfit(nn)%exponents(ii) .NE. INT(&
   &             cptempfit(nn)%exponents(ii))))) td(i) = td(i) + cptempfit(&
   &             nn)%exponents(ii)*t(i)**(cptempfit(nn)%exponents(ii)-1)*&
   &             t2d
   END DO
   CALL POPREAL8(cp)
   CALL POPINTEGER4(ad_count)
   DO i0=1,ad_count
   IF (i0 .NE. 1) CALL POPCONTROL1B(branch)
   CALL POPINTEGER4(nn)
   END DO
   ELSE IF (branch .EQ. 1) THEN
   gammad(i) = 0.0_8
   ELSE
   gammad(i) = 0.0_8
   END IF
   END DO
   END SELECT
   END SUBROUTINE COMPUTEGAMMA_B

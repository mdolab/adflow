   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of turbadvection in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *dw *w *vol *si *sj *sk
   !   with respect to varying inputs: *dw *w *vol *si *sj *sk
   !   Plus diff mem management of: dw:in w:in vol:in si:in sj:in
   !                sk:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          turbAdvection.f90                               *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 09-01-2003                                      *
   !      * Last modified: 04-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE TURBADVECTION_B(madv, nadv, offset, qq)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * turbAdvection discretizes the advection part of the turbulent  *
   !      * transport equations. As the advection part is the same for all *
   !      * models, this generic routine can be used. Both the             *
   !      * discretization and the central jacobian are computed in this   *
   !      * subroutine. The former can either be 1st or 2nd order          *
   !      * accurate; the latter is always based on the 1st order upwind   *
   !      * discretization. When the discretization must be second order   *
   !      * accurate, the fully upwind (kappa = -1) scheme in combination  *
   !      * with the minmod limiter is used.                               *
   !      *                                                                *
   !      * Only nAdv equations are treated, while the actual system has   *
   !      * size mAdv. The reason is that some equations for some          *
   !      * turbulence equations do not have an advection part, e.g. the   *
   !      * f equation in the v2-f model. The argument offset indicates    *
   !      * the offset in the w vector where this subsystem starts. As a   *
   !      * consequence it is assumed that the indices of the current      *
   !      * subsystem are contiguous, e.g. if a 2*2 system is solved the   *
   !      * Last index in w is offset+1 and offset+2 respectively.         *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE TURBMOD
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: nadv, madv, offset
   REAL(kind=realtype), DIMENSION(2:il, 2:jl, 2:kl, madv, madv), INTENT(&
   & INOUT) :: qq
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ii, jj, kk
   REAL(kind=realtype) :: qs, voli, xa, ya, za
   REAL(kind=realtype) :: qsd, volid, xad, yad, zad
   REAL(kind=realtype) :: uu, dwt, dwtm1, dwtp1, dwti, dwtj, dwtk
   REAL(kind=realtype) :: uud, dwtd, dwtm1d, dwtp1d, dwtid, dwtjd, dwtkd
   REAL(kind=realtype), DIMENSION(madv) :: impl
   INTRINSIC ABS
   INTRINSIC MAX
   INTEGER :: branch
   REAL(kind=realtype) :: abs23
   REAL(kind=realtype) :: abs22
   REAL(kind=realtype) :: abs21
   REAL(kind=realtype) :: abs20
   REAL(kind=realtype) :: abs19
   REAL(kind=realtype) :: abs18
   REAL(kind=realtype) :: abs17
   REAL(kind=realtype) :: abs16
   REAL(kind=realtype) :: abs15
   REAL(kind=realtype) :: abs14
   REAL(kind=realtype) :: abs13
   REAL(kind=realtype) :: abs12
   REAL(kind=realtype) :: abs11
   REAL(kind=realtype) :: abs10
   REAL(kind=realtype) :: abs9
   REAL(kind=realtype) :: abs8
   REAL(kind=realtype) :: abs7
   REAL(kind=realtype) :: abs6
   REAL(kind=realtype) :: abs5
   REAL(kind=realtype) :: abs4
   REAL(kind=realtype) :: abs3
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: abs0
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Initialize the grid velocity to zero. This value will be used
   ! if the block is not moving.
   qs = zero
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Upwind discretization of the convective term in k (zeta)       *
   !      * direction. Either the 1st order upwind or the second order     *
   !      * fully upwind interpolation scheme, kappa = -1, is used in      *
   !      * combination with the minmod limiter.                           *
   !      * The possible grid velocity must be taken into account.         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the grid velocity if present.
   ! It is taken as the average of k and k-1,
   voli = half/vol(i, j, k)
   IF (addgridvelocities) THEN
   qs = (sfacek(i, j, k)+sfacek(i, j, k-1))*voli
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the normal velocity, where the normal direction
   ! is taken as the average of faces k and k-1.
   xa = (sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
   ya = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
   za = (sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
   CALL PUSHREAL8(uu)
   uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, ivz&
   &         ) - qs
   ! Determine the situation we are having here, i.e. positive
   ! or negative normal velocity.
   IF (uu .GT. zero) THEN
   ! Velocity has a component in positive k-direction.
   ! Loop over the number of advection equations.
   DO ii=1,nadv
   ! Set the value of jj such that it corresponds to the
   ! turbulent entry in w.
   jj = ii + offset
   ! Check whether a first or a second order discretization
   ! must be used.
   IF (secondord) THEN
   ! Second order; store the three differences for the
   ! discretization of the derivative in k-direction.
   dwtm1 = w(i, j, k-1, jj) - w(i, j, k-2, jj)
   dwt = w(i, j, k, jj) - w(i, j, k-1, jj)
   dwtp1 = w(i, j, k+1, jj) - w(i, j, k, jj)
   ! Construct the derivative in this cell center. This
   ! is the first order upwind derivative with two
   ! nonlinear corrections.
   CALL PUSHREAL8(dwtk)
   dwtk = dwt
   IF (dwt*dwtp1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs0 = dwt
   ELSE
   abs0 = -dwt
   END IF
   IF (dwtp1 .GE. 0.) THEN
   abs12 = dwtp1
   ELSE
   abs12 = -dwtp1
   END IF
   IF (abs0 .LT. abs12) THEN
   dwtk = dwtk + half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtk = dwtk + half*dwtp1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   IF (dwt*dwtm1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs1 = dwt
   ELSE
   abs1 = -dwt
   END IF
   IF (dwtm1 .GE. 0.) THEN
   abs13 = dwtm1
   ELSE
   abs13 = -dwtm1
   END IF
   IF (abs1 .LT. abs13) THEN
   dwtk = dwtk - half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtk = dwtk - half*dwtm1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   ELSE
   ! 1st order upwind scheme.
   CALL PUSHREAL8(dwtk)
   dwtk = w(i, j, k, jj) - w(i, j, k-1, jj)
   CALL PUSHCONTROL2B(3)
   END IF
   END DO
   CALL PUSHCONTROL1B(1)
   ELSE
   ! Velocity has a component in negative k-direction.
   ! Loop over the number of advection equations.
   DO ii=1,nadv
   ! Set the value of jj such that it corresponds to the
   ! turbulent entry in w.
   jj = ii + offset
   ! Check whether a first or a second order discretization
   ! must be used.
   IF (secondord) THEN
   ! Store the three differences for the discretization of
   ! the derivative in k-direction.
   dwtm1 = w(i, j, k, jj) - w(i, j, k-1, jj)
   dwt = w(i, j, k+1, jj) - w(i, j, k, jj)
   dwtp1 = w(i, j, k+2, jj) - w(i, j, k+1, jj)
   ! Construct the derivative in this cell center. This is
   ! the first order upwind derivative with two nonlinear
   ! corrections.
   CALL PUSHREAL8(dwtk)
   dwtk = dwt
   IF (dwt*dwtp1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs2 = dwt
   ELSE
   abs2 = -dwt
   END IF
   IF (dwtp1 .GE. 0.) THEN
   abs14 = dwtp1
   ELSE
   abs14 = -dwtp1
   END IF
   IF (abs2 .LT. abs14) THEN
   dwtk = dwtk - half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtk = dwtk - half*dwtp1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   IF (dwt*dwtm1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs3 = dwt
   ELSE
   abs3 = -dwt
   END IF
   IF (dwtm1 .GE. 0.) THEN
   abs15 = dwtm1
   ELSE
   abs15 = -dwtm1
   END IF
   IF (abs3 .LT. abs15) THEN
   dwtk = dwtk + half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtk = dwtk + half*dwtm1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   ELSE
   ! 1st order upwind scheme.
   CALL PUSHREAL8(dwtk)
   dwtk = w(i, j, k+1, jj) - w(i, j, k, jj)
   CALL PUSHCONTROL2B(3)
   END IF
   END DO
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Upwind discretization of the convective term in j (eta)        *
   !      * direction. Either the 1st order upwind or the second order     *
   !      * fully upwind interpolation scheme, kappa = -1, is used in      *
   !      * combination with the minmod limiter.                           *
   !      * The possible grid velocity must be taken into account.         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the grid velocity if present.
   ! It is taken as the average of j and j-1,
   voli = half/vol(i, j, k)
   IF (addgridvelocities) THEN
   qs = (sfacej(i, j, k)+sfacej(i, j-1, k))*voli
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the normal velocity, where the normal direction
   ! is taken as the average of faces j and j-1.
   xa = (sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
   ya = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
   za = (sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
   CALL PUSHREAL8(uu)
   uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, ivz&
   &         ) - qs
   ! Determine the situation we are having here, i.e. positive
   ! or negative normal velocity.
   IF (uu .GT. zero) THEN
   ! Velocity has a component in positive j-direction.
   ! Loop over the number of advection equations.
   DO ii=1,nadv
   ! Set the value of jj such that it corresponds to the
   ! turbulent entry in w.
   jj = ii + offset
   ! Check whether a first or a second order discretization
   ! must be used.
   IF (secondord) THEN
   ! Second order; store the three differences for the
   ! discretization of the derivative in j-direction.
   dwtm1 = w(i, j-1, k, jj) - w(i, j-2, k, jj)
   dwt = w(i, j, k, jj) - w(i, j-1, k, jj)
   dwtp1 = w(i, j+1, k, jj) - w(i, j, k, jj)
   ! Construct the derivative in this cell center. This is
   ! the first order upwind derivative with two nonlinear
   ! corrections.
   CALL PUSHREAL8(dwtj)
   dwtj = dwt
   IF (dwt*dwtp1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs4 = dwt
   ELSE
   abs4 = -dwt
   END IF
   IF (dwtp1 .GE. 0.) THEN
   abs16 = dwtp1
   ELSE
   abs16 = -dwtp1
   END IF
   IF (abs4 .LT. abs16) THEN
   dwtj = dwtj + half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtj = dwtj + half*dwtp1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   IF (dwt*dwtm1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs5 = dwt
   ELSE
   abs5 = -dwt
   END IF
   IF (dwtm1 .GE. 0.) THEN
   abs17 = dwtm1
   ELSE
   abs17 = -dwtm1
   END IF
   IF (abs5 .LT. abs17) THEN
   dwtj = dwtj - half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtj = dwtj - half*dwtm1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   ELSE
   ! 1st order upwind scheme.
   CALL PUSHREAL8(dwtj)
   dwtj = w(i, j, k, jj) - w(i, j-1, k, jj)
   CALL PUSHCONTROL2B(3)
   END IF
   END DO
   CALL PUSHCONTROL1B(1)
   ELSE
   ! Velocity has a component in negative j-direction.
   ! Loop over the number of advection equations.
   DO ii=1,nadv
   ! Set the value of jj such that it corresponds to the
   ! turbulent entry in w.
   jj = ii + offset
   ! Check whether a first or a second order discretization
   ! must be used.
   IF (secondord) THEN
   ! Store the three differences for the discretization of
   ! the derivative in j-direction.
   dwtm1 = w(i, j, k, jj) - w(i, j-1, k, jj)
   dwt = w(i, j+1, k, jj) - w(i, j, k, jj)
   dwtp1 = w(i, j+2, k, jj) - w(i, j+1, k, jj)
   ! Construct the derivative in this cell center. This is
   ! the first order upwind derivative with two nonlinear
   ! corrections.
   CALL PUSHREAL8(dwtj)
   dwtj = dwt
   IF (dwt*dwtp1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs6 = dwt
   ELSE
   abs6 = -dwt
   END IF
   IF (dwtp1 .GE. 0.) THEN
   abs18 = dwtp1
   ELSE
   abs18 = -dwtp1
   END IF
   IF (abs6 .LT. abs18) THEN
   dwtj = dwtj - half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtj = dwtj - half*dwtp1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   IF (dwt*dwtm1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs7 = dwt
   ELSE
   abs7 = -dwt
   END IF
   IF (dwtm1 .GE. 0.) THEN
   abs19 = dwtm1
   ELSE
   abs19 = -dwtm1
   END IF
   IF (abs7 .LT. abs19) THEN
   dwtj = dwtj + half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwtj = dwtj + half*dwtm1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   ELSE
   ! 1st order upwind scheme.
   CALL PUSHREAL8(dwtj)
   dwtj = w(i, j+1, k, jj) - w(i, j, k, jj)
   CALL PUSHCONTROL2B(3)
   END IF
   END DO
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   END DO
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Upwind discretization of the convective term in i (xi)         *
   !      * direction. Either the 1st order upwind or the second order     *
   !      * fully upwind interpolation scheme, kappa = -1, is used in      *
   !      * combination with the minmod limiter.                           *
   !      * The possible grid velocity must be taken into account.         *
   !      *                                                                *
   !      ******************************************************************
   !
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! Compute the grid velocity if present.
   ! It is taken as the average of i and i-1,
   voli = half/vol(i, j, k)
   IF (addgridvelocities) THEN
   qs = (sfacei(i, j, k)+sfacei(i-1, j, k))*voli
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the normal velocity, where the normal direction
   ! is taken as the average of faces i and i-1.
   xa = (si(i, j, k, 1)+si(i-1, j, k, 1))*voli
   ya = (si(i, j, k, 2)+si(i-1, j, k, 2))*voli
   za = (si(i, j, k, 3)+si(i-1, j, k, 3))*voli
   CALL PUSHREAL8(uu)
   uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, ivz&
   &         ) - qs
   ! Determine the situation we are having here, i.e. positive
   ! or negative normal velocity.
   IF (uu .GT. zero) THEN
   ! Velocity has a component in positive i-direction.
   ! Loop over the number of advection equations.
   DO ii=1,nadv
   ! Set the value of jj such that it corresponds to the
   ! turbulent entry in w.
   jj = ii + offset
   ! Check whether a first or a second order discretization
   ! must be used.
   IF (secondord) THEN
   ! Second order; store the three differences for the
   ! discretization of the derivative in i-direction.
   dwtm1 = w(i-1, j, k, jj) - w(i-2, j, k, jj)
   dwt = w(i, j, k, jj) - w(i-1, j, k, jj)
   dwtp1 = w(i+1, j, k, jj) - w(i, j, k, jj)
   ! Construct the derivative in this cell center. This is
   ! the first order upwind derivative with two nonlinear
   ! corrections.
   CALL PUSHREAL8(dwti)
   dwti = dwt
   IF (dwt*dwtp1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs8 = dwt
   ELSE
   abs8 = -dwt
   END IF
   IF (dwtp1 .GE. 0.) THEN
   abs20 = dwtp1
   ELSE
   abs20 = -dwtp1
   END IF
   IF (abs8 .LT. abs20) THEN
   dwti = dwti + half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwti = dwti + half*dwtp1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   IF (dwt*dwtm1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs9 = dwt
   ELSE
   abs9 = -dwt
   END IF
   IF (dwtm1 .GE. 0.) THEN
   abs21 = dwtm1
   ELSE
   abs21 = -dwtm1
   END IF
   IF (abs9 .LT. abs21) THEN
   dwti = dwti - half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwti = dwti - half*dwtm1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   ELSE
   ! 1st order upwind scheme.
   CALL PUSHREAL8(dwti)
   dwti = w(i, j, k, jj) - w(i-1, j, k, jj)
   CALL PUSHCONTROL2B(3)
   END IF
   END DO
   CALL PUSHCONTROL1B(1)
   ELSE
   ! Velocity has a component in negative i-direction.
   ! Loop over the number of advection equations.
   DO ii=1,nadv
   ! Set the value of jj such that it corresponds to the
   ! turbulent entry in w.
   jj = ii + offset
   ! Check whether a first or a second order discretization
   ! must be used.
   IF (secondord) THEN
   ! Second order; store the three differences for the
   ! discretization of the derivative in i-direction.
   dwtm1 = w(i, j, k, jj) - w(i-1, j, k, jj)
   dwt = w(i+1, j, k, jj) - w(i, j, k, jj)
   dwtp1 = w(i+2, j, k, jj) - w(i+1, j, k, jj)
   ! Construct the derivative in this cell center. This is
   ! the first order upwind derivative with two nonlinear
   ! corrections.
   CALL PUSHREAL8(dwti)
   dwti = dwt
   IF (dwt*dwtp1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs10 = dwt
   ELSE
   abs10 = -dwt
   END IF
   IF (dwtp1 .GE. 0.) THEN
   abs22 = dwtp1
   ELSE
   abs22 = -dwtp1
   END IF
   IF (abs10 .LT. abs22) THEN
   dwti = dwti - half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwti = dwti - half*dwtp1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   IF (dwt*dwtm1 .GT. zero) THEN
   IF (dwt .GE. 0.) THEN
   abs11 = dwt
   ELSE
   abs11 = -dwt
   END IF
   IF (dwtm1 .GE. 0.) THEN
   abs23 = dwtm1
   ELSE
   abs23 = -dwtm1
   END IF
   IF (abs11 .LT. abs23) THEN
   dwti = dwti + half*dwt
   CALL PUSHCONTROL2B(0)
   ELSE
   dwti = dwti + half*dwtm1
   CALL PUSHCONTROL2B(1)
   END IF
   ELSE
   CALL PUSHCONTROL2B(2)
   END IF
   ELSE
   ! 1st order upwind scheme.
   CALL PUSHREAL8(dwti)
   dwti = w(i+1, j, k, jj) - w(i, j, k, jj)
   CALL PUSHCONTROL2B(3)
   END IF
   END DO
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   END DO
   qsd = 0.0_8
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   uud = 0.0_8
   DO 100 ii=nadv,1,-1
   uud = uud - dwti*dwd(i, j, k, idvt+ii-1)
   dwtid = -(uu*dwd(i, j, k, idvt+ii-1))
   jj = ii + offset
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   dwtd = half*dwtid
   dwtm1d = 0.0_8
   ELSE
   dwtm1d = half*dwtid
   dwtd = 0.0_8
   END IF
   ELSE IF (branch .EQ. 2) THEN
   dwtd = 0.0_8
   dwtm1d = 0.0_8
   ELSE
   CALL POPREAL8(dwti)
   wd(i+1, j, k, jj) = wd(i+1, j, k, jj) + dwtid
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtid
   GOTO 100
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   dwtd = dwtd - half*dwtid
   dwtp1d = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   dwtp1d = -(half*dwtid)
   ELSE
   dwtp1d = 0.0_8
   END IF
   CALL POPREAL8(dwti)
   dwtd = dwtd + dwtid
   wd(i+2, j, k, jj) = wd(i+2, j, k, jj) + dwtp1d
   wd(i+1, j, k, jj) = wd(i+1, j, k, jj) - dwtp1d
   wd(i+1, j, k, jj) = wd(i+1, j, k, jj) + dwtd
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtd
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtm1d
   wd(i-1, j, k, jj) = wd(i-1, j, k, jj) - dwtm1d
   100      CONTINUE
   ELSE
   uud = 0.0_8
   DO 110 ii=nadv,1,-1
   uud = uud - dwti*dwd(i, j, k, idvt+ii-1)
   dwtid = -(uu*dwd(i, j, k, idvt+ii-1))
   jj = ii + offset
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   dwtd = -(half*dwtid)
   dwtm1d = 0.0_8
   ELSE
   dwtm1d = -(half*dwtid)
   dwtd = 0.0_8
   END IF
   ELSE IF (branch .EQ. 2) THEN
   dwtd = 0.0_8
   dwtm1d = 0.0_8
   ELSE
   CALL POPREAL8(dwti)
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtid
   wd(i-1, j, k, jj) = wd(i-1, j, k, jj) - dwtid
   GOTO 110
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   dwtd = dwtd + half*dwtid
   dwtp1d = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   dwtp1d = half*dwtid
   ELSE
   dwtp1d = 0.0_8
   END IF
   CALL POPREAL8(dwti)
   dwtd = dwtd + dwtid
   wd(i+1, j, k, jj) = wd(i+1, j, k, jj) + dwtp1d
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtp1d
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtd
   wd(i-1, j, k, jj) = wd(i-1, j, k, jj) - dwtd
   wd(i-1, j, k, jj) = wd(i-1, j, k, jj) + dwtm1d
   wd(i-2, j, k, jj) = wd(i-2, j, k, jj) - dwtm1d
   110      CONTINUE
   END IF
   voli = half/vol(i, j, k)
   xa = (si(i, j, k, 1)+si(i-1, j, k, 1))*voli
   ya = (si(i, j, k, 2)+si(i-1, j, k, 2))*voli
   za = (si(i, j, k, 3)+si(i-1, j, k, 3))*voli
   CALL POPREAL8(uu)
   xad = w(i, j, k, ivx)*uud
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + xa*uud
   yad = w(i, j, k, ivy)*uud
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + ya*uud
   zad = w(i, j, k, ivz)*uud
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + za*uud
   qsd = qsd - uud
   sid(i, j, k, 3) = sid(i, j, k, 3) + voli*zad
   sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*zad
   volid = (si(i, j, k, 2)+si(i-1, j, k, 2))*yad + (si(i, j, k, 1)+&
   &         si(i-1, j, k, 1))*xad + (si(i, j, k, 3)+si(i-1, j, k, 3))*zad
   sid(i, j, k, 2) = sid(i, j, k, 2) + voli*yad
   sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*yad
   sid(i, j, k, 1) = sid(i, j, k, 1) + voli*xad
   sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*xad
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   volid = volid + (sfacei(i, j, k)+sfacei(i-1, j, k))*qsd
   qsd = 0.0_8
   END IF
   vold(i, j, k) = vold(i, j, k) - half*volid/vol(i, j, k)**2
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   uud = 0.0_8
   DO 120 ii=nadv,1,-1
   uud = uud - dwtj*dwd(i, j, k, idvt+ii-1)
   dwtjd = -(uu*dwd(i, j, k, idvt+ii-1))
   jj = ii + offset
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   dwtd = half*dwtjd
   dwtm1d = 0.0_8
   ELSE
   dwtm1d = half*dwtjd
   dwtd = 0.0_8
   END IF
   ELSE IF (branch .EQ. 2) THEN
   dwtd = 0.0_8
   dwtm1d = 0.0_8
   ELSE
   CALL POPREAL8(dwtj)
   wd(i, j+1, k, jj) = wd(i, j+1, k, jj) + dwtjd
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtjd
   GOTO 120
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   dwtd = dwtd - half*dwtjd
   dwtp1d = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   dwtp1d = -(half*dwtjd)
   ELSE
   dwtp1d = 0.0_8
   END IF
   CALL POPREAL8(dwtj)
   dwtd = dwtd + dwtjd
   wd(i, j+2, k, jj) = wd(i, j+2, k, jj) + dwtp1d
   wd(i, j+1, k, jj) = wd(i, j+1, k, jj) - dwtp1d
   wd(i, j+1, k, jj) = wd(i, j+1, k, jj) + dwtd
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtd
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtm1d
   wd(i, j-1, k, jj) = wd(i, j-1, k, jj) - dwtm1d
   120      CONTINUE
   ELSE
   uud = 0.0_8
   DO 130 ii=nadv,1,-1
   uud = uud - dwtj*dwd(i, j, k, idvt+ii-1)
   dwtjd = -(uu*dwd(i, j, k, idvt+ii-1))
   jj = ii + offset
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   dwtd = -(half*dwtjd)
   dwtm1d = 0.0_8
   ELSE
   dwtm1d = -(half*dwtjd)
   dwtd = 0.0_8
   END IF
   ELSE IF (branch .EQ. 2) THEN
   dwtd = 0.0_8
   dwtm1d = 0.0_8
   ELSE
   CALL POPREAL8(dwtj)
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtjd
   wd(i, j-1, k, jj) = wd(i, j-1, k, jj) - dwtjd
   GOTO 130
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   dwtd = dwtd + half*dwtjd
   dwtp1d = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   dwtp1d = half*dwtjd
   ELSE
   dwtp1d = 0.0_8
   END IF
   CALL POPREAL8(dwtj)
   dwtd = dwtd + dwtjd
   wd(i, j+1, k, jj) = wd(i, j+1, k, jj) + dwtp1d
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtp1d
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtd
   wd(i, j-1, k, jj) = wd(i, j-1, k, jj) - dwtd
   wd(i, j-1, k, jj) = wd(i, j-1, k, jj) + dwtm1d
   wd(i, j-2, k, jj) = wd(i, j-2, k, jj) - dwtm1d
   130      CONTINUE
   END IF
   voli = half/vol(i, j, k)
   xa = (sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
   ya = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
   za = (sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
   CALL POPREAL8(uu)
   xad = w(i, j, k, ivx)*uud
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + xa*uud
   yad = w(i, j, k, ivy)*uud
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + ya*uud
   zad = w(i, j, k, ivz)*uud
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + za*uud
   qsd = qsd - uud
   sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*zad
   sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*zad
   volid = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*yad + (sj(i, j, k, 1)+&
   &         sj(i, j-1, k, 1))*xad + (sj(i, j, k, 3)+sj(i, j-1, k, 3))*zad
   sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*yad
   sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*yad
   sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*xad
   sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*xad
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   volid = volid + (sfacej(i, j, k)+sfacej(i, j-1, k))*qsd
   qsd = 0.0_8
   END IF
   vold(i, j, k) = vold(i, j, k) - half*volid/vol(i, j, k)**2
   END DO
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   DO i=il,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   uud = 0.0_8
   DO 140 ii=nadv,1,-1
   uud = uud - dwtk*dwd(i, j, k, idvt+ii-1)
   dwtkd = -(uu*dwd(i, j, k, idvt+ii-1))
   jj = ii + offset
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   dwtd = half*dwtkd
   dwtm1d = 0.0_8
   ELSE
   dwtm1d = half*dwtkd
   dwtd = 0.0_8
   END IF
   ELSE IF (branch .EQ. 2) THEN
   dwtd = 0.0_8
   dwtm1d = 0.0_8
   ELSE
   CALL POPREAL8(dwtk)
   wd(i, j, k+1, jj) = wd(i, j, k+1, jj) + dwtkd
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtkd
   GOTO 140
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   dwtd = dwtd - half*dwtkd
   dwtp1d = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   dwtp1d = -(half*dwtkd)
   ELSE
   dwtp1d = 0.0_8
   END IF
   CALL POPREAL8(dwtk)
   dwtd = dwtd + dwtkd
   wd(i, j, k+2, jj) = wd(i, j, k+2, jj) + dwtp1d
   wd(i, j, k+1, jj) = wd(i, j, k+1, jj) - dwtp1d
   wd(i, j, k+1, jj) = wd(i, j, k+1, jj) + dwtd
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtd
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtm1d
   wd(i, j, k-1, jj) = wd(i, j, k-1, jj) - dwtm1d
   140      CONTINUE
   ELSE
   uud = 0.0_8
   DO 150 ii=nadv,1,-1
   uud = uud - dwtk*dwd(i, j, k, idvt+ii-1)
   dwtkd = -(uu*dwd(i, j, k, idvt+ii-1))
   jj = ii + offset
   CALL POPCONTROL2B(branch)
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) THEN
   dwtd = -(half*dwtkd)
   dwtm1d = 0.0_8
   ELSE
   dwtm1d = -(half*dwtkd)
   dwtd = 0.0_8
   END IF
   ELSE IF (branch .EQ. 2) THEN
   dwtd = 0.0_8
   dwtm1d = 0.0_8
   ELSE
   CALL POPREAL8(dwtk)
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtkd
   wd(i, j, k-1, jj) = wd(i, j, k-1, jj) - dwtkd
   GOTO 150
   END IF
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   dwtd = dwtd + half*dwtkd
   dwtp1d = 0.0_8
   ELSE IF (branch .EQ. 1) THEN
   dwtp1d = half*dwtkd
   ELSE
   dwtp1d = 0.0_8
   END IF
   CALL POPREAL8(dwtk)
   dwtd = dwtd + dwtkd
   wd(i, j, k+1, jj) = wd(i, j, k+1, jj) + dwtp1d
   wd(i, j, k, jj) = wd(i, j, k, jj) - dwtp1d
   wd(i, j, k, jj) = wd(i, j, k, jj) + dwtd
   wd(i, j, k-1, jj) = wd(i, j, k-1, jj) - dwtd
   wd(i, j, k-1, jj) = wd(i, j, k-1, jj) + dwtm1d
   wd(i, j, k-2, jj) = wd(i, j, k-2, jj) - dwtm1d
   150      CONTINUE
   END IF
   voli = half/vol(i, j, k)
   xa = (sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
   ya = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
   za = (sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
   CALL POPREAL8(uu)
   xad = w(i, j, k, ivx)*uud
   wd(i, j, k, ivx) = wd(i, j, k, ivx) + xa*uud
   yad = w(i, j, k, ivy)*uud
   wd(i, j, k, ivy) = wd(i, j, k, ivy) + ya*uud
   zad = w(i, j, k, ivz)*uud
   wd(i, j, k, ivz) = wd(i, j, k, ivz) + za*uud
   qsd = qsd - uud
   skd(i, j, k, 3) = skd(i, j, k, 3) + voli*zad
   skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*zad
   volid = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*yad + (sk(i, j, k, 1)+&
   &         sk(i, j, k-1, 1))*xad + (sk(i, j, k, 3)+sk(i, j, k-1, 3))*zad
   skd(i, j, k, 2) = skd(i, j, k, 2) + voli*yad
   skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*yad
   skd(i, j, k, 1) = skd(i, j, k, 1) + voli*xad
   skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*xad
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   volid = volid + (sfacek(i, j, k)+sfacek(i, j, k-1))*qsd
   qsd = 0.0_8
   END IF
   vold(i, j, k) = vold(i, j, k) - half*volid/vol(i, j, k)**2
   END DO
   END DO
   END DO
   END SUBROUTINE TURBADVECTION_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of xhalo_block in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *x
   !   with respect to varying inputs: *x
   !   Plus diff mem management of: x:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          xhalo.f90                                       *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader            *
   !      * Starting date: 02-23-2003                                      *
   !      * Last modified: 08-12-2009                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE XHALO_BLOCK_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * xhalo determines the coordinates of the nodal halo's.          *
   !      * First it sets all halo coordinates by simple extrapolation,    *
   !      * then the symmetry planes are treated (also the unit normal of  *
   !      * symmetry planes are determined) and finally an exchange is     *
   !      * made for the internal halo's.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE COMMUNICATION
   USE INPUTTIMESPECTRAL
   IMPLICIT NONE
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm, i, j, k
   INTEGER(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
   LOGICAL :: err
   REAL(kind=realtype) :: length, dot
   REAL(kind=realtype) :: dotd
   REAL(kind=realtype), DIMENSION(3) :: v1, v2, norm
   REAL(kind=realtype), DIMENSION(3) :: v1d
   INTRINSIC SQRT
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   REAL(kind=realtype) :: tmp3
   REAL(kind=realtype) :: tmp4
   REAL(kind=realtype) :: tmp5
   REAL(kind=realtype) :: tmp6
   REAL(kind=realtype) :: tmp7
   REAL(kind=realtype) :: tmp8
   REAL(kind=realtype) :: tmp9
   REAL(kind=realtype) :: tmp10
   REAL(kind=realtype) :: tmp11
   REAL(kind=realtype) :: tmp12
   REAL(kind=realtype) :: tmp13
   REAL(kind=realtype) :: tmp14
   REAL(kind=realtype) :: tmp15
   REAL(kind=realtype) :: tmp16
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: ad_from5
   INTEGER :: ad_to5
   INTEGER :: ad_from6
   INTEGER :: ad_to6
   INTEGER :: ad_from7
   INTEGER :: ad_to7
   INTEGER :: ad_from8
   INTEGER :: ad_to8
   INTEGER :: ad_from9
   INTEGER :: ad_to9
   INTEGER :: ad_from10
   INTEGER :: ad_to10
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tmpd16
   REAL(kind=realtype) :: tmpd15
   REAL(kind=realtype) :: tmpd14
   REAL(kind=realtype) :: tmpd13
   REAL(kind=realtype) :: tmpd12
   REAL(kind=realtype) :: tmpd11
   REAL(kind=realtype) :: tmpd10
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tmpd9
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tmpd8
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tmpd7
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tmpd6
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tmpd5
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tmpd4
   REAL(kind=realtype) :: tmpd3
   REAL(kind=realtype) :: tmpd2
   REAL(kind=realtype) :: tmpd1
   REAL(kind=realtype) :: tmpd0
   ! Extrapolation in i-direction.
   DO k=1,kl
   DO j=1,jl
   IF (globalnode(0, j, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (globalnode(ie, j, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Extrapolation in j-direction.
   DO k=1,kl
   DO i=0,ie
   IF (globalnode(i, 0, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (globalnode(i, je, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Extrapolation in k-direction.
   DO j=0,je
   DO i=0,ie
   IF (globalnode(i, j, 0) .LT. 0) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (globalnode(i, j, ke) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   !
   !          **************************************************************
   !          *                                                            *
   !          * Mirror the halo coordinates adjacent to the symmetry       *
   !          * planes                                                     *
   !          *                                                            *
   !          **************************************************************
   !
   ! Loop over boundary subfaces.
   loopbocos:DO mm=1,nbocos
   ! The actual correction of the coordinates only takes
   ! place for symmetry planes.
   IF (bctype(mm) .EQ. symm) THEN
   ! Set some variables, depending on the block face on
   ! which the subface is located.
   CALL PUSHREAL8(norm(1))
   norm(1) = bcdata(mm)%symnorm(1)
   CALL PUSHREAL8(norm(2))
   norm(2) = bcdata(mm)%symnorm(2)
   CALL PUSHREAL8(norm(3))
   norm(3) = bcdata(mm)%symnorm(3)
   length = SQRT(norm(1)**2 + norm(2)**2 + norm(3)**2)
   ! Compute the unit normal of the subface.
   CALL PUSHREAL8(norm(1))
   norm(1) = norm(1)/length
   CALL PUSHREAL8(norm(2))
   norm(2) = norm(2)/length
   CALL PUSHREAL8(norm(3))
   norm(3) = norm(3)/length
   ! See xhalo_block for comments for below:
   IF (length .GT. eps) THEN
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   ibeg = jnbeg(mm)
   iend = jnend(mm)
   iimax = jl
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from0 = jbeg
   DO j=ad_from0,jend
   ad_from = ibeg
   DO i=ad_from,iend
   IF (globalnode(0, i, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL4B(7)
   CASE (imax) 
   ibeg = jnbeg(mm)
   iend = jnend(mm)
   iimax = jl
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from2 = jbeg
   DO j=ad_from2,jend
   ad_from1 = ibeg
   DO i=ad_from1,iend
   IF (globalnode(ie, i, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from2)
   CALL PUSHCONTROL4B(6)
   CASE (jmin) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from4 = jbeg
   DO j=ad_from4,jend
   ad_from3 = ibeg
   DO i=ad_from3,iend
   IF (globalnode(i, 0, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   CALL PUSHCONTROL4B(5)
   CASE (jmax) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from6 = jbeg
   DO j=ad_from6,jend
   ad_from5 = ibeg
   DO i=ad_from5,iend
   IF (globalnode(i, je, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from5)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from6)
   CALL PUSHCONTROL4B(4)
   CASE (kmin) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = jnbeg(mm)
   jend = jnend(mm)
   jjmax = jl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from8 = jbeg
   DO j=ad_from8,jend
   ad_from7 = ibeg
   DO i=ad_from7,iend
   IF (globalnode(i, j, 0) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from7)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from8)
   CALL PUSHCONTROL4B(3)
   CASE (kmax) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = jnbeg(mm)
   jend = jnend(mm)
   jjmax = jl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from10 = jbeg
   DO j=ad_from10,jend
   ad_from9 = ibeg
   DO i=ad_from9,iend
   IF (globalnode(i, j, ke) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from9)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from10)
   CALL PUSHCONTROL4B(2)
   CASE DEFAULT
   CALL PUSHCONTROL4B(8)
   END SELECT
   ELSE
   CALL PUSHCONTROL4B(1)
   END IF
   ELSE
   CALL PUSHCONTROL4B(0)
   END IF
   END DO loopbocos
   v1d = 0.0_8
   DO 100 mm=nbocos,1,-1
   CALL POPCONTROL4B(branch)
   IF (branch .LT. 4) THEN
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) GOTO 100
   ELSE IF (branch .EQ. 2) THEN
   CALL POPINTEGER4(ad_from10)
   CALL POPINTEGER4(ad_to10)
   DO j=ad_to10,ad_from10,-1
   CALL POPINTEGER4(ad_from9)
   CALL POPINTEGER4(ad_to9)
   DO i=ad_to9,ad_from9,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd14 = xd(i, j, ke, 3)
   xd(i, j, ke, 3) = 0.0_8
   xd(i, j, nz, 3) = xd(i, j, nz, 3) + tmpd14
   tmpd15 = xd(i, j, ke, 2)
   xd(i, j, ke, 2) = 0.0_8
   xd(i, j, nz, 2) = xd(i, j, nz, 2) + tmpd15
   tmpd16 = xd(i, j, ke, 1)
   dotd = norm(2)*tmpd15 + norm(1)*tmpd16 + norm(3)*tmpd14
   xd(i, j, ke, 1) = 0.0_8
   xd(i, j, nz, 1) = xd(i, j, nz, 1) + tmpd16
   tempd4 = two*dotd
   v1d(1) = v1d(1) + norm(1)*tempd4
   v1d(2) = v1d(2) + norm(2)*tempd4
   v1d(3) = v1d(3) + norm(3)*tempd4
   xd(i, j, kl, 3) = xd(i, j, kl, 3) + v1d(3)
   xd(i, j, nz, 3) = xd(i, j, nz, 3) - v1d(3)
   v1d(3) = 0.0_8
   xd(i, j, kl, 2) = xd(i, j, kl, 2) + v1d(2)
   xd(i, j, nz, 2) = xd(i, j, nz, 2) - v1d(2)
   v1d(2) = 0.0_8
   xd(i, j, kl, 1) = xd(i, j, kl, 1) + v1d(1)
   xd(i, j, nz, 1) = xd(i, j, nz, 1) - v1d(1)
   v1d(1) = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from8)
   CALL POPINTEGER4(ad_to8)
   DO j=ad_to8,ad_from8,-1
   CALL POPINTEGER4(ad_from7)
   CALL POPINTEGER4(ad_to7)
   DO i=ad_to7,ad_from7,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   xd(i, j, 2, 3) = xd(i, j, 2, 3) + xd(i, j, 0, 3)
   dotd = norm(3)*xd(i, j, 0, 3)
   xd(i, j, 0, 3) = 0.0_8
   xd(i, j, 2, 2) = xd(i, j, 2, 2) + xd(i, j, 0, 2)
   dotd = dotd + norm(2)*xd(i, j, 0, 2)
   xd(i, j, 0, 2) = 0.0_8
   xd(i, j, 2, 1) = xd(i, j, 2, 1) + xd(i, j, 0, 1)
   dotd = dotd + norm(1)*xd(i, j, 0, 1)
   xd(i, j, 0, 1) = 0.0_8
   tempd3 = two*dotd
   v1d(1) = v1d(1) + norm(1)*tempd3
   v1d(2) = v1d(2) + norm(2)*tempd3
   v1d(3) = v1d(3) + norm(3)*tempd3
   xd(i, j, 1, 3) = xd(i, j, 1, 3) + v1d(3)
   xd(i, j, 2, 3) = xd(i, j, 2, 3) - v1d(3)
   v1d(3) = 0.0_8
   xd(i, j, 1, 2) = xd(i, j, 1, 2) + v1d(2)
   xd(i, j, 2, 2) = xd(i, j, 2, 2) - v1d(2)
   v1d(2) = 0.0_8
   xd(i, j, 1, 1) = xd(i, j, 1, 1) + v1d(1)
   xd(i, j, 2, 1) = xd(i, j, 2, 1) - v1d(1)
   v1d(1) = 0.0_8
   END IF
   END DO
   END DO
   END IF
   ELSE IF (branch .LT. 6) THEN
   IF (branch .EQ. 4) THEN
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO j=ad_to6,ad_from6,-1
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO i=ad_to5,ad_from5,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd11 = xd(i, je, j, 3)
   xd(i, je, j, 3) = 0.0_8
   xd(i, ny, j, 3) = xd(i, ny, j, 3) + tmpd11
   tmpd12 = xd(i, je, j, 2)
   xd(i, je, j, 2) = 0.0_8
   xd(i, ny, j, 2) = xd(i, ny, j, 2) + tmpd12
   tmpd13 = xd(i, je, j, 1)
   dotd = norm(2)*tmpd12 + norm(1)*tmpd13 + norm(3)*tmpd11
   xd(i, je, j, 1) = 0.0_8
   xd(i, ny, j, 1) = xd(i, ny, j, 1) + tmpd13
   tempd2 = two*dotd
   v1d(1) = v1d(1) + norm(1)*tempd2
   v1d(2) = v1d(2) + norm(2)*tempd2
   v1d(3) = v1d(3) + norm(3)*tempd2
   xd(i, jl, j, 3) = xd(i, jl, j, 3) + v1d(3)
   xd(i, ny, j, 3) = xd(i, ny, j, 3) - v1d(3)
   v1d(3) = 0.0_8
   xd(i, jl, j, 2) = xd(i, jl, j, 2) + v1d(2)
   xd(i, ny, j, 2) = xd(i, ny, j, 2) - v1d(2)
   v1d(2) = 0.0_8
   xd(i, jl, j, 1) = xd(i, jl, j, 1) + v1d(1)
   xd(i, ny, j, 1) = xd(i, ny, j, 1) - v1d(1)
   v1d(1) = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO i=ad_to3,ad_from3,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   xd(i, 2, j, 3) = xd(i, 2, j, 3) + xd(i, 0, j, 3)
   dotd = norm(3)*xd(i, 0, j, 3)
   xd(i, 0, j, 3) = 0.0_8
   xd(i, 2, j, 2) = xd(i, 2, j, 2) + xd(i, 0, j, 2)
   dotd = dotd + norm(2)*xd(i, 0, j, 2)
   xd(i, 0, j, 2) = 0.0_8
   xd(i, 2, j, 1) = xd(i, 2, j, 1) + xd(i, 0, j, 1)
   dotd = dotd + norm(1)*xd(i, 0, j, 1)
   xd(i, 0, j, 1) = 0.0_8
   tempd1 = two*dotd
   v1d(1) = v1d(1) + norm(1)*tempd1
   v1d(2) = v1d(2) + norm(2)*tempd1
   v1d(3) = v1d(3) + norm(3)*tempd1
   xd(i, 1, j, 3) = xd(i, 1, j, 3) + v1d(3)
   xd(i, 2, j, 3) = xd(i, 2, j, 3) - v1d(3)
   v1d(3) = 0.0_8
   xd(i, 1, j, 2) = xd(i, 1, j, 2) + v1d(2)
   xd(i, 2, j, 2) = xd(i, 2, j, 2) - v1d(2)
   v1d(2) = 0.0_8
   xd(i, 1, j, 1) = xd(i, 1, j, 1) + v1d(1)
   xd(i, 2, j, 1) = xd(i, 2, j, 1) - v1d(1)
   v1d(1) = 0.0_8
   END IF
   END DO
   END DO
   END IF
   ELSE IF (branch .EQ. 6) THEN
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO j=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd8 = xd(ie, i, j, 3)
   xd(ie, i, j, 3) = 0.0_8
   xd(nx, i, j, 3) = xd(nx, i, j, 3) + tmpd8
   tmpd9 = xd(ie, i, j, 2)
   xd(ie, i, j, 2) = 0.0_8
   xd(nx, i, j, 2) = xd(nx, i, j, 2) + tmpd9
   tmpd10 = xd(ie, i, j, 1)
   dotd = norm(2)*tmpd9 + norm(1)*tmpd10 + norm(3)*tmpd8
   xd(ie, i, j, 1) = 0.0_8
   xd(nx, i, j, 1) = xd(nx, i, j, 1) + tmpd10
   tempd0 = two*dotd
   v1d(1) = v1d(1) + norm(1)*tempd0
   v1d(2) = v1d(2) + norm(2)*tempd0
   v1d(3) = v1d(3) + norm(3)*tempd0
   xd(il, i, j, 3) = xd(il, i, j, 3) + v1d(3)
   xd(nx, i, j, 3) = xd(nx, i, j, 3) - v1d(3)
   v1d(3) = 0.0_8
   xd(il, i, j, 2) = xd(il, i, j, 2) + v1d(2)
   xd(nx, i, j, 2) = xd(nx, i, j, 2) - v1d(2)
   v1d(2) = 0.0_8
   xd(il, i, j, 1) = xd(il, i, j, 1) + v1d(1)
   xd(nx, i, j, 1) = xd(nx, i, j, 1) - v1d(1)
   v1d(1) = 0.0_8
   END IF
   END DO
   END DO
   ELSE IF (branch .EQ. 7) THEN
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   xd(2, i, j, 3) = xd(2, i, j, 3) + xd(0, i, j, 3)
   dotd = norm(3)*xd(0, i, j, 3)
   xd(0, i, j, 3) = 0.0_8
   xd(2, i, j, 2) = xd(2, i, j, 2) + xd(0, i, j, 2)
   dotd = dotd + norm(2)*xd(0, i, j, 2)
   xd(0, i, j, 2) = 0.0_8
   xd(2, i, j, 1) = xd(2, i, j, 1) + xd(0, i, j, 1)
   dotd = dotd + norm(1)*xd(0, i, j, 1)
   xd(0, i, j, 1) = 0.0_8
   tempd = two*dotd
   v1d(1) = v1d(1) + norm(1)*tempd
   v1d(2) = v1d(2) + norm(2)*tempd
   v1d(3) = v1d(3) + norm(3)*tempd
   xd(1, i, j, 3) = xd(1, i, j, 3) + v1d(3)
   xd(2, i, j, 3) = xd(2, i, j, 3) - v1d(3)
   v1d(3) = 0.0_8
   xd(1, i, j, 2) = xd(1, i, j, 2) + v1d(2)
   xd(2, i, j, 2) = xd(2, i, j, 2) - v1d(2)
   v1d(2) = 0.0_8
   xd(1, i, j, 1) = xd(1, i, j, 1) + v1d(1)
   xd(2, i, j, 1) = xd(2, i, j, 1) - v1d(1)
   v1d(1) = 0.0_8
   END IF
   END DO
   END DO
   END IF
   CALL POPREAL8(norm(3))
   CALL POPREAL8(norm(2))
   CALL POPREAL8(norm(1))
   CALL POPREAL8(norm(3))
   CALL POPREAL8(norm(2))
   CALL POPREAL8(norm(1))
   100 CONTINUE
   DO j=je,0,-1
   DO i=ie,0,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd5 = xd(i, j, ke, 3)
   xd(i, j, ke, 3) = 0.0_8
   xd(i, j, kl, 3) = xd(i, j, kl, 3) + two*tmpd5
   xd(i, j, nz, 3) = xd(i, j, nz, 3) - tmpd5
   tmpd6 = xd(i, j, ke, 2)
   xd(i, j, ke, 2) = 0.0_8
   xd(i, j, kl, 2) = xd(i, j, kl, 2) + two*tmpd6
   xd(i, j, nz, 2) = xd(i, j, nz, 2) - tmpd6
   tmpd7 = xd(i, j, ke, 1)
   xd(i, j, ke, 1) = 0.0_8
   xd(i, j, kl, 1) = xd(i, j, kl, 1) + two*tmpd7
   xd(i, j, nz, 1) = xd(i, j, nz, 1) - tmpd7
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   xd(i, j, 1, 3) = xd(i, j, 1, 3) + two*xd(i, j, 0, 3)
   xd(i, j, 2, 3) = xd(i, j, 2, 3) - xd(i, j, 0, 3)
   xd(i, j, 0, 3) = 0.0_8
   xd(i, j, 1, 2) = xd(i, j, 1, 2) + two*xd(i, j, 0, 2)
   xd(i, j, 2, 2) = xd(i, j, 2, 2) - xd(i, j, 0, 2)
   xd(i, j, 0, 2) = 0.0_8
   xd(i, j, 1, 1) = xd(i, j, 1, 1) + two*xd(i, j, 0, 1)
   xd(i, j, 2, 1) = xd(i, j, 2, 1) - xd(i, j, 0, 1)
   xd(i, j, 0, 1) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,1,-1
   DO i=ie,0,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd2 = xd(i, je, k, 3)
   xd(i, je, k, 3) = 0.0_8
   xd(i, jl, k, 3) = xd(i, jl, k, 3) + two*tmpd2
   xd(i, ny, k, 3) = xd(i, ny, k, 3) - tmpd2
   tmpd3 = xd(i, je, k, 2)
   xd(i, je, k, 2) = 0.0_8
   xd(i, jl, k, 2) = xd(i, jl, k, 2) + two*tmpd3
   xd(i, ny, k, 2) = xd(i, ny, k, 2) - tmpd3
   tmpd4 = xd(i, je, k, 1)
   xd(i, je, k, 1) = 0.0_8
   xd(i, jl, k, 1) = xd(i, jl, k, 1) + two*tmpd4
   xd(i, ny, k, 1) = xd(i, ny, k, 1) - tmpd4
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   xd(i, 1, k, 3) = xd(i, 1, k, 3) + two*xd(i, 0, k, 3)
   xd(i, 2, k, 3) = xd(i, 2, k, 3) - xd(i, 0, k, 3)
   xd(i, 0, k, 3) = 0.0_8
   xd(i, 1, k, 2) = xd(i, 1, k, 2) + two*xd(i, 0, k, 2)
   xd(i, 2, k, 2) = xd(i, 2, k, 2) - xd(i, 0, k, 2)
   xd(i, 0, k, 2) = 0.0_8
   xd(i, 1, k, 1) = xd(i, 1, k, 1) + two*xd(i, 0, k, 1)
   xd(i, 2, k, 1) = xd(i, 2, k, 1) - xd(i, 0, k, 1)
   xd(i, 0, k, 1) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,1,-1
   DO j=jl,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd = xd(ie, j, k, 3)
   xd(ie, j, k, 3) = 0.0_8
   xd(il, j, k, 3) = xd(il, j, k, 3) + two*tmpd
   xd(nx, j, k, 3) = xd(nx, j, k, 3) - tmpd
   tmpd0 = xd(ie, j, k, 2)
   xd(ie, j, k, 2) = 0.0_8
   xd(il, j, k, 2) = xd(il, j, k, 2) + two*tmpd0
   xd(nx, j, k, 2) = xd(nx, j, k, 2) - tmpd0
   tmpd1 = xd(ie, j, k, 1)
   xd(ie, j, k, 1) = 0.0_8
   xd(il, j, k, 1) = xd(il, j, k, 1) + two*tmpd1
   xd(nx, j, k, 1) = xd(nx, j, k, 1) - tmpd1
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   xd(1, j, k, 3) = xd(1, j, k, 3) + two*xd(0, j, k, 3)
   xd(2, j, k, 3) = xd(2, j, k, 3) - xd(0, j, k, 3)
   xd(0, j, k, 3) = 0.0_8
   xd(1, j, k, 2) = xd(1, j, k, 2) + two*xd(0, j, k, 2)
   xd(2, j, k, 2) = xd(2, j, k, 2) - xd(0, j, k, 2)
   xd(0, j, k, 2) = 0.0_8
   xd(1, j, k, 1) = xd(1, j, k, 1) + two*xd(0, j, k, 1)
   xd(2, j, k, 1) = xd(2, j, k, 1) - xd(0, j, k, 1)
   xd(0, j, k, 1) = 0.0_8
   END IF
   END DO
   END DO
   END SUBROUTINE XHALO_BLOCK_B

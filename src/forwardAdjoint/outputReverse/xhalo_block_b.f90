   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of xhalo_block in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *x
   !   with respect to varying inputs: *x
   !   Plus diff mem management of: x:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          xhalo.f90                                       *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader            *
   !      * Starting date: 02-23-2003                                      *
   !      * Last modified: 08-12-2009                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE XHALO_BLOCK_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * xhalo determines the coordinates of the nodal halo's.          *
   !      * First it sets all halo coordinates by simple extrapolation,    *
   !      * then the symmetry planes are treated (also the unit normal of  *
   !      * symmetry planes are determined) and finally an exchange is     *
   !      * made for the internal halo's.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE BCTYPES
   USE COMMUNICATION
   USE INPUTTIMESPECTRAL
   IMPLICIT NONE
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm, i, j, k
   INTEGER(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
   LOGICAL :: err
   REAL(kind=realtype) :: length, dot
   REAL(kind=realtype) :: dotb
   REAL(kind=realtype), DIMENSION(3) :: v1, v2, norm
   REAL(kind=realtype), DIMENSION(3) :: v1b
   INTRINSIC SQRT
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   REAL(kind=realtype) :: tmp2
   REAL(kind=realtype) :: tmp3
   REAL(kind=realtype) :: tmp4
   REAL(kind=realtype) :: tmp5
   REAL(kind=realtype) :: tmp6
   REAL(kind=realtype) :: tmp7
   REAL(kind=realtype) :: tmp8
   REAL(kind=realtype) :: tmp9
   REAL(kind=realtype) :: tmp10
   REAL(kind=realtype) :: tmp11
   REAL(kind=realtype) :: tmp12
   REAL(kind=realtype) :: tmp13
   REAL(kind=realtype) :: tmp14
   REAL(kind=realtype) :: tmp15
   REAL(kind=realtype) :: tmp16
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: ad_from5
   INTEGER :: ad_to5
   INTEGER :: ad_from6
   INTEGER :: ad_to6
   INTEGER :: ad_from7
   INTEGER :: ad_to7
   INTEGER :: ad_from8
   INTEGER :: ad_to8
   INTEGER :: ad_from9
   INTEGER :: ad_to9
   INTEGER :: ad_from10
   INTEGER :: ad_to10
   REAL(kind=realtype) :: tmpb9
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tmpb8
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tmpb7
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tmpb6
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tmpb5
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tmpb4
   REAL(kind=realtype) :: tmpb3
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tmpb2
   REAL(kind=realtype) :: tmpb1
   REAL(kind=realtype) :: tmpb0
   REAL(kind=realtype) :: tmpb16
   REAL(kind=realtype) :: tmpb15
   REAL(kind=realtype) :: tmpb14
   REAL(kind=realtype) :: tmpb13
   REAL(kind=realtype) :: tmpb12
   REAL(kind=realtype) :: tmpb11
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: tmpb10
   ! Extrapolation in i-direction.
   DO k=1,kl
   DO j=1,jl
   IF (globalnode(0, j, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (globalnode(ie, j, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Extrapolation in j-direction.
   DO k=1,kl
   DO i=0,ie
   IF (globalnode(i, 0, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (globalnode(i, je, k) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Extrapolation in k-direction.
   DO j=0,je
   DO i=0,ie
   IF (globalnode(i, j, 0) .LT. 0) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (globalnode(i, j, ke) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   !
   !          **************************************************************
   !          *                                                            *
   !          * Mirror the halo coordinates adjacent to the symmetry       *
   !          * planes                                                     *
   !          *                                                            *
   !          **************************************************************
   !
   ! Loop over boundary subfaces.
   loopbocos:DO mm=1,nbocos
   ! The actual correction of the coordinates only takes
   ! place for symmetry planes.
   IF (bctype(mm) .EQ. symm) THEN
   ! Set some variables, depending on the block face on
   ! which the subface is located.
   CALL PUSHREAL8(norm(1))
   norm(1) = bcdata(mm)%symnorm(1)
   CALL PUSHREAL8(norm(2))
   norm(2) = bcdata(mm)%symnorm(2)
   CALL PUSHREAL8(norm(3))
   norm(3) = bcdata(mm)%symnorm(3)
   length = SQRT(norm(1)**2 + norm(2)**2 + norm(3)**2)
   ! Compute the unit normal of the subface.
   CALL PUSHREAL8(norm(1))
   norm(1) = norm(1)/length
   CALL PUSHREAL8(norm(2))
   norm(2) = norm(2)/length
   CALL PUSHREAL8(norm(3))
   norm(3) = norm(3)/length
   ! See xhalo_block for comments for below:
   IF (length .GT. eps) THEN
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   ibeg = jnbeg(mm)
   iend = jnend(mm)
   iimax = jl
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from0 = jbeg
   DO j=ad_from0,jend
   ad_from = ibeg
   DO i=ad_from,iend
   IF (globalnode(0, i, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL PUSHCONTROL4B(7)
   CASE (imax) 
   ibeg = jnbeg(mm)
   iend = jnend(mm)
   iimax = jl
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from2 = jbeg
   DO j=ad_from2,jend
   ad_from1 = ibeg
   DO i=ad_from1,iend
   IF (globalnode(ie, i, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from2)
   CALL PUSHCONTROL4B(6)
   CASE (jmin) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from4 = jbeg
   DO j=ad_from4,jend
   ad_from3 = ibeg
   DO i=ad_from3,iend
   IF (globalnode(i, 0, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   CALL PUSHCONTROL4B(5)
   CASE (jmax) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from6 = jbeg
   DO j=ad_from6,jend
   ad_from5 = ibeg
   DO i=ad_from5,iend
   IF (globalnode(i, je, j) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from5)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from6)
   CALL PUSHCONTROL4B(4)
   CASE (kmin) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = jnbeg(mm)
   jend = jnend(mm)
   jjmax = jl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from8 = jbeg
   DO j=ad_from8,jend
   ad_from7 = ibeg
   DO i=ad_from7,iend
   IF (globalnode(i, j, 0) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from7)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from8)
   CALL PUSHCONTROL4B(3)
   CASE (kmax) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = jnbeg(mm)
   jend = jnend(mm)
   jjmax = jl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   ad_from10 = jbeg
   DO j=ad_from10,jend
   ad_from9 = ibeg
   DO i=ad_from9,iend
   IF (globalnode(i, j, ke) .LT. 0) THEN
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from9)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from10)
   CALL PUSHCONTROL4B(2)
   CASE DEFAULT
   CALL PUSHCONTROL4B(8)
   END SELECT
   ELSE
   CALL PUSHCONTROL4B(1)
   END IF
   ELSE
   CALL PUSHCONTROL4B(0)
   END IF
   END DO loopbocos
   v1b = 0.0_8
   DO 100 mm=nbocos,1,-1
   CALL POPCONTROL4B(branch)
   IF (branch .LT. 4) THEN
   IF (branch .LT. 2) THEN
   IF (branch .EQ. 0) GOTO 100
   ELSE IF (branch .EQ. 2) THEN
   CALL POPINTEGER4(ad_from10)
   CALL POPINTEGER4(ad_to10)
   DO j=ad_to10,ad_from10,-1
   CALL POPINTEGER4(ad_from9)
   CALL POPINTEGER4(ad_to9)
   DO i=ad_to9,ad_from9,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpb14 = xb(i, j, ke, 3)
   xb(i, j, ke, 3) = 0.0_8
   xb(i, j, nz, 3) = xb(i, j, nz, 3) + tmpb14
   tmpb15 = xb(i, j, ke, 2)
   xb(i, j, ke, 2) = 0.0_8
   xb(i, j, nz, 2) = xb(i, j, nz, 2) + tmpb15
   tmpb16 = xb(i, j, ke, 1)
   dotb = norm(2)*tmpb15 + norm(1)*tmpb16 + norm(3)*tmpb14
   xb(i, j, ke, 1) = 0.0_8
   xb(i, j, nz, 1) = xb(i, j, nz, 1) + tmpb16
   tempb4 = two*dotb
   v1b(1) = v1b(1) + norm(1)*tempb4
   v1b(2) = v1b(2) + norm(2)*tempb4
   v1b(3) = v1b(3) + norm(3)*tempb4
   xb(i, j, kl, 3) = xb(i, j, kl, 3) + v1b(3)
   xb(i, j, nz, 3) = xb(i, j, nz, 3) - v1b(3)
   v1b(3) = 0.0_8
   xb(i, j, kl, 2) = xb(i, j, kl, 2) + v1b(2)
   xb(i, j, nz, 2) = xb(i, j, nz, 2) - v1b(2)
   v1b(2) = 0.0_8
   xb(i, j, kl, 1) = xb(i, j, kl, 1) + v1b(1)
   xb(i, j, nz, 1) = xb(i, j, nz, 1) - v1b(1)
   v1b(1) = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from8)
   CALL POPINTEGER4(ad_to8)
   DO j=ad_to8,ad_from8,-1
   CALL POPINTEGER4(ad_from7)
   CALL POPINTEGER4(ad_to7)
   DO i=ad_to7,ad_from7,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   xb(i, j, 2, 3) = xb(i, j, 2, 3) + xb(i, j, 0, 3)
   dotb = norm(3)*xb(i, j, 0, 3)
   xb(i, j, 0, 3) = 0.0_8
   xb(i, j, 2, 2) = xb(i, j, 2, 2) + xb(i, j, 0, 2)
   dotb = dotb + norm(2)*xb(i, j, 0, 2)
   xb(i, j, 0, 2) = 0.0_8
   xb(i, j, 2, 1) = xb(i, j, 2, 1) + xb(i, j, 0, 1)
   dotb = dotb + norm(1)*xb(i, j, 0, 1)
   xb(i, j, 0, 1) = 0.0_8
   tempb3 = two*dotb
   v1b(1) = v1b(1) + norm(1)*tempb3
   v1b(2) = v1b(2) + norm(2)*tempb3
   v1b(3) = v1b(3) + norm(3)*tempb3
   xb(i, j, 1, 3) = xb(i, j, 1, 3) + v1b(3)
   xb(i, j, 2, 3) = xb(i, j, 2, 3) - v1b(3)
   v1b(3) = 0.0_8
   xb(i, j, 1, 2) = xb(i, j, 1, 2) + v1b(2)
   xb(i, j, 2, 2) = xb(i, j, 2, 2) - v1b(2)
   v1b(2) = 0.0_8
   xb(i, j, 1, 1) = xb(i, j, 1, 1) + v1b(1)
   xb(i, j, 2, 1) = xb(i, j, 2, 1) - v1b(1)
   v1b(1) = 0.0_8
   END IF
   END DO
   END DO
   END IF
   ELSE IF (branch .LT. 6) THEN
   IF (branch .EQ. 4) THEN
   CALL POPINTEGER4(ad_from6)
   CALL POPINTEGER4(ad_to6)
   DO j=ad_to6,ad_from6,-1
   CALL POPINTEGER4(ad_from5)
   CALL POPINTEGER4(ad_to5)
   DO i=ad_to5,ad_from5,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpb11 = xb(i, je, j, 3)
   xb(i, je, j, 3) = 0.0_8
   xb(i, ny, j, 3) = xb(i, ny, j, 3) + tmpb11
   tmpb12 = xb(i, je, j, 2)
   xb(i, je, j, 2) = 0.0_8
   xb(i, ny, j, 2) = xb(i, ny, j, 2) + tmpb12
   tmpb13 = xb(i, je, j, 1)
   dotb = norm(2)*tmpb12 + norm(1)*tmpb13 + norm(3)*tmpb11
   xb(i, je, j, 1) = 0.0_8
   xb(i, ny, j, 1) = xb(i, ny, j, 1) + tmpb13
   tempb2 = two*dotb
   v1b(1) = v1b(1) + norm(1)*tempb2
   v1b(2) = v1b(2) + norm(2)*tempb2
   v1b(3) = v1b(3) + norm(3)*tempb2
   xb(i, jl, j, 3) = xb(i, jl, j, 3) + v1b(3)
   xb(i, ny, j, 3) = xb(i, ny, j, 3) - v1b(3)
   v1b(3) = 0.0_8
   xb(i, jl, j, 2) = xb(i, jl, j, 2) + v1b(2)
   xb(i, ny, j, 2) = xb(i, ny, j, 2) - v1b(2)
   v1b(2) = 0.0_8
   xb(i, jl, j, 1) = xb(i, jl, j, 1) + v1b(1)
   xb(i, ny, j, 1) = xb(i, ny, j, 1) - v1b(1)
   v1b(1) = 0.0_8
   END IF
   END DO
   END DO
   ELSE
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO i=ad_to3,ad_from3,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   xb(i, 2, j, 3) = xb(i, 2, j, 3) + xb(i, 0, j, 3)
   dotb = norm(3)*xb(i, 0, j, 3)
   xb(i, 0, j, 3) = 0.0_8
   xb(i, 2, j, 2) = xb(i, 2, j, 2) + xb(i, 0, j, 2)
   dotb = dotb + norm(2)*xb(i, 0, j, 2)
   xb(i, 0, j, 2) = 0.0_8
   xb(i, 2, j, 1) = xb(i, 2, j, 1) + xb(i, 0, j, 1)
   dotb = dotb + norm(1)*xb(i, 0, j, 1)
   xb(i, 0, j, 1) = 0.0_8
   tempb1 = two*dotb
   v1b(1) = v1b(1) + norm(1)*tempb1
   v1b(2) = v1b(2) + norm(2)*tempb1
   v1b(3) = v1b(3) + norm(3)*tempb1
   xb(i, 1, j, 3) = xb(i, 1, j, 3) + v1b(3)
   xb(i, 2, j, 3) = xb(i, 2, j, 3) - v1b(3)
   v1b(3) = 0.0_8
   xb(i, 1, j, 2) = xb(i, 1, j, 2) + v1b(2)
   xb(i, 2, j, 2) = xb(i, 2, j, 2) - v1b(2)
   v1b(2) = 0.0_8
   xb(i, 1, j, 1) = xb(i, 1, j, 1) + v1b(1)
   xb(i, 2, j, 1) = xb(i, 2, j, 1) - v1b(1)
   v1b(1) = 0.0_8
   END IF
   END DO
   END DO
   END IF
   ELSE IF (branch .EQ. 6) THEN
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO j=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpb8 = xb(ie, i, j, 3)
   xb(ie, i, j, 3) = 0.0_8
   xb(nx, i, j, 3) = xb(nx, i, j, 3) + tmpb8
   tmpb9 = xb(ie, i, j, 2)
   xb(ie, i, j, 2) = 0.0_8
   xb(nx, i, j, 2) = xb(nx, i, j, 2) + tmpb9
   tmpb10 = xb(ie, i, j, 1)
   dotb = norm(2)*tmpb9 + norm(1)*tmpb10 + norm(3)*tmpb8
   xb(ie, i, j, 1) = 0.0_8
   xb(nx, i, j, 1) = xb(nx, i, j, 1) + tmpb10
   tempb0 = two*dotb
   v1b(1) = v1b(1) + norm(1)*tempb0
   v1b(2) = v1b(2) + norm(2)*tempb0
   v1b(3) = v1b(3) + norm(3)*tempb0
   xb(il, i, j, 3) = xb(il, i, j, 3) + v1b(3)
   xb(nx, i, j, 3) = xb(nx, i, j, 3) - v1b(3)
   v1b(3) = 0.0_8
   xb(il, i, j, 2) = xb(il, i, j, 2) + v1b(2)
   xb(nx, i, j, 2) = xb(nx, i, j, 2) - v1b(2)
   v1b(2) = 0.0_8
   xb(il, i, j, 1) = xb(il, i, j, 1) + v1b(1)
   xb(nx, i, j, 1) = xb(nx, i, j, 1) - v1b(1)
   v1b(1) = 0.0_8
   END IF
   END DO
   END DO
   ELSE IF (branch .EQ. 7) THEN
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   xb(2, i, j, 3) = xb(2, i, j, 3) + xb(0, i, j, 3)
   dotb = norm(3)*xb(0, i, j, 3)
   xb(0, i, j, 3) = 0.0_8
   xb(2, i, j, 2) = xb(2, i, j, 2) + xb(0, i, j, 2)
   dotb = dotb + norm(2)*xb(0, i, j, 2)
   xb(0, i, j, 2) = 0.0_8
   xb(2, i, j, 1) = xb(2, i, j, 1) + xb(0, i, j, 1)
   dotb = dotb + norm(1)*xb(0, i, j, 1)
   xb(0, i, j, 1) = 0.0_8
   tempb = two*dotb
   v1b(1) = v1b(1) + norm(1)*tempb
   v1b(2) = v1b(2) + norm(2)*tempb
   v1b(3) = v1b(3) + norm(3)*tempb
   xb(1, i, j, 3) = xb(1, i, j, 3) + v1b(3)
   xb(2, i, j, 3) = xb(2, i, j, 3) - v1b(3)
   v1b(3) = 0.0_8
   xb(1, i, j, 2) = xb(1, i, j, 2) + v1b(2)
   xb(2, i, j, 2) = xb(2, i, j, 2) - v1b(2)
   v1b(2) = 0.0_8
   xb(1, i, j, 1) = xb(1, i, j, 1) + v1b(1)
   xb(2, i, j, 1) = xb(2, i, j, 1) - v1b(1)
   v1b(1) = 0.0_8
   END IF
   END DO
   END DO
   END IF
   CALL POPREAL8(norm(3))
   CALL POPREAL8(norm(2))
   CALL POPREAL8(norm(1))
   CALL POPREAL8(norm(3))
   CALL POPREAL8(norm(2))
   CALL POPREAL8(norm(1))
   100 CONTINUE
   DO j=je,0,-1
   DO i=ie,0,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpb5 = xb(i, j, ke, 3)
   xb(i, j, ke, 3) = 0.0_8
   xb(i, j, kl, 3) = xb(i, j, kl, 3) + two*tmpb5
   xb(i, j, nz, 3) = xb(i, j, nz, 3) - tmpb5
   tmpb6 = xb(i, j, ke, 2)
   xb(i, j, ke, 2) = 0.0_8
   xb(i, j, kl, 2) = xb(i, j, kl, 2) + two*tmpb6
   xb(i, j, nz, 2) = xb(i, j, nz, 2) - tmpb6
   tmpb7 = xb(i, j, ke, 1)
   xb(i, j, ke, 1) = 0.0_8
   xb(i, j, kl, 1) = xb(i, j, kl, 1) + two*tmpb7
   xb(i, j, nz, 1) = xb(i, j, nz, 1) - tmpb7
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   xb(i, j, 1, 3) = xb(i, j, 1, 3) + two*xb(i, j, 0, 3)
   xb(i, j, 2, 3) = xb(i, j, 2, 3) - xb(i, j, 0, 3)
   xb(i, j, 0, 3) = 0.0_8
   xb(i, j, 1, 2) = xb(i, j, 1, 2) + two*xb(i, j, 0, 2)
   xb(i, j, 2, 2) = xb(i, j, 2, 2) - xb(i, j, 0, 2)
   xb(i, j, 0, 2) = 0.0_8
   xb(i, j, 1, 1) = xb(i, j, 1, 1) + two*xb(i, j, 0, 1)
   xb(i, j, 2, 1) = xb(i, j, 2, 1) - xb(i, j, 0, 1)
   xb(i, j, 0, 1) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,1,-1
   DO i=ie,0,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpb2 = xb(i, je, k, 3)
   xb(i, je, k, 3) = 0.0_8
   xb(i, jl, k, 3) = xb(i, jl, k, 3) + two*tmpb2
   xb(i, ny, k, 3) = xb(i, ny, k, 3) - tmpb2
   tmpb3 = xb(i, je, k, 2)
   xb(i, je, k, 2) = 0.0_8
   xb(i, jl, k, 2) = xb(i, jl, k, 2) + two*tmpb3
   xb(i, ny, k, 2) = xb(i, ny, k, 2) - tmpb3
   tmpb4 = xb(i, je, k, 1)
   xb(i, je, k, 1) = 0.0_8
   xb(i, jl, k, 1) = xb(i, jl, k, 1) + two*tmpb4
   xb(i, ny, k, 1) = xb(i, ny, k, 1) - tmpb4
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   xb(i, 1, k, 3) = xb(i, 1, k, 3) + two*xb(i, 0, k, 3)
   xb(i, 2, k, 3) = xb(i, 2, k, 3) - xb(i, 0, k, 3)
   xb(i, 0, k, 3) = 0.0_8
   xb(i, 1, k, 2) = xb(i, 1, k, 2) + two*xb(i, 0, k, 2)
   xb(i, 2, k, 2) = xb(i, 2, k, 2) - xb(i, 0, k, 2)
   xb(i, 0, k, 2) = 0.0_8
   xb(i, 1, k, 1) = xb(i, 1, k, 1) + two*xb(i, 0, k, 1)
   xb(i, 2, k, 1) = xb(i, 2, k, 1) - xb(i, 0, k, 1)
   xb(i, 0, k, 1) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,1,-1
   DO j=jl,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpb = xb(ie, j, k, 3)
   xb(ie, j, k, 3) = 0.0_8
   xb(il, j, k, 3) = xb(il, j, k, 3) + two*tmpb
   xb(nx, j, k, 3) = xb(nx, j, k, 3) - tmpb
   tmpb0 = xb(ie, j, k, 2)
   xb(ie, j, k, 2) = 0.0_8
   xb(il, j, k, 2) = xb(il, j, k, 2) + two*tmpb0
   xb(nx, j, k, 2) = xb(nx, j, k, 2) - tmpb0
   tmpb1 = xb(ie, j, k, 1)
   xb(ie, j, k, 1) = 0.0_8
   xb(il, j, k, 1) = xb(il, j, k, 1) + two*tmpb1
   xb(nx, j, k, 1) = xb(nx, j, k, 1) - tmpb1
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   xb(1, j, k, 3) = xb(1, j, k, 3) + two*xb(0, j, k, 3)
   xb(2, j, k, 3) = xb(2, j, k, 3) - xb(0, j, k, 3)
   xb(0, j, k, 3) = 0.0_8
   xb(1, j, k, 2) = xb(1, j, k, 2) + two*xb(0, j, k, 2)
   xb(2, j, k, 2) = xb(2, j, k, 2) - xb(0, j, k, 2)
   xb(0, j, k, 2) = 0.0_8
   xb(1, j, k, 1) = xb(1, j, k, 1) + two*xb(0, j, k, 1)
   xb(2, j, k, 1) = xb(2, j, k, 1) - xb(0, j, k, 1)
   xb(0, j, k, 1) = 0.0_8
   END IF
   END DO
   END DO
   END SUBROUTINE XHALO_BLOCK_B

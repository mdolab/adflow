!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
!
!  Differentiation of xhalo_block in reverse (adjoint) mode:
!   gradient     of useful results: *x
!   with respect to varying inputs: *x
!   Plus diff mem management of: x:in
!
!      ******************************************************************
!      *                                                                *
!      * File:          xhalo.f90                                       *
!      * Author:        Edwin van der Weide,C.A.(Sandy) Mader            *
!      * Starting date: 02-23-2003                                      *
!      * Last modified: 08-12-2009                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE XHALO_BLOCK_B()
  USE BLOCKPOINTERS_B
  USE INPUTTIMESPECTRAL
  USE BCTYPES
  USE COMMUNICATION
  IMPLICIT NONE
  !
  !      ******************************************************************
  !      *                                                                *
  !      * xhalo determines the coordinates of the nodal halo's.          *
  !      * First it sets all halo coordinates by simple extrapolation,    *
  !      * then the symmetry planes are treated (also the unit normal of  *
  !      * symmetry planes are determined) and finally an exchange is     *
  !      * made for the internal halo's.                                  *
  !      *                                                                *
  !      ******************************************************************
  !
  !
  !      Subroutine arguments.
  !
  INTEGER(kind=inttype) :: level
  !
  !      Local variables.
  !
  INTEGER(kind=inttype) :: nn, mm, sps, i, j, k, ii, jj, l
  INTEGER(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: x0, x1, x2
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: x0b, x1b, x2b
  LOGICAL :: err
  REAL(kind=realtype) :: length, dot
  REAL(kind=realtype) :: lengthb, dotb
  LOGICAL :: imininternal, jmininternal, kmininternal
  LOGICAL :: imaxinternal, jmaxinternal, kmaxinternal
  REAL(kind=realtype), DIMENSION(3) :: v1, v2, norm
  REAL(kind=realtype), DIMENSION(3) :: v1b, v2b, normb
  REAL(kind=realtype) :: tmp
  REAL(kind=realtype) :: tmp0
  REAL(kind=realtype) :: tmp1
  REAL(kind=realtype) :: tmp2
  REAL(kind=realtype) :: tmp3
  REAL(kind=realtype) :: tmp4
  REAL(kind=realtype) :: tmp5
  REAL(kind=realtype) :: tmp6
  REAL(kind=realtype) :: tmp7
  REAL(kind=realtype) :: tmp8
  REAL(kind=realtype) :: tmp9
  REAL(kind=realtype) :: tmp10
  INTEGER :: branch
  INTEGER :: ad_from
  INTEGER :: ad_to
  INTEGER :: ad_from0
  INTEGER :: ad_to0
  REAL(kind=realtype) :: tmp4b
  REAL(kind=realtype) :: tmp7b
  REAL(kind=realtype) :: tempb0
  REAL(kind=realtype) :: tmp10b
  REAL(kind=realtype) :: tmpb
  REAL(kind=realtype) :: tmp0b
  REAL(kind=realtype) :: tmp3b
  REAL(kind=realtype) :: tmp6b
  REAL(kind=realtype) :: tmp9b
  REAL(kind=realtype) :: tempb
  REAL(kind=realtype) :: tmp2b
  REAL(kind=realtype) :: tmp5b
  REAL(kind=realtype) :: tmp8b
  INTRINSIC SQRT
  REAL(kind=realtype) :: tmp1b
  INTERFACE 
     SUBROUTINE PUSHPOINTER4(pp)
       REAL, POINTER :: pp
     END SUBROUTINE PUSHPOINTER4
     SUBROUTINE LOOKPOINTER4(pp)
       REAL, POINTER :: pp
     END SUBROUTINE LOOKPOINTER4
     SUBROUTINE POPPOINTER4(pp)
       REAL, POINTER :: pp
     END SUBROUTINE POPPOINTER4
  END INTERFACE
  !      ******************************************************************
  !      *                                                                *
  !      * Begin execution                                                *
  !      *                                                                *
  !      ******************************************************************
  !
  !
  !          **************************************************************
  !          *                                                            *
  !          * Extrapolation of the coordinates. First extrapolation in   *
  !          * i-direction, without halo's, followed by extrapolation in  *
  !          * j-direction, with i-halo's and finally extrapolation in    *
  !          * k-direction, with both i- and j-halo's. In this way also   *
  !          * the indirect halo's get a value, albeit a bit arbitrary.   *
  !          *                                                            *
  !          **************************************************************
  !
  imininternal = .false.
  jmininternal = .false.
  kmininternal = .false.
  imaxinternal = .false.
  jmaxinternal = .false.
  kmaxinternal = .false.
  ! Loop over all the subfaces to determine which ones do NOT need to be extrapolated.
  loopsubface:DO mm=1,nsubface
     IF (bctype(mm) .EQ. b2bmatch) THEN
        SELECT CASE  (bcfaceid(mm)) 
        CASE (imin) 
           imininternal = .true.
        CASE (imax) 
           imaxinternal = .true.
        CASE (jmin) 
           jmininternal = .true.
        CASE (jmax) 
           jmaxinternal = .true.
        CASE (kmin) 
           kmininternal = .true.
        CASE (kmax) 
           kmaxinternal = .true.
        END SELECT
     END IF
  END DO loopsubface
  ! Re-loop back over and see if any subface that is NOT B2BMatch is
  ! on the same logical face as a Block2Block. We cannot deal with
  ! properly so will print an error and quit
  err = .false.
  loopsubface2:DO mm=1,nsubface
     IF (bctype(mm) .NE. b2bmatch) THEN
        SELECT CASE  (bcfaceid(mm)) 
        CASE (imin) 
           IF (imininternal) err = .true.
        CASE (imax) 
           IF (imaxinternal) err = .true.
        CASE (jmin) 
           IF (jmininternal) err = .true.
        CASE (jmax) 
           IF (jmaxinternal) err = .true.
        CASE (kmin) 
           IF (kmininternal) err = .true.
        CASE (kmax) 
           IF (kmaxinternal) err = .true.
        END SELECT
     END IF
  END DO loopsubface2
  IF (err) THEN
     STOP
  ELSE
     ! Extrapolation in i-direction.
     DO k=1,kl
        DO j=1,jl
           IF (.NOT.imininternal) THEN
              x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
              x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
              x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
              CALL PUSHCONTROL1B(0)
           ELSE
              CALL PUSHCONTROL1B(1)
           END IF
           IF (.NOT.imaxinternal) THEN
              tmp = two*x(il, j, k, 1) - x(nx, j, k, 1)
              x(ie, j, k, 1) = tmp
              tmp0 = two*x(il, j, k, 2) - x(nx, j, k, 2)
              x(ie, j, k, 2) = tmp0
              tmp1 = two*x(il, j, k, 3) - x(nx, j, k, 3)
              x(ie, j, k, 3) = tmp1
              CALL PUSHCONTROL1B(1)
           ELSE
              CALL PUSHCONTROL1B(0)
           END IF
        END DO
     END DO
     ! Extrapolation in j-direction.
     DO k=1,kl
        DO i=0,ie
           IF (.NOT.jmininternal) THEN
              x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
              x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
              x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
              CALL PUSHCONTROL1B(0)
           ELSE
              CALL PUSHCONTROL1B(1)
           END IF
           IF (.NOT.jmaxinternal) THEN
              tmp2 = two*x(i, jl, k, 1) - x(i, ny, k, 1)
              x(i, je, k, 1) = tmp2
              tmp3 = two*x(i, jl, k, 2) - x(i, ny, k, 2)
              x(i, je, k, 2) = tmp3
              tmp4 = two*x(i, jl, k, 3) - x(i, ny, k, 3)
              x(i, je, k, 3) = tmp4
              CALL PUSHCONTROL1B(1)
           ELSE
              CALL PUSHCONTROL1B(0)
           END IF
        END DO
     END DO
     ! Extrapolation in k-direction.
     DO j=0,je
        DO i=0,ie
           IF (.NOT.kmininternal) THEN
              x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
              x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
              x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
              CALL PUSHCONTROL1B(0)
           ELSE
              CALL PUSHCONTROL1B(1)
           END IF
           IF (.NOT.kmaxinternal) THEN
              tmp5 = two*x(i, j, kl, 1) - x(i, j, nz, 1)
              x(i, j, ke, 1) = tmp5
              tmp6 = two*x(i, j, kl, 2) - x(i, j, nz, 2)
              x(i, j, ke, 2) = tmp6
              tmp7 = two*x(i, j, kl, 3) - x(i, j, nz, 3)
              x(i, j, ke, 3) = tmp7
              CALL PUSHCONTROL1B(1)
           ELSE
              CALL PUSHCONTROL1B(0)
           END IF
        END DO
     END DO
     !
     !          **************************************************************
     !          *                                                            *
     !          * Mirror the halo coordinates adjacent to the symmetry       *
     !          * planes                                                     *
     !          *                                                            *
     !          **************************************************************
     !
     ! Loop over boundary subfaces.
     loopbocos:DO mm=1,nbocos
        ! The actual correction of the coordinates only takes
        ! place for symmetry planes.
        IF (bctype(mm) .EQ. symm) THEN
           ! Set some variables, depending on the block face on
           ! which the subface is located.
           SELECT CASE  (bcfaceid(mm)) 
           CASE (imin) 
              ibeg = jnbeg(mm)
              iend = jnend(mm)
              CALL PUSHINTEGER4(iimax)
              iimax = jl
              jbeg = knbeg(mm)
              jend = knend(mm)
              CALL PUSHINTEGER4(jjmax)
              jjmax = kl
              CALL PUSHPOINTER4(x0b)
              x0b => xb(0, :, :, :)
              CALL PUSHPOINTER4(x1b)
              x1b => xb(1, :, :, :)
              CALL PUSHPOINTER4(x1)
              x1 => x(1, :, :, :)
              CALL PUSHPOINTER4(x2b)
              x2b => xb(2, :, :, :)
              CALL PUSHPOINTER4(x2)
              x2 => x(2, :, :, :)
              CALL PUSHCONTROL3B(1)
           CASE (imax) 
              ibeg = jnbeg(mm)
              iend = jnend(mm)
              CALL PUSHINTEGER4(iimax)
              iimax = jl
              jbeg = knbeg(mm)
              jend = knend(mm)
              CALL PUSHINTEGER4(jjmax)
              jjmax = kl
              CALL PUSHPOINTER4(x0b)
              x0b => xb(ie, :, :, :)
              CALL PUSHPOINTER4(x1b)
              x1b => xb(il, :, :, :)
              CALL PUSHPOINTER4(x1)
              x1 => x(il, :, :, :)
              CALL PUSHPOINTER4(x2b)
              x2b => xb(nx, :, :, :)
              CALL PUSHPOINTER4(x2)
              x2 => x(nx, :, :, :)
              CALL PUSHCONTROL3B(2)
           CASE (jmin) 
              ibeg = inbeg(mm)
              iend = inend(mm)
              CALL PUSHINTEGER4(iimax)
              iimax = il
              jbeg = knbeg(mm)
              jend = knend(mm)
              CALL PUSHINTEGER4(jjmax)
              jjmax = kl
              CALL PUSHPOINTER4(x0b)
              x0b => xb(:, 0, :, :)
              CALL PUSHPOINTER4(x1b)
              x1b => xb(:, 1, :, :)
              CALL PUSHPOINTER4(x1)
              x1 => x(:, 1, :, :)
              CALL PUSHPOINTER4(x2b)
              x2b => xb(:, 2, :, :)
              CALL PUSHPOINTER4(x2)
              x2 => x(:, 2, :, :)
              CALL PUSHCONTROL3B(3)
           CASE (jmax) 
              ibeg = inbeg(mm)
              iend = inend(mm)
              CALL PUSHINTEGER4(iimax)
              iimax = il
              jbeg = knbeg(mm)
              jend = knend(mm)
              CALL PUSHINTEGER4(jjmax)
              jjmax = kl
              CALL PUSHPOINTER4(x0b)
              x0b => xb(:, je, :, :)
              CALL PUSHPOINTER4(x1b)
              x1b => xb(:, jl, :, :)
              CALL PUSHPOINTER4(x1)
              x1 => x(:, jl, :, :)
              CALL PUSHPOINTER4(x2b)
              x2b => xb(:, ny, :, :)
              CALL PUSHPOINTER4(x2)
              x2 => x(:, ny, :, :)
              CALL PUSHCONTROL3B(4)
           CASE (kmin) 
              ibeg = inbeg(mm)
              iend = inend(mm)
              CALL PUSHINTEGER4(iimax)
              iimax = il
              jbeg = jnbeg(mm)
              jend = jnend(mm)
              CALL PUSHINTEGER4(jjmax)
              jjmax = jl
              CALL PUSHPOINTER4(x0b)
              x0b => xb(:, :, 0, :)
              CALL PUSHPOINTER4(x1b)
              x1b => xb(:, :, 1, :)
              CALL PUSHPOINTER4(x1)
              x1 => x(:, :, 1, :)
              CALL PUSHPOINTER4(x2b)
              x2b => xb(:, :, 2, :)
              CALL PUSHPOINTER4(x2)
              x2 => x(:, :, 2, :)
              CALL PUSHCONTROL3B(5)
           CASE (kmax) 
              ibeg = inbeg(mm)
              iend = inend(mm)
              CALL PUSHINTEGER4(iimax)
              iimax = il
              jbeg = jnbeg(mm)
              jend = jnend(mm)
              CALL PUSHINTEGER4(jjmax)
              jjmax = jl
              CALL PUSHPOINTER4(x0b)
              x0b => xb(:, :, ke, :)
              CALL PUSHPOINTER4(x1b)
              x1b => xb(:, :, kl, :)
              CALL PUSHPOINTER4(x1)
              x1 => x(:, :, kl, :)
              CALL PUSHPOINTER4(x2b)
              x2b => xb(:, :, nz, :)
              CALL PUSHPOINTER4(x2)
              x2 => x(:, :, nz, :)
              CALL PUSHCONTROL3B(6)
           CASE DEFAULT
              CALL PUSHCONTROL3B(0)
           END SELECT
           CALL PUSHREAL8(v1(1))
           ! Determine the vector from the lower left corner to
           ! the upper right corner. Due to the usage of pointers
           ! an offset of +1 must be used, because the original
           ! array x start at 0.
           v1(1) = x1(iimax+1, jjmax+1, 1) - x1(1+1, 1+1, 1)
           CALL PUSHREAL8(v1(2))
           v1(2) = x1(iimax+1, jjmax+1, 2) - x1(1+1, 1+1, 2)
           CALL PUSHREAL8(v1(3))
           v1(3) = x1(iimax+1, jjmax+1, 3) - x1(1+1, 1+1, 3)
           CALL PUSHREAL8(v2(1))
           ! And the vector from the upper left corner to the
           ! lower right corner.
           v2(1) = x1(iimax+1, 1+1, 1) - x1(1+1, jjmax+1, 1)
           CALL PUSHREAL8(v2(2))
           v2(2) = x1(iimax+1, 1+1, 2) - x1(1+1, jjmax+1, 2)
           CALL PUSHREAL8(v2(3))
           v2(3) = x1(iimax+1, 1+1, 3) - x1(1+1, jjmax+1, 3)
           CALL PUSHREAL8(norm(1))
           ! Determine the normal of the face by taking the cross
           ! product of v1 and v2 and add it to norm.
           norm(1) = v1(2)*v2(3) - v1(3)*v2(2)
           CALL PUSHREAL8(norm(2))
           norm(2) = v1(3)*v2(1) - v1(1)*v2(3)
           CALL PUSHREAL8(norm(3))
           norm(3) = v1(1)*v2(2) - v1(2)*v2(1)
           CALL PUSHREAL8(length)
           ! Compute the length of the normal and test if this is
           ! larger than eps. If this is the case this means that
           ! it is a nonsingular subface and the coordinates are
           ! corrected.
           length = SQRT(norm(1)**2 + norm(2)**2 + norm(3)**2)
           IF (length .GT. eps) THEN
              CALL PUSHREAL8(norm(1))
              ! Compute the unit normal of the subface.
              norm(1) = norm(1)/length
              CALL PUSHREAL8(norm(2))
              norm(2) = norm(2)/length
              CALL PUSHREAL8(norm(3))
              norm(3) = norm(3)/length
              ! Add an overlap to the symmetry subface if the
              ! boundaries coincide with the block boundaries.
              ! This way the indirect halo's are treated properly.
              IF (ibeg .EQ. 1) ibeg = 0
              IF (iend .EQ. iimax) iend = iimax + 1
              IF (jbeg .EQ. 1) jbeg = 0
              IF (jend .EQ. jjmax) jend = jjmax + 1
              ad_from0 = jbeg
              ! Loop over the nodes of the subface and set the
              ! corresponding halo coordinates.
              DO j=ad_from0,jend
                 ad_from = ibeg
                 DO i=ad_from,iend
                    CALL PUSHREAL8(v1(1))
                    ! Determine the vector from the internal node to the
                    ! node on the face. Again an offset of +1 must be
                    ! used, due to the usage of pointers.
                    v1(1) = x1(i+1, j+1, 1) - x2(i+1, j+1, 1)
                    CALL PUSHREAL8(v1(2))
                    v1(2) = x1(i+1, j+1, 2) - x2(i+1, j+1, 2)
                    CALL PUSHREAL8(v1(3))
                    v1(3) = x1(i+1, j+1, 3) - x2(i+1, j+1, 3)
                    ! Determine two times the normal component of this
                    ! vector; this vector must be added to the
                    ! coordinates of the internal node to obtain the
                    ! halo coordinates. Again the offset of +1.
                    dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                    tmp8 = x2(i+1, j+1, 1) + dot*norm(1)
                    x0(i+1, j+1, 1) = tmp8
                    tmp9 = x2(i+1, j+1, 2) + dot*norm(2)
                    x0(i+1, j+1, 2) = tmp9
                    tmp10 = x2(i+1, j+1, 3) + dot*norm(3)
                    x0(i+1, j+1, 3) = tmp10
                 END DO
                 CALL PUSHINTEGER4(i - 1)
                 CALL PUSHINTEGER4(ad_from)
              END DO
              CALL PUSHINTEGER4(j - 1)
              CALL PUSHINTEGER4(ad_from0)
              CALL PUSHCONTROL2B(2)
           ELSE
              CALL PUSHCONTROL2B(1)
           END IF
        ELSE
           CALL PUSHCONTROL2B(0)
        END IF
     END DO loopbocos
     v1b = 0.0_8
     v2b = 0.0_8
     normb = 0.0_8
     DO mm=nbocos,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
           IF (branch .EQ. 1) THEN
              lengthb = 0.0_8
           ELSE
              CALL POPINTEGER4(ad_from0)
              CALL POPINTEGER4(ad_to0)
              DO j=ad_to0,ad_from0,-1
                 CALL POPINTEGER4(ad_from)
                 CALL POPINTEGER4(ad_to)
                 DO i=ad_to,ad_from,-1
                    dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
                    tmp10b = x0b(i+1, j+1, 3)
                    x0b(i+1, j+1, 3) = 0.0_8
                    x2b(i+1, j+1, 3) = x2b(i+1, j+1, 3) + tmp10b
                    normb(3) = normb(3) + dot*tmp10b
                    tmp9b = x0b(i+1, j+1, 2)
                    x0b(i+1, j+1, 2) = 0.0_8
                    x2b(i+1, j+1, 2) = x2b(i+1, j+1, 2) + tmp9b
                    normb(2) = normb(2) + dot*tmp9b
                    tmp8b = x0b(i+1, j+1, 1)
                    dotb = norm(2)*tmp9b + norm(1)*tmp8b + norm(3)*tmp10b
                    x0b(i+1, j+1, 1) = 0.0_8
                    x2b(i+1, j+1, 1) = x2b(i+1, j+1, 1) + tmp8b
                    tempb0 = two*dotb
                    normb(1) = normb(1) + v1(1)*tempb0 + dot*tmp8b
                    v1b(1) = v1b(1) + norm(1)*tempb0
                    v1b(2) = v1b(2) + norm(2)*tempb0
                    normb(2) = normb(2) + v1(2)*tempb0
                    v1b(3) = v1b(3) + norm(3)*tempb0
                    normb(3) = normb(3) + v1(3)*tempb0
                    CALL POPREAL8(v1(3))
                    x1b(i+1, j+1, 3) = x1b(i+1, j+1, 3) + v1b(3)
                    x2b(i+1, j+1, 3) = x2b(i+1, j+1, 3) - v1b(3)
                    v1b(3) = 0.0_8
                    CALL POPREAL8(v1(2))
                    x1b(i+1, j+1, 2) = x1b(i+1, j+1, 2) + v1b(2)
                    x2b(i+1, j+1, 2) = x2b(i+1, j+1, 2) - v1b(2)
                    v1b(2) = 0.0_8
                    CALL POPREAL8(v1(1))
                    x1b(i+1, j+1, 1) = x1b(i+1, j+1, 1) + v1b(1)
                    x2b(i+1, j+1, 1) = x2b(i+1, j+1, 1) - v1b(1)
                    v1b(1) = 0.0_8
                 END DO
              END DO
              CALL POPREAL8(norm(3))
              lengthb = -(norm(3)*normb(3)/length**2)
              normb(3) = normb(3)/length
              CALL POPREAL8(norm(2))
              lengthb = lengthb - norm(2)*normb(2)/length**2
              normb(2) = normb(2)/length
              CALL POPREAL8(norm(1))
              lengthb = lengthb - norm(1)*normb(1)/length**2
              normb(1) = normb(1)/length
           END IF
           CALL POPREAL8(length)
           IF (norm(1)**2 + norm(2)**2 + norm(3)**2 .EQ. 0.0) THEN
              tempb = 0.0
           ELSE
              tempb = lengthb/(2.0*SQRT(norm(1)**2+norm(2)**2+norm(3)**2))
           END IF
           normb(1) = normb(1) + 2*norm(1)*tempb
           normb(2) = normb(2) + 2*norm(2)*tempb
           normb(3) = normb(3) + 2*norm(3)*tempb
           CALL POPREAL8(norm(3))
           v1b(1) = v1b(1) + v2(2)*normb(3)
           v2b(2) = v2b(2) + v1(1)*normb(3)
           v1b(2) = v1b(2) - v2(1)*normb(3)
           v2b(1) = v2b(1) - v1(2)*normb(3)
           normb(3) = 0.0_8
           CALL POPREAL8(norm(2))
           v1b(3) = v1b(3) + v2(1)*normb(2)
           v2b(1) = v2b(1) + v1(3)*normb(2)
           v1b(1) = v1b(1) - v2(3)*normb(2)
           v2b(3) = v2b(3) - v1(1)*normb(2)
           normb(2) = 0.0_8
           CALL POPREAL8(norm(1))
           v1b(2) = v1b(2) + v2(3)*normb(1)
           v2b(3) = v2b(3) + v1(2)*normb(1)
           v1b(3) = v1b(3) - v2(2)*normb(1)
           v2b(2) = v2b(2) - v1(3)*normb(1)
           normb(1) = 0.0_8
           CALL POPREAL8(v2(3))
           x1b(iimax+1, 1+1, 3) = x1b(iimax+1, 1+1, 3) + v2b(3)
           x1b(1+1, jjmax+1, 3) = x1b(1+1, jjmax+1, 3) - v2b(3)
           v2b(3) = 0.0_8
           CALL POPREAL8(v2(2))
           x1b(iimax+1, 1+1, 2) = x1b(iimax+1, 1+1, 2) + v2b(2)
           x1b(1+1, jjmax+1, 2) = x1b(1+1, jjmax+1, 2) - v2b(2)
           v2b(2) = 0.0_8
           CALL POPREAL8(v2(1))
           x1b(iimax+1, 1+1, 1) = x1b(iimax+1, 1+1, 1) + v2b(1)
           x1b(1+1, jjmax+1, 1) = x1b(1+1, jjmax+1, 1) - v2b(1)
           v2b(1) = 0.0_8
           CALL POPREAL8(v1(3))
           x1b(iimax+1, jjmax+1, 3) = x1b(iimax+1, jjmax+1, 3) + v1b(3)
           x1b(1+1, 1+1, 3) = x1b(1+1, 1+1, 3) - v1b(3)
           v1b(3) = 0.0_8
           CALL POPREAL8(v1(2))
           x1b(iimax+1, jjmax+1, 2) = x1b(iimax+1, jjmax+1, 2) + v1b(2)
           x1b(1+1, 1+1, 2) = x1b(1+1, 1+1, 2) - v1b(2)
           v1b(2) = 0.0_8
           CALL POPREAL8(v1(1))
           x1b(iimax+1, jjmax+1, 1) = x1b(iimax+1, jjmax+1, 1) + v1b(1)
           x1b(1+1, 1+1, 1) = x1b(1+1, 1+1, 1) - v1b(1)
           v1b(1) = 0.0_8
           CALL POPCONTROL3B(branch)
           IF (branch .LT. 3) THEN
              IF (branch .NE. 0) THEN
                 IF (branch .EQ. 1) THEN
                    CALL POPPOINTER4(x2)
                    CALL POPPOINTER4(x2b)
                    CALL POPPOINTER4(x1)
                    CALL POPPOINTER4(x1b)
                    CALL POPPOINTER4(x0b)
                    CALL POPINTEGER4(jjmax)
                    CALL POPINTEGER4(iimax)
                 ELSE
                    CALL POPPOINTER4(x2)
                    CALL POPPOINTER4(x2b)
                    CALL POPPOINTER4(x1)
                    CALL POPPOINTER4(x1b)
                    CALL POPPOINTER4(x0b)
                    CALL POPINTEGER4(jjmax)
                    CALL POPINTEGER4(iimax)
                 END IF
              END IF
           ELSE IF (branch .LT. 5) THEN
              IF (branch .EQ. 3) THEN
                 CALL POPPOINTER4(x2)
                 CALL POPPOINTER4(x2b)
                 CALL POPPOINTER4(x1)
                 CALL POPPOINTER4(x1b)
                 CALL POPPOINTER4(x0b)
                 CALL POPINTEGER4(jjmax)
                 CALL POPINTEGER4(iimax)
              ELSE
                 CALL POPPOINTER4(x2)
                 CALL POPPOINTER4(x2b)
                 CALL POPPOINTER4(x1)
                 CALL POPPOINTER4(x1b)
                 CALL POPPOINTER4(x0b)
                 CALL POPINTEGER4(jjmax)
                 CALL POPINTEGER4(iimax)
              END IF
           ELSE IF (branch .EQ. 5) THEN
              CALL POPPOINTER4(x2)
              CALL POPPOINTER4(x2b)
              CALL POPPOINTER4(x1)
              CALL POPPOINTER4(x1b)
              CALL POPPOINTER4(x0b)
              CALL POPINTEGER4(jjmax)
              CALL POPINTEGER4(iimax)
           ELSE
              CALL POPPOINTER4(x2)
              CALL POPPOINTER4(x2b)
              CALL POPPOINTER4(x1)
              CALL POPPOINTER4(x1b)
              CALL POPPOINTER4(x0b)
              CALL POPINTEGER4(jjmax)
              CALL POPINTEGER4(iimax)
           END IF
        END IF
     END DO
     DO j=je,0,-1
        DO i=ie,0,-1
           CALL POPCONTROL1B(branch)
           IF (branch .NE. 0) THEN
              tmp7b = xb(i, j, ke, 3)
              xb(i, j, ke, 3) = 0.0_8
              xb(i, j, kl, 3) = xb(i, j, kl, 3) + two*tmp7b
              xb(i, j, nz, 3) = xb(i, j, nz, 3) - tmp7b
              tmp6b = xb(i, j, ke, 2)
              xb(i, j, ke, 2) = 0.0_8
              xb(i, j, kl, 2) = xb(i, j, kl, 2) + two*tmp6b
              xb(i, j, nz, 2) = xb(i, j, nz, 2) - tmp6b
              tmp5b = xb(i, j, ke, 1)
              xb(i, j, ke, 1) = 0.0_8
              xb(i, j, kl, 1) = xb(i, j, kl, 1) + two*tmp5b
              xb(i, j, nz, 1) = xb(i, j, nz, 1) - tmp5b
           END IF
           CALL POPCONTROL1B(branch)
           IF (branch .EQ. 0) THEN
              xb(i, j, 1, 3) = xb(i, j, 1, 3) + two*xb(i, j, 0, 3)
              xb(i, j, 2, 3) = xb(i, j, 2, 3) - xb(i, j, 0, 3)
              xb(i, j, 0, 3) = 0.0_8
              xb(i, j, 1, 2) = xb(i, j, 1, 2) + two*xb(i, j, 0, 2)
              xb(i, j, 2, 2) = xb(i, j, 2, 2) - xb(i, j, 0, 2)
              xb(i, j, 0, 2) = 0.0_8
              xb(i, j, 1, 1) = xb(i, j, 1, 1) + two*xb(i, j, 0, 1)
              xb(i, j, 2, 1) = xb(i, j, 2, 1) - xb(i, j, 0, 1)
              xb(i, j, 0, 1) = 0.0_8
           END IF
        END DO
     END DO
     DO k=kl,1,-1
        DO i=ie,0,-1
           CALL POPCONTROL1B(branch)
           IF (branch .NE. 0) THEN
              tmp4b = xb(i, je, k, 3)
              xb(i, je, k, 3) = 0.0_8
              xb(i, jl, k, 3) = xb(i, jl, k, 3) + two*tmp4b
              xb(i, ny, k, 3) = xb(i, ny, k, 3) - tmp4b
              tmp3b = xb(i, je, k, 2)
              xb(i, je, k, 2) = 0.0_8
              xb(i, jl, k, 2) = xb(i, jl, k, 2) + two*tmp3b
              xb(i, ny, k, 2) = xb(i, ny, k, 2) - tmp3b
              tmp2b = xb(i, je, k, 1)
              xb(i, je, k, 1) = 0.0_8
              xb(i, jl, k, 1) = xb(i, jl, k, 1) + two*tmp2b
              xb(i, ny, k, 1) = xb(i, ny, k, 1) - tmp2b
           END IF
           CALL POPCONTROL1B(branch)
           IF (branch .EQ. 0) THEN
              xb(i, 1, k, 3) = xb(i, 1, k, 3) + two*xb(i, 0, k, 3)
              xb(i, 2, k, 3) = xb(i, 2, k, 3) - xb(i, 0, k, 3)
              xb(i, 0, k, 3) = 0.0_8
              xb(i, 1, k, 2) = xb(i, 1, k, 2) + two*xb(i, 0, k, 2)
              xb(i, 2, k, 2) = xb(i, 2, k, 2) - xb(i, 0, k, 2)
              xb(i, 0, k, 2) = 0.0_8
              xb(i, 1, k, 1) = xb(i, 1, k, 1) + two*xb(i, 0, k, 1)
              xb(i, 2, k, 1) = xb(i, 2, k, 1) - xb(i, 0, k, 1)
              xb(i, 0, k, 1) = 0.0_8
           END IF
        END DO
     END DO
     DO k=kl,1,-1
        DO j=jl,1,-1
           CALL POPCONTROL1B(branch)
           IF (branch .NE. 0) THEN
              tmp1b = xb(ie, j, k, 3)
              xb(ie, j, k, 3) = 0.0_8
              xb(il, j, k, 3) = xb(il, j, k, 3) + two*tmp1b
              xb(nx, j, k, 3) = xb(nx, j, k, 3) - tmp1b
              tmp0b = xb(ie, j, k, 2)
              xb(ie, j, k, 2) = 0.0_8
              xb(il, j, k, 2) = xb(il, j, k, 2) + two*tmp0b
              xb(nx, j, k, 2) = xb(nx, j, k, 2) - tmp0b
              tmpb = xb(ie, j, k, 1)
              xb(ie, j, k, 1) = 0.0_8
              xb(il, j, k, 1) = xb(il, j, k, 1) + two*tmpb
              xb(nx, j, k, 1) = xb(nx, j, k, 1) - tmpb
           END IF
           CALL POPCONTROL1B(branch)
           IF (branch .EQ. 0) THEN
              xb(1, j, k, 3) = xb(1, j, k, 3) + two*xb(0, j, k, 3)
              xb(2, j, k, 3) = xb(2, j, k, 3) - xb(0, j, k, 3)
              xb(0, j, k, 3) = 0.0_8
              xb(1, j, k, 2) = xb(1, j, k, 2) + two*xb(0, j, k, 2)
              xb(2, j, k, 2) = xb(2, j, k, 2) - xb(0, j, k, 2)
              xb(0, j, k, 2) = 0.0_8
              xb(1, j, k, 1) = xb(1, j, k, 1) + two*xb(0, j, k, 1)
              xb(2, j, k, 1) = xb(2, j, k, 1) - xb(0, j, k, 1)
              xb(0, j, k, 1) = 0.0_8
           END IF
        END DO
     END DO
  END IF
END SUBROUTINE XHALO_BLOCK_B

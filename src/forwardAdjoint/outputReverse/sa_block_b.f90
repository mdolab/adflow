   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of sa_block in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *dw *w *rlv *vol *si *sj
   !                *sk (global)timeref (global)winf[1:10]
   !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *dw *w *rlv
   !                *bvtk1 *bvtk2 *vol *d2wall *si *sj *sk *bvti1
   !                *bvti2 (global)timeref (global)winf[1:10]
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in dw:in
   !                w:in rlv:in bvtk1:in bvtk2:in vol:in d2wall:in
   !                si:in sj:in sk:in bvti1:in bvti2:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          sa.f90                                          *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 06-11-2003                                      *
   !      * Last modified: 04-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE SA_BLOCK_B(resonly)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * sa solves the transport equation for the Spalart-Allmaras      *
   !      * turbulence model in a segregated manner using a diagonal       *
   !      * dominant ADI-scheme.                                           *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE INPUTTIMESPECTRAL
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine argument.
   !
   LOGICAL, INTENT(IN) :: resonly
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, sps
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   ! Set the arrays for the boundary condition treatment.
   CALL PUSHREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2, 3&
   &               )*SIZE(bmtj2, 4))
   CALL PUSHREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1, 3&
   &               )*SIZE(bmtj1, 4))
   CALL PUSHREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2, 3&
   &               )*SIZE(bmti2, 4))
   CALL PUSHREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1, 3&
   &               )*SIZE(bmti1, 4))
   CALL PUSHREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2, 3&
   &               )*SIZE(bmtk2, 4))
   CALL PUSHREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1, 3&
   &               )*SIZE(bmtk1, 4))
   CALL BCTURBTREATMENT()
   ! Solve the transport equation for nuTilde.
   ! The eddy viscosity and the boundary conditions are only
   ! applied if an actual update has been computed in saSolve.
   IF (.NOT.resonly) THEN
   bvti2b = 0.0_8
   bvti1b = 0.0_8
   bvtk2b = 0.0_8
   bvtk1b = 0.0_8
   bvtj2b = 0.0_8
   bvtj1b = 0.0_8
   CALL APPLYALLTURBBCTHISBLOCK_B(.true.)
   CALL SAEDDYVISCOSITY_B()
   ELSE
   bvtj1b = 0.0_8
   bvtj2b = 0.0_8
   bvtk1b = 0.0_8
   bvtk2b = 0.0_8
   bvti1b = 0.0_8
   bvti2b = 0.0_8
   END IF
   CALL SASOLVE_B(resonly)
   CALL POPREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1, 3)&
   &              *SIZE(bmtk1, 4))
   CALL POPREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2, 3)&
   &              *SIZE(bmtk2, 4))
   CALL POPREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1, 3)&
   &              *SIZE(bmti1, 4))
   CALL POPREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2, 3)&
   &              *SIZE(bmti2, 4))
   CALL POPREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1, 3)&
   &              *SIZE(bmtj1, 4))
   CALL POPREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2, 3)&
   &              *SIZE(bmtj2, 4))
   CALL BCTURBTREATMENT_B()
   END SUBROUTINE SA_BLOCK_B

!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of sa_block in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: *rev *dw *w *rlv *vol *si *sj
!                *sk (global)timeref (global)winf[1:10]
!   with respect to varying inputs: *rev *dw *w *rlv *vol *d2wall
!                *si *sj *sk (global)timeref (global)winf[1:10]
!   plus diff mem management of: rev:in bvtj1:in bvtj2:in dw:in
!                w:in rlv:in bvtk1:in bvtk2:in vol:in d2wall:in
!                si:in sj:in sk:in bvti1:in bvti2:in bcdata:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          sa.f90                                          *
!      * author:        georgi kalitzin, edwin van der weide            *
!      * starting date: 06-11-2003                                      *
!      * last modified: 04-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine sa_block_b(resonly)
!
!      ******************************************************************
!      *                                                                *
!      * sa solves the transport equation for the spalart-allmaras      *
!      * turbulence model in a segregated manner using a diagonal       *
!      * dominant adi-scheme.                                           *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use inputtimespectral
  use iteration
  implicit none
!
!      subroutine argument.
!
  logical, intent(in) :: resonly
!
!      local variables.
!
  integer(kind=inttype) :: nn, sps
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
! set the arrays for the boundary condition treatment.
  call pushreal8array(bmtj2, size(bmtj2, 1)*size(bmtj2, 2)*size(bmtj2, 3&
&               )*size(bmtj2, 4))
  call pushreal8array(bmtj1, size(bmtj1, 1)*size(bmtj1, 2)*size(bmtj1, 3&
&               )*size(bmtj1, 4))
  call pushreal8array(bmti2, size(bmti2, 1)*size(bmti2, 2)*size(bmti2, 3&
&               )*size(bmti2, 4))
  call pushreal8array(bmti1, size(bmti1, 1)*size(bmti1, 2)*size(bmti1, 3&
&               )*size(bmti1, 4))
  call pushreal8array(bmtk2, size(bmtk2, 1)*size(bmtk2, 2)*size(bmtk2, 3&
&               )*size(bmtk2, 4))
  call pushreal8array(bmtk1, size(bmtk1, 1)*size(bmtk1, 2)*size(bmtk1, 3&
&               )*size(bmtk1, 4))
  call bcturbtreatment()
! solve the transport equation for nutilde.
! the eddy viscosity and the boundary conditions are only
! applied if an actual update has been computed in sasolve.
  if (.not.resonly) then
    call applyallturbbcthisblock_b(.true.)
    call saeddyviscosity_b()
  else
    bvtj1d = 0.0_8
    bvtj2d = 0.0_8
    bvtk1d = 0.0_8
    bvtk2d = 0.0_8
    bvti1d = 0.0_8
    bvti2d = 0.0_8
  end if
  call sasolve_b(resonly)
  call popreal8array(bmtk1, size(bmtk1, 1)*size(bmtk1, 2)*size(bmtk1, 3)&
&              *size(bmtk1, 4))
  call popreal8array(bmtk2, size(bmtk2, 1)*size(bmtk2, 2)*size(bmtk2, 3)&
&              *size(bmtk2, 4))
  call popreal8array(bmti1, size(bmti1, 1)*size(bmti1, 2)*size(bmti1, 3)&
&              *size(bmti1, 4))
  call popreal8array(bmti2, size(bmti2, 1)*size(bmti2, 2)*size(bmti2, 3)&
&              *size(bmti2, 4))
  call popreal8array(bmtj1, size(bmtj1, 1)*size(bmtj1, 2)*size(bmtj1, 3)&
&              *size(bmtj1, 4))
  call popreal8array(bmtj2, size(bmtj2, 1)*size(bmtj2, 2)*size(bmtj2, 3)&
&              *size(bmtj2, 4))
  call bcturbtreatment_b()
end subroutine sa_block_b

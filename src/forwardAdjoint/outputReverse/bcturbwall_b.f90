   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcturbwall in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *bvtj1 *bvtj2 *w *rlv *bvtk1
   !                *bvtk2 *d2wall *bvti1 *bvti2
   !   with respect to varying inputs: *bvtj1 *bvtj2 *w *rlv *bvtk1
   !                *bvtk2 *d2wall *bvti1 *bvti2
   !   Plus diff mem management of: bvtj1:in bvtj2:in w:in rlv:in
   !                bvtk1:in bvtk2:in d2wall:in bvti1:in bvti2:in
   !                bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcTurbWall.F90                                  *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 06-26-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCTURBWALL_B(nn)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcTurbWall applies the implicit treatment of the viscous       *
   !      * wall boundary condition for the turbulence model used to the   *
   !      * given subface nn.                                              *
   !      * It is assumed that the pointers in blockPointers are           *
   !      * already set to the correct block.                              *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE CONSTANTS
   USE PARAMTURB
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: nn
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, ii, jj, iimax, jjmax
   REAL(kind=realtype) :: tmpd, tmpe, tmpf, nu
   REAL(kind=realtype) :: tmpdd, nud
   REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: bmt
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: bvt, ww2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv2, dd2wall
   INTRINSIC MIN
   INTRINSIC MAX
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: temp10
   INTEGER(kind=inttype) :: y12
   INTEGER(kind=inttype) :: y11
   INTEGER(kind=inttype) :: y10
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   INTEGER(kind=inttype) :: y9
   REAL(kind=realtype) :: temp
   INTEGER(kind=inttype) :: y8
   INTEGER(kind=inttype) :: y7
   INTEGER(kind=inttype) :: y6
   REAL(kind=realtype) :: temp9
   INTEGER(kind=inttype) :: y5
   REAL(kind=realtype) :: temp8
   INTEGER(kind=inttype) :: y4
   REAL(kind=realtype) :: temp7
   INTEGER(kind=inttype) :: y3
   REAL(kind=realtype) :: temp6
   INTEGER(kind=inttype) :: y2
   REAL(kind=realtype) :: temp5
   INTEGER(kind=inttype) :: y1
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the turbulence model used and loop over the faces
   ! of the subface and set the values of bmt and bvt for an
   ! implicit treatment.
   SELECT CASE  (turbmodel) 
   CASE (spalartallmaras, spalartallmarasedwards) 
      CASE (komegawilcox, komegamodified, mentersst) 
   !        ================================================================
   ! K-omega type of models. K is zero on the wall and thus the
   ! halo value is the negative of the first internal cell.
   ! For omega the situation is a bit more complicated.
   ! Theoretically omega is infinity, but it is set to a large
   ! value, see menter's paper. The halo value is constructed
   ! such that the wall value is correct. Make sure that i and j
   ! are limited to physical dimensions of the face for the wall
   ! distance. Due to the usage of the dd2Wall pointer and the
   ! fact that the original d2Wall array starts at 2, there is
   ! an offset of -1 present in dd2Wall.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   iimax = jl
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y1 = jjmax
   ELSE
   y1 = j
   END IF
   IF (2 .LT. y1) THEN
   CALL PUSHINTEGER4(jj)
   jj = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(jj)
   jj = 2
   CALL PUSHCONTROL1B(1)
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y2 = iimax
   ELSE
   y2 = i
   END IF
   IF (2 .LT. y2) THEN
   CALL PUSHINTEGER4(ii)
   ii = y2
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(ii)
   ii = 2
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nu = rlv(2, i, j)/w(2, i, j, irho)
   tmpd = one/(rkwbeta1*d2wall(2, ii, jj)**2)
   tempd = two*60.0_realType*bvti1d(i, j, itu2)
   nud = tmpd*tempd
   tmpdd = nu*tempd
   bvti1d(i, j, itu2) = 0.0_8
   temp0 = rkwbeta1*d2wall(2, ii, jj)**2
   d2walld(2, ii, jj) = d2walld(2, ii, jj) - rkwbeta1*one*2*&
   &           d2wall(2, ii, jj)*tmpdd/temp0**2
   temp = w(2, i, j, irho)
   rlvd(2, i, j) = rlvd(2, i, j) + nud/temp
   wd(2, i, j, irho) = wd(2, i, j, irho) - rlv(2, i, j)*nud/temp&
   &           **2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ii)
   ELSE
   CALL POPINTEGER4(ii)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(jj)
   ELSE
   CALL POPINTEGER4(jj)
   END IF
   END DO
   CASE (imax) 
   iimax = jl
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y3 = jjmax
   ELSE
   y3 = j
   END IF
   IF (2 .LT. y3) THEN
   CALL PUSHINTEGER4(jj)
   jj = y3
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(jj)
   jj = 2
   CALL PUSHCONTROL1B(1)
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y4 = iimax
   ELSE
   y4 = i
   END IF
   IF (2 .LT. y4) THEN
   CALL PUSHINTEGER4(ii)
   ii = y4
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(ii)
   ii = 2
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nu = rlv(jl, i, j)/w(il, i, j, irho)
   tmpd = one/(rkwbeta1*d2wall(il, ii, jj)**2)
   tempd0 = two*60.0_realType*bvti2d(i, j, itu2)
   nud = tmpd*tempd0
   tmpdd = nu*tempd0
   bvti2d(i, j, itu2) = 0.0_8
   temp2 = rkwbeta1*d2wall(il, ii, jj)**2
   d2walld(il, ii, jj) = d2walld(il, ii, jj) - rkwbeta1*one*2*&
   &           d2wall(il, ii, jj)*tmpdd/temp2**2
   temp1 = w(il, i, j, irho)
   rlvd(jl, i, j) = rlvd(jl, i, j) + nud/temp1
   wd(il, i, j, irho) = wd(il, i, j, irho) - rlv(jl, i, j)*nud/&
   &           temp1**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ii)
   ELSE
   CALL POPINTEGER4(ii)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(jj)
   ELSE
   CALL POPINTEGER4(jj)
   END IF
   END DO
   CASE (jmin) 
   iimax = il
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y5 = jjmax
   ELSE
   y5 = j
   END IF
   IF (2 .LT. y5) THEN
   CALL PUSHINTEGER4(jj)
   jj = y5
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(jj)
   jj = 2
   CALL PUSHCONTROL1B(1)
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y6 = iimax
   ELSE
   y6 = i
   END IF
   IF (2 .LT. y6) THEN
   CALL PUSHINTEGER4(ii)
   ii = y6
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(ii)
   ii = 2
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nu = rlv(i, 2, j)/w(i, 2, j, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, 2, jj)**2)
   tempd1 = two*60.0_realType*bvtj1d(i, j, itu2)
   nud = tmpd*tempd1
   tmpdd = nu*tempd1
   bvtj1d(i, j, itu2) = 0.0_8
   temp4 = rkwbeta1*d2wall(ii, 2, jj)**2
   d2walld(ii, 2, jj) = d2walld(ii, 2, jj) - rkwbeta1*one*2*&
   &           d2wall(ii, 2, jj)*tmpdd/temp4**2
   temp3 = w(i, 2, j, irho)
   rlvd(i, 2, j) = rlvd(i, 2, j) + nud/temp3
   wd(i, 2, j, irho) = wd(i, 2, j, irho) - rlv(i, 2, j)*nud/temp3&
   &           **2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ii)
   ELSE
   CALL POPINTEGER4(ii)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(jj)
   ELSE
   CALL POPINTEGER4(jj)
   END IF
   END DO
   CASE (jmax) 
   iimax = il
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y7 = jjmax
   ELSE
   y7 = j
   END IF
   IF (2 .LT. y7) THEN
   CALL PUSHINTEGER4(jj)
   jj = y7
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(jj)
   jj = 2
   CALL PUSHCONTROL1B(1)
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y8 = iimax
   ELSE
   y8 = i
   END IF
   IF (2 .LT. y8) THEN
   CALL PUSHINTEGER4(ii)
   ii = y8
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(ii)
   ii = 2
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nu = rlv(i, jl, j)/w(i, jl, j, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, jl, jj)**2)
   tempd2 = two*60.0_realType*bvtj2d(i, j, itu2)
   nud = tmpd*tempd2
   tmpdd = nu*tempd2
   bvtj2d(i, j, itu2) = 0.0_8
   temp6 = rkwbeta1*d2wall(ii, jl, jj)**2
   d2walld(ii, jl, jj) = d2walld(ii, jl, jj) - rkwbeta1*one*2*&
   &           d2wall(ii, jl, jj)*tmpdd/temp6**2
   temp5 = w(i, jl, j, irho)
   rlvd(i, jl, j) = rlvd(i, jl, j) + nud/temp5
   wd(i, jl, j, irho) = wd(i, jl, j, irho) - rlv(i, jl, j)*nud/&
   &           temp5**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ii)
   ELSE
   CALL POPINTEGER4(ii)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(jj)
   ELSE
   CALL POPINTEGER4(jj)
   END IF
   END DO
   CASE (kmin) 
   iimax = il
   jjmax = jl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y9 = jjmax
   ELSE
   y9 = j
   END IF
   IF (2 .LT. y9) THEN
   CALL PUSHINTEGER4(jj)
   jj = y9
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(jj)
   jj = 2
   CALL PUSHCONTROL1B(1)
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y10 = iimax
   ELSE
   y10 = i
   END IF
   IF (2 .LT. y10) THEN
   CALL PUSHINTEGER4(ii)
   ii = y10
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(ii)
   ii = 2
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nu = rlv(i, j, 2)/w(i, j, 2, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, jj, 2)**2)
   tempd3 = two*60.0_realType*bvtk1d(i, j, itu2)
   nud = tmpd*tempd3
   tmpdd = nu*tempd3
   bvtk1d(i, j, itu2) = 0.0_8
   temp8 = rkwbeta1*d2wall(ii, jj, 2)**2
   d2walld(ii, jj, 2) = d2walld(ii, jj, 2) - rkwbeta1*one*2*&
   &           d2wall(ii, jj, 2)*tmpdd/temp8**2
   temp7 = w(i, j, 2, irho)
   rlvd(i, j, 2) = rlvd(i, j, 2) + nud/temp7
   wd(i, j, 2, irho) = wd(i, j, 2, irho) - rlv(i, j, 2)*nud/temp7&
   &           **2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ii)
   ELSE
   CALL POPINTEGER4(ii)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(jj)
   ELSE
   CALL POPINTEGER4(jj)
   END IF
   END DO
   CASE (kmax) 
   iimax = il
   jjmax = jl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y11 = jjmax
   ELSE
   y11 = j
   END IF
   IF (2 .LT. y11) THEN
   CALL PUSHINTEGER4(jj)
   jj = y11
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(jj)
   jj = 2
   CALL PUSHCONTROL1B(1)
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y12 = iimax
   ELSE
   y12 = i
   END IF
   IF (2 .LT. y12) THEN
   CALL PUSHINTEGER4(ii)
   ii = y12
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHINTEGER4(ii)
   ii = 2
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nu = rlv(i, j, kl)/w(i, j, kl, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, jj, kl)**2)
   tempd4 = two*60.0_realType*bvtk2d(i, j, itu2)
   nud = tmpd*tempd4
   tmpdd = nu*tempd4
   bvtk2d(i, j, itu2) = 0.0_8
   temp10 = rkwbeta1*d2wall(ii, jj, kl)**2
   d2walld(ii, jj, kl) = d2walld(ii, jj, kl) - rkwbeta1*one*2*&
   &           d2wall(ii, jj, kl)*tmpdd/temp10**2
   temp9 = w(i, j, kl, irho)
   rlvd(i, j, kl) = rlvd(i, j, kl) + nud/temp9
   wd(i, j, kl, irho) = wd(i, j, kl, irho) - rlv(i, j, kl)*nud/&
   &           temp9**2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(ii)
   ELSE
   CALL POPINTEGER4(ii)
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPINTEGER4(jj)
   ELSE
   CALL POPINTEGER4(jj)
   END IF
   END DO
   END SELECT
   END SELECT
   END SUBROUTINE BCTURBWALL_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcturbwall in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *bvtj1 *bvtj2 *w *rlv *bvtk1
   !                *bvtk2 *bvti1 *bvti2
   !   with respect to varying inputs: *bvtj1 *bvtj2 *w *rlv *bvtk1
   !                *bvtk2 *bvti1 *bvti2
   !   Plus diff mem management of: bvtj1:in bvtj2:in w:in rlv:in
   !                bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcTurbWall.F90                                  *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 06-26-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCTURBWALL_B(nn)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcTurbWall applies the implicit treatment of the viscous       *
   !      * wall boundary condition for the turbulence model used to the   *
   !      * given subface nn.                                              *
   !      * It is assumed that the pointers in blockPointers are           *
   !      * already set to the correct block.                              *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE BCTYPES
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE CONSTANTS
   USE PARAMTURB
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: nn
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, ii, jj, iimax, jjmax
   REAL(kind=realtype) :: tmpd, tmpe, tmpf, nu
   REAL(kind=realtype) :: nub
   REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: bmt
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: bvt, ww2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv2, dd2wall
   INTRINSIC MIN
   INTRINSIC MAX
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   INTEGER(kind=inttype) :: y12
   INTEGER(kind=inttype) :: y11
   INTEGER(kind=inttype) :: y10
   INTEGER(kind=inttype) :: y9
   REAL(kind=realtype) :: temp
   INTEGER(kind=inttype) :: y8
   INTEGER(kind=inttype) :: y7
   INTEGER(kind=inttype) :: y6
   INTEGER(kind=inttype) :: y5
   INTEGER(kind=inttype) :: y4
   INTEGER(kind=inttype) :: y3
   INTEGER(kind=inttype) :: y2
   INTEGER(kind=inttype) :: y1
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the turbulence model used and loop over the faces
   ! of the subface and set the values of bmt and bvt for an
   ! implicit treatment.
   SELECT CASE  (turbmodel) 
   CASE (spalartallmaras, spalartallmarasedwards) 
      CASE (komegawilcox, komegamodified, mentersst) 
   !        ================================================================
   ! K-omega type of models. K is zero on the wall and thus the
   ! halo value is the negative of the first internal cell.
   ! For omega the situation is a bit more complicated.
   ! Theoretically omega is infinity, but it is set to a large
   ! value, see menter's paper. The halo value is constructed
   ! such that the wall value is correct. Make sure that i and j
   ! are limited to physical dimensions of the face for the wall
   ! distance. Due to the usage of the dd2Wall pointer and the
   ! fact that the original d2Wall array starts at 2, there is
   ! an offset of -1 present in dd2Wall.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   iimax = jl
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y1 = jjmax
   ELSE
   y1 = j
   END IF
   IF (2 .LT. y1) THEN
   jj = y1
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y2 = iimax
   ELSE
   y2 = i
   END IF
   IF (2 .LT. y2) THEN
   ii = y2
   ELSE
   ii = 2
   END IF
   CALL PUSHREAL8(tmpd)
   tmpd = one/(rkwbeta1*d2wall(2, ii, jj)**2)
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nub = two*60.0_realType*tmpd*bvti1b(i, j, itu2)
   bvti1b(i, j, itu2) = 0.0_8
   CALL POPREAL8(tmpd)
   temp = w(2, i, j, irho)
   rlvb(2, i, j) = rlvb(2, i, j) + nub/temp
   wb(2, i, j, irho) = wb(2, i, j, irho) - rlv(2, i, j)*nub/temp&
   &           **2
   END DO
   END DO
   CASE (imax) 
   iimax = jl
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y3 = jjmax
   ELSE
   y3 = j
   END IF
   IF (2 .LT. y3) THEN
   jj = y3
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y4 = iimax
   ELSE
   y4 = i
   END IF
   IF (2 .LT. y4) THEN
   ii = y4
   ELSE
   ii = 2
   END IF
   CALL PUSHREAL8(tmpd)
   tmpd = one/(rkwbeta1*d2wall(il, ii, jj)**2)
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nub = two*60.0_realType*tmpd*bvti2b(i, j, itu2)
   bvti2b(i, j, itu2) = 0.0_8
   CALL POPREAL8(tmpd)
   temp0 = w(il, i, j, irho)
   rlvb(jl, i, j) = rlvb(jl, i, j) + nub/temp0
   wb(il, i, j, irho) = wb(il, i, j, irho) - rlv(jl, i, j)*nub/&
   &           temp0**2
   END DO
   END DO
   CASE (jmin) 
   iimax = il
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y5 = jjmax
   ELSE
   y5 = j
   END IF
   IF (2 .LT. y5) THEN
   jj = y5
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y6 = iimax
   ELSE
   y6 = i
   END IF
   IF (2 .LT. y6) THEN
   ii = y6
   ELSE
   ii = 2
   END IF
   CALL PUSHREAL8(tmpd)
   tmpd = one/(rkwbeta1*d2wall(ii, 2, jj)**2)
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nub = two*60.0_realType*tmpd*bvtj1b(i, j, itu2)
   bvtj1b(i, j, itu2) = 0.0_8
   CALL POPREAL8(tmpd)
   temp1 = w(i, 2, j, irho)
   rlvb(i, 2, j) = rlvb(i, 2, j) + nub/temp1
   wb(i, 2, j, irho) = wb(i, 2, j, irho) - rlv(i, 2, j)*nub/temp1&
   &           **2
   END DO
   END DO
   CASE (jmax) 
   iimax = il
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y7 = jjmax
   ELSE
   y7 = j
   END IF
   IF (2 .LT. y7) THEN
   jj = y7
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y8 = iimax
   ELSE
   y8 = i
   END IF
   IF (2 .LT. y8) THEN
   ii = y8
   ELSE
   ii = 2
   END IF
   CALL PUSHREAL8(tmpd)
   tmpd = one/(rkwbeta1*d2wall(ii, jl, jj)**2)
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nub = two*60.0_realType*tmpd*bvtj2b(i, j, itu2)
   bvtj2b(i, j, itu2) = 0.0_8
   CALL POPREAL8(tmpd)
   temp2 = w(i, jl, j, irho)
   rlvb(i, jl, j) = rlvb(i, jl, j) + nub/temp2
   wb(i, jl, j, irho) = wb(i, jl, j, irho) - rlv(i, jl, j)*nub/&
   &           temp2**2
   END DO
   END DO
   CASE (kmin) 
   iimax = il
   jjmax = jl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y9 = jjmax
   ELSE
   y9 = j
   END IF
   IF (2 .LT. y9) THEN
   jj = y9
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y10 = iimax
   ELSE
   y10 = i
   END IF
   IF (2 .LT. y10) THEN
   ii = y10
   ELSE
   ii = 2
   END IF
   CALL PUSHREAL8(tmpd)
   tmpd = one/(rkwbeta1*d2wall(ii, jj, 2)**2)
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nub = two*60.0_realType*tmpd*bvtk1b(i, j, itu2)
   bvtk1b(i, j, itu2) = 0.0_8
   CALL POPREAL8(tmpd)
   temp3 = w(i, j, 2, irho)
   rlvb(i, j, 2) = rlvb(i, j, 2) + nub/temp3
   wb(i, j, 2, irho) = wb(i, j, 2, irho) - rlv(i, j, 2)*nub/temp3&
   &           **2
   END DO
   END DO
   CASE (kmax) 
   iimax = il
   jjmax = jl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y11 = jjmax
   ELSE
   y11 = j
   END IF
   IF (2 .LT. y11) THEN
   jj = y11
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y12 = iimax
   ELSE
   y12 = i
   END IF
   IF (2 .LT. y12) THEN
   ii = y12
   ELSE
   ii = 2
   END IF
   CALL PUSHREAL8(tmpd)
   tmpd = one/(rkwbeta1*d2wall(ii, jj, kl)**2)
   END DO
   END DO
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   nub = two*60.0_realType*tmpd*bvtk2b(i, j, itu2)
   bvtk2b(i, j, itu2) = 0.0_8
   CALL POPREAL8(tmpd)
   temp4 = w(i, j, kl, irho)
   rlvb(i, j, kl) = rlvb(i, j, kl) + nub/temp4
   wb(i, j, kl, irho) = wb(i, j, kl, irho) - rlv(i, j, kl)*nub/&
   &           temp4**2
   END DO
   END DO
   END SELECT
   END SELECT
   END SUBROUTINE BCTURBWALL_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of forcesandmoments in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *w *x *(*bcdata.fp) *(*bcdata.fv)
   !                *(*bcdata.m) *(*bcdata.oarea) *(*bcdata.sepsensor)
   !                *(*bcdata.cavitation) lengthref machcoef pointref
   !                gammainf pinf pref cfp cfv cmp cmv cavitation
   !                sepsensor
   !   with respect to varying inputs: *p *w *x *si *sj *sk *(*viscsubface.tau)
   !                *(*bcdata.fp) *(*bcdata.fv) *(*bcdata.m) *(*bcdata.oarea)
   !                *(*bcdata.sepsensor) *(*bcdata.cavitation) veldirfreestream
   !                lengthref machcoef pointref gammainf pinf pref
   !   Plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
   !                sj:in sk:in viscsubface:in *viscsubface.tau:in
   !                bcdata:in *bcdata.fp:in *bcdata.fv:in *bcdata.m:in
   !                *bcdata.oarea:in *bcdata.sepsensor:in *bcdata.cavitation:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          forcesAndMoments.f90                            *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 04-01-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE FORCESANDMOMENTS_B(cfp, cfpb, cfv, cfvb, cmp, cmpb, cmv, cmvb&
   & , yplusmax, sepsensor, sepsensorb, cavitation, cavitationb)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * forcesAndMoments computes the contribution of the block        *
   !      * given by the pointers in blockPointers to the force and        *
   !      * moment coefficients of the geometry. A distinction is made     *
   !      * between the inviscid and viscous parts. In case the maximum    *
   !      * yplus value must be monitored (only possible for rans), this   *
   !      * value is also computed. The separation sensor and the cavita-  *
   !      * tion sensor is also computed                                   *
   !      * here.                                                          *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_B
   USE BCTYPES
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !      Subroutine arguments
   !
   REAL(kind=realtype), DIMENSION(3) :: cfp, cfv
   REAL(kind=realtype), DIMENSION(3) :: cfpb, cfvb
   REAL(kind=realtype), DIMENSION(3) :: cmp, cmv
   REAL(kind=realtype), DIMENSION(3) :: cmpb, cmvb
   REAL(kind=realtype) :: yplusmax, sepsensor, cavitation
   REAL(kind=realtype) :: sepsensorb, cavitationb
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j
   REAL(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
   REAL(kind=realtype) :: pm1b, fxb, fyb, fzb
   REAL(kind=realtype) :: xc, yc, zc
   REAL(kind=realtype) :: xcb, ycb, zcb
   REAL(kind=realtype) :: fact, rho, mul, yplus, dwall
   REAL(kind=realtype) :: factb
   REAL(kind=realtype) :: scaledim, v(3), sensor, sensor1, cp, tmp, &
   & plocal
   REAL(kind=realtype) :: scaledimb, vb(3), sensorb, sensor1b, cpb, tmpb&
   & , plocalb
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxb, tauyyb, tauzzb
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyb, tauxzb, tauyzb
   REAL(kind=realtype), DIMENSION(3) :: refpoint
   REAL(kind=realtype), DIMENSION(3) :: refpointb
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww1, ww2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww1b, ww2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp1, pp2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp1b, pp2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rho2, rho1
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rho2b, rho1b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv1b, rlv2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rev1, rev2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rev1b, rev2b
   REAL(kind=realtype), DIMENSION(imaxdim - 2, jmaxdim - 2) :: dd2wall
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, 3) :: ss
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, 3) :: ssb
   REAL(kind=realtype), DIMENSION(imaxdim + 1, jmaxdim + 1, 3) :: xx
   REAL(kind=realtype), DIMENSION(imaxdim+1, jmaxdim+1, 3) :: xxb
   REAL(kind=realtype) :: mx, my, mz, qa
   REAL(kind=realtype) :: mxb, myb, mzb, qab
   LOGICAL :: viscoussubface
   INTRINSIC SQRT
   INTRINSIC EXP
   INTRINSIC MAX
   REAL(kind=realtype), DIMENSION(3) :: tmp0
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   INTEGER :: ad_from1
   INTEGER :: ad_to1
   INTEGER :: ad_from2
   INTEGER :: ad_to2
   INTEGER :: ad_from3
   INTEGER :: ad_to3
   INTEGER :: ad_from4
   INTEGER :: ad_to4
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2(3)
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb16
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb15
   REAL(kind=realtype) :: tempb14
   REAL(kind=realtype) :: tempb13
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: tmpb0(3)
   REAL(kind=realtype) :: tempb10
   REAL(kind=realtype) :: tempb
   INTEGER :: ii1
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Set the actual scaling factor such that ACTUAL forces are computed
   scaledim = pref/pinf
   ! Determine the reference point for the moment computation in
   ! meters.
   refpoint(1) = lref*pointref(1)
   refpoint(2) = lref*pointref(2)
   refpoint(3) = lref*pointref(3)
   ! Initialize the force and moment coefficients to 0 as well as
   ! yplusMax.
   cfp(1) = zero
   cfp(2) = zero
   cfp(3) = zero
   cfv(1) = zero
   cfv(2) = zero
   cfv(3) = zero
   cmp(1) = zero
   cmp(2) = zero
   cmp(3) = zero
   cmv(1) = zero
   cmv(2) = zero
   cmv(3) = zero
   ! Loop over the boundary subfaces of this block.
   bocos:DO nn=1,nbocos
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Integrate the inviscid contribution over the solid walls,    *
   !        * either inviscid or viscous. The integration is done with     *
   !        * cp. For closed contours this is equal to the integration     *
   !        * of p; for open contours this is not the case anymore.        *
   !        * Question is whether a force for an open contour is           *
   !        * meaningful anyway.                                           *
   !        *                                                              *
   !        ****************************************************************
   !
   IF ((bctype(nn) .EQ. eulerwall .OR. bctype(nn) .EQ. nswalladiabatic)&
   &       .OR. bctype(nn) .EQ. nswallisothermal) THEN
   ! Subface is a wall. Check if it is a viscous wall.
   viscoussubface = .true.
   IF (bctype(nn) .EQ. eulerwall) viscoussubface = .false.
   ! Set a bunch of pointers depending on the face id to make
   ! a generic treatment possible. The routine setBcPointers
   ! is not used, because quite a few other ones are needed.
   CALL PUSHREAL8ARRAY(pp2, imaxdim*jmaxdim)
   CALL PUSHREAL8ARRAY(pp1, imaxdim*jmaxdim)
   CALL SETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, rev1&
   &                        , rev2, 0)
   CALL PUSHREAL8ARRAY(ss, imaxdim*jmaxdim*3)
   CALL SETXXSSRHODD2WALLBWD(nn, xx, ss, rho1, rho2, dd2wall)
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   CALL PUSHREAL8(fact)
   fact = -one
   CALL PUSHCONTROL3B(1)
   CASE (imax) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = one
   CALL PUSHCONTROL3B(2)
   CASE (jmin) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = -one
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = one
   CALL PUSHCONTROL3B(4)
   CASE (kmin) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = -one
   CALL PUSHCONTROL3B(5)
   CASE (kmax) 
   !===========================================================
   CALL PUSHREAL8(fact)
   fact = one
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ! Loop over the quadrilateral faces of the subface. Note
   ! that the nodal range of BCData must be used and not the
   ! cell range, because the latter may include the halo's in i
   ! and j-direction. The offset +1 is there, because inBeg and
   ! jnBeg refer to nodal ranges and not to cell ranges.
   CALL PUSHREAL8ARRAY(bcdata(nn)%oarea, SIZE(bcdata(nn)%oarea, 1)*&
   &                   SIZE(bcdata(nn)%oarea, 2))
   bcdata(nn)%oarea(:, :) = zero
   ad_from0 = bcdata(nn)%jnbeg + 1
   DO j=ad_from0,bcdata(nn)%jnend
   ad_from = bcdata(nn)%inbeg + 1
   DO i=ad_from,bcdata(nn)%inend
   ! Compute the average pressure minus 1 and the coordinates
   ! of the centroid of the face relative from from the
   ! moment reference point. Due to the usage of pointers for
   ! the coordinates, whose original array starts at 0, an
   ! offset of 1 must be used. The pressure is multipled by
   ! fact to account for the possibility of an inward or
   ! outward pointing normal.
   CALL PUSHREAL8(pm1)
   pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*scaledim
   CALL PUSHREAL8(xc)
   xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j&
   &           +1, 1)) - refpoint(1)
   CALL PUSHREAL8(yc)
   yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j&
   &           +1, 2)) - refpoint(2)
   CALL PUSHREAL8(zc)
   zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j&
   &           +1, 3)) - refpoint(3)
   ! Compute the force components.
   CALL PUSHREAL8(fx)
   fx = pm1*ss(i, j, 1)
   CALL PUSHREAL8(fy)
   fy = pm1*ss(i, j, 2)
   CALL PUSHREAL8(fz)
   fz = pm1*ss(i, j, 3)
   ! Store Force data on face
   ! Scatter a quarter of the area to each node:
   CALL PUSHREAL8(qa)
   qa = fourth*SQRT(ss(i, j, 1)**2+ss(i, j, 2)**2+ss(i, j, 3)**2)
   CALL PUSHREAL8(bcdata(nn)%oarea(i-1, j-1))
   bcdata(nn)%oarea(i-1, j-1) = bcdata(nn)%oarea(i-1, j-1) + qa
   CALL PUSHREAL8(bcdata(nn)%oarea(i, j-1))
   bcdata(nn)%oarea(i, j-1) = bcdata(nn)%oarea(i, j-1) + qa
   CALL PUSHREAL8(bcdata(nn)%oarea(i-1, j))
   bcdata(nn)%oarea(i-1, j) = bcdata(nn)%oarea(i-1, j) + qa
   CALL PUSHREAL8(bcdata(nn)%oarea(i, j))
   bcdata(nn)%oarea(i, j) = bcdata(nn)%oarea(i, j) + qa
   ! Get normalized surface velocity:
   CALL PUSHREAL8(v(1))
   v(1) = ww2(i, j, ivx)
   CALL PUSHREAL8(v(2))
   v(2) = ww2(i, j, ivy)
   CALL PUSHREAL8(v(3))
   v(3) = ww2(i, j, ivz)
   tmp0 = v/(SQRT(v(1)**2+v(2)**2+v(3)**2)+1e-16)
   CALL PUSHREAL8ARRAY(v, 3)
   v = tmp0
   ! Dot product with free stream
   CALL PUSHREAL8(sensor)
   sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v&
   &           (3)*veldirfreestream(3))
   !Now run through a smooth heaviside function:
   CALL PUSHREAL8(sensor)
   sensor = one/(one+EXP(-(2*10*sensor)))
   ! And integrate over the area of this cell and save:
   CALL PUSHREAL8(plocal)
   plocal = pp2(i, j)
   CALL PUSHREAL8(tmp)
   tmp = two/(gammainf*pinf*machcoef*machcoef)
   cp = tmp*(plocal-pinf)
   sigma = 1.4
   CALL PUSHREAL8(sensor1)
   sensor1 = -cp - sigma
   !IF (sense >= 0) THEN
   !Sensor = 1
   !ELSE 
   !Sensor = 0
   !END IF
   CALL PUSHREAL8(sensor1)
   sensor1 = one/(one+EXP(-(2*10*sensor1)))
   ! Update the inviscid force and moment coefficients.
   cfp(1) = cfp(1) + fx
   cfp(2) = cfp(2) + fy
   cfp(3) = cfp(3) + fz
   mx = yc*fz - zc*fy
   my = zc*fx - xc*fz
   mz = xc*fy - yc*fx
   cmp(1) = cmp(1) + mx
   cmp(2) = cmp(2) + my
   cmp(3) = cmp(3) + mz
   ! Store Moment data on face
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   !
   !          **************************************************************
   !          *                                                            *
   !          * Integration of the viscous forces.                         *
   !          * Only for viscous boundaries.                               *
   !          *                                                            *
   !          **************************************************************
   !
   IF (viscoussubface) THEN
   ad_from2 = bcdata(nn)%jnbeg + 1
   ! Replace norm with BCData norm - Peter Lyu
   !norm => BCData(nn)%norm
   ! Loop over the quadrilateral faces of the subface and
   ! compute the viscous contribution to the force and
   ! moment and update the maximum value of y+.
   !DEC$ NOVECTOR
   DO j=ad_from2,bcdata(nn)%jnend
   ad_from1 = bcdata(nn)%inbeg + 1
   !DEC$ NOVECTOR
   DO i=ad_from1,bcdata(nn)%inend
   ! Store the viscous stress tensor a bit easier.
   tauxx = viscsubface(nn)%tau(i, j, 1)
   tauyy = viscsubface(nn)%tau(i, j, 2)
   tauzz = viscsubface(nn)%tau(i, j, 3)
   tauxy = viscsubface(nn)%tau(i, j, 4)
   tauxz = viscsubface(nn)%tau(i, j, 5)
   tauyz = viscsubface(nn)%tau(i, j, 6)
   ! Compute the viscous force on the face. A minus sign
   ! is now present, due to the definition of this force.
   CALL PUSHREAL8(fx)
   fx = -(fact*(tauxx*ss(i, j, 1)+tauxy*ss(i, j, 2)+tauxz*ss(i&
   &             , j, 3))*scaledim)
   CALL PUSHREAL8(fy)
   fy = -(fact*(tauxy*ss(i, j, 1)+tauyy*ss(i, j, 2)+tauyz*ss(i&
   &             , j, 3))*scaledim)
   CALL PUSHREAL8(fz)
   fz = -(fact*(tauxz*ss(i, j, 1)+tauyz*ss(i, j, 2)+tauzz*ss(i&
   &             , j, 3))*scaledim)
   ! Compute the coordinates of the centroid of the face
   ! relative from the moment reference point. Due to the
   ! usage of pointers for xx and offset of 1 is present,
   ! because x originally starts at 0.
   CALL PUSHREAL8(xc)
   xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
   &             , j+1, 1)) - refpoint(1)
   CALL PUSHREAL8(yc)
   yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
   &             , j+1, 2)) - refpoint(2)
   CALL PUSHREAL8(zc)
   zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
   &             , j+1, 3)) - refpoint(3)
   ! Update the viscous force and moment coefficients.
   cfv(1) = cfv(1) + fx
   cfv(2) = cfv(2) + fy
   cfv(3) = cfv(3) + fz
   ! Store Force data on face
   mx = yc*fz - zc*fy
   my = zc*fx - xc*fz
   mz = xc*fy - yc*fx
   cmv(1) = cmv(1) + mx
   cmv(2) = cmv(2) + my
   cmv(3) = cmv(3) + mz
   ! Store Moment data on face
   ! Compute the tangential component of the stress tensor,
   ! which is needed to monitor y+. The result is stored
   ! in fx, fy, fz, although it is not really a force.
   ! As later on only the magnitude of the tangential
   ! component is important, there is no need to take the
   ! sign into account (it should be a minus sign).
   ! Compute the local value of y+. Due to the usage
   ! of pointers there is on offset of -1 in dd2Wall..
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from1)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from2)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   ad_from4 = bcdata(nn)%jnbeg
   ! We have to inverse the nodal areas
   DO j=ad_from4,bcdata(nn)%jnend
   ad_from3 = bcdata(nn)%inbeg
   DO i=ad_from3,bcdata(nn)%inend
   CALL PUSHREAL8(bcdata(nn)%oarea(i, j))
   bcdata(nn)%oarea(i, j) = one/bcdata(nn)%oarea(i, j)
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from3)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from4)
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL RESETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
   &                          rev1, rev2, 0)
   CALL PUSHREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(&
   &                   sk, 4))
   CALL PUSHREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(&
   &                   sj, 4))
   CALL PUSHREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(&
   &                   si, 4))
   CALL PUSHREAL8ARRAY(d2wall, SIZE(d2wall, 1)*SIZE(d2wall, 2)*SIZE(&
   &                   d2wall, 3))
   CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4)&
   &                  )
   CALL RESETXXSSRHODD2WALLBWD(nn, xx, ss, rho1, rho2, dd2wall)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO bocos
   ! Currently the coefficients only contain the surface integral
   ! of the pressure tensor. These values must be scaled to
   ! obtain the correct coefficients.
   CALL PUSHREAL8(fact)
   fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
   &   scaledim)
   CALL PUSHREAL8(cfp(1))
   cfp(1) = cfp(1)*fact
   CALL PUSHREAL8(cfp(2))
   cfp(2) = cfp(2)*fact
   CALL PUSHREAL8(cfv(1))
   cfv(1) = cfv(1)*fact
   CALL PUSHREAL8(cfv(2))
   cfv(2) = cfv(2)*fact
   CALL PUSHREAL8(fact)
   fact = fact/(lengthref*lref)
   CALL PUSHREAL8(cmp(1))
   cmp(1) = cmp(1)*fact
   CALL PUSHREAL8(cmp(2))
   cmp(2) = cmp(2)*fact
   CALL PUSHREAL8(cmv(1))
   cmv(1) = cmv(1)*fact
   CALL PUSHREAL8(cmv(2))
   cmv(2) = cmv(2)*fact
   factb = cmv(3)*cmvb(3)
   cmvb(3) = fact*cmvb(3)
   CALL POPREAL8(cmv(2))
   factb = factb + cmv(2)*cmvb(2)
   cmvb(2) = fact*cmvb(2)
   CALL POPREAL8(cmv(1))
   factb = factb + cmp(3)*cmpb(3) + cmv(1)*cmvb(1)
   cmvb(1) = fact*cmvb(1)
   cmpb(3) = fact*cmpb(3)
   CALL POPREAL8(cmp(2))
   factb = factb + cmp(2)*cmpb(2)
   cmpb(2) = fact*cmpb(2)
   CALL POPREAL8(cmp(1))
   factb = factb + cmp(1)*cmpb(1)
   cmpb(1) = fact*cmpb(1)
   CALL POPREAL8(fact)
   tempb14 = factb/(lref*lengthref)
   lengthrefb = lengthrefb - fact*tempb14/lengthref
   factb = cfv(3)*cfvb(3) + tempb14
   cfvb(3) = fact*cfvb(3)
   CALL POPREAL8(cfv(2))
   factb = factb + cfv(2)*cfvb(2)
   cfvb(2) = fact*cfvb(2)
   CALL POPREAL8(cfv(1))
   factb = factb + cfp(3)*cfpb(3) + cfv(1)*cfvb(1)
   cfvb(1) = fact*cfvb(1)
   cfpb(3) = fact*cfpb(3)
   CALL POPREAL8(cfp(2))
   factb = factb + cfp(2)*cfpb(2)
   cfpb(2) = fact*cfpb(2)
   CALL POPREAL8(cfp(1))
   factb = factb + cfp(1)*cfpb(1)
   cfpb(1) = fact*cfpb(1)
   CALL POPREAL8(fact)
   temp9 = machcoef**2*scaledim
   temp8 = surfaceref*lref**2
   temp7 = temp8*gammainf*pinf
   tempb15 = -(two*factb/(temp7**2*temp9**2))
   tempb16 = temp9*temp8*tempb15
   gammainfb = gammainfb + pinf*tempb16
   pinfb = pinfb + gammainf*tempb16
   machcoefb = machcoefb + scaledim*temp7*2*machcoef*tempb15
   scaledimb = temp7*machcoef**2*tempb15
   pb = 0.0_8
   sib = 0.0_8
   sjb = 0.0_8
   skb = 0.0_8
   DO ii1=1,SIZE(viscsubfaceb)
   viscsubfaceb(ii1)%tau = 0.0_8
   END DO
   veldirfreestreamb = 0.0_8
   rho1b = 0.0_8
   rho2b = 0.0_8
   vb = 0.0_8
   refpointb = 0.0_8
   xxb = 0.0_8
   ssb = 0.0_8
   DO nn=nbocos,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL POPREAL8ARRAY(d2wall, SIZE(d2wall, 1)*SIZE(d2wall, 2)*SIZE(&
   &                  d2wall, 3))
   CALL POPREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si&
   &                  , 4))
   CALL POPREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj&
   &                  , 4))
   CALL POPREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk&
   &                  , 4))
   CALL RESETXXSSRHODD2WALLBWD_B(nn, xx, xxb, ss, ssb, rho1, rho1b, &
   &                             rho2, rho2b, dd2wall)
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   rlvb = 0.0_8
   revb = 0.0_8
   CALL RESETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2&
   &                         , pp2b, rlv1, rlv1b, rlv2, rlv2b, rev1, rev1b&
   &                         , rev2, rev2b, 0)
   CALL POPINTEGER4(ad_from4)
   CALL POPINTEGER4(ad_to4)
   DO j=ad_to4,ad_from4,-1
   CALL POPINTEGER4(ad_from3)
   CALL POPINTEGER4(ad_to3)
   DO i=ad_to3,ad_from3,-1
   CALL POPREAL8(bcdata(nn)%oarea(i, j))
   temp6 = bcdata(nn)%oarea(i, j)
   bcdatab(nn)%oarea(i, j) = -(one*bcdatab(nn)%oarea(i, j)/temp6&
   &           **2)
   END DO
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   bcdatab(nn)%fv = 0.0_8
   ELSE
   CALL POPINTEGER4(ad_from2)
   CALL POPINTEGER4(ad_to2)
   DO j=ad_to2,ad_from2,-1
   CALL POPINTEGER4(ad_from1)
   CALL POPINTEGER4(ad_to1)
   DO i=ad_to1,ad_from1,-1
   tauxx = viscsubface(nn)%tau(i, j, 1)
   tauyy = viscsubface(nn)%tau(i, j, 2)
   tauxy = viscsubface(nn)%tau(i, j, 4)
   mzb = cmvb(3) + bcdatab(nn)%m(i, j, 3)
   myb = cmvb(2) + bcdatab(nn)%m(i, j, 2)
   mxb = cmvb(1) + bcdatab(nn)%m(i, j, 1)
   xcb = fy*mzb - fz*myb
   ycb = fz*mxb - fx*mzb
   zcb = fx*myb - fy*mxb
   fzb = yc*mxb + bcdatab(nn)%fv(i, j, 3) - xc*myb
   bcdatab(nn)%fv(i, j, 3) = 0.0_8
   fyb = bcdatab(nn)%fv(i, j, 2) - zc*mxb + xc*mzb
   bcdatab(nn)%fv(i, j, 2) = 0.0_8
   fxb = zc*myb + bcdatab(nn)%fv(i, j, 1) - yc*mzb
   bcdatab(nn)%fv(i, j, 1) = 0.0_8
   fzb = fzb + cfvb(3)
   fyb = fyb + cfvb(2)
   fxb = fxb + cfvb(1)
   CALL POPREAL8(zc)
   tempb8 = fourth*zcb
   xxb(i, j, 3) = xxb(i, j, 3) + tempb8
   xxb(i+1, j, 3) = xxb(i+1, j, 3) + tempb8
   xxb(i, j+1, 3) = xxb(i, j+1, 3) + tempb8
   xxb(i+1, j+1, 3) = xxb(i+1, j+1, 3) + tempb8
   refpointb(3) = refpointb(3) - zcb
   CALL POPREAL8(yc)
   tempb9 = fourth*ycb
   xxb(i, j, 2) = xxb(i, j, 2) + tempb9
   xxb(i+1, j, 2) = xxb(i+1, j, 2) + tempb9
   xxb(i, j+1, 2) = xxb(i, j+1, 2) + tempb9
   xxb(i+1, j+1, 2) = xxb(i+1, j+1, 2) + tempb9
   refpointb(2) = refpointb(2) - ycb
   CALL POPREAL8(xc)
   tempb10 = fourth*xcb
   xxb(i, j, 1) = xxb(i, j, 1) + tempb10
   xxb(i+1, j, 1) = xxb(i+1, j, 1) + tempb10
   xxb(i, j+1, 1) = xxb(i, j+1, 1) + tempb10
   xxb(i+1, j+1, 1) = xxb(i+1, j+1, 1) + tempb10
   refpointb(1) = refpointb(1) - xcb
   tauzz = viscsubface(nn)%tau(i, j, 3)
   tauxz = viscsubface(nn)%tau(i, j, 5)
   tauyz = viscsubface(nn)%tau(i, j, 6)
   CALL POPREAL8(fz)
   tempb11 = -(fact*scaledim*fzb)
   ssb(i, j, 1) = ssb(i, j, 1) + tauxz*tempb11
   ssb(i, j, 2) = ssb(i, j, 2) + tauyz*tempb11
   tauzzb = ss(i, j, 3)*tempb11
   ssb(i, j, 3) = ssb(i, j, 3) + tauzz*tempb11
   scaledimb = scaledimb - fact*(tauxy*ss(i, j, 1)+tauyy*ss(i, &
   &             j, 2)+tauyz*ss(i, j, 3))*fyb - fact*(tauxx*ss(i, j, 1)+&
   &             tauxy*ss(i, j, 2)+tauxz*ss(i, j, 3))*fxb - fact*(tauxz*ss(&
   &             i, j, 1)+tauyz*ss(i, j, 2)+tauzz*ss(i, j, 3))*fzb
   CALL POPREAL8(fy)
   tempb13 = -(fact*scaledim*fyb)
   tauyzb = ss(i, j, 3)*tempb13 + ss(i, j, 2)*tempb11
   ssb(i, j, 1) = ssb(i, j, 1) + tauxy*tempb13
   tauyyb = ss(i, j, 2)*tempb13
   ssb(i, j, 2) = ssb(i, j, 2) + tauyy*tempb13
   ssb(i, j, 3) = ssb(i, j, 3) + tauyz*tempb13
   CALL POPREAL8(fx)
   tempb12 = -(fact*scaledim*fxb)
   tauxzb = ss(i, j, 3)*tempb12 + ss(i, j, 1)*tempb11
   tauxyb = ss(i, j, 2)*tempb12 + ss(i, j, 1)*tempb13
   tauxxb = ss(i, j, 1)*tempb12
   ssb(i, j, 1) = ssb(i, j, 1) + tauxx*tempb12
   ssb(i, j, 2) = ssb(i, j, 2) + tauxy*tempb12
   ssb(i, j, 3) = ssb(i, j, 3) + tauxz*tempb12
   viscsubfaceb(nn)%tau(i, j, 6) = viscsubfaceb(nn)%tau(i, j, 6&
   &             ) + tauyzb
   viscsubfaceb(nn)%tau(i, j, 5) = viscsubfaceb(nn)%tau(i, j, 5&
   &             ) + tauxzb
   viscsubfaceb(nn)%tau(i, j, 4) = viscsubfaceb(nn)%tau(i, j, 4&
   &             ) + tauxyb
   viscsubfaceb(nn)%tau(i, j, 3) = viscsubfaceb(nn)%tau(i, j, 3&
   &             ) + tauzzb
   viscsubfaceb(nn)%tau(i, j, 2) = viscsubfaceb(nn)%tau(i, j, 2&
   &             ) + tauyyb
   viscsubfaceb(nn)%tau(i, j, 1) = viscsubfaceb(nn)%tau(i, j, 1&
   &             ) + tauxxb
   END DO
   END DO
   END IF
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   mzb = bcdatab(nn)%m(i, j, 3)
   bcdatab(nn)%m(i, j, 3) = 0.0_8
   myb = bcdatab(nn)%m(i, j, 2)
   bcdatab(nn)%m(i, j, 2) = 0.0_8
   mxb = bcdatab(nn)%m(i, j, 1)
   bcdatab(nn)%m(i, j, 1) = 0.0_8
   mzb = mzb + cmpb(3)
   myb = myb + cmpb(2)
   mxb = mxb + cmpb(1)
   xcb = fy*mzb - fz*myb
   fyb = cfpb(2) - zc*mxb + xc*mzb
   ycb = fz*mxb - fx*mzb
   fxb = zc*myb + cfpb(1) - yc*mzb
   zcb = fx*myb - fy*mxb
   fzb = yc*mxb + cfpb(3) - xc*myb
   sensor1b = bcdatab(nn)%cavitation(i, j)
   bcdatab(nn)%cavitation(i, j) = 0.0_8
   sensor1b = sensor1b + cavitationb
   qab = four*sensor1*sensor1b
   sensor1b = four*qa*sensor1b
   CALL POPREAL8(sensor1)
   temp5 = -(10*2*sensor1)
   temp4 = one + EXP(temp5)
   sensor1b = EXP(temp5)*one*10*2*sensor1b/temp4**2
   CALL POPREAL8(sensor1)
   cpb = -sensor1b
   tmpb = (plocal-pinf)*cpb
   plocalb = tmp*cpb
   temp3 = gammainf*pinf*machcoef**2
   tempb0 = -(two*tmpb/temp3**2)
   tempb = machcoef**2*tempb0
   pinfb = pinfb + gammainf*tempb - tmp*cpb
   CALL POPREAL8(tmp)
   gammainfb = gammainfb + pinf*tempb
   machcoefb = machcoefb + gammainf*pinf*2*machcoef*tempb0
   CALL POPREAL8(plocal)
   sensorb = bcdatab(nn)%sepsensor(i, j)
   bcdatab(nn)%sepsensor(i, j) = 0.0_8
   sensorb = sensorb + sepsensorb
   qab = qab + four*sensor*sensorb
   sensorb = four*qa*sensorb
   CALL POPREAL8(sensor)
   temp2 = -(10*2*sensor)
   temp1 = one + EXP(temp2)
   sensorb = EXP(temp2)*one*10*2*sensorb/temp1**2
   CALL POPREAL8(sensor)
   vb(1) = vb(1) - veldirfreestream(1)*sensorb
   veldirfreestreamb(1) = veldirfreestreamb(1) - v(1)*sensorb
   vb(2) = vb(2) - veldirfreestream(2)*sensorb
   veldirfreestreamb(2) = veldirfreestreamb(2) - v(2)*sensorb
   vb(3) = vb(3) - veldirfreestream(3)*sensorb
   veldirfreestreamb(3) = veldirfreestreamb(3) - v(3)*sensorb
   CALL POPREAL8ARRAY(v, 3)
   tmpb0 = vb
   temp = v(1)**2 + v(2)**2 + v(3)**2
   temp0 = SQRT(temp)
   tempb2 = tmpb0/(temp0+1e-16)
   vb = tempb2
   IF (temp .EQ. 0.0_8) THEN
   tempb3 = 0.0
   ELSE
   tempb3 = SUM(-(v*tempb2/(temp0+1e-16)))/(2.0*temp0)
   END IF
   vb(1) = vb(1) + 2*v(1)*tempb3
   vb(2) = vb(2) + 2*v(2)*tempb3
   vb(3) = vb(3) + 2*v(3)*tempb3
   CALL POPREAL8(v(3))
   ww2b(i, j, ivz) = ww2b(i, j, ivz) + vb(3)
   vb(3) = 0.0_8
   CALL POPREAL8(v(2))
   ww2b(i, j, ivy) = ww2b(i, j, ivy) + vb(2)
   vb(2) = 0.0_8
   CALL POPREAL8(v(1))
   ww2b(i, j, ivx) = ww2b(i, j, ivx) + vb(1)
   vb(1) = 0.0_8
   CALL POPREAL8(bcdata(nn)%oarea(i, j))
   qab = qab + bcdatab(nn)%oarea(i-1, j) + bcdatab(nn)%oarea(i-1&
   &           , j-1) + bcdatab(nn)%oarea(i, j-1) + bcdatab(nn)%oarea(i, j)
   CALL POPREAL8(bcdata(nn)%oarea(i-1, j))
   CALL POPREAL8(bcdata(nn)%oarea(i, j-1))
   CALL POPREAL8(bcdata(nn)%oarea(i-1, j-1))
   CALL POPREAL8(qa)
   IF (ss(i, j, 1)**2 + ss(i, j, 2)**2 + ss(i, j, 3)**2 .EQ. &
   &             0.0_8) THEN
   tempb4 = 0.0
   ELSE
   tempb4 = fourth*qab/(2.0*SQRT(ss(i, j, 1)**2+ss(i, j, 2)**2+&
   &             ss(i, j, 3)**2))
   END IF
   ssb(i, j, 1) = ssb(i, j, 1) + 2*ss(i, j, 1)*tempb4
   ssb(i, j, 2) = ssb(i, j, 2) + 2*ss(i, j, 2)*tempb4
   fzb = fzb + bcdatab(nn)%fp(i, j, 3)
   ssb(i, j, 3) = ssb(i, j, 3) + pm1*fzb + 2*ss(i, j, 3)*tempb4
   bcdatab(nn)%fp(i, j, 3) = 0.0_8
   fyb = fyb + bcdatab(nn)%fp(i, j, 2)
   bcdatab(nn)%fp(i, j, 2) = 0.0_8
   fxb = fxb + bcdatab(nn)%fp(i, j, 1)
   bcdatab(nn)%fp(i, j, 1) = 0.0_8
   CALL POPREAL8(fz)
   pm1b = ss(i, j, 2)*fyb + ss(i, j, 1)*fxb + ss(i, j, 3)*fzb
   CALL POPREAL8(fy)
   ssb(i, j, 2) = ssb(i, j, 2) + pm1*fyb
   CALL POPREAL8(fx)
   ssb(i, j, 1) = ssb(i, j, 1) + pm1*fxb
   CALL POPREAL8(zc)
   tempb5 = fourth*zcb
   xxb(i, j, 3) = xxb(i, j, 3) + tempb5
   xxb(i+1, j, 3) = xxb(i+1, j, 3) + tempb5
   xxb(i, j+1, 3) = xxb(i, j+1, 3) + tempb5
   xxb(i+1, j+1, 3) = xxb(i+1, j+1, 3) + tempb5
   refpointb(3) = refpointb(3) - zcb
   CALL POPREAL8(yc)
   tempb6 = fourth*ycb
   xxb(i, j, 2) = xxb(i, j, 2) + tempb6
   xxb(i+1, j, 2) = xxb(i+1, j, 2) + tempb6
   xxb(i, j+1, 2) = xxb(i, j+1, 2) + tempb6
   xxb(i+1, j+1, 2) = xxb(i+1, j+1, 2) + tempb6
   refpointb(2) = refpointb(2) - ycb
   CALL POPREAL8(xc)
   tempb7 = fourth*xcb
   xxb(i, j, 1) = xxb(i, j, 1) + tempb7
   xxb(i+1, j, 1) = xxb(i+1, j, 1) + tempb7
   xxb(i, j+1, 1) = xxb(i, j+1, 1) + tempb7
   xxb(i+1, j+1, 1) = xxb(i+1, j+1, 1) + tempb7
   refpointb(1) = refpointb(1) - xcb
   CALL POPREAL8(pm1)
   tempb1 = fact*scaledim*pm1b
   pp2b(i, j) = pp2b(i, j) + half*tempb1 + plocalb
   pp1b(i, j) = pp1b(i, j) + half*tempb1
   pinfb = pinfb - tempb1
   scaledimb = scaledimb + fact*(half*(pp2(i, j)+pp1(i, j))-pinf)&
   &           *pm1b
   END DO
   END DO
   CALL POPREAL8ARRAY(bcdata(nn)%oarea, SIZE(bcdata(nn)%oarea, 1)*&
   &                  SIZE(bcdata(nn)%oarea, 2))
   bcdatab(nn)%oarea = 0.0_8
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .NE. 0) THEN
   IF (branch .EQ. 1) THEN
   CALL POPREAL8(fact)
   ELSE
   CALL POPREAL8(fact)
   END IF
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL POPREAL8(fact)
   ELSE
   CALL POPREAL8(fact)
   END IF
   ELSE IF (branch .EQ. 5) THEN
   CALL POPREAL8(fact)
   ELSE
   CALL POPREAL8(fact)
   END IF
   CALL POPREAL8ARRAY(ss, imaxdim*jmaxdim*3)
   CALL SETXXSSRHODD2WALLBWD_B(nn, xx, xxb, ss, ssb, rho1, rho1b, &
   &                           rho2, rho2b, dd2wall)
   CALL POPREAL8ARRAY(pp1, imaxdim*jmaxdim)
   CALL POPREAL8ARRAY(pp2, imaxdim*jmaxdim)
   rlv1b = 0.0_8
   rlv2b = 0.0_8
   rev1b = 0.0_8
   rev2b = 0.0_8
   rlvb = 0.0_8
   revb = 0.0_8
   CALL SETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2, &
   &                       pp2b, rlv1, rlv1b, rlv2, rlv2b, rev1, rev1b, &
   &                       rev2, rev2b, 0)
   END IF
   END DO
   pointrefb(3) = pointrefb(3) + lref*refpointb(3)
   refpointb(3) = 0.0_8
   pointrefb(2) = pointrefb(2) + lref*refpointb(2)
   refpointb(2) = 0.0_8
   pointrefb(1) = pointrefb(1) + lref*refpointb(1)
   prefb = prefb + scaledimb/pinf
   pinfb = pinfb - pref*scaledimb/pinf**2
   END SUBROUTINE FORCESANDMOMENTS_B

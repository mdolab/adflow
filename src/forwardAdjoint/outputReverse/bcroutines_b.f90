   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          BCRoutines.F90                                   *
   !      * Author:        Gaetan K. W. Kenway                             *
   !      * Starting date: 01-23-2015                                      *
   !      * Last modified: 01-23-2015                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   !      ******************************************************************
   !      *                                                                *
   !      * This module contains data structures *and* routines used       *
   !      * for applying *all* boundary conditions for Navier Stokes part  *
   !      * of the code. The reason for using a module to contain the      *
   !      * routines is that due to the use of pointers, it eliminates the *
   !      * need for using interfaces. All former bc*.f90 routines are now *
   !      * included in this module.                                       *
   !      *                                                                *
   !      ******************************************************************
   !
   MODULE BCROUTINES_B
   USE CONSTANTS
   IMPLICIT NONE
   SAVE 
   REAL(kind=realtype), DIMENSION(:, :, :), ALLOCATABLE :: ww0, ww1, ww2&
   & , ww3
   REAL(kind=realtype), DIMENSION(:, :, :), ALLOCATABLE :: ww0d, ww1d, &
   & ww2d, ww3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: pp0, pp1, pp2, &
   & pp3
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: pp0d, pp1d, pp2d&
   & , pp3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rlv0, rlv1, rlv2&
   & , rlv3
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rlv0d, rlv1d, &
   & rlv2d, rlv3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rev0, rev1, rev2&
   & , rev3
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rev0d, rev1d, &
   & rev2d, rev3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: gamma0, gamma1, &
   & gamma2, gamma3
   INTEGER(kind=inttype) :: isize, jsize
      CONTAINS
   !  Differentiation of applyallbc_block2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: gammainf winf pinfcorr rgas
   !                *rev *bvtj1 *bvtj2 *p *w *rlv *bvtk1 *bvtk2 *d2wall
   !                *bvti1 *bvti2 *rev0 *rev1 *rev2 *rev3 *pp0 *pp1
   !                *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ww0 *ww1 *ww2
   !                *ww3
   !   with respect to varying inputs: gammainf winf pinfcorr rgas
   !                *rev *p *w *rlv *d2wall *(*bcdata.norm) *rev0
   !                *rev1 *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1
   !                *rlv2 *rlv3 *ww0 *ww1 *ww2 *ww3
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in p:in
   !                w:in rlv:in bvtk1:in bvtk2:in d2wall:in bvti1:in
   !                bvti2:in bcdata:in *bcdata.norm:in rev0:in rev1:in
   !                rev2:in rev3:in pp0:in pp1:in pp2:in pp3:in rlv0:in
   !                rlv1:in rlv2:in rlv3:in ww0:in ww1:in ww2:in ww3:in
   SUBROUTINE APPLYALLBC_BLOCK2_B(secondhalo)
   ! Apply BC's for a single block
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTTIMESPECTRAL
   USE ITERATION
   USE BCTYPES
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   ! Local variables.
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: nn
   INTEGER :: ii1
   !
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   ! Apply all the boundary conditions. The order is important!  Only
   ! some of them have been AD'ed
   ! ------------------------------------
   !  Symmetry Boundary Condition 
   ! ------------------------------------
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. symm) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCSYMM2(nn, secondhalo)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1&
   &                 , 3)*SIZE(bmtk1, 4))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2&
   &                 , 3)*SIZE(bmtk2, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1&
   &                 , 3)*SIZE(bmti1, 4))
   CALL PUSHREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2&
   &                 , 3)*SIZE(bmti2, 4))
   CALL PUSHREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1&
   &                 , 3)*SIZE(bmtj1, 4))
   CALL PUSHREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2&
   &                 , 3)*SIZE(bmtj2, 4))
   CALL PUSHREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   ! ------------------------------------
   !  Adibatic Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswalladiabatic) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCNSWALLADIABATIC2(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1&
   &                 , 3)*SIZE(bmtk1, 4))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2&
   &                 , 3)*SIZE(bmtk2, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1&
   &                 , 3)*SIZE(bmti1, 4))
   CALL PUSHREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2&
   &                 , 3)*SIZE(bmti2, 4))
   CALL PUSHREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2&
   &                 , 3))
   CALL PUSHREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1&
   &                 , 3)*SIZE(bmtj1, 4))
   CALL PUSHREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2&
   &                 , 3)*SIZE(bmtj2, 4))
   CALL PUSHREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   ! ------------------------------------
   !  Isotermal Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCNSWALLISOTHERMAL2(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL PUSHREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. farfield) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCFARFIELD2(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   CALL PUSHREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   DO ii1=1,SIZE(bcdatad)
   bcdatad(ii1)%norm = 0.0_8
   END DO
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. eulerwall) THEN
   CALL SETBCPOINTERS2(nn)
   CALL RESETBCPOINTERS2_B(nn)
   CALL BCEULERWALL2_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS2_B(nn)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL POPREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL POPREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL LOOKREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL LOOKREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. farfield) THEN
   CALL SETBCPOINTERS2(nn)
   CALL RESETBCPOINTERS2_B(nn)
   CALL BCFARFIELD2_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS2_B(nn)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL POPREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL POPREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2, &
   &                3)*SIZE(bmtj2, 4))
   CALL POPREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1, &
   &                3)*SIZE(bmtj1, 4))
   CALL POPREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2, &
   &                3))
   CALL POPREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1, &
   &                3))
   CALL POPREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2, &
   &                3)*SIZE(bmti2, 4))
   CALL POPREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1, &
   &                3)*SIZE(bmti1, 4))
   CALL POPREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2, &
   &                3))
   CALL POPREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1, &
   &                3))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2, &
   &                3)*SIZE(bmtk2, 4))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1, &
   &                3)*SIZE(bmtk1, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2, &
   &                3))
   CALL POPREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1, &
   &                3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL LOOKREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL LOOKREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   CALL SETBCPOINTERS2(nn)
   CALL RESETBCPOINTERS2_B(nn)
   CALL BCNSWALLISOTHERMAL2_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS2_B(nn)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL POPREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL POPREAL8ARRAY(bmtj2, SIZE(bmtj2, 1)*SIZE(bmtj2, 2)*SIZE(bmtj2, &
   &                3)*SIZE(bmtj2, 4))
   CALL POPREAL8ARRAY(bmtj1, SIZE(bmtj1, 1)*SIZE(bmtj1, 2)*SIZE(bmtj1, &
   &                3)*SIZE(bmtj1, 4))
   CALL POPREAL8ARRAY(bvti2, SIZE(bvti2, 1)*SIZE(bvti2, 2)*SIZE(bvti2, &
   &                3))
   CALL POPREAL8ARRAY(bvti1, SIZE(bvti1, 1)*SIZE(bvti1, 2)*SIZE(bvti1, &
   &                3))
   CALL POPREAL8ARRAY(bmti2, SIZE(bmti2, 1)*SIZE(bmti2, 2)*SIZE(bmti2, &
   &                3)*SIZE(bmti2, 4))
   CALL POPREAL8ARRAY(bmti1, SIZE(bmti1, 1)*SIZE(bmti1, 2)*SIZE(bmti1, &
   &                3)*SIZE(bmti1, 4))
   CALL POPREAL8ARRAY(bvtk2, SIZE(bvtk2, 1)*SIZE(bvtk2, 2)*SIZE(bvtk2, &
   &                3))
   CALL POPREAL8ARRAY(bvtk1, SIZE(bvtk1, 1)*SIZE(bvtk1, 2)*SIZE(bvtk1, &
   &                3))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(bmtk2, SIZE(bmtk2, 1)*SIZE(bmtk2, 2)*SIZE(bmtk2, &
   &                3)*SIZE(bmtk2, 4))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(bmtk1, SIZE(bmtk1, 1)*SIZE(bmtk1, 2)*SIZE(bmtk1, &
   &                3)*SIZE(bmtk1, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(bvtj2, SIZE(bvtj2, 1)*SIZE(bvtj2, 2)*SIZE(bvtj2, &
   &                3))
   CALL POPREAL8ARRAY(bvtj1, SIZE(bvtj1, 1)*SIZE(bvtj1, 2)*SIZE(bvtj1, &
   &                3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL LOOKREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswalladiabatic) THEN
   CALL SETBCPOINTERS2(nn)
   CALL RESETBCPOINTERS2_B(nn)
   CALL BCNSWALLADIABATIC2_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS2_B(nn)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. symm) THEN
   CALL SETBCPOINTERS2(nn)
   CALL RESETBCPOINTERS2_B(nn)
   CALL BCSYMM2_B(nn, secondhalo)
   CALL SETBCPOINTERS2_B(nn)
   END IF
   END DO
   END SUBROUTINE APPLYALLBC_BLOCK2_B
   SUBROUTINE APPLYALLBC_BLOCK2(secondhalo)
   ! Apply BC's for a single block
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTTIMESPECTRAL
   USE ITERATION
   USE BCTYPES
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   ! Local variables.
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: nn
   !
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   ! Apply all the boundary conditions. The order is important!  Only
   ! some of them have been AD'ed
   ! ------------------------------------
   !  Symmetry Boundary Condition 
   ! ------------------------------------
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. symm) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCSYMM2(nn, secondhalo)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   ! ------------------------------------
   !  Adibatic Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswalladiabatic) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCNSWALLADIABATIC2(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   ! ------------------------------------
   !  Isotermal Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCNSWALLISOTHERMAL2(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   ! ------------------------------------
   !  Farfield Boundary Condition 
   ! ------------------------------------
   IF (precond .EQ. turkel .OR. precond .EQ. choimerkle) CALL &
   &     TERMINATE('applyAllBC', &
   &      'Farfield Turkel and Coid/Merkle preconditioners not implemented'&
   &           )
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. farfield) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCFARFIELD2(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   ! ------------------------------------
   !  Euler Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. eulerwall) THEN
   CALL SETBCPOINTERS2(nn)
   CALL BCEULERWALL2(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS2(nn)
   END IF
   END DO
   END SUBROUTINE APPLYALLBC_BLOCK2
   !  Differentiation of bcsymm2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   Plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
   !                rev1:in rev2:in rev3:in pp0:in pp1:in pp2:in pp3:in
   !                rlv0:in rlv1:in rlv2:in rlv3:in ww0:in ww1:in
   !                ww2:in ww3:in
   ! ===================================================================
   !   Actual implementation of each of the boundary condition routines
   ! ===================================================================
   SUBROUTINE BCSYMM2_B(nn, secondhalo)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcSymm applies the symmetry boundary conditions to a block.    *
   ! * It is assumed that the pointers in blockPointers are already   *
   ! * set to the correct block on the correct grid level.            *
   ! *                                                                *
   ! * In case also the second halo must be set the loop over the     *
   ! * boundary subfaces is executed twice. This is the only correct  *
   ! * way in case the block contains only 1 cell between two         *
   ! * symmetry planes, i.e. a 2D problem.                            *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, l, ii
   REAL(kind=realtype) :: vn, nnx, nny, nnz
   REAL(kind=realtype) :: vnd
   INTRINSIC MOD
   INTEGER :: branch
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd0
   IF (secondhalo) THEN
   CALL PUSHINTEGER4(i)
   CALL PUSHINTEGER4(j)
   CALL PUSHREAL8(vn)
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
   &         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
   &         , 3))
   ! Determine the flow variables in the halo cell.
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev3d(i, j) = rev3d(i, j) + rev0d(i, j)
   rev0d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv3d(i, j) = rlv3d(i, j) + rlv0d(i, j)
   rlv0d(i, j) = 0.0_8
   END IF
   pp3d(i, j) = pp3d(i, j) + pp0d(i, j)
   pp0d(i, j) = 0.0_8
   DO l=nt1mg,nt2mg
   ww3d(i, j, l) = ww3d(i, j, l) + ww0d(i, j, l)
   ww0d(i, j, l) = 0.0_8
   END DO
   ww3d(i, j, irhoe) = ww3d(i, j, irhoe) + ww0d(i, j, irhoe)
   ww0d(i, j, irhoe) = 0.0_8
   ww3d(i, j, ivz) = ww3d(i, j, ivz) + ww0d(i, j, ivz)
   vnd = -(bcdata(nn)%norm(i, j, 3)*ww0d(i, j, ivz))
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww0d(&
   &         i, j, ivz)
   ww0d(i, j, ivz) = 0.0_8
   ww3d(i, j, ivy) = ww3d(i, j, ivy) + ww0d(i, j, ivy)
   vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww0d(i, j, ivy)
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww0d(&
   &         i, j, ivy)
   ww0d(i, j, ivy) = 0.0_8
   ww3d(i, j, ivx) = ww3d(i, j, ivx) + ww0d(i, j, ivx)
   vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww0d(i, j, ivx)
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww0d(&
   &         i, j, ivx)
   ww0d(i, j, ivx) = 0.0_8
   ww3d(i, j, irho) = ww3d(i, j, irho) + ww0d(i, j, irho)
   ww0d(i, j, irho) = 0.0_8
   tempd0 = two*vnd
   ww3d(i, j, ivx) = ww3d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*&
   &         tempd0
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww3(i, j&
   &         , ivx)*tempd0
   ww3d(i, j, ivy) = ww3d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*&
   &         tempd0
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww3(i, j&
   &         , ivy)*tempd0
   ww3d(i, j, ivz) = ww3d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*&
   &         tempd0
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww3(i, j&
   &         , ivz)*tempd0
   END DO
   CALL POPREAL8(vn)
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(i)
   END IF
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
   &       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
   &       )
   ! Determine the flow variables in the halo cell.
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   END IF
   pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
   pp1d(i, j) = 0.0_8
   DO l=nt1mg,nt2mg
   ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
   ww1d(i, j, l) = 0.0_8
   END DO
   ww2d(i, j, irhoe) = ww2d(i, j, irhoe) + ww1d(i, j, irhoe)
   ww1d(i, j, irhoe) = 0.0_8
   ww2d(i, j, ivz) = ww2d(i, j, ivz) + ww1d(i, j, ivz)
   vnd = -(bcdata(nn)%norm(i, j, 3)*ww1d(i, j, ivz))
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww1d(i&
   &       , j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   ww2d(i, j, ivy) = ww2d(i, j, ivy) + ww1d(i, j, ivy)
   vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww1d(i, j, ivy)
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww1d(i&
   &       , j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ww2d(i, j, ivx) = ww2d(i, j, ivx) + ww1d(i, j, ivx)
   vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww1d(i, j, ivx)
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww1d(i&
   &       , j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
   ww1d(i, j, irho) = 0.0_8
   tempd = two*vnd
   ww2d(i, j, ivx) = ww2d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*tempd
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww2(i, j, &
   &       ivx)*tempd
   ww2d(i, j, ivy) = ww2d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*tempd
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww2(i, j, &
   &       ivy)*tempd
   ww2d(i, j, ivz) = ww2d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*tempd
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww2(i, j, &
   &       ivz)*tempd
   END DO
   END SUBROUTINE BCSYMM2_B
   ! ===================================================================
   !   Actual implementation of each of the boundary condition routines
   ! ===================================================================
   SUBROUTINE BCSYMM2(nn, secondhalo)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcSymm applies the symmetry boundary conditions to a block.    *
   ! * It is assumed that the pointers in blockPointers are already   *
   ! * set to the correct block on the correct grid level.            *
   ! *                                                                *
   ! * In case also the second halo must be set the loop over the     *
   ! * boundary subfaces is executed twice. This is the only correct  *
   ! * way in case the block contains only 1 cell between two         *
   ! * symmetry planes, i.e. a 2D problem.                            *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, l, ii
   REAL(kind=realtype) :: vn, nnx, nny, nnz
   INTRINSIC MOD
   ! Loop over the generic subface to set the state in the
   ! 1-st level halos 
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
   &       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
   &       )
   ! Determine the flow variables in the halo cell.
   ww1(i, j, irho) = ww2(i, j, irho)
   ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
   ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
   ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
   ww1(i, j, irhoe) = ww2(i, j, irhoe)
   ! Simply copy the turbulent variables.
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   gamma1(i, j) = gamma2(i, j)
   pp1(i, j) = pp2(i, j)
   IF (viscous) rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = rev2(i, j)
   END DO
   IF (secondhalo) THEN
   ! If we need the second halo, do everything again, but using ww0,
   ! ww3 etc instead of ww2 and ww1. 
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
   &         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
   &         , 3))
   ! Determine the flow variables in the halo cell.
   ww0(i, j, irho) = ww3(i, j, irho)
   ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
   ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
   ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
   ww0(i, j, irhoe) = ww3(i, j, irhoe)
   DO l=nt1mg,nt2mg
   ww0(i, j, l) = ww3(i, j, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   gamma0(i, j) = gamma3(i, j)
   pp0(i, j) = pp3(i, j)
   IF (viscous) rlv0(i, j) = rlv3(i, j)
   IF (eddymodel) rev0(i, j) = rev3(i, j)
   END DO
   END IF
   END SUBROUTINE BCSYMM2
   !  Differentiation of bcnswalladiabatic2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *bvtj1 *bvtj2 *w *rlv
   !                *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2 *rev0 *rev1
   !                *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1
   !                *ww2
   !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *w *rlv
   !                *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2 *rev0 *rev1
   !                *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1
   !                *ww2
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
   !                rlv:in bvtk1:in bvtk2:in d2wall:in bvti1:in bvti2:in
   !                bcdata:in rev0:in rev1:in rev2:in pp0:in pp1:in
   !                pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in ww2:in
   SUBROUTINE BCNSWALLADIABATIC2_B(nn, secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcNSWallAdiabatic applies the viscous adiabatic wall           *
   !      * boundary condition the pointers already defined.               *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok
   REAL(kind=realtype) :: rhokd
   INTRINSIC MOD
   INTEGER :: branch
   ! Apply the BCWall In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   IF (turbcoupled) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   ww1(i, j, irho) = ww2(i, j, irho)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2_B(ww1, ww1d, pp1, pp1d, correctfork)
   rhokd = 0.0_8
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
   rhokd = rhokd - four*third*pp1d(i, j)
   pp1d(i, j) = 0.0_8
   ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
   ww1d(i, j, irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
   ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL TURBBCNSWALL_B(.false.)
   END SUBROUTINE BCNSWALLADIABATIC2_B
   SUBROUTINE BCNSWALLADIABATIC2(nn, secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcNSWallAdiabatic applies the viscous adiabatic wall           *
   !      * boundary condition the pointers already defined.               *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok
   INTRINSIC MOD
   ! Apply the BCWall In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   IF (turbcoupled) CALL TURBBCNSWALL(.false.)
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   ww1(i, j, irho) = ww2(i, j, irho)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
   END SUBROUTINE BCNSWALLADIABATIC2
   !  Differentiation of bcnswallisothermal2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: rgas *rev *bvtj1 *bvtj2 *w
   !                *rlv *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2 *rev0
   !                *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0
   !                *ww1 *ww2
   !   with respect to varying inputs: rgas *rev *bvtj1 *bvtj2 *w
   !                *rlv *bvtk1 *bvtk2 *d2wall *bvti1 *bvti2 *rev0
   !                *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0
   !                *ww1 *ww2
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
   !                rlv:in bvtk1:in bvtk2:in d2wall:in bvti1:in bvti2:in
   !                bcdata:in rev0:in rev1:in rev2:in pp0:in pp1:in
   !                pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in ww2:in
   SUBROUTINE BCNSWALLISOTHERMAL2_B(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcNSWallAdiabatic applies the viscous isothermal wall          *
   ! * boundary condition to a block. It is assumed that the          *
   ! * BCPointers are already set                                     *
   ! *                                                                *
   ! ******************************************************************
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok, t2, t1
   REAL(kind=realtype) :: rhokd, t2d, t1d
   INTRINSIC MOD
   INTRINSIC MAX
   INTRINSIC MIN
   INTEGER :: branch
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: temp
   ! In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   IF (turbcoupled) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8(rhok)
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2_B(ww1, ww1d, pp1, pp1d, correctfork)
   rhokd = 0.0_8
   CALL POPREAL8(rhok)
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) THEN
   rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   tempd0 = ww1d(i, j, irho)/(rgas*t1)
   tempd1 = -(pp1(i, j)*tempd0/(rgas*t1))
   pp1d(i, j) = pp1d(i, j) + tempd0
   rgasd = rgasd + t1*tempd1
   t1d = rgas*tempd1
   ww1d(i, j, irho) = 0.0_8
   pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
   rhokd = rhokd - four*third*pp1d(i, j)
   pp1d(i, j) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   t2d = -t1d
   temp = rgas*ww2(i, j, irho)
   tempd = -(pp2(i, j)*t2d/temp**2)
   pp2d(i, j) = pp2d(i, j) + t2d/temp
   rgasd = rgasd + ww2(i, j, irho)*tempd
   ww2d(i, j, irho) = ww2d(i, j, irho) + rgas*tempd
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
   ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) CALL TURBBCNSWALL_B(.false.)
   END SUBROUTINE BCNSWALLISOTHERMAL2_B
   SUBROUTINE BCNSWALLISOTHERMAL2(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcNSWallAdiabatic applies the viscous isothermal wall          *
   ! * boundary condition to a block. It is assumed that the          *
   ! * BCPointers are already set                                     *
   ! *                                                                *
   ! ******************************************************************
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok, t2, t1
   INTRINSIC MOD
   INTRINSIC MAX
   INTRINSIC MIN
   ! In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   IF (turbcoupled) CALL TURBBCNSWALL(.false.)
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
   END SUBROUTINE BCNSWALLISOTHERMAL2
   !  Differentiation of bceulerwall2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0
   !                *ww1 *ww2
   !   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0
   !                *ww1 *ww2
   !   Plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
   !                rev1:in rev2:in pp0:in pp1:in pp2:in pp3:in rlv0:in
   !                rlv1:in rlv2:in ww0:in ww1:in ww2:in
   SUBROUTINE BCEULERWALL2_B(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcEulerWall applies the inviscid wall boundary condition to    *
   ! * a block. It is assumed that the bcpointers are                 *
   ! * already set to the correct block on the correct grid level.    *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: j, k, l, ii
   INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
   INTEGER(kind=inttype) :: walltreatment
   REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
   REAL(kind=realtype) :: skxa, skya, skza, a1, b1
   REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
   REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
   REAL(kind=realtype) :: vnd
   REAL(kind=realtype) :: uux, uuy, uuz
   REAL(kind=realtype), DIMENSION(isize, jsize) :: grad
   REAL(kind=realtype), DIMENSION(isize, jsize) :: gradd
   INTRINSIC MOD
   REAL(kind=realtype) :: DIM
   INTEGER :: branch
   REAL(kind=realtype) :: tempd
   ! Make sure that on the coarser grids the constant pressure
   ! boundary condition is used.
   walltreatment = wallbctreatment
   IF (currentlevel .GT. groundlevel) walltreatment = constantpressure
   ! **************************************************************
   ! *                                                            *
   ! * Determine the boundary condition treatment and compute the *
   ! * undivided pressure gradient accordingly. This gradient is  *
   ! * temporarily stored in the halo pressure.                   *
   ! *                                                            *
   ! **************************************************************
   !
   SELECT CASE  (walltreatment) 
   CASE (constantpressure) 
   CALL PUSHCONTROL1B(1)
   ! Constant pressure. Set the gradient to zero.
   grad = zero
   CASE (linextrapolpressure) 
   ! Linear extrapolation. 
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + 1
   k = ii/isize + 1
   grad(j, k) = pp3(j, k) - pp2(j, k)
   END DO
   CALL PUSHCONTROL1B(0)
   CASE DEFAULT
   CALL PUSHCONTROL1B(1)
   END SELECT
   CALL PUSHINTEGER4(j)
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + 1
   k = ii/isize + 1
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   pp1(j, k) = DIM(pp2(j, k), grad(j, k))
   vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
   &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
   &       bcdata(nn)%norm(j, k, 3))
   ww1(j, k, irho) = ww2(j, k, irho)
   ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
   ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
   ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   ww1(j, k, l) = ww2(j, k, l)
   END DO
   ! The laminar and eddy viscosity, if present.
   IF (viscous) rlv1(j, k) = rlv2(j, k)
   IF (eddymodel) rev1(j, k) = rev2(j, k)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2_B(ww1, ww1d, pp1, pp1d, correctfork)
   gradd = 0.0_8
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + 1
   k = ii/isize + 1
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
   &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
   &       bcdata(nn)%norm(j, k, 3))
   ! The laminar and eddy viscosity, if present.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev2d(j, k) = rev2d(j, k) + rev1d(j, k)
   rev1d(j, k) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2d(j, k) = rlv2d(j, k) + rlv1d(j, k)
   rlv1d(j, k) = 0.0_8
   END IF
   DO l=nt2mg,nt1mg,-1
   ww2d(j, k, l) = ww2d(j, k, l) + ww1d(j, k, l)
   ww1d(j, k, l) = 0.0_8
   END DO
   ww2d(j, k, ivz) = ww2d(j, k, ivz) + ww1d(j, k, ivz)
   vnd = bcdata(nn)%norm(j, k, 3)*ww1d(j, k, ivz)
   bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) + vn*ww1d(j&
   &       , k, ivz)
   ww1d(j, k, ivz) = 0.0_8
   ww2d(j, k, ivy) = ww2d(j, k, ivy) + ww1d(j, k, ivy)
   vnd = vnd + bcdata(nn)%norm(j, k, 2)*ww1d(j, k, ivy)
   bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) + vn*ww1d(j&
   &       , k, ivy)
   ww1d(j, k, ivy) = 0.0_8
   ww2d(j, k, ivx) = ww2d(j, k, ivx) + ww1d(j, k, ivx)
   vnd = vnd + bcdata(nn)%norm(j, k, 1)*ww1d(j, k, ivx)
   bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) + vn*ww1d(j&
   &       , k, ivx)
   ww1d(j, k, ivx) = 0.0_8
   ww2d(j, k, irho) = ww2d(j, k, irho) + ww1d(j, k, irho)
   ww1d(j, k, irho) = 0.0_8
   tempd = two*vnd
   ww2d(j, k, ivx) = ww2d(j, k, ivx) - bcdata(nn)%norm(j, k, 1)*tempd
   bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) - ww2(j, k, &
   &       ivx)*tempd
   ww2d(j, k, ivy) = ww2d(j, k, ivy) - bcdata(nn)%norm(j, k, 2)*tempd
   bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) - ww2(j, k, &
   &       ivy)*tempd
   ww2d(j, k, ivz) = ww2d(j, k, ivz) - bcdata(nn)%norm(j, k, 3)*tempd
   bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) - ww2(j, k, &
   &       ivz)*tempd
   CALL DIM_B(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k), pp1d(j&
   &          , k))
   pp1d(j, k) = 0.0_8
   END DO
   CALL POPINTEGER4(j)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + 1
   k = ii/isize + 1
   pp3d(j, k) = pp3d(j, k) + gradd(j, k)
   pp2d(j, k) = pp2d(j, k) - gradd(j, k)
   gradd(j, k) = 0.0_8
   END DO
   END IF
   END SUBROUTINE BCEULERWALL2_B
   SUBROUTINE BCEULERWALL2(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcEulerWall applies the inviscid wall boundary condition to    *
   ! * a block. It is assumed that the bcpointers are                 *
   ! * already set to the correct block on the correct grid level.    *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: j, k, l, ii
   INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
   INTEGER(kind=inttype) :: walltreatment
   REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
   REAL(kind=realtype) :: skxa, skya, skza, a1, b1
   REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
   REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
   REAL(kind=realtype) :: uux, uuy, uuz
   REAL(kind=realtype), DIMENSION(isize, jsize) :: grad
   INTRINSIC MOD
   REAL(kind=realtype) :: DIM
   ! Make sure that on the coarser grids the constant pressure
   ! boundary condition is used.
   walltreatment = wallbctreatment
   IF (currentlevel .GT. groundlevel) walltreatment = constantpressure
   ! **************************************************************
   ! *                                                            *
   ! * Determine the boundary condition treatment and compute the *
   ! * undivided pressure gradient accordingly. This gradient is  *
   ! * temporarily stored in the halo pressure.                   *
   ! *                                                            *
   ! **************************************************************
   !
   SELECT CASE  (walltreatment) 
   CASE (constantpressure) 
   ! Constant pressure. Set the gradient to zero.
   grad = zero
   CASE (linextrapolpressure) 
   ! Linear extrapolation. 
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + 1
   k = ii/isize + 1
   grad(j, k) = pp3(j, k) - pp2(j, k)
   END DO
   END SELECT
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + 1
   k = ii/isize + 1
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   pp1(j, k) = DIM(pp2(j, k), grad(j, k))
   vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
   &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
   &       bcdata(nn)%norm(j, k, 3))
   ww1(j, k, irho) = ww2(j, k, irho)
   ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
   ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
   ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   ww1(j, k, l) = ww2(j, k, l)
   END DO
   ! The laminar and eddy viscosity, if present.
   IF (viscous) rlv1(j, k) = rlv2(j, k)
   IF (eddymodel) rev1(j, k) = rev2(j, k)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
   END SUBROUTINE BCEULERWALL2
   !  Differentiation of bcfarfield2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: gammainf winf pinfcorr *(*bcdata.norm)
   !                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
   !                *ww0 *ww1 *ww2
   !   with respect to varying inputs: gammainf winf pinfcorr *(*bcdata.norm)
   !                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
   !                *ww0 *ww1 *ww2
   !   Plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
   !                rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in rlv1:in
   !                rlv2:in ww0:in ww1:in ww2:in
   SUBROUTINE BCFARFIELD2_B(nn, secondhalo, correctfork)
   !      ******************************************************************
   !      *                                                                *
   !      * bcFarfield applies the farfield boundary condition to a block. *
   !      * It is assumed that the BCPointers are already set              *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   ! Local variables.
   INTEGER(kind=inttype) :: nn, i, j, k, l, ii
   REAL(kind=realtype) :: nnx, nny, nnz
   REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
   REAL(kind=realtype) :: gm1d, ovgm1d, ac1d, ac2d
   REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
   REAL(kind=realtype) :: r0d, u0d, v0d, w0d, qn0d, c0d, s0d
   REAL(kind=realtype) :: re, ue, ve, we, qne, ce
   REAL(kind=realtype) :: red, ued, ved, wed, qned, ced
   REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
   REAL(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
   INTRINSIC SQRT
   INTRINSIC MOD
   INTEGER :: branch
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: temp
   ! Some constants needed to compute the riemann inVariants.
   gm1 = gammainf - one
   ovgm1 = one/gm1
   ! Compute the three velocity components, the speed of sound and
   ! the entropy of the free stream.
   r0 = one/winf(irho)
   u0 = winf(ivx)
   v0 = winf(ivy)
   w0 = winf(ivz)
   c0 = SQRT(gammainf*pinfcorr*r0)
   s0 = winf(irho)**gammainf/pinfcorr
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
   &       w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   re = one/ww2(i, j, irho)
   ue = ww2(i, j, ivx)
   ve = ww2(i, j, ivy)
   we = ww2(i, j, ivz)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
   &       we*bcdata(nn)%norm(i, j, 3)
   ce = SQRT(gamma2(i, j)*pp2(i, j)*re)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   ac1 = qne + two*ovgm1*ce
   ELSE
   ! Supersonic inflow.
   ac1 = qn0 + two*ovgm1*c0
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   ac2 = qne - two*ovgm1*ce
   ELSE
   ! Inflow or subsonic outflow.
   ac2 = qn0 - two*ovgm1*c0
   END IF
   qnf = half*(ac1+ac2)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   ELSE
   ! Inflow
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = winf(l)
   END DO
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   cc = cf*cf/gamma2(i, j)
   qq = uf*uf + vf*vf + wf*wf
   ww1(i, j, irho) = (sf*cc)**ovgm1
   ww1(i, j, ivx) = uf
   ww1(i, j, ivy) = vf
   ww1(i, j, ivz) = wf
   pp1(i, j) = ww1(i, j, irho)*cc
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT2_B(ww1, ww1d, pp1, pp1d, correctfork)
   v0d = 0.0_8
   gm1d = 0.0_8
   s0d = 0.0_8
   c0d = 0.0_8
   w0d = 0.0_8
   u0d = 0.0_8
   ovgm1d = 0.0_8
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
   &       w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   re = one/ww2(i, j, irho)
   ue = ww2(i, j, ivx)
   ve = ww2(i, j, ivy)
   we = ww2(i, j, ivz)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
   &       we*bcdata(nn)%norm(i, j, 3)
   ce = SQRT(gamma2(i, j)*pp2(i, j)*re)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   ac1 = qne + two*ovgm1*ce
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Supersonic inflow.
   ac1 = qn0 + two*ovgm1*c0
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   ac2 = qne - two*ovgm1*ce
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Inflow or subsonic outflow.
   ac2 = qn0 - two*ovgm1*c0
   CALL PUSHCONTROL1B(1)
   END IF
   qnf = half*(ac1+ac2)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Inflow
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = winf(l)
   END DO
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   cc = cf*cf/gamma2(i, j)
   ww1(i, j, irho) = (sf*cc)**ovgm1
   ww1(i, j, ivx) = uf
   ww1(i, j, ivy) = vf
   ww1(i, j, ivz) = wf
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   END IF
   ww1d(i, j, irho) = ww1d(i, j, irho) + cc*pp1d(i, j)
   wfd = ww1d(i, j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   vfd = ww1d(i, j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ufd = ww1d(i, j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   temp1 = sf*cc
   IF (temp1 .LE. 0.0_8 .AND. (ovgm1 .EQ. 0.0_8 .OR. ovgm1 .NE. INT(&
   &         ovgm1))) THEN
   tempd10 = 0.0
   ELSE
   tempd10 = ovgm1*temp1**(ovgm1-1)*ww1d(i, j, irho)
   END IF
   ccd = sf*tempd10 + ww1(i, j, irho)*pp1d(i, j)
   pp1d(i, j) = 0.0_8
   sfd = cc*tempd10
   IF (.NOT.temp1 .LE. 0.0_8) ovgm1d = ovgm1d + temp1**ovgm1*LOG(&
   &         temp1)*ww1d(i, j, irho)
   ww1d(i, j, irho) = 0.0_8
   cfd = 2*cf*ccd/gamma2(i, j)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   DO l=nt1mg,nt2mg
   ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
   ww1d(i, j, l) = 0.0_8
   END DO
   tempd6 = bcdata(nn)%norm(i, j, 1)*ufd
   tempd5 = bcdata(nn)%norm(i, j, 2)*vfd
   tempd3 = sfd/pp2(i, j)
   temp0 = gamma2(i, j)
   IF (.NOT.(ww2(i, j, irho) .LE. 0.0_8 .AND. (temp0 .EQ. 0.0_8 &
   &           .OR. temp0 .NE. INT(temp0)))) ww2d(i, j, irho) = ww2d(i, j, &
   &           irho) + temp0*ww2(i, j, irho)**(temp0-1)*tempd3
   pp2d(i, j) = pp2d(i, j) - ww2(i, j, irho)**temp0*tempd3/pp2(i, j&
   &         )
   tempd4 = bcdata(nn)%norm(i, j, 3)*wfd
   wed = wfd
   qnfd = tempd5 + tempd6 + tempd4
   qned = -tempd5 - tempd6 - tempd4
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qne&
   &         )*wfd
   ved = vfd
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qne&
   &         )*vfd
   ued = ufd
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qne&
   &         )*ufd
   qn0d = 0.0_8
   ELSE
   DO l=nt1mg,nt2mg
   winfd(l) = winfd(l) + ww1d(i, j, l)
   ww1d(i, j, l) = 0.0_8
   END DO
   tempd9 = bcdata(nn)%norm(i, j, 1)*ufd
   tempd8 = bcdata(nn)%norm(i, j, 2)*vfd
   s0d = s0d + sfd
   tempd7 = bcdata(nn)%norm(i, j, 3)*wfd
   w0d = w0d + wfd
   qnfd = tempd8 + tempd9 + tempd7
   qn0d = -tempd8 - tempd9 - tempd7
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qn0&
   &         )*wfd
   v0d = v0d + vfd
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qn0&
   &         )*vfd
   u0d = u0d + ufd
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qn0&
   &         )*ufd
   qned = 0.0_8
   ued = 0.0_8
   ved = 0.0_8
   wed = 0.0_8
   END IF
   tempd2 = fourth*cfd
   ac1d = half*qnfd + gm1*tempd2
   ac2d = half*qnfd - gm1*tempd2
   gm1d = gm1d + (ac1-ac2)*tempd2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   qned = qned + ac2d
   ovgm1d = ovgm1d - two*ce*ac2d
   ced = -(two*ovgm1*ac2d)
   ELSE
   qn0d = qn0d + ac2d
   ovgm1d = ovgm1d - two*c0*ac2d
   c0d = c0d - two*ovgm1*ac2d
   ced = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   qned = qned + ac1d
   ovgm1d = ovgm1d + two*ce*ac1d
   ced = ced + two*ovgm1*ac1d
   ELSE
   qn0d = qn0d + ac1d
   ovgm1d = ovgm1d + two*c0*ac1d
   c0d = c0d + two*ovgm1*ac1d
   END IF
   IF (gamma2(i, j)*(pp2(i, j)*re) .EQ. 0.0_8) THEN
   tempd1 = 0.0
   ELSE
   tempd1 = gamma2(i, j)*ced/(2.0*SQRT(gamma2(i, j)*(pp2(i, j)*re))&
   &         )
   END IF
   pp2d(i, j) = pp2d(i, j) + re*tempd1
   red = pp2(i, j)*tempd1
   ued = ued + bcdata(nn)%norm(i, j, 1)*qned
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ue*qned
   ved = ved + bcdata(nn)%norm(i, j, 2)*qned
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ve*qned
   wed = wed + bcdata(nn)%norm(i, j, 3)*qned
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + we*qned
   ww2d(i, j, ivz) = ww2d(i, j, ivz) + wed
   ww2d(i, j, ivy) = ww2d(i, j, ivy) + ved
   ww2d(i, j, ivx) = ww2d(i, j, ivx) + ued
   ww2d(i, j, irho) = ww2d(i, j, irho) - one*red/ww2(i, j, irho)**2
   u0d = u0d + bcdata(nn)%norm(i, j, 1)*qn0d
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + u0*qn0d
   v0d = v0d + bcdata(nn)%norm(i, j, 2)*qn0d
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + v0*qn0d
   w0d = w0d + bcdata(nn)%norm(i, j, 3)*qn0d
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + w0*qn0d
   END DO
   gm1d = gm1d - one*ovgm1d/gm1**2
   IF (gammainf*pinfcorr*r0 .EQ. 0.0_8) THEN
   tempd0 = 0.0
   ELSE
   tempd0 = c0d/(2.0*SQRT(gammainf*pinfcorr*r0))
   END IF
   tempd = s0d/pinfcorr
   temp = winf(irho)**gammainf
   IF (.NOT.(winf(irho) .LE. 0.0_8 .AND. (gammainf .EQ. 0.0_8 .OR. &
   &       gammainf .NE. INT(gammainf)))) winfd(irho) = winfd(irho) + &
   &       gammainf*winf(irho)**(gammainf-1)*tempd
   IF (winf(irho) .LE. 0.0_8) THEN
   gammainfd = gammainfd + r0*pinfcorr*tempd0 + gm1d
   ELSE
   gammainfd = gammainfd + r0*pinfcorr*tempd0 + gm1d + temp*LOG(winf(&
   &       irho))*tempd
   END IF
   pinfcorrd = pinfcorrd + r0*gammainf*tempd0 - temp*tempd/pinfcorr
   r0d = gammainf*pinfcorr*tempd0
   winfd(ivz) = winfd(ivz) + w0d
   winfd(ivy) = winfd(ivy) + v0d
   winfd(ivx) = winfd(ivx) + u0d
   winfd(irho) = winfd(irho) - one*r0d/winf(irho)**2
   END SUBROUTINE BCFARFIELD2_B
   SUBROUTINE BCFARFIELD2(nn, secondhalo, correctfork)
   !      ******************************************************************
   !      *                                                                *
   !      * bcFarfield applies the farfield boundary condition to a block. *
   !      * It is assumed that the BCPointers are already set              *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   ! Local variables.
   INTEGER(kind=inttype) :: nn, i, j, k, l, ii
   REAL(kind=realtype) :: nnx, nny, nnz
   REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
   REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
   REAL(kind=realtype) :: re, ue, ve, we, qne, ce
   REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
   INTRINSIC SQRT
   INTRINSIC MOD
   ! Some constants needed to compute the riemann inVariants.
   gm1 = gammainf - one
   ovgm1 = one/gm1
   ! Compute the three velocity components, the speed of sound and
   ! the entropy of the free stream.
   r0 = one/winf(irho)
   u0 = winf(ivx)
   v0 = winf(ivy)
   w0 = winf(ivz)
   c0 = SQRT(gammainf*pinfcorr*r0)
   s0 = winf(irho)**gammainf/pinfcorr
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
   &       w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   re = one/ww2(i, j, irho)
   ue = ww2(i, j, ivx)
   ve = ww2(i, j, ivy)
   we = ww2(i, j, ivz)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
   &       we*bcdata(nn)%norm(i, j, 3)
   ce = SQRT(gamma2(i, j)*pp2(i, j)*re)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   ac1 = qne + two*ovgm1*ce
   ELSE
   ! Supersonic inflow.
   ac1 = qn0 + two*ovgm1*c0
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   ac2 = qne - two*ovgm1*ce
   ELSE
   ! Inflow or subsonic outflow.
   ac2 = qn0 - two*ovgm1*c0
   END IF
   qnf = half*(ac1+ac2)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   ELSE
   ! Inflow
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = winf(l)
   END DO
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   cc = cf*cf/gamma2(i, j)
   qq = uf*uf + vf*vf + wf*wf
   ww1(i, j, irho) = (sf*cc)**ovgm1
   ww1(i, j, ivx) = uf
   ww1(i, j, ivy) = vf
   ww1(i, j, ivz) = wf
   pp1(i, j) = ww1(i, j, irho)*cc
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT2(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
   END SUBROUTINE BCFARFIELD2
   !  Differentiation of extrapolate2ndhalo2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev0 *rev1 *pp0 *pp1 *pp2
   !                *rlv0 *rlv1 *ww0 *ww1 *ww2
   !   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
   !                *rlv0 *rlv1 *ww0 *ww1 *ww2
   !   Plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
   !                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
   SUBROUTINE EXTRAPOLATE2NDHALO2_B(correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * extrapolate2ndHalo determines the states of the second layer   *
   !      * halo cells for the given subface of the block. It is assumed   *
   !      * that the appropriate BCPointers are already set
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   USE INPUTPHYSICS
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: correctfork
   REAL(kind=realtype), PARAMETER :: factor=0.5_realType
   INTEGER(kind=inttype) :: i, j, l, ii
   INTRINSIC MOD
   INTRINSIC MAX
   INTEGER :: branch
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Extrapolate the density, momentum and pressure.
   ! Make sure that a certain threshold is kept.
   ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
   IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
   ww0(i, j, irho) = ww0(i, j, irho)
   ELSE
   ww0(i, j, irho) = factor*ww1(i, j, irho)
   END IF
   ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
   ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
   ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
   IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
   pp0(i, j) = two*pp1(i, j) - pp2(i, j)
   ELSE
   pp0(i, j) = factor*pp1(i, j)
   END IF
   ! Extrapolate the turbulent variables. Use constant
   ! extrapolation.
   DO l=nt1mg,nt2mg
   ww0(i, j, l) = ww1(i, j, l)
   END DO
   ! The laminar and eddy viscosity, if present. These values
   ! are simply taken constant. Their values do not matter.
   IF (viscous) rlv0(i, j) = rlv1(i, j)
   IF (eddymodel) rev0(i, j) = rev1(i, j)
   END DO
   CALL COMPUTEETOT2_B(ww0, ww0d, pp0, pp0d, correctfork)
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Extrapolate the density, momentum and pressure.
   ! Make sure that a certain threshold is kept.
   ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
   IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! The laminar and eddy viscosity, if present. These values
   ! are simply taken constant. Their values do not matter.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev1d(i, j) = rev1d(i, j) + rev0d(i, j)
   rev0d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv1d(i, j) = rlv1d(i, j) + rlv0d(i, j)
   rlv0d(i, j) = 0.0_8
   END IF
   DO l=nt1mg,nt2mg
   ww1d(i, j, l) = ww1d(i, j, l) + ww0d(i, j, l)
   ww0d(i, j, l) = 0.0_8
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   pp1d(i, j) = pp1d(i, j) + two*pp0d(i, j)
   pp2d(i, j) = pp2d(i, j) - pp0d(i, j)
   pp0d(i, j) = 0.0_8
   ELSE
   pp1d(i, j) = pp1d(i, j) + factor*pp0d(i, j)
   pp0d(i, j) = 0.0_8
   END IF
   ww1d(i, j, ivz) = ww1d(i, j, ivz) + two*ww0d(i, j, ivz)
   ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww0d(i, j, ivz)
   ww0d(i, j, ivz) = 0.0_8
   ww1d(i, j, ivy) = ww1d(i, j, ivy) + two*ww0d(i, j, ivy)
   ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww0d(i, j, ivy)
   ww0d(i, j, ivy) = 0.0_8
   ww1d(i, j, ivx) = ww1d(i, j, ivx) + two*ww0d(i, j, ivx)
   ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww0d(i, j, ivx)
   ww0d(i, j, ivx) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ww1d(i, j, irho) = ww1d(i, j, irho) + factor*ww0d(i, j, irho)
   ww0d(i, j, irho) = 0.0_8
   END IF
   ww1d(i, j, irho) = ww1d(i, j, irho) + two*ww0d(i, j, irho)
   ww2d(i, j, irho) = ww2d(i, j, irho) - ww0d(i, j, irho)
   ww0d(i, j, irho) = 0.0_8
   END DO
   END SUBROUTINE EXTRAPOLATE2NDHALO2_B
   !  Differentiation of computeetot2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: ww pp
   !   with respect to varying inputs: ww pp
   SUBROUTINE COMPUTEETOT2_B(ww, wwd, pp, ppd, correctfork)
   ! Simplified total energy computation for boundary conditions.
   ! Only implements the constant cpModel
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   REAL(kind=realtype), DIMENSION(:, :) :: pp
   REAL(kind=realtype), DIMENSION(:, :) :: ppd
   REAL(kind=realtype), DIMENSION(:, :, :) :: ww
   REAL(kind=realtype), DIMENSION(:, :, :) :: wwd
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: ii, i, j
   REAL(kind=realtype) :: ovgm1, factk
   INTRINSIC MOD
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tmpd0
   SELECT CASE  (cpmodel) 
   CASE (cpconstant) 
   ! Constant cp and thus constant gamma.
   ! Abbreviate 1/(gamma -1) a bit easier.
   ovgm1 = one/(gammaconstant-one)
   factk = ovgm1*(five*third-gammaconstant)
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   IF (.NOT.correctfork) THEN
   tmpd = wwd(i, j, irhoe)
   wwd(i, j, irhoe) = 0.0_8
   tempd = half*ww(i, j, irho)*tmpd
   ppd(i, j) = ppd(i, j) + ovgm1*tmpd
   wwd(i, j, irho) = wwd(i, j, irho) + half*(ww(i, j, ivx)**2+ww(&
   &           i, j, ivy)**2+ww(i, j, ivz)**2)*tmpd
   wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd
   wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd
   wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd
   ELSE
   tmpd0 = wwd(i, j, irhoe)
   wwd(i, j, irhoe) = 0.0_8
   tempd0 = half*ww(i, j, irho)*tmpd0
   ppd(i, j) = ppd(i, j) + ovgm1*tmpd0
   wwd(i, j, irho) = wwd(i, j, irho) + (half*(ww(i, j, ivx)**2+ww&
   &           (i, j, ivy)**2+ww(i, j, ivz)**2)-factk*ww(i, j, itu1))*tmpd0
   wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd0
   wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd0
   wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd0
   wwd(i, j, itu1) = wwd(i, j, itu1) - factk*ww(i, j, irho)*tmpd0
   END IF
   END DO
   END SELECT
   END SUBROUTINE COMPUTEETOT2_B
   SUBROUTINE EXTRAPOLATE2NDHALO2(correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * extrapolate2ndHalo determines the states of the second layer   *
   !      * halo cells for the given subface of the block. It is assumed   *
   !      * that the appropriate BCPointers are already set
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   USE INPUTPHYSICS
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: correctfork
   REAL(kind=realtype), PARAMETER :: factor=0.5_realType
   INTEGER(kind=inttype) :: i, j, l, ii
   INTRINSIC MOD
   INTRINSIC MAX
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   ! Extrapolate the density, momentum and pressure.
   ! Make sure that a certain threshold is kept.
   ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
   IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
   ww0(i, j, irho) = ww0(i, j, irho)
   ELSE
   ww0(i, j, irho) = factor*ww1(i, j, irho)
   END IF
   ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
   ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
   ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
   IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
   pp0(i, j) = two*pp1(i, j) - pp2(i, j)
   ELSE
   pp0(i, j) = factor*pp1(i, j)
   END IF
   ! Extrapolate the turbulent variables. Use constant
   ! extrapolation.
   DO l=nt1mg,nt2mg
   ww0(i, j, l) = ww1(i, j, l)
   END DO
   ! The laminar and eddy viscosity, if present. These values
   ! are simply taken constant. Their values do not matter.
   IF (viscous) rlv0(i, j) = rlv1(i, j)
   IF (eddymodel) rev0(i, j) = rev1(i, j)
   END DO
   ! Compute the energy for this halo range.
   CALL COMPUTEETOT2(ww0, pp0, correctfork)
   END SUBROUTINE EXTRAPOLATE2NDHALO2
   SUBROUTINE COMPUTEETOT2(ww, pp, correctfork)
   ! Simplified total energy computation for boundary conditions.
   ! Only implements the constant cpModel
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   REAL(kind=realtype), DIMENSION(:, :) :: pp
   REAL(kind=realtype), DIMENSION(:, :, :) :: ww
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: ii, i, j
   REAL(kind=realtype) :: ovgm1, factk
   INTRINSIC MOD
   SELECT CASE  (cpmodel) 
   CASE (cpconstant) 
   ! Constant cp and thus constant gamma.
   ! Abbreviate 1/(gamma -1) a bit easier.
   ovgm1 = one/(gammaconstant-one)
   factk = ovgm1*(five*third-gammaconstant)
   ! Loop over the given array and compute the energy, possibly
   ! correcting for K
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + 1
   j = ii/isize + 1
   IF (.NOT.correctfork) THEN
   ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
   &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
   ELSE
   ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
   &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
   &           j, irho)*ww(i, j, itu1)
   END IF
   END DO
   CASE (cptempcurvefits) 
   CALL TERMINATE('BCRoutines', &
   &                 'CPTempCurveFits not implemented yet.')
   END SELECT
   END SUBROUTINE COMPUTEETOT2
   !  Differentiation of setbcpointers2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *p *w *rlv *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   with respect to varying inputs: *rev *p *w *rlv *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   Plus diff mem management of: rev:in p:in w:in rlv:in bcdata:in
   !                rev0:in rev1:in rev2:in rev3:in pp0:in pp1:in
   !                pp2:in pp3:in rlv0:in rlv1:in rlv2:in rlv3:in
   !                ww0:in ww1:in ww2:in ww3:in
   SUBROUTINE SETBCPOINTERS2_B(nn)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * setBCPointers sets the pointers needed for the boundary        *
   !      * condition treatment on a general face, such that the boundary  *
   !      * routines are only implemented once instead of 6 times.         *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Note that the ss{i,j,}, ss and xline pointers are NOT included
   ! here since they are not AD'ed. 
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables
   INTEGER(kind=inttype) :: istart, iend, jstart, jend
   ! Determine the sizes of each face and point to just the range we
   ! need on each face. 
   istart = bcdata(nn)%icbeg
   iend = bcdata(nn)%icend
   jstart = bcdata(nn)%jcbeg
   jend = bcdata(nn)%jcend
   ! Set the size of the subface
   isize = iend - istart + 1
   jsize = jend - jstart + 1
   ! Determine the face id on which the subface is located and set
   ! the pointers accordinly.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   revd(0, istart:iend, jstart:jend) = revd(0, istart:iend, jstart:&
   &       jend) + rev0d(1:isize, 1:jsize)
   rev0d(1:isize, 1:jsize) = 0.0_8
   revd(1, istart:iend, jstart:jend) = revd(1, istart:iend, jstart:&
   &       jend) + rev1d(1:isize, 1:jsize)
   rev1d(1:isize, 1:jsize) = 0.0_8
   revd(2, istart:iend, jstart:jend) = revd(2, istart:iend, jstart:&
   &       jend) + rev2d(1:isize, 1:jsize)
   rev2d(1:isize, 1:jsize) = 0.0_8
   revd(3, istart:iend, jstart:jend) = revd(3, istart:iend, jstart:&
   &       jend) + rev3d(1:isize, 1:jsize)
   rev3d(1:isize, 1:jsize) = 0.0_8
   rlvd(0, istart:iend, jstart:jend) = rlvd(0, istart:iend, jstart:&
   &       jend) + rlv0d(1:isize, 1:jsize)
   rlv0d(1:isize, 1:jsize) = 0.0_8
   rlvd(1, istart:iend, jstart:jend) = rlvd(1, istart:iend, jstart:&
   &       jend) + rlv1d(1:isize, 1:jsize)
   rlv1d(1:isize, 1:jsize) = 0.0_8
   rlvd(2, istart:iend, jstart:jend) = rlvd(2, istart:iend, jstart:&
   &       jend) + rlv2d(1:isize, 1:jsize)
   rlv2d(1:isize, 1:jsize) = 0.0_8
   rlvd(3, istart:iend, jstart:jend) = rlvd(3, istart:iend, jstart:&
   &       jend) + rlv3d(1:isize, 1:jsize)
   rlv3d(1:isize, 1:jsize) = 0.0_8
   pd(0, istart:iend, jstart:jend) = pd(0, istart:iend, jstart:jend) &
   &       + pp0d(1:isize, 1:jsize)
   pp0d(1:isize, 1:jsize) = 0.0_8
   pd(1, istart:iend, jstart:jend) = pd(1, istart:iend, jstart:jend) &
   &       + pp1d(1:isize, 1:jsize)
   pp1d(1:isize, 1:jsize) = 0.0_8
   pd(2, istart:iend, jstart:jend) = pd(2, istart:iend, jstart:jend) &
   &       + pp2d(1:isize, 1:jsize)
   pp2d(1:isize, 1:jsize) = 0.0_8
   pd(3, istart:iend, jstart:jend) = pd(3, istart:iend, jstart:jend) &
   &       + pp3d(1:isize, 1:jsize)
   pp3d(1:isize, 1:jsize) = 0.0_8
   wd(0, istart:iend, jstart:jend, :) = wd(0, istart:iend, jstart:&
   &       jend, :) + ww0d(1:isize, 1:jsize, :)
   ww0d(1:isize, 1:jsize, :) = 0.0_8
   wd(1, istart:iend, jstart:jend, :) = wd(1, istart:iend, jstart:&
   &       jend, :) + ww1d(1:isize, 1:jsize, :)
   ww1d(1:isize, 1:jsize, :) = 0.0_8
   wd(2, istart:iend, jstart:jend, :) = wd(2, istart:iend, jstart:&
   &       jend, :) + ww2d(1:isize, 1:jsize, :)
   ww2d(1:isize, 1:jsize, :) = 0.0_8
   wd(3, istart:iend, jstart:jend, :) = wd(3, istart:iend, jstart:&
   &       jend, :) + ww3d(1:isize, 1:jsize, :)
   ww3d(1:isize, 1:jsize, :) = 0.0_8
   CASE (imax) 
   revd(ib, istart:iend, jstart:jend) = revd(ib, istart:iend, jstart:&
   &       jend) + rev0d(1:isize, 1:jsize)
   rev0d(1:isize, 1:jsize) = 0.0_8
   revd(ie, istart:iend, jstart:jend) = revd(ie, istart:iend, jstart:&
   &       jend) + rev1d(1:isize, 1:jsize)
   rev1d(1:isize, 1:jsize) = 0.0_8
   revd(il, istart:iend, jstart:jend) = revd(il, istart:iend, jstart:&
   &       jend) + rev2d(1:isize, 1:jsize)
   rev2d(1:isize, 1:jsize) = 0.0_8
   revd(nx, istart:iend, jstart:jend) = revd(nx, istart:iend, jstart:&
   &       jend) + rev3d(1:isize, 1:jsize)
   rev3d(1:isize, 1:jsize) = 0.0_8
   rlvd(ib, istart:iend, jstart:jend) = rlvd(ib, istart:iend, jstart:&
   &       jend) + rlv0d(1:isize, 1:jsize)
   rlv0d(1:isize, 1:jsize) = 0.0_8
   rlvd(ie, istart:iend, jstart:jend) = rlvd(ie, istart:iend, jstart:&
   &       jend) + rlv1d(1:isize, 1:jsize)
   rlv1d(1:isize, 1:jsize) = 0.0_8
   rlvd(il, istart:iend, jstart:jend) = rlvd(il, istart:iend, jstart:&
   &       jend) + rlv2d(1:isize, 1:jsize)
   rlv2d(1:isize, 1:jsize) = 0.0_8
   rlvd(nx, istart:iend, jstart:jend) = rlvd(nx, istart:iend, jstart:&
   &       jend) + rlv3d(1:isize, 1:jsize)
   rlv3d(1:isize, 1:jsize) = 0.0_8
   pd(ib, istart:iend, jstart:jend) = pd(ib, istart:iend, jstart:jend&
   &       ) + pp0d(1:isize, 1:jsize)
   pp0d(1:isize, 1:jsize) = 0.0_8
   pd(ie, istart:iend, jstart:jend) = pd(ie, istart:iend, jstart:jend&
   &       ) + pp1d(1:isize, 1:jsize)
   pp1d(1:isize, 1:jsize) = 0.0_8
   pd(il, istart:iend, jstart:jend) = pd(il, istart:iend, jstart:jend&
   &       ) + pp2d(1:isize, 1:jsize)
   pp2d(1:isize, 1:jsize) = 0.0_8
   pd(nx, istart:iend, jstart:jend) = pd(nx, istart:iend, jstart:jend&
   &       ) + pp3d(1:isize, 1:jsize)
   pp3d(1:isize, 1:jsize) = 0.0_8
   wd(ib, istart:iend, jstart:jend, :) = wd(ib, istart:iend, jstart:&
   &       jend, :) + ww0d(1:isize, 1:jsize, :)
   ww0d(1:isize, 1:jsize, :) = 0.0_8
   wd(ie, istart:iend, jstart:jend, :) = wd(ie, istart:iend, jstart:&
   &       jend, :) + ww1d(1:isize, 1:jsize, :)
   ww1d(1:isize, 1:jsize, :) = 0.0_8
   wd(il, istart:iend, jstart:jend, :) = wd(il, istart:iend, jstart:&
   &       jend, :) + ww2d(1:isize, 1:jsize, :)
   ww2d(1:isize, 1:jsize, :) = 0.0_8
   wd(nx, istart:iend, jstart:jend, :) = wd(nx, istart:iend, jstart:&
   &       jend, :) + ww3d(1:isize, 1:jsize, :)
   ww3d(1:isize, 1:jsize, :) = 0.0_8
   CASE (jmin) 
   revd(istart:iend, 0, jstart:jend) = revd(istart:iend, 0, jstart:&
   &       jend) + rev0d(1:isize, 1:jsize)
   rev0d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, 1, jstart:jend) = revd(istart:iend, 1, jstart:&
   &       jend) + rev1d(1:isize, 1:jsize)
   rev1d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, 2, jstart:jend) = revd(istart:iend, 2, jstart:&
   &       jend) + rev2d(1:isize, 1:jsize)
   rev2d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, 3, jstart:jend) = revd(istart:iend, 3, jstart:&
   &       jend) + rev3d(1:isize, 1:jsize)
   rev3d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, 0, jstart:jend) = rlvd(istart:iend, 0, jstart:&
   &       jend) + rlv0d(1:isize, 1:jsize)
   rlv0d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, 1, jstart:jend) = rlvd(istart:iend, 1, jstart:&
   &       jend) + rlv1d(1:isize, 1:jsize)
   rlv1d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, 2, jstart:jend) = rlvd(istart:iend, 2, jstart:&
   &       jend) + rlv2d(1:isize, 1:jsize)
   rlv2d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, 3, jstart:jend) = rlvd(istart:iend, 3, jstart:&
   &       jend) + rlv3d(1:isize, 1:jsize)
   rlv3d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, 0, jstart:jend) = pd(istart:iend, 0, jstart:jend) &
   &       + pp0d(1:isize, 1:jsize)
   pp0d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, 1, jstart:jend) = pd(istart:iend, 1, jstart:jend) &
   &       + pp1d(1:isize, 1:jsize)
   pp1d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, 2, jstart:jend) = pd(istart:iend, 2, jstart:jend) &
   &       + pp2d(1:isize, 1:jsize)
   pp2d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, 3, jstart:jend) = pd(istart:iend, 3, jstart:jend) &
   &       + pp3d(1:isize, 1:jsize)
   pp3d(1:isize, 1:jsize) = 0.0_8
   wd(istart:iend, 0, jstart:jend, :) = wd(istart:iend, 0, jstart:&
   &       jend, :) + ww0d(1:isize, 1:jsize, :)
   ww0d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, 1, jstart:jend, :) = wd(istart:iend, 1, jstart:&
   &       jend, :) + ww1d(1:isize, 1:jsize, :)
   ww1d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, 2, jstart:jend, :) = wd(istart:iend, 2, jstart:&
   &       jend, :) + ww2d(1:isize, 1:jsize, :)
   ww2d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, 3, jstart:jend, :) = wd(istart:iend, 3, jstart:&
   &       jend, :) + ww3d(1:isize, 1:jsize, :)
   ww3d(1:isize, 1:jsize, :) = 0.0_8
   CASE (jmax) 
   revd(istart:iend, jb, jstart:jend) = revd(istart:iend, jb, jstart:&
   &       jend) + rev0d(1:isize, 1:jsize)
   rev0d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, je, jstart:jend) = revd(istart:iend, je, jstart:&
   &       jend) + rev1d(1:isize, 1:jsize)
   rev1d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, jl, jstart:jend) = revd(istart:iend, jl, jstart:&
   &       jend) + rev2d(1:isize, 1:jsize)
   rev2d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, ny, jstart:jend) = revd(istart:iend, ny, jstart:&
   &       jend) + rev3d(1:isize, 1:jsize)
   rev3d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jb, jstart:jend) = rlvd(istart:iend, jb, jstart:&
   &       jend) + rlv0d(1:isize, 1:jsize)
   rlv0d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, je, jstart:jend) = rlvd(istart:iend, je, jstart:&
   &       jend) + rlv1d(1:isize, 1:jsize)
   rlv1d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jl, jstart:jend) = rlvd(istart:iend, jl, jstart:&
   &       jend) + rlv2d(1:isize, 1:jsize)
   rlv2d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, ny, jstart:jend) = rlvd(istart:iend, ny, jstart:&
   &       jend) + rlv3d(1:isize, 1:jsize)
   rlv3d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jb, jstart:jend) = pd(istart:iend, jb, jstart:jend&
   &       ) + pp0d(1:isize, 1:jsize)
   pp0d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, je, jstart:jend) = pd(istart:iend, je, jstart:jend&
   &       ) + pp1d(1:isize, 1:jsize)
   pp1d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jl, jstart:jend) = pd(istart:iend, jl, jstart:jend&
   &       ) + pp2d(1:isize, 1:jsize)
   pp2d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, ny, jstart:jend) = pd(istart:iend, ny, jstart:jend&
   &       ) + pp3d(1:isize, 1:jsize)
   pp3d(1:isize, 1:jsize) = 0.0_8
   wd(istart:iend, jb, jstart:jend, :) = wd(istart:iend, jb, jstart:&
   &       jend, :) + ww0d(1:isize, 1:jsize, :)
   ww0d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, je, jstart:jend, :) = wd(istart:iend, je, jstart:&
   &       jend, :) + ww1d(1:isize, 1:jsize, :)
   ww1d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, jl, jstart:jend, :) = wd(istart:iend, jl, jstart:&
   &       jend, :) + ww2d(1:isize, 1:jsize, :)
   ww2d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, ny, jstart:jend, :) = wd(istart:iend, ny, jstart:&
   &       jend, :) + ww3d(1:isize, 1:jsize, :)
   ww3d(1:isize, 1:jsize, :) = 0.0_8
   CASE (kmin) 
   revd(istart:iend, jstart:jend, 0) = revd(istart:iend, jstart:jend&
   &       , 0) + rev0d(1:isize, 1:jsize)
   rev0d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, jstart:jend, 1) = revd(istart:iend, jstart:jend&
   &       , 1) + rev1d(1:isize, 1:jsize)
   rev1d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, jstart:jend, 2) = revd(istart:iend, jstart:jend&
   &       , 2) + rev2d(1:isize, 1:jsize)
   rev2d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, jstart:jend, 3) = revd(istart:iend, jstart:jend&
   &       , 3) + rev3d(1:isize, 1:jsize)
   rev3d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, 0) = rlvd(istart:iend, jstart:jend&
   &       , 0) + rlv0d(1:isize, 1:jsize)
   rlv0d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, 1) = rlvd(istart:iend, jstart:jend&
   &       , 1) + rlv1d(1:isize, 1:jsize)
   rlv1d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, 2) = rlvd(istart:iend, jstart:jend&
   &       , 2) + rlv2d(1:isize, 1:jsize)
   rlv2d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, 3) = rlvd(istart:iend, jstart:jend&
   &       , 3) + rlv3d(1:isize, 1:jsize)
   rlv3d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, 0) = pd(istart:iend, jstart:jend, 0) &
   &       + pp0d(1:isize, 1:jsize)
   pp0d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, 1) = pd(istart:iend, jstart:jend, 1) &
   &       + pp1d(1:isize, 1:jsize)
   pp1d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, 2) = pd(istart:iend, jstart:jend, 2) &
   &       + pp2d(1:isize, 1:jsize)
   pp2d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, 3) = pd(istart:iend, jstart:jend, 3) &
   &       + pp3d(1:isize, 1:jsize)
   pp3d(1:isize, 1:jsize) = 0.0_8
   wd(istart:iend, jstart:jend, 0, :) = wd(istart:iend, jstart:jend, &
   &       0, :) + ww0d(1:isize, 1:jsize, :)
   ww0d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, jstart:jend, 1, :) = wd(istart:iend, jstart:jend, &
   &       1, :) + ww1d(1:isize, 1:jsize, :)
   ww1d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, jstart:jend, 2, :) = wd(istart:iend, jstart:jend, &
   &       2, :) + ww2d(1:isize, 1:jsize, :)
   ww2d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, jstart:jend, 3, :) = wd(istart:iend, jstart:jend, &
   &       3, :) + ww3d(1:isize, 1:jsize, :)
   ww3d(1:isize, 1:jsize, :) = 0.0_8
   CASE (kmax) 
   revd(istart:iend, jstart:jend, kb) = revd(istart:iend, jstart:jend&
   &       , kb) + rev0d(1:isize, 1:jsize)
   rev0d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, jstart:jend, ke) = revd(istart:iend, jstart:jend&
   &       , ke) + rev1d(1:isize, 1:jsize)
   rev1d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, jstart:jend, kl) = revd(istart:iend, jstart:jend&
   &       , kl) + rev2d(1:isize, 1:jsize)
   rev2d(1:isize, 1:jsize) = 0.0_8
   revd(istart:iend, jstart:jend, nz) = revd(istart:iend, jstart:jend&
   &       , nz) + rev3d(1:isize, 1:jsize)
   rev3d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, kb) = rlvd(istart:iend, jstart:jend&
   &       , kb) + rlv0d(1:isize, 1:jsize)
   rlv0d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, ke) = rlvd(istart:iend, jstart:jend&
   &       , ke) + rlv1d(1:isize, 1:jsize)
   rlv1d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, kl) = rlvd(istart:iend, jstart:jend&
   &       , kl) + rlv2d(1:isize, 1:jsize)
   rlv2d(1:isize, 1:jsize) = 0.0_8
   rlvd(istart:iend, jstart:jend, nz) = rlvd(istart:iend, jstart:jend&
   &       , nz) + rlv3d(1:isize, 1:jsize)
   rlv3d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, kb) = pd(istart:iend, jstart:jend, kb&
   &       ) + pp0d(1:isize, 1:jsize)
   pp0d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, ke) = pd(istart:iend, jstart:jend, ke&
   &       ) + pp1d(1:isize, 1:jsize)
   pp1d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, kl) = pd(istart:iend, jstart:jend, kl&
   &       ) + pp2d(1:isize, 1:jsize)
   pp2d(1:isize, 1:jsize) = 0.0_8
   pd(istart:iend, jstart:jend, nz) = pd(istart:iend, jstart:jend, nz&
   &       ) + pp3d(1:isize, 1:jsize)
   pp3d(1:isize, 1:jsize) = 0.0_8
   wd(istart:iend, jstart:jend, kb, :) = wd(istart:iend, jstart:jend&
   &       , kb, :) + ww0d(1:isize, 1:jsize, :)
   ww0d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, jstart:jend, ke, :) = wd(istart:iend, jstart:jend&
   &       , ke, :) + ww1d(1:isize, 1:jsize, :)
   ww1d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, jstart:jend, kl, :) = wd(istart:iend, jstart:jend&
   &       , kl, :) + ww2d(1:isize, 1:jsize, :)
   ww2d(1:isize, 1:jsize, :) = 0.0_8
   wd(istart:iend, jstart:jend, nz, :) = wd(istart:iend, jstart:jend&
   &       , nz, :) + ww3d(1:isize, 1:jsize, :)
   ww3d(1:isize, 1:jsize, :) = 0.0_8
   END SELECT
   END SUBROUTINE SETBCPOINTERS2_B
   SUBROUTINE SETBCPOINTERS2(nn)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * setBCPointers sets the pointers needed for the boundary        *
   !      * condition treatment on a general face, such that the boundary  *
   !      * routines are only implemented once instead of 6 times.         *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Note that the ss{i,j,}, ss and xline pointers are NOT included
   ! here since they are not AD'ed. 
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables
   INTEGER(kind=inttype) :: istart, iend, jstart, jend
   ! Determine the sizes of each face and point to just the range we
   ! need on each face. 
   istart = bcdata(nn)%icbeg
   iend = bcdata(nn)%icend
   jstart = bcdata(nn)%jcbeg
   jend = bcdata(nn)%jcend
   ! Set the size of the subface
   isize = iend - istart + 1
   jsize = jend - jstart + 1
   ! Determine the face id on which the subface is located and set
   ! the pointers accordinly.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   !===============================================================
   ww3(1:isize, 1:jsize, :) = w(3, istart:iend, jstart:jend, :)
   ww2(1:isize, 1:jsize, :) = w(2, istart:iend, jstart:jend, :)
   ww1(1:isize, 1:jsize, :) = w(1, istart:iend, jstart:jend, :)
   ww0(1:isize, 1:jsize, :) = w(0, istart:iend, jstart:jend, :)
   pp3(1:isize, 1:jsize) = p(3, istart:iend, jstart:jend)
   pp2(1:isize, 1:jsize) = p(2, istart:iend, jstart:jend)
   pp1(1:isize, 1:jsize) = p(1, istart:iend, jstart:jend)
   pp0(1:isize, 1:jsize) = p(0, istart:iend, jstart:jend)
   rlv3(1:isize, 1:jsize) = rlv(3, istart:iend, jstart:jend)
   rlv2(1:isize, 1:jsize) = rlv(2, istart:iend, jstart:jend)
   rlv1(1:isize, 1:jsize) = rlv(1, istart:iend, jstart:jend)
   rlv0(1:isize, 1:jsize) = rlv(0, istart:iend, jstart:jend)
   rev3(1:isize, 1:jsize) = rev(3, istart:iend, jstart:jend)
   rev2(1:isize, 1:jsize) = rev(2, istart:iend, jstart:jend)
   rev1(1:isize, 1:jsize) = rev(1, istart:iend, jstart:jend)
   rev0(1:isize, 1:jsize) = rev(0, istart:iend, jstart:jend)
   gamma3(1:isize, 1:jsize) = gamma(3, istart:iend, jstart:jend)
   gamma2(1:isize, 1:jsize) = gamma(2, istart:iend, jstart:jend)
   gamma1(1:isize, 1:jsize) = gamma(1, istart:iend, jstart:jend)
   gamma0(1:isize, 1:jsize) = gamma(0, istart:iend, jstart:jend)
   CASE (imax) 
   !===============================================================
   ww3(1:isize, 1:jsize, :) = w(nx, istart:iend, jstart:jend, :)
   ww2(1:isize, 1:jsize, :) = w(il, istart:iend, jstart:jend, :)
   ww1(1:isize, 1:jsize, :) = w(ie, istart:iend, jstart:jend, :)
   ww0(1:isize, 1:jsize, :) = w(ib, istart:iend, jstart:jend, :)
   pp3(1:isize, 1:jsize) = p(nx, istart:iend, jstart:jend)
   pp2(1:isize, 1:jsize) = p(il, istart:iend, jstart:jend)
   pp1(1:isize, 1:jsize) = p(ie, istart:iend, jstart:jend)
   pp0(1:isize, 1:jsize) = p(ib, istart:iend, jstart:jend)
   rlv3(1:isize, 1:jsize) = rlv(nx, istart:iend, jstart:jend)
   rlv2(1:isize, 1:jsize) = rlv(il, istart:iend, jstart:jend)
   rlv1(1:isize, 1:jsize) = rlv(ie, istart:iend, jstart:jend)
   rlv0(1:isize, 1:jsize) = rlv(ib, istart:iend, jstart:jend)
   rev3(1:isize, 1:jsize) = rev(nx, istart:iend, jstart:jend)
   rev2(1:isize, 1:jsize) = rev(il, istart:iend, jstart:jend)
   rev1(1:isize, 1:jsize) = rev(ie, istart:iend, jstart:jend)
   rev0(1:isize, 1:jsize) = rev(ib, istart:iend, jstart:jend)
   gamma3(1:isize, 1:jsize) = gamma(nx, istart:iend, jstart:jend)
   gamma2(1:isize, 1:jsize) = gamma(il, istart:iend, jstart:jend)
   gamma1(1:isize, 1:jsize) = gamma(ie, istart:iend, jstart:jend)
   gamma0(1:isize, 1:jsize) = gamma(ib, istart:iend, jstart:jend)
   CASE (jmin) 
   !===============================================================
   ww3(1:isize, 1:jsize, :) = w(istart:iend, 3, jstart:jend, :)
   ww2(1:isize, 1:jsize, :) = w(istart:iend, 2, jstart:jend, :)
   ww1(1:isize, 1:jsize, :) = w(istart:iend, 1, jstart:jend, :)
   ww0(1:isize, 1:jsize, :) = w(istart:iend, 0, jstart:jend, :)
   pp3(1:isize, 1:jsize) = p(istart:iend, 3, jstart:jend)
   pp2(1:isize, 1:jsize) = p(istart:iend, 2, jstart:jend)
   pp1(1:isize, 1:jsize) = p(istart:iend, 1, jstart:jend)
   pp0(1:isize, 1:jsize) = p(istart:iend, 0, jstart:jend)
   rlv3(1:isize, 1:jsize) = rlv(istart:iend, 3, jstart:jend)
   rlv2(1:isize, 1:jsize) = rlv(istart:iend, 2, jstart:jend)
   rlv1(1:isize, 1:jsize) = rlv(istart:iend, 1, jstart:jend)
   rlv0(1:isize, 1:jsize) = rlv(istart:iend, 0, jstart:jend)
   rev3(1:isize, 1:jsize) = rev(istart:iend, 3, jstart:jend)
   rev2(1:isize, 1:jsize) = rev(istart:iend, 2, jstart:jend)
   rev1(1:isize, 1:jsize) = rev(istart:iend, 1, jstart:jend)
   rev0(1:isize, 1:jsize) = rev(istart:iend, 0, jstart:jend)
   gamma3(1:isize, 1:jsize) = gamma(istart:iend, 3, jstart:jend)
   gamma2(1:isize, 1:jsize) = gamma(istart:iend, 2, jstart:jend)
   gamma1(1:isize, 1:jsize) = gamma(istart:iend, 1, jstart:jend)
   gamma0(1:isize, 1:jsize) = gamma(istart:iend, 0, jstart:jend)
   CASE (jmax) 
   !===============================================================
   ww3(1:isize, 1:jsize, :) = w(istart:iend, ny, jstart:jend, :)
   ww2(1:isize, 1:jsize, :) = w(istart:iend, jl, jstart:jend, :)
   ww1(1:isize, 1:jsize, :) = w(istart:iend, je, jstart:jend, :)
   ww0(1:isize, 1:jsize, :) = w(istart:iend, jb, jstart:jend, :)
   pp3(1:isize, 1:jsize) = p(istart:iend, ny, jstart:jend)
   pp2(1:isize, 1:jsize) = p(istart:iend, jl, jstart:jend)
   pp1(1:isize, 1:jsize) = p(istart:iend, je, jstart:jend)
   pp0(1:isize, 1:jsize) = p(istart:iend, jb, jstart:jend)
   rlv3(1:isize, 1:jsize) = rlv(istart:iend, ny, jstart:jend)
   rlv2(1:isize, 1:jsize) = rlv(istart:iend, jl, jstart:jend)
   rlv1(1:isize, 1:jsize) = rlv(istart:iend, je, jstart:jend)
   rlv0(1:isize, 1:jsize) = rlv(istart:iend, jb, jstart:jend)
   rev3(1:isize, 1:jsize) = rev(istart:iend, ny, jstart:jend)
   rev2(1:isize, 1:jsize) = rev(istart:iend, jl, jstart:jend)
   rev1(1:isize, 1:jsize) = rev(istart:iend, je, jstart:jend)
   rev0(1:isize, 1:jsize) = rev(istart:iend, jb, jstart:jend)
   gamma3(1:isize, 1:jsize) = gamma(istart:iend, ny, jstart:jend)
   gamma2(1:isize, 1:jsize) = gamma(istart:iend, jl, jstart:jend)
   gamma1(1:isize, 1:jsize) = gamma(istart:iend, je, jstart:jend)
   gamma0(1:isize, 1:jsize) = gamma(istart:iend, jb, jstart:jend)
   CASE (kmin) 
   !===============================================================
   ww3(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, 3, :)
   ww2(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, 2, :)
   ww1(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, 1, :)
   ww0(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, 0, :)
   pp3(1:isize, 1:jsize) = p(istart:iend, jstart:jend, 3)
   pp2(1:isize, 1:jsize) = p(istart:iend, jstart:jend, 2)
   pp1(1:isize, 1:jsize) = p(istart:iend, jstart:jend, 1)
   pp0(1:isize, 1:jsize) = p(istart:iend, jstart:jend, 0)
   rlv3(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, 3)
   rlv2(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, 2)
   rlv1(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, 1)
   rlv0(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, 0)
   rev3(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, 3)
   rev2(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, 2)
   rev1(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, 1)
   rev0(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, 0)
   gamma3(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, 3)
   gamma2(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, 2)
   gamma1(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, 1)
   gamma0(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, 0)
   CASE (kmax) 
   !===============================================================
   ww3(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, nz, :)
   ww2(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, kl, :)
   ww1(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, ke, :)
   ww0(1:isize, 1:jsize, :) = w(istart:iend, jstart:jend, kb, :)
   pp3(1:isize, 1:jsize) = p(istart:iend, jstart:jend, nz)
   pp2(1:isize, 1:jsize) = p(istart:iend, jstart:jend, kl)
   pp1(1:isize, 1:jsize) = p(istart:iend, jstart:jend, ke)
   pp0(1:isize, 1:jsize) = p(istart:iend, jstart:jend, kb)
   rlv3(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, nz)
   rlv2(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, kl)
   rlv1(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, ke)
   rlv0(1:isize, 1:jsize) = rlv(istart:iend, jstart:jend, kb)
   rev3(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, nz)
   rev2(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, kl)
   rev1(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, ke)
   rev0(1:isize, 1:jsize) = rev(istart:iend, jstart:jend, kb)
   gamma3(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, nz)
   gamma2(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, kl)
   gamma1(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, ke)
   gamma0(1:isize, 1:jsize) = gamma(istart:iend, jstart:jend, kb)
   END SELECT
   END SUBROUTINE SETBCPOINTERS2
   !  Differentiation of resetbcpointers2 in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *p *w *rlv *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   with respect to varying inputs: *rev *p *w *rlv *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   Plus diff mem management of: rev:in p:in w:in rlv:in bcdata:in
   !                rev0:in rev1:in rev2:in rev3:in pp0:in pp1:in
   !                pp2:in pp3:in rlv0:in rlv1:in rlv2:in rlv3:in
   !                ww0:in ww1:in ww2:in ww3:in
   SUBROUTINE RESETBCPOINTERS2_B(nn)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * resetBCPointers nullifyies the boundary pointers. For reverse  *
   !      * mode AD it copies the values back in to the respective arrays  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Note that the ss{i,j,}, ss and xline pointers are NOT included
   ! here since they are not AD'ed. 
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables
   INTEGER(kind=inttype) :: istart, iend, jstart, jend
   ! Determine the face id on which the subface is located and set
   ! the pointers accordinly.
   istart = bcdata(nn)%icbeg
   iend = bcdata(nn)%icend
   jstart = bcdata(nn)%jcbeg
   jend = bcdata(nn)%jcend
   ! Set the size of the subface
   CALL PUSHINTEGER4(isize)
   isize = iend - istart + 1
   CALL PUSHINTEGER4(jsize)
   jsize = jend - jstart + 1
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   rev0d(1:isize, 1:jsize) = rev0d(1:isize, 1:jsize) + revd(0, istart&
   &       :iend, jstart:jend)
   revd(0, istart:iend, jstart:jend) = 0.0_8
   rev1d(1:isize, 1:jsize) = rev1d(1:isize, 1:jsize) + revd(1, istart&
   &       :iend, jstart:jend)
   revd(1, istart:iend, jstart:jend) = 0.0_8
   rev2d(1:isize, 1:jsize) = rev2d(1:isize, 1:jsize) + revd(2, istart&
   &       :iend, jstart:jend)
   revd(2, istart:iend, jstart:jend) = 0.0_8
   rev3d(1:isize, 1:jsize) = rev3d(1:isize, 1:jsize) + revd(3, istart&
   &       :iend, jstart:jend)
   revd(3, istart:iend, jstart:jend) = 0.0_8
   rlv0d(1:isize, 1:jsize) = rlv0d(1:isize, 1:jsize) + rlvd(0, istart&
   &       :iend, jstart:jend)
   rlvd(0, istart:iend, jstart:jend) = 0.0_8
   rlv1d(1:isize, 1:jsize) = rlv1d(1:isize, 1:jsize) + rlvd(1, istart&
   &       :iend, jstart:jend)
   rlvd(1, istart:iend, jstart:jend) = 0.0_8
   rlv2d(1:isize, 1:jsize) = rlv2d(1:isize, 1:jsize) + rlvd(2, istart&
   &       :iend, jstart:jend)
   rlvd(2, istart:iend, jstart:jend) = 0.0_8
   rlv3d(1:isize, 1:jsize) = rlv3d(1:isize, 1:jsize) + rlvd(3, istart&
   &       :iend, jstart:jend)
   rlvd(3, istart:iend, jstart:jend) = 0.0_8
   pp0d(1:isize, 1:jsize) = pp0d(1:isize, 1:jsize) + pd(0, istart:&
   &       iend, jstart:jend)
   pd(0, istart:iend, jstart:jend) = 0.0_8
   pp1d(1:isize, 1:jsize) = pp1d(1:isize, 1:jsize) + pd(1, istart:&
   &       iend, jstart:jend)
   pd(1, istart:iend, jstart:jend) = 0.0_8
   pp2d(1:isize, 1:jsize) = pp2d(1:isize, 1:jsize) + pd(2, istart:&
   &       iend, jstart:jend)
   pd(2, istart:iend, jstart:jend) = 0.0_8
   pp3d(1:isize, 1:jsize) = pp3d(1:isize, 1:jsize) + pd(3, istart:&
   &       iend, jstart:jend)
   pd(3, istart:iend, jstart:jend) = 0.0_8
   ww0d(1:isize, 1:jsize, :) = ww0d(1:isize, 1:jsize, :) + wd(0, &
   &       istart:iend, jstart:jend, :)
   wd(0, istart:iend, jstart:jend, :) = 0.0_8
   ww1d(1:isize, 1:jsize, :) = ww1d(1:isize, 1:jsize, :) + wd(1, &
   &       istart:iend, jstart:jend, :)
   wd(1, istart:iend, jstart:jend, :) = 0.0_8
   ww2d(1:isize, 1:jsize, :) = ww2d(1:isize, 1:jsize, :) + wd(2, &
   &       istart:iend, jstart:jend, :)
   wd(2, istart:iend, jstart:jend, :) = 0.0_8
   ww3d(1:isize, 1:jsize, :) = ww3d(1:isize, 1:jsize, :) + wd(3, &
   &       istart:iend, jstart:jend, :)
   wd(3, istart:iend, jstart:jend, :) = 0.0_8
   CASE (imax) 
   rev0d(1:isize, 1:jsize) = rev0d(1:isize, 1:jsize) + revd(ib, &
   &       istart:iend, jstart:jend)
   revd(ib, istart:iend, jstart:jend) = 0.0_8
   rev1d(1:isize, 1:jsize) = rev1d(1:isize, 1:jsize) + revd(ie, &
   &       istart:iend, jstart:jend)
   revd(ie, istart:iend, jstart:jend) = 0.0_8
   rev2d(1:isize, 1:jsize) = rev2d(1:isize, 1:jsize) + revd(il, &
   &       istart:iend, jstart:jend)
   revd(il, istart:iend, jstart:jend) = 0.0_8
   rev3d(1:isize, 1:jsize) = rev3d(1:isize, 1:jsize) + revd(nx, &
   &       istart:iend, jstart:jend)
   revd(nx, istart:iend, jstart:jend) = 0.0_8
   rlv0d(1:isize, 1:jsize) = rlv0d(1:isize, 1:jsize) + rlvd(ib, &
   &       istart:iend, jstart:jend)
   rlvd(ib, istart:iend, jstart:jend) = 0.0_8
   rlv1d(1:isize, 1:jsize) = rlv1d(1:isize, 1:jsize) + rlvd(ie, &
   &       istart:iend, jstart:jend)
   rlvd(ie, istart:iend, jstart:jend) = 0.0_8
   rlv2d(1:isize, 1:jsize) = rlv2d(1:isize, 1:jsize) + rlvd(il, &
   &       istart:iend, jstart:jend)
   rlvd(il, istart:iend, jstart:jend) = 0.0_8
   rlv3d(1:isize, 1:jsize) = rlv3d(1:isize, 1:jsize) + rlvd(nx, &
   &       istart:iend, jstart:jend)
   rlvd(nx, istart:iend, jstart:jend) = 0.0_8
   pp0d(1:isize, 1:jsize) = pp0d(1:isize, 1:jsize) + pd(ib, istart:&
   &       iend, jstart:jend)
   pd(ib, istart:iend, jstart:jend) = 0.0_8
   pp1d(1:isize, 1:jsize) = pp1d(1:isize, 1:jsize) + pd(ie, istart:&
   &       iend, jstart:jend)
   pd(ie, istart:iend, jstart:jend) = 0.0_8
   pp2d(1:isize, 1:jsize) = pp2d(1:isize, 1:jsize) + pd(il, istart:&
   &       iend, jstart:jend)
   pd(il, istart:iend, jstart:jend) = 0.0_8
   pp3d(1:isize, 1:jsize) = pp3d(1:isize, 1:jsize) + pd(nx, istart:&
   &       iend, jstart:jend)
   pd(nx, istart:iend, jstart:jend) = 0.0_8
   ww0d(1:isize, 1:jsize, :) = ww0d(1:isize, 1:jsize, :) + wd(ib, &
   &       istart:iend, jstart:jend, :)
   wd(ib, istart:iend, jstart:jend, :) = 0.0_8
   ww1d(1:isize, 1:jsize, :) = ww1d(1:isize, 1:jsize, :) + wd(ie, &
   &       istart:iend, jstart:jend, :)
   wd(ie, istart:iend, jstart:jend, :) = 0.0_8
   ww2d(1:isize, 1:jsize, :) = ww2d(1:isize, 1:jsize, :) + wd(il, &
   &       istart:iend, jstart:jend, :)
   wd(il, istart:iend, jstart:jend, :) = 0.0_8
   ww3d(1:isize, 1:jsize, :) = ww3d(1:isize, 1:jsize, :) + wd(nx, &
   &       istart:iend, jstart:jend, :)
   wd(nx, istart:iend, jstart:jend, :) = 0.0_8
   CASE (jmin) 
   rev0d(1:isize, 1:jsize) = rev0d(1:isize, 1:jsize) + revd(istart:&
   &       iend, 0, jstart:jend)
   revd(istart:iend, 0, jstart:jend) = 0.0_8
   rev1d(1:isize, 1:jsize) = rev1d(1:isize, 1:jsize) + revd(istart:&
   &       iend, 1, jstart:jend)
   revd(istart:iend, 1, jstart:jend) = 0.0_8
   rev2d(1:isize, 1:jsize) = rev2d(1:isize, 1:jsize) + revd(istart:&
   &       iend, 2, jstart:jend)
   revd(istart:iend, 2, jstart:jend) = 0.0_8
   rev3d(1:isize, 1:jsize) = rev3d(1:isize, 1:jsize) + revd(istart:&
   &       iend, 3, jstart:jend)
   revd(istart:iend, 3, jstart:jend) = 0.0_8
   rlv0d(1:isize, 1:jsize) = rlv0d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, 0, jstart:jend)
   rlvd(istart:iend, 0, jstart:jend) = 0.0_8
   rlv1d(1:isize, 1:jsize) = rlv1d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, 1, jstart:jend)
   rlvd(istart:iend, 1, jstart:jend) = 0.0_8
   rlv2d(1:isize, 1:jsize) = rlv2d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, 2, jstart:jend)
   rlvd(istart:iend, 2, jstart:jend) = 0.0_8
   rlv3d(1:isize, 1:jsize) = rlv3d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, 3, jstart:jend)
   rlvd(istart:iend, 3, jstart:jend) = 0.0_8
   pp0d(1:isize, 1:jsize) = pp0d(1:isize, 1:jsize) + pd(istart:iend, &
   &       0, jstart:jend)
   pd(istart:iend, 0, jstart:jend) = 0.0_8
   pp1d(1:isize, 1:jsize) = pp1d(1:isize, 1:jsize) + pd(istart:iend, &
   &       1, jstart:jend)
   pd(istart:iend, 1, jstart:jend) = 0.0_8
   pp2d(1:isize, 1:jsize) = pp2d(1:isize, 1:jsize) + pd(istart:iend, &
   &       2, jstart:jend)
   pd(istart:iend, 2, jstart:jend) = 0.0_8
   pp3d(1:isize, 1:jsize) = pp3d(1:isize, 1:jsize) + pd(istart:iend, &
   &       3, jstart:jend)
   pd(istart:iend, 3, jstart:jend) = 0.0_8
   ww0d(1:isize, 1:jsize, :) = ww0d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, 0, jstart:jend, :)
   wd(istart:iend, 0, jstart:jend, :) = 0.0_8
   ww1d(1:isize, 1:jsize, :) = ww1d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, 1, jstart:jend, :)
   wd(istart:iend, 1, jstart:jend, :) = 0.0_8
   ww2d(1:isize, 1:jsize, :) = ww2d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, 2, jstart:jend, :)
   wd(istart:iend, 2, jstart:jend, :) = 0.0_8
   ww3d(1:isize, 1:jsize, :) = ww3d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, 3, jstart:jend, :)
   wd(istart:iend, 3, jstart:jend, :) = 0.0_8
   CASE (jmax) 
   rev0d(1:isize, 1:jsize) = rev0d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jb, jstart:jend)
   revd(istart:iend, jb, jstart:jend) = 0.0_8
   rev1d(1:isize, 1:jsize) = rev1d(1:isize, 1:jsize) + revd(istart:&
   &       iend, je, jstart:jend)
   revd(istart:iend, je, jstart:jend) = 0.0_8
   rev2d(1:isize, 1:jsize) = rev2d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jl, jstart:jend)
   revd(istart:iend, jl, jstart:jend) = 0.0_8
   rev3d(1:isize, 1:jsize) = rev3d(1:isize, 1:jsize) + revd(istart:&
   &       iend, ny, jstart:jend)
   revd(istart:iend, ny, jstart:jend) = 0.0_8
   rlv0d(1:isize, 1:jsize) = rlv0d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jb, jstart:jend)
   rlvd(istart:iend, jb, jstart:jend) = 0.0_8
   rlv1d(1:isize, 1:jsize) = rlv1d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, je, jstart:jend)
   rlvd(istart:iend, je, jstart:jend) = 0.0_8
   rlv2d(1:isize, 1:jsize) = rlv2d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jl, jstart:jend)
   rlvd(istart:iend, jl, jstart:jend) = 0.0_8
   rlv3d(1:isize, 1:jsize) = rlv3d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, ny, jstart:jend)
   rlvd(istart:iend, ny, jstart:jend) = 0.0_8
   pp0d(1:isize, 1:jsize) = pp0d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jb, jstart:jend)
   pd(istart:iend, jb, jstart:jend) = 0.0_8
   pp1d(1:isize, 1:jsize) = pp1d(1:isize, 1:jsize) + pd(istart:iend, &
   &       je, jstart:jend)
   pd(istart:iend, je, jstart:jend) = 0.0_8
   pp2d(1:isize, 1:jsize) = pp2d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jl, jstart:jend)
   pd(istart:iend, jl, jstart:jend) = 0.0_8
   pp3d(1:isize, 1:jsize) = pp3d(1:isize, 1:jsize) + pd(istart:iend, &
   &       ny, jstart:jend)
   pd(istart:iend, ny, jstart:jend) = 0.0_8
   ww0d(1:isize, 1:jsize, :) = ww0d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jb, jstart:jend, :)
   wd(istart:iend, jb, jstart:jend, :) = 0.0_8
   ww1d(1:isize, 1:jsize, :) = ww1d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, je, jstart:jend, :)
   wd(istart:iend, je, jstart:jend, :) = 0.0_8
   ww2d(1:isize, 1:jsize, :) = ww2d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jl, jstart:jend, :)
   wd(istart:iend, jl, jstart:jend, :) = 0.0_8
   ww3d(1:isize, 1:jsize, :) = ww3d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, ny, jstart:jend, :)
   wd(istart:iend, ny, jstart:jend, :) = 0.0_8
   CASE (kmin) 
   rev0d(1:isize, 1:jsize) = rev0d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, 0)
   revd(istart:iend, jstart:jend, 0) = 0.0_8
   rev1d(1:isize, 1:jsize) = rev1d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, 1)
   revd(istart:iend, jstart:jend, 1) = 0.0_8
   rev2d(1:isize, 1:jsize) = rev2d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, 2)
   revd(istart:iend, jstart:jend, 2) = 0.0_8
   rev3d(1:isize, 1:jsize) = rev3d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, 3)
   revd(istart:iend, jstart:jend, 3) = 0.0_8
   rlv0d(1:isize, 1:jsize) = rlv0d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, 0)
   rlvd(istart:iend, jstart:jend, 0) = 0.0_8
   rlv1d(1:isize, 1:jsize) = rlv1d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, 1)
   rlvd(istart:iend, jstart:jend, 1) = 0.0_8
   rlv2d(1:isize, 1:jsize) = rlv2d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, 2)
   rlvd(istart:iend, jstart:jend, 2) = 0.0_8
   rlv3d(1:isize, 1:jsize) = rlv3d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, 3)
   rlvd(istart:iend, jstart:jend, 3) = 0.0_8
   pp0d(1:isize, 1:jsize) = pp0d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, 0)
   pd(istart:iend, jstart:jend, 0) = 0.0_8
   pp1d(1:isize, 1:jsize) = pp1d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, 1)
   pd(istart:iend, jstart:jend, 1) = 0.0_8
   pp2d(1:isize, 1:jsize) = pp2d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, 2)
   pd(istart:iend, jstart:jend, 2) = 0.0_8
   pp3d(1:isize, 1:jsize) = pp3d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, 3)
   pd(istart:iend, jstart:jend, 3) = 0.0_8
   ww0d(1:isize, 1:jsize, :) = ww0d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, 0, :)
   wd(istart:iend, jstart:jend, 0, :) = 0.0_8
   ww1d(1:isize, 1:jsize, :) = ww1d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, 1, :)
   wd(istart:iend, jstart:jend, 1, :) = 0.0_8
   ww2d(1:isize, 1:jsize, :) = ww2d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, 2, :)
   wd(istart:iend, jstart:jend, 2, :) = 0.0_8
   ww3d(1:isize, 1:jsize, :) = ww3d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, 3, :)
   wd(istart:iend, jstart:jend, 3, :) = 0.0_8
   CASE (kmax) 
   rev0d(1:isize, 1:jsize) = rev0d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, kb)
   revd(istart:iend, jstart:jend, kb) = 0.0_8
   rev1d(1:isize, 1:jsize) = rev1d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, ke)
   revd(istart:iend, jstart:jend, ke) = 0.0_8
   rev2d(1:isize, 1:jsize) = rev2d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, kl)
   revd(istart:iend, jstart:jend, kl) = 0.0_8
   rev3d(1:isize, 1:jsize) = rev3d(1:isize, 1:jsize) + revd(istart:&
   &       iend, jstart:jend, nz)
   revd(istart:iend, jstart:jend, nz) = 0.0_8
   rlv0d(1:isize, 1:jsize) = rlv0d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, kb)
   rlvd(istart:iend, jstart:jend, kb) = 0.0_8
   rlv1d(1:isize, 1:jsize) = rlv1d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, ke)
   rlvd(istart:iend, jstart:jend, ke) = 0.0_8
   rlv2d(1:isize, 1:jsize) = rlv2d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, kl)
   rlvd(istart:iend, jstart:jend, kl) = 0.0_8
   rlv3d(1:isize, 1:jsize) = rlv3d(1:isize, 1:jsize) + rlvd(istart:&
   &       iend, jstart:jend, nz)
   rlvd(istart:iend, jstart:jend, nz) = 0.0_8
   pp0d(1:isize, 1:jsize) = pp0d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, kb)
   pd(istart:iend, jstart:jend, kb) = 0.0_8
   pp1d(1:isize, 1:jsize) = pp1d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, ke)
   pd(istart:iend, jstart:jend, ke) = 0.0_8
   pp2d(1:isize, 1:jsize) = pp2d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, kl)
   pd(istart:iend, jstart:jend, kl) = 0.0_8
   pp3d(1:isize, 1:jsize) = pp3d(1:isize, 1:jsize) + pd(istart:iend, &
   &       jstart:jend, nz)
   pd(istart:iend, jstart:jend, nz) = 0.0_8
   ww0d(1:isize, 1:jsize, :) = ww0d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, kb, :)
   wd(istart:iend, jstart:jend, kb, :) = 0.0_8
   ww1d(1:isize, 1:jsize, :) = ww1d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, ke, :)
   wd(istart:iend, jstart:jend, ke, :) = 0.0_8
   ww2d(1:isize, 1:jsize, :) = ww2d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, kl, :)
   wd(istart:iend, jstart:jend, kl, :) = 0.0_8
   ww3d(1:isize, 1:jsize, :) = ww3d(1:isize, 1:jsize, :) + wd(istart:&
   &       iend, jstart:jend, nz, :)
   wd(istart:iend, jstart:jend, nz, :) = 0.0_8
   END SELECT
   CALL POPINTEGER4(jsize)
   CALL POPINTEGER4(isize)
   END SUBROUTINE RESETBCPOINTERS2_B
   SUBROUTINE RESETBCPOINTERS2(nn)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * resetBCPointers nullifyies the boundary pointers. For reverse  *
   !      * mode AD it copies the values back in to the respective arrays  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Note that the ss{i,j,}, ss and xline pointers are NOT included
   ! here since they are not AD'ed. 
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables
   INTEGER(kind=inttype) :: istart, iend, jstart, jend
   ! Determine the face id on which the subface is located and set
   ! the pointers accordinly.
   istart = bcdata(nn)%icbeg
   iend = bcdata(nn)%icend
   jstart = bcdata(nn)%jcbeg
   jend = bcdata(nn)%jcend
   ! Set the size of the subface
   isize = iend - istart + 1
   jsize = jend - jstart + 1
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   !===============================================================
   w(3, istart:iend, jstart:jend, :) = ww3(1:isize, 1:jsize, :)
   w(2, istart:iend, jstart:jend, :) = ww2(1:isize, 1:jsize, :)
   w(1, istart:iend, jstart:jend, :) = ww1(1:isize, 1:jsize, :)
   w(0, istart:iend, jstart:jend, :) = ww0(1:isize, 1:jsize, :)
   p(3, istart:iend, jstart:jend) = pp3(1:isize, 1:jsize)
   p(2, istart:iend, jstart:jend) = pp2(1:isize, 1:jsize)
   p(1, istart:iend, jstart:jend) = pp1(1:isize, 1:jsize)
   p(0, istart:iend, jstart:jend) = pp0(1:isize, 1:jsize)
   rlv(3, istart:iend, jstart:jend) = rlv3(1:isize, 1:jsize)
   rlv(2, istart:iend, jstart:jend) = rlv2(1:isize, 1:jsize)
   rlv(1, istart:iend, jstart:jend) = rlv1(1:isize, 1:jsize)
   rlv(0, istart:iend, jstart:jend) = rlv0(1:isize, 1:jsize)
   rev(3, istart:iend, jstart:jend) = rev3(1:isize, 1:jsize)
   rev(2, istart:iend, jstart:jend) = rev2(1:isize, 1:jsize)
   rev(1, istart:iend, jstart:jend) = rev1(1:isize, 1:jsize)
   rev(0, istart:iend, jstart:jend) = rev0(1:isize, 1:jsize)
   gamma(3, istart:iend, jstart:jend) = gamma3(1:isize, 1:jsize)
   gamma(2, istart:iend, jstart:jend) = gamma2(1:isize, 1:jsize)
   gamma(1, istart:iend, jstart:jend) = gamma1(1:isize, 1:jsize)
   gamma(0, istart:iend, jstart:jend) = gamma0(1:isize, 1:jsize)
   CASE (imax) 
   !===============================================================
   w(nx, istart:iend, jstart:jend, :) = ww3(1:isize, 1:jsize, :)
   w(il, istart:iend, jstart:jend, :) = ww2(1:isize, 1:jsize, :)
   w(ie, istart:iend, jstart:jend, :) = ww1(1:isize, 1:jsize, :)
   w(ib, istart:iend, jstart:jend, :) = ww0(1:isize, 1:jsize, :)
   p(nx, istart:iend, jstart:jend) = pp3(1:isize, 1:jsize)
   p(il, istart:iend, jstart:jend) = pp2(1:isize, 1:jsize)
   p(ie, istart:iend, jstart:jend) = pp1(1:isize, 1:jsize)
   p(ib, istart:iend, jstart:jend) = pp0(1:isize, 1:jsize)
   rlv(nx, istart:iend, jstart:jend) = rlv3(1:isize, 1:jsize)
   rlv(il, istart:iend, jstart:jend) = rlv2(1:isize, 1:jsize)
   rlv(ie, istart:iend, jstart:jend) = rlv1(1:isize, 1:jsize)
   rlv(ib, istart:iend, jstart:jend) = rlv0(1:isize, 1:jsize)
   rev(nx, istart:iend, jstart:jend) = rev3(1:isize, 1:jsize)
   rev(il, istart:iend, jstart:jend) = rev2(1:isize, 1:jsize)
   rev(ie, istart:iend, jstart:jend) = rev1(1:isize, 1:jsize)
   rev(ib, istart:iend, jstart:jend) = rev0(1:isize, 1:jsize)
   gamma(nx, istart:iend, jstart:jend) = gamma3(1:isize, 1:jsize)
   gamma(il, istart:iend, jstart:jend) = gamma2(1:isize, 1:jsize)
   gamma(ie, istart:iend, jstart:jend) = gamma1(1:isize, 1:jsize)
   gamma(ib, istart:iend, jstart:jend) = gamma0(1:isize, 1:jsize)
   CASE (jmin) 
   !===============================================================
   w(istart:iend, 3, jstart:jend, :) = ww3(1:isize, 1:jsize, :)
   w(istart:iend, 2, jstart:jend, :) = ww2(1:isize, 1:jsize, :)
   w(istart:iend, 1, jstart:jend, :) = ww1(1:isize, 1:jsize, :)
   w(istart:iend, 0, jstart:jend, :) = ww0(1:isize, 1:jsize, :)
   p(istart:iend, 3, jstart:jend) = pp3(1:isize, 1:jsize)
   p(istart:iend, 2, jstart:jend) = pp2(1:isize, 1:jsize)
   p(istart:iend, 1, jstart:jend) = pp1(1:isize, 1:jsize)
   p(istart:iend, 0, jstart:jend) = pp0(1:isize, 1:jsize)
   rlv(istart:iend, 3, jstart:jend) = rlv3(1:isize, 1:jsize)
   rlv(istart:iend, 2, jstart:jend) = rlv2(1:isize, 1:jsize)
   rlv(istart:iend, 1, jstart:jend) = rlv1(1:isize, 1:jsize)
   rlv(istart:iend, 0, jstart:jend) = rlv0(1:isize, 1:jsize)
   rev(istart:iend, 3, jstart:jend) = rev3(1:isize, 1:jsize)
   rev(istart:iend, 2, jstart:jend) = rev2(1:isize, 1:jsize)
   rev(istart:iend, 1, jstart:jend) = rev1(1:isize, 1:jsize)
   rev(istart:iend, 0, jstart:jend) = rev0(1:isize, 1:jsize)
   gamma(istart:iend, 3, jstart:jend) = gamma3(1:isize, 1:jsize)
   gamma(istart:iend, 2, jstart:jend) = gamma2(1:isize, 1:jsize)
   gamma(istart:iend, 1, jstart:jend) = gamma1(1:isize, 1:jsize)
   gamma(istart:iend, 0, jstart:jend) = gamma0(1:isize, 1:jsize)
   CASE (jmax) 
   !===============================================================
   w(istart:iend, ny, jstart:jend, :) = ww3(1:isize, 1:jsize, :)
   w(istart:iend, jl, jstart:jend, :) = ww2(1:isize, 1:jsize, :)
   w(istart:iend, je, jstart:jend, :) = ww1(1:isize, 1:jsize, :)
   w(istart:iend, jb, jstart:jend, :) = ww0(1:isize, 1:jsize, :)
   p(istart:iend, ny, jstart:jend) = pp3(1:isize, 1:jsize)
   p(istart:iend, jl, jstart:jend) = pp2(1:isize, 1:jsize)
   p(istart:iend, je, jstart:jend) = pp1(1:isize, 1:jsize)
   p(istart:iend, jb, jstart:jend) = pp0(1:isize, 1:jsize)
   rlv(istart:iend, ny, jstart:jend) = rlv3(1:isize, 1:jsize)
   rlv(istart:iend, jl, jstart:jend) = rlv2(1:isize, 1:jsize)
   rlv(istart:iend, je, jstart:jend) = rlv1(1:isize, 1:jsize)
   rlv(istart:iend, jb, jstart:jend) = rlv0(1:isize, 1:jsize)
   rev(istart:iend, ny, jstart:jend) = rev3(1:isize, 1:jsize)
   rev(istart:iend, jl, jstart:jend) = rev2(1:isize, 1:jsize)
   rev(istart:iend, je, jstart:jend) = rev1(1:isize, 1:jsize)
   rev(istart:iend, jb, jstart:jend) = rev0(1:isize, 1:jsize)
   gamma(istart:iend, ny, jstart:jend) = gamma3(1:isize, 1:jsize)
   gamma(istart:iend, jl, jstart:jend) = gamma2(1:isize, 1:jsize)
   gamma(istart:iend, je, jstart:jend) = gamma1(1:isize, 1:jsize)
   gamma(istart:iend, jb, jstart:jend) = gamma0(1:isize, 1:jsize)
   CASE (kmin) 
   !===============================================================
   w(istart:iend, jstart:jend, 3, :) = ww3(1:isize, 1:jsize, :)
   w(istart:iend, jstart:jend, 2, :) = ww2(1:isize, 1:jsize, :)
   w(istart:iend, jstart:jend, 1, :) = ww1(1:isize, 1:jsize, :)
   w(istart:iend, jstart:jend, 0, :) = ww0(1:isize, 1:jsize, :)
   p(istart:iend, jstart:jend, 3) = pp3(1:isize, 1:jsize)
   p(istart:iend, jstart:jend, 2) = pp2(1:isize, 1:jsize)
   p(istart:iend, jstart:jend, 1) = pp1(1:isize, 1:jsize)
   p(istart:iend, jstart:jend, 0) = pp0(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, 3) = rlv3(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, 2) = rlv2(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, 1) = rlv1(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, 0) = rlv0(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, 3) = rev3(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, 2) = rev2(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, 1) = rev1(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, 0) = rev0(1:isize, 1:jsize)
   gamma(istart:iend, jstart:jend, 3) = gamma3(1:isize, 1:jsize)
   gamma(istart:iend, jstart:jend, 2) = gamma2(1:isize, 1:jsize)
   gamma(istart:iend, jstart:jend, 1) = gamma1(1:isize, 1:jsize)
   gamma(istart:iend, jstart:jend, 0) = gamma0(1:isize, 1:jsize)
   CASE (kmax) 
   !===============================================================
   w(istart:iend, jstart:jend, nz, :) = ww3(1:isize, 1:jsize, :)
   w(istart:iend, jstart:jend, kl, :) = ww2(1:isize, 1:jsize, :)
   w(istart:iend, jstart:jend, ke, :) = ww1(1:isize, 1:jsize, :)
   w(istart:iend, jstart:jend, kb, :) = ww0(1:isize, 1:jsize, :)
   p(istart:iend, jstart:jend, nz) = pp3(1:isize, 1:jsize)
   p(istart:iend, jstart:jend, kl) = pp2(1:isize, 1:jsize)
   p(istart:iend, jstart:jend, ke) = pp1(1:isize, 1:jsize)
   p(istart:iend, jstart:jend, kb) = pp0(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, nz) = rlv3(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, kl) = rlv2(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, ke) = rlv1(1:isize, 1:jsize)
   rlv(istart:iend, jstart:jend, kb) = rlv0(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, nz) = rev3(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, kl) = rev2(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, ke) = rev1(1:isize, 1:jsize)
   rev(istart:iend, jstart:jend, kb) = rev0(1:isize, 1:jsize)
   END SELECT
   END SUBROUTINE RESETBCPOINTERS2
   END MODULE BCROUTINES_B

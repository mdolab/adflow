   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          BCRoutines.F90                                   *
   !      * Author:        Gaetan K. W. Kenway                             *
   !      * Starting date: 01-23-2015                                      *
   !      * Last modified: 01-23-2015                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   !      ******************************************************************
   !      *                                                                *
   !      * This module contains data structures *and* routines used       *
   !      * for applying *all* boundary conditions for Navier Stokes part  *
   !      * of the code. The reason for using a module to contain the      *
   !      * routines is that due to the use of pointers, it eliminates the *
   !      * need for using interfaces. All former bc*.f90 routines are now *
   !      * included in this module.                                       *
   !      *                                                                *
   !      ******************************************************************
   !
   MODULE BCROUTINES_B
   USE CONSTANTS
   IMPLICIT NONE
   SAVE 
   REAL(kind=realtype), DIMENSION(:, :, :), ALLOCATABLE :: ww0, ww1, ww2&
   & , ww3
   REAL(kind=realtype), DIMENSION(:, :, :), ALLOCATABLE :: ww0d, ww1d, &
   & ww2d, ww3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: pp0, pp1, pp2, &
   & pp3
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: pp0d, pp1d, pp2d&
   & , pp3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rlv0, rlv1, rlv2&
   & , rlv3
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rlv0d, rlv1d, &
   & rlv2d, rlv3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rev0, rev1, rev2&
   & , rev3
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: rev0d, rev1d, &
   & rev2d, rev3d
   REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: gamma0, gamma1, &
   & gamma2, gamma3
   REAL(kind=realtype), DIMENSION(:, :, :), ALLOCATABLE :: ssi, xx
   REAL(kind=realtype), DIMENSION(:, :, :), ALLOCATABLE :: ssid, xxd
   INTEGER(kind=inttype) :: istart, iend, isize
   INTEGER(kind=inttype) :: jstart, jend, jsize
      CONTAINS
   !  Differentiation of applyallbc_block in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: gammainf winf pinfcorr rgas
   !                *rev *p *w *rlv *x *si *sj *sk *xx *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ssi *ww0 *ww1 *ww2 *ww3
   !   with respect to varying inputs: gammainf winf pinfcorr rgas
   !                *rev *p *w *rlv *x *si *sj *sk *(*bcdata.norm)
   !                *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2 *pp3
   !                *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2 *ww3
   !   Plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
   !                sj:in sk:in bcdata:in *bcdata.norm:in xx:in rev0:in
   !                rev1:in rev2:in rev3:in pp0:in pp1:in pp2:in pp3:in
   !                rlv0:in rlv1:in rlv2:in rlv3:in ssi:in ww0:in
   !                ww1:in ww2:in ww3:in
   SUBROUTINE APPLYALLBC_BLOCK_B(secondhalo)
   ! Apply BC's for a single block
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTTIMESPECTRAL
   USE ITERATION
   USE BCTYPES
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   ! Local variables.
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: nn
   INTEGER :: ii1
   !
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL PUSHREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk&
   &                 , 4))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   ! Apply all the boundary conditions. The order is important!  Only
   ! some of them have been AD'ed
   ! ------------------------------------
   !  Symmetry Boundary Condition 
   ! ------------------------------------
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. symm) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCSYMM(nn, secondhalo)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   CALL PUSHINTEGER4(jstart)
   CALL PUSHINTEGER4(isize)
   CALL PUSHINTEGER4(jsize)
   CALL PUSHINTEGER4(istart)
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL PUSHREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk&
   &                 , 4))
   CALL PUSHREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   ! ------------------------------------
   !  Adibatic Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswalladiabatic) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCNSWALLADIABATIC(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   CALL PUSHINTEGER4(jstart)
   CALL PUSHINTEGER4(isize)
   CALL PUSHINTEGER4(jsize)
   CALL PUSHINTEGER4(istart)
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL PUSHREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk&
   &                 , 4))
   CALL PUSHREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   ! ------------------------------------
   !  Isotermal Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCNSWALLISOTHERMAL(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   CALL PUSHINTEGER4(jstart)
   CALL PUSHINTEGER4(isize)
   CALL PUSHINTEGER4(jsize)
   CALL PUSHINTEGER4(istart)
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL PUSHREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma&
   &                 , 3))
   CALL PUSHREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL PUSHREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL PUSHREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL PUSHREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj&
   &                 , 4))
   CALL PUSHREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk&
   &                 , 4))
   CALL PUSHREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL PUSHREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. farfield) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCFARFIELD(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   CALL PUSHREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL PUSHINTEGER4(jstart)
   CALL PUSHREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL PUSHINTEGER4(isize)
   CALL PUSHINTEGER4(jsize)
   CALL PUSHINTEGER4(istart)
   CALL PUSHREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL PUSHREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   DO ii1=1,SIZE(bcdatad)
   bcdatad(ii1)%norm = 0.0_8
   END DO
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. eulerwall) THEN
   CALL SETBCPOINTERS(nn, .true.)
   CALL RESETBCPOINTERS_B(nn, .true.)
   CALL BCEULERWALL_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS_B(nn, .true.)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPINTEGER4(istart)
   CALL POPINTEGER4(jsize)
   CALL POPINTEGER4(isize)
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPINTEGER4(jstart)
   CALL POPREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL POPREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL POPREAL8ARRAY(gamma2, SIZE(gamma2, 1)*SIZE(gamma2, 2))
   CALL POPREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk, &
   &                4))
   CALL POPREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj, &
   &                4))
   CALL POPREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si, &
   &                4))
   CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL LOOKREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL LOOKREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. farfield) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL RESETBCPOINTERS_B(nn, .false.)
   CALL BCFARFIELD_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS_B(nn, .false.)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPINTEGER4(istart)
   CALL POPINTEGER4(jsize)
   CALL POPINTEGER4(isize)
   CALL POPINTEGER4(jstart)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL POPREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL POPREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk, &
   &                4))
   CALL POPREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj, &
   &                4))
   CALL POPREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si, &
   &                4))
   CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL LOOKREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL LOOKREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL RESETBCPOINTERS_B(nn, .false.)
   CALL BCNSWALLISOTHERMAL_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS_B(nn, .false.)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPINTEGER4(istart)
   CALL POPINTEGER4(jsize)
   CALL POPINTEGER4(isize)
   CALL POPINTEGER4(jstart)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   CALL POPREAL8ARRAY(pp2, SIZE(pp2, 1)*SIZE(pp2, 2))
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL POPREAL8ARRAY(pp0, SIZE(pp0, 1)*SIZE(pp0, 2))
   CALL POPREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk, &
   &                4))
   CALL POPREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj, &
   &                4))
   CALL POPREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si, &
   &                4))
   CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   CALL LOOKREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswalladiabatic) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL RESETBCPOINTERS_B(nn, .false.)
   CALL BCNSWALLADIABATIC_B(nn, secondhalo, correctfork)
   CALL SETBCPOINTERS_B(nn, .false.)
   END IF
   END DO
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPINTEGER4(istart)
   CALL POPINTEGER4(jsize)
   CALL POPINTEGER4(isize)
   CALL POPINTEGER4(jstart)
   CALL POPREAL8ARRAY(ww3, SIZE(ww3, 1)*SIZE(ww3, 2)*SIZE(ww3, 3))
   CALL POPREAL8ARRAY(ww2, SIZE(ww2, 1)*SIZE(ww2, 2)*SIZE(ww2, 3))
   CALL POPREAL8ARRAY(sk, SIZE(sk, 1)*SIZE(sk, 2)*SIZE(sk, 3)*SIZE(sk, &
   &                4))
   CALL POPREAL8ARRAY(sj, SIZE(sj, 1)*SIZE(sj, 2)*SIZE(sj, 3)*SIZE(sj, &
   &                4))
   CALL POPREAL8ARRAY(si, SIZE(si, 1)*SIZE(si, 2)*SIZE(si, 3)*SIZE(si, &
   &                4))
   CALL POPREAL8ARRAY(x, SIZE(x, 1)*SIZE(x, 2)*SIZE(x, 3)*SIZE(x, 4))
   CALL POPREAL8ARRAY(rlv, SIZE(rlv, 1)*SIZE(rlv, 2)*SIZE(rlv, 3))
   CALL POPREAL8ARRAY(w, SIZE(w, 1)*SIZE(w, 2)*SIZE(w, 3)*SIZE(w, 4))
   CALL POPREAL8ARRAY(gamma, SIZE(gamma, 1)*SIZE(gamma, 2)*SIZE(gamma, &
   &                3))
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL POPREAL8ARRAY(rev, SIZE(rev, 1)*SIZE(rev, 2)*SIZE(rev, 3))
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. symm) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL RESETBCPOINTERS_B(nn, .false.)
   CALL BCSYMM_B(nn, secondhalo)
   CALL SETBCPOINTERS_B(nn, .false.)
   END IF
   END DO
   END SUBROUTINE APPLYALLBC_BLOCK_B
   SUBROUTINE APPLYALLBC_BLOCK(secondhalo)
   ! Apply BC's for a single block
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTTIMESPECTRAL
   USE ITERATION
   USE BCTYPES
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   ! Local variables.
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: nn
   !
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   ! Apply all the boundary conditions. The order is important!  Only
   ! some of them have been AD'ed
   ! ------------------------------------
   !  Symmetry Boundary Condition 
   ! ------------------------------------
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. symm) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCSYMM(nn, secondhalo)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   ! ------------------------------------
   !  Adibatic Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswalladiabatic) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCNSWALLADIABATIC(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   ! ------------------------------------
   !  Isotermal Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nviscbocos
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCNSWALLISOTHERMAL(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   ! ------------------------------------
   !  Farfield Boundary Condition 
   ! ------------------------------------
   IF (precond .EQ. turkel .OR. precond .EQ. choimerkle) CALL &
   &     TERMINATE('applyAllBC', &
   &      'Farfield Turkel and Coid/Merkle preconditioners not implemented'&
   &           )
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. farfield) THEN
   CALL SETBCPOINTERS(nn, .false.)
   CALL BCFARFIELD(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS(nn, .false.)
   END IF
   END DO
   ! ------------------------------------
   !  Euler Wall Boundary Condition 
   ! ------------------------------------
   DO nn=1,nbocos
   IF (bctype(nn) .EQ. eulerwall) THEN
   CALL SETBCPOINTERS(nn, .true.)
   CALL BCEULERWALL(nn, secondhalo, correctfork)
   CALL RESETBCPOINTERS(nn, .true.)
   END IF
   END DO
   END SUBROUTINE APPLYALLBC_BLOCK
   !  Differentiation of bcsymm in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
   !                *rlv3 *ww0 *ww1 *ww2 *ww3
   !   Plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
   !                rev1:in rev2:in rev3:in pp0:in pp1:in pp2:in pp3:in
   !                rlv0:in rlv1:in rlv2:in rlv3:in ww0:in ww1:in
   !                ww2:in ww3:in
   ! ===================================================================
   !   Actual implementation of each of the boundary condition routines
   ! ===================================================================
   SUBROUTINE BCSYMM_B(nn, secondhalo)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcSymm applies the symmetry boundary conditions to a block.    *
   ! * It is assumed that the pointers in blockPointers are already   *
   ! * set to the correct block on the correct grid level.            *
   ! *                                                                *
   ! * In case also the second halo must be set the loop over the     *
   ! * boundary subfaces is executed twice. This is the only correct  *
   ! * way in case the block contains only 1 cell between two         *
   ! * symmetry planes, i.e. a 2D problem.                            *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, l, ii
   REAL(kind=realtype) :: vn, nnx, nny, nnz
   REAL(kind=realtype) :: vnd
   INTRINSIC MOD
   INTEGER :: branch
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd0
   IF (secondhalo) THEN
   CALL PUSHINTEGER4(i)
   CALL PUSHINTEGER4(j)
   CALL PUSHREAL8(vn)
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
   &         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
   &         , 3))
   ! Determine the flow variables in the halo cell.
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev3d(i, j) = rev3d(i, j) + rev0d(i, j)
   rev0d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv3d(i, j) = rlv3d(i, j) + rlv0d(i, j)
   rlv0d(i, j) = 0.0_8
   END IF
   pp3d(i, j) = pp3d(i, j) + pp0d(i, j)
   pp0d(i, j) = 0.0_8
   DO l=nt1mg,nt2mg
   ww3d(i, j, l) = ww3d(i, j, l) + ww0d(i, j, l)
   ww0d(i, j, l) = 0.0_8
   END DO
   ww3d(i, j, irhoe) = ww3d(i, j, irhoe) + ww0d(i, j, irhoe)
   ww0d(i, j, irhoe) = 0.0_8
   ww3d(i, j, ivz) = ww3d(i, j, ivz) + ww0d(i, j, ivz)
   vnd = -(bcdata(nn)%norm(i, j, 3)*ww0d(i, j, ivz))
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww0d(&
   &         i, j, ivz)
   ww0d(i, j, ivz) = 0.0_8
   ww3d(i, j, ivy) = ww3d(i, j, ivy) + ww0d(i, j, ivy)
   vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww0d(i, j, ivy)
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww0d(&
   &         i, j, ivy)
   ww0d(i, j, ivy) = 0.0_8
   ww3d(i, j, ivx) = ww3d(i, j, ivx) + ww0d(i, j, ivx)
   vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww0d(i, j, ivx)
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww0d(&
   &         i, j, ivx)
   ww0d(i, j, ivx) = 0.0_8
   ww3d(i, j, irho) = ww3d(i, j, irho) + ww0d(i, j, irho)
   ww0d(i, j, irho) = 0.0_8
   tempd0 = two*vnd
   ww3d(i, j, ivx) = ww3d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*&
   &         tempd0
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww3(i, j&
   &         , ivx)*tempd0
   ww3d(i, j, ivy) = ww3d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*&
   &         tempd0
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww3(i, j&
   &         , ivy)*tempd0
   ww3d(i, j, ivz) = ww3d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*&
   &         tempd0
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww3(i, j&
   &         , ivz)*tempd0
   END DO
   CALL POPREAL8(vn)
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(i)
   END IF
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
   &       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
   &       )
   ! Determine the flow variables in the halo cell.
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   END IF
   pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
   pp1d(i, j) = 0.0_8
   DO l=nt1mg,nt2mg
   ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
   ww1d(i, j, l) = 0.0_8
   END DO
   ww2d(i, j, irhoe) = ww2d(i, j, irhoe) + ww1d(i, j, irhoe)
   ww1d(i, j, irhoe) = 0.0_8
   ww2d(i, j, ivz) = ww2d(i, j, ivz) + ww1d(i, j, ivz)
   vnd = -(bcdata(nn)%norm(i, j, 3)*ww1d(i, j, ivz))
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) - vn*ww1d(i&
   &       , j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   ww2d(i, j, ivy) = ww2d(i, j, ivy) + ww1d(i, j, ivy)
   vnd = vnd - bcdata(nn)%norm(i, j, 2)*ww1d(i, j, ivy)
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) - vn*ww1d(i&
   &       , j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ww2d(i, j, ivx) = ww2d(i, j, ivx) + ww1d(i, j, ivx)
   vnd = vnd - bcdata(nn)%norm(i, j, 1)*ww1d(i, j, ivx)
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) - vn*ww1d(i&
   &       , j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
   ww1d(i, j, irho) = 0.0_8
   tempd = two*vnd
   ww2d(i, j, ivx) = ww2d(i, j, ivx) + bcdata(nn)%norm(i, j, 1)*tempd
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ww2(i, j, &
   &       ivx)*tempd
   ww2d(i, j, ivy) = ww2d(i, j, ivy) + bcdata(nn)%norm(i, j, 2)*tempd
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ww2(i, j, &
   &       ivy)*tempd
   ww2d(i, j, ivz) = ww2d(i, j, ivz) + bcdata(nn)%norm(i, j, 3)*tempd
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + ww2(i, j, &
   &       ivz)*tempd
   END DO
   END SUBROUTINE BCSYMM_B
   ! ===================================================================
   !   Actual implementation of each of the boundary condition routines
   ! ===================================================================
   SUBROUTINE BCSYMM(nn, secondhalo)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcSymm applies the symmetry boundary conditions to a block.    *
   ! * It is assumed that the pointers in blockPointers are already   *
   ! * set to the correct block on the correct grid level.            *
   ! *                                                                *
   ! * In case also the second halo must be set the loop over the     *
   ! * boundary subfaces is executed twice. This is the only correct  *
   ! * way in case the block contains only 1 cell between two         *
   ! * symmetry planes, i.e. a 2D problem.                            *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, l, ii
   REAL(kind=realtype) :: vn, nnx, nny, nnz
   INTRINSIC MOD
   ! Loop over the generic subface to set the state in the
   ! 1-st level halos 
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Determine twice the normal velocity component,
   ! which must be substracted from the donor velocity
   ! to obtain the halo velocity.
   vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
   &       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
   &       )
   ! Determine the flow variables in the halo cell.
   ww1(i, j, irho) = ww2(i, j, irho)
   ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
   ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
   ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
   ww1(i, j, irhoe) = ww2(i, j, irhoe)
   ! Simply copy the turbulent variables.
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   gamma1(i, j) = gamma2(i, j)
   pp1(i, j) = pp2(i, j)
   IF (viscous) rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = rev2(i, j)
   END DO
   IF (secondhalo) THEN
   ! If we need the second halo, do everything again, but using ww0,
   ! ww3 etc instead of ww2 and ww1. 
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
   &         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
   &         , 3))
   ! Determine the flow variables in the halo cell.
   ww0(i, j, irho) = ww3(i, j, irho)
   ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
   ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
   ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
   ww0(i, j, irhoe) = ww3(i, j, irhoe)
   DO l=nt1mg,nt2mg
   ww0(i, j, l) = ww3(i, j, l)
   END DO
   ! Set the pressure and gamma and possibly the
   ! laminar and eddy viscosity in the halo.
   gamma0(i, j) = gamma3(i, j)
   pp0(i, j) = pp3(i, j)
   IF (viscous) rlv0(i, j) = rlv3(i, j)
   IF (eddymodel) rev0(i, j) = rev3(i, j)
   END DO
   END IF
   END SUBROUTINE BCSYMM
   !  Differentiation of bcnswalladiabatic in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev0 *rev1 *rev2 *pp0 *pp1
   !                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
   !   with respect to varying inputs: *rev0 *rev1 *rev2 *pp0 *pp1
   !                *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
   !   Plus diff mem management of: bcdata:in rev0:in rev1:in rev2:in
   !                pp0:in pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in
   !                ww1:in ww2:in
   SUBROUTINE BCNSWALLADIABATIC_B(nn, secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcNSWallAdiabatic applies the viscous adiabatic wall           *
   !      * boundary condition the pointers already defined.               *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok
   REAL(kind=realtype) :: rhokd
   INTRINSIC MOD
   INTEGER :: branch
   ! Apply the BCWall In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   ww1(i, j, irho) = ww2(i, j, irho)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT_B(ww1, ww1d, pp1, pp1d, correctfork)
   rhokd = 0.0_8
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
   rhokd = rhokd - four*third*pp1d(i, j)
   pp1d(i, j) = 0.0_8
   ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww1d(i, j, irho)
   ww1d(i, j, irho) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
   ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END SUBROUTINE BCNSWALLADIABATIC_B
   SUBROUTINE BCNSWALLADIABATIC(nn, secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcNSWallAdiabatic applies the viscous adiabatic wall           *
   !      * boundary condition the pointers already defined.               *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok
   INTRINSIC MOD
   ! Apply the BCWall In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   ww1(i, j, irho) = ww2(i, j, irho)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO(correctfork)
   END SUBROUTINE BCNSWALLADIABATIC
   !  Differentiation of bcnswallisothermal in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: rgas *rev0 *rev1 *rev2 *pp0
   !                *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
   !   with respect to varying inputs: rgas *rev0 *rev1 *rev2 *pp0
   !                *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0 *ww1 *ww2
   !   Plus diff mem management of: bcdata:in rev0:in rev1:in rev2:in
   !                pp0:in pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in
   !                ww1:in ww2:in
   SUBROUTINE BCNSWALLISOTHERMAL_B(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcNSWallAdiabatic applies the viscous isothermal wall          *
   ! * boundary condition to a block. It is assumed that the          *
   ! * BCPointers are already set                                     *
   ! *                                                                *
   ! ******************************************************************
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok, t2, t1
   REAL(kind=realtype) :: rhokd, t2d, t1d
   INTRINSIC MOD
   INTRINSIC MAX
   INTRINSIC MIN
   INTEGER :: branch
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: temp
   ! In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   CALL PUSHREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   CALL PUSHREAL8(rhok)
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT_B(ww1, ww1d, pp1, pp1d, correctfork)
   rhokd = 0.0_8
   CALL POPREAL8(rhok)
   CALL POPREAL8ARRAY(pp1, SIZE(pp1, 1)*SIZE(pp1, 2))
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) THEN
   rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   CALL PUSHCONTROL1B(0)
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) - rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww1d(i, j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww1d(i, j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww1d(i, j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   tempd0 = ww1d(i, j, irho)/(rgas*t1)
   tempd1 = -(pp1(i, j)*tempd0/(rgas*t1))
   pp1d(i, j) = pp1d(i, j) + tempd0
   rgasd = rgasd + t1*tempd1
   t1d = rgas*tempd1
   ww1d(i, j, irho) = 0.0_8
   pp2d(i, j) = pp2d(i, j) + pp1d(i, j)
   rhokd = rhokd - four*third*pp1d(i, j)
   pp1d(i, j) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) t1d = 0.0_8
   t2d = -t1d
   temp = rgas*ww2(i, j, irho)
   tempd = -(pp2(i, j)*t2d/temp**2)
   pp2d(i, j) = pp2d(i, j) + t2d/temp
   rgasd = rgasd + ww2(i, j, irho)*tempd
   ww2d(i, j, irho) = ww2d(i, j, irho) + rgas*tempd
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ww2d(i, j, irho) = ww2d(i, j, irho) + ww2(i, j, itu1)*rhokd
   ww2d(i, j, itu1) = ww2d(i, j, itu1) + ww2(i, j, irho)*rhokd
   rhokd = 0.0_8
   END IF
   END DO
   END SUBROUTINE BCNSWALLISOTHERMAL_B
   SUBROUTINE BCNSWALLISOTHERMAL(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcNSWallAdiabatic applies the viscous isothermal wall          *
   ! * boundary condition to a block. It is assumed that the          *
   ! * BCPointers are already set                                     *
   ! *                                                                *
   ! ******************************************************************
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: i, j, ii
   REAL(kind=realtype) :: rhok, t2, t1
   INTRINSIC MOD
   INTRINSIC MAX
   INTRINSIC MIN
   ! In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   pp1(i, j) = pp2(i, j) - four*third*rhok
   ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
   ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
   ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
   ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = -rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO(correctfork)
   END SUBROUTINE BCNSWALLISOTHERMAL
   !  Differentiation of bceulerwall in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0
   !                *ww1 *ww2
   !   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
   !                *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *ww0
   !                *ww1 *ww2
   !   Plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
   !                rev1:in rev2:in pp0:in pp1:in pp2:in pp3:in rlv0:in
   !                rlv1:in rlv2:in ww0:in ww1:in ww2:in
   SUBROUTINE BCEULERWALL_B(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcEulerWall applies the inviscid wall boundary condition to    *
   ! * a block. It is assumed that the bcpointers are                 *
   ! * already set to the correct block on the correct grid level.    *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: j, k, l, ii
   INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
   INTEGER(kind=inttype) :: walltreatment
   REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
   REAL(kind=realtype) :: skxa, skya, skza, a1, b1
   REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
   REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
   REAL(kind=realtype) :: vnd
   REAL(kind=realtype) :: uux, uuy, uuz
   REAL(kind=realtype), DIMENSION(isize, jsize) :: grad
   REAL(kind=realtype), DIMENSION(isize, jsize) :: gradd
   INTRINSIC MOD
   REAL(kind=realtype) :: DIM
   INTEGER :: branch
   REAL(kind=realtype) :: tempd
   ! Make sure that on the coarser grids the constant pressure
   ! boundary condition is used.
   walltreatment = wallbctreatment
   IF (currentlevel .GT. groundlevel) walltreatment = constantpressure
   ! **************************************************************
   ! *                                                            *
   ! * Determine the boundary condition treatment and compute the *
   ! * undivided pressure gradient accordingly. This gradient is  *
   ! * temporarily stored in the halo pressure.                   *
   ! *                                                            *
   ! **************************************************************
   !
   SELECT CASE  (walltreatment) 
   CASE (constantpressure) 
   CALL PUSHCONTROL1B(1)
   ! Constant pressure. Set the gradient to zero.
   grad = zero
   CASE (linextrapolpressure) 
   ! Linear extrapolation. 
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + istart
   k = ii/isize + jstart
   grad(j, k) = pp3(j, k) - pp2(j, k)
   END DO
   CALL PUSHCONTROL1B(0)
   CASE DEFAULT
   CALL PUSHCONTROL1B(1)
   END SELECT
   CALL PUSHINTEGER4(j)
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + istart
   k = ii/isize + jstart
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   pp1(j, k) = DIM(pp2(j, k), grad(j, k))
   vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
   &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
   &       bcdata(nn)%norm(j, k, 3))
   ww1(j, k, irho) = ww2(j, k, irho)
   ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
   ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
   ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   ww1(j, k, l) = ww2(j, k, l)
   END DO
   ! The laminar and eddy viscosity, if present.
   IF (viscous) rlv1(j, k) = rlv2(j, k)
   IF (eddymodel) rev1(j, k) = rev2(j, k)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT_B(ww1, ww1d, pp1, pp1d, correctfork)
   gradd = 0.0_8
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + istart
   k = ii/isize + jstart
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
   &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
   &       bcdata(nn)%norm(j, k, 3))
   ! The laminar and eddy viscosity, if present.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev2d(j, k) = rev2d(j, k) + rev1d(j, k)
   rev1d(j, k) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2d(j, k) = rlv2d(j, k) + rlv1d(j, k)
   rlv1d(j, k) = 0.0_8
   END IF
   DO l=nt2mg,nt1mg,-1
   ww2d(j, k, l) = ww2d(j, k, l) + ww1d(j, k, l)
   ww1d(j, k, l) = 0.0_8
   END DO
   ww2d(j, k, ivz) = ww2d(j, k, ivz) + ww1d(j, k, ivz)
   vnd = bcdata(nn)%norm(j, k, 3)*ww1d(j, k, ivz)
   bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) + vn*ww1d(j&
   &       , k, ivz)
   ww1d(j, k, ivz) = 0.0_8
   ww2d(j, k, ivy) = ww2d(j, k, ivy) + ww1d(j, k, ivy)
   vnd = vnd + bcdata(nn)%norm(j, k, 2)*ww1d(j, k, ivy)
   bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) + vn*ww1d(j&
   &       , k, ivy)
   ww1d(j, k, ivy) = 0.0_8
   ww2d(j, k, ivx) = ww2d(j, k, ivx) + ww1d(j, k, ivx)
   vnd = vnd + bcdata(nn)%norm(j, k, 1)*ww1d(j, k, ivx)
   bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) + vn*ww1d(j&
   &       , k, ivx)
   ww1d(j, k, ivx) = 0.0_8
   ww2d(j, k, irho) = ww2d(j, k, irho) + ww1d(j, k, irho)
   ww1d(j, k, irho) = 0.0_8
   tempd = two*vnd
   ww2d(j, k, ivx) = ww2d(j, k, ivx) - bcdata(nn)%norm(j, k, 1)*tempd
   bcdatad(nn)%norm(j, k, 1) = bcdatad(nn)%norm(j, k, 1) - ww2(j, k, &
   &       ivx)*tempd
   ww2d(j, k, ivy) = ww2d(j, k, ivy) - bcdata(nn)%norm(j, k, 2)*tempd
   bcdatad(nn)%norm(j, k, 2) = bcdatad(nn)%norm(j, k, 2) - ww2(j, k, &
   &       ivy)*tempd
   ww2d(j, k, ivz) = ww2d(j, k, ivz) - bcdata(nn)%norm(j, k, 3)*tempd
   bcdatad(nn)%norm(j, k, 3) = bcdatad(nn)%norm(j, k, 3) - ww2(j, k, &
   &       ivz)*tempd
   CALL DIM_B(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k), pp1d(j&
   &          , k))
   pp1d(j, k) = 0.0_8
   END DO
   CALL POPINTEGER4(j)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + istart
   k = ii/isize + jstart
   pp3d(j, k) = pp3d(j, k) + gradd(j, k)
   pp2d(j, k) = pp2d(j, k) - gradd(j, k)
   gradd(j, k) = 0.0_8
   END DO
   END IF
   END SUBROUTINE BCEULERWALL_B
   SUBROUTINE BCEULERWALL(nn, secondhalo, correctfork)
   !
   ! ******************************************************************
   ! *                                                                *
   ! * bcEulerWall applies the inviscid wall boundary condition to    *
   ! * a block. It is assumed that the bcpointers are                 *
   ! * already set to the correct block on the correct grid level.    *
   ! *                                                                *
   ! ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   INTEGER(kind=inttype), INTENT(IN) :: nn
   ! Local variables.
   INTEGER(kind=inttype) :: j, k, l, ii
   INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
   INTEGER(kind=inttype) :: walltreatment
   REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
   REAL(kind=realtype) :: skxa, skya, skza, a1, b1
   REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
   REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
   REAL(kind=realtype) :: uux, uuy, uuz
   REAL(kind=realtype), DIMENSION(isize, jsize) :: grad
   INTRINSIC MOD
   REAL(kind=realtype) :: DIM
   ! Make sure that on the coarser grids the constant pressure
   ! boundary condition is used.
   walltreatment = wallbctreatment
   IF (currentlevel .GT. groundlevel) walltreatment = constantpressure
   ! **************************************************************
   ! *                                                            *
   ! * Determine the boundary condition treatment and compute the *
   ! * undivided pressure gradient accordingly. This gradient is  *
   ! * temporarily stored in the halo pressure.                   *
   ! *                                                            *
   ! **************************************************************
   !
   SELECT CASE  (walltreatment) 
   CASE (constantpressure) 
   ! Constant pressure. Set the gradient to zero.
   grad = zero
   CASE (linextrapolpressure) 
   ! Linear extrapolation. 
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + istart
   k = ii/isize + jstart
   grad(j, k) = pp3(j, k) - pp2(j, k)
   END DO
   END SELECT
   ! Determine the state in the halo cell. Again loop over
   ! the cell range for this subface.
   DO ii=0,isize*jsize-1
   j = MOD(ii, isize) + istart
   k = ii/isize + jstart
   ! Compute the pressure density and velocity in the
   ! halo cell. Note that rface is the grid velocity
   ! component in the direction of norm, i.e. outward
   ! pointing.
   pp1(j, k) = DIM(pp2(j, k), grad(j, k))
   vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
   &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
   &       bcdata(nn)%norm(j, k, 3))
   ww1(j, k, irho) = ww2(j, k, irho)
   ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
   ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
   ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
   ! Just copy the turbulent variables.
   DO l=nt1mg,nt2mg
   ww1(j, k, l) = ww2(j, k, l)
   END DO
   ! The laminar and eddy viscosity, if present.
   IF (viscous) rlv1(j, k) = rlv2(j, k)
   IF (eddymodel) rev1(j, k) = rev2(j, k)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO(correctfork)
   END SUBROUTINE BCEULERWALL
   !  Differentiation of bcfarfield in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: gammainf winf pinfcorr *(*bcdata.norm)
   !                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
   !                *ww0 *ww1 *ww2
   !   with respect to varying inputs: gammainf winf pinfcorr *(*bcdata.norm)
   !                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
   !                *ww0 *ww1 *ww2
   !   Plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
   !                rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in rlv1:in
   !                rlv2:in ww0:in ww1:in ww2:in
   SUBROUTINE BCFARFIELD_B(nn, secondhalo, correctfork)
   !      ******************************************************************
   !      *                                                                *
   !      * bcFarfield applies the farfield boundary condition to a block. *
   !      * It is assumed that the BCPointers are already set              *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   ! Local variables.
   INTEGER(kind=inttype) :: nn, i, j, k, l, ii
   REAL(kind=realtype) :: nnx, nny, nnz
   REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
   REAL(kind=realtype) :: gm1d, ovgm1d, ac1d, ac2d
   REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
   REAL(kind=realtype) :: r0d, u0d, v0d, w0d, qn0d, c0d, s0d
   REAL(kind=realtype) :: re, ue, ve, we, qne, ce
   REAL(kind=realtype) :: red, ued, ved, wed, qned, ced
   REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
   REAL(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
   INTRINSIC SQRT
   INTRINSIC MOD
   INTEGER :: branch
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: temp
   ! Some constants needed to compute the riemann inVariants.
   gm1 = gammainf - one
   ovgm1 = one/gm1
   ! Compute the three velocity components, the speed of sound and
   ! the entropy of the free stream.
   r0 = one/winf(irho)
   u0 = winf(ivx)
   v0 = winf(ivy)
   w0 = winf(ivz)
   c0 = SQRT(gammainf*pinfcorr*r0)
   s0 = winf(irho)**gammainf/pinfcorr
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
   &       w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   re = one/ww2(i, j, irho)
   ue = ww2(i, j, ivx)
   ve = ww2(i, j, ivy)
   we = ww2(i, j, ivz)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
   &       we*bcdata(nn)%norm(i, j, 3)
   ce = SQRT(gamma2(i, j)*pp2(i, j)*re)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   ac1 = qne + two*ovgm1*ce
   ELSE
   ! Supersonic inflow.
   ac1 = qn0 + two*ovgm1*c0
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   ac2 = qne - two*ovgm1*ce
   ELSE
   ! Inflow or subsonic outflow.
   ac2 = qn0 - two*ovgm1*c0
   END IF
   qnf = half*(ac1+ac2)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   ELSE
   ! Inflow
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = winf(l)
   END DO
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   cc = cf*cf/gamma2(i, j)
   qq = uf*uf + vf*vf + wf*wf
   ww1(i, j, irho) = (sf*cc)**ovgm1
   ww1(i, j, ivx) = uf
   ww1(i, j, ivy) = vf
   ww1(i, j, ivz) = wf
   pp1(i, j) = ww1(i, j, irho)*cc
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL PUSHREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO_B(correctfork)
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   CALL COMPUTEETOT_B(ww1, ww1d, pp1, pp1d, correctfork)
   v0d = 0.0_8
   gm1d = 0.0_8
   s0d = 0.0_8
   c0d = 0.0_8
   w0d = 0.0_8
   u0d = 0.0_8
   ovgm1d = 0.0_8
   CALL POPREAL8ARRAY(ww1, SIZE(ww1, 1)*SIZE(ww1, 2)*SIZE(ww1, 3))
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
   &       w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   re = one/ww2(i, j, irho)
   ue = ww2(i, j, ivx)
   ve = ww2(i, j, ivy)
   we = ww2(i, j, ivz)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
   &       we*bcdata(nn)%norm(i, j, 3)
   ce = SQRT(gamma2(i, j)*pp2(i, j)*re)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   ac1 = qne + two*ovgm1*ce
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Supersonic inflow.
   ac1 = qn0 + two*ovgm1*c0
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   ac2 = qne - two*ovgm1*ce
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Inflow or subsonic outflow.
   ac2 = qn0 - two*ovgm1*c0
   CALL PUSHCONTROL1B(1)
   END IF
   qnf = half*(ac1+ac2)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   CALL PUSHCONTROL1B(0)
   ELSE
   ! Inflow
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = winf(l)
   END DO
   CALL PUSHCONTROL1B(1)
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   cc = cf*cf/gamma2(i, j)
   ww1(i, j, irho) = (sf*cc)**ovgm1
   ww1(i, j, ivx) = uf
   ww1(i, j, ivy) = vf
   ww1(i, j, ivz) = wf
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev2d(i, j) = rev2d(i, j) + rev1d(i, j)
   rev1d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv2d(i, j) = rlv2d(i, j) + rlv1d(i, j)
   rlv1d(i, j) = 0.0_8
   END IF
   ww1d(i, j, irho) = ww1d(i, j, irho) + cc*pp1d(i, j)
   wfd = ww1d(i, j, ivz)
   ww1d(i, j, ivz) = 0.0_8
   vfd = ww1d(i, j, ivy)
   ww1d(i, j, ivy) = 0.0_8
   ufd = ww1d(i, j, ivx)
   ww1d(i, j, ivx) = 0.0_8
   temp1 = sf*cc
   IF (temp1 .LE. 0.0_8 .AND. (ovgm1 .EQ. 0.0_8 .OR. ovgm1 .NE. INT(&
   &         ovgm1))) THEN
   tempd10 = 0.0
   ELSE
   tempd10 = ovgm1*temp1**(ovgm1-1)*ww1d(i, j, irho)
   END IF
   ccd = sf*tempd10 + ww1(i, j, irho)*pp1d(i, j)
   pp1d(i, j) = 0.0_8
   sfd = cc*tempd10
   IF (.NOT.temp1 .LE. 0.0_8) ovgm1d = ovgm1d + temp1**ovgm1*LOG(&
   &         temp1)*ww1d(i, j, irho)
   ww1d(i, j, irho) = 0.0_8
   cfd = 2*cf*ccd/gamma2(i, j)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   DO l=nt1mg,nt2mg
   ww2d(i, j, l) = ww2d(i, j, l) + ww1d(i, j, l)
   ww1d(i, j, l) = 0.0_8
   END DO
   tempd6 = bcdata(nn)%norm(i, j, 1)*ufd
   tempd5 = bcdata(nn)%norm(i, j, 2)*vfd
   tempd3 = sfd/pp2(i, j)
   temp0 = gamma2(i, j)
   IF (.NOT.(ww2(i, j, irho) .LE. 0.0_8 .AND. (temp0 .EQ. 0.0_8 &
   &           .OR. temp0 .NE. INT(temp0)))) ww2d(i, j, irho) = ww2d(i, j, &
   &           irho) + temp0*ww2(i, j, irho)**(temp0-1)*tempd3
   pp2d(i, j) = pp2d(i, j) - ww2(i, j, irho)**temp0*tempd3/pp2(i, j&
   &         )
   tempd4 = bcdata(nn)%norm(i, j, 3)*wfd
   wed = wfd
   qnfd = tempd5 + tempd6 + tempd4
   qned = -tempd5 - tempd6 - tempd4
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qne&
   &         )*wfd
   ved = vfd
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qne&
   &         )*vfd
   ued = ufd
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qne&
   &         )*ufd
   qn0d = 0.0_8
   ELSE
   DO l=nt1mg,nt2mg
   winfd(l) = winfd(l) + ww1d(i, j, l)
   ww1d(i, j, l) = 0.0_8
   END DO
   tempd9 = bcdata(nn)%norm(i, j, 1)*ufd
   tempd8 = bcdata(nn)%norm(i, j, 2)*vfd
   s0d = s0d + sfd
   tempd7 = bcdata(nn)%norm(i, j, 3)*wfd
   w0d = w0d + wfd
   qnfd = tempd8 + tempd9 + tempd7
   qn0d = -tempd8 - tempd9 - tempd7
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + (qnf-qn0&
   &         )*wfd
   v0d = v0d + vfd
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + (qnf-qn0&
   &         )*vfd
   u0d = u0d + ufd
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + (qnf-qn0&
   &         )*ufd
   qned = 0.0_8
   ued = 0.0_8
   ved = 0.0_8
   wed = 0.0_8
   END IF
   tempd2 = fourth*cfd
   ac1d = half*qnfd + gm1*tempd2
   ac2d = half*qnfd - gm1*tempd2
   gm1d = gm1d + (ac1-ac2)*tempd2
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   qned = qned + ac2d
   ovgm1d = ovgm1d - two*ce*ac2d
   ced = -(two*ovgm1*ac2d)
   ELSE
   qn0d = qn0d + ac2d
   ovgm1d = ovgm1d - two*c0*ac2d
   c0d = c0d - two*ovgm1*ac2d
   ced = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   qned = qned + ac1d
   ovgm1d = ovgm1d + two*ce*ac1d
   ced = ced + two*ovgm1*ac1d
   ELSE
   qn0d = qn0d + ac1d
   ovgm1d = ovgm1d + two*c0*ac1d
   c0d = c0d + two*ovgm1*ac1d
   END IF
   IF (gamma2(i, j)*(pp2(i, j)*re) .EQ. 0.0_8) THEN
   tempd1 = 0.0
   ELSE
   tempd1 = gamma2(i, j)*ced/(2.0*SQRT(gamma2(i, j)*(pp2(i, j)*re))&
   &         )
   END IF
   pp2d(i, j) = pp2d(i, j) + re*tempd1
   red = pp2(i, j)*tempd1
   ued = ued + bcdata(nn)%norm(i, j, 1)*qned
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + ue*qned
   ved = ved + bcdata(nn)%norm(i, j, 2)*qned
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + ve*qned
   wed = wed + bcdata(nn)%norm(i, j, 3)*qned
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + we*qned
   ww2d(i, j, ivz) = ww2d(i, j, ivz) + wed
   ww2d(i, j, ivy) = ww2d(i, j, ivy) + ved
   ww2d(i, j, ivx) = ww2d(i, j, ivx) + ued
   ww2d(i, j, irho) = ww2d(i, j, irho) - one*red/ww2(i, j, irho)**2
   u0d = u0d + bcdata(nn)%norm(i, j, 1)*qn0d
   bcdatad(nn)%norm(i, j, 1) = bcdatad(nn)%norm(i, j, 1) + u0*qn0d
   v0d = v0d + bcdata(nn)%norm(i, j, 2)*qn0d
   bcdatad(nn)%norm(i, j, 2) = bcdatad(nn)%norm(i, j, 2) + v0*qn0d
   w0d = w0d + bcdata(nn)%norm(i, j, 3)*qn0d
   bcdatad(nn)%norm(i, j, 3) = bcdatad(nn)%norm(i, j, 3) + w0*qn0d
   END DO
   gm1d = gm1d - one*ovgm1d/gm1**2
   IF (gammainf*pinfcorr*r0 .EQ. 0.0_8) THEN
   tempd0 = 0.0
   ELSE
   tempd0 = c0d/(2.0*SQRT(gammainf*pinfcorr*r0))
   END IF
   tempd = s0d/pinfcorr
   temp = winf(irho)**gammainf
   IF (.NOT.(winf(irho) .LE. 0.0_8 .AND. (gammainf .EQ. 0.0_8 .OR. &
   &       gammainf .NE. INT(gammainf)))) winfd(irho) = winfd(irho) + &
   &       gammainf*winf(irho)**(gammainf-1)*tempd
   IF (winf(irho) .LE. 0.0_8) THEN
   gammainfd = gammainfd + r0*pinfcorr*tempd0 + gm1d
   ELSE
   gammainfd = gammainfd + r0*pinfcorr*tempd0 + gm1d + temp*LOG(winf(&
   &       irho))*tempd
   END IF
   pinfcorrd = pinfcorrd + r0*gammainf*tempd0 - temp*tempd/pinfcorr
   r0d = gammainf*pinfcorr*tempd0
   winfd(ivz) = winfd(ivz) + w0d
   winfd(ivy) = winfd(ivy) + v0d
   winfd(ivx) = winfd(ivx) + u0d
   winfd(irho) = winfd(irho) - one*r0d/winf(irho)**2
   END SUBROUTINE BCFARFIELD_B
   SUBROUTINE BCFARFIELD(nn, secondhalo, correctfork)
   !      ******************************************************************
   !      *                                                                *
   !      * bcFarfield applies the farfield boundary condition to a block. *
   !      * It is assumed that the BCPointers are already set              *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   ! Subroutine arguments.
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   ! Local variables.
   INTEGER(kind=inttype) :: nn, i, j, k, l, ii
   REAL(kind=realtype) :: nnx, nny, nnz
   REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
   REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
   REAL(kind=realtype) :: re, ue, ve, we, qne, ce
   REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
   INTRINSIC SQRT
   INTRINSIC MOD
   ! Some constants needed to compute the riemann inVariants.
   gm1 = gammainf - one
   ovgm1 = one/gm1
   ! Compute the three velocity components, the speed of sound and
   ! the entropy of the free stream.
   r0 = one/winf(irho)
   u0 = winf(ivx)
   v0 = winf(ivy)
   w0 = winf(ivz)
   c0 = SQRT(gammainf*pinfcorr*r0)
   s0 = winf(irho)**gammainf/pinfcorr
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
   &       w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   re = one/ww2(i, j, irho)
   ue = ww2(i, j, ivx)
   ve = ww2(i, j, ivy)
   we = ww2(i, j, ivz)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
   &       we*bcdata(nn)%norm(i, j, 3)
   ce = SQRT(gamma2(i, j)*pp2(i, j)*re)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   ac1 = qne + two*ovgm1*ce
   ELSE
   ! Supersonic inflow.
   ac1 = qn0 + two*ovgm1*c0
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   ac2 = qne - two*ovgm1*ce
   ELSE
   ! Inflow or subsonic outflow.
   ac2 = qn0 - two*ovgm1*c0
   END IF
   qnf = half*(ac1+ac2)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   sf = ww2(i, j, irho)**gamma2(i, j)/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   ELSE
   ! Inflow
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1(i, j, l) = winf(l)
   END DO
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   cc = cf*cf/gamma2(i, j)
   qq = uf*uf + vf*vf + wf*wf
   ww1(i, j, irho) = (sf*cc)**ovgm1
   ww1(i, j, ivx) = uf
   ww1(i, j, ivy) = vf
   ww1(i, j, ivz) = wf
   pp1(i, j) = ww1(i, j, irho)*cc
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) rlv1(i, j) = rlv2(i, j)
   IF (eddymodel) rev1(i, j) = rev2(i, j)
   END DO
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT(ww1, pp1, correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO(correctfork)
   END SUBROUTINE BCFARFIELD
   !  Differentiation of extrapolate2ndhalo in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev0 *rev1 *pp0 *pp1 *pp2
   !                *rlv0 *rlv1 *ww0 *ww1 *ww2
   !   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
   !                *rlv0 *rlv1 *ww0 *ww1 *ww2
   !   Plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
   !                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
   SUBROUTINE EXTRAPOLATE2NDHALO_B(correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * extrapolate2ndHalo determines the states of the second layer   *
   !      * halo cells for the given subface of the block. It is assumed   *
   !      * that the appropriate BCPointers are already set
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   USE INPUTPHYSICS
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: correctfork
   REAL(kind=realtype), PARAMETER :: factor=0.5_realType
   INTEGER(kind=inttype) :: i, j, l, ii
   INTRINSIC MOD
   INTRINSIC MAX
   INTEGER :: branch
   CALL PUSHREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Extrapolate the density, momentum and pressure.
   ! Make sure that a certain threshold is kept.
   ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
   IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
   ww0(i, j, irho) = ww0(i, j, irho)
   ELSE
   ww0(i, j, irho) = factor*ww1(i, j, irho)
   END IF
   ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
   ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
   ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
   IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
   pp0(i, j) = two*pp1(i, j) - pp2(i, j)
   ELSE
   pp0(i, j) = factor*pp1(i, j)
   END IF
   ! Extrapolate the turbulent variables. Use constant
   ! extrapolation.
   DO l=nt1mg,nt2mg
   ww0(i, j, l) = ww1(i, j, l)
   END DO
   ! The laminar and eddy viscosity, if present. These values
   ! are simply taken constant. Their values do not matter.
   IF (viscous) rlv0(i, j) = rlv1(i, j)
   IF (eddymodel) rev0(i, j) = rev1(i, j)
   END DO
   CALL COMPUTEETOT_B(ww0, ww0d, pp0, pp0d, correctfork)
   CALL POPREAL8ARRAY(ww0, SIZE(ww0, 1)*SIZE(ww0, 2)*SIZE(ww0, 3))
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Extrapolate the density, momentum and pressure.
   ! Make sure that a certain threshold is kept.
   ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
   IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   ! The laminar and eddy viscosity, if present. These values
   ! are simply taken constant. Their values do not matter.
   IF (viscous) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev1d(i, j) = rev1d(i, j) + rev0d(i, j)
   rev0d(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv1d(i, j) = rlv1d(i, j) + rlv0d(i, j)
   rlv0d(i, j) = 0.0_8
   END IF
   DO l=nt1mg,nt2mg
   ww1d(i, j, l) = ww1d(i, j, l) + ww0d(i, j, l)
   ww0d(i, j, l) = 0.0_8
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   pp1d(i, j) = pp1d(i, j) + two*pp0d(i, j)
   pp2d(i, j) = pp2d(i, j) - pp0d(i, j)
   pp0d(i, j) = 0.0_8
   ELSE
   pp1d(i, j) = pp1d(i, j) + factor*pp0d(i, j)
   pp0d(i, j) = 0.0_8
   END IF
   ww1d(i, j, ivz) = ww1d(i, j, ivz) + two*ww0d(i, j, ivz)
   ww2d(i, j, ivz) = ww2d(i, j, ivz) - ww0d(i, j, ivz)
   ww0d(i, j, ivz) = 0.0_8
   ww1d(i, j, ivy) = ww1d(i, j, ivy) + two*ww0d(i, j, ivy)
   ww2d(i, j, ivy) = ww2d(i, j, ivy) - ww0d(i, j, ivy)
   ww0d(i, j, ivy) = 0.0_8
   ww1d(i, j, ivx) = ww1d(i, j, ivx) + two*ww0d(i, j, ivx)
   ww2d(i, j, ivx) = ww2d(i, j, ivx) - ww0d(i, j, ivx)
   ww0d(i, j, ivx) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ww1d(i, j, irho) = ww1d(i, j, irho) + factor*ww0d(i, j, irho)
   ww0d(i, j, irho) = 0.0_8
   END IF
   ww1d(i, j, irho) = ww1d(i, j, irho) + two*ww0d(i, j, irho)
   ww2d(i, j, irho) = ww2d(i, j, irho) - ww0d(i, j, irho)
   ww0d(i, j, irho) = 0.0_8
   END DO
   END SUBROUTINE EXTRAPOLATE2NDHALO_B
   !  Differentiation of computeetot in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: ww pp
   !   with respect to varying inputs: ww pp
   SUBROUTINE COMPUTEETOT_B(ww, wwd, pp, ppd, correctfork)
   ! Simplified total energy computation for boundary conditions.
   ! Only implements the constant cpModel
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   REAL(kind=realtype), DIMENSION(:, :) :: pp
   REAL(kind=realtype), DIMENSION(:, :) :: ppd
   REAL(kind=realtype), DIMENSION(:, :, :) :: ww
   REAL(kind=realtype), DIMENSION(:, :, :) :: wwd
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: ii, i, j
   REAL(kind=realtype) :: ovgm1, factk
   INTRINSIC MOD
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tmpd0
   SELECT CASE  (cpmodel) 
   CASE (cpconstant) 
   ! Constant cp and thus constant gamma.
   ! Abbreviate 1/(gamma -1) a bit easier.
   ovgm1 = one/(gammaconstant-one)
   factk = ovgm1*(five*third-gammaconstant)
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   IF (.NOT.correctfork) THEN
   tmpd = wwd(i, j, irhoe)
   wwd(i, j, irhoe) = 0.0_8
   tempd = half*ww(i, j, irho)*tmpd
   ppd(i, j) = ppd(i, j) + ovgm1*tmpd
   wwd(i, j, irho) = wwd(i, j, irho) + half*(ww(i, j, ivx)**2+ww(&
   &           i, j, ivy)**2+ww(i, j, ivz)**2)*tmpd
   wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd
   wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd
   wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd
   ELSE
   tmpd0 = wwd(i, j, irhoe)
   wwd(i, j, irhoe) = 0.0_8
   tempd0 = half*ww(i, j, irho)*tmpd0
   ppd(i, j) = ppd(i, j) + ovgm1*tmpd0
   wwd(i, j, irho) = wwd(i, j, irho) + (half*(ww(i, j, ivx)**2+ww&
   &           (i, j, ivy)**2+ww(i, j, ivz)**2)-factk*ww(i, j, itu1))*tmpd0
   wwd(i, j, ivx) = wwd(i, j, ivx) + 2*ww(i, j, ivx)*tempd0
   wwd(i, j, ivy) = wwd(i, j, ivy) + 2*ww(i, j, ivy)*tempd0
   wwd(i, j, ivz) = wwd(i, j, ivz) + 2*ww(i, j, ivz)*tempd0
   wwd(i, j, itu1) = wwd(i, j, itu1) - factk*ww(i, j, irho)*tmpd0
   END IF
   END DO
   END SELECT
   END SUBROUTINE COMPUTEETOT_B
   SUBROUTINE EXTRAPOLATE2NDHALO(correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * extrapolate2ndHalo determines the states of the second layer   *
   !      * halo cells for the given subface of the block. It is assumed   *
   !      * that the appropriate BCPointers are already set
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   USE INPUTPHYSICS
   IMPLICIT NONE
   LOGICAL, INTENT(IN) :: correctfork
   REAL(kind=realtype), PARAMETER :: factor=0.5_realType
   INTEGER(kind=inttype) :: i, j, l, ii
   INTRINSIC MOD
   INTRINSIC MAX
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   ! Extrapolate the density, momentum and pressure.
   ! Make sure that a certain threshold is kept.
   ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
   IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
   ww0(i, j, irho) = ww0(i, j, irho)
   ELSE
   ww0(i, j, irho) = factor*ww1(i, j, irho)
   END IF
   ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
   ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
   ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
   IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
   pp0(i, j) = two*pp1(i, j) - pp2(i, j)
   ELSE
   pp0(i, j) = factor*pp1(i, j)
   END IF
   ! Extrapolate the turbulent variables. Use constant
   ! extrapolation.
   DO l=nt1mg,nt2mg
   ww0(i, j, l) = ww1(i, j, l)
   END DO
   ! The laminar and eddy viscosity, if present. These values
   ! are simply taken constant. Their values do not matter.
   IF (viscous) rlv0(i, j) = rlv1(i, j)
   IF (eddymodel) rev0(i, j) = rev1(i, j)
   END DO
   ! Compute the energy for this halo range.
   CALL COMPUTEETOT(ww0, pp0, correctfork)
   END SUBROUTINE EXTRAPOLATE2NDHALO
   SUBROUTINE COMPUTEETOT(ww, pp, correctfork)
   ! Simplified total energy computation for boundary conditions.
   ! Only implements the constant cpModel
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   REAL(kind=realtype), DIMENSION(:, :) :: pp
   REAL(kind=realtype), DIMENSION(:, :, :) :: ww
   LOGICAL :: correctfork
   INTEGER(kind=inttype) :: ii, i, j
   REAL(kind=realtype) :: ovgm1, factk
   INTRINSIC MOD
   SELECT CASE  (cpmodel) 
   CASE (cpconstant) 
   ! Constant cp and thus constant gamma.
   ! Abbreviate 1/(gamma -1) a bit easier.
   ovgm1 = one/(gammaconstant-one)
   factk = ovgm1*(five*third-gammaconstant)
   ! Loop over the given array and compute the energy, possibly
   ! correcting for K
   DO ii=0,isize*jsize-1
   i = MOD(ii, isize) + istart
   j = ii/isize + jstart
   IF (.NOT.correctfork) THEN
   ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
   &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
   ELSE
   ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
   &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
   &           j, irho)*ww(i, j, itu1)
   END IF
   END DO
   CASE (cptempcurvefits) 
   CALL TERMINATE('BCRoutines', &
   &                 'CPTempCurveFits not implemented yet.')
   END SELECT
   END SUBROUTINE COMPUTEETOT
   !  Differentiation of setbcpointers in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *p *w *rlv *x *si *sj
   !                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
   !                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
   !                *ww3
   !   with respect to varying inputs: *rev *p *w *rlv *x *si *sj
   !                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
   !                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
   !                *ww3
   !   Plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
   !                sj:in sk:in bcdata:in xx:in rev0:in rev1:in rev2:in
   !                rev3:in pp0:in pp1:in pp2:in pp3:in rlv0:in rlv1:in
   !                rlv2:in rlv3:in ssi:in ww0:in ww1:in ww2:in ww3:in
   SUBROUTINE SETBCPOINTERS_B(nn, spatialpointers)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * setBCPointers sets the pointers needed for the boundary        *
   !      * condition treatment on a general face, such that the boundary  *
   !      * routines are only implemented once instead of 6 times.         *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   LOGICAL, INTENT(IN) :: spatialpointers
   INTEGER :: branch
   ! Determine the sizes of each face and point to just the range we
   ! need on each face. 
   ! Set the size of the subface
   ! Determine the face id on which the subface is located and set
   ! the pointers accordinly.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   CALL PUSHCONTROL3B(1)
   CASE (imax) 
   CALL PUSHCONTROL3B(2)
   CASE (jmin) 
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   CALL PUSHCONTROL3B(4)
   CASE (kmin) 
   CALL PUSHCONTROL3B(5)
   CASE (kmax) 
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ! These spatial pointers are only required for
   ! forcesAndMoments. Eulerwall normal moment is is reverse AD'ed.
   IF (spatialpointers) THEN
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   sid(1, 1:je, 1:ke, :) = sid(1, 1:je, 1:ke, :) + ssid(1:je, 1:ke&
   &         , :)
   ssid(1:je, 1:ke, :) = 0.0_8
   xd(1, 0:je, 0:ke, :) = xd(1, 0:je, 0:ke, :) + xxd(1:je+1, 1:ke+1&
   &         , :)
   xxd(1:je+1, 1:ke+1, :) = 0.0_8
   CASE (imax) 
   sid(il, 1:je, 1:ke, :) = sid(il, 1:je, 1:ke, :) + ssid(1:je, 1:&
   &         ke, :)
   ssid(1:je, 1:ke, :) = 0.0_8
   xd(il, 0:je, 0:ke, :) = xd(il, 0:je, 0:ke, :) + xxd(1:je+1, 1:ke&
   &         +1, :)
   xxd(1:je+1, 1:ke+1, :) = 0.0_8
   CASE (jmin) 
   sjd(1:ie, 1, 1:ke, :) = sjd(1:ie, 1, 1:ke, :) + ssid(1:ie, 1:ke&
   &         , :)
   ssid(1:ie, 1:ke, :) = 0.0_8
   xd(0:ie, 1, 0:ke, :) = xd(0:ie, 1, 0:ke, :) + xxd(1:ie+1, 1:ke+1&
   &         , :)
   xxd(1:ie+1, 1:ke+1, :) = 0.0_8
   CASE (jmax) 
   sjd(1:ie, jl, 1:ke, :) = sjd(1:ie, jl, 1:ke, :) + ssid(1:ie, 1:&
   &         ke, :)
   ssid(1:ie, 1:ke, :) = 0.0_8
   xd(0:ie, jl, 0:ke, :) = xd(0:ie, jl, 0:ke, :) + xxd(1:ie+1, 1:ke&
   &         +1, :)
   xxd(1:ie+1, 1:ke+1, :) = 0.0_8
   CASE (kmin) 
   skd(1:ie, 1:je, 1, :) = skd(1:ie, 1:je, 1, :) + ssid(1:ie, 1:je&
   &         , :)
   ssid(1:ie, 1:je, :) = 0.0_8
   xd(0:ie, 0:je, 1, :) = xd(0:ie, 0:je, 1, :) + xxd(1:ie+1, 1:je+1&
   &         , :)
   xxd(1:ie+1, 1:je+1, :) = 0.0_8
   CASE (kmax) 
   skd(1:ie, 1:je, kl, :) = skd(1:ie, 1:je, kl, :) + ssid(1:ie, 1:&
   &         je, :)
   ssid(1:ie, 1:je, :) = 0.0_8
   xd(0:ie, 0:je, kl, :) = xd(0:ie, 0:je, kl, :) + xxd(1:ie+1, 1:je&
   &         +1, :)
   xxd(1:ie+1, 1:je+1, :) = 0.0_8
   END SELECT
   END IF
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .NE. 0) THEN
   IF (branch .EQ. 1) THEN
   revd(0, 1:je, 1:ke) = revd(0, 1:je, 1:ke) + rev0d(1:je, 1:ke)
   rev0d(1:je, 1:ke) = 0.0_8
   revd(1, 1:je, 1:ke) = revd(1, 1:je, 1:ke) + rev1d(1:je, 1:ke)
   rev1d(1:je, 1:ke) = 0.0_8
   revd(2, 1:je, 1:ke) = revd(2, 1:je, 1:ke) + rev2d(1:je, 1:ke)
   rev2d(1:je, 1:ke) = 0.0_8
   revd(3, 1:je, 1:ke) = revd(3, 1:je, 1:ke) + rev3d(1:je, 1:ke)
   rev3d(1:je, 1:ke) = 0.0_8
   rlvd(0, 1:je, 1:ke) = rlvd(0, 1:je, 1:ke) + rlv0d(1:je, 1:ke)
   rlv0d(1:je, 1:ke) = 0.0_8
   rlvd(1, 1:je, 1:ke) = rlvd(1, 1:je, 1:ke) + rlv1d(1:je, 1:ke)
   rlv1d(1:je, 1:ke) = 0.0_8
   rlvd(2, 1:je, 1:ke) = rlvd(2, 1:je, 1:ke) + rlv2d(1:je, 1:ke)
   rlv2d(1:je, 1:ke) = 0.0_8
   rlvd(3, 1:je, 1:ke) = rlvd(3, 1:je, 1:ke) + rlv3d(1:je, 1:ke)
   rlv3d(1:je, 1:ke) = 0.0_8
   pd(0, 1:je, 1:ke) = pd(0, 1:je, 1:ke) + pp0d(1:je, 1:ke)
   pp0d(1:je, 1:ke) = 0.0_8
   pd(1, 1:je, 1:ke) = pd(1, 1:je, 1:ke) + pp1d(1:je, 1:ke)
   pp1d(1:je, 1:ke) = 0.0_8
   pd(2, 1:je, 1:ke) = pd(2, 1:je, 1:ke) + pp2d(1:je, 1:ke)
   pp2d(1:je, 1:ke) = 0.0_8
   pd(3, 1:je, 1:ke) = pd(3, 1:je, 1:ke) + pp3d(1:je, 1:ke)
   pp3d(1:je, 1:ke) = 0.0_8
   wd(0, 1:je, 1:ke, :) = wd(0, 1:je, 1:ke, :) + ww0d(1:je, 1:ke&
   &           , :)
   ww0d(1:je, 1:ke, :) = 0.0_8
   wd(1, 1:je, 1:ke, :) = wd(1, 1:je, 1:ke, :) + ww1d(1:je, 1:ke&
   &           , :)
   ww1d(1:je, 1:ke, :) = 0.0_8
   wd(2, 1:je, 1:ke, :) = wd(2, 1:je, 1:ke, :) + ww2d(1:je, 1:ke&
   &           , :)
   ww2d(1:je, 1:ke, :) = 0.0_8
   wd(3, 1:je, 1:ke, :) = wd(3, 1:je, 1:ke, :) + ww3d(1:je, 1:ke&
   &           , :)
   ww3d(1:je, 1:ke, :) = 0.0_8
   ELSE
   revd(ib, 1:je, 1:ke) = revd(ib, 1:je, 1:ke) + rev0d(1:je, 1:ke&
   &           )
   rev0d(1:je, 1:ke) = 0.0_8
   revd(ie, 1:je, 1:ke) = revd(ie, 1:je, 1:ke) + rev1d(1:je, 1:ke&
   &           )
   rev1d(1:je, 1:ke) = 0.0_8
   revd(il, 1:je, 1:ke) = revd(il, 1:je, 1:ke) + rev2d(1:je, 1:ke&
   &           )
   rev2d(1:je, 1:ke) = 0.0_8
   revd(nx, 1:je, 1:ke) = revd(nx, 1:je, 1:ke) + rev3d(1:je, 1:ke&
   &           )
   rev3d(1:je, 1:ke) = 0.0_8
   rlvd(ib, 1:je, 1:ke) = rlvd(ib, 1:je, 1:ke) + rlv0d(1:je, 1:ke&
   &           )
   rlv0d(1:je, 1:ke) = 0.0_8
   rlvd(ie, 1:je, 1:ke) = rlvd(ie, 1:je, 1:ke) + rlv1d(1:je, 1:ke&
   &           )
   rlv1d(1:je, 1:ke) = 0.0_8
   rlvd(il, 1:je, 1:ke) = rlvd(il, 1:je, 1:ke) + rlv2d(1:je, 1:ke&
   &           )
   rlv2d(1:je, 1:ke) = 0.0_8
   rlvd(nx, 1:je, 1:ke) = rlvd(nx, 1:je, 1:ke) + rlv3d(1:je, 1:ke&
   &           )
   rlv3d(1:je, 1:ke) = 0.0_8
   pd(ib, 1:je, 1:ke) = pd(ib, 1:je, 1:ke) + pp0d(1:je, 1:ke)
   pp0d(1:je, 1:ke) = 0.0_8
   pd(ie, 1:je, 1:ke) = pd(ie, 1:je, 1:ke) + pp1d(1:je, 1:ke)
   pp1d(1:je, 1:ke) = 0.0_8
   pd(il, 1:je, 1:ke) = pd(il, 1:je, 1:ke) + pp2d(1:je, 1:ke)
   pp2d(1:je, 1:ke) = 0.0_8
   pd(nx, 1:je, 1:ke) = pd(nx, 1:je, 1:ke) + pp3d(1:je, 1:ke)
   pp3d(1:je, 1:ke) = 0.0_8
   wd(ib, 1:je, 1:ke, :) = wd(ib, 1:je, 1:ke, :) + ww0d(1:je, 1:&
   &           ke, :)
   ww0d(1:je, 1:ke, :) = 0.0_8
   wd(ie, 1:je, 1:ke, :) = wd(ie, 1:je, 1:ke, :) + ww1d(1:je, 1:&
   &           ke, :)
   ww1d(1:je, 1:ke, :) = 0.0_8
   wd(il, 1:je, 1:ke, :) = wd(il, 1:je, 1:ke, :) + ww2d(1:je, 1:&
   &           ke, :)
   ww2d(1:je, 1:ke, :) = 0.0_8
   wd(nx, 1:je, 1:ke, :) = wd(nx, 1:je, 1:ke, :) + ww3d(1:je, 1:&
   &           ke, :)
   ww3d(1:je, 1:ke, :) = 0.0_8
   END IF
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   revd(1:ie, 0, 1:ke) = revd(1:ie, 0, 1:ke) + rev0d(1:ie, 1:ke)
   rev0d(1:ie, 1:ke) = 0.0_8
   revd(1:ie, 1, 1:ke) = revd(1:ie, 1, 1:ke) + rev1d(1:ie, 1:ke)
   rev1d(1:ie, 1:ke) = 0.0_8
   revd(1:ie, 2, 1:ke) = revd(1:ie, 2, 1:ke) + rev2d(1:ie, 1:ke)
   rev2d(1:ie, 1:ke) = 0.0_8
   revd(1:ie, 3, 1:ke) = revd(1:ie, 3, 1:ke) + rev3d(1:ie, 1:ke)
   rev3d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, 0, 1:ke) = rlvd(1:ie, 0, 1:ke) + rlv0d(1:ie, 1:ke)
   rlv0d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, 1, 1:ke) = rlvd(1:ie, 1, 1:ke) + rlv1d(1:ie, 1:ke)
   rlv1d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, 2, 1:ke) = rlvd(1:ie, 2, 1:ke) + rlv2d(1:ie, 1:ke)
   rlv2d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, 3, 1:ke) = rlvd(1:ie, 3, 1:ke) + rlv3d(1:ie, 1:ke)
   rlv3d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, 0, 1:ke) = pd(1:ie, 0, 1:ke) + pp0d(1:ie, 1:ke)
   pp0d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, 1, 1:ke) = pd(1:ie, 1, 1:ke) + pp1d(1:ie, 1:ke)
   pp1d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, 2, 1:ke) = pd(1:ie, 2, 1:ke) + pp2d(1:ie, 1:ke)
   pp2d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, 3, 1:ke) = pd(1:ie, 3, 1:ke) + pp3d(1:ie, 1:ke)
   pp3d(1:ie, 1:ke) = 0.0_8
   wd(1:ie, 0, 1:ke, :) = wd(1:ie, 0, 1:ke, :) + ww0d(1:ie, 1:ke, :&
   &         )
   ww0d(1:ie, 1:ke, :) = 0.0_8
   wd(1:ie, 1, 1:ke, :) = wd(1:ie, 1, 1:ke, :) + ww1d(1:ie, 1:ke, :&
   &         )
   ww1d(1:ie, 1:ke, :) = 0.0_8
   wd(1:ie, 2, 1:ke, :) = wd(1:ie, 2, 1:ke, :) + ww2d(1:ie, 1:ke, :&
   &         )
   ww2d(1:ie, 1:ke, :) = 0.0_8
   wd(1:ie, 3, 1:ke, :) = wd(1:ie, 3, 1:ke, :) + ww3d(1:ie, 1:ke, :&
   &         )
   ww3d(1:ie, 1:ke, :) = 0.0_8
   ELSE
   revd(1:ie, jb, 1:ke) = revd(1:ie, jb, 1:ke) + rev0d(1:ie, 1:ke)
   rev0d(1:ie, 1:ke) = 0.0_8
   revd(1:ie, je, 1:ke) = revd(1:ie, je, 1:ke) + rev1d(1:ie, 1:ke)
   rev1d(1:ie, 1:ke) = 0.0_8
   revd(1:ie, jl, 1:ke) = revd(1:ie, jl, 1:ke) + rev2d(1:ie, 1:ke)
   rev2d(1:ie, 1:ke) = 0.0_8
   revd(1:ie, ny, 1:ke) = revd(1:ie, ny, 1:ke) + rev3d(1:ie, 1:ke)
   rev3d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, jb, 1:ke) = rlvd(1:ie, jb, 1:ke) + rlv0d(1:ie, 1:ke)
   rlv0d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, je, 1:ke) = rlvd(1:ie, je, 1:ke) + rlv1d(1:ie, 1:ke)
   rlv1d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, jl, 1:ke) = rlvd(1:ie, jl, 1:ke) + rlv2d(1:ie, 1:ke)
   rlv2d(1:ie, 1:ke) = 0.0_8
   rlvd(1:ie, ny, 1:ke) = rlvd(1:ie, ny, 1:ke) + rlv3d(1:ie, 1:ke)
   rlv3d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, jb, 1:ke) = pd(1:ie, jb, 1:ke) + pp0d(1:ie, 1:ke)
   pp0d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, je, 1:ke) = pd(1:ie, je, 1:ke) + pp1d(1:ie, 1:ke)
   pp1d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, jl, 1:ke) = pd(1:ie, jl, 1:ke) + pp2d(1:ie, 1:ke)
   pp2d(1:ie, 1:ke) = 0.0_8
   pd(1:ie, ny, 1:ke) = pd(1:ie, ny, 1:ke) + pp3d(1:ie, 1:ke)
   pp3d(1:ie, 1:ke) = 0.0_8
   wd(1:ie, jb, 1:ke, :) = wd(1:ie, jb, 1:ke, :) + ww0d(1:ie, 1:ke&
   &         , :)
   ww0d(1:ie, 1:ke, :) = 0.0_8
   wd(1:ie, je, 1:ke, :) = wd(1:ie, je, 1:ke, :) + ww1d(1:ie, 1:ke&
   &         , :)
   ww1d(1:ie, 1:ke, :) = 0.0_8
   wd(1:ie, jl, 1:ke, :) = wd(1:ie, jl, 1:ke, :) + ww2d(1:ie, 1:ke&
   &         , :)
   ww2d(1:ie, 1:ke, :) = 0.0_8
   wd(1:ie, ny, 1:ke, :) = wd(1:ie, ny, 1:ke, :) + ww3d(1:ie, 1:ke&
   &         , :)
   ww3d(1:ie, 1:ke, :) = 0.0_8
   END IF
   ELSE IF (branch .EQ. 5) THEN
   revd(1:ie, 1:je, 0) = revd(1:ie, 1:je, 0) + rev0d(1:ie, 1:je)
   rev0d(1:ie, 1:je) = 0.0_8
   revd(1:ie, 1:je, 1) = revd(1:ie, 1:je, 1) + rev1d(1:ie, 1:je)
   rev1d(1:ie, 1:je) = 0.0_8
   revd(1:ie, 1:je, 2) = revd(1:ie, 1:je, 2) + rev2d(1:ie, 1:je)
   rev2d(1:ie, 1:je) = 0.0_8
   revd(1:ie, 1:je, 3) = revd(1:ie, 1:je, 3) + rev3d(1:ie, 1:je)
   rev3d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, 0) = rlvd(1:ie, 1:je, 0) + rlv0d(1:ie, 1:je)
   rlv0d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, 1) = rlvd(1:ie, 1:je, 1) + rlv1d(1:ie, 1:je)
   rlv1d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, 2) = rlvd(1:ie, 1:je, 2) + rlv2d(1:ie, 1:je)
   rlv2d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, 3) = rlvd(1:ie, 1:je, 3) + rlv3d(1:ie, 1:je)
   rlv3d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, 0) = pd(1:ie, 1:je, 0) + pp0d(1:ie, 1:je)
   pp0d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, 1) = pd(1:ie, 1:je, 1) + pp1d(1:ie, 1:je)
   pp1d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, 2) = pd(1:ie, 1:je, 2) + pp2d(1:ie, 1:je)
   pp2d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, 3) = pd(1:ie, 1:je, 3) + pp3d(1:ie, 1:je)
   pp3d(1:ie, 1:je) = 0.0_8
   wd(1:ie, 1:je, 0, :) = wd(1:ie, 1:je, 0, :) + ww0d(1:ie, 1:je, :)
   ww0d(1:ie, 1:je, :) = 0.0_8
   wd(1:ie, 1:je, 1, :) = wd(1:ie, 1:je, 1, :) + ww1d(1:ie, 1:je, :)
   ww1d(1:ie, 1:je, :) = 0.0_8
   wd(1:ie, 1:je, 2, :) = wd(1:ie, 1:je, 2, :) + ww2d(1:ie, 1:je, :)
   ww2d(1:ie, 1:je, :) = 0.0_8
   wd(1:ie, 1:je, 3, :) = wd(1:ie, 1:je, 3, :) + ww3d(1:ie, 1:je, :)
   ww3d(1:ie, 1:je, :) = 0.0_8
   ELSE
   revd(1:ie, 1:je, kb) = revd(1:ie, 1:je, kb) + rev0d(1:ie, 1:je)
   rev0d(1:ie, 1:je) = 0.0_8
   revd(1:ie, 1:je, ke) = revd(1:ie, 1:je, ke) + rev1d(1:ie, 1:je)
   rev1d(1:ie, 1:je) = 0.0_8
   revd(1:ie, 1:je, kl) = revd(1:ie, 1:je, kl) + rev2d(1:ie, 1:je)
   rev2d(1:ie, 1:je) = 0.0_8
   revd(1:ie, 1:je, nz) = revd(1:ie, 1:je, nz) + rev3d(1:ie, 1:je)
   rev3d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, kb) = rlvd(1:ie, 1:je, kb) + rlv0d(1:ie, 1:je)
   rlv0d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, ke) = rlvd(1:ie, 1:je, ke) + rlv1d(1:ie, 1:je)
   rlv1d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, kl) = rlvd(1:ie, 1:je, kl) + rlv2d(1:ie, 1:je)
   rlv2d(1:ie, 1:je) = 0.0_8
   rlvd(1:ie, 1:je, nz) = rlvd(1:ie, 1:je, nz) + rlv3d(1:ie, 1:je)
   rlv3d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, kb) = pd(1:ie, 1:je, kb) + pp0d(1:ie, 1:je)
   pp0d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, ke) = pd(1:ie, 1:je, ke) + pp1d(1:ie, 1:je)
   pp1d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, kl) = pd(1:ie, 1:je, kl) + pp2d(1:ie, 1:je)
   pp2d(1:ie, 1:je) = 0.0_8
   pd(1:ie, 1:je, nz) = pd(1:ie, 1:je, nz) + pp3d(1:ie, 1:je)
   pp3d(1:ie, 1:je) = 0.0_8
   wd(1:ie, 1:je, kb, :) = wd(1:ie, 1:je, kb, :) + ww0d(1:ie, 1:je, :&
   &       )
   ww0d(1:ie, 1:je, :) = 0.0_8
   wd(1:ie, 1:je, ke, :) = wd(1:ie, 1:je, ke, :) + ww1d(1:ie, 1:je, :&
   &       )
   ww1d(1:ie, 1:je, :) = 0.0_8
   wd(1:ie, 1:je, kl, :) = wd(1:ie, 1:je, kl, :) + ww2d(1:ie, 1:je, :&
   &       )
   ww2d(1:ie, 1:je, :) = 0.0_8
   wd(1:ie, 1:je, nz, :) = wd(1:ie, 1:je, nz, :) + ww3d(1:ie, 1:je, :&
   &       )
   ww3d(1:ie, 1:je, :) = 0.0_8
   END IF
   END SUBROUTINE SETBCPOINTERS_B
   SUBROUTINE SETBCPOINTERS(nn, spatialpointers)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * setBCPointers sets the pointers needed for the boundary        *
   !      * condition treatment on a general face, such that the boundary  *
   !      * routines are only implemented once instead of 6 times.         *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   LOGICAL, INTENT(IN) :: spatialpointers
   ! Determine the sizes of each face and point to just the range we
   ! need on each face. 
   istart = bcdata(nn)%icbeg
   iend = bcdata(nn)%icend
   jstart = bcdata(nn)%jcbeg
   jend = bcdata(nn)%jcend
   ! Set the size of the subface
   isize = iend - istart + 1
   jsize = jend - jstart + 1
   ! Determine the face id on which the subface is located and set
   ! the pointers accordinly.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   !===============================================================
   ww3(1:je, 1:ke, :) = w(3, 1:je, 1:ke, :)
   ww2(1:je, 1:ke, :) = w(2, 1:je, 1:ke, :)
   ww1(1:je, 1:ke, :) = w(1, 1:je, 1:ke, :)
   ww0(1:je, 1:ke, :) = w(0, 1:je, 1:ke, :)
   pp3(1:je, 1:ke) = p(3, 1:je, 1:ke)
   pp2(1:je, 1:ke) = p(2, 1:je, 1:ke)
   pp1(1:je, 1:ke) = p(1, 1:je, 1:ke)
   pp0(1:je, 1:ke) = p(0, 1:je, 1:ke)
   rlv3(1:je, 1:ke) = rlv(3, 1:je, 1:ke)
   rlv2(1:je, 1:ke) = rlv(2, 1:je, 1:ke)
   rlv1(1:je, 1:ke) = rlv(1, 1:je, 1:ke)
   rlv0(1:je, 1:ke) = rlv(0, 1:je, 1:ke)
   rev3(1:je, 1:ke) = rev(3, 1:je, 1:ke)
   rev2(1:je, 1:ke) = rev(2, 1:je, 1:ke)
   rev1(1:je, 1:ke) = rev(1, 1:je, 1:ke)
   rev0(1:je, 1:ke) = rev(0, 1:je, 1:ke)
   gamma3(1:je, 1:ke) = gamma(3, 1:je, 1:ke)
   gamma2(1:je, 1:ke) = gamma(2, 1:je, 1:ke)
   gamma1(1:je, 1:ke) = gamma(1, 1:je, 1:ke)
   gamma0(1:je, 1:ke) = gamma(0, 1:je, 1:ke)
   CASE (imax) 
   !===============================================================
   ww3(1:je, 1:ke, :) = w(nx, 1:je, 1:ke, :)
   ww2(1:je, 1:ke, :) = w(il, 1:je, 1:ke, :)
   ww1(1:je, 1:ke, :) = w(ie, 1:je, 1:ke, :)
   ww0(1:je, 1:ke, :) = w(ib, 1:je, 1:ke, :)
   pp3(1:je, 1:ke) = p(nx, 1:je, 1:ke)
   pp2(1:je, 1:ke) = p(il, 1:je, 1:ke)
   pp1(1:je, 1:ke) = p(ie, 1:je, 1:ke)
   pp0(1:je, 1:ke) = p(ib, 1:je, 1:ke)
   rlv3(1:je, 1:ke) = rlv(nx, 1:je, 1:ke)
   rlv2(1:je, 1:ke) = rlv(il, 1:je, 1:ke)
   rlv1(1:je, 1:ke) = rlv(ie, 1:je, 1:ke)
   rlv0(1:je, 1:ke) = rlv(ib, 1:je, 1:ke)
   rev3(1:je, 1:ke) = rev(nx, 1:je, 1:ke)
   rev2(1:je, 1:ke) = rev(il, 1:je, 1:ke)
   rev1(1:je, 1:ke) = rev(ie, 1:je, 1:ke)
   rev0(1:je, 1:ke) = rev(ib, 1:je, 1:ke)
   gamma3(1:je, 1:ke) = gamma(nx, 1:je, 1:ke)
   gamma2(1:je, 1:ke) = gamma(il, 1:je, 1:ke)
   gamma1(1:je, 1:ke) = gamma(ie, 1:je, 1:ke)
   gamma0(1:je, 1:ke) = gamma(ib, 1:je, 1:ke)
   CASE (jmin) 
   !===============================================================
   ww3(1:ie, 1:ke, :) = w(1:ie, 3, 1:ke, :)
   ww2(1:ie, 1:ke, :) = w(1:ie, 2, 1:ke, :)
   ww1(1:ie, 1:ke, :) = w(1:ie, 1, 1:ke, :)
   ww0(1:ie, 1:ke, :) = w(1:ie, 0, 1:ke, :)
   pp3(1:ie, 1:ke) = p(1:ie, 3, 1:ke)
   pp2(1:ie, 1:ke) = p(1:ie, 2, 1:ke)
   pp1(1:ie, 1:ke) = p(1:ie, 1, 1:ke)
   pp0(1:ie, 1:ke) = p(1:ie, 0, 1:ke)
   rlv3(1:ie, 1:ke) = rlv(1:ie, 3, 1:ke)
   rlv2(1:ie, 1:ke) = rlv(1:ie, 2, 1:ke)
   rlv1(1:ie, 1:ke) = rlv(1:ie, 1, 1:ke)
   rlv0(1:ie, 1:ke) = rlv(1:ie, 0, 1:ke)
   rev3(1:ie, 1:ke) = rev(1:ie, 3, 1:ke)
   rev2(1:ie, 1:ke) = rev(1:ie, 2, 1:ke)
   rev1(1:ie, 1:ke) = rev(1:ie, 1, 1:ke)
   rev0(1:ie, 1:ke) = rev(1:ie, 0, 1:ke)
   gamma3(1:ie, 1:ke) = gamma(1:ie, 3, 1:ke)
   gamma2(1:ie, 1:ke) = gamma(1:ie, 2, 1:ke)
   gamma1(1:ie, 1:ke) = gamma(1:ie, 1, 1:ke)
   gamma0(1:ie, 1:ke) = gamma(1:ie, 0, 1:ke)
   CASE (jmax) 
   !===============================================================
   ww3(1:ie, 1:ke, :) = w(1:ie, ny, 1:ke, :)
   ww2(1:ie, 1:ke, :) = w(1:ie, jl, 1:ke, :)
   ww1(1:ie, 1:ke, :) = w(1:ie, je, 1:ke, :)
   ww0(1:ie, 1:ke, :) = w(1:ie, jb, 1:ke, :)
   pp3(1:ie, 1:ke) = p(1:ie, ny, 1:ke)
   pp2(1:ie, 1:ke) = p(1:ie, jl, 1:ke)
   pp1(1:ie, 1:ke) = p(1:ie, je, 1:ke)
   pp0(1:ie, 1:ke) = p(1:ie, jb, 1:ke)
   rlv3(1:ie, 1:ke) = rlv(1:ie, ny, 1:ke)
   rlv2(1:ie, 1:ke) = rlv(1:ie, jl, 1:ke)
   rlv1(1:ie, 1:ke) = rlv(1:ie, je, 1:ke)
   rlv0(1:ie, 1:ke) = rlv(1:ie, jb, 1:ke)
   rev3(1:ie, 1:ke) = rev(1:ie, ny, 1:ke)
   rev2(1:ie, 1:ke) = rev(1:ie, jl, 1:ke)
   rev1(1:ie, 1:ke) = rev(1:ie, je, 1:ke)
   rev0(1:ie, 1:ke) = rev(1:ie, jb, 1:ke)
   gamma3(1:ie, 1:ke) = gamma(1:ie, ny, 1:ke)
   gamma2(1:ie, 1:ke) = gamma(1:ie, jl, 1:ke)
   gamma1(1:ie, 1:ke) = gamma(1:ie, je, 1:ke)
   gamma0(1:ie, 1:ke) = gamma(1:ie, jb, 1:ke)
   CASE (kmin) 
   !===============================================================
   ww3(1:ie, 1:je, :) = w(1:ie, 1:je, 3, :)
   ww2(1:ie, 1:je, :) = w(1:ie, 1:je, 2, :)
   ww1(1:ie, 1:je, :) = w(1:ie, 1:je, 1, :)
   ww0(1:ie, 1:je, :) = w(1:ie, 1:je, 0, :)
   pp3(1:ie, 1:je) = p(1:ie, 1:je, 3)
   pp2(1:ie, 1:je) = p(1:ie, 1:je, 2)
   pp1(1:ie, 1:je) = p(1:ie, 1:je, 1)
   pp0(1:ie, 1:je) = p(1:ie, 1:je, 0)
   rlv3(1:ie, 1:je) = rlv(1:ie, 1:je, 3)
   rlv2(1:ie, 1:je) = rlv(1:ie, 1:je, 2)
   rlv1(1:ie, 1:je) = rlv(1:ie, 1:je, 1)
   rlv0(1:ie, 1:je) = rlv(1:ie, 1:je, 0)
   rev3(1:ie, 1:je) = rev(1:ie, 1:je, 3)
   rev2(1:ie, 1:je) = rev(1:ie, 1:je, 2)
   rev1(1:ie, 1:je) = rev(1:ie, 1:je, 1)
   rev0(1:ie, 1:je) = rev(1:ie, 1:je, 0)
   gamma3(1:ie, 1:je) = gamma(1:ie, 1:je, 3)
   gamma2(1:ie, 1:je) = gamma(1:ie, 1:je, 2)
   gamma1(1:ie, 1:je) = gamma(1:ie, 1:je, 1)
   gamma0(1:ie, 1:je) = gamma(1:ie, 1:je, 0)
   CASE (kmax) 
   !===============================================================
   ww3(1:ie, 1:je, :) = w(1:ie, 1:je, nz, :)
   ww2(1:ie, 1:je, :) = w(1:ie, 1:je, kl, :)
   ww1(1:ie, 1:je, :) = w(1:ie, 1:je, ke, :)
   ww0(1:ie, 1:je, :) = w(1:ie, 1:je, kb, :)
   pp3(1:ie, 1:je) = p(1:ie, 1:je, nz)
   pp2(1:ie, 1:je) = p(1:ie, 1:je, kl)
   pp1(1:ie, 1:je) = p(1:ie, 1:je, ke)
   pp0(1:ie, 1:je) = p(1:ie, 1:je, kb)
   rlv3(1:ie, 1:je) = rlv(1:ie, 1:je, nz)
   rlv2(1:ie, 1:je) = rlv(1:ie, 1:je, kl)
   rlv1(1:ie, 1:je) = rlv(1:ie, 1:je, ke)
   rlv0(1:ie, 1:je) = rlv(1:ie, 1:je, kb)
   rev3(1:ie, 1:je) = rev(1:ie, 1:je, nz)
   rev2(1:ie, 1:je) = rev(1:ie, 1:je, kl)
   rev1(1:ie, 1:je) = rev(1:ie, 1:je, ke)
   rev0(1:ie, 1:je) = rev(1:ie, 1:je, kb)
   gamma3(1:ie, 1:je) = gamma(1:ie, 1:je, nz)
   gamma2(1:ie, 1:je) = gamma(1:ie, 1:je, kl)
   gamma1(1:ie, 1:je) = gamma(1:ie, 1:je, ke)
   gamma0(1:ie, 1:je) = gamma(1:ie, 1:je, kb)
   END SELECT
   ! These spatial pointers are only required for
   ! forcesAndMoments. Eulerwall normal moment is is reverse AD'ed.
   IF (spatialpointers) THEN
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   xx(1:je+1, 1:ke+1, :) = x(1, 0:je, 0:ke, :)
   ssi(1:je, 1:ke, :) = si(1, 1:je, 1:ke, :)
   CASE (imax) 
   xx(1:je+1, 1:ke+1, :) = x(il, 0:je, 0:ke, :)
   ssi(1:je, 1:ke, :) = si(il, 1:je, 1:ke, :)
   CASE (jmin) 
   xx(1:ie+1, 1:ke+1, :) = x(0:ie, 1, 0:ke, :)
   ssi(1:ie, 1:ke, :) = sj(1:ie, 1, 1:ke, :)
   CASE (jmax) 
   xx(1:ie+1, 1:ke+1, :) = x(0:ie, jl, 0:ke, :)
   ssi(1:ie, 1:ke, :) = sj(1:ie, jl, 1:ke, :)
   CASE (kmin) 
   xx(1:ie+1, 1:je+1, :) = x(0:ie, 0:je, 1, :)
   ssi(1:ie, 1:je, :) = sk(1:ie, 1:je, 1, :)
   CASE (kmax) 
   xx(1:ie+1, 1:je+1, :) = x(0:ie, 0:je, kl, :)
   ssi(1:ie, 1:je, :) = sk(1:ie, 1:je, kl, :)
   END SELECT
   END IF
   END SUBROUTINE SETBCPOINTERS
   !  Differentiation of resetbcpointers in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *p *w *rlv *x *si *sj
   !                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
   !                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
   !                *ww3
   !   with respect to varying inputs: *rev *p *w *rlv *x *si *sj
   !                *sk *xx *rev0 *rev1 *rev2 *rev3 *pp0 *pp1 *pp2
   !                *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ssi *ww0 *ww1 *ww2
   !                *ww3
   !   Plus diff mem management of: rev:in p:in w:in rlv:in x:in si:in
   !                sj:in sk:in xx:in rev0:in rev1:in rev2:in rev3:in
   !                pp0:in pp1:in pp2:in pp3:in rlv0:in rlv1:in rlv2:in
   !                rlv3:in ssi:in ww0:in ww1:in ww2:in ww3:in
   SUBROUTINE RESETBCPOINTERS_B(nn, spatialpointers)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * resetBCPointers nullifyies the boundary pointers. For reverse  *
   !      * mode AD it copies the values back in to the respective arrays  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   LOGICAL, INTENT(IN) :: spatialpointers
   INTEGER :: branch
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   CALL PUSHCONTROL3B(1)
   CASE (imax) 
   CALL PUSHCONTROL3B(2)
   CASE (jmin) 
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   CALL PUSHCONTROL3B(4)
   CASE (kmin) 
   CALL PUSHCONTROL3B(5)
   CASE (kmax) 
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   ! These spatial pointers are only required for
   ! forcesAndMoments. Eulerwall normal moment is is reverse AD'ed.
   IF (spatialpointers) THEN
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   ssid(1:je, 1:ke, :) = ssid(1:je, 1:ke, :) + sid(1, 1:je, 1:ke, :&
   &         )
   sid(1, 1:je, 1:ke, :) = 0.0_8
   xxd(1:je+1, 1:ke+1, :) = xxd(1:je+1, 1:ke+1, :) + xd(1, 0:je, 0:&
   &         ke, :)
   xd(1, 0:je, 0:ke, :) = 0.0_8
   CASE (imax) 
   ssid(1:je, 1:ke, :) = ssid(1:je, 1:ke, :) + sid(il, 1:je, 1:ke, &
   &         :)
   sid(il, 1:je, 1:ke, :) = 0.0_8
   xxd(1:je+1, 1:ke+1, :) = xxd(1:je+1, 1:ke+1, :) + xd(il, 0:je, 0&
   &         :ke, :)
   xd(il, 0:je, 0:ke, :) = 0.0_8
   CASE (jmin) 
   ssid(1:ie, 1:ke, :) = ssid(1:ie, 1:ke, :) + sjd(1:ie, 1, 1:ke, :&
   &         )
   sjd(1:ie, 1, 1:ke, :) = 0.0_8
   xxd(1:ie+1, 1:ke+1, :) = xxd(1:ie+1, 1:ke+1, :) + xd(0:ie, 1, 0:&
   &         ke, :)
   xd(0:ie, 1, 0:ke, :) = 0.0_8
   CASE (jmax) 
   ssid(1:ie, 1:ke, :) = ssid(1:ie, 1:ke, :) + sjd(1:ie, jl, 1:ke, &
   &         :)
   sjd(1:ie, jl, 1:ke, :) = 0.0_8
   xxd(1:ie+1, 1:ke+1, :) = xxd(1:ie+1, 1:ke+1, :) + xd(0:ie, jl, 0&
   &         :ke, :)
   xd(0:ie, jl, 0:ke, :) = 0.0_8
   CASE (kmin) 
   ssid(1:ie, 1:je, :) = ssid(1:ie, 1:je, :) + skd(1:ie, 1:je, 1, :&
   &         )
   skd(1:ie, 1:je, 1, :) = 0.0_8
   xxd(1:ie+1, 1:je+1, :) = xxd(1:ie+1, 1:je+1, :) + xd(0:ie, 0:je&
   &         , 1, :)
   xd(0:ie, 0:je, 1, :) = 0.0_8
   CASE (kmax) 
   ssid(1:ie, 1:je, :) = ssid(1:ie, 1:je, :) + skd(1:ie, 1:je, kl, &
   &         :)
   skd(1:ie, 1:je, kl, :) = 0.0_8
   xxd(1:ie+1, 1:je+1, :) = xxd(1:ie+1, 1:je+1, :) + xd(0:ie, 0:je&
   &         , kl, :)
   xd(0:ie, 0:je, kl, :) = 0.0_8
   END SELECT
   END IF
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .NE. 0) THEN
   IF (branch .EQ. 1) THEN
   rev0d(1:je, 1:ke) = rev0d(1:je, 1:ke) + revd(0, 1:je, 1:ke)
   revd(0, 1:je, 1:ke) = 0.0_8
   rev1d(1:je, 1:ke) = rev1d(1:je, 1:ke) + revd(1, 1:je, 1:ke)
   revd(1, 1:je, 1:ke) = 0.0_8
   rev2d(1:je, 1:ke) = rev2d(1:je, 1:ke) + revd(2, 1:je, 1:ke)
   revd(2, 1:je, 1:ke) = 0.0_8
   rev3d(1:je, 1:ke) = rev3d(1:je, 1:ke) + revd(3, 1:je, 1:ke)
   revd(3, 1:je, 1:ke) = 0.0_8
   rlv0d(1:je, 1:ke) = rlv0d(1:je, 1:ke) + rlvd(0, 1:je, 1:ke)
   rlvd(0, 1:je, 1:ke) = 0.0_8
   rlv1d(1:je, 1:ke) = rlv1d(1:je, 1:ke) + rlvd(1, 1:je, 1:ke)
   rlvd(1, 1:je, 1:ke) = 0.0_8
   rlv2d(1:je, 1:ke) = rlv2d(1:je, 1:ke) + rlvd(2, 1:je, 1:ke)
   rlvd(2, 1:je, 1:ke) = 0.0_8
   rlv3d(1:je, 1:ke) = rlv3d(1:je, 1:ke) + rlvd(3, 1:je, 1:ke)
   rlvd(3, 1:je, 1:ke) = 0.0_8
   pp0d(1:je, 1:ke) = pp0d(1:je, 1:ke) + pd(0, 1:je, 1:ke)
   pd(0, 1:je, 1:ke) = 0.0_8
   pp1d(1:je, 1:ke) = pp1d(1:je, 1:ke) + pd(1, 1:je, 1:ke)
   pd(1, 1:je, 1:ke) = 0.0_8
   pp2d(1:je, 1:ke) = pp2d(1:je, 1:ke) + pd(2, 1:je, 1:ke)
   pd(2, 1:je, 1:ke) = 0.0_8
   pp3d(1:je, 1:ke) = pp3d(1:je, 1:ke) + pd(3, 1:je, 1:ke)
   pd(3, 1:je, 1:ke) = 0.0_8
   ww0d(1:je, 1:ke, :) = ww0d(1:je, 1:ke, :) + wd(0, 1:je, 1:ke, &
   &           :)
   wd(0, 1:je, 1:ke, :) = 0.0_8
   ww1d(1:je, 1:ke, :) = ww1d(1:je, 1:ke, :) + wd(1, 1:je, 1:ke, &
   &           :)
   wd(1, 1:je, 1:ke, :) = 0.0_8
   ww2d(1:je, 1:ke, :) = ww2d(1:je, 1:ke, :) + wd(2, 1:je, 1:ke, &
   &           :)
   wd(2, 1:je, 1:ke, :) = 0.0_8
   ww3d(1:je, 1:ke, :) = ww3d(1:je, 1:ke, :) + wd(3, 1:je, 1:ke, &
   &           :)
   wd(3, 1:je, 1:ke, :) = 0.0_8
   ELSE
   rev0d(1:je, 1:ke) = rev0d(1:je, 1:ke) + revd(ib, 1:je, 1:ke)
   revd(ib, 1:je, 1:ke) = 0.0_8
   rev1d(1:je, 1:ke) = rev1d(1:je, 1:ke) + revd(ie, 1:je, 1:ke)
   revd(ie, 1:je, 1:ke) = 0.0_8
   rev2d(1:je, 1:ke) = rev2d(1:je, 1:ke) + revd(il, 1:je, 1:ke)
   revd(il, 1:je, 1:ke) = 0.0_8
   rev3d(1:je, 1:ke) = rev3d(1:je, 1:ke) + revd(nx, 1:je, 1:ke)
   revd(nx, 1:je, 1:ke) = 0.0_8
   rlv0d(1:je, 1:ke) = rlv0d(1:je, 1:ke) + rlvd(ib, 1:je, 1:ke)
   rlvd(ib, 1:je, 1:ke) = 0.0_8
   rlv1d(1:je, 1:ke) = rlv1d(1:je, 1:ke) + rlvd(ie, 1:je, 1:ke)
   rlvd(ie, 1:je, 1:ke) = 0.0_8
   rlv2d(1:je, 1:ke) = rlv2d(1:je, 1:ke) + rlvd(il, 1:je, 1:ke)
   rlvd(il, 1:je, 1:ke) = 0.0_8
   rlv3d(1:je, 1:ke) = rlv3d(1:je, 1:ke) + rlvd(nx, 1:je, 1:ke)
   rlvd(nx, 1:je, 1:ke) = 0.0_8
   pp0d(1:je, 1:ke) = pp0d(1:je, 1:ke) + pd(ib, 1:je, 1:ke)
   pd(ib, 1:je, 1:ke) = 0.0_8
   pp1d(1:je, 1:ke) = pp1d(1:je, 1:ke) + pd(ie, 1:je, 1:ke)
   pd(ie, 1:je, 1:ke) = 0.0_8
   pp2d(1:je, 1:ke) = pp2d(1:je, 1:ke) + pd(il, 1:je, 1:ke)
   pd(il, 1:je, 1:ke) = 0.0_8
   pp3d(1:je, 1:ke) = pp3d(1:je, 1:ke) + pd(nx, 1:je, 1:ke)
   pd(nx, 1:je, 1:ke) = 0.0_8
   ww0d(1:je, 1:ke, :) = ww0d(1:je, 1:ke, :) + wd(ib, 1:je, 1:ke&
   &           , :)
   wd(ib, 1:je, 1:ke, :) = 0.0_8
   ww1d(1:je, 1:ke, :) = ww1d(1:je, 1:ke, :) + wd(ie, 1:je, 1:ke&
   &           , :)
   wd(ie, 1:je, 1:ke, :) = 0.0_8
   ww2d(1:je, 1:ke, :) = ww2d(1:je, 1:ke, :) + wd(il, 1:je, 1:ke&
   &           , :)
   wd(il, 1:je, 1:ke, :) = 0.0_8
   ww3d(1:je, 1:ke, :) = ww3d(1:je, 1:ke, :) + wd(nx, 1:je, 1:ke&
   &           , :)
   wd(nx, 1:je, 1:ke, :) = 0.0_8
   END IF
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   rev0d(1:ie, 1:ke) = rev0d(1:ie, 1:ke) + revd(1:ie, 0, 1:ke)
   revd(1:ie, 0, 1:ke) = 0.0_8
   rev1d(1:ie, 1:ke) = rev1d(1:ie, 1:ke) + revd(1:ie, 1, 1:ke)
   revd(1:ie, 1, 1:ke) = 0.0_8
   rev2d(1:ie, 1:ke) = rev2d(1:ie, 1:ke) + revd(1:ie, 2, 1:ke)
   revd(1:ie, 2, 1:ke) = 0.0_8
   rev3d(1:ie, 1:ke) = rev3d(1:ie, 1:ke) + revd(1:ie, 3, 1:ke)
   revd(1:ie, 3, 1:ke) = 0.0_8
   rlv0d(1:ie, 1:ke) = rlv0d(1:ie, 1:ke) + rlvd(1:ie, 0, 1:ke)
   rlvd(1:ie, 0, 1:ke) = 0.0_8
   rlv1d(1:ie, 1:ke) = rlv1d(1:ie, 1:ke) + rlvd(1:ie, 1, 1:ke)
   rlvd(1:ie, 1, 1:ke) = 0.0_8
   rlv2d(1:ie, 1:ke) = rlv2d(1:ie, 1:ke) + rlvd(1:ie, 2, 1:ke)
   rlvd(1:ie, 2, 1:ke) = 0.0_8
   rlv3d(1:ie, 1:ke) = rlv3d(1:ie, 1:ke) + rlvd(1:ie, 3, 1:ke)
   rlvd(1:ie, 3, 1:ke) = 0.0_8
   pp0d(1:ie, 1:ke) = pp0d(1:ie, 1:ke) + pd(1:ie, 0, 1:ke)
   pd(1:ie, 0, 1:ke) = 0.0_8
   pp1d(1:ie, 1:ke) = pp1d(1:ie, 1:ke) + pd(1:ie, 1, 1:ke)
   pd(1:ie, 1, 1:ke) = 0.0_8
   pp2d(1:ie, 1:ke) = pp2d(1:ie, 1:ke) + pd(1:ie, 2, 1:ke)
   pd(1:ie, 2, 1:ke) = 0.0_8
   pp3d(1:ie, 1:ke) = pp3d(1:ie, 1:ke) + pd(1:ie, 3, 1:ke)
   pd(1:ie, 3, 1:ke) = 0.0_8
   ww0d(1:ie, 1:ke, :) = ww0d(1:ie, 1:ke, :) + wd(1:ie, 0, 1:ke, :)
   wd(1:ie, 0, 1:ke, :) = 0.0_8
   ww1d(1:ie, 1:ke, :) = ww1d(1:ie, 1:ke, :) + wd(1:ie, 1, 1:ke, :)
   wd(1:ie, 1, 1:ke, :) = 0.0_8
   ww2d(1:ie, 1:ke, :) = ww2d(1:ie, 1:ke, :) + wd(1:ie, 2, 1:ke, :)
   wd(1:ie, 2, 1:ke, :) = 0.0_8
   ww3d(1:ie, 1:ke, :) = ww3d(1:ie, 1:ke, :) + wd(1:ie, 3, 1:ke, :)
   wd(1:ie, 3, 1:ke, :) = 0.0_8
   ELSE
   rev0d(1:ie, 1:ke) = rev0d(1:ie, 1:ke) + revd(1:ie, jb, 1:ke)
   revd(1:ie, jb, 1:ke) = 0.0_8
   rev1d(1:ie, 1:ke) = rev1d(1:ie, 1:ke) + revd(1:ie, je, 1:ke)
   revd(1:ie, je, 1:ke) = 0.0_8
   rev2d(1:ie, 1:ke) = rev2d(1:ie, 1:ke) + revd(1:ie, jl, 1:ke)
   revd(1:ie, jl, 1:ke) = 0.0_8
   rev3d(1:ie, 1:ke) = rev3d(1:ie, 1:ke) + revd(1:ie, ny, 1:ke)
   revd(1:ie, ny, 1:ke) = 0.0_8
   rlv0d(1:ie, 1:ke) = rlv0d(1:ie, 1:ke) + rlvd(1:ie, jb, 1:ke)
   rlvd(1:ie, jb, 1:ke) = 0.0_8
   rlv1d(1:ie, 1:ke) = rlv1d(1:ie, 1:ke) + rlvd(1:ie, je, 1:ke)
   rlvd(1:ie, je, 1:ke) = 0.0_8
   rlv2d(1:ie, 1:ke) = rlv2d(1:ie, 1:ke) + rlvd(1:ie, jl, 1:ke)
   rlvd(1:ie, jl, 1:ke) = 0.0_8
   rlv3d(1:ie, 1:ke) = rlv3d(1:ie, 1:ke) + rlvd(1:ie, ny, 1:ke)
   rlvd(1:ie, ny, 1:ke) = 0.0_8
   pp0d(1:ie, 1:ke) = pp0d(1:ie, 1:ke) + pd(1:ie, jb, 1:ke)
   pd(1:ie, jb, 1:ke) = 0.0_8
   pp1d(1:ie, 1:ke) = pp1d(1:ie, 1:ke) + pd(1:ie, je, 1:ke)
   pd(1:ie, je, 1:ke) = 0.0_8
   pp2d(1:ie, 1:ke) = pp2d(1:ie, 1:ke) + pd(1:ie, jl, 1:ke)
   pd(1:ie, jl, 1:ke) = 0.0_8
   pp3d(1:ie, 1:ke) = pp3d(1:ie, 1:ke) + pd(1:ie, ny, 1:ke)
   pd(1:ie, ny, 1:ke) = 0.0_8
   ww0d(1:ie, 1:ke, :) = ww0d(1:ie, 1:ke, :) + wd(1:ie, jb, 1:ke, :&
   &         )
   wd(1:ie, jb, 1:ke, :) = 0.0_8
   ww1d(1:ie, 1:ke, :) = ww1d(1:ie, 1:ke, :) + wd(1:ie, je, 1:ke, :&
   &         )
   wd(1:ie, je, 1:ke, :) = 0.0_8
   ww2d(1:ie, 1:ke, :) = ww2d(1:ie, 1:ke, :) + wd(1:ie, jl, 1:ke, :&
   &         )
   wd(1:ie, jl, 1:ke, :) = 0.0_8
   ww3d(1:ie, 1:ke, :) = ww3d(1:ie, 1:ke, :) + wd(1:ie, ny, 1:ke, :&
   &         )
   wd(1:ie, ny, 1:ke, :) = 0.0_8
   END IF
   ELSE IF (branch .EQ. 5) THEN
   rev0d(1:ie, 1:je) = rev0d(1:ie, 1:je) + revd(1:ie, 1:je, 0)
   revd(1:ie, 1:je, 0) = 0.0_8
   rev1d(1:ie, 1:je) = rev1d(1:ie, 1:je) + revd(1:ie, 1:je, 1)
   revd(1:ie, 1:je, 1) = 0.0_8
   rev2d(1:ie, 1:je) = rev2d(1:ie, 1:je) + revd(1:ie, 1:je, 2)
   revd(1:ie, 1:je, 2) = 0.0_8
   rev3d(1:ie, 1:je) = rev3d(1:ie, 1:je) + revd(1:ie, 1:je, 3)
   revd(1:ie, 1:je, 3) = 0.0_8
   rlv0d(1:ie, 1:je) = rlv0d(1:ie, 1:je) + rlvd(1:ie, 1:je, 0)
   rlvd(1:ie, 1:je, 0) = 0.0_8
   rlv1d(1:ie, 1:je) = rlv1d(1:ie, 1:je) + rlvd(1:ie, 1:je, 1)
   rlvd(1:ie, 1:je, 1) = 0.0_8
   rlv2d(1:ie, 1:je) = rlv2d(1:ie, 1:je) + rlvd(1:ie, 1:je, 2)
   rlvd(1:ie, 1:je, 2) = 0.0_8
   rlv3d(1:ie, 1:je) = rlv3d(1:ie, 1:je) + rlvd(1:ie, 1:je, 3)
   rlvd(1:ie, 1:je, 3) = 0.0_8
   pp0d(1:ie, 1:je) = pp0d(1:ie, 1:je) + pd(1:ie, 1:je, 0)
   pd(1:ie, 1:je, 0) = 0.0_8
   pp1d(1:ie, 1:je) = pp1d(1:ie, 1:je) + pd(1:ie, 1:je, 1)
   pd(1:ie, 1:je, 1) = 0.0_8
   pp2d(1:ie, 1:je) = pp2d(1:ie, 1:je) + pd(1:ie, 1:je, 2)
   pd(1:ie, 1:je, 2) = 0.0_8
   pp3d(1:ie, 1:je) = pp3d(1:ie, 1:je) + pd(1:ie, 1:je, 3)
   pd(1:ie, 1:je, 3) = 0.0_8
   ww0d(1:ie, 1:je, :) = ww0d(1:ie, 1:je, :) + wd(1:ie, 1:je, 0, :)
   wd(1:ie, 1:je, 0, :) = 0.0_8
   ww1d(1:ie, 1:je, :) = ww1d(1:ie, 1:je, :) + wd(1:ie, 1:je, 1, :)
   wd(1:ie, 1:je, 1, :) = 0.0_8
   ww2d(1:ie, 1:je, :) = ww2d(1:ie, 1:je, :) + wd(1:ie, 1:je, 2, :)
   wd(1:ie, 1:je, 2, :) = 0.0_8
   ww3d(1:ie, 1:je, :) = ww3d(1:ie, 1:je, :) + wd(1:ie, 1:je, 3, :)
   wd(1:ie, 1:je, 3, :) = 0.0_8
   ELSE
   rev0d(1:ie, 1:je) = rev0d(1:ie, 1:je) + revd(1:ie, 1:je, kb)
   revd(1:ie, 1:je, kb) = 0.0_8
   rev1d(1:ie, 1:je) = rev1d(1:ie, 1:je) + revd(1:ie, 1:je, ke)
   revd(1:ie, 1:je, ke) = 0.0_8
   rev2d(1:ie, 1:je) = rev2d(1:ie, 1:je) + revd(1:ie, 1:je, kl)
   revd(1:ie, 1:je, kl) = 0.0_8
   rev3d(1:ie, 1:je) = rev3d(1:ie, 1:je) + revd(1:ie, 1:je, nz)
   revd(1:ie, 1:je, nz) = 0.0_8
   rlv0d(1:ie, 1:je) = rlv0d(1:ie, 1:je) + rlvd(1:ie, 1:je, kb)
   rlvd(1:ie, 1:je, kb) = 0.0_8
   rlv1d(1:ie, 1:je) = rlv1d(1:ie, 1:je) + rlvd(1:ie, 1:je, ke)
   rlvd(1:ie, 1:je, ke) = 0.0_8
   rlv2d(1:ie, 1:je) = rlv2d(1:ie, 1:je) + rlvd(1:ie, 1:je, kl)
   rlvd(1:ie, 1:je, kl) = 0.0_8
   rlv3d(1:ie, 1:je) = rlv3d(1:ie, 1:je) + rlvd(1:ie, 1:je, nz)
   rlvd(1:ie, 1:je, nz) = 0.0_8
   pp0d(1:ie, 1:je) = pp0d(1:ie, 1:je) + pd(1:ie, 1:je, kb)
   pd(1:ie, 1:je, kb) = 0.0_8
   pp1d(1:ie, 1:je) = pp1d(1:ie, 1:je) + pd(1:ie, 1:je, ke)
   pd(1:ie, 1:je, ke) = 0.0_8
   pp2d(1:ie, 1:je) = pp2d(1:ie, 1:je) + pd(1:ie, 1:je, kl)
   pd(1:ie, 1:je, kl) = 0.0_8
   pp3d(1:ie, 1:je) = pp3d(1:ie, 1:je) + pd(1:ie, 1:je, nz)
   pd(1:ie, 1:je, nz) = 0.0_8
   ww0d(1:ie, 1:je, :) = ww0d(1:ie, 1:je, :) + wd(1:ie, 1:je, kb, :)
   wd(1:ie, 1:je, kb, :) = 0.0_8
   ww1d(1:ie, 1:je, :) = ww1d(1:ie, 1:je, :) + wd(1:ie, 1:je, ke, :)
   wd(1:ie, 1:je, ke, :) = 0.0_8
   ww2d(1:ie, 1:je, :) = ww2d(1:ie, 1:je, :) + wd(1:ie, 1:je, kl, :)
   wd(1:ie, 1:je, kl, :) = 0.0_8
   ww3d(1:ie, 1:je, :) = ww3d(1:ie, 1:je, :) + wd(1:ie, 1:je, nz, :)
   wd(1:ie, 1:je, nz, :) = 0.0_8
   END IF
   END SUBROUTINE RESETBCPOINTERS_B
   SUBROUTINE RESETBCPOINTERS(nn, spatialpointers)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * resetBCPointers nullifyies the boundary pointers. For reverse  *
   !      * mode AD it copies the values back in to the respective arrays  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Subroutine arguments.
   INTEGER(kind=inttype), INTENT(IN) :: nn
   LOGICAL, INTENT(IN) :: spatialpointers
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   !===============================================================
   w(3, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
   w(2, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
   w(1, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
   w(0, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
   p(3, 1:je, 1:ke) = pp3(1:je, 1:ke)
   p(2, 1:je, 1:ke) = pp2(1:je, 1:ke)
   p(1, 1:je, 1:ke) = pp1(1:je, 1:ke)
   p(0, 1:je, 1:ke) = pp0(1:je, 1:ke)
   rlv(3, 1:je, 1:ke) = rlv3(1:je, 1:ke)
   rlv(2, 1:je, 1:ke) = rlv2(1:je, 1:ke)
   rlv(1, 1:je, 1:ke) = rlv1(1:je, 1:ke)
   rlv(0, 1:je, 1:ke) = rlv0(1:je, 1:ke)
   rev(3, 1:je, 1:ke) = rev3(1:je, 1:ke)
   rev(2, 1:je, 1:ke) = rev2(1:je, 1:ke)
   rev(1, 1:je, 1:ke) = rev1(1:je, 1:ke)
   rev(0, 1:je, 1:ke) = rev0(1:je, 1:ke)
   gamma(3, 1:je, 1:ke) = gamma3(1:je, 1:ke)
   gamma(2, 1:je, 1:ke) = gamma2(1:je, 1:ke)
   gamma(1, 1:je, 1:ke) = gamma1(1:je, 1:ke)
   gamma(0, 1:je, 1:ke) = gamma0(1:je, 1:ke)
   CASE (imax) 
   !===============================================================
   w(nx, 1:je, 1:ke, :) = ww3(1:je, 1:ke, :)
   w(il, 1:je, 1:ke, :) = ww2(1:je, 1:ke, :)
   w(ie, 1:je, 1:ke, :) = ww1(1:je, 1:ke, :)
   w(ib, 1:je, 1:ke, :) = ww0(1:je, 1:ke, :)
   p(nx, 1:je, 1:ke) = pp3(1:je, 1:ke)
   p(il, 1:je, 1:ke) = pp2(1:je, 1:ke)
   p(ie, 1:je, 1:ke) = pp1(1:je, 1:ke)
   p(ib, 1:je, 1:ke) = pp0(1:je, 1:ke)
   rlv(nx, 1:je, 1:ke) = rlv3(1:je, 1:ke)
   rlv(il, 1:je, 1:ke) = rlv2(1:je, 1:ke)
   rlv(ie, 1:je, 1:ke) = rlv1(1:je, 1:ke)
   rlv(ib, 1:je, 1:ke) = rlv0(1:je, 1:ke)
   rev(nx, 1:je, 1:ke) = rev3(1:je, 1:ke)
   rev(il, 1:je, 1:ke) = rev2(1:je, 1:ke)
   rev(ie, 1:je, 1:ke) = rev1(1:je, 1:ke)
   rev(ib, 1:je, 1:ke) = rev0(1:je, 1:ke)
   gamma(nx, 1:je, 1:ke) = gamma3(1:je, 1:ke)
   gamma(il, 1:je, 1:ke) = gamma2(1:je, 1:ke)
   gamma(ie, 1:je, 1:ke) = gamma1(1:je, 1:ke)
   gamma(ib, 1:je, 1:ke) = gamma0(1:je, 1:ke)
   CASE (jmin) 
   !===============================================================
   w(1:ie, 3, 1:ke, :) = ww3(1:ie, 1:ke, :)
   w(1:ie, 2, 1:ke, :) = ww2(1:ie, 1:ke, :)
   w(1:ie, 1, 1:ke, :) = ww1(1:ie, 1:ke, :)
   w(1:ie, 0, 1:ke, :) = ww0(1:ie, 1:ke, :)
   p(1:ie, 3, 1:ke) = pp3(1:ie, 1:ke)
   p(1:ie, 2, 1:ke) = pp2(1:ie, 1:ke)
   p(1:ie, 1, 1:ke) = pp1(1:ie, 1:ke)
   p(1:ie, 0, 1:ke) = pp0(1:ie, 1:ke)
   rlv(1:ie, 3, 1:ke) = rlv3(1:ie, 1:ke)
   rlv(1:ie, 2, 1:ke) = rlv2(1:ie, 1:ke)
   rlv(1:ie, 1, 1:ke) = rlv1(1:ie, 1:ke)
   rlv(1:ie, 0, 1:ke) = rlv0(1:ie, 1:ke)
   rev(1:ie, 3, 1:ke) = rev3(1:ie, 1:ke)
   rev(1:ie, 2, 1:ke) = rev2(1:ie, 1:ke)
   rev(1:ie, 1, 1:ke) = rev1(1:ie, 1:ke)
   rev(1:ie, 0, 1:ke) = rev0(1:ie, 1:ke)
   gamma(1:ie, 3, 1:ke) = gamma3(1:ie, 1:ke)
   gamma(1:ie, 2, 1:ke) = gamma2(1:ie, 1:ke)
   gamma(1:ie, 1, 1:ke) = gamma1(1:ie, 1:ke)
   gamma(1:ie, 0, 1:ke) = gamma0(1:ie, 1:ke)
   CASE (jmax) 
   !===============================================================
   w(1:ie, ny, 1:ke, :) = ww3(1:ie, 1:ke, :)
   w(1:ie, jl, 1:ke, :) = ww2(1:ie, 1:ke, :)
   w(1:ie, je, 1:ke, :) = ww1(1:ie, 1:ke, :)
   w(1:ie, jb, 1:ke, :) = ww0(1:ie, 1:ke, :)
   p(1:ie, ny, 1:ke) = pp3(1:ie, 1:ke)
   p(1:ie, jl, 1:ke) = pp2(1:ie, 1:ke)
   p(1:ie, je, 1:ke) = pp1(1:ie, 1:ke)
   p(1:ie, jb, 1:ke) = pp0(1:ie, 1:ke)
   rlv(1:ie, ny, 1:ke) = rlv3(1:ie, 1:ke)
   rlv(1:ie, jl, 1:ke) = rlv2(1:ie, 1:ke)
   rlv(1:ie, je, 1:ke) = rlv1(1:ie, 1:ke)
   rlv(1:ie, jb, 1:ke) = rlv0(1:ie, 1:ke)
   rev(1:ie, ny, 1:ke) = rev3(1:ie, 1:ke)
   rev(1:ie, jl, 1:ke) = rev2(1:ie, 1:ke)
   rev(1:ie, je, 1:ke) = rev1(1:ie, 1:ke)
   rev(1:ie, jb, 1:ke) = rev0(1:ie, 1:ke)
   gamma(1:ie, ny, 1:ke) = gamma3(1:ie, 1:ke)
   gamma(1:ie, jl, 1:ke) = gamma2(1:ie, 1:ke)
   gamma(1:ie, je, 1:ke) = gamma1(1:ie, 1:ke)
   gamma(1:ie, jb, 1:ke) = gamma0(1:ie, 1:ke)
   CASE (kmin) 
   !===============================================================
   w(1:ie, 1:je, 3, :) = ww3(1:ie, 1:je, :)
   w(1:ie, 1:je, 2, :) = ww2(1:ie, 1:je, :)
   w(1:ie, 1:je, 1, :) = ww1(1:ie, 1:je, :)
   w(1:ie, 1:je, 0, :) = ww0(1:ie, 1:je, :)
   p(1:ie, 1:je, 3) = pp3(1:ie, 1:je)
   p(1:ie, 1:je, 2) = pp2(1:ie, 1:je)
   p(1:ie, 1:je, 1) = pp1(1:ie, 1:je)
   p(1:ie, 1:je, 0) = pp0(1:ie, 1:je)
   rlv(1:ie, 1:je, 3) = rlv3(1:ie, 1:je)
   rlv(1:ie, 1:je, 2) = rlv2(1:ie, 1:je)
   rlv(1:ie, 1:je, 1) = rlv1(1:ie, 1:je)
   rlv(1:ie, 1:je, 0) = rlv0(1:ie, 1:je)
   rev(1:ie, 1:je, 3) = rev3(1:ie, 1:je)
   rev(1:ie, 1:je, 2) = rev2(1:ie, 1:je)
   rev(1:ie, 1:je, 1) = rev1(1:ie, 1:je)
   rev(1:ie, 1:je, 0) = rev0(1:ie, 1:je)
   gamma(1:ie, 1:je, 3) = gamma3(1:ie, 1:je)
   gamma(1:ie, 1:je, 2) = gamma2(1:ie, 1:je)
   gamma(1:ie, 1:je, 1) = gamma1(1:ie, 1:je)
   gamma(1:ie, 1:je, 0) = gamma0(1:ie, 1:je)
   CASE (kmax) 
   !===============================================================
   w(1:ie, 1:je, nz, :) = ww3(1:ie, 1:je, :)
   w(1:ie, 1:je, kl, :) = ww2(1:ie, 1:je, :)
   w(1:ie, 1:je, ke, :) = ww1(1:ie, 1:je, :)
   w(1:ie, 1:je, kb, :) = ww0(1:ie, 1:je, :)
   p(1:ie, 1:je, nz) = pp3(1:ie, 1:je)
   p(1:ie, 1:je, kl) = pp2(1:ie, 1:je)
   p(1:ie, 1:je, ke) = pp1(1:ie, 1:je)
   p(1:ie, 1:je, kb) = pp0(1:ie, 1:je)
   rlv(1:ie, 1:je, nz) = rlv3(1:ie, 1:je)
   rlv(1:ie, 1:je, kl) = rlv2(1:ie, 1:je)
   rlv(1:ie, 1:je, ke) = rlv1(1:ie, 1:je)
   rlv(1:ie, 1:je, kb) = rlv0(1:ie, 1:je)
   rev(1:ie, 1:je, nz) = rev3(1:ie, 1:je)
   rev(1:ie, 1:je, kl) = rev2(1:ie, 1:je)
   rev(1:ie, 1:je, ke) = rev1(1:ie, 1:je)
   rev(1:ie, 1:je, kb) = rev0(1:ie, 1:je)
   gamma(1:ie, 1:je, nz) = gamma3(1:ie, 1:je)
   gamma(1:ie, 1:je, kl) = gamma2(1:ie, 1:je)
   gamma(1:ie, 1:je, ke) = gamma1(1:ie, 1:je)
   gamma(1:ie, 1:je, kb) = gamma0(1:ie, 1:je)
   END SELECT
   ! These spatial pointers are only required for
   ! forcesAndMoments. Eulerwall normal moment is is reverse AD'ed.
   IF (spatialpointers) THEN
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   x(1, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
   si(1, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
   CASE (imax) 
   x(il, 0:je, 0:ke, :) = xx(1:je+1, 1:ke+1, :)
   si(il, 1:je, 1:ke, :) = ssi(1:je, 1:ke, :)
   CASE (jmin) 
   x(0:ie, 1, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
   sj(1:ie, 1, 1:ke, :) = ssi(1:ie, 1:ke, :)
   CASE (jmax) 
   x(0:ie, jl, 0:ke, :) = xx(1:ie+1, 1:ke+1, :)
   sj(1:ie, jl, 1:ke, :) = ssi(1:ie, 1:ke, :)
   CASE (kmin) 
   x(0:ie, 0:je, 1, :) = xx(1:ie+1, 1:je+1, :)
   sk(1:ie, 1:je, 1, :) = ssi(1:ie, 1:je, :)
   CASE (kmax) 
   x(0:ie, 0:je, kl, :) = xx(1:ie+1, 1:je+1, :)
   sk(1:ie, 1:je, kl, :) = ssi(1:ie, 1:je, :)
   END SELECT
   END IF
   END SUBROUTINE RESETBCPOINTERS
   END MODULE BCROUTINES_B

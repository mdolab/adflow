   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of computelamviscosity in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: tref rgas *p *w *rlv
   !   with respect to varying inputs: muref tref rgas *p *w
   !   Plus diff mem management of: p:in w:in rlv:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          computeLamViscosity.f90                         *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-10-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE COMPUTELAMVISCOSITY_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * computeLamViscosity computes the laminar viscosity ratio in    *
   !      * the owned cell centers of the given block. Sutherland's law is *
   !      * used. It is assumed that the pointes already point to the      *
   !      * correct block before entering this subroutine.                 *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: twothird=two*third
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ii
   REAL(kind=realtype) :: musuth, tsuth, ssuth, t, pp
   REAL(kind=realtype) :: musuthd, tsuthd, ssuthd, td, ppd
   LOGICAL :: correctfork
   INTRINSIC MOD
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: temp4
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately if no laminar viscosity needs to be computed.
   IF (.NOT.viscous) THEN
   murefd = 0.0_8
   ELSE
   ! Determine whether or not the pressure must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   ! Compute the nonDimensional constants in sutherland's law.
   musuth = musuthdim/muref
   tsuth = tsuthdim/tref
   ssuth = ssuthdim/tref
   ! Substract 2/3 rho k, which is a part of the normal turbulent
   ! stresses, in case the pressure must be corrected.
   IF (correctfork) THEN
   ssuthd = 0.0_8
   musuthd = 0.0_8
   tsuthd = 0.0_8
   DO ii=0,ie*je*ke-1
   i = MOD(ii, ie) + 1
   j = MOD(ii/ie, je) + 1
   k = ii/(ie*je) + 1
   pp = p(i, j, k) - twothird*w(i, j, k, irho)*w(i, j, k, itu1)
   t = pp/(rgas*w(i, j, k, irho))
   temp2 = t/tsuth
   tempd = temp2**1.5_realType*rlvd(i, j, k)/(t+ssuth)
   temp1 = musuth*(tsuth+ssuth)/(t+ssuth)
   tempd0 = -(temp1*tempd)
   tempd1 = 1.5_realType*temp2**0.5*temp1*rlvd(i, j, k)/tsuth
   musuthd = musuthd + (tsuth+ssuth)*tempd
   tsuthd = tsuthd + musuth*tempd - temp2*tempd1
   ssuthd = ssuthd + tempd0 + musuth*tempd
   td = tempd1 + tempd0
   rlvd(i, j, k) = 0.0_8
   temp0 = w(i, j, k, irho)
   temp = rgas*temp0
   tempd2 = -(pp*td/temp**2)
   ppd = td/temp
   rgasd = rgasd + temp0*tempd2
   wd(i, j, k, irho) = wd(i, j, k, irho) + rgas*tempd2
   pd(i, j, k) = pd(i, j, k) + ppd
   wd(i, j, k, irho) = wd(i, j, k, irho) - twothird*w(i, j, k, itu1&
   &         )*ppd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - twothird*w(i, j, k, irho&
   &         )*ppd
   END DO
   ELSE
   ssuthd = 0.0_8
   musuthd = 0.0_8
   tsuthd = 0.0_8
   DO ii=0,ie*je*ke-1
   i = MOD(ii, ie) + 1
   j = MOD(ii/ie, je) + 1
   k = ii/(ie*je) + 1
   ! Compute the nonDimensional temperature and the
   ! nonDimensional laminar viscosity.
   t = p(i, j, k)/(rgas*w(i, j, k, irho))
   temp6 = t/tsuth
   tempd3 = temp6**1.5_realType*rlvd(i, j, k)/(t+ssuth)
   temp5 = musuth*(tsuth+ssuth)/(t+ssuth)
   tempd4 = -(temp5*tempd3)
   tempd5 = 1.5_realType*temp6**0.5*temp5*rlvd(i, j, k)/tsuth
   musuthd = musuthd + (tsuth+ssuth)*tempd3
   tsuthd = tsuthd + musuth*tempd3 - temp6*tempd5
   ssuthd = ssuthd + tempd4 + musuth*tempd3
   td = tempd5 + tempd4
   rlvd(i, j, k) = 0.0_8
   temp4 = w(i, j, k, irho)
   temp3 = rgas*temp4
   tempd6 = -(p(i, j, k)*td/temp3**2)
   pd(i, j, k) = pd(i, j, k) + td/temp3
   rgasd = rgasd + temp4*tempd6
   wd(i, j, k, irho) = wd(i, j, k, irho) + rgas*tempd6
   END DO
   END IF
   trefd = trefd - tsuthdim*tsuthd/tref**2 - ssuthdim*ssuthd/tref**2
   murefd = -(musuthdim*musuthd/muref**2)
   END IF
   END SUBROUTINE COMPUTELAMVISCOSITY_B

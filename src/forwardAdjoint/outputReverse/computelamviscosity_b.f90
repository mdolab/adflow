!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of computelamviscosity in reverse (adjoint) mode (with options i4 dr8 r8 noisize):
!   gradient     of useful results: tref rgas *p *w *rlv
!   with respect to varying inputs: muref tref rgas *p *w
!   plus diff mem management of: p:in w:in rlv:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          computelamviscosity.f90                         *
!      * author:        edwin van der weide                             *
!      * starting date: 03-10-2003                                      *
!      * last modified: 06-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine computelamviscosity_b()
!
!      ******************************************************************
!      *                                                                *
!      * computelamviscosity computes the laminar viscosity ratio in    *
!      * the owned cell centers of the given block. sutherland's law is *
!      * used. it is assumed that the pointes already point to the      *
!      * correct block before entering this subroutine.                 *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use constants
  use flowvarrefstate
  use inputphysics
  use iteration
  implicit none
!
!      local parameter.
!
  real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ii
  real(kind=realtype) :: musuth, tsuth, ssuth, t, pp
  real(kind=realtype) :: musuthd, tsuthd, ssuthd, td, ppd
  logical :: correctfork
  intrinsic mod
  real(kind=realtype) :: temp3
  real(kind=realtype) :: temp2
  real(kind=realtype) :: temp1
  real(kind=realtype) :: temp0
  real(kind=realtype) :: tempd
  real(kind=realtype) :: tempd6
  real(kind=realtype) :: tempd5
  real(kind=realtype) :: tempd4
  real(kind=realtype) :: tempd3
  real(kind=realtype) :: tempd2
  real(kind=realtype) :: tempd1
  real(kind=realtype) :: tempd0
  real(kind=realtype) :: temp
  real(kind=realtype) :: temp6
  real(kind=realtype) :: temp5
  real(kind=realtype) :: temp4
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! return immediately if no laminar viscosity needs to be computed.
  if (.not.viscous) then
    murefd = 0.0_8
  else
! determine whether or not the pressure must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .le. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
! compute the nondimensional constants in sutherland's law.
    musuth = musuthdim/muref
    tsuth = tsuthdim/tref
    ssuth = ssuthdim/tref
! substract 2/3 rho k, which is a part of the normal turbulent
! stresses, in case the pressure must be corrected.
    if (correctfork) then
      ssuthd = 0.0_8
      musuthd = 0.0_8
      tsuthd = 0.0_8
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
        pp = p(i, j, k) - twothird*w(i, j, k, irho)*w(i, j, k, itu1)
        t = pp/(rgas*w(i, j, k, irho))
        temp2 = t/tsuth
        tempd = temp2**1.5_realtype*rlvd(i, j, k)/(t+ssuth)
        temp1 = musuth*(tsuth+ssuth)/(t+ssuth)
        tempd0 = -(temp1*tempd)
        tempd1 = 1.5_realtype*temp2**0.5*temp1*rlvd(i, j, k)/tsuth
        musuthd = musuthd + (tsuth+ssuth)*tempd
        tsuthd = tsuthd + musuth*tempd - temp2*tempd1
        ssuthd = ssuthd + tempd0 + musuth*tempd
        td = tempd1 + tempd0
        rlvd(i, j, k) = 0.0_8
        temp0 = w(i, j, k, irho)
        temp = rgas*temp0
        tempd2 = -(pp*td/temp**2)
        ppd = td/temp
        rgasd = rgasd + temp0*tempd2
        wd(i, j, k, irho) = wd(i, j, k, irho) + rgas*tempd2
        pd(i, j, k) = pd(i, j, k) + ppd
        wd(i, j, k, irho) = wd(i, j, k, irho) - twothird*w(i, j, k, itu1&
&         )*ppd
        wd(i, j, k, itu1) = wd(i, j, k, itu1) - twothird*w(i, j, k, irho&
&         )*ppd
      end do
    else
      ssuthd = 0.0_8
      musuthd = 0.0_8
      tsuthd = 0.0_8
      do ii=0,ie*je*ke-1
        i = mod(ii, ie) + 1
        j = mod(ii/ie, je) + 1
        k = ii/(ie*je) + 1
! compute the nondimensional temperature and the
! nondimensional laminar viscosity.
        t = p(i, j, k)/(rgas*w(i, j, k, irho))
        temp6 = t/tsuth
        tempd3 = temp6**1.5_realtype*rlvd(i, j, k)/(t+ssuth)
        temp5 = musuth*(tsuth+ssuth)/(t+ssuth)
        tempd4 = -(temp5*tempd3)
        tempd5 = 1.5_realtype*temp6**0.5*temp5*rlvd(i, j, k)/tsuth
        musuthd = musuthd + (tsuth+ssuth)*tempd3
        tsuthd = tsuthd + musuth*tempd3 - temp6*tempd5
        ssuthd = ssuthd + tempd4 + musuth*tempd3
        td = tempd5 + tempd4
        rlvd(i, j, k) = 0.0_8
        temp4 = w(i, j, k, irho)
        temp3 = rgas*temp4
        tempd6 = -(p(i, j, k)*td/temp3**2)
        pd(i, j, k) = pd(i, j, k) + td/temp3
        rgasd = rgasd + temp4*tempd6
        wd(i, j, k, irho) = wd(i, j, k, irho) + rgas*tempd6
      end do
    end if
    trefd = trefd - tsuthdim*tsuthd/tref**2 - ssuthdim*ssuthd/tref**2
    murefd = -(musuthdim*musuthd/muref**2)
  end if
end subroutine computelamviscosity_b

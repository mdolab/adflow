   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of extrapolate2ndhalo in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *rev *p *gamma *w *rlv tref
   !                rgas
   !   with respect to varying inputs: *rev *p *gamma *w *rlv tref
   !                rgas
   !   Plus diff mem management of: rev:in p:in gamma:in w:in rlv:in
   !                bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          extrapolate2ndHalo.f90                          *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-10-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE EXTRAPOLATE2NDHALO_B(nn, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * extrapolate2ndHalo determines the states of the second layer   *
   !      * halo cells for the given subface of the block. It is assumed   *
   !      * that the pointers in blockPointers are already set to the      *
   !      * correct block on the correct grid level.                       *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS_B
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   USE INPUTPHYSICS
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: nn
   LOGICAL, INTENT(IN) :: correctfork
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: factor=0.5_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, l, idim, ddim
   INTEGER(kind=inttype), DIMENSION(3, 2) :: crange
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww0, ww1, ww2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, nw) :: ww0b, ww1b, &
   & ww2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp0, pp1, pp2
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: pp0b, pp1b, pp2b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv0, rlv1
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rlv0b, rlv1b
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rev0, rev1
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim) :: rev0b, rev1b
   INTRINSIC MAX
   INTEGER :: branch
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Nullify the pointers and set them to the correct subface.
   ! They are nullified first, because some compilers require that.
   ! Note that rlv0 and rev0 are used here as dummies.
   !nullify(ww1, ww2, pp1, pp2, rlv1, rlv0, rev1, rev0)
   ! Set a couple of additional variables needed for the
   ! extrapolation. This depends on the block face on which the
   ! subface is located.
   CALL SETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv0, rev1, &
   &                    rev0, 0)
   !_intType)
   CALL SETWW0PP0RLV0REV0BWD(nn, idim, ddim, ww0, pp0, rlv0, rev0)
   ! Loop over the generic subface to set the state in the halo's.
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   ! Extrapolate the density, momentum and pressure.
   ! Make sure that a certain threshold is kept.
   ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
   IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
   CALL PUSHCONTROL1B(0)
   ww0(i, j, irho) = ww0(i, j, irho)
   ELSE
   ww0(i, j, irho) = factor*ww1(i, j, irho)
   CALL PUSHCONTROL1B(1)
   END IF
   ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
   ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
   ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
   IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
   pp0(i, j) = two*pp1(i, j) - pp2(i, j)
   CALL PUSHCONTROL1B(0)
   ELSE
   pp0(i, j) = factor*pp1(i, j)
   CALL PUSHCONTROL1B(1)
   END IF
   ! Extrapolate the turbulent variables. Use constant
   ! extrapolation.
   DO l=nt1mg,nt2mg
   ww0(i, j, l) = ww1(i, j, l)
   END DO
   ! The laminar and eddy viscosity, if present. These values
   ! are simply taken constant. Their values do not matter.
   IF (viscous) THEN
   rlv0(i, j) = rlv1(i, j)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (eddymodel) THEN
   rev0(i, j) = rev1(i, j)
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   CALL PUSHREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   CALL RESETBCPOINTERSBWD(nn, ww1, ww2, pp1, pp2, rlv1, rlv0, rev1, &
   &                      rev0, 0)
   CALL RESETWW0PP0RLV0REV0BWD(nn, idim, ddim, ww0, pp0, rlv0, rev0)
   ! Set the range for the halo cells for the energy computation.
   crange(1, 1) = icbeg(nn)
   crange(1, 2) = icend(nn)
   crange(2, 1) = jcbeg(nn)
   crange(2, 2) = jcend(nn)
   crange(3, 1) = kcbeg(nn)
   crange(3, 2) = kcend(nn)
   crange(idim, 1) = ddim
   crange(idim, 2) = ddim
   ! Compute the energy for this halo range.
   CALL COMPUTEETOT_B(crange(1, 1), crange(1, 2), crange(2, 1), crange(2&
   &              , 2), crange(3, 1), crange(3, 2), correctfork)
   CALL RESETWW0PP0RLV0REV0BWD_B(nn, idim, ddim, ww0, ww0b, pp0, pp0b, &
   &                         rlv0, rlv0b, rev0, rev0b)
   CALL POPREAL8ARRAY(p, SIZE(p, 1)*SIZE(p, 2)*SIZE(p, 3))
   ww1b = 0.0_8
   ww2b = 0.0_8
   pp1b = 0.0_8
   pp2b = 0.0_8
   rlv1b = 0.0_8
   rev1b = 0.0_8
   CALL RESETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2, &
   &                     pp2b, rlv1, rlv1b, rlv0, rlv0b, rev1, rev1b, rev0&
   &                     , rev0b, 0)
   DO j=bcdata(nn)%jcend,bcdata(nn)%jcbeg,-1
   DO i=bcdata(nn)%icend,bcdata(nn)%icbeg,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   rev1b(i, j) = rev1b(i, j) + rev0b(i, j)
   rev0b(i, j) = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   rlv1b(i, j) = rlv1b(i, j) + rlv0b(i, j)
   rlv0b(i, j) = 0.0_8
   END IF
   DO l=nt2mg,nt1mg,-1
   ww1b(i, j, l) = ww1b(i, j, l) + ww0b(i, j, l)
   ww0b(i, j, l) = 0.0_8
   END DO
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   pp1b(i, j) = pp1b(i, j) + two*pp0b(i, j)
   pp2b(i, j) = pp2b(i, j) - pp0b(i, j)
   pp0b(i, j) = 0.0_8
   ELSE
   pp1b(i, j) = pp1b(i, j) + factor*pp0b(i, j)
   pp0b(i, j) = 0.0_8
   END IF
   ww1b(i, j, ivz) = ww1b(i, j, ivz) + two*ww0b(i, j, ivz)
   ww2b(i, j, ivz) = ww2b(i, j, ivz) - ww0b(i, j, ivz)
   ww0b(i, j, ivz) = 0.0_8
   ww1b(i, j, ivy) = ww1b(i, j, ivy) + two*ww0b(i, j, ivy)
   ww2b(i, j, ivy) = ww2b(i, j, ivy) - ww0b(i, j, ivy)
   ww0b(i, j, ivy) = 0.0_8
   ww1b(i, j, ivx) = ww1b(i, j, ivx) + two*ww0b(i, j, ivx)
   ww2b(i, j, ivx) = ww2b(i, j, ivx) - ww0b(i, j, ivx)
   ww0b(i, j, ivx) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   ww1b(i, j, irho) = ww1b(i, j, irho) + factor*ww0b(i, j, irho)
   ww0b(i, j, irho) = 0.0_8
   END IF
   ww1b(i, j, irho) = ww1b(i, j, irho) + two*ww0b(i, j, irho)
   ww2b(i, j, irho) = ww2b(i, j, irho) - ww0b(i, j, irho)
   ww0b(i, j, irho) = 0.0_8
   END DO
   END DO
   CALL SETWW0PP0RLV0REV0BWD_B(nn, idim, ddim, ww0, ww0b, pp0, pp0b, rlv0&
   &                       , rlv0b, rev0, rev0b)
   CALL SETBCPOINTERSBWD_B(nn, ww1, ww1b, ww2, ww2b, pp1, pp1b, pp2, pp2b&
   &                   , rlv1, rlv1b, rlv0, rlv0b, rev1, rev1b, rev0, rev0b&
   &                   , 0)
   END SUBROUTINE EXTRAPOLATE2NDHALO_B

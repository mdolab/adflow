   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of metric_block in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *x *vol *si *sj *sk *(*bcdata.norm)
   !   with respect to varying inputs: *x
   !   Plus diff mem management of: x:in vol:in si:in sj:in sk:in
   !                bcdata:in *bcdata.norm:in
   SUBROUTINE METRIC_BLOCK_B()
   ! This is COPY of metric.f90. It was necessary to copy this file
   ! since there is debugging stuff in the original that is not
   ! necessary for AD.
   USE BCTYPES
   USE BLOCKPOINTERS
   USE CGNSGRID
   USE COMMUNICATION
   USE INPUTTIMESPECTRAL
   IMPLICIT NONE
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: thresvolume=1.e-2_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, n, m, l
   INTEGER(kind=inttype) :: mm
   REAL(kind=realtype) :: fact, mult
   REAL(kind=realtype) :: factd
   REAL(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
   REAL(kind=realtype) :: xpd, ypd, zpd, vp1d, vp2d, vp3d, vp4d, vp5d, &
   & vp6d
   REAL(kind=realtype), DIMENSION(3) :: v1, v2
   REAL(kind=realtype), DIMENSION(3) :: v1d, v2d
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, 3) :: ss
   REAL(kind=realtype), DIMENSION(imaxdim, jmaxdim, 3) :: ssd
   LOGICAL :: checkk, checkj, checki, checkall
   INTRINSIC ABS
   INTRINSIC SQRT
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   REAL(kind=realtype) :: tempd12
   REAL(kind=realtype) :: tempd11
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: tmpd
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: tmpd1
   REAL(kind=realtype) :: tmpd0
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the volumes. The hexahedron is split into 6 pyramids
   ! whose volumes are computed. The volume is positive for a
   ! right handed block.
   ! Initialize the volumes to zero. The reasons is that the second
   ! level halo's must be initialized to zero and for convenience
   ! all the volumes are set to zero.
   vol = zero
   DO k=1,ke
   CALL PUSHINTEGER4(n)
   n = k - 1
   DO j=1,je
   CALL PUSHINTEGER4(m)
   m = j - 1
   DO i=1,ie
   l = i - 1
   ! Compute the coordinates of the center of gravity.
   CALL PUSHREAL8(xp)
   xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j, n&
   &         , 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n, 1))
   CALL PUSHREAL8(yp)
   yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j, n&
   &         , 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n, 2))
   CALL PUSHREAL8(zp)
   zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j, n&
   &         , 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n, 3))
   ! Compute the volumes of the 6 sub pyramids. The
   ! arguments of volpym must be such that for a (regular)
   ! right handed hexahedron all volumes are positive.
   CALL VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, j&
   &             , n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x(i&
   &             , m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2), x&
   &             (i, m, k, 3), vp1)
   CALL VOLPYM(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, m&
   &             , k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x(l&
   &             , m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2), x&
   &             (l, j, n, 3), vp2)
   CALL VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, j&
   &             , k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x(l&
   &             , j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2), x&
   &             (i, j, n, 3), vp3)
   CALL VOLPYM(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, m&
   &             , n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x(l&
   &             , m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2), x&
   &             (l, m, k, 3), vp4)
   CALL VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, m&
   &             , k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x(l&
   &             , m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2), x&
   &             (l, j, k, 3), vp5)
   CALL VOLPYM(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, j&
   &             , n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x(l&
   &             , m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2), x&
   &             (i, m, n, 3), vp6)
   ! Set the volume to 1/6 of the sum of the volumes of the
   ! pyramid. Remember that volpym computes 6 times the
   ! volume.
   vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
   IF (vol(i, j, k) .GE. 0.) THEN
   CALL PUSHCONTROL1B(0)
   vol(i, j, k) = vol(i, j, k)
   ELSE
   vol(i, j, k) = -vol(i, j, k)
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Some additional safety stuff for halo volumes.
   DO k=2,kl
   DO j=2,jl
   IF (vol(1, j, k) .LE. eps) THEN
   vol(1, j, k) = vol(2, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vol(ie, j, k) .LE. eps) THEN
   tmp = vol(il, j, k)
   vol(ie, j, k) = tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   DO k=2,kl
   DO i=1,ie
   IF (vol(i, 1, k) .LE. eps) THEN
   vol(i, 1, k) = vol(i, 2, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vol(i, je, k) .LE. eps) THEN
   tmp0 = vol(i, jl, k)
   vol(i, je, k) = tmp0
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   DO j=1,je
   DO i=1,ie
   IF (vol(i, j, 1) .LE. eps) THEN
   vol(i, j, 1) = vol(i, j, 2)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vol(i, j, ke) .LE. eps) THEN
   tmp1 = vol(i, j, kl)
   vol(i, j, ke) = tmp1
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Set the factor in the surface normals computation. For a
   ! left handed block this factor is negative, such that the
   ! normals still point in the direction of increasing index.
   ! The formulae used later on assume a right handed block
   ! and fact is used to correct this for a left handed block,
   ! as well as the scaling factor of 0.5
   IF (righthanded) THEN
   fact = half
   ELSE
   fact = -half
   END IF
   ! Check if both positive and negative volumes occur. If so,
   ! the block is bad and the counter nBlockBad is updated.
   !
   !          **************************************************************
   !          *                                                            *
   !          * Computation of the face normals in i-, j- and k-direction. *
   !          * Formula's are valid for a right handed block; for a left   *
   !          * handed block the correct orientation is obtained via fact. *
   !          * The normals point in the direction of increasing index.    *
   !          * The absolute value of fact is 0.5, because the cross       *
   !          * product of the two diagonals is twice the normal vector.   *
   !          *                                                            *
   !          * Note that also the normals of the first level halo cells   *
   !          * are computed. These are needed for the viscous fluxes.     *
   !          *                                                            *
   !          **************************************************************
   !
   ! Projected areas of cell faces in the i direction.
   DO k=1,ke
   CALL PUSHINTEGER4(n)
   n = k - 1
   DO j=1,je
   CALL PUSHINTEGER4(m)
   m = j - 1
   DO i=0,ie
   ! Determine the two diagonal vectors of the face.
   CALL PUSHREAL8(v1(1))
   v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
   CALL PUSHREAL8(v1(2))
   v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
   CALL PUSHREAL8(v1(3))
   v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
   CALL PUSHREAL8(v2(1))
   v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
   CALL PUSHREAL8(v2(2))
   v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
   CALL PUSHREAL8(v2(3))
   v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   ! Projected areas of cell faces in the j direction.
   DO k=1,ke
   CALL PUSHINTEGER4(n)
   n = k - 1
   DO j=0,je
   DO i=1,ie
   l = i - 1
   ! Determine the two diagonal vectors of the face.
   CALL PUSHREAL8(v1(1))
   v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
   CALL PUSHREAL8(v1(2))
   v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
   CALL PUSHREAL8(v1(3))
   v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
   CALL PUSHREAL8(v2(1))
   v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
   CALL PUSHREAL8(v2(2))
   v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
   CALL PUSHREAL8(v2(3))
   v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   ! Projected areas of cell faces in the k direction.
   DO k=0,ke
   DO j=1,je
   CALL PUSHINTEGER4(m)
   m = j - 1
   DO i=1,ie
   l = i - 1
   ! Determine the two diagonal vectors of the face.
   CALL PUSHREAL8(v1(1))
   v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
   CALL PUSHREAL8(v1(2))
   v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
   CALL PUSHREAL8(v1(3))
   v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
   CALL PUSHREAL8(v2(1))
   v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
   CALL PUSHREAL8(v2(2))
   v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
   CALL PUSHREAL8(v2(3))
   v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   !
   !          **************************************************************
   !          *                                                            *
   !          * The unit normals on the boundary faces. These always point *
   !          * out of the domain, so a multiplication by -1 is needed for *
   !          * the iMin, jMin and kMin boundaries.                        *
   !          *                                                            *
   !          **************************************************************
   !
   ! Loop over the boundary subfaces of this block.
   bocoloop:DO mm=1,nbocos
   ! Determine the block face on which this subface is located
   ! and set ss and mult accordingly.
   CALL SETSSMETRICBWD(mm, ss)
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHCONTROL3B(5)
   CASE (imax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHCONTROL3B(4)
   CASE (jmin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHCONTROL3B(2)
   CASE (kmin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHCONTROL3B(1)
   CASE (kmax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHCONTROL3B(0)
   CASE DEFAULT
   CALL PUSHCONTROL3B(6)
   END SELECT
   ad_from0 = bcdata(mm)%jcbeg
   ! Loop over the boundary faces of the subface.
   DO j=ad_from0,bcdata(mm)%jcend
   ad_from = bcdata(mm)%icbeg
   DO i=ad_from,bcdata(mm)%icend
   ! Compute the inverse of the length of the normal vector
   ! and possibly correct for inward pointing.
   CALL PUSHREAL8(xp)
   xp = ss(i, j, 1)
   CALL PUSHREAL8(yp)
   yp = ss(i, j, 2)
   CALL PUSHREAL8(zp)
   zp = ss(i, j, 3)
   CALL PUSHREAL8(fact)
   fact = SQRT(xp*xp + yp*yp + zp*zp)
   IF (fact .GT. zero) THEN
   CALL PUSHREAL8(fact)
   fact = mult/fact
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   CALL RESETSSMETRICBWD(mm, ss)
   END DO bocoloop
   ssd = 0.0_8
   DO mm=nbocos,1,-1
   CALL RESETSSMETRICBWD_B(mm, ss, ssd)
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   factd = zp*bcdatad(mm)%norm(i, j, 3)
   zpd = fact*bcdatad(mm)%norm(i, j, 3)
   bcdatad(mm)%norm(i, j, 3) = 0.0_8
   factd = factd + yp*bcdatad(mm)%norm(i, j, 2)
   ypd = fact*bcdatad(mm)%norm(i, j, 2)
   bcdatad(mm)%norm(i, j, 2) = 0.0_8
   factd = factd + xp*bcdatad(mm)%norm(i, j, 1)
   xpd = fact*bcdatad(mm)%norm(i, j, 1)
   bcdatad(mm)%norm(i, j, 1) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(fact)
   factd = -(mult*factd/fact**2)
   END IF
   CALL POPREAL8(fact)
   IF (xp**2 + yp**2 + zp**2 .EQ. 0.0_8) THEN
   tempd12 = 0.0
   ELSE
   tempd12 = factd/(2.0*SQRT(xp**2+yp**2+zp**2))
   END IF
   xpd = xpd + 2*xp*tempd12
   ypd = ypd + 2*yp*tempd12
   zpd = zpd + 2*zp*tempd12
   CALL POPREAL8(zp)
   ssd(i, j, 3) = ssd(i, j, 3) + zpd
   CALL POPREAL8(yp)
   ssd(i, j, 2) = ssd(i, j, 2) + ypd
   CALL POPREAL8(xp)
   ssd(i, j, 1) = ssd(i, j, 1) + xpd
   END DO
   END DO
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(mult)
   ELSE IF (branch .EQ. 1) THEN
   CALL POPREAL8(mult)
   ELSE
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL POPREAL8(mult)
   ELSE
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .EQ. 5) THEN
   CALL POPREAL8(mult)
   END IF
   CALL SETSSMETRICBWD_B(mm, ss, ssd)
   END DO
   v1d = 0.0_8
   v2d = 0.0_8
   DO k=ke,0,-1
   DO j=je,1,-1
   DO i=ie,1,-1
   tempd9 = fact*skd(i, j, k, 3)
   v1d(1) = v1d(1) + v2(2)*tempd9
   v2d(2) = v2d(2) + v1(1)*tempd9
   v1d(2) = v1d(2) - v2(1)*tempd9
   skd(i, j, k, 3) = 0.0_8
   tempd10 = fact*skd(i, j, k, 2)
   v2d(1) = v2d(1) + v1(3)*tempd10 - v1(2)*tempd9
   v1d(3) = v1d(3) + v2(1)*tempd10
   v1d(1) = v1d(1) - v2(3)*tempd10
   skd(i, j, k, 2) = 0.0_8
   tempd11 = fact*skd(i, j, k, 1)
   v2d(3) = v2d(3) + v1(2)*tempd11 - v1(1)*tempd10
   v1d(2) = v1d(2) + v2(3)*tempd11
   v1d(3) = v1d(3) - v2(2)*tempd11
   v2d(2) = v2d(2) - v1(3)*tempd11
   skd(i, j, k, 1) = 0.0_8
   l = i - 1
   CALL POPREAL8(v2(3))
   xd(l, j, k, 3) = xd(l, j, k, 3) + v2d(3)
   xd(i, m, k, 3) = xd(i, m, k, 3) - v2d(3)
   v2d(3) = 0.0_8
   CALL POPREAL8(v2(2))
   xd(l, j, k, 2) = xd(l, j, k, 2) + v2d(2)
   xd(i, m, k, 2) = xd(i, m, k, 2) - v2d(2)
   v2d(2) = 0.0_8
   CALL POPREAL8(v2(1))
   xd(l, j, k, 1) = xd(l, j, k, 1) + v2d(1)
   xd(i, m, k, 1) = xd(i, m, k, 1) - v2d(1)
   v2d(1) = 0.0_8
   CALL POPREAL8(v1(3))
   xd(i, j, k, 3) = xd(i, j, k, 3) + v1d(3)
   xd(l, m, k, 3) = xd(l, m, k, 3) - v1d(3)
   v1d(3) = 0.0_8
   CALL POPREAL8(v1(2))
   xd(i, j, k, 2) = xd(i, j, k, 2) + v1d(2)
   xd(l, m, k, 2) = xd(l, m, k, 2) - v1d(2)
   v1d(2) = 0.0_8
   CALL POPREAL8(v1(1))
   xd(i, j, k, 1) = xd(i, j, k, 1) + v1d(1)
   xd(l, m, k, 1) = xd(l, m, k, 1) - v1d(1)
   v1d(1) = 0.0_8
   END DO
   CALL POPINTEGER4(m)
   END DO
   END DO
   DO k=ke,1,-1
   DO j=je,0,-1
   DO i=ie,1,-1
   tempd6 = fact*sjd(i, j, k, 3)
   v1d(1) = v1d(1) + v2(2)*tempd6
   v2d(2) = v2d(2) + v1(1)*tempd6
   v1d(2) = v1d(2) - v2(1)*tempd6
   sjd(i, j, k, 3) = 0.0_8
   tempd7 = fact*sjd(i, j, k, 2)
   v2d(1) = v2d(1) + v1(3)*tempd7 - v1(2)*tempd6
   v1d(3) = v1d(3) + v2(1)*tempd7
   v1d(1) = v1d(1) - v2(3)*tempd7
   sjd(i, j, k, 2) = 0.0_8
   tempd8 = fact*sjd(i, j, k, 1)
   v2d(3) = v2d(3) + v1(2)*tempd8 - v1(1)*tempd7
   v1d(2) = v1d(2) + v2(3)*tempd8
   v1d(3) = v1d(3) - v2(2)*tempd8
   v2d(2) = v2d(2) - v1(3)*tempd8
   sjd(i, j, k, 1) = 0.0_8
   l = i - 1
   CALL POPREAL8(v2(3))
   xd(l, j, n, 3) = xd(l, j, n, 3) + v2d(3)
   xd(i, j, k, 3) = xd(i, j, k, 3) - v2d(3)
   v2d(3) = 0.0_8
   CALL POPREAL8(v2(2))
   xd(l, j, n, 2) = xd(l, j, n, 2) + v2d(2)
   xd(i, j, k, 2) = xd(i, j, k, 2) - v2d(2)
   v2d(2) = 0.0_8
   CALL POPREAL8(v2(1))
   xd(l, j, n, 1) = xd(l, j, n, 1) + v2d(1)
   xd(i, j, k, 1) = xd(i, j, k, 1) - v2d(1)
   v2d(1) = 0.0_8
   CALL POPREAL8(v1(3))
   xd(i, j, n, 3) = xd(i, j, n, 3) + v1d(3)
   xd(l, j, k, 3) = xd(l, j, k, 3) - v1d(3)
   v1d(3) = 0.0_8
   CALL POPREAL8(v1(2))
   xd(i, j, n, 2) = xd(i, j, n, 2) + v1d(2)
   xd(l, j, k, 2) = xd(l, j, k, 2) - v1d(2)
   v1d(2) = 0.0_8
   CALL POPREAL8(v1(1))
   xd(i, j, n, 1) = xd(i, j, n, 1) + v1d(1)
   xd(l, j, k, 1) = xd(l, j, k, 1) - v1d(1)
   v1d(1) = 0.0_8
   END DO
   END DO
   CALL POPINTEGER4(n)
   END DO
   DO k=ke,1,-1
   DO j=je,1,-1
   DO i=ie,0,-1
   tempd3 = fact*sid(i, j, k, 3)
   v1d(1) = v1d(1) + v2(2)*tempd3
   v2d(2) = v2d(2) + v1(1)*tempd3
   v1d(2) = v1d(2) - v2(1)*tempd3
   sid(i, j, k, 3) = 0.0_8
   tempd4 = fact*sid(i, j, k, 2)
   v2d(1) = v2d(1) + v1(3)*tempd4 - v1(2)*tempd3
   v1d(3) = v1d(3) + v2(1)*tempd4
   v1d(1) = v1d(1) - v2(3)*tempd4
   sid(i, j, k, 2) = 0.0_8
   tempd5 = fact*sid(i, j, k, 1)
   v2d(3) = v2d(3) + v1(2)*tempd5 - v1(1)*tempd4
   v1d(2) = v1d(2) + v2(3)*tempd5
   v1d(3) = v1d(3) - v2(2)*tempd5
   v2d(2) = v2d(2) - v1(3)*tempd5
   sid(i, j, k, 1) = 0.0_8
   CALL POPREAL8(v2(3))
   xd(i, j, k, 3) = xd(i, j, k, 3) + v2d(3)
   xd(i, m, n, 3) = xd(i, m, n, 3) - v2d(3)
   v2d(3) = 0.0_8
   CALL POPREAL8(v2(2))
   xd(i, j, k, 2) = xd(i, j, k, 2) + v2d(2)
   xd(i, m, n, 2) = xd(i, m, n, 2) - v2d(2)
   v2d(2) = 0.0_8
   CALL POPREAL8(v2(1))
   xd(i, j, k, 1) = xd(i, j, k, 1) + v2d(1)
   xd(i, m, n, 1) = xd(i, m, n, 1) - v2d(1)
   v2d(1) = 0.0_8
   CALL POPREAL8(v1(3))
   xd(i, j, n, 3) = xd(i, j, n, 3) + v1d(3)
   xd(i, m, k, 3) = xd(i, m, k, 3) - v1d(3)
   v1d(3) = 0.0_8
   CALL POPREAL8(v1(2))
   xd(i, j, n, 2) = xd(i, j, n, 2) + v1d(2)
   xd(i, m, k, 2) = xd(i, m, k, 2) - v1d(2)
   v1d(2) = 0.0_8
   CALL POPREAL8(v1(1))
   xd(i, j, n, 1) = xd(i, j, n, 1) + v1d(1)
   xd(i, m, k, 1) = xd(i, m, k, 1) - v1d(1)
   v1d(1) = 0.0_8
   END DO
   CALL POPINTEGER4(m)
   END DO
   CALL POPINTEGER4(n)
   END DO
   DO j=je,1,-1
   DO i=ie,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd1 = vold(i, j, ke)
   vold(i, j, ke) = 0.0_8
   vold(i, j, kl) = vold(i, j, kl) + tmpd1
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   vold(i, j, 2) = vold(i, j, 2) + vold(i, j, 1)
   vold(i, j, 1) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO i=ie,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd0 = vold(i, je, k)
   vold(i, je, k) = 0.0_8
   vold(i, jl, k) = vold(i, jl, k) + tmpd0
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   vold(i, 2, k) = vold(i, 2, k) + vold(i, 1, k)
   vold(i, 1, k) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpd = vold(ie, j, k)
   vold(ie, j, k) = 0.0_8
   vold(il, j, k) = vold(il, j, k) + tmpd
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   vold(2, j, k) = vold(2, j, k) + vold(1, j, k)
   vold(1, j, k) = 0.0_8
   END IF
   END DO
   END DO
   vp1d = 0.0_8
   vp2d = 0.0_8
   vp3d = 0.0_8
   vp4d = 0.0_8
   vp5d = 0.0_8
   vp6d = 0.0_8
   DO k=ke,1,-1
   DO j=je,1,-1
   DO i=ie,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) vold(i, j, k) = -vold(i, j, k)
   tempd = sixth*vold(i, j, k)
   vp1d = vp1d + tempd
   vp2d = vp2d + tempd
   vp3d = vp3d + tempd
   vp4d = vp4d + tempd
   vp5d = vp5d + tempd
   vp6d = vp6d + tempd
   vold(i, j, k) = 0.0_8
   l = i - 1
   zpd = 0.0_8
   ypd = 0.0_8
   xpd = 0.0_8
   CALL VOLPYM_B(x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i&
   &               , j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), x(l, j, n, 1)&
   &               , xd(l, j, n, 1), x(l, j, n, 2), xd(l, j, n, 2), x(l, j&
   &               , n, 3), xd(l, j, n, 3), x(l, m, n, 1), xd(l, m, n, 1), &
   &               x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), xd(l, m, n&
   &               , 3), x(i, m, n, 1), xd(i, m, n, 1), x(i, m, n, 2), xd(i&
   &               , m, n, 2), x(i, m, n, 3), xd(i, m, n, 3), vp6, vp6d)
   vp6d = 0.0_8
   CALL VOLPYM_B(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd(i&
   &               , j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, m, k, 1)&
   &               , xd(i, m, k, 1), x(i, m, k, 2), xd(i, m, k, 2), x(i, m&
   &               , k, 3), xd(i, m, k, 3), x(l, m, k, 1), xd(l, m, k, 1), &
   &               x(l, m, k, 2), xd(l, m, k, 2), x(l, m, k, 3), xd(l, m, k&
   &               , 3), x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l&
   &               , j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), vp5, vp5d)
   vp5d = 0.0_8
   CALL VOLPYM_B(x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i&
   &               , m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), x(i, m, n, 1)&
   &               , xd(i, m, n, 1), x(i, m, n, 2), xd(i, m, n, 2), x(i, m&
   &               , n, 3), xd(i, m, n, 3), x(l, m, n, 1), xd(l, m, n, 1), &
   &               x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), xd(l, m, n&
   &               , 3), x(l, m, k, 1), xd(l, m, k, 1), x(l, m, k, 2), xd(l&
   &               , m, k, 2), x(l, m, k, 3), xd(l, m, k, 3), vp4, vp4d)
   vp4d = 0.0_8
   CALL VOLPYM_B(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd(i&
   &               , j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(l, j, k, 1)&
   &               , xd(l, j, k, 1), x(l, j, k, 2), xd(l, j, k, 2), x(l, j&
   &               , k, 3), xd(l, j, k, 3), x(l, j, n, 1), xd(l, j, n, 1), &
   &               x(l, j, n, 2), xd(l, j, n, 2), x(l, j, n, 3), xd(l, j, n&
   &               , 3), x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i&
   &               , j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), vp3, vp3d)
   vp3d = 0.0_8
   CALL VOLPYM_B(x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l&
   &               , j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), x(l, m, k, 1)&
   &               , xd(l, m, k, 1), x(l, m, k, 2), xd(l, m, k, 2), x(l, m&
   &               , k, 3), xd(l, m, k, 3), x(l, m, n, 1), xd(l, m, n, 1), &
   &               x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), xd(l, m, n&
   &               , 3), x(l, j, n, 1), xd(l, j, n, 1), x(l, j, n, 2), xd(l&
   &               , j, n, 2), x(l, j, n, 3), xd(l, j, n, 3), vp2, vp2d)
   vp2d = 0.0_8
   CALL VOLPYM_B(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd(i&
   &               , j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, j, n, 1)&
   &               , xd(i, j, n, 1), x(i, j, n, 2), xd(i, j, n, 2), x(i, j&
   &               , n, 3), xd(i, j, n, 3), x(i, m, n, 1), xd(i, m, n, 1), &
   &               x(i, m, n, 2), xd(i, m, n, 2), x(i, m, n, 3), xd(i, m, n&
   &               , 3), x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i&
   &               , m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), vp1, vp1d)
   vp1d = 0.0_8
   CALL POPREAL8(zp)
   tempd0 = eighth*zpd
   xd(i, j, k, 3) = xd(i, j, k, 3) + tempd0
   xd(i, m, k, 3) = xd(i, m, k, 3) + tempd0
   xd(i, m, n, 3) = xd(i, m, n, 3) + tempd0
   xd(i, j, n, 3) = xd(i, j, n, 3) + tempd0
   xd(l, j, k, 3) = xd(l, j, k, 3) + tempd0
   xd(l, m, k, 3) = xd(l, m, k, 3) + tempd0
   xd(l, m, n, 3) = xd(l, m, n, 3) + tempd0
   xd(l, j, n, 3) = xd(l, j, n, 3) + tempd0
   CALL POPREAL8(yp)
   tempd1 = eighth*ypd
   xd(i, j, k, 2) = xd(i, j, k, 2) + tempd1
   xd(i, m, k, 2) = xd(i, m, k, 2) + tempd1
   xd(i, m, n, 2) = xd(i, m, n, 2) + tempd1
   xd(i, j, n, 2) = xd(i, j, n, 2) + tempd1
   xd(l, j, k, 2) = xd(l, j, k, 2) + tempd1
   xd(l, m, k, 2) = xd(l, m, k, 2) + tempd1
   xd(l, m, n, 2) = xd(l, m, n, 2) + tempd1
   xd(l, j, n, 2) = xd(l, j, n, 2) + tempd1
   CALL POPREAL8(xp)
   tempd2 = eighth*xpd
   xd(i, j, k, 1) = xd(i, j, k, 1) + tempd2
   xd(i, m, k, 1) = xd(i, m, k, 1) + tempd2
   xd(i, m, n, 1) = xd(i, m, n, 1) + tempd2
   xd(i, j, n, 1) = xd(i, j, n, 1) + tempd2
   xd(l, j, k, 1) = xd(l, j, k, 1) + tempd2
   xd(l, m, k, 1) = xd(l, m, k, 1) + tempd2
   xd(l, m, n, 1) = xd(l, m, n, 1) + tempd2
   xd(l, j, n, 1) = xd(l, j, n, 1) + tempd2
   END DO
   CALL POPINTEGER4(m)
   END DO
   CALL POPINTEGER4(n)
   END DO
      CONTAINS
   !  Differentiation of volpym in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: xp yp zp xa xb xc xd ya yb
   !                yc yd za zb zc zd volume
   !   with respect to varying inputs: xp yp zp xa xb xc xd ya yb
   !                yc yd za zb zc zd
   !        ================================================================
   SUBROUTINE VOLPYM_B(xa, xad, ya, yad, za, zad, xb, xbd, yb, ybd, zb, &
   &   zbd, xc, xcd, yc, ycd, zc, zcd, xd, xdd, yd, ydd, zd, zdd, volume, &
   &   volumed)
   !
   !        ****************************************************************
   !        *                                                              *
   !        * volpym computes 6 times the volume of a pyramid. Node p,     *
   !        * whose coordinates are set in the subroutine metric itself,   *
   !        * is the top node and a-b-c-d is the quadrilateral surface.    *
   !        * It is assumed that the cross product vCa * vDb points in     *
   !        * the direction of the top node. Here vCa is the diagonal      *
   !        * running from node c to node a and vDb the diagonal from      *
   !        * node d to node b.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   USE PRECISION
   IMPLICIT NONE
   !
   !        Function type.
   !
   REAL(kind=realtype) :: volume
   REAL(kind=realtype) :: volumed
   !
   !        Function arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: xa, ya, za, xb, yb, zb
   REAL(kind=realtype) :: xad, yad, zad, xbd, ybd, zbd
   REAL(kind=realtype), INTENT(IN) :: xc, yc, zc, xd, yd, zd
   REAL(kind=realtype) :: xcd, ycd, zcd, xdd, ydd, zdd
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   tempd = ((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))*volumed
   tempd0 = -(fourth*tempd)
   tempd1 = (xp-fourth*(xa+xb+xc+xd))*volumed
   tempd2 = ((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))*volumed
   tempd3 = -(fourth*tempd2)
   tempd4 = (yp-fourth*(ya+yb+yc+yd))*volumed
   tempd5 = ((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))*volumed
   tempd6 = -(fourth*tempd5)
   tempd7 = (zp-fourth*(za+zb+zc+zd))*volumed
   xpd = xpd + tempd
   xad = xad + (yb-yd)*tempd7 - (zb-zd)*tempd4 + tempd0
   xbd = xbd + (za-zc)*tempd4 - (ya-yc)*tempd7 + tempd0
   xcd = xcd + (zb-zd)*tempd4 - (yb-yd)*tempd7 + tempd0
   xdd = xdd + (ya-yc)*tempd7 - (za-zc)*tempd4 + tempd0
   yad = yad + tempd3 - (xb-xd)*tempd7 + (zb-zd)*tempd1
   ycd = ycd + (xb-xd)*tempd7 + tempd3 - (zb-zd)*tempd1
   zbd = zbd + tempd6 - (xa-xc)*tempd4 + (ya-yc)*tempd1
   zdd = zdd + tempd6 + (xa-xc)*tempd4 - (ya-yc)*tempd1
   zad = zad + tempd6 + (xb-xd)*tempd4 - (yb-yd)*tempd1
   zcd = zcd + tempd6 - (xb-xd)*tempd4 + (yb-yd)*tempd1
   ybd = ybd + (xa-xc)*tempd7 + tempd3 - (za-zc)*tempd1
   ydd = ydd + tempd3 - (xa-xc)*tempd7 + (za-zc)*tempd1
   ypd = ypd + tempd2
   zpd = zpd + tempd5
   END SUBROUTINE VOLPYM_B
   !        ================================================================
   SUBROUTINE VOLPYM(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
   &   volume)
   !
   !        ****************************************************************
   !        *                                                              *
   !        * volpym computes 6 times the volume of a pyramid. Node p,     *
   !        * whose coordinates are set in the subroutine metric itself,   *
   !        * is the top node and a-b-c-d is the quadrilateral surface.    *
   !        * It is assumed that the cross product vCa * vDb points in     *
   !        * the direction of the top node. Here vCa is the diagonal      *
   !        * running from node c to node a and vDb the diagonal from      *
   !        * node d to node b.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   USE PRECISION
   IMPLICIT NONE
   !
   !        Function type.
   !
   REAL(kind=realtype) :: volume
   !
   !        Function arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: xa, ya, za, xb, yb, zb
   REAL(kind=realtype), INTENT(IN) :: xc, yc, zc, xd, yd, zd
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))&
   &     + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd)) + (&
   &     zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
   END SUBROUTINE VOLPYM
   END SUBROUTINE METRIC_BLOCK_B

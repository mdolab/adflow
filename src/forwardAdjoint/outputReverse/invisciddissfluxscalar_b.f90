   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of invisciddissfluxscalar in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *p *gamma *w *fw gammainf
   !   with respect to varying inputs: *p *gamma *w *radi *radj *radk
   !                gammainf rhoinf pinfcorr
   !   Plus diff mem management of: p:in gamma:in w:in fw:in radi:in
   !                radj:in radk:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidDissFluxScalar.f90                      *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-24-2003                                      *
   !      * Last modified: 10-29-2007                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDDISSFLUXSCALAR_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidDissFluxScalar computes the scalar artificial          *
   !      * dissipation, see AIAA paper 81-1259, for a given block.        *
   !      * Therefore it is assumed that the pointers in  blockPointers    *
   !      * already point to the correct block.                            *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE CGNSGRID
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: dssmax=0.25_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ind, ii
   REAL(kind=realtype) :: sslim, rhoi
   REAL(kind=realtype) :: sslimd
   REAL(kind=realtype) :: sfil, fis2, fis4
   REAL(kind=realtype) :: ppor, rrad, dis2, dis4
   REAL(kind=realtype) :: rradd, dis2d, dis4d
   REAL(kind=realtype) :: ddw1, ddw2, ddw3, ddw4, ddw5, fs
   REAL(kind=realtype) :: ddw1d, ddw2d, ddw3d, ddw4d, ddw5d, fsd
   REAL(kind=realtype), DIMENSION(ie, je, ke, 3) :: dss
   REAL(kind=realtype), DIMENSION(ie, je, ke, 3) :: dssd
   REAL(kind=realtype), DIMENSION(0:ib, 0:jb, 0:kb) :: ss
   REAL(kind=realtype), DIMENSION(0:ib, 0:jb, 0:kb) :: ssd
   INTRINSIC ABS
   INTRINSIC MOD
   INTRINSIC MAX
   INTRINSIC MIN
   REAL(kind=realtype) :: DIM
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   INTEGER :: branch
   REAL(kind=realtype) :: temp3
   REAL(kind=realtype) :: temp29
   REAL(kind=realtype) :: tempd14
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp28
   REAL(kind=realtype) :: tempd13
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: tempd12
   REAL(kind=realtype) :: temp27
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd11
   REAL(kind=realtype) :: temp26
   REAL(kind=realtype) :: tempd10
   REAL(kind=realtype) :: temp25
   REAL(kind=realtype) :: temp24
   REAL(kind=realtype) :: temp23
   REAL(kind=realtype) :: temp22
   REAL(kind=realtype) :: temp21
   REAL(kind=realtype) :: temp20
   REAL(kind=realtype) :: min3
   REAL(kind=realtype) :: min2
   REAL(kind=realtype) :: min1
   REAL(kind=realtype) :: min1d
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: temp19
   REAL(kind=realtype) :: temp18
   REAL(kind=realtype) :: temp17
   REAL(kind=realtype) :: temp16
   REAL(kind=realtype) :: temp15
   REAL(kind=realtype) :: temp14
   REAL(kind=realtype) :: temp13
   REAL(kind=realtype) :: y3d
   REAL(kind=realtype) :: temp12
   REAL(kind=realtype) :: temp11
   REAL(kind=realtype) :: temp10
   REAL(kind=realtype) :: temp41
   REAL(kind=realtype) :: temp40
   REAL(kind=realtype) :: tempd9
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd8
   REAL(kind=realtype) :: tempd7
   REAL(kind=realtype) :: tempd6
   REAL(kind=realtype) :: tempd5
   REAL(kind=realtype) :: tempd4
   REAL(kind=realtype) :: tempd3
   REAL(kind=realtype) :: tempd2
   REAL(kind=realtype) :: tempd1
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: min3d
   REAL(kind=realtype) :: y2d
   REAL(kind=realtype) :: temp39
   REAL(kind=realtype) :: temp38
   REAL(kind=realtype) :: temp37
   REAL(kind=realtype) :: tempd22
   REAL(kind=realtype) :: temp36
   REAL(kind=realtype) :: tempd21
   REAL(kind=realtype) :: temp35
   REAL(kind=realtype) :: tempd20
   REAL(kind=realtype) :: temp34
   REAL(kind=realtype) :: temp33
   REAL(kind=realtype) :: temp32
   REAL(kind=realtype) :: temp31
   REAL(kind=realtype) :: temp30
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: temp9
   REAL(kind=realtype) :: temp8
   REAL(kind=realtype) :: min2d
   REAL(kind=realtype) :: tempd19
   REAL(kind=realtype) :: temp7
   REAL(kind=realtype) :: tempd18
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: temp6
   REAL(kind=realtype) :: tempd17
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: temp5
   REAL(kind=realtype) :: x3d
   REAL(kind=realtype) :: tempd16
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: temp4
   REAL(kind=realtype) :: y1d
   REAL(kind=realtype) :: tempd15
   IF (rfil .GE. 0.) THEN
   abs0 = rfil
   ELSE
   abs0 = -rfil
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check if rFil == 0. If so, the dissipative flux needs not to
   ! be computed.
   IF (abs0 .LT. thresholdreal) THEN
   radid = 0.0_8
   radjd = 0.0_8
   radkd = 0.0_8
   rhoinfd = 0.0_8
   pinfcorrd = 0.0_8
   ELSE
   ! Determine the variables used to compute the switch.
   ! For the inviscid case this is the pressure; for the viscous
   ! case it is the entropy.
   SELECT CASE  (equations) 
   CASE (eulerequations) 
   ! Inviscid case. Pressure switch is based on the pressure.
   ! Also set the value of sslim. To be fully consistent this
   ! must have the dimension of pressure and it is therefore
   ! set to a fraction of the free stream value.
   sslim = 0.001_realType*pinfcorr
   ! Copy the pressure in ss. Only need the entries used in the
   ! discretization, i.e. not including the corner halo's, but we'll
   ! just copy all anyway. 
   ss = p
   CALL PUSHCONTROL2B(1)
   CASE (nsequations, ransequations) 
   !===============================================================
   ! Viscous case. Pressure switch is based on the entropy.
   ! Also set the value of sslim. To be fully consistent this
   ! must have the dimension of entropy and it is therefore
   ! set to a fraction of the free stream value.
   sslim = 0.001_realType*pinfcorr/rhoinf**gammainf
   ! Store the entropy in ss. See above. 
   DO ii=0,(ib+1)*(jb+1)*(kb+1)-1
   i = MOD(ii, ib + 1)
   j = MOD(ii/(ib+1), jb + 1)
   k = ii/((ib+1)*(jb+1))
   ss(i, j, k) = p(i, j, k)/w(i, j, k, irho)**gamma(i, j, k)
   END DO
   CALL PUSHCONTROL2B(0)
   CASE DEFAULT
   CALL PUSHCONTROL2B(2)
   END SELECT
   CALL PUSHINTEGER4(i)
   CALL PUSHINTEGER4(j)
   ! Compute the pressure sensor for each cell, in each direction:
   DO ii=0,ie*je*ke-1
   i = MOD(ii, ie) + 1
   j = MOD(ii/ie, je) + 1
   k = ii/(ie*je) + 1
   x1 = (ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))/(ss(i+1, j, k)+&
   &       two*ss(i, j, k)+ss(i-1, j, k)+sslim)
   IF (x1 .GE. 0.) THEN
   dss(i, j, k, 1) = x1
   ELSE
   dss(i, j, k, 1) = -x1
   END IF
   x2 = (ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))/(ss(i, j+1, k)+&
   &       two*ss(i, j, k)+ss(i, j-1, k)+sslim)
   IF (x2 .GE. 0.) THEN
   dss(i, j, k, 2) = x2
   ELSE
   dss(i, j, k, 2) = -x2
   END IF
   x3 = (ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))/(ss(i, j, k+1)+&
   &       two*ss(i, j, k)+ss(i, j, k-1)+sslim)
   IF (x3 .GE. 0.) THEN
   dss(i, j, k, 3) = x3
   ELSE
   dss(i, j, k, 3) = -x3
   END IF
   END DO
   ! Set a couple of constants for the scheme.
   fis2 = rfil*vis2
   fis4 = rfil*vis4
   ! Initialize the dissipative residual to a certain times,
   ! possibly zero, the previously stored value. Owned cells
   ! only, because the halo values do not matter.
   CALL PUSHINTEGER4(i)
   CALL PUSHINTEGER4(j)
   CALL PUSHINTEGER4(i)
   CALL PUSHINTEGER4(j)
   CALL PUSHREAL8(dis4)
   CALL PUSHREAL8(ddw2)
   CALL PUSHREAL8(ddw3)
   CALL PUSHREAL8(ddw4)
   CALL PUSHREAL8(ddw5)
   CALL PUSHREAL8(ppor)
   CALL PUSHINTEGER4(i)
   CALL PUSHINTEGER4(j)
   CALL PUSHREAL8(dis4)
   CALL PUSHREAL8(ddw2)
   CALL PUSHREAL8(ddw3)
   CALL PUSHREAL8(ddw4)
   CALL PUSHREAL8(ddw5)
   CALL PUSHREAL8(ppor)
   radkd = 0.0_8
   dssd = 0.0_8
   DO ii=0,nx*ny*kl-1
   i = MOD(ii, nx) + 2
   j = MOD(ii/nx, ny) + 2
   k = ii/(nx*ny) + 1
   ! Compute the dissipation coefficients for this face.
   ppor = zero
   IF (pork(i, j, k) .EQ. normalflux) ppor = half
   rrad = ppor*(radk(i, j, k)+radk(i, j, k+1))
   IF (dss(i, j, k, 3) .LT. dss(i, j, k+1, 3)) THEN
   y3 = dss(i, j, k+1, 3)
   CALL PUSHCONTROL1B(0)
   ELSE
   y3 = dss(i, j, k, 3)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dssmax .GT. y3) THEN
   min3 = y3
   CALL PUSHCONTROL1B(0)
   ELSE
   min3 = dssmax
   CALL PUSHCONTROL1B(1)
   END IF
   dis2 = fis2*rrad*min3
   arg1 = fis4*rrad
   dis4 = DIM(arg1, dis2)
   ! Compute and scatter the dissipative flux.
   ! Density. Store it in the mass flow of the
   ! appropriate sliding mesh interface.
   ddw1 = w(i, j, k+1, irho) - w(i, j, k, irho)
   ! X-momentum.
   ddw2 = w(i, j, k+1, ivx)*w(i, j, k+1, irho) - w(i, j, k, ivx)*w(i&
   &       , j, k, irho)
   ! Y-momentum.
   ddw3 = w(i, j, k+1, ivy)*w(i, j, k+1, irho) - w(i, j, k, ivy)*w(i&
   &       , j, k, irho)
   ! Z-momentum.
   ddw4 = w(i, j, k+1, ivz)*w(i, j, k+1, irho) - w(i, j, k, ivz)*w(i&
   &       , j, k, irho)
   ! Energy.
   ddw5 = w(i, j, k+1, irhoe) + p(i, j, k+1) - (w(i, j, k, irhoe)+p(i&
   &       , j, k))
   fsd = fwd(i, j, k+1, irhoe) - fwd(i, j, k, irhoe)
   tempd18 = -(dis4*fsd)
   dis2d = ddw5*fsd
   ddw5d = dis2*fsd - three*tempd18
   dis4d = -((w(i, j, k+2, irhoe)+p(i, j, k+2)-w(i, j, k-1, irhoe)-p(&
   &       i, j, k-1)-three*ddw5)*fsd)
   wd(i, j, k+2, irhoe) = wd(i, j, k+2, irhoe) + tempd18
   pd(i, j, k+2) = pd(i, j, k+2) + tempd18
   wd(i, j, k-1, irhoe) = wd(i, j, k-1, irhoe) - tempd18
   pd(i, j, k-1) = pd(i, j, k-1) - tempd18
   wd(i, j, k+1, irhoe) = wd(i, j, k+1, irhoe) + ddw5d
   pd(i, j, k+1) = pd(i, j, k+1) + ddw5d
   wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
   pd(i, j, k) = pd(i, j, k) - ddw5d
   fsd = fwd(i, j, k+1, imz) - fwd(i, j, k, imz)
   temp41 = w(i, j, k-1, irho)
   temp40 = w(i, j, k-1, ivz)
   temp39 = w(i, j, k+2, irho)
   temp38 = w(i, j, k+2, ivz)
   tempd19 = -(dis4*fsd)
   dis2d = dis2d + ddw4*fsd
   ddw4d = dis2*fsd - three*tempd19
   dis4d = dis4d - (temp38*temp39-temp40*temp41-three*ddw4)*fsd
   wd(i, j, k+2, ivz) = wd(i, j, k+2, ivz) + temp39*tempd19
   wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp38*tempd19
   wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - temp41*tempd19
   wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp40*tempd19
   wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + w(i, j, k+1, irho)*ddw4d
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivz)*&
   &       ddw4d
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
   fsd = fwd(i, j, k+1, imy) - fwd(i, j, k, imy)
   temp37 = w(i, j, k-1, irho)
   temp36 = w(i, j, k-1, ivy)
   temp35 = w(i, j, k+2, irho)
   temp34 = w(i, j, k+2, ivy)
   tempd20 = -(dis4*fsd)
   dis2d = dis2d + ddw3*fsd
   ddw3d = dis2*fsd - three*tempd20
   dis4d = dis4d - (temp34*temp35-temp36*temp37-three*ddw3)*fsd
   wd(i, j, k+2, ivy) = wd(i, j, k+2, ivy) + temp35*tempd20
   wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp34*tempd20
   wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - temp37*tempd20
   wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp36*tempd20
   wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + w(i, j, k+1, irho)*ddw3d
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivy)*&
   &       ddw3d
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
   fsd = fwd(i, j, k+1, imx) - fwd(i, j, k, imx)
   temp33 = w(i, j, k-1, irho)
   temp32 = w(i, j, k-1, ivx)
   temp31 = w(i, j, k+2, irho)
   temp30 = w(i, j, k+2, ivx)
   tempd21 = -(dis4*fsd)
   dis2d = dis2d + ddw2*fsd
   ddw2d = dis2*fsd - three*tempd21
   dis4d = dis4d - (temp30*temp31-temp32*temp33-three*ddw2)*fsd
   wd(i, j, k+2, ivx) = wd(i, j, k+2, ivx) + temp31*tempd21
   wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + temp30*tempd21
   wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - temp33*tempd21
   wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - temp32*tempd21
   wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + w(i, j, k+1, irho)*ddw2d
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + w(i, j, k+1, ivx)*&
   &       ddw2d
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
   fsd = fwd(i, j, k+1, irho) - fwd(i, j, k, irho)
   tempd22 = -(dis4*fsd)
   dis2d = dis2d + ddw1*fsd
   ddw1d = dis2*fsd - three*tempd22
   dis4d = dis4d - (w(i, j, k+2, irho)-w(i, j, k-1, irho)-three*ddw1)&
   &       *fsd
   wd(i, j, k+2, irho) = wd(i, j, k+2, irho) + tempd22
   wd(i, j, k-1, irho) = wd(i, j, k-1, irho) - tempd22
   wd(i, j, k+1, irho) = wd(i, j, k+1, irho) + ddw1d
   wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
   arg1d = 0.0_8
   CALL DIM_B(arg1, arg1d, dis2, dis2d, dis4d)
   rradd = fis2*min3*dis2d + fis4*arg1d
   min3d = fis2*rrad*dis2d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y3d = min3d
   ELSE
   y3d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dssd(i, j, k+1, 3) = dssd(i, j, k+1, 3) + y3d
   ELSE
   dssd(i, j, k, 3) = dssd(i, j, k, 3) + y3d
   END IF
   radkd(i, j, k) = radkd(i, j, k) + ppor*rradd
   radkd(i, j, k+1) = radkd(i, j, k+1) + ppor*rradd
   END DO
   CALL POPREAL8(ppor)
   CALL POPREAL8(ddw5)
   CALL POPREAL8(ddw4)
   CALL POPREAL8(ddw3)
   CALL POPREAL8(ddw2)
   CALL POPREAL8(dis4)
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(i)
   radjd = 0.0_8
   DO ii=0,nx*jl*nz-1
   i = MOD(ii, nx) + 2
   j = MOD(ii/nx, jl) + 1
   k = ii/(nx*jl) + 2
   ! Compute the dissipation coefficients for this face.
   ppor = zero
   IF (porj(i, j, k) .EQ. normalflux) ppor = half
   rrad = ppor*(radj(i, j, k)+radj(i, j+1, k))
   IF (dss(i, j, k, 2) .LT. dss(i, j+1, k, 2)) THEN
   y2 = dss(i, j+1, k, 2)
   CALL PUSHCONTROL1B(0)
   ELSE
   y2 = dss(i, j, k, 2)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dssmax .GT. y2) THEN
   min2 = y2
   CALL PUSHCONTROL1B(0)
   ELSE
   min2 = dssmax
   CALL PUSHCONTROL1B(1)
   END IF
   dis2 = fis2*rrad*min2
   arg1 = fis4*rrad
   dis4 = DIM(arg1, dis2)
   ! Compute and scatter the dissipative flux.
   ! Density. Store it in the mass flow of the
   ! appropriate sliding mesh interface.
   ddw1 = w(i, j+1, k, irho) - w(i, j, k, irho)
   ! X-momentum.
   ddw2 = w(i, j+1, k, ivx)*w(i, j+1, k, irho) - w(i, j, k, ivx)*w(i&
   &       , j, k, irho)
   ! Y-momentum.
   ddw3 = w(i, j+1, k, ivy)*w(i, j+1, k, irho) - w(i, j, k, ivy)*w(i&
   &       , j, k, irho)
   ! Z-momentum.
   ddw4 = w(i, j+1, k, ivz)*w(i, j+1, k, irho) - w(i, j, k, ivz)*w(i&
   &       , j, k, irho)
   ! Energy.
   ddw5 = w(i, j+1, k, irhoe) + p(i, j+1, k) - (w(i, j, k, irhoe)+p(i&
   &       , j, k))
   fsd = fwd(i, j+1, k, irhoe) - fwd(i, j, k, irhoe)
   tempd13 = -(dis4*fsd)
   dis2d = ddw5*fsd
   ddw5d = dis2*fsd - three*tempd13
   dis4d = -((w(i, j+2, k, irhoe)+p(i, j+2, k)-w(i, j-1, k, irhoe)-p(&
   &       i, j-1, k)-three*ddw5)*fsd)
   wd(i, j+2, k, irhoe) = wd(i, j+2, k, irhoe) + tempd13
   pd(i, j+2, k) = pd(i, j+2, k) + tempd13
   wd(i, j-1, k, irhoe) = wd(i, j-1, k, irhoe) - tempd13
   pd(i, j-1, k) = pd(i, j-1, k) - tempd13
   wd(i, j+1, k, irhoe) = wd(i, j+1, k, irhoe) + ddw5d
   pd(i, j+1, k) = pd(i, j+1, k) + ddw5d
   wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
   pd(i, j, k) = pd(i, j, k) - ddw5d
   fsd = fwd(i, j+1, k, imz) - fwd(i, j, k, imz)
   temp29 = w(i, j-1, k, irho)
   temp28 = w(i, j-1, k, ivz)
   temp27 = w(i, j+2, k, irho)
   temp26 = w(i, j+2, k, ivz)
   tempd14 = -(dis4*fsd)
   dis2d = dis2d + ddw4*fsd
   ddw4d = dis2*fsd - three*tempd14
   dis4d = dis4d - (temp26*temp27-temp28*temp29-three*ddw4)*fsd
   wd(i, j+2, k, ivz) = wd(i, j+2, k, ivz) + temp27*tempd14
   wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp26*tempd14
   wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - temp29*tempd14
   wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp28*tempd14
   wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + w(i, j+1, k, irho)*ddw4d
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivz)*&
   &       ddw4d
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
   fsd = fwd(i, j+1, k, imy) - fwd(i, j, k, imy)
   temp25 = w(i, j-1, k, irho)
   temp24 = w(i, j-1, k, ivy)
   temp23 = w(i, j+2, k, irho)
   temp22 = w(i, j+2, k, ivy)
   tempd15 = -(dis4*fsd)
   dis2d = dis2d + ddw3*fsd
   ddw3d = dis2*fsd - three*tempd15
   dis4d = dis4d - (temp22*temp23-temp24*temp25-three*ddw3)*fsd
   wd(i, j+2, k, ivy) = wd(i, j+2, k, ivy) + temp23*tempd15
   wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp22*tempd15
   wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - temp25*tempd15
   wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp24*tempd15
   wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + w(i, j+1, k, irho)*ddw3d
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivy)*&
   &       ddw3d
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
   fsd = fwd(i, j+1, k, imx) - fwd(i, j, k, imx)
   temp21 = w(i, j-1, k, irho)
   temp20 = w(i, j-1, k, ivx)
   temp19 = w(i, j+2, k, irho)
   temp18 = w(i, j+2, k, ivx)
   tempd16 = -(dis4*fsd)
   dis2d = dis2d + ddw2*fsd
   ddw2d = dis2*fsd - three*tempd16
   dis4d = dis4d - (temp18*temp19-temp20*temp21-three*ddw2)*fsd
   wd(i, j+2, k, ivx) = wd(i, j+2, k, ivx) + temp19*tempd16
   wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + temp18*tempd16
   wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - temp21*tempd16
   wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - temp20*tempd16
   wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + w(i, j+1, k, irho)*ddw2d
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + w(i, j+1, k, ivx)*&
   &       ddw2d
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
   fsd = fwd(i, j+1, k, irho) - fwd(i, j, k, irho)
   tempd17 = -(dis4*fsd)
   dis2d = dis2d + ddw1*fsd
   ddw1d = dis2*fsd - three*tempd17
   dis4d = dis4d - (w(i, j+2, k, irho)-w(i, j-1, k, irho)-three*ddw1)&
   &       *fsd
   wd(i, j+2, k, irho) = wd(i, j+2, k, irho) + tempd17
   wd(i, j-1, k, irho) = wd(i, j-1, k, irho) - tempd17
   wd(i, j+1, k, irho) = wd(i, j+1, k, irho) + ddw1d
   wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
   arg1d = 0.0_8
   CALL DIM_B(arg1, arg1d, dis2, dis2d, dis4d)
   rradd = fis2*min2*dis2d + fis4*arg1d
   min2d = fis2*rrad*dis2d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y2d = min2d
   ELSE
   y2d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dssd(i, j+1, k, 2) = dssd(i, j+1, k, 2) + y2d
   ELSE
   dssd(i, j, k, 2) = dssd(i, j, k, 2) + y2d
   END IF
   radjd(i, j, k) = radjd(i, j, k) + ppor*rradd
   radjd(i, j+1, k) = radjd(i, j+1, k) + ppor*rradd
   END DO
   CALL POPREAL8(ppor)
   CALL POPREAL8(ddw5)
   CALL POPREAL8(ddw4)
   CALL POPREAL8(ddw3)
   CALL POPREAL8(ddw2)
   CALL POPREAL8(dis4)
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(i)
   radid = 0.0_8
   DO ii=0,il*ny*nz-1
   i = MOD(ii, il) + 1
   j = MOD(ii/il, ny) + 2
   k = ii/(il*ny) + 2
   ! Compute the dissipation coefficients for this face.
   ppor = zero
   IF (pori(i, j, k) .EQ. normalflux) ppor = half
   rrad = ppor*(radi(i, j, k)+radi(i+1, j, k))
   IF (dss(i, j, k, 1) .LT. dss(i+1, j, k, 1)) THEN
   y1 = dss(i+1, j, k, 1)
   CALL PUSHCONTROL1B(0)
   ELSE
   y1 = dss(i, j, k, 1)
   CALL PUSHCONTROL1B(1)
   END IF
   IF (dssmax .GT. y1) THEN
   min1 = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   min1 = dssmax
   CALL PUSHCONTROL1B(1)
   END IF
   dis2 = fis2*rrad*min1
   arg1 = fis4*rrad
   dis4 = DIM(arg1, dis2)
   ! Compute and scatter the dissipative flux.
   ! Density. Store it in the mass flow of the
   ! appropriate sliding mesh interface.
   ddw1 = w(i+1, j, k, irho) - w(i, j, k, irho)
   ! X-momentum.
   ddw2 = w(i+1, j, k, ivx)*w(i+1, j, k, irho) - w(i, j, k, ivx)*w(i&
   &       , j, k, irho)
   ! Y-momentum.
   ddw3 = w(i+1, j, k, ivy)*w(i+1, j, k, irho) - w(i, j, k, ivy)*w(i&
   &       , j, k, irho)
   ! Z-momentum.
   ddw4 = w(i+1, j, k, ivz)*w(i+1, j, k, irho) - w(i, j, k, ivz)*w(i&
   &       , j, k, irho)
   ! Energy.
   ddw5 = w(i+1, j, k, irhoe) + p(i+1, j, k) - (w(i, j, k, irhoe)+p(i&
   &       , j, k))
   fsd = fwd(i+1, j, k, irhoe) - fwd(i, j, k, irhoe)
   tempd8 = -(dis4*fsd)
   dis2d = ddw5*fsd
   ddw5d = dis2*fsd - three*tempd8
   dis4d = -((w(i+2, j, k, irhoe)+p(i+2, j, k)-w(i-1, j, k, irhoe)-p(&
   &       i-1, j, k)-three*ddw5)*fsd)
   wd(i+2, j, k, irhoe) = wd(i+2, j, k, irhoe) + tempd8
   pd(i+2, j, k) = pd(i+2, j, k) + tempd8
   wd(i-1, j, k, irhoe) = wd(i-1, j, k, irhoe) - tempd8
   pd(i-1, j, k) = pd(i-1, j, k) - tempd8
   wd(i+1, j, k, irhoe) = wd(i+1, j, k, irhoe) + ddw5d
   pd(i+1, j, k) = pd(i+1, j, k) + ddw5d
   wd(i, j, k, irhoe) = wd(i, j, k, irhoe) - ddw5d
   pd(i, j, k) = pd(i, j, k) - ddw5d
   fsd = fwd(i+1, j, k, imz) - fwd(i, j, k, imz)
   temp17 = w(i-1, j, k, irho)
   temp16 = w(i-1, j, k, ivz)
   temp15 = w(i+2, j, k, irho)
   temp14 = w(i+2, j, k, ivz)
   tempd9 = -(dis4*fsd)
   dis2d = dis2d + ddw4*fsd
   ddw4d = dis2*fsd - three*tempd9
   dis4d = dis4d - (temp14*temp15-temp16*temp17-three*ddw4)*fsd
   wd(i+2, j, k, ivz) = wd(i+2, j, k, ivz) + temp15*tempd9
   wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp14*tempd9
   wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - temp17*tempd9
   wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp16*tempd9
   wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + w(i+1, j, k, irho)*ddw4d
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivz)*&
   &       ddw4d
   wd(i, j, k, ivz) = wd(i, j, k, ivz) - w(i, j, k, irho)*ddw4d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivz)*ddw4d
   fsd = fwd(i+1, j, k, imy) - fwd(i, j, k, imy)
   temp13 = w(i-1, j, k, irho)
   temp12 = w(i-1, j, k, ivy)
   temp11 = w(i+2, j, k, irho)
   temp10 = w(i+2, j, k, ivy)
   tempd10 = -(dis4*fsd)
   dis2d = dis2d + ddw3*fsd
   ddw3d = dis2*fsd - three*tempd10
   dis4d = dis4d - (temp10*temp11-temp12*temp13-three*ddw3)*fsd
   wd(i+2, j, k, ivy) = wd(i+2, j, k, ivy) + temp11*tempd10
   wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp10*tempd10
   wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - temp13*tempd10
   wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp12*tempd10
   wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + w(i+1, j, k, irho)*ddw3d
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivy)*&
   &       ddw3d
   wd(i, j, k, ivy) = wd(i, j, k, ivy) - w(i, j, k, irho)*ddw3d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivy)*ddw3d
   fsd = fwd(i+1, j, k, imx) - fwd(i, j, k, imx)
   temp9 = w(i-1, j, k, irho)
   temp8 = w(i-1, j, k, ivx)
   temp7 = w(i+2, j, k, irho)
   temp6 = w(i+2, j, k, ivx)
   tempd11 = -(dis4*fsd)
   dis2d = dis2d + ddw2*fsd
   ddw2d = dis2*fsd - three*tempd11
   dis4d = dis4d - (temp6*temp7-temp8*temp9-three*ddw2)*fsd
   wd(i+2, j, k, ivx) = wd(i+2, j, k, ivx) + temp7*tempd11
   wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + temp6*tempd11
   wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - temp9*tempd11
   wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - temp8*tempd11
   wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + w(i+1, j, k, irho)*ddw2d
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + w(i+1, j, k, ivx)*&
   &       ddw2d
   wd(i, j, k, ivx) = wd(i, j, k, ivx) - w(i, j, k, irho)*ddw2d
   wd(i, j, k, irho) = wd(i, j, k, irho) - w(i, j, k, ivx)*ddw2d
   fsd = fwd(i+1, j, k, irho) - fwd(i, j, k, irho)
   tempd12 = -(dis4*fsd)
   dis2d = dis2d + ddw1*fsd
   ddw1d = dis2*fsd - three*tempd12
   dis4d = dis4d - (w(i+2, j, k, irho)-w(i-1, j, k, irho)-three*ddw1)&
   &       *fsd
   wd(i+2, j, k, irho) = wd(i+2, j, k, irho) + tempd12
   wd(i-1, j, k, irho) = wd(i-1, j, k, irho) - tempd12
   wd(i+1, j, k, irho) = wd(i+1, j, k, irho) + ddw1d
   wd(i, j, k, irho) = wd(i, j, k, irho) - ddw1d
   arg1d = 0.0_8
   CALL DIM_B(arg1, arg1d, dis2, dis2d, dis4d)
   rradd = fis2*min1*dis2d + fis4*arg1d
   min1d = fis2*rrad*dis2d
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   y1d = min1d
   ELSE
   y1d = 0.0_8
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   dssd(i+1, j, k, 1) = dssd(i+1, j, k, 1) + y1d
   ELSE
   dssd(i, j, k, 1) = dssd(i, j, k, 1) + y1d
   END IF
   radid(i, j, k) = radid(i, j, k) + ppor*rradd
   radid(i+1, j, k) = radid(i+1, j, k) + ppor*rradd
   END DO
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(i)
   sslimd = 0.0_8
   ssd = 0.0_8
   DO ii=0,ie*je*ke-1
   i = MOD(ii, ie) + 1
   j = MOD(ii/ie, je) + 1
   k = ii/(ie*je) + 1
   x1 = (ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))/(ss(i+1, j, k)+&
   &       two*ss(i, j, k)+ss(i-1, j, k)+sslim)
   IF (x1 .GE. 0.) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   x2 = (ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))/(ss(i, j+1, k)+&
   &       two*ss(i, j, k)+ss(i, j-1, k)+sslim)
   IF (x2 .GE. 0.) THEN
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   x3 = (ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))/(ss(i, j, k+1)+&
   &       two*ss(i, j, k)+ss(i, j, k-1)+sslim)
   IF (x3 .GE. 0.) THEN
   x3d = dssd(i, j, k, 3)
   dssd(i, j, k, 3) = 0.0_8
   ELSE
   x3d = -dssd(i, j, k, 3)
   dssd(i, j, k, 3) = 0.0_8
   END IF
   temp5 = ss(i, j, k+1) + two*ss(i, j, k) + ss(i, j, k-1) + sslim
   tempd6 = x3d/temp5
   tempd7 = -((ss(i, j, k+1)-two*ss(i, j, k)+ss(i, j, k-1))*tempd6/&
   &       temp5)
   ssd(i, j, k+1) = ssd(i, j, k+1) + tempd7 + tempd6
   ssd(i, j, k) = ssd(i, j, k) + two*tempd7 - two*tempd6
   ssd(i, j, k-1) = ssd(i, j, k-1) + tempd7 + tempd6
   sslimd = sslimd + tempd7
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x2d = dssd(i, j, k, 2)
   dssd(i, j, k, 2) = 0.0_8
   ELSE
   x2d = -dssd(i, j, k, 2)
   dssd(i, j, k, 2) = 0.0_8
   END IF
   temp4 = ss(i, j+1, k) + two*ss(i, j, k) + ss(i, j-1, k) + sslim
   tempd4 = x2d/temp4
   tempd5 = -((ss(i, j+1, k)-two*ss(i, j, k)+ss(i, j-1, k))*tempd4/&
   &       temp4)
   ssd(i, j+1, k) = ssd(i, j+1, k) + tempd5 + tempd4
   ssd(i, j, k) = ssd(i, j, k) + two*tempd5 - two*tempd4
   ssd(i, j-1, k) = ssd(i, j-1, k) + tempd5 + tempd4
   sslimd = sslimd + tempd5
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   x1d = dssd(i, j, k, 1)
   dssd(i, j, k, 1) = 0.0_8
   ELSE
   x1d = -dssd(i, j, k, 1)
   dssd(i, j, k, 1) = 0.0_8
   END IF
   temp3 = ss(i+1, j, k) + two*ss(i, j, k) + ss(i-1, j, k) + sslim
   tempd2 = x1d/temp3
   tempd3 = -((ss(i+1, j, k)-two*ss(i, j, k)+ss(i-1, j, k))*tempd2/&
   &       temp3)
   ssd(i+1, j, k) = ssd(i+1, j, k) + tempd3 + tempd2
   ssd(i, j, k) = ssd(i, j, k) + two*tempd3 - two*tempd2
   ssd(i-1, j, k) = ssd(i-1, j, k) + tempd3 + tempd2
   sslimd = sslimd + tempd3
   END DO
   CALL POPINTEGER4(j)
   CALL POPINTEGER4(i)
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   DO ii=0,(ib+1)*(jb+1)*(kb+1)-1
   i = MOD(ii, ib + 1)
   j = MOD(ii/(ib+1), jb + 1)
   k = ii/((ib+1)*(jb+1))
   temp2 = gamma(i, j, k)
   temp1 = w(i, j, k, irho)
   temp0 = temp1**temp2
   tempd1 = -(p(i, j, k)*ssd(i, j, k)/temp0**2)
   pd(i, j, k) = pd(i, j, k) + ssd(i, j, k)/temp0
   IF (.NOT.(temp1 .LE. 0.0_8 .AND. (temp2 .EQ. 0.0_8 .OR. temp2 &
   &           .NE. INT(temp2)))) wd(i, j, k, irho) = wd(i, j, k, irho) + &
   &           temp2*temp1**(temp2-1)*tempd1
   IF (.NOT.temp1 .LE. 0.0_8) gammad(i, j, k) = gammad(i, j, k) + &
   &           temp0*LOG(temp1)*tempd1
   ssd(i, j, k) = 0.0_8
   END DO
   temp = rhoinf**gammainf
   tempd = 0.001_realType*sslimd/temp
   tempd0 = -(pinfcorr*tempd/temp)
   pinfcorrd = tempd
   IF (rhoinf .LE. 0.0_8 .AND. (gammainf .EQ. 0.0_8 .OR. gammainf &
   &         .NE. INT(gammainf))) THEN
   rhoinfd = 0.0
   ELSE
   rhoinfd = gammainf*rhoinf**(gammainf-1)*tempd0
   END IF
   IF (.NOT.rhoinf .LE. 0.0_8) gammainfd = gammainfd + temp*LOG(&
   &         rhoinf)*tempd0
   ELSE IF (branch .EQ. 1) THEN
   pd = pd + ssd
   pinfcorrd = 0.001_realType*sslimd
   rhoinfd = 0.0_8
   ELSE
   rhoinfd = 0.0_8
   pinfcorrd = 0.0_8
   END IF
   END IF
   END SUBROUTINE INVISCIDDISSFLUXSCALAR_B

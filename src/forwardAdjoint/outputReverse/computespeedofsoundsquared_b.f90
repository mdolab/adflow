   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of computespeedofsoundsquared in reverse (adjoint) mode (with options i4 dr8 r8 noISIZE):
   !   gradient     of useful results: *aa *p *w
   !   with respect to varying inputs: *p *w
   !   Plus diff mem management of: aa:in p:in w:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          computeSpeedOfSoundSquared.F90                  *
   !      * Author:        Gaetan K.W. Kenway                              *
   !      * Starting date: 01-20-2014                                      *
   !      * Last modified: 01-20-2014                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE COMPUTESPEEDOFSOUNDSQUARED_B()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * computeSpeedOfSoundSquared does what it says.                  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !
   !      Local variables.
   !
   LOGICAL :: correctfork
   REAL(kind=realtype), PARAMETER :: twothird=two*third
   INTEGER(kind=inttype) :: i, j, k, ii
   REAL(kind=realtype) :: pp
   REAL(kind=realtype) :: ppd
   INTRINSIC MOD
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempd
   REAL(kind=realtype) :: tempd0
   REAL(kind=realtype) :: temp
   ! Determine if we need to correct for K
   IF (kpresent) THEN
   IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   IF (correctfork) THEN
   DO ii=0,ie*je*ke-1
   i = MOD(ii, ie) + 1
   j = MOD(ii/ie, je) + 1
   k = ii/(ie*je) + 1
   pp = p(i, j, k) - twothird*w(i, j, k, irho)*w(i, j, k, itu1)
   temp = w(i, j, k, irho)
   tempd = gamma(i, j, k)*aad(i, j, k)/temp
   ppd = tempd
   wd(i, j, k, irho) = wd(i, j, k, irho) - pp*tempd/temp
   aad(i, j, k) = 0.0_8
   pd(i, j, k) = pd(i, j, k) + ppd
   wd(i, j, k, irho) = wd(i, j, k, irho) - twothird*w(i, j, k, itu1)*&
   &       ppd
   wd(i, j, k, itu1) = wd(i, j, k, itu1) - twothird*w(i, j, k, irho)*&
   &       ppd
   END DO
   ELSE
   DO ii=0,ie*je*ke-1
   i = MOD(ii, ie) + 1
   j = MOD(ii/ie, je) + 1
   k = ii/(ie*je) + 1
   temp0 = w(i, j, k, irho)
   tempd0 = gamma(i, j, k)*aad(i, j, k)/temp0
   pd(i, j, k) = pd(i, j, k) + tempd0
   wd(i, j, k, irho) = wd(i, j, k, irho) - p(i, j, k)*tempd0/temp0
   aad(i, j, k) = 0.0_8
   END DO
   END IF
   END SUBROUTINE COMPUTESPEEDOFSOUNDSQUARED_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of block_res_spatial in forward (tangent) mode:
   !   variations   of useful results: *dw *w *x
   !   with respect to varying inputs: *x
   !   RW status of diff variables: *dw:out *w:out *x:in-out
   ! This is a super-combined function that combines the original
   ! functionality of: 
   ! Pressure Computation
   ! timeStep
   ! applyAllBCs
   ! initRes
   ! residual 
   ! The real difference between this and the original modules is that it
   ! it only operates on a single block at a time and as such the
   ! block/sps loop is outside the calculation. This routine is suitable
   ! for forward mode AD with Tapenade
   SUBROUTINE BLOCK_RES_SPATIAL_SPATIAL_D(nn, sps)
   USE SECTION
   USE INPUTPHYSICS
   USE ITERATION
   USE INPUTTIMESPECTRAL
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !,x_peturb)
   ! i/j/kl/b/e, i/j/k/Min/MaxBoundaryStencil
   ! nw
   !nsections
   !timeunsteadyrestart
   REAL(kind=realtype) :: gm1, v2
   INTEGER(kind=inttype) :: nn, sps, i, j, k, sps2, mm, l
   LOGICAL :: correctfork, useoldcoor=.false.
   !for grid velocities computation
   REAL(kind=realtype), DIMENSION(nsections) :: t
   REAL(kind=realtype), DIMENSION(nsections) :: td
   REAL :: result1
   INTRINSIC MAX
   INTRINSIC REAL
   REAL :: timeunsteadyrestart
   !  logical :: x_peturb(0:ie,0:je,0:ke,3)
   !print *,'setpointers'
   CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps, sps)
   ! Do the spatial things first:
   !print *,'xhalo'
   CALL XHALO_BLOCK_SPATIAL_D(1)
   !,x_peturb)
   !print *,'metric'
   CALL METRIC_BLOCK_SPATIAL_D(nn, 1, sps)
   ! Compute the time, which corresponds to this spectral solution.
   ! For steady and unsteady mode this is simply the restart time;
   ! for the spectral mode the periodic time must be taken into
   ! account, which can be different for every section.
   !print *,'time'
   t = timeunsteadyrestart
   IF (equationmode .EQ. timespectral) THEN
   DO nn=1,nsections
   result1 = REAL(ntimeintervalsspectral, realtype)
   td(nn) = 0.0
   t(nn) = t(nn) + (sps-1)*sections(nn)%timeperiod/result1
   END DO
   END IF
   !print *,'gridvel'
   CALL GRIDVELOCITIESFINELEVEL_BLOCK_SPATIAL_D(useoldcoor, t, sps)
   ! Required for TS
   !print *,'normalv'
   CALL NORMALVELOCITIES_BLOCK_SPATIAL_D(sps)
   ! Required for TS
   !call slipVelocitiesFineLevel(.false., t, mm) !required for viscous
   ! Compute the pressures
   !print *,'computep'
   gm1 = gammaconstant - one
   correctfork = .false.
   ! Compute P 
   DO k=0,kb
   DO j=0,jb
   DO i=0,ib
   v2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
   &          2
   pd(i, j, k) = 0.0
   p(i, j, k) = gm1*(w(i, j, k, irhoe)-half*w(i, j, k, irho)*v2)
   IF (p(i, j, k) .LT. 1.e-4_realType*pinfcorr) THEN
   pd(i, j, k) = 0.0
   p(i, j, k) = 1.e-4_realType*pinfcorr
   ELSE
   pd(i, j, k) = 0.0
   p(i, j, k) = p(i, j, k)
   END IF
   END DO
   END DO
   END DO
   !call computeEtot(0,ib,0,jb,0,kb,correctForK)
   !  Apply all BC's
   CALL APPLYALLBC_BLOCK_SPATIAL_D(.true.)
   ! Compute skin_friction Velocity
   CALL COMPUTEUTAU_BLOCK()
   ! Compute time step and spectral radius
   CALL TIMESTEP_BLOCK_SPATIAL_D(.false.)
   !   if( equations == RANSEquations ) then
   !      call initres_block(nt1MG, nMGVar,nn,sps) ! Initialize only the Turblent Variables
   !      call turbResidual_block
   !   endif
   SELECT CASE  (equationmode) 
   CASE (steady) 
   dw = 0.0
   CASE (timespectral) 
   DO sps2=1,ntimeintervalsspectral
   CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps2, sps2)
   dw = 0.0
   DO mm=1,ntimeintervalsspectral
   CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps2, mm)
   CALL INITRES_BLOCK_TS(1, nwf, nn, sps2, mm)
   END DO
   END DO
   END SELECT
   ! Rest the pointers the the "on time instance"
   CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps, sps)
   ! Actual residual calc
   CALL RESIDUAL_BLOCK_SPATIAL_D()
   ! Divide through by the volume
   DO sps2=1,ntimeintervalsspectral
   CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps2, sps2)
   DO l=1,nw
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   dwd(i, j, k, l) = (dwd(i, j, k, l)*vol(i, j, k)-dw(i, j, k, &
   &              l)*vold(i, j, k))/vol(i, j, k)**2
   dw(i, j, k, l) = dw(i, j, k, l)/vol(i, j, k)
   END DO
   END DO
   END DO
   END DO
   END DO
   END SUBROUTINE BLOCK_RES_SPATIAL_SPATIAL_D

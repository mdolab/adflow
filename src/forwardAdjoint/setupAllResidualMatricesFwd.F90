!
!     ******************************************************************
!     *                                                                *
!     * File:          setupAllResidualMatricesFwd.F90                 *
!     * Author:        C.A.(Sandy) Mader                               *
!     * Starting date: 14-07-2011                                      *
!     * Last modified: 14-07-2011                                      *
!     *                                                                *
!     ******************************************************************
!
subroutine setupAllResidualMatricesfwd
#ifndef USE_COMPLEX
  !
  !     ******************************************************************
  !     *                                                                *
  !     * Combines all of the redidual setting routines into one....     *
  !     * Compute the transpose of the matrix dRdW of the discrete       *
  !     * ADjoint problem for                                            *
  !     * subsequent use by the solveADjointPETSc subroutine. The entries*
  !     * in dRdw are obtained using the automatically differentiated    *
  !     * routines generated by Tapenade.                                *
  !     *                                                                *
  !     * The ordering of the unknowns in the ADjoint matrix used here   *
  !     * is based on the global node numbering and is consistent with   *
  !     * the ordering used in the vector for the ADjoint problem        *
  !     * assembled in setupADjointRHS.                                  *
  !     *                                                                *
  !     ******************************************************************
  !
  use ADjointPETSc
  use ADjointVars 
  use blockPointers
  use cgnsGrid     
  use communication    
  use inputDiscretization 
  USE inputTimeSpectral   
  use iteration           
  use flowVarRefState     
  use inputADjoint       
  use section            
  use monitor            
  use diffsizes
  implicit none
  !
  !     Local variables.
  !
  integer(kind=intType) ::level
  integer(kind=intType) :: iCell, jCell, kCell
  integer(kind=intType) :: nn, m, idxres

  logical :: fineGrid, correctForK, exchangeTurb, secondhalo
  logical :: useAD, useTranspose, usePC, useObjective

  real(kind=realType), dimension(2) :: time
  real(kind=realType)               :: timeAdjLocal, timeAdj

  integer(kind=intType) :: sps,i, ierr

  !temporary storage for current dissipation coefficients. Used in error check
  real(kind=realType)::vis2ref, vis4ref

#ifndef USE_NO_PETSC

  if( myid ==0 ) &
       write(*, 10) "Assembling All Residual Matrices in Forward mode..."
  
  call cpu_time(time(1))

  !zero the matrix for dRdW Insert call
  call MatZeroEntries(dRdwt, PETScIerr)
  call EChk(PETScIerr, __FILE__, __LINE__)

  !zero the matrix for dRdx ADD call
  call MatZeroEntries(dRdx, PETScIerr)
  call EChk(PETScIerr, __FILE__, __LINE__)
  
  !zero the matrix for dRda  call
  call MatZeroEntries(dRda, PETScIerr)
  call EChk(PETScIerr, __FILE__, __LINE__)

  ! Compute dRdw with forward AD
  useAD = .True.
  usePC = .False.
  useTranspose = .True.
  useObjective = .True.

  call setupStateResidualMatrix(drdwT, useAD, usePC, useTranspose, useObjective, &
       1_intType)
  call setupSpatialResidualMatrix(drdx, useAD, useObjective)
  call setupExtraResidualMatrix(drda, useAD)

  if (nDesignDissError >= 0) then
     !==================================
     !Compute Dissipation error estimate
     !==================================
     
     !store dissipation coefficients
     vis2ref = vis2
     vis4ref = vis4
     
     !set dissipation coefficients to zero
     vis2 = 0.0
     vis4 = 0.0
     
     !evaluate new residual
     call whalo2(1_intType, 1_intType, nw, .True., .True., .True.)
     call computeResidualNK ! This is the easiest way to do this
     
     !Store updated residual. This is an indication of how much error
     !the dissipation scheme is causing
     
     do nn=1, nDom
        
        ! Loop over the number of time instances for this block.
        do sps=1, nTimeIntervalsSpectral
           
           call setPointers(nn, level, sps)
           
           ! Set unknown sizes in diffSizes for AD routine
           ISIZE1OFDrfbcdata = nBocos
           ISIZE1OFDrfviscsubface = nViscBocos

           ! Loop over location of output (R) cell of residual
           do kCell = 2, kl
              do jCell = 2, jl
                 do iCell = 2, il
                    do m = 1, nw 
                       idxres   = globalCell(iCell, jCell, kCell)*nw+ m - 1
                       
                       call MatSetValues(dRda, 1, idxres, 1, nDesignDissError, &
                            dw(icell, jcell, kcell, m), INSERT_VALUES, &
                            PETScIerr)
                       
                       call EChk(PETScIerr, __FILE__, __LINE__)

                    end do
                 end do
              end do
           end do
        end do
     end do

     !Now restore the original residual

     !reset the original dissipation coefficients
     vis2 = vis2ref
     vis4 = vis4ref

     !reevaluate residual
     call whalo2(1_intType, 1_intType, nw, .True., .True., .True.)
     call computeResidualNK
     
     !reassemble dRda with error term included  
     call MatAssemblyBegin(dRda, MAT_FINAL_ASSEMBLY, PETScIerr)
     call EChk(PETScIerr, __FILE__, __LINE__)
          
     call MatAssemblyEnd(dRda, MAT_FINAL_ASSEMBLY, PETScIerr)
     call EChk(PETScIerr, __FILE__, __LINE__)
  end if

  ! Get new time and compute the elapsed time.

  call cpu_time(time(2))
  timeAdjLocal = time(2)-time(1)

  ! Determine maximum time using MPI reduce
  ! with operation mpi_max.

  call mpi_reduce(timeAdjLocal, timeAdj, 1, sumb_real, &
       mpi_max, 0, SUMB_COMM_WORLD, PETScIerr)
  call EChk(PETScIerr, __FILE__, __LINE__)
  if(myid ==0) &
       write(*, 20) "Assembling All Residaul Matrices Fwd time (s) = ", timeAdj

  ! Output formats.
#endif
 
10 format(a)
20 format(a, 1x, f8.2)
99 format(a, 1x, i6)
 
#endif
end subroutine setupAllResidualMatricesfwd

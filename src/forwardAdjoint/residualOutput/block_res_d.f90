   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
   !
   !  Differentiation of block_res in forward (tangent) mode:
   !   variations   of useful results: *(flowdoms.x) flowdoms.w flowdoms.dw
   !   with respect to varying inputs: *(flowdoms.x) flowdoms.w
   !   RW status of diff variables: *(flowdoms.x):in-out flowdoms.w:in-out
   !                flowdoms.dw:out
   !   Plus diff mem management of: flowdoms.x:in flowdoms.temphalo:in
   !                rev:in dtl:in p:in sfacei:in sfacej:in gamma:in
   !                sfacek:in rlv:in vol:in si:in sj:in sk:in fw:in
   !                rotmatrixi:in rotmatrixj:in rotmatrixk:in *bcdata.norm:in
   !                radi:in radj:in radk:in
   ! This is a super-combined function that combines the original
   ! functionality of: 
   ! Pressure Computation
   ! timeStep
   ! applyAllBCs
   ! initRes
   ! residual 
   ! The real difference between this and the original modules is that it
   ! it only operates on a single block at a time and as such the nominal
   ! block/sps loop is outside the calculation. This routine is suitable
   ! for forward mode AD with Tapenade
   SUBROUTINE BLOCK_RES_D(nn, sps, usespatial, useextra)
   USE FLOWVARREFSTATE
   USE MONITOR
   USE BLOCKPOINTERS_D
   USE SECTION
   USE INPUTTIMESPECTRAL
   USE INPUTPHYSICS
   USE DIFFSIZES
   !  Hint: ISIZE1OFflowdoms should be the size of dimension 1 of array flowdoms
   !  Hint: ISIZE2OFflowdoms should be the size of dimension 2 of array flowdoms
   !  Hint: ISIZE3OFflowdoms should be the size of dimension 3 of array flowdoms
   IMPLICIT NONE
   ! ------------------------------------------------
   !        Additional 'Extra' Components
   ! ------------------------------------------------
   !dw(i,j,k,l) = vol(i,j,k) + sum(si(i,j,k,:)) + sum(sj(i,j,k,:)) + sum(sk(i,j,k,:))
   ! end do
   ! Reset dw and vol to sps instance
   !  dw => flowDoms(nn,1,sps)%dw
   !  vol => flowDoms(nn,1,sps)%vol
   !alpha, beta, liftIndex,
   ! Input Arguments:
   INTEGER(kind=inttype), INTENT(IN) :: nn, sps
   !real(kind=realType), intent(in) :: alpha, beta
   !integer(kind=intType), intent(in) :: liftIndex
   LOGICAL, INTENT(IN) :: usespatial, useextra
   ! Working Variables
   REAL(kind=realtype) :: gm1, v2
   REAL(kind=realtype) :: v2d
   INTEGER(kind=inttype) :: i, j, k, sps2, mm, l
   REAL(kind=realtype), DIMENSION(nsections) :: t
   LOGICAL :: useoldcoor
   REAL(realtype) :: result1
   INTRINSIC MAX
   INTRINSIC REAL
   INTEGER :: ii3
   INTEGER :: ii2
   INTEGER :: ii1
   useoldcoor = .false.
   ! Set pointers to input/output variables
   wd => flowdomsd(nn, 1, sps)%w
   w => flowdoms(nn, 1, sps)%w

   dwd => flowdomsd(nn, 1, sps)%dw
   dw => flowdoms(nn, 1, sps)%dw
   xd => flowdomsd(nn, 1, sps)%x
   x => flowdoms(nn, 1, sps)%x
   !  call adjustInflowAngle(alpha,beta,liftIndex)
   !      call referenceState_mod()
   !      call setFlowInfinityState()
   ! ------------------------------------------------
   !        Additional Spatial Components
   ! ------------------------------------------------
   IF (usespatial .OR. useextra) THEN
   CALL XHALO_BLOCK_D(nn, 1, sps)
   CALL METRIC_BLOCK_D(nn, 1, sps)
   t = timeunsteadyrestart
   IF (equationmode .EQ. timespectral) THEN
   DO mm=1,nsections
   result1 = REAL(ntimeintervalsspectral, realtype)
   t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/result1
   END DO
   END IF
   ELSE
   vold = 0.0
   sid = 0.0
   sjd = 0.0
   skd = 0.0
   END IF
   !call gridVelocitiesFineLevel_block(useOldCoor, t, sps) ! Required for TS
   !call normalVelocities_block(sps) ! Required for TS
   !call slipVelocitiesFineLevel(.false., t, mm) !required for wall Functions
   ! ------------------------------------------------
   !        Normal Residual Computation
   ! ------------------------------------------------
   ! Compute the pressures
   gm1 = gammaconstant - one
   pd = 0.0
   ! Compute P 
   DO k=0,kb
   DO j=0,jb
   DO i=0,ib
   v2d = 2*w(i, j, k, ivx)*wd(i, j, k, ivx) + 2*w(i, j, k, ivy)*wd(&
   &          i, j, k, ivy) + 2*w(i, j, k, ivz)*wd(i, j, k, ivz)
   v2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
   &          2
   pd(i, j, k) = gm1*(wd(i, j, k, irhoe)-half*(wd(i, j, k, irho)*v2&
   &          +w(i, j, k, irho)*v2d))
   p(i, j, k) = gm1*(w(i, j, k, irhoe)-half*w(i, j, k, irho)*v2)
   IF (p(i, j, k) .LT. 1.e-4_realType*pinfcorr) THEN
   pd(i, j, k) = 0.0
   p(i, j, k) = 1.e-4_realType*pinfcorr
   ELSE
   p(i, j, k) = p(i, j, k)
   END IF
   END DO
   END DO
   END DO
   ! Compute Laminar/eddy viscosity if required
   !call computeLamViscosity
   !call computeEddyViscosity
   !  Apply all BC's
   !call applyAllBC_block(.True.)
   ! Compute skin_friction Velocity
   !call computeUtau_block
   ! Compute time step and spectral radius
   CALL TIMESTEP_BLOCK_D(.false.)
   ! !   if( equations == RANSEquations ) then
   ! !      ! Initialize only the Turblent Variables
   ! !      call initres_block(nt1MG, nMGVar,nn,sps) 
   ! !      call turbResidual_block
   ! !   endif
   ! Next initialize residual for flow variables. The is the only place
   ! where there is an n^2 dependance
   !  do sps2 = 1,nTimeIntervalsSpectral
   !      dw => flowDoms(nn,1,sps2)%dw
   dwd = 0.0
   dw = zero
   !call initRes_block(1,nwf, nn, sps2)
   !  end do
   ! Reset dw pointer to sps instance
   ! dw => flowDoms(nn,1,sps)%dw
   !  Actual residual calc
   CALL RESIDUAL_BLOCK_D()
   ! Divide through by the volume
   !  do sps2 = 1,nTimeIntervalsSpectral
   ! Set dw and vol to looping sps2 instance
   !dw => flowDoms(nn,1,sps2)%dw
   !vol => flowDoms(nn,1,sps2)%vol
   !si => flowDoms(nn,1,sps2)%si
   !sj => flowDoms(nn,1,sps2)%sj
   !sk => flowDoms(nn,1,sps2)%sk
   DO l=1,nw
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   !dw(i,j,k,l) = radI(i,j,k) + radJ(i,j,k) + radK(i,j,k)
   dwd(i, j, k, l) = (dwd(i, j, k, l)*vol(i, j, k)-dw(i, j, k, l)&
   &            *vold(i, j, k))/vol(i, j, k)**2
   dw(i, j, k, l) = dw(i, j, k, l)/vol(i, j, k)
   END DO
   END DO
   END DO
   END DO
   END SUBROUTINE BLOCK_RES_D

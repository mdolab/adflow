!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
!
!  Differentiation of block_res in forward (tangent) mode:
!   variations   of useful results: *(*flowdoms.w) *(*flowdoms.dw)
!   with respect to varying inputs: *(*flowdoms.w)
!   RW status of diff variables: *(*flowdoms.w):in-out *(*flowdoms.dw):out
!   Plus diff mem management of: flowdoms:in *flowdoms.x:in *flowdoms.w:in
!                *flowdoms.dw:in rev:in dtl:in bvtj1:in bvtj2:in
!                p:in sfacei:in sfacej:in s:in gamma:in sfacek:in
!                bmtk1:in bmtk2:in rlv:in bvtk1:in bvtk2:in vol:in
!                d2wall:in bmti1:in bmti2:in si:in sj:in sk:in
!                bvti1:in bvti2:in fw:in rotmatrixi:in rotmatrixj:in
!                rotmatrixk:in bmtj1:in bmtj2:in viscsubface:in
!                *viscsubface.tau:in *viscsubface.q:in *viscsubface.utau:in
!                *bcdata.norm:in *bcdata.rface:in *bcdata.uslip:in
!                *bcdata.tns_wall:in radi:in radj:in radk:in winf:in
!                (global)cphint:in
! This is a super-combined function that combines the original
! functionality of: 
! Pressure Computation
! timeStep
! applyAllBCs
! initRes
! residual 
! The real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the nominal
! block/sps loop is outside the calculation. This routine is suitable
! for forward mode AD with Tapenade
SUBROUTINE BLOCK_RES_D(nn, sps, usespatial, useextra)
  USE FLOWVARREFSTATE
  USE BLOCKPOINTERS_D
  USE SECTION
  USE INPUTTIMESPECTRAL
  USE INPUTPHYSICS
  USE ITERATION
  IMPLICIT NONE
  !      call adjustInflowAngle(alpha,beta,liftIndex)
  !      call referenceState_mod()
  !      call setFlowInfinityState()
  ! ------------------------------------------------
  !        Additional Spatial Components
  ! ------------------------------------------------
  ! ------------------------------------------------
  !        Additional 'Extra' Components
  ! ------------------------------------------------
  !alpha, beta, liftIndex,
  ! Input Arguments:
  INTEGER(kind=inttype), INTENT(IN) :: nn, sps
  !real(kind=realType), intent(in) :: alpha, beta
  !integer(kind=intType), intent(in) :: liftIndex
  LOGICAL, INTENT(IN) :: usespatial, useextra
  ! Working Variables
  REAL(kind=realtype) :: gm1, v2
  REAL(kind=realtype) :: v2d
  INTEGER(kind=inttype) :: i, j, k, sps2, mm, l
  REAL(kind=realtype), DIMENSION(nsections) :: t
  LOGICAL :: useoldcoor
  INTRINSIC MAX
  useoldcoor = .false.
  ! Set pointers to input/output variables
  wd => flowdomsd(nn, currentlevel, sps)%w
  w => flowdoms(nn, currentlevel, sps)%w
  dwd => flowdomsd(nn, 1, sps)%dw
  dw => flowdoms(nn, 1, sps)%dw
  xd => flowdomsd(nn, currentlevel, sps)%x
  x => flowdoms(nn, currentlevel, sps)%x
  !  call xhalo_block(nn,1,sps)
  !      call metric_block(nn,1,sps)
  !      t = timeUnsteadyRestart
  !      if(equationMode == timeSpectral) then
  !         do mm=1,nSections
  !            t(mm) = t(mm) + (sps-1)*sections(mm)%timePeriod &
  !                 /         real(nTimeIntervalsSpectral,realType)
  !         enddo
  !      endif
  !call gridVelocitiesFineLevel_block(useOldCoor, t, sps) ! Required for TS
  !call normalVelocities_block(sps) ! Required for TS
  !call slipVelocitiesFineLevel(.false., t, mm) !required for wall Functions
  ! ------------------------------------------------
  !        Normal Residual Computation
  ! ------------------------------------------------
  ! Compute the pressures
  gm1 = gammaconstant - one
  pd = 0.0
  ! Compute P 
  DO k=0,kb
     DO j=0,jb
        DO i=0,ib
           v2d = 2*w(i, j, k, ivx)*wd(i, j, k, ivx) + 2*w(i, j, k, ivy)*wd(&
                &          i, j, k, ivy) + 2*w(i, j, k, ivz)*wd(i, j, k, ivz)
           v2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
                &          2
           pd(i, j, k) = gm1*(wd(i, j, k, irhoe)-half*(wd(i, j, k, irho)*v2&
                &          +w(i, j, k, irho)*v2d))
           p(i, j, k) = gm1*(w(i, j, k, irhoe)-half*w(i, j, k, irho)*v2)
           IF (p(i, j, k) .LT. 1.e-4_realType*pinfcorr) THEN
              pd(i, j, k) = 0.0
              p(i, j, k) = 1.e-4_realType*pinfcorr
           ELSE
              p(i, j, k) = p(i, j, k)
           END IF
        END DO
     END DO
  END DO
  ! Compute Laminar/eddy viscosity if required
  CALL COMPUTELAMVISCOSITY_D()
  !call computeEddyViscosity # Required for turblence models
  !  Apply all BC's
  CALL APPLYALLBC_BLOCK_D(.true.)
  ! Compute skin_friction Velocity (only for wall Functions)
  !call computeUtau_block
  ! Compute time step and spectral radius
  CALL TIMESTEP_BLOCK_D(.false.)
  !   if( equations == RANSEquations ) then
  !      ! Initialize only the Turblent Variables
  !      call initres_block(nt1MG, nMGVar,nn,sps) 
  !      call turbResidual_block
  !   endif
  ! Next initialize residual for flow variables. The is the only place
  ! where there is an n^2 dependance
  !   do sps2 = 1,nTimeIntervalsSpectral
  !      dw => flowDoms(nn, 1, sps2)%dw
  !      call initRes_block(1, nwf, nn, sps2)
  !   end do
  !   ! Reset dw pointer to sps instance
  !   dw => flowDoms(nn, 1, sps)%dw
  dwd = 0.0
  dw = zero
  !  Actual residual calc
  CALL RESIDUAL_BLOCK_D()
  ! Divide through by the volume
  DO sps2=1,ntimeintervalsspectral
     ! Set dw and vol to looping sps2 instance
     dwd => flowdomsd(nn, 1, sps2)%dw
     dw => flowdoms(nn, 1, sps2)%dw
     vold => flowdomsd(nn, currentlevel, sps2)%vol
     vol => flowdoms(nn, currentlevel, sps2)%vol
     DO l=1,nw
        DO k=2,kl
           DO j=2,jl
              DO i=2,il
                 dwd(i, j, k, l) = dwd(i, j, k, l)/vol(i, j, k)
                 dw(i, j, k, l) = dw(i, j, k, l)/vol(i, j, k)
              END DO
           END DO
        END DO
     END DO
  END DO
  ! Reset dw and vol to sps instance
  dwd => flowdomsd(nn, 1, sps)%dw
  dw => flowdoms(nn, 1, sps)%dw
  vold => flowdomsd(nn, currentlevel, sps)%vol
  vol => flowdoms(nn, currentlevel, sps)%vol
END SUBROUTINE BLOCK_RES_D

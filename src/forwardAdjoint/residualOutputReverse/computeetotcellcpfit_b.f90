   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
   !
   !  Differentiation of computeetotcellcpfit in reverse (adjoint) mode:
   !   gradient     of useful results: *p *gamma *w
   !   with respect to varying inputs: *p *gamma *w cv0 *cptrange
   !                *cpeint *(*cptempfit.constants) *cptempfit.eint0
   !                cvn
   !   Plus diff mem management of: p:in gamma:in w:in cptrange:in
   !                cpeint:in cptempfit:in
   !      ==================================================================
   SUBROUTINE COMPUTEETOTCELLCPFIT_B(i, j, k, scale, correctfork)
   USE BLOCKPOINTERS_B
   USE CPCURVEFITS
   USE FLOWVARREFSTATE
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfcptempfit should be the size of dimension 1 of array *cptempfit
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * ComputeEtotCellCpfit will compute the total energy for the     *
   !      * given cell of the block given by the current pointers with the *
   !      * cp temperature curve fit model.                                *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: twothird=two*third
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: i, j, k
   REAL(kind=realtype), INTENT(IN) :: scale
   LOGICAL, INTENT(IN) :: correctfork
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, mm, ii, start
   REAL(kind=realtype) :: pp, t, t2, cv, eint
   REAL(kind=realtype) :: ppb, tb, t2b, cvb, eintb
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   INTEGER :: branch
   REAL(kind=realtype) :: temp2
   REAL(kind=realtype) :: temp1
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: temp0b
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tmp0b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: temp0b0
   INTRINSIC LOG
   INTEGER :: ii1
   REAL(kind=realtype) :: temp
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the dimensional temperature.
   pp = p(i, j, k)
   IF (correctfork) THEN
   pp = pp - twothird*w(i, j, k, irho)*w(i, j, k, itu1)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   t = tref*pp/(rgas*w(i, j, k, irho))
   ! Determine the case we are having here.
   IF (t .LE. cptrange(0)) THEN
   ! Temperature is less than the smallest temperature
   ! in the curve fits. Use extrapolation using
   ! constant cv.
   eint = scale*(cpeint(0)+cv0*(t-cptrange(0)))
   CALL PUSHCONTROL2B(0)
   ELSE IF (t .GE. cptrange(cpnparts)) THEN
   ! Temperature is larger than the largest temperature
   ! in the curve fits. Use extrapolation using
   ! constant cv.
   eint = scale*(cpeint(cpnparts)+cvn*(t-cptrange(cpnparts)))
   CALL PUSHCONTROL2B(1)
   ELSE
   ! Temperature is in the curve fit range.
   ! First find the valid range.
   ii = cpnparts
   start = 1
   ! Next guess for the interval.
   100 nn = start + ii/2
   ! Determine the situation we are having here.
   IF (t .GT. cptrange(nn)) THEN
   ! Temperature is larger than the upper boundary of
   ! the current interval. Update the lower boundary.
   start = nn + 1
   ii = ii - 1
   ELSE IF (t .GE. cptrange(nn-1)) THEN
   GOTO 110
   END IF
   ! This is the correct range. Exit the do-loop.
   ! Modify ii for the next branch to search.
   ii = ii/2
   GOTO 100
   ! Nn contains the correct curve fit interval.
   ! Integrate cv to compute eint.
   110 eint = cptempfit(nn)%eint0 - t
   cv = -one
   DO ii=1,cptempfit(nn)%nterm
   t2 = t**cptempfit(nn)%exponents(ii)
   cv = cv + cptempfit(nn)%constants(ii)*t2
   IF (cptempfit(nn)%exponents(ii) .EQ. -1) THEN
   eint = eint + cptempfit(nn)%constants(ii)*LOG(t)
   CALL PUSHCONTROL1B(1)
   ELSE
   mm = cptempfit(nn)%exponents(ii) + 1
   CALL PUSHREAL8(t2)
   t2 = t*t2
   eint = eint + cptempfit(nn)%constants(ii)*t2/mm
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   eint = scale*eint
   CALL PUSHCONTROL2B(2)
   END IF
   ! Compute the total energy per unit volume.
   tmp = w(i, j, k, irho)*(eint+half*(w(i, j, k, ivx)**2+w(i, j, k, ivy)&
   &    **2+w(i, j, k, ivz)**2))
   CALL PUSHREAL8(w(i, j, k, irhoe))
   w(i, j, k, irhoe) = tmp
   IF (correctfork) THEN
   tmp0b = wb(i, j, k, irhoe)
   wb(i, j, k, irhoe) = tmp0b
   wb(i, j, k, irho) = wb(i, j, k, irho) + w(i, j, k, itu1)*tmp0b
   wb(i, j, k, itu1) = wb(i, j, k, itu1) + w(i, j, k, irho)*tmp0b
   END IF
   CALL POPREAL8(w(i, j, k, irhoe))
   tmpb = wb(i, j, k, irhoe)
   wb(i, j, k, irhoe) = 0.0_8
   temp2 = w(i, j, k, ivz)
   temp1 = w(i, j, k, ivy)
   temp0 = w(i, j, k, ivx)
   temp0b = w(i, j, k, irho)*tmpb
   temp0b0 = half*temp0b
   wb(i, j, k, irho) = wb(i, j, k, irho) + (eint+half*(temp0**2+temp1**2+&
   &    temp2**2))*tmpb
   eintb = temp0b
   wb(i, j, k, ivx) = wb(i, j, k, ivx) + 2*temp0*temp0b0
   wb(i, j, k, ivy) = wb(i, j, k, ivy) + 2*temp1*temp0b0
   wb(i, j, k, ivz) = wb(i, j, k, ivz) + 2*temp2*temp0b0
   CALL POPCONTROL2B(branch)
   IF (branch .EQ. 0) THEN
   gammab(i, j, k) = 0.0_8
   tb = scale*cv0*eintb
   ELSE IF (branch .EQ. 1) THEN
   gammab(i, j, k) = 0.0_8
   tb = scale*cvn*eintb
   ELSE
   cvb = (1.0/cv-(one+cv)/cv**2)*gammab(i, j, k)
   gammab(i, j, k) = 0.0_8
   eintb = scale*eintb
   tb = 0.0_8
   DO ii=cptempfit(nn)%nterm,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   mm = cptempfit(nn)%exponents(ii) + 1
   t2b = cptempfit(nn)%constants(ii)*eintb/mm
   CALL POPREAL8(t2)
   tb = tb + t2*t2b
   t2b = t*t2b
   ELSE
   tb = tb + cptempfit(nn)%constants(ii)*eintb/t
   t2b = 0.0_8
   END IF
   t2b = t2b + cptempfit(nn)%constants(ii)*cvb
   IF (.NOT.(t .LE. 0.0 .AND. (cptempfit(nn)%exponents(ii) .EQ. 0.0 &
   &          .OR. cptempfit(nn)%exponents(ii) .NE. INT(cptempfit(nn)%&
   &          exponents(ii))))) tb = tb + cptempfit(nn)%exponents(ii)*t**(&
   &          cptempfit(nn)%exponents(ii)-1)*t2b
   END DO
   tb = tb - eintb
   END IF
   temp = rgas*w(i, j, k, irho)
   tempb = tref*tb/temp
   ppb = tempb
   wb(i, j, k, irho) = wb(i, j, k, irho) - pp*rgas*tempb/temp
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   wb(i, j, k, irho) = wb(i, j, k, irho) - twothird*w(i, j, k, itu1)*&
   &      ppb
   wb(i, j, k, itu1) = wb(i, j, k, itu1) - twothird*w(i, j, k, irho)*&
   &      ppb
   END IF
   pb(i, j, k) = pb(i, j, k) + ppb
   cv0b = 0.0_8
   cptrangeb = 0.0_8
   cpeintb = 0.0_8
   DO ii1=1,ISIZE1OFDrfcptempfit
   cptempfitb(ii1)%constants = 0.0_8
   END DO
   cptempfitb%eint0 = 0.0_8
   cvnb = 0.0_8
   END SUBROUTINE COMPUTEETOTCELLCPFIT_B

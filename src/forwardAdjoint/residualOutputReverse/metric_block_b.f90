   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
   !
   !  Differentiation of metric_block in reverse (adjoint) mode:
   !   gradient     of useful results: *x *vol *si *sj *sk *(*bcdata.norm)
   !   with respect to varying inputs: *x
   !   Plus diff mem management of: x:in vol:in si:in sj:in sk:in
   !                bcdata:in *bcdata.norm:in
   SUBROUTINE METRIC_BLOCK_B()
   USE CGNSGRID
   USE BLOCKPOINTERS_B
   USE INPUTTIMESPECTRAL
   USE BCTYPES
   USE COMMUNICATION
   IMPLICIT NONE
   ! This is COPY of metric.f90. It was necessary to copy this file
   ! since there is debugging stuff in the original that is not
   ! necessary for AD.
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: thresvolume=1.e-2_realType
   !
   !      Local variables.
   !
   INTEGER :: ierr
   INTEGER(kind=inttype) :: i, j, k, n, m, l
   INTEGER(kind=inttype) :: nn, mm, sps
   INTEGER(kind=inttype) :: nvolneg, nvolpos
   INTEGER(kind=inttype) :: nvolbad, nvolbadglobal
   INTEGER(kind=inttype) :: nblockbad, nblockbadglobal
   REAL(kind=realtype) :: fact, mult
   REAL(kind=realtype) :: factb
   REAL(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
   REAL(kind=realtype) :: xpb, ypb, zpb, vp1b, vp2b, vp3b, vp4b, vp5b, &
   &  vp6b
   REAL(kind=realtype), DIMENSION(3) :: v1, v2
   REAL(kind=realtype), DIMENSION(3) :: v1b, v2b
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssb
   CHARACTER(len=10) :: integerstring
   LOGICAL :: checkk, checkj, checki, checkall
   LOGICAL :: badvolume
   REAL(kind=realtype) :: tmp
   REAL(kind=realtype) :: tmp0
   REAL(kind=realtype) :: tmp1
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   REAL(kind=realtype) :: tempb9
   REAL(kind=realtype) :: tempb8
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tmpb
   REAL(kind=realtype) :: tempb12
   REAL(kind=realtype) :: tempb11
   REAL(kind=realtype) :: tmp0b
   REAL(kind=realtype) :: tempb10
   INTRINSIC ABS
   REAL(kind=realtype) :: tempb
   INTRINSIC SQRT
   REAL(kind=realtype) :: tmp1b
   INTERFACE 
   SUBROUTINE PUSHPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE PUSHPOINTER4
   SUBROUTINE LOOKPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE LOOKPOINTER4
   SUBROUTINE POPPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE POPPOINTER4
   END INTERFACE
      !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the volumes. The hexahedron is split into 6 pyramids
   ! whose volumes are computed. The volume is positive for a
   ! right handed block.
   ! Initialize the volumes to zero. The reasons is that the second
   ! level halo's must be initialized to zero and for convenience
   ! all the volumes are set to zero.
   vol = zero
   DO k=1,ke
   CALL PUSHINTEGER4(n)
   n = k - 1
   DO j=1,je
   CALL PUSHINTEGER4(m)
   m = j - 1
   DO i=1,ie
   l = i - 1
   CALL PUSHREAL8(xp)
   ! Compute the coordinates of the center of gravity.
   xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j, n&
   &          , 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n, 1))
   CALL PUSHREAL8(yp)
   yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j, n&
   &          , 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n, 2))
   CALL PUSHREAL8(zp)
   zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j, n&
   &          , 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n, 3))
   ! Compute the volumes of the 6 sub pyramids. The
   ! arguments of volpym must be such that for a (regular)
   ! right handed hexahedron all volumes are positive.
   CALL VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i&
   &                 , j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1)&
   &                 , x(i, m, n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, &
   &                 k, 2), x(i, m, k, 3), vp1)
   CALL VOLPYM(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l&
   &                 , m, k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1)&
   &                 , x(l, m, n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, &
   &                 n, 2), x(l, j, n, 3), vp2)
   CALL VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l&
   &                 , j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1)&
   &                 , x(l, j, n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, &
   &                 n, 2), x(i, j, n, 3), vp3)
   CALL VOLPYM(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i&
   &                 , m, n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1)&
   &                 , x(l, m, n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, &
   &                 k, 2), x(l, m, k, 3), vp4)
   CALL VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i&
   &                 , m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1)&
   &                 , x(l, m, k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, &
   &                 k, 2), x(l, j, k, 3), vp5)
   CALL VOLPYM(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l&
   &                 , j, n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1)&
   &                 , x(l, m, n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, &
   &                 n, 2), x(i, m, n, 3), vp6)
   ! Set the volume to 1/6 of the sum of the volumes of the
   ! pyramid. Remember that volpym computes 6 times the
   ! volume.
   vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
   IF (vol(i, j, k) .GE. 0.) THEN
   CALL PUSHCONTROL1B(0)
   vol(i, j, k) = vol(i, j, k)
   ELSE
   vol(i, j, k) = -vol(i, j, k)
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   END DO
   END DO
   ! Some additional safety stuff for halo volumes.
   DO k=2,kl
   DO j=2,jl
   IF (vol(1, j, k) .LE. eps) THEN
   vol(1, j, k) = vol(2, j, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vol(ie, j, k) .LE. eps) THEN
   tmp = vol(il, j, k)
   vol(ie, j, k) = tmp
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   DO k=2,kl
   DO i=1,ie
   IF (vol(i, 1, k) .LE. eps) THEN
   vol(i, 1, k) = vol(i, 2, k)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vol(i, je, k) .LE. eps) THEN
   tmp0 = vol(i, jl, k)
   vol(i, je, k) = tmp0
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   DO j=1,je
   DO i=1,ie
   IF (vol(i, j, 1) .LE. eps) THEN
   vol(i, j, 1) = vol(i, j, 2)
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   IF (vol(i, j, ke) .LE. eps) THEN
   tmp1 = vol(i, j, kl)
   vol(i, j, ke) = tmp1
   CALL PUSHCONTROL1B(1)
   ELSE
   CALL PUSHCONTROL1B(0)
   END IF
   END DO
   END DO
   ! Set the factor in the surface normals computation. For a
   ! left handed block this factor is negative, such that the
   ! normals still point in the direction of increasing index.
   ! The formulae used later on assume a right handed block
   ! and fact is used to correct this for a left handed block,
   ! as well as the scaling factor of 0.5
   IF (righthanded) THEN
   fact = half
   ELSE
   fact = -half
   END IF
   ! Check if both positive and negative volumes occur. If so,
   ! the block is bad and the counter nBlockBad is updated.
   !
   !          **************************************************************
   !          *                                                            *
   !          * Computation of the face normals in i-, j- and k-direction. *
   !          * Formula's are valid for a right handed block; for a left   *
   !          * handed block the correct orientation is obtained via fact. *
   !          * The normals point in the direction of increasing index.    *
   !          * The absolute value of fact is 0.5, because the cross       *
   !          * product of the two diagonals is twice the normal vector.   *
   !          *                                                            *
   !          * Note that also the normals of the first level halo cells   *
   !          * are computed. These are needed for the viscous fluxes.     *
   !          *                                                            *
   !          **************************************************************
   !
   ! Projected areas of cell faces in the i direction.
   DO k=1,ke
   CALL PUSHINTEGER4(n)
   n = k - 1
   DO j=1,je
   CALL PUSHINTEGER4(m)
   m = j - 1
   DO i=0,ie
   CALL PUSHREAL8(v1(1))
   ! Determine the two diagonal vectors of the face.
   v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
   CALL PUSHREAL8(v1(2))
   v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
   CALL PUSHREAL8(v1(3))
   v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
   CALL PUSHREAL8(v2(1))
   v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
   CALL PUSHREAL8(v2(2))
   v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
   CALL PUSHREAL8(v2(3))
   v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   ! Projected areas of cell faces in the j direction.
   DO k=1,ke
   CALL PUSHINTEGER4(n)
   n = k - 1
   DO j=0,je
   DO i=1,ie
   l = i - 1
   CALL PUSHREAL8(v1(1))
   ! Determine the two diagonal vectors of the face.
   v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
   CALL PUSHREAL8(v1(2))
   v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
   CALL PUSHREAL8(v1(3))
   v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
   CALL PUSHREAL8(v2(1))
   v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
   CALL PUSHREAL8(v2(2))
   v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
   CALL PUSHREAL8(v2(3))
   v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   ! Projected areas of cell faces in the k direction.
   DO k=0,ke
   DO j=1,je
   CALL PUSHINTEGER4(m)
   m = j - 1
   DO i=1,ie
   l = i - 1
   CALL PUSHREAL8(v1(1))
   ! Determine the two diagonal vectors of the face.
   v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
   CALL PUSHREAL8(v1(2))
   v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
   CALL PUSHREAL8(v1(3))
   v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
   CALL PUSHREAL8(v2(1))
   v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
   CALL PUSHREAL8(v2(2))
   v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
   CALL PUSHREAL8(v2(3))
   v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   !
   !          **************************************************************
   !          *                                                            *
   !          * The unit normals on the boundary faces. These always point *
   !          * out of the domain, so a multiplication by -1 is needed for *
   !          * the iMin, jMin and kMin boundaries.                        *
   !          *                                                            *
   !          **************************************************************
   !
   ! Loop over the boundary subfaces of this block.
   bocoloop:DO mm=1,nbocos
   ! Determine the block face on which this subface is located
   ! and set ss and mult accordingly.
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHPOINTER4(ssb)
   ssb => sib(1, :, :, :)
   CALL PUSHPOINTER4(ss)
   ss => si(1, :, :, :)
   CALL PUSHCONTROL3B(5)
   CASE (imax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHPOINTER4(ssb)
   ssb => sib(il, :, :, :)
   CALL PUSHPOINTER4(ss)
   ss => si(il, :, :, :)
   CALL PUSHCONTROL3B(4)
   CASE (jmin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHPOINTER4(ssb)
   ssb => sjb(:, 1, :, :)
   CALL PUSHPOINTER4(ss)
   ss => sj(:, 1, :, :)
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHPOINTER4(ssb)
   ssb => sjb(:, jl, :, :)
   CALL PUSHPOINTER4(ss)
   ss => sj(:, jl, :, :)
   CALL PUSHCONTROL3B(2)
   CASE (kmin) 
   CALL PUSHREAL8(mult)
   mult = -one
   CALL PUSHPOINTER4(ssb)
   ssb => skb(:, :, 1, :)
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, 1, :)
   CALL PUSHCONTROL3B(1)
   CASE (kmax) 
   CALL PUSHREAL8(mult)
   mult = one
   CALL PUSHPOINTER4(ssb)
   ssb => skb(:, :, kl, :)
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, kl, :)
   CALL PUSHCONTROL3B(0)
   CASE DEFAULT
   CALL PUSHCONTROL3B(6)
   END SELECT
   ad_from0 = bcdata(mm)%jcbeg
   ! Loop over the boundary faces of the subface.
   DO j=ad_from0,bcdata(mm)%jcend
   ad_from = bcdata(mm)%icbeg
   DO i=ad_from,bcdata(mm)%icend
   CALL PUSHREAL8(xp)
   ! Compute the inverse of the length of the normal vector
   ! and possibly correct for inward pointing.
   xp = ss(i, j, 1)
   CALL PUSHREAL8(yp)
   yp = ss(i, j, 2)
   CALL PUSHREAL8(zp)
   zp = ss(i, j, 3)
   CALL PUSHREAL8(fact)
   fact = SQRT(xp*xp + yp*yp + zp*zp)
   IF (fact .GT. zero) THEN
   CALL PUSHREAL8(fact)
   fact = mult/fact
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHCONTROL1B(1)
   END IF
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO bocoloop
   DO mm=nbocos,1,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   factb = zp*bcdatab(mm)%norm(i, j, 3)
   zpb = fact*bcdatab(mm)%norm(i, j, 3)
   bcdatab(mm)%norm(i, j, 3) = 0.0_8
   factb = factb + yp*bcdatab(mm)%norm(i, j, 2)
   ypb = fact*bcdatab(mm)%norm(i, j, 2)
   bcdatab(mm)%norm(i, j, 2) = 0.0_8
   factb = factb + xp*bcdatab(mm)%norm(i, j, 1)
   xpb = fact*bcdatab(mm)%norm(i, j, 1)
   bcdatab(mm)%norm(i, j, 1) = 0.0_8
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(fact)
   factb = -(mult*factb/fact**2)
   END IF
   CALL POPREAL8(fact)
   IF (xp**2 + yp**2 + zp**2 .EQ. 0.0) THEN
   tempb12 = 0.0
   ELSE
   tempb12 = factb/(2.0*SQRT(xp**2+yp**2+zp**2))
   END IF
   xpb = xpb + 2*xp*tempb12
   ypb = ypb + 2*yp*tempb12
   zpb = zpb + 2*zp*tempb12
   CALL POPREAL8(zp)
   ssb(i, j, 3) = ssb(i, j, 3) + zpb
   CALL POPREAL8(yp)
   ssb(i, j, 2) = ssb(i, j, 2) + ypb
   CALL POPREAL8(xp)
   ssb(i, j, 1) = ssb(i, j, 1) + xpb
   END DO
   END DO
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .EQ. 0) THEN
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(mult)
   ELSE IF (branch .EQ. 1) THEN
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(mult)
   ELSE
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(mult)
   ELSE
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(mult)
   END IF
   ELSE IF (branch .EQ. 5) THEN
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(mult)
   END IF
   END DO
   v1b = 0.0_8
   v2b = 0.0_8
   DO k=ke,0,-1
   DO j=je,1,-1
   DO i=ie,1,-1
   tempb9 = fact*skb(i, j, k, 3)
   v1b(1) = v1b(1) + v2(2)*tempb9
   v2b(2) = v2b(2) + v1(1)*tempb9
   v1b(2) = v1b(2) - v2(1)*tempb9
   skb(i, j, k, 3) = 0.0_8
   tempb10 = fact*skb(i, j, k, 2)
   v2b(1) = v2b(1) + v1(3)*tempb10 - v1(2)*tempb9
   v1b(3) = v1b(3) + v2(1)*tempb10
   v1b(1) = v1b(1) - v2(3)*tempb10
   skb(i, j, k, 2) = 0.0_8
   tempb11 = fact*skb(i, j, k, 1)
   v2b(3) = v2b(3) + v1(2)*tempb11 - v1(1)*tempb10
   v1b(2) = v1b(2) + v2(3)*tempb11
   v1b(3) = v1b(3) - v2(2)*tempb11
   v2b(2) = v2b(2) - v1(3)*tempb11
   skb(i, j, k, 1) = 0.0_8
   l = i - 1
   CALL POPREAL8(v2(3))
   xb(l, j, k, 3) = xb(l, j, k, 3) + v2b(3)
   xb(i, m, k, 3) = xb(i, m, k, 3) - v2b(3)
   v2b(3) = 0.0_8
   CALL POPREAL8(v2(2))
   xb(l, j, k, 2) = xb(l, j, k, 2) + v2b(2)
   xb(i, m, k, 2) = xb(i, m, k, 2) - v2b(2)
   v2b(2) = 0.0_8
   CALL POPREAL8(v2(1))
   xb(l, j, k, 1) = xb(l, j, k, 1) + v2b(1)
   xb(i, m, k, 1) = xb(i, m, k, 1) - v2b(1)
   v2b(1) = 0.0_8
   CALL POPREAL8(v1(3))
   xb(i, j, k, 3) = xb(i, j, k, 3) + v1b(3)
   xb(l, m, k, 3) = xb(l, m, k, 3) - v1b(3)
   v1b(3) = 0.0_8
   CALL POPREAL8(v1(2))
   xb(i, j, k, 2) = xb(i, j, k, 2) + v1b(2)
   xb(l, m, k, 2) = xb(l, m, k, 2) - v1b(2)
   v1b(2) = 0.0_8
   CALL POPREAL8(v1(1))
   xb(i, j, k, 1) = xb(i, j, k, 1) + v1b(1)
   xb(l, m, k, 1) = xb(l, m, k, 1) - v1b(1)
   v1b(1) = 0.0_8
   END DO
   CALL POPINTEGER4(m)
   END DO
   END DO
   DO k=ke,1,-1
   DO j=je,0,-1
   DO i=ie,1,-1
   tempb6 = fact*sjb(i, j, k, 3)
   v1b(1) = v1b(1) + v2(2)*tempb6
   v2b(2) = v2b(2) + v1(1)*tempb6
   v1b(2) = v1b(2) - v2(1)*tempb6
   sjb(i, j, k, 3) = 0.0_8
   tempb7 = fact*sjb(i, j, k, 2)
   v2b(1) = v2b(1) + v1(3)*tempb7 - v1(2)*tempb6
   v1b(3) = v1b(3) + v2(1)*tempb7
   v1b(1) = v1b(1) - v2(3)*tempb7
   sjb(i, j, k, 2) = 0.0_8
   tempb8 = fact*sjb(i, j, k, 1)
   v2b(3) = v2b(3) + v1(2)*tempb8 - v1(1)*tempb7
   v1b(2) = v1b(2) + v2(3)*tempb8
   v1b(3) = v1b(3) - v2(2)*tempb8
   v2b(2) = v2b(2) - v1(3)*tempb8
   sjb(i, j, k, 1) = 0.0_8
   l = i - 1
   CALL POPREAL8(v2(3))
   xb(l, j, n, 3) = xb(l, j, n, 3) + v2b(3)
   xb(i, j, k, 3) = xb(i, j, k, 3) - v2b(3)
   v2b(3) = 0.0_8
   CALL POPREAL8(v2(2))
   xb(l, j, n, 2) = xb(l, j, n, 2) + v2b(2)
   xb(i, j, k, 2) = xb(i, j, k, 2) - v2b(2)
   v2b(2) = 0.0_8
   CALL POPREAL8(v2(1))
   xb(l, j, n, 1) = xb(l, j, n, 1) + v2b(1)
   xb(i, j, k, 1) = xb(i, j, k, 1) - v2b(1)
   v2b(1) = 0.0_8
   CALL POPREAL8(v1(3))
   xb(i, j, n, 3) = xb(i, j, n, 3) + v1b(3)
   xb(l, j, k, 3) = xb(l, j, k, 3) - v1b(3)
   v1b(3) = 0.0_8
   CALL POPREAL8(v1(2))
   xb(i, j, n, 2) = xb(i, j, n, 2) + v1b(2)
   xb(l, j, k, 2) = xb(l, j, k, 2) - v1b(2)
   v1b(2) = 0.0_8
   CALL POPREAL8(v1(1))
   xb(i, j, n, 1) = xb(i, j, n, 1) + v1b(1)
   xb(l, j, k, 1) = xb(l, j, k, 1) - v1b(1)
   v1b(1) = 0.0_8
   END DO
   END DO
   CALL POPINTEGER4(n)
   END DO
   DO k=ke,1,-1
   DO j=je,1,-1
   DO i=ie,0,-1
   tempb3 = fact*sib(i, j, k, 3)
   v1b(1) = v1b(1) + v2(2)*tempb3
   v2b(2) = v2b(2) + v1(1)*tempb3
   v1b(2) = v1b(2) - v2(1)*tempb3
   sib(i, j, k, 3) = 0.0_8
   tempb4 = fact*sib(i, j, k, 2)
   v2b(1) = v2b(1) + v1(3)*tempb4 - v1(2)*tempb3
   v1b(3) = v1b(3) + v2(1)*tempb4
   v1b(1) = v1b(1) - v2(3)*tempb4
   sib(i, j, k, 2) = 0.0_8
   tempb5 = fact*sib(i, j, k, 1)
   v2b(3) = v2b(3) + v1(2)*tempb5 - v1(1)*tempb4
   v1b(2) = v1b(2) + v2(3)*tempb5
   v1b(3) = v1b(3) - v2(2)*tempb5
   v2b(2) = v2b(2) - v1(3)*tempb5
   sib(i, j, k, 1) = 0.0_8
   CALL POPREAL8(v2(3))
   xb(i, j, k, 3) = xb(i, j, k, 3) + v2b(3)
   xb(i, m, n, 3) = xb(i, m, n, 3) - v2b(3)
   v2b(3) = 0.0_8
   CALL POPREAL8(v2(2))
   xb(i, j, k, 2) = xb(i, j, k, 2) + v2b(2)
   xb(i, m, n, 2) = xb(i, m, n, 2) - v2b(2)
   v2b(2) = 0.0_8
   CALL POPREAL8(v2(1))
   xb(i, j, k, 1) = xb(i, j, k, 1) + v2b(1)
   xb(i, m, n, 1) = xb(i, m, n, 1) - v2b(1)
   v2b(1) = 0.0_8
   CALL POPREAL8(v1(3))
   xb(i, j, n, 3) = xb(i, j, n, 3) + v1b(3)
   xb(i, m, k, 3) = xb(i, m, k, 3) - v1b(3)
   v1b(3) = 0.0_8
   CALL POPREAL8(v1(2))
   xb(i, j, n, 2) = xb(i, j, n, 2) + v1b(2)
   xb(i, m, k, 2) = xb(i, m, k, 2) - v1b(2)
   v1b(2) = 0.0_8
   CALL POPREAL8(v1(1))
   xb(i, j, n, 1) = xb(i, j, n, 1) + v1b(1)
   xb(i, m, k, 1) = xb(i, m, k, 1) - v1b(1)
   v1b(1) = 0.0_8
   END DO
   CALL POPINTEGER4(m)
   END DO
   CALL POPINTEGER4(n)
   END DO
   DO j=je,1,-1
   DO i=ie,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmp1b = volb(i, j, ke)
   volb(i, j, ke) = 0.0_8
   volb(i, j, kl) = volb(i, j, kl) + tmp1b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   volb(i, j, 2) = volb(i, j, 2) + volb(i, j, 1)
   volb(i, j, 1) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO i=ie,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmp0b = volb(i, je, k)
   volb(i, je, k) = 0.0_8
   volb(i, jl, k) = volb(i, jl, k) + tmp0b
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   volb(i, 2, k) = volb(i, 2, k) + volb(i, 1, k)
   volb(i, 1, k) = 0.0_8
   END IF
   END DO
   END DO
   DO k=kl,2,-1
   DO j=jl,2,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) THEN
   tmpb = volb(ie, j, k)
   volb(ie, j, k) = 0.0_8
   volb(il, j, k) = volb(il, j, k) + tmpb
   END IF
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   volb(2, j, k) = volb(2, j, k) + volb(1, j, k)
   volb(1, j, k) = 0.0_8
   END IF
   END DO
   END DO
   vp1b = 0.0_8
   vp2b = 0.0_8
   vp3b = 0.0_8
   vp4b = 0.0_8
   vp5b = 0.0_8
   vp6b = 0.0_8
   DO k=ke,1,-1
   DO j=je,1,-1
   DO i=ie,1,-1
   CALL POPCONTROL1B(branch)
   IF (branch .NE. 0) volb(i, j, k) = -volb(i, j, k)
   tempb = sixth*volb(i, j, k)
   vp1b = vp1b + tempb
   vp2b = vp2b + tempb
   vp3b = vp3b + tempb
   vp4b = vp4b + tempb
   vp5b = vp5b + tempb
   vp6b = vp6b + tempb
   volb(i, j, k) = 0.0_8
   l = i - 1
   zpb = 0.0_8
   ypb = 0.0_8
   xpb = 0.0_8
   CALL VOLPYM_B(x(i, j, n, 1), xb(i, j, n, 1), x(i, j, n, 2), xb(i&
   &                , j, n, 2), x(i, j, n, 3), xb(i, j, n, 3), x(l, j, n, 1)&
   &                , xb(l, j, n, 1), x(l, j, n, 2), xb(l, j, n, 2), x(l, j&
   &                , n, 3), xb(l, j, n, 3), x(l, m, n, 1), xb(l, m, n, 1), &
   &                x(l, m, n, 2), xb(l, m, n, 2), x(l, m, n, 3), xb(l, m, n&
   &                , 3), x(i, m, n, 1), xb(i, m, n, 1), x(i, m, n, 2), xb(i&
   &                , m, n, 2), x(i, m, n, 3), xb(i, m, n, 3), vp6, vp6b)
   vp6b = 0.0_8
   CALL VOLPYM_B(x(i, j, k, 1), xb(i, j, k, 1), x(i, j, k, 2), xb(i&
   &                , j, k, 2), x(i, j, k, 3), xb(i, j, k, 3), x(i, m, k, 1)&
   &                , xb(i, m, k, 1), x(i, m, k, 2), xb(i, m, k, 2), x(i, m&
   &                , k, 3), xb(i, m, k, 3), x(l, m, k, 1), xb(l, m, k, 1), &
   &                x(l, m, k, 2), xb(l, m, k, 2), x(l, m, k, 3), xb(l, m, k&
   &                , 3), x(l, j, k, 1), xb(l, j, k, 1), x(l, j, k, 2), xb(l&
   &                , j, k, 2), x(l, j, k, 3), xb(l, j, k, 3), vp5, vp5b)
   vp5b = 0.0_8
   CALL VOLPYM_B(x(i, m, k, 1), xb(i, m, k, 1), x(i, m, k, 2), xb(i&
   &                , m, k, 2), x(i, m, k, 3), xb(i, m, k, 3), x(i, m, n, 1)&
   &                , xb(i, m, n, 1), x(i, m, n, 2), xb(i, m, n, 2), x(i, m&
   &                , n, 3), xb(i, m, n, 3), x(l, m, n, 1), xb(l, m, n, 1), &
   &                x(l, m, n, 2), xb(l, m, n, 2), x(l, m, n, 3), xb(l, m, n&
   &                , 3), x(l, m, k, 1), xb(l, m, k, 1), x(l, m, k, 2), xb(l&
   &                , m, k, 2), x(l, m, k, 3), xb(l, m, k, 3), vp4, vp4b)
   vp4b = 0.0_8
   CALL VOLPYM_B(x(i, j, k, 1), xb(i, j, k, 1), x(i, j, k, 2), xb(i&
   &                , j, k, 2), x(i, j, k, 3), xb(i, j, k, 3), x(l, j, k, 1)&
   &                , xb(l, j, k, 1), x(l, j, k, 2), xb(l, j, k, 2), x(l, j&
   &                , k, 3), xb(l, j, k, 3), x(l, j, n, 1), xb(l, j, n, 1), &
   &                x(l, j, n, 2), xb(l, j, n, 2), x(l, j, n, 3), xb(l, j, n&
   &                , 3), x(i, j, n, 1), xb(i, j, n, 1), x(i, j, n, 2), xb(i&
   &                , j, n, 2), x(i, j, n, 3), xb(i, j, n, 3), vp3, vp3b)
   vp3b = 0.0_8
   CALL VOLPYM_B(x(l, j, k, 1), xb(l, j, k, 1), x(l, j, k, 2), xb(l&
   &                , j, k, 2), x(l, j, k, 3), xb(l, j, k, 3), x(l, m, k, 1)&
   &                , xb(l, m, k, 1), x(l, m, k, 2), xb(l, m, k, 2), x(l, m&
   &                , k, 3), xb(l, m, k, 3), x(l, m, n, 1), xb(l, m, n, 1), &
   &                x(l, m, n, 2), xb(l, m, n, 2), x(l, m, n, 3), xb(l, m, n&
   &                , 3), x(l, j, n, 1), xb(l, j, n, 1), x(l, j, n, 2), xb(l&
   &                , j, n, 2), x(l, j, n, 3), xb(l, j, n, 3), vp2, vp2b)
   vp2b = 0.0_8
   CALL VOLPYM_B(x(i, j, k, 1), xb(i, j, k, 1), x(i, j, k, 2), xb(i&
   &                , j, k, 2), x(i, j, k, 3), xb(i, j, k, 3), x(i, j, n, 1)&
   &                , xb(i, j, n, 1), x(i, j, n, 2), xb(i, j, n, 2), x(i, j&
   &                , n, 3), xb(i, j, n, 3), x(i, m, n, 1), xb(i, m, n, 1), &
   &                x(i, m, n, 2), xb(i, m, n, 2), x(i, m, n, 3), xb(i, m, n&
   &                , 3), x(i, m, k, 1), xb(i, m, k, 1), x(i, m, k, 2), xb(i&
   &                , m, k, 2), x(i, m, k, 3), xb(i, m, k, 3), vp1, vp1b)
   vp1b = 0.0_8
   CALL POPREAL8(zp)
   tempb0 = eighth*zpb
   xb(i, j, k, 3) = xb(i, j, k, 3) + tempb0
   xb(i, m, k, 3) = xb(i, m, k, 3) + tempb0
   xb(i, m, n, 3) = xb(i, m, n, 3) + tempb0
   xb(i, j, n, 3) = xb(i, j, n, 3) + tempb0
   xb(l, j, k, 3) = xb(l, j, k, 3) + tempb0
   xb(l, m, k, 3) = xb(l, m, k, 3) + tempb0
   xb(l, m, n, 3) = xb(l, m, n, 3) + tempb0
   xb(l, j, n, 3) = xb(l, j, n, 3) + tempb0
   CALL POPREAL8(yp)
   tempb1 = eighth*ypb
   xb(i, j, k, 2) = xb(i, j, k, 2) + tempb1
   xb(i, m, k, 2) = xb(i, m, k, 2) + tempb1
   xb(i, m, n, 2) = xb(i, m, n, 2) + tempb1
   xb(i, j, n, 2) = xb(i, j, n, 2) + tempb1
   xb(l, j, k, 2) = xb(l, j, k, 2) + tempb1
   xb(l, m, k, 2) = xb(l, m, k, 2) + tempb1
   xb(l, m, n, 2) = xb(l, m, n, 2) + tempb1
   xb(l, j, n, 2) = xb(l, j, n, 2) + tempb1
   CALL POPREAL8(xp)
   tempb2 = eighth*xpb
   xb(i, j, k, 1) = xb(i, j, k, 1) + tempb2
   xb(i, m, k, 1) = xb(i, m, k, 1) + tempb2
   xb(i, m, n, 1) = xb(i, m, n, 1) + tempb2
   xb(i, j, n, 1) = xb(i, j, n, 1) + tempb2
   xb(l, j, k, 1) = xb(l, j, k, 1) + tempb2
   xb(l, m, k, 1) = xb(l, m, k, 1) + tempb2
   xb(l, m, n, 1) = xb(l, m, n, 1) + tempb2
   xb(l, j, n, 1) = xb(l, j, n, 1) + tempb2
   END DO
   CALL POPINTEGER4(m)
   END DO
   CALL POPINTEGER4(n)
   END DO
      CONTAINS
   !  Differentiation of volpym in reverse (adjoint) mode:
   !   gradient     of useful results: xp yp zp xa xb xc xd ya yb
   !                yc yd za zb zc zd volume
   !   with respect to varying inputs: xp yp zp xa xb xc xd ya yb
   !                yc yd za zb zc zd
   !        ================================================================
   SUBROUTINE VOLPYM_B(xa, xab, ya, yab, za, zab, xb, xbb, yb, ybb, zb, &
   &    zbb, xc, xcb, yc, ycb, zc, zcb, xd, xdb, yd, ydb, zd, zdb, volume, &
   &    volumeb)
   USE PRECISION
   IMPLICIT NONE
   !
   !        ****************************************************************
   !        *                                                              *
   !        * volpym computes 6 times the volume of a pyramid. Node p,     *
   !        * whose coordinates are set in the subroutine metric itself,   *
   !        * is the top node and a-b-c-d is the quadrilateral surface.    *
   !        * It is assumed that the cross product vCa * vDb points in     *
   !        * the direction of the top node. Here vCa is the diagonal      *
   !        * running from node c to node a and vDb the diagonal from      *
   !        * node d to node b.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   !
   !        Function type.
   !
   REAL(kind=realtype) :: volume
   REAL(kind=realtype) :: volumeb
   !
   !        Function arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: xa, ya, za, xb, yb, zb
   REAL(kind=realtype) :: xab, yab, zab, xbb, ybb, zbb
   REAL(kind=realtype), INTENT(IN) :: xc, yc, zc, xd, yd, zd
   REAL(kind=realtype) :: xcb, ycb, zcb, xdb, ydb, zdb
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   REAL(kind=realtype) :: tempb7
   REAL(kind=realtype) :: tempb6
   REAL(kind=realtype) :: tempb5
   REAL(kind=realtype) :: tempb4
   REAL(kind=realtype) :: tempb3
   REAL(kind=realtype) :: tempb2
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   REAL(kind=realtype) :: tempb
   tempb = ((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))*volumeb
   tempb0 = -(fourth*tempb)
   tempb1 = (xp-fourth*(xa+xb+xc+xd))*volumeb
   tempb2 = ((za-zc)*(xb-xd)-(xa-xc)*(zb-zd))*volumeb
   tempb3 = -(fourth*tempb2)
   tempb4 = (yp-fourth*(ya+yb+yc+yd))*volumeb
   tempb5 = ((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))*volumeb
   tempb6 = -(fourth*tempb5)
   tempb7 = (zp-fourth*(za+zb+zc+zd))*volumeb
   xpb = xpb + tempb
   xab = xab + (yb-yd)*tempb7 - (zb-zd)*tempb4 + tempb0
   xbb = xbb + (za-zc)*tempb4 - (ya-yc)*tempb7 + tempb0
   xcb = xcb + (zb-zd)*tempb4 - (yb-yd)*tempb7 + tempb0
   xdb = xdb + (ya-yc)*tempb7 - (za-zc)*tempb4 + tempb0
   yab = yab + tempb3 - (xb-xd)*tempb7 + (zb-zd)*tempb1
   ycb = ycb + (xb-xd)*tempb7 + tempb3 - (zb-zd)*tempb1
   zbb = zbb + tempb6 - (xa-xc)*tempb4 + (ya-yc)*tempb1
   zdb = zdb + tempb6 + (xa-xc)*tempb4 - (ya-yc)*tempb1
   zab = zab + tempb6 + (xb-xd)*tempb4 - (yb-yd)*tempb1
   zcb = zcb + tempb6 - (xb-xd)*tempb4 + (yb-yd)*tempb1
   ybb = ybb + (xa-xc)*tempb7 + tempb3 - (za-zc)*tempb1
   ydb = ydb + tempb3 - (xa-xc)*tempb7 + (za-zc)*tempb1
   ypb = ypb + tempb2
   zpb = zpb + tempb5
   END SUBROUTINE VOLPYM_B
   !        ================================================================
   SUBROUTINE VOLPYM(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
   &    volume)
   USE PRECISION
   IMPLICIT NONE
   !
   !        ****************************************************************
   !        *                                                              *
   !        * volpym computes 6 times the volume of a pyramid. Node p,     *
   !        * whose coordinates are set in the subroutine metric itself,   *
   !        * is the top node and a-b-c-d is the quadrilateral surface.    *
   !        * It is assumed that the cross product vCa * vDb points in     *
   !        * the direction of the top node. Here vCa is the diagonal      *
   !        * running from node c to node a and vDb the diagonal from      *
   !        * node d to node b.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   !
   !        Function type.
   !
   REAL(kind=realtype) :: volume
   !
   !        Function arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: xa, ya, za, xb, yb, zb
   REAL(kind=realtype), INTENT(IN) :: xc, yc, zc, xd, yd, zd
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))&
   &      + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd)) + (&
   &      zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
   END SUBROUTINE VOLPYM
   END SUBROUTINE METRIC_BLOCK_B

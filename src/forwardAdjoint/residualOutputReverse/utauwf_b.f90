   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.6 (r4159) - 21 Sep 2011 10:11
   !
   !  Differentiation of utauwf in reverse (adjoint) mode:
   !   gradient     of useful results: *w *fw
   !   with respect to varying inputs: *w *rlv *si *sj *sk *fw *(*viscsubface.tau)
   !                *(*bcdata.norm)
   !   Plus diff mem management of: w:in rlv:in d2wall:in si:in sj:in
   !                sk:in fw:in viscsubface:in *viscsubface.tau:in
   !                bcdata:in *bcdata.norm:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          utauWF.f90                                      *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 10-01-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE UTAUWF_B(rfilv)
   USE BLOCKPOINTERS_B
   USE BCTYPES
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   !  Hint: ISIZE1OFDrfviscsubface should be the size of dimension 1 of array *viscsubface
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * utauWF substitutes the wall shear stress with values from a    *
   !      * look-up table, if desired.                                     *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine argument.
   !
   REAL(kind=realtype), INTENT(IN) :: rfilv
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, nn
   REAL(kind=realtype) :: fact
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxb, tauyyb, tauzzb
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyb, tauxzb, tauyzb
   REAL(kind=realtype) :: rbar, ubar, vbar, wbar, vx, vy, vz
   REAL(kind=realtype) :: rbarb, ubarb, vbarb, wbarb, vxb, vyb, vzb
   REAL(kind=realtype) :: fmx, fmy, fmz, frhoe
   REAL(kind=realtype) :: fmxb, fmyb, fmzb, frhoeb
   REAL(kind=realtype) :: veln, velnx, velny, velnz, tx, ty, tz
   REAL(kind=realtype) :: velnb, velnxb, velnyb, velnzb, txb, tyb, tzb
   REAL(kind=realtype) :: veltx, velty, veltz, veltmag
   REAL(kind=realtype) :: veltxb, veltyb, veltzb, veltmagb
   REAL(kind=realtype) :: txnx, txny, txnz, tynx, tyny, tynz
   REAL(kind=realtype) :: txnxb, txnyb, txnzb, tynxb, tynyb, tynzb
   REAL(kind=realtype) :: tznx, tzny, tznz
   REAL(kind=realtype) :: tznxb, tznyb, tznzb
   REAL(kind=realtype) :: tautn, tauwall, utau, re
   REAL(kind=realtype) :: tautnb, tauwallb, utaub, reb
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1b, ww2b
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss, rres
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssb, rresb
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: norm
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: normb
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv2, dd2wall2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv2b
   !
   !      Function definition.
   !
   REAL(kind=realtype) :: CURVEUPRE
   INTEGER :: branch
   INTEGER :: ad_from
   INTEGER :: ad_to
   INTEGER :: ad_from0
   INTEGER :: ad_to0
   REAL(kind=realtype) :: y1b
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: tempb1
   REAL(kind=realtype) :: tempb0
   INTRINSIC MAX
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: max1b
   REAL(kind=realtype) :: tempb
   REAL(kind=realtype) :: x1b
   REAL(kind=realtype) :: temp1b
   INTEGER :: ii1
   INTRINSIC SQRT
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: max1
   REAL(kind=realtype) :: temp1b1
   REAL(kind=realtype) :: temp1b0
   REAL(kind=realtype) :: y1
   INTERFACE 
   SUBROUTINE PUSHPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE PUSHPOINTER4
   SUBROUTINE LOOKPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE LOOKPOINTER4
   SUBROUTINE POPPOINTER4(pp)
   REAL, POINTER :: pp
   END SUBROUTINE POPPOINTER4
   END INTERFACE
      !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Return immediately if no wall functions must be used.
   IF (.NOT.wallfunctions) THEN
   rlvb = 0.0_8
   sib = 0.0_8
   sjb = 0.0_8
   skb = 0.0_8
   DO ii1=1,ISIZE1OFDrfviscsubface
   viscsubfaceb(ii1)%tau = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatab(ii1)%norm = 0.0_8
   END DO
   ELSE
   ! Loop over the viscous subfaces of this block.
   viscsubfaces:DO nn=1,nviscbocos
   ! Set a bunch of variables depending on the face id to make
   ! a generic treatment possible.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   CALL PUSHREAL8(fact)
   fact = -one
   CALL PUSHPOINTER4(ssb)
   ssb => sib(1, :, :, :)
   CALL PUSHPOINTER4(ss)
   ss => si(1, :, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(2, 1:, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(2, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(2, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(2, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1, 1:, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(2, :, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(2, 1:, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(2, 1:, 1:)
   CALL PUSHCONTROL3B(1)
   CASE (imax) 
   CALL PUSHREAL8(fact)
   !===========================================================
   fact = one
   CALL PUSHPOINTER4(ssb)
   ssb => sib(il, :, :, :)
   CALL PUSHPOINTER4(ss)
   ss => si(il, :, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(il, 1:, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(il, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(il, 1:, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(il, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(ie, 1:, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(ie, 1:, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(il, :, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(il, 1:, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(il, 1:, 1:)
   CALL PUSHCONTROL3B(2)
   CASE (jmin) 
   CALL PUSHREAL8(fact)
   !===========================================================
   fact = -one
   CALL PUSHPOINTER4(ssb)
   ssb => sjb(:, 1, :, :)
   CALL PUSHPOINTER4(ss)
   ss => sj(:, 1, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, 2, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, 2, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, 2, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, 2, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, 1, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, 1, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, 2, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, 2, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, 2, 1:)
   CALL PUSHCONTROL3B(3)
   CASE (jmax) 
   CALL PUSHREAL8(fact)
   !===========================================================
   fact = one
   CALL PUSHPOINTER4(ssb)
   ssb => sjb(:, jl, :, :)
   CALL PUSHPOINTER4(ss)
   ss => sj(:, jl, :, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, jl, 1:, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, jl, 1:, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, jl, 1:, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, jl, 1:, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, je, 1:, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, je, 1:, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, jl, :)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, jl, 1:)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, jl, 1:)
   CALL PUSHCONTROL3B(4)
   CASE (kmin) 
   CALL PUSHREAL8(fact)
   !===========================================================
   fact = -one
   CALL PUSHPOINTER4(ssb)
   ssb => skb(:, :, 1, :)
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, 1, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, 1:, 2, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, 1:, 2, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, 1:, 2, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, 1:, 2, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, 1:, 1, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, 1:, 1, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, :, 2)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, 1:, 2)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, 1:, 2)
   CALL PUSHCONTROL3B(5)
   CASE (kmax) 
   CALL PUSHREAL8(fact)
   !===========================================================
   fact = one
   CALL PUSHPOINTER4(ssb)
   ssb => skb(:, :, kl, :)
   CALL PUSHPOINTER4(ss)
   ss => sk(:, :, kl, :)
   CALL PUSHPOINTER4(rresb)
   rresb => fwb(1:, 1:, kl, :)
   CALL PUSHPOINTER4(rres)
   rres => fw(1:, 1:, kl, :)
   CALL PUSHPOINTER4(ww2b)
   ww2b => wb(1:, 1:, kl, :)
   CALL PUSHPOINTER4(ww2)
   ww2 => w(1:, 1:, kl, :)
   CALL PUSHPOINTER4(ww1b)
   ww1b => wb(1:, 1:, ke, :)
   CALL PUSHPOINTER4(ww1)
   ww1 => w(1:, 1:, ke, :)
   CALL PUSHPOINTER4(dd2wall2)
   dd2wall2 => d2wall(:, :, kl)
   CALL PUSHPOINTER4(rrlv2b)
   rrlv2b => rlvb(1:, 1:, kl)
   CALL PUSHPOINTER4(rrlv2)
   rrlv2 => rlv(1:, 1:, kl)
   CALL PUSHCONTROL3B(6)
   CASE DEFAULT
   CALL PUSHCONTROL3B(0)
   END SELECT
   CALL PUSHPOINTER4(normb)
   normb => bcdatab(nn)%norm
   CALL PUSHPOINTER4(norm)
   ! Set the pointer for the unit outward normals.
   norm => bcdata(nn)%norm
   ad_from0 = bcdata(nn)%jnbeg + 1
   ! Loop over the quadrilateral faces of the subface. Note
   ! that the nodal range of BCData must be used and not the
   ! cell range, because the latter may include the halo's in i
   ! and j-direction. The offset +1 is there, because inBeg and
   ! jnBeg refer to nodal ranges and not to cell ranges.
   DO j=ad_from0,bcdata(nn)%jnend
   ad_from = bcdata(nn)%inbeg + 1
   DO i=ad_from,bcdata(nn)%inend
   ! Store the viscous stress tensor a bit easier.
   tauxx = viscsubface(nn)%tau(i, j, 1)
   tauyy = viscsubface(nn)%tau(i, j, 2)
   tauzz = viscsubface(nn)%tau(i, j, 3)
   tauxy = viscsubface(nn)%tau(i, j, 4)
   tauxz = viscsubface(nn)%tau(i, j, 5)
   tauyz = viscsubface(nn)%tau(i, j, 6)
   CALL PUSHREAL8(rbar)
   ! Compute the velocities at the wall face; these are only
   ! non-zero for moving a block. Also compute the density,
   ! which is needed to compute the wall shear stress via
   ! wall functions.
   rbar = half*(ww2(i, j, irho)+ww1(i, j, irho))
   ubar = half*(ww2(i, j, ivx)+ww1(i, j, ivx))
   vbar = half*(ww2(i, j, ivy)+ww1(i, j, ivy))
   wbar = half*(ww2(i, j, ivz)+ww1(i, j, ivz))
   ! Compute the velocity difference between the internal cell
   ! and the wall.
   vx = ww2(i, j, ivx) - ubar
   vy = ww2(i, j, ivy) - vbar
   vz = ww2(i, j, ivz) - wbar
   CALL PUSHREAL8(veln)
   ! Compute the normal velocity of the internal cell.
   veln = vx*norm(i, j, 1) + vy*norm(i, j, 2) + vz*norm(i, j, 3)
   velnx = veln*norm(i, j, 1)
   velny = veln*norm(i, j, 2)
   velnz = veln*norm(i, j, 3)
   ! Compute the tangential velocity, its magnitude and its
   ! unit vector of the internal cell.
   veltx = vx - velnx
   velty = vy - velny
   veltz = vz - velnz
   y1 = SQRT(veltx**2 + velty**2 + veltz**2)
   IF (eps .LT. y1) THEN
   CALL PUSHREAL8(veltmag)
   veltmag = y1
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(veltmag)
   veltmag = eps
   CALL PUSHCONTROL1B(1)
   END IF
   tx = veltx/veltmag
   ty = velty/veltmag
   tz = veltz/veltmag
   ! Compute some coefficients needed for the transformation
   ! between the cartesian frame and the frame defined by the
   ! tangential direction (tx,ty,tz) and the normal direction.
   ! The minus sign is present, because for this transformation
   ! the normal direction should be inward pointing and norm
   ! is outward pointing.
   txnx = -(tx*norm(i, j, 1))
   txny = -(tx*norm(i, j, 2))
   txnz = -(tx*norm(i, j, 3))
   tynx = -(ty*norm(i, j, 1))
   tyny = -(ty*norm(i, j, 2))
   tynz = -(ty*norm(i, j, 3))
   tznx = -(tz*norm(i, j, 1))
   tzny = -(tz*norm(i, j, 2))
   tznz = -(tz*norm(i, j, 3))
   CALL PUSHREAL8(tautn)
   ! Compute the tn component of the wall shear stress
   ! tensor. Normally this is the only nonzero shear
   ! stress component in the t-n frame.
   tautn = tauxx*txnx + tauyy*tyny + tauzz*tznz + tauxy*(txny+&
   &            tynx) + tauxz*(txnz+tznx) + tauyz*(tynz+tzny)
   CALL PUSHREAL8(re)
   ! Compute the Reynolds number using the velocity, density,
   ! laminar viscosity and wall distance. Note that an offset
   ! of -1 must be used in dd2Wall2, because the original array
   ! d2Wall starts at 2.
   re = ww2(i, j, irho)*veltmag*dd2wall2(i-1, j-1)/rrlv2(i, j)
   x1 = CURVEUPRE(re)
   IF (x1 .LT. eps) THEN
   CALL PUSHREAL8(max1)
   max1 = eps
   CALL PUSHCONTROL1B(0)
   ELSE
   CALL PUSHREAL8(max1)
   max1 = x1
   CALL PUSHCONTROL1B(1)
   END IF
   CALL PUSHREAL8(utau)
   ! Determine the friction velocity from the table and
   ! compute the wall shear stress from it.
   utau = veltmag/max1
   tauwall = rbar*utau*utau
   ! Compute the correction to the wall shear stress tautn and
   ! transform this correction back to the cartesian frame.
   ! Take rFilv into account, such that the correction to the
   ! stress tensor is computed correctly.
   tautn = rfilv*tauwall - tautn
   CALL PUSHREAL8(tauxx)
   tauxx = two*tautn*txnx
   CALL PUSHREAL8(tauyy)
   tauyy = two*tautn*tyny
   CALL PUSHREAL8(tauzz)
   tauzz = two*tautn*tznz
   CALL PUSHREAL8(tauxy)
   tauxy = tautn*(txny+tynx)
   CALL PUSHREAL8(tauxz)
   tauxz = tautn*(txnz+tznx)
   CALL PUSHREAL8(tauyz)
   tauyz = tautn*(tynz+tzny)
   ! Compute the correction to the viscous flux at the wall.
   fmx = tauxx*ss(i, j, 1) + tauxy*ss(i, j, 2) + tauxz*ss(i, j, 3&
   &            )
   fmy = tauxy*ss(i, j, 1) + tauyy*ss(i, j, 2) + tauyz*ss(i, j, 3&
   &            )
   fmz = tauxz*ss(i, j, 1) + tauyz*ss(i, j, 2) + tauzz*ss(i, j, 3&
   &            )
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*ss(i, j, 1) + (ubar&
   &            *tauxy+vbar*tauyy+wbar*tauyz)*ss(i, j, 2) + (ubar*tauxz+vbar&
   &            *tauyz+wbar*tauzz)*ss(i, j, 3)
   ! Add them to the residual. Note that now the factor rFilv
   ! is already taken into account via tau. Fact is present to
   ! take inward/outward pointing normals into account
   rres(i, j, imx) = rres(i, j, imx) - fact*fmx
   rres(i, j, imy) = rres(i, j, imy) - fact*fmy
   rres(i, j, imz) = rres(i, j, imz) - fact*fmz
   rres(i, j, irhoe) = rres(i, j, irhoe) - fact*frhoe
   ! Store the friction velocity for later use.
   ! Also add the correction to the wall stress tensor.
   viscsubface(nn)%tau(i, j, 1) = viscsubface(nn)%tau(i, j, 1) + &
   &            tauxx
   viscsubface(nn)%tau(i, j, 2) = viscsubface(nn)%tau(i, j, 2) + &
   &            tauyy
   viscsubface(nn)%tau(i, j, 3) = viscsubface(nn)%tau(i, j, 3) + &
   &            tauzz
   viscsubface(nn)%tau(i, j, 4) = viscsubface(nn)%tau(i, j, 4) + &
   &            tauxy
   viscsubface(nn)%tau(i, j, 5) = viscsubface(nn)%tau(i, j, 5) + &
   &            tauxz
   viscsubface(nn)%tau(i, j, 6) = viscsubface(nn)%tau(i, j, 6) + &
   &            tauyz
   END DO
   CALL PUSHINTEGER4(i - 1)
   CALL PUSHINTEGER4(ad_from)
   END DO
   CALL PUSHINTEGER4(j - 1)
   CALL PUSHINTEGER4(ad_from0)
   END DO viscsubfaces
   rlvb = 0.0_8
   sib = 0.0_8
   sjb = 0.0_8
   skb = 0.0_8
   DO ii1=1,ISIZE1OFDrfviscsubface
   viscsubfaceb(ii1)%tau = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatab(ii1)%norm = 0.0_8
   END DO
   DO nn=nviscbocos,1,-1
   CALL POPINTEGER4(ad_from0)
   CALL POPINTEGER4(ad_to0)
   DO j=ad_to0,ad_from0,-1
   CALL POPINTEGER4(ad_from)
   CALL POPINTEGER4(ad_to)
   DO i=ad_to,ad_from,-1
   frhoeb = -(fact*rresb(i, j, irhoe))
   fmzb = -(fact*rresb(i, j, imz))
   fmyb = -(fact*rresb(i, j, imy))
   fmxb = -(fact*rresb(i, j, imx))
   temp1b1 = ss(i, j, 1)*frhoeb
   temp1b = ss(i, j, 2)*frhoeb
   temp1b0 = ss(i, j, 3)*frhoeb
   vbar = half*(ww2(i, j, ivy)+ww1(i, j, ivy))
   vy = ww2(i, j, ivy) - vbar
   velny = veln*norm(i, j, 2)
   velty = vy - velny
   ty = velty/veltmag
   wbar = half*(ww2(i, j, ivz)+ww1(i, j, ivz))
   vz = ww2(i, j, ivz) - wbar
   velnz = veln*norm(i, j, 3)
   veltz = vz - velnz
   tz = veltz/veltmag
   tzny = -(tz*norm(i, j, 2))
   tynz = -(ty*norm(i, j, 3))
   tauyz = tautn*(tynz+tzny)
   tauyzb = wbar*temp1b + vbar*temp1b0 + ss(i, j, 3)*fmyb + ss(i&
   &            , j, 2)*fmzb + viscsubfaceb(nn)%tau(i, j, 6)
   ubar = half*(ww2(i, j, ivx)+ww1(i, j, ivx))
   vx = ww2(i, j, ivx) - ubar
   velnx = veln*norm(i, j, 1)
   veltx = vx - velnx
   tx = veltx/veltmag
   txnz = -(tx*norm(i, j, 3))
   tznx = -(tz*norm(i, j, 1))
   tauxz = tautn*(txnz+tznx)
   tauxzb = wbar*temp1b1 + ubar*temp1b0 + ss(i, j, 3)*fmxb + ss(i&
   &            , j, 1)*fmzb + viscsubfaceb(nn)%tau(i, j, 5)
   txny = -(tx*norm(i, j, 2))
   tynx = -(ty*norm(i, j, 1))
   tauxy = tautn*(txny+tynx)
   tauxyb = vbar*temp1b1 + ubar*temp1b + ss(i, j, 2)*fmxb + ss(i&
   &            , j, 1)*fmyb + viscsubfaceb(nn)%tau(i, j, 4)
   tznz = -(tz*norm(i, j, 3))
   tauzz = two*tautn*tznz
   tauzzb = wbar*temp1b0 + ss(i, j, 3)*fmzb + viscsubfaceb(nn)%&
   &            tau(i, j, 3)
   tyny = -(ty*norm(i, j, 2))
   tauyy = two*tautn*tyny
   tauyyb = vbar*temp1b + ss(i, j, 2)*fmyb + viscsubfaceb(nn)%tau&
   &            (i, j, 2)
   txnx = -(tx*norm(i, j, 1))
   tauxx = two*tautn*txnx
   tauxxb = ubar*temp1b1 + ss(i, j, 1)*fmxb + viscsubfaceb(nn)%&
   &            tau(i, j, 1)
   ubarb = tauxz*temp1b0 + tauxy*temp1b + tauxx*temp1b1
   vbarb = tauyz*temp1b0 + tauyy*temp1b + tauxy*temp1b1
   wbarb = tauzz*temp1b0 + tauyz*temp1b + tauxz*temp1b1
   ssb(i, j, 1) = ssb(i, j, 1) + (ubar*tauxx+vbar*tauxy+wbar*&
   &            tauxz)*frhoeb
   ssb(i, j, 2) = ssb(i, j, 2) + (ubar*tauxy+vbar*tauyy+wbar*&
   &            tauyz)*frhoeb
   ssb(i, j, 3) = ssb(i, j, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
   &            tauzz)*frhoeb
   ssb(i, j, 1) = ssb(i, j, 1) + tauxz*fmzb
   ssb(i, j, 2) = ssb(i, j, 2) + tauyz*fmzb
   ssb(i, j, 3) = ssb(i, j, 3) + tauzz*fmzb
   ssb(i, j, 1) = ssb(i, j, 1) + tauxy*fmyb
   ssb(i, j, 2) = ssb(i, j, 2) + tauyy*fmyb
   ssb(i, j, 3) = ssb(i, j, 3) + tauyz*fmyb
   ssb(i, j, 1) = ssb(i, j, 1) + tauxx*fmxb
   ssb(i, j, 2) = ssb(i, j, 2) + tauxy*fmxb
   ssb(i, j, 3) = ssb(i, j, 3) + tauxz*fmxb
   CALL POPREAL8(tauyz)
   tautnb = (txnz+tznx)*tauxzb + two*tznz*tauzzb + two*txnx*&
   &            tauxxb + two*tyny*tauyyb + (txny+tynx)*tauxyb + (tynz+tzny)*&
   &            tauyzb
   tynzb = tautn*tauyzb
   tznyb = tautn*tauyzb
   CALL POPREAL8(tauxz)
   txnzb = tautn*tauxzb
   tznxb = tautn*tauxzb
   CALL POPREAL8(tauxy)
   txnyb = tautn*tauxyb
   tynxb = tautn*tauxyb
   CALL POPREAL8(tauzz)
   tznzb = two*tautn*tauzzb
   CALL POPREAL8(tauyy)
   tynyb = two*tautn*tauyyb
   CALL POPREAL8(tauxx)
   txnxb = two*tautn*tauxxb
   tauwallb = rfilv*tautnb
   tautnb = -tautnb
   rbarb = utau**2*tauwallb
   utaub = rbar*2*utau*tauwallb
   CALL POPREAL8(utau)
   veltmagb = utaub/max1
   max1b = -(veltmag*utaub/max1**2)
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(max1)
   x1b = 0.0_8
   ELSE
   CALL POPREAL8(max1)
   x1b = max1b
   END IF
   txnxb = txnxb + tauxx*tautnb
   tynyb = tynyb + tauyy*tautnb
   tznzb = tznzb + tauzz*tautnb
   txnyb = txnyb + tauxy*tautnb
   tynxb = tynxb + tauxy*tautnb
   txnzb = txnzb + tauxz*tautnb
   tznxb = tznxb + tauxz*tautnb
   tynzb = tynzb + tauyz*tautnb
   tznyb = tznyb + tauyz*tautnb
   tzb = -(norm(i, j, 2)*tznyb) - norm(i, j, 1)*tznxb - norm(i, j&
   &            , 3)*tznzb
   tyb = -(norm(i, j, 2)*tynyb) - norm(i, j, 1)*tynxb - norm(i, j&
   &            , 3)*tynzb
   txb = -(norm(i, j, 2)*txnyb) - norm(i, j, 1)*txnxb - norm(i, j&
   &            , 3)*txnzb
   CALL CURVEUPRE_B(re, reb, x1b)
   CALL POPREAL8(re)
   temp0 = rrlv2(i, j)
   temp = veltmag/temp0
   tempb0 = dd2wall2(i-1, j-1)*reb
   tempb1 = ww2(i, j, irho)*tempb0/temp0
   ww2b(i, j, irho) = ww2b(i, j, irho) + temp*tempb0
   veltmagb = veltmagb + tempb1 - veltx*txb/veltmag**2 - velty*&
   &            tyb/veltmag**2 - veltz*tzb/veltmag**2
   rrlv2b(i, j) = rrlv2b(i, j) - temp*tempb1
   CALL POPREAL8(tautn)
   tauxxb = txnx*tautnb
   tauyyb = tyny*tautnb
   tauzzb = tznz*tautnb
   tauxyb = (txny+tynx)*tautnb
   tauxzb = (txnz+tznx)*tautnb
   tauyzb = (tynz+tzny)*tautnb
   normb(i, j, 3) = normb(i, j, 3) - tz*tznzb
   normb(i, j, 2) = normb(i, j, 2) - tz*tznyb
   normb(i, j, 1) = normb(i, j, 1) - tz*tznxb
   normb(i, j, 3) = normb(i, j, 3) - ty*tynzb
   normb(i, j, 2) = normb(i, j, 2) - ty*tynyb
   normb(i, j, 1) = normb(i, j, 1) - ty*tynxb
   normb(i, j, 3) = normb(i, j, 3) - tx*txnzb
   normb(i, j, 2) = normb(i, j, 2) - tx*txnyb
   normb(i, j, 1) = normb(i, j, 1) - tx*txnxb
   veltzb = tzb/veltmag
   veltyb = tyb/veltmag
   veltxb = txb/veltmag
   CALL POPCONTROL1B(branch)
   IF (branch .EQ. 0) THEN
   CALL POPREAL8(veltmag)
   y1b = veltmagb
   ELSE
   CALL POPREAL8(veltmag)
   y1b = 0.0_8
   END IF
   IF (veltx**2 + velty**2 + veltz**2 .EQ. 0.0) THEN
   tempb = 0.0
   ELSE
   tempb = y1b/(2.0*SQRT(veltx**2+velty**2+veltz**2))
   END IF
   veltxb = veltxb + 2*veltx*tempb
   veltyb = veltyb + 2*velty*tempb
   veltzb = veltzb + 2*veltz*tempb
   velnzb = -veltzb
   velnyb = -veltyb
   velnxb = -veltxb
   velnb = norm(i, j, 2)*velnyb + norm(i, j, 1)*velnxb + norm(i, &
   &            j, 3)*velnzb
   vzb = norm(i, j, 3)*velnb + veltzb
   vyb = norm(i, j, 2)*velnb + veltyb
   vxb = norm(i, j, 1)*velnb + veltxb
   normb(i, j, 3) = normb(i, j, 3) + veln*velnzb
   normb(i, j, 2) = normb(i, j, 2) + veln*velnyb
   normb(i, j, 1) = normb(i, j, 1) + veln*velnxb
   CALL POPREAL8(veln)
   normb(i, j, 1) = normb(i, j, 1) + vx*velnb
   normb(i, j, 2) = normb(i, j, 2) + vy*velnb
   normb(i, j, 3) = normb(i, j, 3) + vz*velnb
   ww2b(i, j, ivz) = ww2b(i, j, ivz) + vzb
   wbarb = wbarb - vzb
   ww2b(i, j, ivy) = ww2b(i, j, ivy) + vyb
   vbarb = vbarb - vyb
   ww2b(i, j, ivx) = ww2b(i, j, ivx) + vxb
   ubarb = ubarb - vxb
   ww2b(i, j, ivz) = ww2b(i, j, ivz) + half*wbarb
   ww1b(i, j, ivz) = ww1b(i, j, ivz) + half*wbarb
   ww2b(i, j, ivy) = ww2b(i, j, ivy) + half*vbarb
   ww1b(i, j, ivy) = ww1b(i, j, ivy) + half*vbarb
   ww2b(i, j, ivx) = ww2b(i, j, ivx) + half*ubarb
   ww1b(i, j, ivx) = ww1b(i, j, ivx) + half*ubarb
   CALL POPREAL8(rbar)
   ww2b(i, j, irho) = ww2b(i, j, irho) + half*rbarb
   ww1b(i, j, irho) = ww1b(i, j, irho) + half*rbarb
   viscsubfaceb(nn)%tau(i, j, 6) = viscsubfaceb(nn)%tau(i, j, 6) &
   &            + tauyzb
   viscsubfaceb(nn)%tau(i, j, 5) = viscsubfaceb(nn)%tau(i, j, 5) &
   &            + tauxzb
   viscsubfaceb(nn)%tau(i, j, 4) = viscsubfaceb(nn)%tau(i, j, 4) &
   &            + tauxyb
   viscsubfaceb(nn)%tau(i, j, 3) = viscsubfaceb(nn)%tau(i, j, 3) &
   &            + tauzzb
   viscsubfaceb(nn)%tau(i, j, 2) = viscsubfaceb(nn)%tau(i, j, 2) &
   &            + tauyyb
   viscsubfaceb(nn)%tau(i, j, 1) = viscsubfaceb(nn)%tau(i, j, 1) &
   &            + tauxxb
   END DO
   END DO
   CALL POPPOINTER4(norm)
   bcdatab(nn)%norm = bcdatab(nn)%norm + normb
   CALL POPPOINTER4(normb)
   CALL POPCONTROL3B(branch)
   IF (branch .LT. 3) THEN
   IF (branch .NE. 0) THEN
   IF (branch .EQ. 1) THEN
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(fact)
   ELSE
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(fact)
   END IF
   END IF
   ELSE IF (branch .LT. 5) THEN
   IF (branch .EQ. 3) THEN
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(fact)
   ELSE
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(fact)
   END IF
   ELSE IF (branch .EQ. 5) THEN
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(fact)
   ELSE
   CALL POPPOINTER4(rrlv2)
   CALL POPPOINTER4(rrlv2b)
   CALL POPPOINTER4(dd2wall2)
   CALL POPPOINTER4(ww1)
   CALL POPPOINTER4(ww1b)
   CALL POPPOINTER4(ww2)
   CALL POPPOINTER4(ww2b)
   CALL POPPOINTER4(rres)
   CALL POPPOINTER4(rresb)
   CALL POPPOINTER4(ss)
   CALL POPPOINTER4(ssb)
   CALL POPREAL8(fact)
   END IF
   END DO
   END IF
   END SUBROUTINE UTAUWF_B

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
   !
   !  Differentiation of rotmatrixrigidbody in forward (tangent) mode:
   !   variations   of useful results: rotationpoint
   !   with respect to varying inputs: rotpoint rotationpoint
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          rotMatrixRigidBody.f90                          *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 12-15-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE ROTMATRIXRIGIDBODY_EXTRA_D(tnew, told, rotationmatrix, &
   &  rotationpoint, rotationpointd)
   USE FLOWVARREFSTATE
   USE MONITOR
   USE INPUTMOTION
   IMPLICIT NONE
   !
   !      ******************************************************************
   !      *                                                                *
   !      * rotMatrixRigidBody determines the rotation matrix and the      *
   !      * rotation point to determine the coordinates of the new time    *
   !      * level starting from the coordinates of the old time level.     *
   !      *                                                                *
   !      ******************************************************************
   !
   !
   !      Subroutine arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: tnew, told
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: rotationpoint
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: rotationpointd
   REAL(kind=realtype), DIMENSION(3, 3), INTENT(OUT) :: rotationmatrix
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j
   REAL(kind=realtype) :: phi
   REAL(kind=realtype) :: cosx, cosy, cosz, sinx, siny, sinz
   REAL(kind=realtype), DIMENSION(3, 3) :: mnew, mold
   !
   !      Function definition.
   !
   REAL(kind=realtype) :: RIGIDROTANGLE
   INTRINSIC COS
   INTRINSIC SIN
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the rotation angle around the x-axis for the new
   ! time level and the corresponding values of the sine and cosine.
   phi = RIGIDROTANGLE(degreepolxrot, coefpolxrot, degreefourxrot, &
   &    omegafourxrot, coscoeffourxrot, sincoeffourxrot, tnew)
   sinx = SIN(phi)
   cosx = COS(phi)
   ! Idem for the y-axis.
   phi = RIGIDROTANGLE(degreepolyrot, coefpolyrot, degreefouryrot, &
   &    omegafouryrot, coscoeffouryrot, sincoeffouryrot, tnew)
   siny = SIN(phi)
   cosy = COS(phi)
   ! Idem for the z-axis.
   phi = RIGIDROTANGLE(degreepolzrot, coefpolzrot, degreefourzrot, &
   &    omegafourzrot, coscoeffourzrot, sincoeffourzrot, tnew)
   sinz = SIN(phi)
   cosz = COS(phi)
   ! Construct the transformation matrix at the new time level.
   ! It is assumed that the sequence of rotation is first around the
   ! x-axis then around the y-axis and finally around the z-axis.
   mnew(1, 1) = cosy*cosz
   mnew(2, 1) = cosy*sinz
   mnew(3, 1) = -siny
   mnew(1, 2) = sinx*siny*cosz - cosx*sinz
   mnew(2, 2) = sinx*siny*sinz + cosx*cosz
   mnew(3, 2) = sinx*cosy
   mnew(1, 3) = cosx*siny*cosz + sinx*sinz
   mnew(2, 3) = cosx*siny*sinz - sinx*cosz
   mnew(3, 3) = cosx*cosy
   ! Determine the rotation angle around the x-axis for the old
   ! time level and the corresponding values of the sine and cosine.
   phi = RIGIDROTANGLE(degreepolxrot, coefpolxrot, degreefourxrot, &
   &    omegafourxrot, coscoeffourxrot, sincoeffourxrot, told)
   sinx = SIN(phi)
   cosx = COS(phi)
   ! Idem for the y-axis.
   phi = RIGIDROTANGLE(degreepolyrot, coefpolyrot, degreefouryrot, &
   &    omegafouryrot, coscoeffouryrot, sincoeffouryrot, told)
   siny = SIN(phi)
   cosy = COS(phi)
   ! Idem for the z-axis.
   phi = RIGIDROTANGLE(degreepolzrot, coefpolzrot, degreefourzrot, &
   &    omegafourzrot, coscoeffourzrot, sincoeffourzrot, told)
   sinz = SIN(phi)
   cosz = COS(phi)
   ! Construct the transformation matrix at the old time level.
   mold(1, 1) = cosy*cosz
   mold(2, 1) = cosy*sinz
   mold(3, 1) = -siny
   mold(1, 2) = sinx*siny*cosz - cosx*sinz
   mold(2, 2) = sinx*siny*sinz + cosx*cosz
   mold(3, 2) = sinx*cosy
   mold(1, 3) = cosx*siny*cosz + sinx*sinz
   mold(2, 3) = cosx*siny*sinz - sinx*cosz
   mold(3, 3) = cosx*cosy
   ! Construct the transformation matrix between the new and the
   ! old time level. This is mNew*inverse(mOld). However the
   ! inverse of mOld is the transpose.
   DO j=1,3
   DO i=1,3
   rotationmatrix(i, j) = mnew(i, 1)*mold(j, 1) + mnew(i, 2)*mold(j, &
   &        2) + mnew(i, 3)*mold(j, 3)
   END DO
   END DO
   ! Determine the rotation point at the old time level; it is
   ! possible that this value changes due to translation of the grid.
   !  aInf = sqrt(gammaInf*pInf/rhoInf)
   !  rotationPoint(1) = LRef*rotPoint(1) &
   !                   + MachGrid(1)*aInf*tOld/timeRef
   !  rotationPoint(2) = LRef*rotPoint(2) &
   !                   + MachGrid(2)*aInf*tOld/timeRef
   !  rotationPoint(3) = LRef*rotPoint(3) &
   !                   + MachGrid(3)*aInf*tOld/timeRef
   rotationpointd(1) = lref*rotpointd(1)
   rotationpoint(1) = lref*rotpoint(1)
   rotationpointd(2) = lref*rotpointd(2)
   rotationpoint(2) = lref*rotpoint(2)
   rotationpointd(3) = lref*rotpointd(3)
   rotationpoint(3) = lref*rotpoint(3)
   END SUBROUTINE ROTMATRIXRIGIDBODY_EXTRA_D

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!  Differentiation of block_res_extra in forward (tangent) mode:
!   variations   of useful results: mach *dw *w
!   with respect to varying inputs: machgrid mach rotpoint cgnsdoms.rotcenter
!                cgnsdoms.rotrate alpha beta
!   RW status of diff variables: machgrid:in mach:in-out rotpoint:in
!                *dw:out *w:out cgnsdoms.rotcenter:in cgnsdoms.rotrate:in
!                alpha:in beta:in
! This is a super-combined function that combines the original
! functionality of: 
! Pressure Computation
! timeStep
! applyAllBCs
! initRes
! residual 
! The real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the
! block/sps loop is outside the calculation. This routine is suitable
! for forward mode AD with Tapenade
SUBROUTINE BLOCK_RES_EXTRA_EXTRA_D(nn, sps, alpha, alphad, beta, betad, &
     &  liftindex)
  USE INPUTTIMESPECTRAL
  USE FLOWVARREFSTATE
  USE CGNSGRID
  USE INPUTPHYSICS
  USE BLOCKPOINTERS_D
  USE MONITOR
  USE ITERATION
  USE INPUTMOTION
  USE SECTION
  IMPLICIT NONE
  !,x_peturb)
  ! i/j/kl/b/e, i/j/k/Min/MaxBoundaryStencil
  ! nw
  !nsections
  !timeunsteadyrestart
  !rotPoint
  !cgnsDoms vars for differentiation
  !Subrountine Variables
  INTEGER(kind=inttype) :: nn, sps, liftindex
  REAL(kind=realtype) :: alpha, beta
  REAL(kind=realtype) :: alphad, betad
  REAL(kind=realtype) :: gm1, v2
  INTEGER(kind=inttype) :: i, j, k, mm, l, sps2
  LOGICAL :: correctfork, useoldcoor=.false.
  !for grid velocities computation
  REAL(kind=realtype), DIMENSION(nsections) :: t
  REAL(kind=realtype), DIMENSION(nsections) :: td
  REAL :: result1
  INTRINSIC MAX
  INTRINSIC REAL
  !Begin execution
  !get some basic info about extra variables
  !print *,'adjust'
  CALL ADJUSTINFLOWANGLE_EXTRA_D(alpha, alphad, beta, betad, liftindex)
  !print *,'check'
  CALL CHECKINPUTPARAM_MOD_EXTRA_D()
  !print *,'ref'
  CALL REFERENCESTATE_MOD_EXTRA_D()
  !print *,'setflow'
  CALL SETFLOWINFINITYSTATE_EXTRA_D()
  !print *,'setpointers'
  CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps, sps)
  ! Compute the time, which corresponds to this spectral solution.
  ! For steady and unsteady mode this is simply the restart time;
  ! for the spectral mode the periodic time must be taken into
  ! account, which can be different for every section.
  !print *,'time sps'
  t = timeunsteadyrestart
  IF (equationmode .EQ. timespectral) THEN
     DO mm=1,nsections
        result1 = REAL(ntimeintervalsspectral, realtype)
        td(mm) = 0.0
        t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/result1
     END DO
  END IF
  !print *,'gridvel'
  CALL GRIDVELOCITIESFINELEVEL_BLOCK_EXTRA_D(useoldcoor, t, sps)
  ! Required for TS
  !print *,'normalvel'
  CALL NORMALVELOCITIES_BLOCK_EXTRA_D(sps)
  ! Required for TS
  !call slipVelocitiesFineLevel(.false., t, mm) !required for viscous
  ! Compute the pressures
  !print *,'computep'
  gm1 = gammaconstant - one
  correctfork = .false.
  pd = 0.0
  ! Compute P 
  DO k=0,kb
     DO j=0,jb
        DO i=0,ib
           v2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
                &          2
           pd(i, j, k) = 0.0
           p(i, j, k) = gm1*(w(i, j, k, irhoe)-half*w(i, j, k, irho)*v2)
           IF (p(i, j, k) .LT. 1.e-4_realType*pinfcorr) THEN
              pd(i, j, k) = 1.e-4_realType*pinfcorrd
              p(i, j, k) = 1.e-4_realType*pinfcorr
           ELSE
              p(i, j, k) = p(i, j, k)
           END IF
        END DO
     END DO
  END DO
  !call computeEtot(0,ib,0,jb,0,kb,correctForK)
  !  Apply all BC's
  !print *,'bcs'
  CALL APPLYALLBC_BLOCK_EXTRA_D(.true.)
  ! Compute skin_friction Velocity
  !   print *,'utau'
  CALL COMPUTEUTAU_BLOCK()
  ! Compute time step and spectral radius
  !   print *,'timestep'
  CALL TIMESTEP_BLOCK_EXTRA_D(.false.)
  !   if( equations == RANSEquations ) then
  !      call initres_block(nt1MG, nMGVar,nn,sps) ! Initialize only the Turblent Variables
  !      call turbResidual_block
  !   endif
  SELECT CASE  (equationmode) 
  CASE (steady) 
     dw = 0.0
  CASE (timespectral) 
     DO sps2=1,ntimeintervalsspectral
        CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps2, sps2)
        dw = 0.0
        DO mm=1,ntimeintervalsspectral
           CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps2, mm)
           !print *,'initres'
           CALL INITRES_BLOCK_TS(1, nwf, nn, sps2, mm)
        END DO
     END DO
  END SELECT
  ! Rest the pointers the the "on time instance"
  CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps, sps)
  ! Actual residual calc
  !print *,'res'
  CALL RESIDUAL_BLOCK_EXTRA_D()
  ! Divide through by the volume
  DO sps2=1,ntimeintervalsspectral
     CALL SETPOINTERSOFFTSINSTANCE_D(nn, sps2, sps2)
     DO l=1,nw
        DO k=2,kl
           DO j=2,jl
              DO i=2,il
                 dwd(i, j, k, l) = dwd(i, j, k, l)/vol(i, j, k)
                 dw(i, j, k, l) = dw(i, j, k, l)/vol(i, j, k)
              END DO
           END DO
        END DO
     END DO
  END DO
  !print *,'end'
END SUBROUTINE BLOCK_RES_EXTRA_EXTRA_D

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of getcostfunction in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: pref
   !   with respect to varying inputs: tempfreestream veldirfreestream
   !                machcoef gammainf pref alpha
   SUBROUTINE GETCOSTFUNCTION_D(costfunction, force, moment, sepsensor, &
   & cavitation, alpha, alphad, beta, liftindex, objvalue)
   ! Compute the value of the actual objective function based on the
   ! (summed) forces and moments and any other "extra" design
   ! variables. The index of the objective is determined by 'iDV'. This
   ! function is intended to be AD'ed in reverse mode. 
   USE INPUTTIMESPECTRAL
   USE COSTFUNCTIONS
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   ! Input 
   INTEGER(kind=inttype), INTENT(IN) :: costfunction
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral), INTENT(IN) &
   & :: force, moment
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral), INTENT(IN) :: &
   & sepsensor, cavitation
   REAL(kind=realtype), INTENT(IN) :: alpha, beta
   REAL(kind=realtype), INTENT(IN) :: alphad
   ! Output
   REAL(kind=realtype) :: objvalue
   ! Working
   REAL(kind=realtype) :: fact, factmoment, scaledim, ovrnts
   REAL(kind=realtype), DIMENSION(3) :: cf, cm
   REAL(kind=realtype) :: elasticmomentx, elasticmomenty, elasticmomentz
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: basecoef
   REAL(kind=realtype), DIMENSION(8) :: coef0, dcdalpha, dcdalphadot, &
   & dcdq, dcdqdot
   REAL(kind=realtype) :: bendingmoment
   INTEGER(kind=inttype) :: sps
   REAL(kind=realtype) :: betad
   ! Compute the factor since we may need it below
   betad = 0.0_8
   CALL ADJUSTINFLOWANGLE_D(alpha, alphad, beta, betad, liftindex)
   machd = 0.0_8
   CALL REFERENCESTATE_D()
   scaledim = pref/pinf
   fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
   factmoment = fact/(lengthref*lref)
   objvalue = zero
   ovrnts = one/ntimeintervalsspectral
   ! Pre-compute TS stability info if required:
   SELECT CASE  (costfunction) 
   CASE (costfunccl0, costfunccd0, costfunccm0, costfuncclalpha, &
   & costfunccdalpha, costfunccmzalpha, costfuncclalphadot, &
   & costfunccdalphadot, costfunccmzalphadot, costfuncclq, costfunccdq, &
   & costfunccmzq, costfuncclqdot, costfunccdqdot, costfunccmzqdot) 
   CALL COMPUTETSDERIVATIVES(force, moment, liftindex, coef0, &
   &                          dcdalpha, dcdalphadot, dcdq, dcdqdot)
   END SELECT
   ! Main cost function selection
   SELECT CASE  (costfunction) 
   CASE (costfuncforcex) 
   ! ------------------ Steady or Average Objectives ---------------
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*force(1, sps)
   END DO
   CASE (costfuncforcey) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*force(2, sps)
   END DO
   CASE (costfuncforcez) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*force(3, sps)
   END DO
   CASE (costfuncmomx) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*moment(1, sps)
   END DO
   CASE (costfuncmomy) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*moment(2, sps)
   END DO
   CASE (costfuncmomz) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*moment(3, sps)
   END DO
   CASE (costfuncforcexcoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*force(1, sps)*fact
   END DO
   CASE (costfuncforceycoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*force(2, sps)*fact
   END DO
   CASE (costfuncforcezcoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*force(3, sps)*fact
   END DO
   CASE (costfuncmomxcoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*moment(1, sps)*factmoment
   END DO
   CASE (costfuncmomycoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*moment(2, sps)*factmoment
   END DO
   CASE (costfuncmomzcoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*moment(3, sps)*factmoment
   END DO
   CASE (costfunclift) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*(force(1, sps)*liftdirection(1)+force&
   &       (2, sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
   END DO
   CASE (costfuncdrag) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*(force(1, sps)*dragdirection(1)+force&
   &       (2, sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
   END DO
   CASE (costfuncliftcoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*fact*(force(1, sps)*liftdirection(1)+&
   &       force(2, sps)*liftdirection(2)+force(3, sps)*liftdirection(3))
   END DO
   CASE (costfuncdragcoef) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*fact*(force(1, sps)*dragdirection(1)+&
   &       force(2, sps)*dragdirection(2)+force(3, sps)*dragdirection(3))
   END DO
   CASE (costfunccl0) 
   ! -------------------- Time Spectral Objectives ------------------
   objvalue = coef0(1)
   CASE (costfunccd0) 
   objvalue = coef0(2)
   CASE (costfunccm0) 
   objvalue = coef0(8)
   CASE (costfuncclalpha) 
   objvalue = dcdalpha(1)
   CASE (costfunccdalpha) 
   objvalue = dcdalpha(2)
   CASE (costfunccmzalpha) 
   objvalue = dcdalpha(8)
   CASE (costfuncclalphadot) 
   objvalue = dcdalphadot(1)
   CASE (costfunccdalphadot) 
   objvalue = dcdalphadot(2)
   CASE (costfunccmzalphadot) 
   objvalue = dcdalphadot(8)
   CASE (costfuncclq) 
   objvalue = dcdq(1)
   CASE (costfunccdq) 
   objvalue = dcdq(2)
   CASE (costfunccmzq) 
   objvalue = dcdq(8)
   CASE (costfuncclqdot) 
   objvalue = dcdqdot(1)
   CASE (costfunccdqdot) 
   objvalue = dcdqdot(2)
   CASE (costfunccmzqdot) 
   objvalue = dcdqdot(8)
   CASE (costfuncbendingcoef) 
   ! ----------------- Bending moment calc -------------------
   DO sps=1,ntimeintervalsspectral
   cm = factmoment*moment(:, sps)
   cf = fact*force(:, sps)
   CALL COMPUTEROOTBENDINGMOMENT(cf, cm, liftindex, bendingmoment)
   objvalue = objvalue + ovrnts*bendingmoment
   END DO
   CASE (costfuncsepsensor) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*sepsensor(sps)
   END DO
   CASE (costfunccavitation) 
   DO sps=1,ntimeintervalsspectral
   objvalue = objvalue + ovrnts*cavitation(sps)
   END DO
   END SELECT
   END SUBROUTINE GETCOSTFUNCTION_D

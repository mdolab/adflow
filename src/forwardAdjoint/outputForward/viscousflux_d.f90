   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of viscousflux in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *fw *(*viscsubface.tau)
   !   with respect to varying inputs: *rev *aa *wx *wy *wz *w *rlv
   !                *x *qx *qy *qz *ux *uy *uz *si *sj *sk *vx *vy
   !                *vz *fw
   !   Plus diff mem management of: rev:in aa:in wx:in wy:in wz:in
   !                w:in rlv:in x:in qx:in qy:in qz:in ux:in uy:in
   !                uz:in si:in sj:in sk:in vx:in vy:in vz:in fw:in
   !                viscsubface:in *viscsubface.tau:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          viscousFlux.f90                                 *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-21-2003                                      *
   !      * Last modified: 04-18-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE VISCOUSFLUX_D()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * viscousFlux computes the viscous fluxes using a central        *
   !      * difference scheme for a block.                                 *
   !      * It is assumed that the pointers in block pointer already point *
   !      * to the correct block.                                          *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfviscsubface should be the size of dimension 1 of array *viscsubface
   IMPLICIT NONE
   ! Possibly correct the wall shear stress.
   ! Wall function is not ADed
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: twothird=two*third
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, ii
   REAL(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
   REAL(kind=realtype) :: muld, mued, mutd, heatcoefd
   REAL(kind=realtype) :: gm1, factlamheat, factturbheat
   REAL(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
   REAL(kind=realtype) :: u_xd, u_yd, u_zd, v_xd, v_yd, v_zd, w_xd, w_yd&
   & , w_zd
   REAL(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
   REAL(kind=realtype) :: q_xd, q_yd, q_zd, ubard, vbard, wbard
   REAL(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
   REAL(kind=realtype) :: corrd, ssxd, ssyd, sszd, ssd, fracdivd
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxd, tauyyd, tauzzd
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyd, tauxzd, tauyzd
   REAL(kind=realtype) :: fmx, fmy, fmz, frhoe
   REAL(kind=realtype) :: fmxd, fmyd, fmzd, frhoed
   LOGICAL :: correctfork, storewalltensor
   INTRINSIC ABS
   INTRINSIC SQRT
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: result1d
   REAL(kind=realtype) :: abs0
   INTEGER :: ii1
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   ! Set rFilv to rFil to indicate that this is the viscous part.
   ! If rFilv == 0 the viscous residuals need not to be computed
   ! and a return can be made.
   rfilv = rfil
   IF (rfilv .GE. 0.) THEN
   abs0 = rfilv
   ELSE
   abs0 = -rfilv
   END IF
   IF (abs0 .LT. thresholdreal) THEN
   DO ii1=1,ISIZE1OFDrfviscsubface
   viscsubfaced(ii1)%tau = 0.0_8
   END DO
   RETURN
   ELSE
   ! Determine whether or not the wall stress tensor and wall heat
   ! flux must be stored for viscous walls.
   storewalltensor = .false.
   IF (wallfunctions) THEN
   storewalltensor = .true.
   ELSE IF (rkstage .EQ. 0 .AND. currentlevel .EQ. groundlevel) THEN
   storewalltensor = .true.
   END IF
   !
   !        ****************************************************************
   !        *                                                              *
   !        * viscous fluxes in the k-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   mue = zero
   DO ii1=1,ISIZE1OFDrfviscsubface
   viscsubfaced(ii1)%tau = 0.0_8
   END DO
   mued = 0.0_8
   DO k=1,kl
   DO j=2,jl
   DO i=2,il
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pork(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   muld = por*(rlvd(i, j, k)+rlvd(i, j, k+1))
   mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
   IF (eddymodel) THEN
   mued = por*(revd(i, j, k)+revd(i, j, k+1))
   mue = por*(rev(i, j, k)+rev(i, j, k+1))
   END IF
   mutd = muld + mued
   mut = mul + mue
   gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   heatcoefd = factlamheat*muld + factturbheat*mued
   heatcoef = mul*factlamheat + mue*factturbheat
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_xd = fourth*(uxd(i-1, j-1, k)+uxd(i, j-1, k)+uxd(i-1, j, k)+&
   &           uxd(i, j, k))
   u_x = fourth*(ux(i-1, j-1, k)+ux(i, j-1, k)+ux(i-1, j, k)+ux(i&
   &           , j, k))
   u_yd = fourth*(uyd(i-1, j-1, k)+uyd(i, j-1, k)+uyd(i-1, j, k)+&
   &           uyd(i, j, k))
   u_y = fourth*(uy(i-1, j-1, k)+uy(i, j-1, k)+uy(i-1, j, k)+uy(i&
   &           , j, k))
   u_zd = fourth*(uzd(i-1, j-1, k)+uzd(i, j-1, k)+uzd(i-1, j, k)+&
   &           uzd(i, j, k))
   u_z = fourth*(uz(i-1, j-1, k)+uz(i, j-1, k)+uz(i-1, j, k)+uz(i&
   &           , j, k))
   v_xd = fourth*(vxd(i-1, j-1, k)+vxd(i, j-1, k)+vxd(i-1, j, k)+&
   &           vxd(i, j, k))
   v_x = fourth*(vx(i-1, j-1, k)+vx(i, j-1, k)+vx(i-1, j, k)+vx(i&
   &           , j, k))
   v_yd = fourth*(vyd(i-1, j-1, k)+vyd(i, j-1, k)+vyd(i-1, j, k)+&
   &           vyd(i, j, k))
   v_y = fourth*(vy(i-1, j-1, k)+vy(i, j-1, k)+vy(i-1, j, k)+vy(i&
   &           , j, k))
   v_zd = fourth*(vzd(i-1, j-1, k)+vzd(i, j-1, k)+vzd(i-1, j, k)+&
   &           vzd(i, j, k))
   v_z = fourth*(vz(i-1, j-1, k)+vz(i, j-1, k)+vz(i-1, j, k)+vz(i&
   &           , j, k))
   w_xd = fourth*(wxd(i-1, j-1, k)+wxd(i, j-1, k)+wxd(i-1, j, k)+&
   &           wxd(i, j, k))
   w_x = fourth*(wx(i-1, j-1, k)+wx(i, j-1, k)+wx(i-1, j, k)+wx(i&
   &           , j, k))
   w_yd = fourth*(wyd(i-1, j-1, k)+wyd(i, j-1, k)+wyd(i-1, j, k)+&
   &           wyd(i, j, k))
   w_y = fourth*(wy(i-1, j-1, k)+wy(i, j-1, k)+wy(i-1, j, k)+wy(i&
   &           , j, k))
   w_zd = fourth*(wzd(i-1, j-1, k)+wzd(i, j-1, k)+wzd(i-1, j, k)+&
   &           wzd(i, j, k))
   w_z = fourth*(wz(i-1, j-1, k)+wz(i, j-1, k)+wz(i-1, j, k)+wz(i&
   &           , j, k))
   q_xd = fourth*(qxd(i-1, j-1, k)+qxd(i, j-1, k)+qxd(i-1, j, k)+&
   &           qxd(i, j, k))
   q_x = fourth*(qx(i-1, j-1, k)+qx(i, j-1, k)+qx(i-1, j, k)+qx(i&
   &           , j, k))
   q_yd = fourth*(qyd(i-1, j-1, k)+qyd(i, j-1, k)+qyd(i-1, j, k)+&
   &           qyd(i, j, k))
   q_y = fourth*(qy(i-1, j-1, k)+qy(i, j-1, k)+qy(i-1, j, k)+qy(i&
   &           , j, k))
   q_zd = fourth*(qzd(i-1, j-1, k)+qzd(i, j-1, k)+qzd(i-1, j, k)+&
   &           qzd(i, j, k))
   q_z = fourth*(qz(i-1, j-1, k)+qz(i, j-1, k)+qz(i-1, j, k)+qz(i&
   &           , j, k))
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center k to cell center k+1.
   ssxd = eighth*(xd(i-1, j-1, k+1, 1)-xd(i-1, j-1, k-1, 1)+xd(i-&
   &           1, j, k+1, 1)-xd(i-1, j, k-1, 1)+xd(i, j-1, k+1, 1)-xd(i, j-&
   &           1, k-1, 1)+xd(i, j, k+1, 1)-xd(i, j, k-1, 1))
   ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
   &           , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
   &           , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
   ssyd = eighth*(xd(i-1, j-1, k+1, 2)-xd(i-1, j-1, k-1, 2)+xd(i-&
   &           1, j, k+1, 2)-xd(i-1, j, k-1, 2)+xd(i, j-1, k+1, 2)-xd(i, j-&
   &           1, k-1, 2)+xd(i, j, k+1, 2)-xd(i, j, k-1, 2))
   ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
   &           , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
   &           , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
   sszd = eighth*(xd(i-1, j-1, k+1, 3)-xd(i-1, j-1, k-1, 3)+xd(i-&
   &           1, j, k+1, 3)-xd(i-1, j, k-1, 3)+xd(i, j-1, k+1, 3)-xd(i, j-&
   &           1, k-1, 3)+xd(i, j, k+1, 3)-xd(i, j, k-1, 3))
   ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
   &           , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
   &           , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
   ! Determine the length of this vector and create the
   ! unit normal.
   arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz +&
   &           ssz*sszd
   arg1 = ssx*ssx + ssy*ssy + ssz*ssz
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   ssd = -(one*result1d/result1**2)
   ss = one/result1
   ssxd = ssd*ssx + ss*ssxd
   ssx = ss*ssx
   ssyd = ssd*ssy + ss*ssyd
   ssy = ss*ssy
   sszd = ssd*ssz + ss*sszd
   ssz = ss*ssz
   ! Correct the gradients.
   corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz +&
   &           u_z*sszd - (wd(i, j, k+1, ivx)-wd(i, j, k, ivx))*ss - (w(i, &
   &           j, k+1, ivx)-w(i, j, k, ivx))*ssd
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j&
   &           , k, ivx))*ss
   u_xd = u_xd - corrd*ssx - corr*ssxd
   u_x = u_x - corr*ssx
   u_yd = u_yd - corrd*ssy - corr*ssyd
   u_y = u_y - corr*ssy
   u_zd = u_zd - corrd*ssz - corr*sszd
   u_z = u_z - corr*ssz
   corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz +&
   &           v_z*sszd - (wd(i, j, k+1, ivy)-wd(i, j, k, ivy))*ss - (w(i, &
   &           j, k+1, ivy)-w(i, j, k, ivy))*ssd
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j&
   &           , k, ivy))*ss
   v_xd = v_xd - corrd*ssx - corr*ssxd
   v_x = v_x - corr*ssx
   v_yd = v_yd - corrd*ssy - corr*ssyd
   v_y = v_y - corr*ssy
   v_zd = v_zd - corrd*ssz - corr*sszd
   v_z = v_z - corr*ssz
   corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz +&
   &           w_z*sszd - (wd(i, j, k+1, ivz)-wd(i, j, k, ivz))*ss - (w(i, &
   &           j, k+1, ivz)-w(i, j, k, ivz))*ssd
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j&
   &           , k, ivz))*ss
   w_xd = w_xd - corrd*ssx - corr*ssxd
   w_x = w_x - corr*ssx
   w_yd = w_yd - corrd*ssy - corr*ssyd
   w_y = w_y - corr*ssy
   w_zd = w_zd - corrd*ssz - corr*sszd
   w_z = w_z - corr*ssz
   corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz +&
   &           q_z*sszd + (aad(i, j, k+1)-aad(i, j, k))*ss + (aa(i, j, k+1)&
   &           -aa(i, j, k))*ssd
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j, k+1)-aa(i, j, k&
   &           ))*ss
   q_xd = q_xd - corrd*ssx - corr*ssxd
   q_x = q_x - corr*ssx
   q_yd = q_yd - corrd*ssy - corr*ssyd
   q_y = q_y - corr*ssy
   q_zd = q_zd - corrd*ssz - corr*sszd
   q_z = q_z - corr*ssz
   ! Compute the stress tensor and the heat flux vector.
   fracdivd = twothird*(u_xd+v_yd+w_zd)
   fracdiv = twothird*(u_x+v_y+w_z)
   tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
   tauxx = mut*(two*u_x-fracdiv)
   tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
   tauyy = mut*(two*v_y-fracdiv)
   tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
   tauzz = mut*(two*w_z-fracdiv)
   tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
   tauxy = mut*(u_y+v_x)
   tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
   tauxz = mut*(u_z+w_x)
   tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
   tauyz = mut*(v_z+w_y)
   q_xd = heatcoefd*q_x + heatcoef*q_xd
   q_x = heatcoef*q_x
   q_yd = heatcoefd*q_y + heatcoef*q_yd
   q_y = heatcoef*q_y
   q_zd = heatcoefd*q_z + heatcoef*q_zd
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubard = half*(wd(i, j, k, ivx)+wd(i, j, k+1, ivx))
   ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
   vbard = half*(wd(i, j, k, ivy)+wd(i, j, k+1, ivy))
   vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
   wbard = half*(wd(i, j, k, ivz)+wd(i, j, k+1, ivz))
   wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
   ! Compute the viscous fluxes for this k-face.
   fmxd = tauxxd*sk(i, j, k, 1) + tauxx*skd(i, j, k, 1) + tauxyd*&
   &           sk(i, j, k, 2) + tauxy*skd(i, j, k, 2) + tauxzd*sk(i, j, k, &
   &           3) + tauxz*skd(i, j, k, 3)
   fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i&
   &           , j, k, 3)
   fmyd = tauxyd*sk(i, j, k, 1) + tauxy*skd(i, j, k, 1) + tauyyd*&
   &           sk(i, j, k, 2) + tauyy*skd(i, j, k, 2) + tauyzd*sk(i, j, k, &
   &           3) + tauyz*skd(i, j, k, 3)
   fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i&
   &           , j, k, 3)
   fmzd = tauxzd*sk(i, j, k, 1) + tauxz*skd(i, j, k, 1) + tauyzd*&
   &           sk(i, j, k, 2) + tauyz*skd(i, j, k, 2) + tauzzd*sk(i, j, k, &
   &           3) + tauzz*skd(i, j, k, 3)
   fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i&
   &           , j, k, 3)
   frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
   &           wbard*tauxz+wbar*tauxzd)*sk(i, j, k, 1) + (ubar*tauxx+vbar*&
   &           tauxy+wbar*tauxz)*skd(i, j, k, 1)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1)
   frhoed = frhoed + (ubard*tauxy+ubar*tauxyd+vbard*tauyy+vbar*&
   &           tauyyd+wbard*tauyz+wbar*tauyzd)*sk(i, j, k, 2) + (ubar*tauxy&
   &           +vbar*tauyy+wbar*tauyz)*skd(i, j, k, 2)
   frhoe = frhoe + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k&
   &           , 2)
   frhoed = frhoed + (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*&
   &           tauyzd+wbard*tauzz+wbar*tauzzd)*sk(i, j, k, 3) + (ubar*tauxz&
   &           +vbar*tauyz+wbar*tauzz)*skd(i, j, k, 3)
   frhoe = frhoe + (ubar*tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k&
   &           , 3)
   frhoed = frhoed - q_xd*sk(i, j, k, 1) - q_x*skd(i, j, k, 1) - &
   &           q_yd*sk(i, j, k, 2) - q_y*skd(i, j, k, 2) - q_zd*sk(i, j, k&
   &           , 3) - q_z*skd(i, j, k, 3)
   frhoe = frhoe - q_x*sk(i, j, k, 1) - q_y*sk(i, j, k, 2) - q_z*&
   &           sk(i, j, k, 3)
   ! Update the residuals of cell k and k+1.
   fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fmxd
   fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
   fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fmyd
   fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
   fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fmzd
   fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
   fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + frhoed
   fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface. Both the cases k == 1
   ! and k == kl must be tested.
   IF (k .EQ. 1 .AND. storewalltensor .AND. visckminpointer(i, j)&
   &             .GT. 0) THEN
   ! We need to index viscSubface with viscKminPointer(i,j) 
   ! since Tapenade does not like temporary indexes 
   viscsubfaced(visckminpointer(i, j))%tau(i, j, 1) = tauxxd
   viscsubface(visckminpointer(i, j))%tau(i, j, 1) = tauxx
   viscsubfaced(visckminpointer(i, j))%tau(i, j, 2) = tauyyd
   viscsubface(visckminpointer(i, j))%tau(i, j, 2) = tauyy
   viscsubfaced(visckminpointer(i, j))%tau(i, j, 3) = tauzzd
   viscsubface(visckminpointer(i, j))%tau(i, j, 3) = tauzz
   viscsubfaced(visckminpointer(i, j))%tau(i, j, 4) = tauxyd
   viscsubface(visckminpointer(i, j))%tau(i, j, 4) = tauxy
   viscsubfaced(visckminpointer(i, j))%tau(i, j, 5) = tauxzd
   viscsubface(visckminpointer(i, j))%tau(i, j, 5) = tauxz
   viscsubfaced(visckminpointer(i, j))%tau(i, j, 6) = tauyzd
   viscsubface(visckminpointer(i, j))%tau(i, j, 6) = tauyz
   viscsubface(visckminpointer(i, j))%q(i, j, 1) = q_x
   viscsubface(visckminpointer(i, j))%q(i, j, 2) = q_y
   viscsubface(visckminpointer(i, j))%q(i, j, 3) = q_z
   END IF
   ! And the k == kl case.
   IF (k .EQ. kl .AND. storewalltensor .AND. visckmaxpointer(i, j&
   &             ) .GT. 0) THEN
   viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 1) = tauxxd
   viscsubface(visckmaxpointer(i, j))%tau(i, j, 1) = tauxx
   viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 2) = tauyyd
   viscsubface(visckmaxpointer(i, j))%tau(i, j, 2) = tauyy
   viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 3) = tauzzd
   viscsubface(visckmaxpointer(i, j))%tau(i, j, 3) = tauzz
   viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 4) = tauxyd
   viscsubface(visckmaxpointer(i, j))%tau(i, j, 4) = tauxy
   viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 5) = tauxzd
   viscsubface(visckmaxpointer(i, j))%tau(i, j, 5) = tauxz
   viscsubfaced(visckmaxpointer(i, j))%tau(i, j, 6) = tauyzd
   viscsubface(visckmaxpointer(i, j))%tau(i, j, 6) = tauyz
   viscsubface(visckmaxpointer(i, j))%q(i, j, 1) = q_x
   viscsubface(visckmaxpointer(i, j))%q(i, j, 2) = q_y
   viscsubface(visckmaxpointer(i, j))%q(i, j, 3) = q_z
   END IF
   END DO
   END DO
   END DO
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the j-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   mue = zero
   mued = 0.0_8
   DO k=2,kl
   DO j=1,jl
   DO i=2,il
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (porj(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied by the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   muld = por*(rlvd(i, j, k)+rlvd(i, j+1, k))
   mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
   IF (eddymodel) THEN
   mued = por*(revd(i, j, k)+revd(i, j+1, k))
   mue = por*(rev(i, j, k)+rev(i, j+1, k))
   END IF
   mutd = muld + mued
   mut = mul + mue
   gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   heatcoefd = factlamheat*muld + factturbheat*mued
   heatcoef = mul*factlamheat + mue*factturbheat
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_xd = fourth*(uxd(i-1, j, k-1)+uxd(i, j, k-1)+uxd(i-1, j, k)+&
   &           uxd(i, j, k))
   u_x = fourth*(ux(i-1, j, k-1)+ux(i, j, k-1)+ux(i-1, j, k)+ux(i&
   &           , j, k))
   u_yd = fourth*(uyd(i-1, j, k-1)+uyd(i, j, k-1)+uyd(i-1, j, k)+&
   &           uyd(i, j, k))
   u_y = fourth*(uy(i-1, j, k-1)+uy(i, j, k-1)+uy(i-1, j, k)+uy(i&
   &           , j, k))
   u_zd = fourth*(uzd(i-1, j, k-1)+uzd(i, j, k-1)+uzd(i-1, j, k)+&
   &           uzd(i, j, k))
   u_z = fourth*(uz(i-1, j, k-1)+uz(i, j, k-1)+uz(i-1, j, k)+uz(i&
   &           , j, k))
   v_xd = fourth*(vxd(i-1, j, k-1)+vxd(i, j, k-1)+vxd(i-1, j, k)+&
   &           vxd(i, j, k))
   v_x = fourth*(vx(i-1, j, k-1)+vx(i, j, k-1)+vx(i-1, j, k)+vx(i&
   &           , j, k))
   v_yd = fourth*(vyd(i-1, j, k-1)+vyd(i, j, k-1)+vyd(i-1, j, k)+&
   &           vyd(i, j, k))
   v_y = fourth*(vy(i-1, j, k-1)+vy(i, j, k-1)+vy(i-1, j, k)+vy(i&
   &           , j, k))
   v_zd = fourth*(vzd(i-1, j, k-1)+vzd(i, j, k-1)+vzd(i-1, j, k)+&
   &           vzd(i, j, k))
   v_z = fourth*(vz(i-1, j, k-1)+vz(i, j, k-1)+vz(i-1, j, k)+vz(i&
   &           , j, k))
   w_xd = fourth*(wxd(i-1, j, k-1)+wxd(i, j, k-1)+wxd(i-1, j, k)+&
   &           wxd(i, j, k))
   w_x = fourth*(wx(i-1, j, k-1)+wx(i, j, k-1)+wx(i-1, j, k)+wx(i&
   &           , j, k))
   w_yd = fourth*(wyd(i-1, j, k-1)+wyd(i, j, k-1)+wyd(i-1, j, k)+&
   &           wyd(i, j, k))
   w_y = fourth*(wy(i-1, j, k-1)+wy(i, j, k-1)+wy(i-1, j, k)+wy(i&
   &           , j, k))
   w_zd = fourth*(wzd(i-1, j, k-1)+wzd(i, j, k-1)+wzd(i-1, j, k)+&
   &           wzd(i, j, k))
   w_z = fourth*(wz(i-1, j, k-1)+wz(i, j, k-1)+wz(i-1, j, k)+wz(i&
   &           , j, k))
   q_xd = fourth*(qxd(i-1, j, k-1)+qxd(i, j, k-1)+qxd(i-1, j, k)+&
   &           qxd(i, j, k))
   q_x = fourth*(qx(i-1, j, k-1)+qx(i, j, k-1)+qx(i-1, j, k)+qx(i&
   &           , j, k))
   q_yd = fourth*(qyd(i-1, j, k-1)+qyd(i, j, k-1)+qyd(i-1, j, k)+&
   &           qyd(i, j, k))
   q_y = fourth*(qy(i-1, j, k-1)+qy(i, j, k-1)+qy(i-1, j, k)+qy(i&
   &           , j, k))
   q_zd = fourth*(qzd(i-1, j, k-1)+qzd(i, j, k-1)+qzd(i-1, j, k)+&
   &           qzd(i, j, k))
   q_z = fourth*(qz(i-1, j, k-1)+qz(i, j, k-1)+qz(i-1, j, k)+qz(i&
   &           , j, k))
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center j to cell center j+1.
   ssxd = eighth*(xd(i-1, j+1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(i-&
   &           1, j+1, k, 1)-xd(i-1, j-1, k, 1)+xd(i, j+1, k-1, 1)-xd(i, j-&
   &           1, k-1, 1)+xd(i, j+1, k, 1)-xd(i, j-1, k, 1))
   ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
   &           +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
   &           , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
   ssyd = eighth*(xd(i-1, j+1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(i-&
   &           1, j+1, k, 2)-xd(i-1, j-1, k, 2)+xd(i, j+1, k-1, 2)-xd(i, j-&
   &           1, k-1, 2)+xd(i, j+1, k, 2)-xd(i, j-1, k, 2))
   ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
   &           +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
   &           , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
   sszd = eighth*(xd(i-1, j+1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(i-&
   &           1, j+1, k, 3)-xd(i-1, j-1, k, 3)+xd(i, j+1, k-1, 3)-xd(i, j-&
   &           1, k-1, 3)+xd(i, j+1, k, 3)-xd(i, j-1, k, 3))
   ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
   &           +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
   &           , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
   ! Determine the length of this vector and create the
   ! unit normal.
   arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz +&
   &           ssz*sszd
   arg1 = ssx*ssx + ssy*ssy + ssz*ssz
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   ssd = -(one*result1d/result1**2)
   ss = one/result1
   ssxd = ssd*ssx + ss*ssxd
   ssx = ss*ssx
   ssyd = ssd*ssy + ss*ssyd
   ssy = ss*ssy
   sszd = ssd*ssz + ss*sszd
   ssz = ss*ssz
   ! Correct the gradients.
   corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz +&
   &           u_z*sszd - (wd(i, j+1, k, ivx)-wd(i, j, k, ivx))*ss - (w(i, &
   &           j+1, k, ivx)-w(i, j, k, ivx))*ssd
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j&
   &           , k, ivx))*ss
   u_xd = u_xd - corrd*ssx - corr*ssxd
   u_x = u_x - corr*ssx
   u_yd = u_yd - corrd*ssy - corr*ssyd
   u_y = u_y - corr*ssy
   u_zd = u_zd - corrd*ssz - corr*sszd
   u_z = u_z - corr*ssz
   corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz +&
   &           v_z*sszd - (wd(i, j+1, k, ivy)-wd(i, j, k, ivy))*ss - (w(i, &
   &           j+1, k, ivy)-w(i, j, k, ivy))*ssd
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j&
   &           , k, ivy))*ss
   v_xd = v_xd - corrd*ssx - corr*ssxd
   v_x = v_x - corr*ssx
   v_yd = v_yd - corrd*ssy - corr*ssyd
   v_y = v_y - corr*ssy
   v_zd = v_zd - corrd*ssz - corr*sszd
   v_z = v_z - corr*ssz
   corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz +&
   &           w_z*sszd - (wd(i, j+1, k, ivz)-wd(i, j, k, ivz))*ss - (w(i, &
   &           j+1, k, ivz)-w(i, j, k, ivz))*ssd
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j&
   &           , k, ivz))*ss
   w_xd = w_xd - corrd*ssx - corr*ssxd
   w_x = w_x - corr*ssx
   w_yd = w_yd - corrd*ssy - corr*ssyd
   w_y = w_y - corr*ssy
   w_zd = w_zd - corrd*ssz - corr*sszd
   w_z = w_z - corr*ssz
   corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz +&
   &           q_z*sszd + (aad(i, j+1, k)-aad(i, j, k))*ss + (aa(i, j+1, k)&
   &           -aa(i, j, k))*ssd
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i, j+1, k)-aa(i, j, k&
   &           ))*ss
   q_xd = q_xd - corrd*ssx - corr*ssxd
   q_x = q_x - corr*ssx
   q_yd = q_yd - corrd*ssy - corr*ssyd
   q_y = q_y - corr*ssy
   q_zd = q_zd - corrd*ssz - corr*sszd
   q_z = q_z - corr*ssz
   ! Compute the stress tensor and the heat flux vector.
   fracdivd = twothird*(u_xd+v_yd+w_zd)
   fracdiv = twothird*(u_x+v_y+w_z)
   tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
   tauxx = mut*(two*u_x-fracdiv)
   tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
   tauyy = mut*(two*v_y-fracdiv)
   tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
   tauzz = mut*(two*w_z-fracdiv)
   tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
   tauxy = mut*(u_y+v_x)
   tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
   tauxz = mut*(u_z+w_x)
   tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
   tauyz = mut*(v_z+w_y)
   q_xd = heatcoefd*q_x + heatcoef*q_xd
   q_x = heatcoef*q_x
   q_yd = heatcoefd*q_y + heatcoef*q_yd
   q_y = heatcoef*q_y
   q_zd = heatcoefd*q_z + heatcoef*q_zd
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubard = half*(wd(i, j, k, ivx)+wd(i, j+1, k, ivx))
   ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
   vbard = half*(wd(i, j, k, ivy)+wd(i, j+1, k, ivy))
   vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
   wbard = half*(wd(i, j, k, ivz)+wd(i, j+1, k, ivz))
   wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
   ! Compute the viscous fluxes for this j-face.
   fmxd = tauxxd*sj(i, j, k, 1) + tauxx*sjd(i, j, k, 1) + tauxyd*&
   &           sj(i, j, k, 2) + tauxy*sjd(i, j, k, 2) + tauxzd*sj(i, j, k, &
   &           3) + tauxz*sjd(i, j, k, 3)
   fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i&
   &           , j, k, 3)
   fmyd = tauxyd*sj(i, j, k, 1) + tauxy*sjd(i, j, k, 1) + tauyyd*&
   &           sj(i, j, k, 2) + tauyy*sjd(i, j, k, 2) + tauyzd*sj(i, j, k, &
   &           3) + tauyz*sjd(i, j, k, 3)
   fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i&
   &           , j, k, 3)
   fmzd = tauxzd*sj(i, j, k, 1) + tauxz*sjd(i, j, k, 1) + tauyzd*&
   &           sj(i, j, k, 2) + tauyz*sjd(i, j, k, 2) + tauzzd*sj(i, j, k, &
   &           3) + tauzz*sjd(i, j, k, 3)
   fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i&
   &           , j, k, 3)
   frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
   &           wbard*tauxz+wbar*tauxzd)*sj(i, j, k, 1) + (ubar*tauxx+vbar*&
   &           tauxy+wbar*tauxz)*sjd(i, j, k, 1) + (ubard*tauxy+ubar*tauxyd&
   &           +vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*sj(i, j, k&
   &           , 2) + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sjd(i, j, k, 2) + &
   &           (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd+wbard*tauzz&
   &           +wbar*tauzzd)*sj(i, j, k, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
   &           tauzz)*sjd(i, j, k, 3) - q_xd*sj(i, j, k, 1) - q_x*sjd(i, j&
   &           , k, 1) - q_yd*sj(i, j, k, 2) - q_y*sjd(i, j, k, 2) - q_zd*&
   &           sj(i, j, k, 3) - q_z*sjd(i, j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
   &           ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
   &           tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k&
   &           , 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
   ! Update the residuals of cell j and j+1.
   fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fmxd
   fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
   fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fmyd
   fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
   fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fmzd
   fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
   fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + frhoed
   fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface. Both the cases j == 1
   ! and j == jl must be tested.
   IF (j .EQ. 1 .AND. storewalltensor .AND. viscjminpointer(i, k)&
   &             .GT. 0) THEN
   ! We need to index viscSubface with viscJminPointer(i,k) 
   ! since Tapenade does not like temporary indexes 
   viscsubfaced(viscjminpointer(i, k))%tau(i, k, 1) = tauxxd
   viscsubface(viscjminpointer(i, k))%tau(i, k, 1) = tauxx
   viscsubfaced(viscjminpointer(i, k))%tau(i, k, 2) = tauyyd
   viscsubface(viscjminpointer(i, k))%tau(i, k, 2) = tauyy
   viscsubfaced(viscjminpointer(i, k))%tau(i, k, 3) = tauzzd
   viscsubface(viscjminpointer(i, k))%tau(i, k, 3) = tauzz
   viscsubfaced(viscjminpointer(i, k))%tau(i, k, 4) = tauxyd
   viscsubface(viscjminpointer(i, k))%tau(i, k, 4) = tauxy
   viscsubfaced(viscjminpointer(i, k))%tau(i, k, 5) = tauxzd
   viscsubface(viscjminpointer(i, k))%tau(i, k, 5) = tauxz
   viscsubfaced(viscjminpointer(i, k))%tau(i, k, 6) = tauyzd
   viscsubface(viscjminpointer(i, k))%tau(i, k, 6) = tauyz
   viscsubface(viscjminpointer(i, k))%q(i, k, 1) = q_x
   viscsubface(viscjminpointer(i, k))%q(i, k, 2) = q_y
   viscsubface(viscjminpointer(i, k))%q(i, k, 3) = q_z
   END IF
   ! And the j == jl case.
   IF (j .EQ. jl .AND. storewalltensor .AND. viscjmaxpointer(i, k&
   &             ) .GT. 0) THEN
   viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 1) = tauxxd
   viscsubface(viscjmaxpointer(i, k))%tau(i, k, 1) = tauxx
   viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 2) = tauyyd
   viscsubface(viscjmaxpointer(i, k))%tau(i, k, 2) = tauyy
   viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 3) = tauzzd
   viscsubface(viscjmaxpointer(i, k))%tau(i, k, 3) = tauzz
   viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 4) = tauxyd
   viscsubface(viscjmaxpointer(i, k))%tau(i, k, 4) = tauxy
   viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 5) = tauxzd
   viscsubface(viscjmaxpointer(i, k))%tau(i, k, 5) = tauxz
   viscsubfaced(viscjmaxpointer(i, k))%tau(i, k, 6) = tauyzd
   viscsubface(viscjmaxpointer(i, k))%tau(i, k, 6) = tauyz
   viscsubface(viscjmaxpointer(i, k))%q(i, k, 1) = q_x
   viscsubface(viscjmaxpointer(i, k))%q(i, k, 2) = q_y
   viscsubface(viscjmaxpointer(i, k))%q(i, k, 3) = q_z
   END IF
   END DO
   END DO
   END DO
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Viscous fluxes in the i-direction.                           *
   !        *                                                              *
   !        ****************************************************************
   !
   mue = zero
   mued = 0.0_8
   DO k=2,kl
   DO j=2,jl
   DO i=1,il
   ! Set the value of the porosity. If not zero, it is set
   ! to average the eddy-viscosity and to take the factor
   ! rFilv into account.
   por = half*rfilv
   IF (pori(i, j, k) .EQ. noflux) por = zero
   ! Compute the laminar and (if present) the eddy viscosities
   ! multiplied the porosity. Compute the factor in front of
   ! the gradients of the speed of sound squared for the heat
   ! flux.
   muld = por*(rlvd(i, j, k)+rlvd(i+1, j, k))
   mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
   IF (eddymodel) THEN
   mued = por*(revd(i, j, k)+revd(i+1, j, k))
   mue = por*(rev(i, j, k)+rev(i+1, j, k))
   END IF
   mutd = muld + mued
   mut = mul + mue
   gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
   factlamheat = one/(prandtl*gm1)
   factturbheat = one/(prandtlturb*gm1)
   heatcoefd = factlamheat*muld + factturbheat*mued
   heatcoef = mul*factlamheat + mue*factturbheat
   ! Compute the gradients at the face by averaging the four
   ! nodal values.
   u_xd = fourth*(uxd(i, j-1, k-1)+uxd(i, j, k-1)+uxd(i, j-1, k)+&
   &           uxd(i, j, k))
   u_x = fourth*(ux(i, j-1, k-1)+ux(i, j, k-1)+ux(i, j-1, k)+ux(i&
   &           , j, k))
   u_yd = fourth*(uyd(i, j-1, k-1)+uyd(i, j, k-1)+uyd(i, j-1, k)+&
   &           uyd(i, j, k))
   u_y = fourth*(uy(i, j-1, k-1)+uy(i, j, k-1)+uy(i, j-1, k)+uy(i&
   &           , j, k))
   u_zd = fourth*(uzd(i, j-1, k-1)+uzd(i, j, k-1)+uzd(i, j-1, k)+&
   &           uzd(i, j, k))
   u_z = fourth*(uz(i, j-1, k-1)+uz(i, j, k-1)+uz(i, j-1, k)+uz(i&
   &           , j, k))
   v_xd = fourth*(vxd(i, j-1, k-1)+vxd(i, j, k-1)+vxd(i, j-1, k)+&
   &           vxd(i, j, k))
   v_x = fourth*(vx(i, j-1, k-1)+vx(i, j, k-1)+vx(i, j-1, k)+vx(i&
   &           , j, k))
   v_yd = fourth*(vyd(i, j-1, k-1)+vyd(i, j, k-1)+vyd(i, j-1, k)+&
   &           vyd(i, j, k))
   v_y = fourth*(vy(i, j-1, k-1)+vy(i, j, k-1)+vy(i, j-1, k)+vy(i&
   &           , j, k))
   v_zd = fourth*(vzd(i, j-1, k-1)+vzd(i, j, k-1)+vzd(i, j-1, k)+&
   &           vzd(i, j, k))
   v_z = fourth*(vz(i, j-1, k-1)+vz(i, j, k-1)+vz(i, j-1, k)+vz(i&
   &           , j, k))
   w_xd = fourth*(wxd(i, j-1, k-1)+wxd(i, j, k-1)+wxd(i, j-1, k)+&
   &           wxd(i, j, k))
   w_x = fourth*(wx(i, j-1, k-1)+wx(i, j, k-1)+wx(i, j-1, k)+wx(i&
   &           , j, k))
   w_yd = fourth*(wyd(i, j-1, k-1)+wyd(i, j, k-1)+wyd(i, j-1, k)+&
   &           wyd(i, j, k))
   w_y = fourth*(wy(i, j-1, k-1)+wy(i, j, k-1)+wy(i, j-1, k)+wy(i&
   &           , j, k))
   w_zd = fourth*(wzd(i, j-1, k-1)+wzd(i, j, k-1)+wzd(i, j-1, k)+&
   &           wzd(i, j, k))
   w_z = fourth*(wz(i, j-1, k-1)+wz(i, j, k-1)+wz(i, j-1, k)+wz(i&
   &           , j, k))
   q_xd = fourth*(qxd(i, j-1, k-1)+qxd(i, j, k-1)+qxd(i, j-1, k)+&
   &           qxd(i, j, k))
   q_x = fourth*(qx(i, j-1, k-1)+qx(i, j, k-1)+qx(i, j-1, k)+qx(i&
   &           , j, k))
   q_yd = fourth*(qyd(i, j-1, k-1)+qyd(i, j, k-1)+qyd(i, j-1, k)+&
   &           qyd(i, j, k))
   q_y = fourth*(qy(i, j-1, k-1)+qy(i, j, k-1)+qy(i, j-1, k)+qy(i&
   &           , j, k))
   q_zd = fourth*(qzd(i, j-1, k-1)+qzd(i, j, k-1)+qzd(i, j-1, k)+&
   &           qzd(i, j, k))
   q_z = fourth*(qz(i, j-1, k-1)+qz(i, j, k-1)+qz(i, j-1, k)+qz(i&
   &           , j, k))
   ! The gradients in the normal direction are corrected, such
   ! that no averaging takes places here.
   ! First determine the vector in the direction from the
   ! cell center i to cell center i+1.
   ssxd = eighth*(xd(i+1, j-1, k-1, 1)-xd(i-1, j-1, k-1, 1)+xd(i+&
   &           1, j-1, k, 1)-xd(i-1, j-1, k, 1)+xd(i+1, j, k-1, 1)-xd(i-1, &
   &           j, k-1, 1)+xd(i+1, j, k, 1)-xd(i-1, j, k, 1))
   ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
   &           -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
   &           , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
   ssyd = eighth*(xd(i+1, j-1, k-1, 2)-xd(i-1, j-1, k-1, 2)+xd(i+&
   &           1, j-1, k, 2)-xd(i-1, j-1, k, 2)+xd(i+1, j, k-1, 2)-xd(i-1, &
   &           j, k-1, 2)+xd(i+1, j, k, 2)-xd(i-1, j, k, 2))
   ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
   &           -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
   &           , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
   sszd = eighth*(xd(i+1, j-1, k-1, 3)-xd(i-1, j-1, k-1, 3)+xd(i+&
   &           1, j-1, k, 3)-xd(i-1, j-1, k, 3)+xd(i+1, j, k-1, 3)-xd(i-1, &
   &           j, k-1, 3)+xd(i+1, j, k, 3)-xd(i-1, j, k, 3))
   ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
   &           -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
   &           , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
   ! Determine the length of this vector and create the
   ! unit normal.
   arg1d = ssxd*ssx + ssx*ssxd + ssyd*ssy + ssy*ssyd + sszd*ssz +&
   &           ssz*sszd
   arg1 = ssx*ssx + ssy*ssy + ssz*ssz
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   ssd = -(one*result1d/result1**2)
   ss = one/result1
   ssxd = ssd*ssx + ss*ssxd
   ssx = ss*ssx
   ssyd = ssd*ssy + ss*ssyd
   ssy = ss*ssy
   sszd = ssd*ssz + ss*sszd
   ssz = ss*ssz
   ! Correct the gradients.
   corrd = u_xd*ssx + u_x*ssxd + u_yd*ssy + u_y*ssyd + u_zd*ssz +&
   &           u_z*sszd - (wd(i+1, j, k, ivx)-wd(i, j, k, ivx))*ss - (w(i+1&
   &           , j, k, ivx)-w(i, j, k, ivx))*ssd
   corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j&
   &           , k, ivx))*ss
   u_xd = u_xd - corrd*ssx - corr*ssxd
   u_x = u_x - corr*ssx
   u_yd = u_yd - corrd*ssy - corr*ssyd
   u_y = u_y - corr*ssy
   u_zd = u_zd - corrd*ssz - corr*sszd
   u_z = u_z - corr*ssz
   corrd = v_xd*ssx + v_x*ssxd + v_yd*ssy + v_y*ssyd + v_zd*ssz +&
   &           v_z*sszd - (wd(i+1, j, k, ivy)-wd(i, j, k, ivy))*ss - (w(i+1&
   &           , j, k, ivy)-w(i, j, k, ivy))*ssd
   corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j&
   &           , k, ivy))*ss
   v_xd = v_xd - corrd*ssx - corr*ssxd
   v_x = v_x - corr*ssx
   v_yd = v_yd - corrd*ssy - corr*ssyd
   v_y = v_y - corr*ssy
   v_zd = v_zd - corrd*ssz - corr*sszd
   v_z = v_z - corr*ssz
   corrd = w_xd*ssx + w_x*ssxd + w_yd*ssy + w_y*ssyd + w_zd*ssz +&
   &           w_z*sszd - (wd(i+1, j, k, ivz)-wd(i, j, k, ivz))*ss - (w(i+1&
   &           , j, k, ivz)-w(i, j, k, ivz))*ssd
   corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j&
   &           , k, ivz))*ss
   w_xd = w_xd - corrd*ssx - corr*ssxd
   w_x = w_x - corr*ssx
   w_yd = w_yd - corrd*ssy - corr*ssyd
   w_y = w_y - corr*ssy
   w_zd = w_zd - corrd*ssz - corr*sszd
   w_z = w_z - corr*ssz
   corrd = q_xd*ssx + q_x*ssxd + q_yd*ssy + q_y*ssyd + q_zd*ssz +&
   &           q_z*sszd + (aad(i+1, j, k)-aad(i, j, k))*ss + (aa(i+1, j, k)&
   &           -aa(i, j, k))*ssd
   corr = q_x*ssx + q_y*ssy + q_z*ssz + (aa(i+1, j, k)-aa(i, j, k&
   &           ))*ss
   q_xd = q_xd - corrd*ssx - corr*ssxd
   q_x = q_x - corr*ssx
   q_yd = q_yd - corrd*ssy - corr*ssyd
   q_y = q_y - corr*ssy
   q_zd = q_zd - corrd*ssz - corr*sszd
   q_z = q_z - corr*ssz
   ! Compute the stress tensor and the heat flux vector.
   fracdivd = twothird*(u_xd+v_yd+w_zd)
   fracdiv = twothird*(u_x+v_y+w_z)
   tauxxd = mutd*(two*u_x-fracdiv) + mut*(two*u_xd-fracdivd)
   tauxx = mut*(two*u_x-fracdiv)
   tauyyd = mutd*(two*v_y-fracdiv) + mut*(two*v_yd-fracdivd)
   tauyy = mut*(two*v_y-fracdiv)
   tauzzd = mutd*(two*w_z-fracdiv) + mut*(two*w_zd-fracdivd)
   tauzz = mut*(two*w_z-fracdiv)
   tauxyd = mutd*(u_y+v_x) + mut*(u_yd+v_xd)
   tauxy = mut*(u_y+v_x)
   tauxzd = mutd*(u_z+w_x) + mut*(u_zd+w_xd)
   tauxz = mut*(u_z+w_x)
   tauyzd = mutd*(v_z+w_y) + mut*(v_zd+w_yd)
   tauyz = mut*(v_z+w_y)
   q_xd = heatcoefd*q_x + heatcoef*q_xd
   q_x = heatcoef*q_x
   q_yd = heatcoefd*q_y + heatcoef*q_yd
   q_y = heatcoef*q_y
   q_zd = heatcoefd*q_z + heatcoef*q_zd
   q_z = heatcoef*q_z
   ! Compute the average velocities for the face. Remember that
   ! the velocities are stored and not the momentum.
   ubard = half*(wd(i, j, k, ivx)+wd(i+1, j, k, ivx))
   ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
   vbard = half*(wd(i, j, k, ivy)+wd(i+1, j, k, ivy))
   vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
   wbard = half*(wd(i, j, k, ivz)+wd(i+1, j, k, ivz))
   wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
   ! Compute the viscous fluxes for this i-face.
   fmxd = tauxxd*si(i, j, k, 1) + tauxx*sid(i, j, k, 1) + tauxyd*&
   &           si(i, j, k, 2) + tauxy*sid(i, j, k, 2) + tauxzd*si(i, j, k, &
   &           3) + tauxz*sid(i, j, k, 3)
   fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i&
   &           , j, k, 3)
   fmyd = tauxyd*si(i, j, k, 1) + tauxy*sid(i, j, k, 1) + tauyyd*&
   &           si(i, j, k, 2) + tauyy*sid(i, j, k, 2) + tauyzd*si(i, j, k, &
   &           3) + tauyz*sid(i, j, k, 3)
   fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i&
   &           , j, k, 3)
   fmzd = tauxzd*si(i, j, k, 1) + tauxz*sid(i, j, k, 1) + tauyzd*&
   &           si(i, j, k, 2) + tauyz*sid(i, j, k, 2) + tauzzd*si(i, j, k, &
   &           3) + tauzz*sid(i, j, k, 3)
   fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i&
   &           , j, k, 3)
   frhoed = (ubard*tauxx+ubar*tauxxd+vbard*tauxy+vbar*tauxyd+&
   &           wbard*tauxz+wbar*tauxzd)*si(i, j, k, 1) + (ubar*tauxx+vbar*&
   &           tauxy+wbar*tauxz)*sid(i, j, k, 1) + (ubard*tauxy+ubar*tauxyd&
   &           +vbard*tauyy+vbar*tauyyd+wbard*tauyz+wbar*tauyzd)*si(i, j, k&
   &           , 2) + (ubar*tauxy+vbar*tauyy+wbar*tauyz)*sid(i, j, k, 2) + &
   &           (ubard*tauxz+ubar*tauxzd+vbard*tauyz+vbar*tauyzd+wbard*tauzz&
   &           +wbar*tauzzd)*si(i, j, k, 3) + (ubar*tauxz+vbar*tauyz+wbar*&
   &           tauzz)*sid(i, j, k, 3) - q_xd*si(i, j, k, 1) - q_x*sid(i, j&
   &           , k, 1) - q_yd*si(i, j, k, 2) - q_y*sid(i, j, k, 2) - q_zd*&
   &           si(i, j, k, 3) - q_z*sid(i, j, k, 3)
   frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
   &           ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
   &           tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k&
   &           , 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
   ! Update the residuals of cell i and i+1.
   fwd(i, j, k, imx) = fwd(i, j, k, imx) - fmxd
   fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
   fwd(i, j, k, imy) = fwd(i, j, k, imy) - fmyd
   fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
   fwd(i, j, k, imz) = fwd(i, j, k, imz) - fmzd
   fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - frhoed
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
   fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fmxd
   fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
   fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fmyd
   fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
   fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fmzd
   fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
   fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + frhoed
   fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
   ! Store the stress tensor and the heat flux vector if this
   ! face is part of a viscous subface. Both the cases i == 1
   ! and i == il must be tested.
   IF (i .EQ. 1 .AND. storewalltensor .AND. visciminpointer(j, k)&
   &             .GT. 0) THEN
   ! We need to index viscSubface with viscIminPointer(j,k) 
   ! since Tapenade does not like temporary indexes 
   viscsubfaced(visciminpointer(j, k))%tau(j, k, 1) = tauxxd
   viscsubface(visciminpointer(j, k))%tau(j, k, 1) = tauxx
   viscsubfaced(visciminpointer(j, k))%tau(j, k, 2) = tauyyd
   viscsubface(visciminpointer(j, k))%tau(j, k, 2) = tauyy
   viscsubfaced(visciminpointer(j, k))%tau(j, k, 3) = tauzzd
   viscsubface(visciminpointer(j, k))%tau(j, k, 3) = tauzz
   viscsubfaced(visciminpointer(j, k))%tau(j, k, 4) = tauxyd
   viscsubface(visciminpointer(j, k))%tau(j, k, 4) = tauxy
   viscsubfaced(visciminpointer(j, k))%tau(j, k, 5) = tauxzd
   viscsubface(visciminpointer(j, k))%tau(j, k, 5) = tauxz
   viscsubfaced(visciminpointer(j, k))%tau(j, k, 6) = tauyzd
   viscsubface(visciminpointer(j, k))%tau(j, k, 6) = tauyz
   viscsubface(visciminpointer(j, k))%q(j, k, 1) = q_x
   viscsubface(visciminpointer(j, k))%q(j, k, 2) = q_y
   viscsubface(visciminpointer(j, k))%q(j, k, 3) = q_z
   END IF
   ! And the i == il case.
   IF (i .EQ. il .AND. storewalltensor .AND. viscimaxpointer(j, k&
   &             ) .GT. 0) THEN
   ! We need to index viscSubface with viscImaxPointer(j,k) 
   ! since Tapenade does not like temporary indexes 
   viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 1) = tauxxd
   viscsubface(viscimaxpointer(j, k))%tau(j, k, 1) = tauxx
   viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 2) = tauyyd
   viscsubface(viscimaxpointer(j, k))%tau(j, k, 2) = tauyy
   viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 3) = tauzzd
   viscsubface(viscimaxpointer(j, k))%tau(j, k, 3) = tauzz
   viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 4) = tauxyd
   viscsubface(viscimaxpointer(j, k))%tau(j, k, 4) = tauxy
   viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 5) = tauxzd
   viscsubface(viscimaxpointer(j, k))%tau(j, k, 5) = tauxz
   viscsubfaced(viscimaxpointer(j, k))%tau(j, k, 6) = tauyzd
   viscsubface(viscimaxpointer(j, k))%tau(j, k, 6) = tauyz
   viscsubface(viscimaxpointer(j, k))%q(j, k, 1) = q_x
   viscsubface(viscimaxpointer(j, k))%q(j, k, 2) = q_y
   viscsubface(viscimaxpointer(j, k))%q(j, k, 3) = q_z
   END IF
   END DO
   END DO
   END DO
   END IF
   END SUBROUTINE VISCOUSFLUX_D

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of turbbcnswall in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *rev *bvtj1 *bvtj2 *w *bvtk1
   !                *bvtk2 *bvti1 *bvti2
   !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *w *rlv
   !                *bvtk1 *bvtk2 *bvti1 *bvti2
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
   !                rlv:in bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          turbBCNSWall.f90                                *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 05-30-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE TURBBCNSWALL_D(secondhalo)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * turbBCNSWall applies the viscous wall boundary conditions      *
   !      * of the turbulent transport equations to a block. It is assumed *
   !      * that the pointers in blockPointers are already set to the      *
   !      * correct block on the correct grid level.                       *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BCTYPES
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   !
   !      Subroutine argument.
   !
   LOGICAL, INTENT(IN) :: secondhalo
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j, l, m
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Loop over the viscous subfaces of this block.
   bocos:DO nn=1,nviscbocos
   ! Set the corresponding arrays.
   CALL BCTURBWALL_D(nn)
   ! Loop over the faces and set the state in
   ! the turbulent halo cells.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   DO l=nt1,nt2
   wd(1, i, j, l) = bvti1d(i, j, l)
   w(1, i, j, l) = bvti1(i, j, l)
   DO m=nt1,nt2
   wd(1, i, j, l) = wd(1, i, j, l) - bmti1(i, j, l, m)*wd(2, &
   &               i, j, m)
   w(1, i, j, l) = w(1, i, j, l) - bmti1(i, j, l, m)*w(2, i, &
   &               j, m)
   END DO
   IF (secondhalo) THEN
   wd(0, i, j, l) = wd(1, i, j, l)
   w(0, i, j, l) = w(1, i, j, l)
   END IF
   END DO
   IF (eddymodel) THEN
   revd(1, i, j) = -revd(2, i, j)
   rev(1, i, j) = -rev(2, i, j)
   IF (secondhalo) THEN
   revd(0, i, j) = revd(1, i, j)
   rev(0, i, j) = rev(1, i, j)
   END IF
   END IF
   END DO
   END DO
   CASE (imax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   DO l=nt1,nt2
   wd(ie, i, j, l) = bvti2d(i, j, l)
   w(ie, i, j, l) = bvti2(i, j, l)
   DO m=nt1,nt2
   wd(ie, i, j, l) = wd(ie, i, j, l) - bmti2(i, j, l, m)*wd(&
   &               il, i, j, m)
   w(ie, i, j, l) = w(ie, i, j, l) - bmti2(i, j, l, m)*w(il, &
   &               i, j, m)
   END DO
   IF (secondhalo) THEN
   wd(ib, i, j, l) = wd(ie, i, j, l)
   w(ib, i, j, l) = w(ie, i, j, l)
   END IF
   END DO
   IF (eddymodel) THEN
   revd(ie, i, j) = -revd(il, i, j)
   rev(ie, i, j) = -rev(il, i, j)
   IF (secondhalo) THEN
   revd(ib, i, j) = revd(ie, i, j)
   rev(ib, i, j) = rev(ie, i, j)
   END IF
   END IF
   END DO
   END DO
   CASE (jmin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   DO l=nt1,nt2
   wd(i, 1, j, l) = bvtj1d(i, j, l)
   w(i, 1, j, l) = bvtj1(i, j, l)
   DO m=nt1,nt2
   wd(i, 1, j, l) = wd(i, 1, j, l) - bmtj1(i, j, l, m)*wd(i, &
   &               2, j, m)
   w(i, 1, j, l) = w(i, 1, j, l) - bmtj1(i, j, l, m)*w(i, 2, &
   &               j, m)
   END DO
   IF (secondhalo) THEN
   wd(i, 0, j, l) = wd(i, 1, j, l)
   w(i, 0, j, l) = w(i, 1, j, l)
   END IF
   END DO
   IF (eddymodel) THEN
   revd(i, 1, j) = -revd(i, 2, j)
   rev(i, 1, j) = -rev(i, 2, j)
   IF (secondhalo) THEN
   revd(i, 0, j) = revd(i, 1, j)
   rev(i, 0, j) = rev(i, 1, j)
   END IF
   END IF
   END DO
   END DO
   CASE (jmax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   DO l=nt1,nt2
   wd(i, je, j, l) = bvtj2d(i, j, l)
   w(i, je, j, l) = bvtj2(i, j, l)
   DO m=nt1,nt2
   wd(i, je, j, l) = wd(i, je, j, l) - bmtj2(i, j, l, m)*wd(i&
   &               , jl, j, m)
   w(i, je, j, l) = w(i, je, j, l) - bmtj2(i, j, l, m)*w(i, &
   &               jl, j, m)
   END DO
   IF (secondhalo) THEN
   wd(i, jb, j, l) = wd(i, je, j, l)
   w(i, jb, j, l) = w(i, je, j, l)
   END IF
   END DO
   IF (eddymodel) THEN
   revd(i, je, j) = -revd(i, jl, j)
   rev(i, je, j) = -rev(i, jl, j)
   IF (secondhalo) THEN
   revd(i, jb, j) = revd(i, je, j)
   rev(i, jb, j) = rev(i, je, j)
   END IF
   END IF
   END DO
   END DO
   CASE (kmin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   DO l=nt1,nt2
   wd(i, j, 1, l) = bvtk1d(i, j, l)
   w(i, j, 1, l) = bvtk1(i, j, l)
   DO m=nt1,nt2
   wd(i, j, 1, l) = wd(i, j, 1, l) - bmtk1(i, j, l, m)*wd(i, &
   &               j, 2, m)
   w(i, j, 1, l) = w(i, j, 1, l) - bmtk1(i, j, l, m)*w(i, j, &
   &               2, m)
   END DO
   IF (secondhalo) THEN
   wd(i, j, 0, l) = wd(i, j, 1, l)
   w(i, j, 0, l) = w(i, j, 1, l)
   END IF
   END DO
   IF (eddymodel) THEN
   revd(i, j, 1) = -revd(i, j, 2)
   rev(i, j, 1) = -rev(i, j, 2)
   IF (secondhalo) THEN
   revd(i, j, 0) = revd(i, j, 1)
   rev(i, j, 0) = rev(i, j, 1)
   END IF
   END IF
   END DO
   END DO
   CASE (kmax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   DO l=nt1,nt2
   wd(i, j, ke, l) = bvtk2d(i, j, l)
   w(i, j, ke, l) = bvtk2(i, j, l)
   DO m=nt1,nt2
   wd(i, j, ke, l) = wd(i, j, ke, l) - bmtk2(i, j, l, m)*wd(i&
   &               , j, kl, m)
   w(i, j, ke, l) = w(i, j, ke, l) - bmtk2(i, j, l, m)*w(i, j&
   &               , kl, m)
   END DO
   IF (secondhalo) THEN
   wd(i, j, kb, l) = wd(i, j, ke, l)
   w(i, j, kb, l) = w(i, j, ke, l)
   END IF
   END DO
   IF (eddymodel) THEN
   revd(i, j, ke) = -revd(i, j, kl)
   rev(i, j, ke) = -rev(i, j, kl)
   IF (secondhalo) THEN
   revd(i, j, kb) = revd(i, j, ke)
   rev(i, j, kb) = rev(i, j, ke)
   END IF
   END IF
   END DO
   END DO
   END SELECT
   END DO bocos
   END SUBROUTINE TURBBCNSWALL_D

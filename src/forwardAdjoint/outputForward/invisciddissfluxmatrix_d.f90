!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of invisciddissfluxmatrix in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *fw
!   with respect to varying inputs: pinfcorr *p *sfacei *sfacej
!                *sfacek *w *si *sj *sk
!   plus diff mem management of: p:in sfacei:in sfacej:in sfacek:in
!                w:in si:in sj:in sk:in fw:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          invisciddissfluxmatrix.f90                      *
!      * author:        edwin van der weide                             *
!      * starting date: 03-25-2003                                      *
!      * last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine invisciddissfluxmatrix_d()
!
!      ******************************************************************
!      *                                                                *
!      * invisciddissfluxmatrix computes the matrix artificial          *
!      * dissipation term. instead of the spectral radius, as used in   *
!      * the scalar dissipation scheme, the absolute value of the flux  *
!      * jacobian is used. this leads to a less diffusive and           *
!      * consequently more accurate scheme. it is assumed that the      *
!      * pointers in blockpointers already point to the correct block.  *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use cgnsgrid
  use constants
  use flowvarrefstate
  use inputdiscretization
  use inputphysics
  use iteration
  implicit none
!
!      local parameters.
!
  real(kind=realtype), parameter :: dpmax=0.25_realtype
  real(kind=realtype), parameter :: epsacoustic=0.25_realtype
  real(kind=realtype), parameter :: epsshear=0.025_realtype
  real(kind=realtype), parameter :: omega=0.5_realtype
  real(kind=realtype), parameter :: oneminomega=one-omega
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ind
  real(kind=realtype) :: plim, sface
  real(kind=realtype) :: plimd, sfaced
  real(kind=realtype) :: sfil, fis2, fis4
  real(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
  real(kind=realtype) :: ppor, rrad, dis2, dis4
  real(kind=realtype) :: rradd, dis2d, dis4d
  real(kind=realtype) :: dp1, dp2, ddw, tmp, fs
  real(kind=realtype) :: dp1d, dp2d, ddwd, tmpd, fsd
  real(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
  real(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd, sxd, syd, &
& szd
  real(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
  real(kind=realtype) :: uavgd, vavgd, wavgd, a2avgd, aavgd, havgd
  real(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
  real(kind=realtype) :: alphaavgd, unavgd, ovaavgd, ova2avgd
  real(kind=realtype) :: kavg, lam1, lam2, lam3, area
  real(kind=realtype) :: kavgd, lam1d, lam2d, lam3d, aread
  real(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
  real(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, abv7d
  logical :: correctfork
  intrinsic abs
  intrinsic max
  intrinsic min
  real(kind=realtype) :: dim
  real(kind=realtype) :: dim_d
  intrinsic sqrt
  real(kind=realtype) :: arg1
  real(kind=realtype) :: arg1d
  real(kind=realtype) :: min5d
  real(kind=realtype) :: x6d
  real(kind=realtype) :: y4d
  real(kind=realtype) :: abs1d
  real(kind=realtype) :: min6
  real(kind=realtype) :: min5
  real(kind=realtype) :: min4
  real(kind=realtype) :: max2d
  real(kind=realtype) :: min3
  real(kind=realtype) :: min2
  real(kind=realtype) :: min1
  real(kind=realtype) :: abs4d
  real(kind=realtype) :: abs11d
  real(kind=realtype) :: abs7d
  real(kind=realtype) :: x6
  real(kind=realtype) :: x5
  real(kind=realtype) :: min1d
  real(kind=realtype) :: x4
  real(kind=realtype) :: x3
  real(kind=realtype) :: x2
  real(kind=realtype) :: x2d
  real(kind=realtype) :: x1
  real(kind=realtype) :: min4d
  real(kind=realtype) :: x5d
  real(kind=realtype) :: y3d
  real(kind=realtype) :: max1d
  real(kind=realtype) :: y6d
  real(kind=realtype) :: abs3d
  real(kind=realtype) :: abs10d
  real(kind=realtype) :: abs6d
  real(kind=realtype) :: abs12
  real(kind=realtype) :: x1d
  real(kind=realtype) :: abs11
  real(kind=realtype) :: abs10
  real(kind=realtype) :: abs9d
  real(kind=realtype) :: min3d
  real(kind=realtype) :: x4d
  real(kind=realtype) :: y2d
  real(kind=realtype) :: min6d
  real(kind=realtype) :: abs9
  real(kind=realtype) :: abs8
  real(kind=realtype) :: abs7
  real(kind=realtype) :: abs6
  real(kind=realtype) :: y5d
  real(kind=realtype) :: abs5
  real(kind=realtype) :: abs4
  real(kind=realtype) :: abs3
  real(kind=realtype) :: abs2
  real(kind=realtype) :: abs2d
  real(kind=realtype) :: abs1
  real(kind=realtype) :: abs0
  real(kind=realtype) :: max3d
  real(kind=realtype) :: abs5d
  real(kind=realtype) :: abs12d
  real(kind=realtype) :: max3
  real(kind=realtype) :: max2
  real(kind=realtype) :: abs8d
  real(kind=realtype) :: y6
  real(kind=realtype) :: max1
  real(kind=realtype) :: y5
  real(kind=realtype) :: min2d
  real(kind=realtype) :: y4
  real(kind=realtype) :: y3
  real(kind=realtype) :: y2
  real(kind=realtype) :: x3d
  real(kind=realtype) :: y1
  real(kind=realtype) :: y1d
  if (rfil .ge. 0.) then
    abs0 = rfil
  else
    abs0 = -rfil
  end if
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! check if rfil == 0. if so, the dissipative flux needs not to
! be computed.
  if (abs0 .lt. thresholdreal) then
    fwd = 0.0_8
    return
  else
! set the value of plim. to be fully consistent this must have
! the dimension of a pressure. therefore a fraction of pinfcorr
! is used.
    plimd = 0.001_realtype*pinfcorrd
    plim = 0.001_realtype*pinfcorr
! determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    if (kpresent) then
      if (currentlevel .eq. groundlevel .or. turbcoupled) then
        correctfork = .true.
      else
        correctfork = .false.
      end if
    else
      correctfork = .false.
    end if
! initialize sface to zero. this value will be used if the
! block is not moving.
    sface = zero
! set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
    sfil = one - rfil
! initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. owned cells
! only, because the halo values do not matter.
    do k=2,kl
      do j=2,jl
        do i=2,il
          fwd(i, j, k, irho) = 0.0_8
          fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
          fwd(i, j, k, imx) = 0.0_8
          fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
          fwd(i, j, k, imy) = 0.0_8
          fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
          fwd(i, j, k, imz) = 0.0_8
          fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
          fwd(i, j, k, irhoe) = 0.0_8
          fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
        end do
      end do
    end do
    fwd = 0.0_8
    sfaced = 0.0_8
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the i-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do j=2,jl
        if (p(2, j, k) - p(1, j, k) .ge. 0.) then
          abs1d = pd(2, j, k) - pd(1, j, k)
          abs1 = p(2, j, k) - p(1, j, k)
        else
          abs1d = -(pd(2, j, k)-pd(1, j, k))
          abs1 = -(p(2, j, k)-p(1, j, k))
        end if
        if (p(1, j, k) - p(0, j, k) .ge. 0.) then
          abs7d = pd(1, j, k) - pd(0, j, k)
          abs7 = p(1, j, k) - p(0, j, k)
        else
          abs7d = -(pd(1, j, k)-pd(0, j, k))
          abs7 = -(p(1, j, k)-p(0, j, k))
        end if
        x1d = ((pd(2, j, k)-two*pd(1, j, k)+pd(0, j, k))*(omega*(p(2, j&
&         , k)+two*p(1, j, k)+p(0, j, k))+oneminomega*(abs1+abs7)+plim)-&
&         (p(2, j, k)-two*p(1, j, k)+p(0, j, k))*(omega*(pd(2, j, k)+two&
&         *pd(1, j, k)+pd(0, j, k))+oneminomega*(abs1d+abs7d)+plimd))/(&
&         omega*(p(2, j, k)+two*p(1, j, k)+p(0, j, k))+oneminomega*(abs1&
&         +abs7)+plim)**2
        x1 = (p(2, j, k)-two*p(1, j, k)+p(0, j, k))/(omega*(p(2, j, k)+&
&         two*p(1, j, k)+p(0, j, k))+oneminomega*(abs1+abs7)+plim)
        if (x1 .ge. 0.) then
          dp1d = x1d
          dp1 = x1
        else
          dp1d = -x1d
          dp1 = -x1
        end if
! loop in i-direction.
        do i=1,il
          if (p(i+2, j, k) - p(i+1, j, k) .ge. 0.) then
            abs2d = pd(i+2, j, k) - pd(i+1, j, k)
            abs2 = p(i+2, j, k) - p(i+1, j, k)
          else
            abs2d = -(pd(i+2, j, k)-pd(i+1, j, k))
            abs2 = -(p(i+2, j, k)-p(i+1, j, k))
          end if
          if (p(i+1, j, k) - p(i, j, k) .ge. 0.) then
            abs8d = pd(i+1, j, k) - pd(i, j, k)
            abs8 = p(i+1, j, k) - p(i, j, k)
          else
            abs8d = -(pd(i+1, j, k)-pd(i, j, k))
            abs8 = -(p(i+1, j, k)-p(i, j, k))
          end if
          x2d = ((pd(i+2, j, k)-two*pd(i+1, j, k)+pd(i, j, k))*(omega*(p&
&           (i+2, j, k)+two*p(i+1, j, k)+p(i, j, k))+oneminomega*(abs2+&
&           abs8)+plim)-(p(i+2, j, k)-two*p(i+1, j, k)+p(i, j, k))*(&
&           omega*(pd(i+2, j, k)+two*pd(i+1, j, k)+pd(i, j, k))+&
&           oneminomega*(abs2d+abs8d)+plimd))/(omega*(p(i+2, j, k)+two*p&
&           (i+1, j, k)+p(i, j, k))+oneminomega*(abs2+abs8)+plim)**2
          x2 = (p(i+2, j, k)-two*p(i+1, j, k)+p(i, j, k))/(omega*(p(i+2&
&           , j, k)+two*p(i+1, j, k)+p(i, j, k))+oneminomega*(abs2+abs8)&
&           +plim)
          if (x2 .ge. 0.) then
            dp2d = x2d
            dp2 = x2
          else
            dp2d = -x2d
            dp2 = -x2
          end if
! compute the dissipation coefficients for this face.
          ppor = zero
          if (pori(i, j, k) .eq. normalflux) ppor = one
          if (lumpeddiss) then
            if (dp1 .lt. dp2) then
              y1d = dp2d
              y1 = dp2
            else
              y1d = dp1d
              y1 = dp1
            end if
            if (dpmax .gt. y1) then
              min1d = y1d
              min1 = y1
            else
              min1 = dpmax
              min1d = 0.0_8
            end if
            dis2d = fis2*ppor*min1d
            dis2 = fis2*ppor*min1 + sigma*fis4*ppor
            dis4 = 0.0
            dis4d = 0.0_8
          else
            if (dp1 .lt. dp2) then
              y2d = dp2d
              y2 = dp2
            else
              y2d = dp1d
              y2 = dp1
            end if
            if (dpmax .gt. y2) then
              min2d = y2d
              min2 = y2
            else
              min2 = dpmax
              min2d = 0.0_8
            end if
            dis2d = ppor*fis2*min2d
            dis2 = ppor*fis2*min2
            dis4d = dim_d(ppor*fis4, 0.0_8, dis2, dis2d, dis4)
          end if
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          ddwd = wd(i+1, j, k, irho) - wd(i, j, k, irho)
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          drd = dis2d*ddw + dis2*ddwd - dis4d*(w(i+2, j, k, irho)-w(i-1&
&           , j, k, irho)-three*ddw) - dis4*(wd(i+2, j, k, irho)-wd(i-1&
&           , j, k, irho)-three*ddwd)
          dr = dis2*ddw - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-&
&           three*ddw)
          ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, ivx) + w(i+1, j, k, &
&           irho)*wd(i+1, j, k, ivx) - wd(i, j, k, irho)*w(i, j, k, ivx)&
&           - w(i, j, k, irho)*wd(i, j, k, ivx)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          drud = dis2d*ddw + dis2*ddwd - dis4d*(w(i+2, j, k, irho)*w(i+2&
&           , j, k, ivx)-w(i-1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw)&
&           - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, ivx)+w(i+2, j, k, &
&           irho)*wd(i+2, j, k, ivx)-wd(i-1, j, k, irho)*w(i-1, j, k, &
&           ivx)-w(i-1, j, k, irho)*wd(i-1, j, k, ivx)-three*ddwd)
          dru = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(&
&           i-1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw)
          ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, ivy) + w(i+1, j, k, &
&           irho)*wd(i+1, j, k, ivy) - wd(i, j, k, irho)*w(i, j, k, ivy)&
&           - w(i, j, k, irho)*wd(i, j, k, ivy)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          drvd = dis2d*ddw + dis2*ddwd - dis4d*(w(i+2, j, k, irho)*w(i+2&
&           , j, k, ivy)-w(i-1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw)&
&           - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, ivy)+w(i+2, j, k, &
&           irho)*wd(i+2, j, k, ivy)-wd(i-1, j, k, irho)*w(i-1, j, k, &
&           ivy)-w(i-1, j, k, irho)*wd(i-1, j, k, ivy)-three*ddwd)
          drv = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(&
&           i-1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw)
          ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, ivz) + w(i+1, j, k, &
&           irho)*wd(i+1, j, k, ivz) - wd(i, j, k, irho)*w(i, j, k, ivz)&
&           - w(i, j, k, irho)*wd(i, j, k, ivz)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          drwd = dis2d*ddw + dis2*ddwd - dis4d*(w(i+2, j, k, irho)*w(i+2&
&           , j, k, ivz)-w(i-1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw)&
&           - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, ivz)+w(i+2, j, k, &
&           irho)*wd(i+2, j, k, ivz)-wd(i-1, j, k, irho)*w(i-1, j, k, &
&           ivz)-w(i-1, j, k, irho)*wd(i-1, j, k, ivz)-three*ddwd)
          drw = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(&
&           i-1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw)
          ddwd = wd(i+1, j, k, irhoe) - wd(i, j, k, irhoe)
          ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          dred = dis2d*ddw + dis2*ddwd - dis4d*(w(i+2, j, k, irhoe)-w(i-&
&           1, j, k, irhoe)-three*ddw) - dis4*(wd(i+2, j, k, irhoe)-wd(i&
&           -1, j, k, irhoe)-three*ddwd)
          dre = dis2*ddw - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)&
&           -three*ddw)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddwd = wd(i+1, j, k, irho)*w(i+1, j, k, itu1) + w(i+1, j, k&
&             , irho)*wd(i+1, j, k, itu1) - wd(i, j, k, irho)*w(i, j, k&
&             , itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drkd = dis2d*ddw + dis2*ddwd - dis4d*(w(i+2, j, k, irho)*w(i&
&             +2, j, k, itu1)-w(i-1, j, k, irho)*w(i-1, j, k, itu1)-&
&             three*ddw) - dis4*(wd(i+2, j, k, irho)*w(i+2, j, k, itu1)+&
&             w(i+2, j, k, irho)*wd(i+2, j, k, itu1)-wd(i-1, j, k, irho)&
&             *w(i-1, j, k, itu1)-w(i-1, j, k, irho)*wd(i-1, j, k, itu1)&
&             -three*ddwd)
            drk = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)&
&             -w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw)
            kavgd = half*(wd(i, j, k, itu1)+wd(i+1, j, k, itu1))
            kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
          else
            drk = zero
            kavg = zero
            kavgd = 0.0_8
            drkd = 0.0_8
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavgd = half*(wd(i+1, j, k, ivx)+wd(i, j, k, ivx))
          uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
          vavgd = half*(wd(i+1, j, k, ivy)+wd(i, j, k, ivy))
          vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
          wavgd = half*(wd(i+1, j, k, ivz)+wd(i, j, k, ivz))
          wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
          a2avgd = half*((gamma(i+1, j, k)*pd(i+1, j, k)*w(i+1, j, k, &
&           irho)-gamma(i+1, j, k)*p(i+1, j, k)*wd(i+1, j, k, irho))/w(i&
&           +1, j, k, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k, &
&           irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, j, k&
&           , irho)**2)
          a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          sxd = sid(i, j, k, 1)
          sx = si(i, j, k, 1)
          syd = sid(i, j, k, 2)
          sy = si(i, j, k, 2)
          szd = sid(i, j, k, 3)
          sz = si(i, j, k, 3)
          arg1d = 2*sx*sxd + 2*sy*syd + 2*sz*szd
          arg1 = sx**2 + sy**2 + sz**2
          if (arg1 .eq. 0.0_8) then
            aread = 0.0_8
          else
            aread = arg1d/(2.0*sqrt(arg1))
          end if
          area = sqrt(arg1)
          if (1.e-25_realtype .lt. area) then
            max1d = aread
            max1 = area
          else
            max1 = 1.e-25_realtype
            max1d = 0.0_8
          end if
          tmpd = -(one*max1d/max1**2)
          tmp = one/max1
          sxd = sxd*tmp + sx*tmpd
          sx = sx*tmp
          syd = syd*tmp + sy*tmpd
          sy = sy*tmp
          szd = szd*tmp + sz*tmpd
          sz = sz*tmp
          alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          if (a2avg .eq. 0.0_8) then
            aavgd = 0.0_8
          else
            aavgd = a2avgd/(2.0*sqrt(a2avg))
          end if
          aavg = sqrt(a2avg)
          unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*sz &
&           + wavg*szd
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavgd = -(one*aavgd/aavg**2)
          ovaavg = one/aavg
          ova2avgd = -(one*a2avgd/a2avg**2)
          ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sfaced = sfaceid(i, j, k)*tmp + sfacei(i, j, k)*tmpd
            sface = sfacei(i, j, k)*tmp
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1d = unavgd - sfaced + aavgd
            lam1 = unavg - sface + aavg
          else
            lam1d = -(unavgd-sfaced+aavgd)
            lam1 = -(unavg-sface+aavg)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2d = unavgd - sfaced - aavgd
            lam2 = unavg - sface - aavg
          else
            lam2d = -(unavgd-sfaced-aavgd)
            lam2 = -(unavg-sface-aavg)
          end if
          if (unavg - sface .ge. 0.) then
            lam3d = unavgd - sfaced
            lam3 = unavg - sface
          else
            lam3d = -(unavgd-sfaced)
            lam3 = -(unavg-sface)
          end if
          rradd = lam3d + aavgd
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1d = epsacoustic*rradd
            lam1 = epsacoustic*rrad
          else
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2d = epsacoustic*rradd
            lam2 = epsacoustic*rrad
          else
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3d = epsshear*rradd
            lam3 = epsshear*rrad
          else
            lam3 = lam3
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1d = lam1d*area + lam1*aread
          lam1 = lam1*area
          lam2d = lam2d*area + lam2*aread
          lam2 = lam2*area
          lam3d = lam3d*area + lam3*aread
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1d = half*(lam1d+lam2d)
          abv1 = half*(lam1+lam2)
          abv2d = half*(lam1d-lam2d)
          abv2 = half*(lam1-lam2)
          abv3d = abv1d - lam3d
          abv3 = abv1 - lam3
          abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&           vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz*&
&           drwd - unavgd*dr - unavg*drd
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd +&
&           (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd + &
&           abv3d*abv5 + abv3*abv5d
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
          fsd = lam3d*dr + lam3*drd + abv6d
          fs = lam3*dr + abv6
          fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) + fsd
          fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
          fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
          fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sxd*&
&           abv7 + sx*abv7d
          fs = lam3*dru + uavg*abv6 + sx*abv7
          fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) + fsd
          fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
          fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + syd*&
&           abv7 + sy*abv7d
          fs = lam3*drv + vavg*abv6 + sy*abv7
          fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) + fsd
          fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
          fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + szd*&
&           abv7 + sz*abv7d
          fs = lam3*drw + wavg*abv6 + sz*abv7
          fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) + fsd
          fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
          fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + unavgd&
&           *abv7 + unavg*abv7d
          fs = lam3*dre + havg*abv6 + unavg*abv7
          fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) + fsd
          fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
          dp1d = dp2d
          dp1 = dp2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the j-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do k=2,kl
      do i=2,il
        if (p(i, 2, k) - p(i, 1, k) .ge. 0.) then
          abs3d = pd(i, 2, k) - pd(i, 1, k)
          abs3 = p(i, 2, k) - p(i, 1, k)
        else
          abs3d = -(pd(i, 2, k)-pd(i, 1, k))
          abs3 = -(p(i, 2, k)-p(i, 1, k))
        end if
        if (p(i, 1, k) - p(i, 0, k) .ge. 0.) then
          abs9d = pd(i, 1, k) - pd(i, 0, k)
          abs9 = p(i, 1, k) - p(i, 0, k)
        else
          abs9d = -(pd(i, 1, k)-pd(i, 0, k))
          abs9 = -(p(i, 1, k)-p(i, 0, k))
        end if
        x3d = ((pd(i, 2, k)-two*pd(i, 1, k)+pd(i, 0, k))*(omega*(p(i, 2&
&         , k)+two*p(i, 1, k)+p(i, 0, k))+oneminomega*(abs3+abs9)+plim)-&
&         (p(i, 2, k)-two*p(i, 1, k)+p(i, 0, k))*(omega*(pd(i, 2, k)+two&
&         *pd(i, 1, k)+pd(i, 0, k))+oneminomega*(abs3d+abs9d)+plimd))/(&
&         omega*(p(i, 2, k)+two*p(i, 1, k)+p(i, 0, k))+oneminomega*(abs3&
&         +abs9)+plim)**2
        x3 = (p(i, 2, k)-two*p(i, 1, k)+p(i, 0, k))/(omega*(p(i, 2, k)+&
&         two*p(i, 1, k)+p(i, 0, k))+oneminomega*(abs3+abs9)+plim)
        if (x3 .ge. 0.) then
          dp1d = x3d
          dp1 = x3
        else
          dp1d = -x3d
          dp1 = -x3
        end if
! loop in j-direction.
        do j=1,jl
          if (p(i, j+2, k) - p(i, j+1, k) .ge. 0.) then
            abs4d = pd(i, j+2, k) - pd(i, j+1, k)
            abs4 = p(i, j+2, k) - p(i, j+1, k)
          else
            abs4d = -(pd(i, j+2, k)-pd(i, j+1, k))
            abs4 = -(p(i, j+2, k)-p(i, j+1, k))
          end if
          if (p(i, j+1, k) - p(i, j, k) .ge. 0.) then
            abs10d = pd(i, j+1, k) - pd(i, j, k)
            abs10 = p(i, j+1, k) - p(i, j, k)
          else
            abs10d = -(pd(i, j+1, k)-pd(i, j, k))
            abs10 = -(p(i, j+1, k)-p(i, j, k))
          end if
          x4d = ((pd(i, j+2, k)-two*pd(i, j+1, k)+pd(i, j, k))*(omega*(p&
&           (i, j+2, k)+two*p(i, j+1, k)+p(i, j, k))+oneminomega*(abs4+&
&           abs10)+plim)-(p(i, j+2, k)-two*p(i, j+1, k)+p(i, j, k))*(&
&           omega*(pd(i, j+2, k)+two*pd(i, j+1, k)+pd(i, j, k))+&
&           oneminomega*(abs4d+abs10d)+plimd))/(omega*(p(i, j+2, k)+two*&
&           p(i, j+1, k)+p(i, j, k))+oneminomega*(abs4+abs10)+plim)**2
          x4 = (p(i, j+2, k)-two*p(i, j+1, k)+p(i, j, k))/(omega*(p(i, j&
&           +2, k)+two*p(i, j+1, k)+p(i, j, k))+oneminomega*(abs4+abs10)&
&           +plim)
          if (x4 .ge. 0.) then
            dp2d = x4d
            dp2 = x4
          else
            dp2d = -x4d
            dp2 = -x4
          end if
! compute the dissipation coefficients for this face.
          ppor = zero
          if (porj(i, j, k) .eq. normalflux) ppor = one
          if (lumpeddiss) then
            if (dp1 .lt. dp2) then
              y3d = dp2d
              y3 = dp2
            else
              y3d = dp1d
              y3 = dp1
            end if
            if (dpmax .gt. y3) then
              min3d = y3d
              min3 = y3
            else
              min3 = dpmax
              min3d = 0.0_8
            end if
            dis2d = fis2*ppor*min3d
            dis2 = fis2*ppor*min3 + sigma*fis4*ppor
            dis4 = 0.0
            dis4d = 0.0_8
          else
            if (dp1 .lt. dp2) then
              y4d = dp2d
              y4 = dp2
            else
              y4d = dp1d
              y4 = dp1
            end if
            if (dpmax .gt. y4) then
              min4d = y4d
              min4 = y4
            else
              min4 = dpmax
              min4d = 0.0_8
            end if
            dis2d = ppor*fis2*min4d
            dis2 = ppor*fis2*min4
            dis4d = dim_d(ppor*fis4, 0.0_8, dis2, dis2d, dis4)
          end if
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          ddwd = wd(i, j+1, k, irho) - wd(i, j, k, irho)
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          drd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j+2, k, irho)-w(i, j&
&           -1, k, irho)-three*ddw) - dis4*(wd(i, j+2, k, irho)-wd(i, j-&
&           1, k, irho)-three*ddwd)
          dr = dis2*ddw - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-&
&           three*ddw)
          ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, ivx) + w(i, j+1, k, &
&           irho)*wd(i, j+1, k, ivx) - wd(i, j, k, irho)*w(i, j, k, ivx)&
&           - w(i, j, k, irho)*wd(i, j, k, ivx)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          drud = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j+2, k, irho)*w(i, &
&           j+2, k, ivx)-w(i, j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw)&
&           - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, ivx)+w(i, j+2, k, &
&           irho)*wd(i, j+2, k, ivx)-wd(i, j-1, k, irho)*w(i, j-1, k, &
&           ivx)-w(i, j-1, k, irho)*wd(i, j-1, k, ivx)-three*ddwd)
          dru = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(&
&           i, j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw)
          ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, ivy) + w(i, j+1, k, &
&           irho)*wd(i, j+1, k, ivy) - wd(i, j, k, irho)*w(i, j, k, ivy)&
&           - w(i, j, k, irho)*wd(i, j, k, ivy)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          drvd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j+2, k, irho)*w(i, &
&           j+2, k, ivy)-w(i, j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw)&
&           - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, ivy)+w(i, j+2, k, &
&           irho)*wd(i, j+2, k, ivy)-wd(i, j-1, k, irho)*w(i, j-1, k, &
&           ivy)-w(i, j-1, k, irho)*wd(i, j-1, k, ivy)-three*ddwd)
          drv = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(&
&           i, j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw)
          ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, ivz) + w(i, j+1, k, &
&           irho)*wd(i, j+1, k, ivz) - wd(i, j, k, irho)*w(i, j, k, ivz)&
&           - w(i, j, k, irho)*wd(i, j, k, ivz)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          drwd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j+2, k, irho)*w(i, &
&           j+2, k, ivz)-w(i, j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw)&
&           - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, ivz)+w(i, j+2, k, &
&           irho)*wd(i, j+2, k, ivz)-wd(i, j-1, k, irho)*w(i, j-1, k, &
&           ivz)-w(i, j-1, k, irho)*wd(i, j-1, k, ivz)-three*ddwd)
          drw = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(&
&           i, j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw)
          ddwd = wd(i, j+1, k, irhoe) - wd(i, j, k, irhoe)
          ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          dred = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j+2, k, irhoe)-w(i&
&           , j-1, k, irhoe)-three*ddw) - dis4*(wd(i, j+2, k, irhoe)-wd(&
&           i, j-1, k, irhoe)-three*ddwd)
          dre = dis2*ddw - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)&
&           -three*ddw)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddwd = wd(i, j+1, k, irho)*w(i, j+1, k, itu1) + w(i, j+1, k&
&             , irho)*wd(i, j+1, k, itu1) - wd(i, j, k, irho)*w(i, j, k&
&             , itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drkd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j+2, k, irho)*w(i&
&             , j+2, k, itu1)-w(i, j-1, k, irho)*w(i, j-1, k, itu1)-&
&             three*ddw) - dis4*(wd(i, j+2, k, irho)*w(i, j+2, k, itu1)+&
&             w(i, j+2, k, irho)*wd(i, j+2, k, itu1)-wd(i, j-1, k, irho)&
&             *w(i, j-1, k, itu1)-w(i, j-1, k, irho)*wd(i, j-1, k, itu1)&
&             -three*ddwd)
            drk = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)&
&             -w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw)
            kavgd = half*(wd(i, j, k, itu1)+wd(i, j+1, k, itu1))
            kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
          else
            drk = zero
            kavg = zero
            kavgd = 0.0_8
            drkd = 0.0_8
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavgd = half*(wd(i, j+1, k, ivx)+wd(i, j, k, ivx))
          uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
          vavgd = half*(wd(i, j+1, k, ivy)+wd(i, j, k, ivy))
          vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
          wavgd = half*(wd(i, j+1, k, ivz)+wd(i, j, k, ivz))
          wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
          a2avgd = half*((gamma(i, j+1, k)*pd(i, j+1, k)*w(i, j+1, k, &
&           irho)-gamma(i, j+1, k)*p(i, j+1, k)*wd(i, j+1, k, irho))/w(i&
&           , j+1, k, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k, &
&           irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, j, k&
&           , irho)**2)
          a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          sxd = sjd(i, j, k, 1)
          sx = sj(i, j, k, 1)
          syd = sjd(i, j, k, 2)
          sy = sj(i, j, k, 2)
          szd = sjd(i, j, k, 3)
          sz = sj(i, j, k, 3)
          arg1d = 2*sx*sxd + 2*sy*syd + 2*sz*szd
          arg1 = sx**2 + sy**2 + sz**2
          if (arg1 .eq. 0.0_8) then
            aread = 0.0_8
          else
            aread = arg1d/(2.0*sqrt(arg1))
          end if
          area = sqrt(arg1)
          if (1.e-25_realtype .lt. area) then
            max2d = aread
            max2 = area
          else
            max2 = 1.e-25_realtype
            max2d = 0.0_8
          end if
          tmpd = -(one*max2d/max2**2)
          tmp = one/max2
          sxd = sxd*tmp + sx*tmpd
          sx = sx*tmp
          syd = syd*tmp + sy*tmpd
          sy = sy*tmp
          szd = szd*tmp + sz*tmpd
          sz = sz*tmp
          alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          if (a2avg .eq. 0.0_8) then
            aavgd = 0.0_8
          else
            aavgd = a2avgd/(2.0*sqrt(a2avg))
          end if
          aavg = sqrt(a2avg)
          unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*sz &
&           + wavg*szd
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavgd = -(one*aavgd/aavg**2)
          ovaavg = one/aavg
          ova2avgd = -(one*a2avgd/a2avg**2)
          ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sfaced = sfacejd(i, j, k)*tmp + sfacej(i, j, k)*tmpd
            sface = sfacej(i, j, k)*tmp
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1d = unavgd - sfaced + aavgd
            lam1 = unavg - sface + aavg
          else
            lam1d = -(unavgd-sfaced+aavgd)
            lam1 = -(unavg-sface+aavg)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2d = unavgd - sfaced - aavgd
            lam2 = unavg - sface - aavg
          else
            lam2d = -(unavgd-sfaced-aavgd)
            lam2 = -(unavg-sface-aavg)
          end if
          if (unavg - sface .ge. 0.) then
            lam3d = unavgd - sfaced
            lam3 = unavg - sface
          else
            lam3d = -(unavgd-sfaced)
            lam3 = -(unavg-sface)
          end if
          rradd = lam3d + aavgd
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1d = epsacoustic*rradd
            lam1 = epsacoustic*rrad
          else
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2d = epsacoustic*rradd
            lam2 = epsacoustic*rrad
          else
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3d = epsshear*rradd
            lam3 = epsshear*rrad
          else
            lam3 = lam3
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1d = lam1d*area + lam1*aread
          lam1 = lam1*area
          lam2d = lam2d*area + lam2*aread
          lam2 = lam2*area
          lam3d = lam3d*area + lam3*aread
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1d = half*(lam1d+lam2d)
          abv1 = half*(lam1+lam2)
          abv2d = half*(lam1d-lam2d)
          abv2 = half*(lam1-lam2)
          abv3d = abv1d - lam3d
          abv3 = abv1 - lam3
          abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&           vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz*&
&           drwd - unavgd*dr - unavg*drd
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd +&
&           (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd + &
&           abv3d*abv5 + abv3*abv5d
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
          fsd = lam3d*dr + lam3*drd + abv6d
          fs = lam3*dr + abv6
          fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) + fsd
          fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
          fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
          fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sxd*&
&           abv7 + sx*abv7d
          fs = lam3*dru + uavg*abv6 + sx*abv7
          fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) + fsd
          fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
          fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + syd*&
&           abv7 + sy*abv7d
          fs = lam3*drv + vavg*abv6 + sy*abv7
          fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) + fsd
          fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
          fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + szd*&
&           abv7 + sz*abv7d
          fs = lam3*drw + wavg*abv6 + sz*abv7
          fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) + fsd
          fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
          fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + unavgd&
&           *abv7 + unavg*abv7d
          fs = lam3*dre + havg*abv6 + unavg*abv7
          fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) + fsd
          fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
          dp1d = dp2d
          dp1 = dp2
        end do
      end do
    end do
!
!      ******************************************************************
!      *                                                                *
!      * dissipative fluxes in the k-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    do j=2,jl
      do i=2,il
        if (p(i, j, 2) - p(i, j, 1) .ge. 0.) then
          abs5d = pd(i, j, 2) - pd(i, j, 1)
          abs5 = p(i, j, 2) - p(i, j, 1)
        else
          abs5d = -(pd(i, j, 2)-pd(i, j, 1))
          abs5 = -(p(i, j, 2)-p(i, j, 1))
        end if
        if (p(i, j, 1) - p(i, j, 0) .ge. 0.) then
          abs11d = pd(i, j, 1) - pd(i, j, 0)
          abs11 = p(i, j, 1) - p(i, j, 0)
        else
          abs11d = -(pd(i, j, 1)-pd(i, j, 0))
          abs11 = -(p(i, j, 1)-p(i, j, 0))
        end if
        x5d = ((pd(i, j, 2)-two*pd(i, j, 1)+pd(i, j, 0))*(omega*(p(i, j&
&         , 2)+two*p(i, j, 1)+p(i, j, 0))+oneminomega*(abs5+abs11)+plim)&
&         -(p(i, j, 2)-two*p(i, j, 1)+p(i, j, 0))*(omega*(pd(i, j, 2)+&
&         two*pd(i, j, 1)+pd(i, j, 0))+oneminomega*(abs5d+abs11d)+plimd)&
&         )/(omega*(p(i, j, 2)+two*p(i, j, 1)+p(i, j, 0))+oneminomega*(&
&         abs5+abs11)+plim)**2
        x5 = (p(i, j, 2)-two*p(i, j, 1)+p(i, j, 0))/(omega*(p(i, j, 2)+&
&         two*p(i, j, 1)+p(i, j, 0))+oneminomega*(abs5+abs11)+plim)
        if (x5 .ge. 0.) then
          dp1d = x5d
          dp1 = x5
        else
          dp1d = -x5d
          dp1 = -x5
        end if
! loop in k-direction.
        do k=1,kl
          if (p(i, j, k+2) - p(i, j, k+1) .ge. 0.) then
            abs6d = pd(i, j, k+2) - pd(i, j, k+1)
            abs6 = p(i, j, k+2) - p(i, j, k+1)
          else
            abs6d = -(pd(i, j, k+2)-pd(i, j, k+1))
            abs6 = -(p(i, j, k+2)-p(i, j, k+1))
          end if
          if (p(i, j, k+1) - p(i, j, k) .ge. 0.) then
            abs12d = pd(i, j, k+1) - pd(i, j, k)
            abs12 = p(i, j, k+1) - p(i, j, k)
          else
            abs12d = -(pd(i, j, k+1)-pd(i, j, k))
            abs12 = -(p(i, j, k+1)-p(i, j, k))
          end if
          x6d = ((pd(i, j, k+2)-two*pd(i, j, k+1)+pd(i, j, k))*(omega*(p&
&           (i, j, k+2)+two*p(i, j, k+1)+p(i, j, k))+oneminomega*(abs6+&
&           abs12)+plim)-(p(i, j, k+2)-two*p(i, j, k+1)+p(i, j, k))*(&
&           omega*(pd(i, j, k+2)+two*pd(i, j, k+1)+pd(i, j, k))+&
&           oneminomega*(abs6d+abs12d)+plimd))/(omega*(p(i, j, k+2)+two*&
&           p(i, j, k+1)+p(i, j, k))+oneminomega*(abs6+abs12)+plim)**2
          x6 = (p(i, j, k+2)-two*p(i, j, k+1)+p(i, j, k))/(omega*(p(i, j&
&           , k+2)+two*p(i, j, k+1)+p(i, j, k))+oneminomega*(abs6+abs12)&
&           +plim)
          if (x6 .ge. 0.) then
            dp2d = x6d
            dp2 = x6
          else
            dp2d = -x6d
            dp2 = -x6
          end if
! compute the dissipation coefficients for this face.
          ppor = zero
          if (pork(i, j, k) .eq. normalflux) ppor = one
          if (lumpeddiss) then
            if (dp1 .lt. dp2) then
              y5d = dp2d
              y5 = dp2
            else
              y5d = dp1d
              y5 = dp1
            end if
            if (dpmax .gt. y5) then
              min5d = y5d
              min5 = y5
            else
              min5 = dpmax
              min5d = 0.0_8
            end if
            dis2d = fis2*ppor*min5d
            dis2 = fis2*ppor*min5 + sigma*fis4*ppor
            dis4 = 0.0
            dis4d = 0.0_8
          else
            if (dp1 .lt. dp2) then
              y6d = dp2d
              y6 = dp2
            else
              y6d = dp1d
              y6 = dp1
            end if
            if (dpmax .gt. y6) then
              min6d = y6d
              min6 = y6
            else
              min6 = dpmax
              min6d = 0.0_8
            end if
            dis2d = ppor*fis2*min6d
            dis2 = ppor*fis2*min6
            dis4d = dim_d(ppor*fis4, 0.0_8, dis2, dis2d, dis4)
          end if
! construct the vector of the first and third differences
! multiplied by the appropriate constants.
          ddwd = wd(i, j, k+1, irho) - wd(i, j, k, irho)
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          drd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j, k+2, irho)-w(i, j&
&           , k-1, irho)-three*ddw) - dis4*(wd(i, j, k+2, irho)-wd(i, j&
&           , k-1, irho)-three*ddwd)
          dr = dis2*ddw - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)-&
&           three*ddw)
          ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, ivx) + w(i, j, k+1, &
&           irho)*wd(i, j, k+1, ivx) - wd(i, j, k, irho)*w(i, j, k, ivx)&
&           - w(i, j, k, irho)*wd(i, j, k, ivx)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*&
&           w(i, j, k, ivx)
          drud = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j, k+2, irho)*w(i, &
&           j, k+2, ivx)-w(i, j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw)&
&           - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, ivx)+w(i, j, k+2, &
&           irho)*wd(i, j, k+2, ivx)-wd(i, j, k-1, irho)*w(i, j, k-1, &
&           ivx)-w(i, j, k-1, irho)*wd(i, j, k-1, ivx)-three*ddwd)
          dru = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)-w(&
&           i, j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw)
          ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, ivy) + w(i, j, k+1, &
&           irho)*wd(i, j, k+1, ivy) - wd(i, j, k, irho)*w(i, j, k, ivy)&
&           - w(i, j, k, irho)*wd(i, j, k, ivy)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*&
&           w(i, j, k, ivy)
          drvd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j, k+2, irho)*w(i, &
&           j, k+2, ivy)-w(i, j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw)&
&           - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, ivy)+w(i, j, k+2, &
&           irho)*wd(i, j, k+2, ivy)-wd(i, j, k-1, irho)*w(i, j, k-1, &
&           ivy)-w(i, j, k-1, irho)*wd(i, j, k-1, ivy)-three*ddwd)
          drv = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)-w(&
&           i, j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw)
          ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, ivz) + w(i, j, k+1, &
&           irho)*wd(i, j, k+1, ivz) - wd(i, j, k, irho)*w(i, j, k, ivz)&
&           - w(i, j, k, irho)*wd(i, j, k, ivz)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*&
&           w(i, j, k, ivz)
          drwd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j, k+2, irho)*w(i, &
&           j, k+2, ivz)-w(i, j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw)&
&           - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, ivz)+w(i, j, k+2, &
&           irho)*wd(i, j, k+2, ivz)-wd(i, j, k-1, irho)*w(i, j, k-1, &
&           ivz)-w(i, j, k-1, irho)*wd(i, j, k-1, ivz)-three*ddwd)
          drw = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)-w(&
&           i, j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw)
          ddwd = wd(i, j, k+1, irhoe) - wd(i, j, k, irhoe)
          ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          dred = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j, k+2, irhoe)-w(i&
&           , j, k-1, irhoe)-three*ddw) - dis4*(wd(i, j, k+2, irhoe)-wd(&
&           i, j, k-1, irhoe)-three*ddwd)
          dre = dis2*ddw - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, irhoe)&
&           -three*ddw)
! in case a k-equation is present, compute the difference
! of rhok and store the average value of k. if not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          if (correctfork) then
            ddwd = wd(i, j, k+1, irho)*w(i, j, k+1, itu1) + w(i, j, k+1&
&             , irho)*wd(i, j, k+1, itu1) - wd(i, j, k, irho)*w(i, j, k&
&             , itu1) - w(i, j, k, irho)*wd(i, j, k, itu1)
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&             irho)*w(i, j, k, itu1)
            drkd = dis2d*ddw + dis2*ddwd - dis4d*(w(i, j, k+2, irho)*w(i&
&             , j, k+2, itu1)-w(i, j, k-1, irho)*w(i, j, k-1, itu1)-&
&             three*ddw) - dis4*(wd(i, j, k+2, irho)*w(i, j, k+2, itu1)+&
&             w(i, j, k+2, irho)*wd(i, j, k+2, itu1)-wd(i, j, k-1, irho)&
&             *w(i, j, k-1, itu1)-w(i, j, k-1, irho)*wd(i, j, k-1, itu1)&
&             -three*ddwd)
            drk = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, itu1)&
&             -w(i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw)
            kavgd = half*(wd(i, j, k+1, itu1)+wd(i, j, k, itu1))
            kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
          else
            drk = zero
            kavg = zero
            kavgd = 0.0_8
            drkd = 0.0_8
          end if
! compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! compute the average state at the interface.
          uavgd = half*(wd(i, j, k+1, ivx)+wd(i, j, k, ivx))
          uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
          vavgd = half*(wd(i, j, k+1, ivy)+wd(i, j, k, ivy))
          vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
          wavgd = half*(wd(i, j, k+1, ivz)+wd(i, j, k, ivz))
          wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
          a2avgd = half*((gamma(i, j, k+1)*pd(i, j, k+1)*w(i, j, k+1, &
&           irho)-gamma(i, j, k+1)*p(i, j, k+1)*wd(i, j, k+1, irho))/w(i&
&           , j, k+1, irho)**2+(gamma(i, j, k)*pd(i, j, k)*w(i, j, k, &
&           irho)-gamma(i, j, k)*p(i, j, k)*wd(i, j, k, irho))/w(i, j, k&
&           , irho)**2)
          a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)&
&           +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          sxd = skd(i, j, k, 1)
          sx = sk(i, j, k, 1)
          syd = skd(i, j, k, 2)
          sy = sk(i, j, k, 2)
          szd = skd(i, j, k, 3)
          sz = sk(i, j, k, 3)
          arg1d = 2*sx*sxd + 2*sy*syd + 2*sz*szd
          arg1 = sx**2 + sy**2 + sz**2
          if (arg1 .eq. 0.0_8) then
            aread = 0.0_8
          else
            aread = arg1d/(2.0*sqrt(arg1))
          end if
          area = sqrt(arg1)
          if (1.e-25_realtype .lt. area) then
            max3d = aread
            max3 = area
          else
            max3 = 1.e-25_realtype
            max3d = 0.0_8
          end if
          tmpd = -(one*max3d/max3**2)
          tmp = one/max3
          sxd = sxd*tmp + sx*tmpd
          sx = sx*tmp
          syd = syd*tmp + sy*tmpd
          sy = sy*tmp
          szd = szd*tmp + sz*tmpd
          sz = sz*tmp
          alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          havgd = alphaavgd + ovgm1*(a2avgd-gm53*kavgd)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          if (a2avg .eq. 0.0_8) then
            aavgd = 0.0_8
          else
            aavgd = a2avgd/(2.0*sqrt(a2avg))
          end if
          aavg = sqrt(a2avg)
          unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*sz &
&           + wavg*szd
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavgd = -(one*aavgd/aavg**2)
          ovaavg = one/aavg
          ova2avgd = -(one*a2avgd/a2avg**2)
          ova2avg = one/a2avg
! the mesh velocity if the face is moving. it must be
! divided by the area to obtain a true velocity.
          if (addgridvelocities) then
            sfaced = sfacekd(i, j, k)*tmp + sfacek(i, j, k)*tmpd
            sface = sfacek(i, j, k)*tmp
          end if
          if (unavg - sface + aavg .ge. 0.) then
            lam1d = unavgd - sfaced + aavgd
            lam1 = unavg - sface + aavg
          else
            lam1d = -(unavgd-sfaced+aavgd)
            lam1 = -(unavg-sface+aavg)
          end if
          if (unavg - sface - aavg .ge. 0.) then
            lam2d = unavgd - sfaced - aavgd
            lam2 = unavg - sface - aavg
          else
            lam2d = -(unavgd-sfaced-aavgd)
            lam2 = -(unavg-sface-aavg)
          end if
          if (unavg - sface .ge. 0.) then
            lam3d = unavgd - sfaced
            lam3 = unavg - sface
          else
            lam3d = -(unavgd-sfaced)
            lam3 = -(unavg-sface)
          end if
          rradd = lam3d + aavgd
          rrad = lam3 + aavg
          if (lam1 .lt. epsacoustic*rrad) then
            lam1d = epsacoustic*rradd
            lam1 = epsacoustic*rrad
          else
            lam1 = lam1
          end if
          if (lam2 .lt. epsacoustic*rrad) then
            lam2d = epsacoustic*rradd
            lam2 = epsacoustic*rrad
          else
            lam2 = lam2
          end if
          if (lam3 .lt. epsshear*rrad) then
            lam3d = epsshear*rradd
            lam3 = epsshear*rrad
          else
            lam3 = lam3
          end if
! multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1d = lam1d*area + lam1*aread
          lam1 = lam1*area
          lam2d = lam2d*area + lam2*aread
          lam2 = lam2*area
          lam3d = lam3d*area + lam3*aread
          lam3 = lam3*area
! some abbreviations, which occur quite often in the
! dissipation terms.
          abv1d = half*(lam1d+lam2d)
          abv1 = half*(lam1+lam2)
          abv2d = half*(lam1d-lam2d)
          abv2 = half*(lam1-lam2)
          abv3d = abv1d - lam3d
          abv3 = abv1 - lam3
          abv4d = gm1*(alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-&
&           vavgd*drv-vavg*drvd-wavgd*drw-wavg*drwd+dred) - gm53*drkd
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&           *drk
          abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz*&
&           drwd - unavgd*dr - unavg*drd
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd +&
&           (abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd + &
&           abv3d*abv5 + abv3*abv5d
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! compute and scatter the dissipative flux.
! density.
          fsd = lam3d*dr + lam3*drd + abv6d
          fs = lam3*dr + abv6
          fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) + fsd
          fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
          fwd(i, j, k, irho) = fwd(i, j, k, irho) - fsd
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
! x-momentum.
          fsd = lam3d*dru + lam3*drud + uavgd*abv6 + uavg*abv6d + sxd*&
&           abv7 + sx*abv7d
          fs = lam3*dru + uavg*abv6 + sx*abv7
          fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) + fsd
          fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
          fwd(i, j, k, imx) = fwd(i, j, k, imx) - fsd
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! y-momentum.
          fsd = lam3d*drv + lam3*drvd + vavgd*abv6 + vavg*abv6d + syd*&
&           abv7 + sy*abv7d
          fs = lam3*drv + vavg*abv6 + sy*abv7
          fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) + fsd
          fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
          fwd(i, j, k, imy) = fwd(i, j, k, imy) - fsd
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! z-momentum.
          fsd = lam3d*drw + lam3*drwd + wavgd*abv6 + wavg*abv6d + szd*&
&           abv7 + sz*abv7d
          fs = lam3*drw + wavg*abv6 + sz*abv7
          fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) + fsd
          fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
          fwd(i, j, k, imz) = fwd(i, j, k, imz) - fsd
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! energy.
          fsd = lam3d*dre + lam3*dred + havgd*abv6 + havg*abv6d + unavgd&
&           *abv7 + unavg*abv7d
          fs = lam3*dre + havg*abv6 + unavg*abv7
          fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) + fsd
          fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
          fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) - fsd
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! set dp1 to dp2 for the next face.
          dp1d = dp2d
          dp1 = dp2
        end do
      end do
    end do
  end if
end subroutine invisciddissfluxmatrix_d

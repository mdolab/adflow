!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of sasolve in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *sfacei *sfacej *sfacek *w
!                *rlv *vol *si *sj *sk (global)timeref
!   plus diff mem management of: sfacei:in sfacej:in sfacek:in
!                dw:in w:in rlv:in vol:in si:in sj:in sk:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          sasolve.f90                                     *
!      * author:        georgi kalitzin, edwin van der weide,           *
!      *                steve repsher (blanking)                        *
!      * starting date: 06-11-2003                                      *
!      * last modified: 07-05-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine sasolve_d(resonly)
!
!      ******************************************************************
!      *                                                                *
!      * sasolve solves the turbulent transport equation for the        *
!      * original spalart-allmaras model in a segregated manner using   *
!      * a diagonal dominant adi-scheme.                                *
!      *                                                                *
!      ******************************************************************
!
  use bctypes
  use blockpointers
  use constants
  use inputiteration
  use inputphysics
  use paramturb
  use turbmod
  implicit none
! don't need the remainder for residual derivative
!
!      subroutine arguments.
!
  logical, intent(in) :: resonly
!
!      local parameters.
!
  real(kind=realtype), parameter :: xminn=1.e-10_realtype
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, nn
  real(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
  real(kind=realtype) :: fv1, fv2, ft2
  real(kind=realtype) :: fv1d, fv2d, ft2d
  real(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
  real(kind=realtype) :: ssd, sstd, nud, chid, chi2d, chi3d
  real(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
  real(kind=realtype) :: rrd, ggd, gg6d, termfwd, fwsad, term1d, term2d
  real(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
  real(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
  real(kind=realtype) :: volid, volmid, volpid, xmd, ymd, zmd, xpd, ypd&
& , zpd
  real(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
  real(kind=realtype) :: xad, yad, zad, ttmd, ttpd, cnudd, camd, capd
  real(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
  real(kind=realtype) :: nutmd, nutpd, numd, nupd, cdmd, cdpd
  real(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
  real(kind=realtype) :: c1md, c1pd, c10d
  real(kind=realtype) :: uu, um, up, factor, f, tu1p, rblank
  real(kind=realtype), dimension(2:il, 2:jl, 2:kl) :: qq
  real(kind=realtype), dimension(2:max(kl, il, jl)) :: bb, cc, dd, ff
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall
  logical, dimension(2:jl, 2:kl), target :: flagi2, flagil
  logical, dimension(2:il, 2:kl), target :: flagj2, flagjl
  logical, dimension(2:il, 2:jl), target :: flagk2, flagkl
  logical, dimension(:, :), pointer :: flag
  intrinsic max
  intrinsic sqrt
  intrinsic exp
  intrinsic min
  intrinsic real
  real(kind=realtype) :: pwx1
  real(kind=realtype) :: pwx1d
  real(kind=realtype) :: max6
  real(kind=realtype) :: max5
  real(kind=realtype) :: max4
  real(kind=realtype) :: max3
  real(kind=realtype) :: max2
  real(kind=realtype) :: max1
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! set model constants
  cv13 = rsacv1**3
  kar2inv = one/rsak**2
  cw36 = rsacw3**6
  cb3inv = one/rsacb3
! set the pointer for dvt in dw, such that the code is more
! readable. also set the pointers for the production term
! and vorticity.
!
!      ******************************************************************
!      *                                                                *
!      * production term.                                               *
!      *                                                                *
!      ******************************************************************
!
  select case  (turbprod) 
  case (strain) 
    call prodsmag2_d()
  case (vorticity) 
    call prodwmag2_d()
  case (katolaunder) 
    call prodkatolaunder_d()
  case default
    dwd = 0.0_8
  end select
!
!      ******************************************************************
!      *                                                                *
!      * source terms.                                                  *
!      *                                                                *
!      * determine the source term and its derivative w.r.t. nutilde    *
!      * for all internal cells of the block.                           *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! first take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
        if (dw(i, j, k, iprod) .eq. 0.0_8) then
          ssd = 0.0_8
        else
          ssd = dwd(i, j, k, iprod)/(2.0*sqrt(dw(i, j, k, iprod)))
        end if
        ss = sqrt(dw(i, j, k, iprod))
! compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nutilde
! and nu) and the functions fv1 and fv2. the latter corrects
! the production term near a viscous wall.
        nud = (rlvd(i, j, k)*w(i, j, k, irho)-rlv(i, j, k)*wd(i, j, k, &
&         irho))/w(i, j, k, irho)**2
        nu = rlv(i, j, k)/w(i, j, k, irho)
        dist2inv = one/d2wall(i, j, k)**2
        chid = (wd(i, j, k, itu1)*nu-w(i, j, k, itu1)*nud)/nu**2
        chi = w(i, j, k, itu1)/nu
        chi2d = chid*chi + chi*chid
        chi2 = chi*chi
        chi3d = chid*chi2 + chi*chi2d
        chi3 = chi*chi2
        fv1d = (chi3d*(chi3+cv13)-chi3*chi3d)/(chi3+cv13)**2
        fv1 = chi3/(chi3+cv13)
        fv2d = -((chid*(one+chi*fv1)-chi*(chid*fv1+chi*fv1d))/(one+chi*&
&         fv1)**2)
        fv2 = one - chi/(one+chi*fv1)
! the function ft2, which is designed to keep a laminar
! solution laminar. when running in fully turbulent mode
! this function should be set to 0.0.
        ft2d = -(rsact3*rsact4*chi2d*exp(-(rsact4*chi2)))
        ft2 = rsact3*exp(-(rsact4*chi2))
! ft2 = zero
! correct the production term to account for the influence
! of the wall. make sure that this term remains positive
! (the function fv2 is negative between chi = 1 and 18.4,
! which can cause sst to go negative, which is undesirable).
        sstd = ssd + kar2inv*dist2inv*(wd(i, j, k, itu1)*fv2+w(i, j, k, &
&         itu1)*fv2d)
        sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
        if (sst .lt. xminn) then
          sst = xminn
          sstd = 0.0_8
        else
          sst = sst
        end if
! compute the function fw. the argument rr is cut off at 10
! to avoid numerical problems. this is ok, because the
! asymptotical value of fw is then already reached.
        rrd = (kar2inv*dist2inv*wd(i, j, k, itu1)*sst-w(i, j, k, itu1)*&
&         kar2inv*dist2inv*sstd)/sst**2
        rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
        if (rr .gt. 10.0_realtype) then
          rr = 10.0_realtype
          rrd = 0.0_8
        else
          rr = rr
        end if
        ggd = rrd + rsacw2*(6*rr**5*rrd-rrd)
        gg = rr + rsacw2*(rr**6-rr)
        gg6d = 6*gg**5*ggd
        gg6 = gg**6
        pwx1d = -((one+cw36)*gg6d/(gg6+cw36)**2)
        pwx1 = (one+cw36)/(gg6+cw36)
        if (pwx1 .gt. 0.0_8 .or. (pwx1 .lt. 0.0_8 .and. sixth .eq. int(&
&           sixth))) then
          termfwd = sixth*pwx1**(sixth-1)*pwx1d
        else if (pwx1 .eq. 0.0_8 .and. sixth .eq. 1.0) then
          termfwd = pwx1d
        else
          termfwd = 0.0_8
        end if
        termfw = pwx1**sixth
        fwsad = ggd*termfw + gg*termfwd
        fwsa = gg*termfw
! compute the source term; some terms are saved for the
! linearization. the source term is stored in dvt.
        term1d = rsacb1*((one-ft2)*ssd-ft2d*ss)
        term1 = rsacb1*(one-ft2)*ss
        term2d = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2d-ft2d*fv2+ft2d)&
&         -rsacw1*fwsad)
        term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
&         )
        dwd(i, j, k, idvt) = (term1d+term2d*w(i, j, k, itu1)+term2*wd(i&
&         , j, k, itu1))*w(i, j, k, itu1) + (term1+term2*w(i, j, k, itu1&
&         ))*wd(i, j, k, itu1)
        dw(i, j, k, idvt) = (term1+term2*w(i, j, k, itu1))*w(i, j, k, &
&         itu1)
! compute some derivatives w.r.t. nutilde. these will occur
! in the left hand side, i.e. the matrix for the implicit
! treatment.
        dfv1 = three*chi2*cv13/(chi3+cv13)**2
        dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
        dft2 = -(two*rsact4*chi*ft2/nu)
        drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
        dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
        dfw = cw36/(gg6+cw36)*termfw*dgg
! compute the source term jacobian. note that the part
! containing term1 is treated explicitly. the reason is that
! implicit treatment of this part leads to a decrease of the
! diagonal dominance of the jacobian and it thus decreases
! the stability. you may want to play around and try to
! take this term into account in the jacobian.
! note that -dsource/dnu is stored.
        qq(i, j, k) = -(two*term2*w(i, j, k, itu1)) - dist2inv*w(i, j, k&
&         , itu1)*w(i, j, k, itu1)*(rsacb1*kar2inv*(dfv2-ft2*dfv2-fv2*&
&         dft2+dft2)-rsacw1*dfw)
        if (qq(i, j, k) .lt. zero) then
          qq(i, j, k) = zero
        else
          qq(i, j, k) = qq(i, j, k)
        end if
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * advection and unsteady terms.                                  *
!      *                                                                *
!      ******************************************************************
!
  nn = itu1 - 1
  call turbadvection_d(1_inttype, 1_inttype, nn, qq)
  call unsteadyturbterm_d(1_inttype, 1_inttype, nn, qq)
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in k-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
        volid = -(one*vold(i, j, k)/vol(i, j, k)**2)
        voli = one/vol(i, j, k)
        volmid = -(two*(vold(i, j, k)+vold(i, j, k-1))/(vol(i, j, k)+vol&
&         (i, j, k-1))**2)
        volmi = two/(vol(i, j, k)+vol(i, j, k-1))
        volpid = -(two*(vold(i, j, k)+vold(i, j, k+1))/(vol(i, j, k)+vol&
&         (i, j, k+1))**2)
        volpi = two/(vol(i, j, k)+vol(i, j, k+1))
        xmd = skd(i, j, k-1, 1)*volmi + sk(i, j, k-1, 1)*volmid
        xm = sk(i, j, k-1, 1)*volmi
        ymd = skd(i, j, k-1, 2)*volmi + sk(i, j, k-1, 2)*volmid
        ym = sk(i, j, k-1, 2)*volmi
        zmd = skd(i, j, k-1, 3)*volmi + sk(i, j, k-1, 3)*volmid
        zm = sk(i, j, k-1, 3)*volmi
        xpd = skd(i, j, k, 1)*volpi + sk(i, j, k, 1)*volpid
        xp = sk(i, j, k, 1)*volpi
        ypd = skd(i, j, k, 2)*volpi + sk(i, j, k, 2)*volpid
        yp = sk(i, j, k, 2)*volpi
        zpd = skd(i, j, k, 3)*volpi + sk(i, j, k, 3)*volpid
        zp = sk(i, j, k, 3)*volpi
        xad = half*((skd(i, j, k, 1)+skd(i, j, k-1, 1))*voli+(sk(i, j, k&
&         , 1)+sk(i, j, k-1, 1))*volid)
        xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
        yad = half*((skd(i, j, k, 2)+skd(i, j, k-1, 2))*voli+(sk(i, j, k&
&         , 2)+sk(i, j, k-1, 2))*volid)
        ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
        zad = half*((skd(i, j, k, 3)+skd(i, j, k-1, 3))*voli+(sk(i, j, k&
&         , 3)+sk(i, j, k-1, 3))*volid)
        za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
        ttmd = xmd*xa + xm*xad + ymd*ya + ym*yad + zmd*za + zm*zad
        ttm = xm*xa + ym*ya + zm*za
        ttpd = xpd*xa + xp*xad + ypd*ya + yp*yad + zpd*za + zp*zad
        ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. make sure that
! these coefficients are nonnegative.
        cnudd = -(rsacb2*cb3inv*wd(i, j, k, itu1))
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        camd = ttmd*cnud + ttm*cnudd
        cam = ttm*cnud
        capd = ttpd*cnud + ttp*cnudd
        cap = ttp*cnud
        nutmd = half*(wd(i, j, k-1, itu1)+wd(i, j, k, itu1))
        nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
        nutpd = half*(wd(i, j, k+1, itu1)+wd(i, j, k, itu1))
        nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
        nud = (rlvd(i, j, k)*w(i, j, k, irho)-rlv(i, j, k)*wd(i, j, k, &
&         irho))/w(i, j, k, irho)**2
        nu = rlv(i, j, k)/w(i, j, k, irho)
        numd = half*((rlvd(i, j, k-1)*w(i, j, k-1, irho)-rlv(i, j, k-1)*&
&         wd(i, j, k-1, irho))/w(i, j, k-1, irho)**2+nud)
        num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
        nupd = half*((rlvd(i, j, k+1)*w(i, j, k+1, irho)-rlv(i, j, k+1)*&
&         wd(i, j, k+1, irho))/w(i, j, k+1, irho)**2+nud)
        nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
        cdmd = cb3inv*((numd+(one+rsacb2)*nutmd)*ttm+(num+(one+rsacb2)*&
&         nutm)*ttmd)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdpd = cb3inv*((nupd+(one+rsacb2)*nutpd)*ttp+(nup+(one+rsacb2)*&
&         nutp)*ttpd)
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        if (cdm + cam .lt. zero) then
          c1m = zero
          c1md = 0.0_8
        else
          c1md = cdmd + camd
          c1m = cdm + cam
        end if
        if (cdp + cap .lt. zero) then
          c1p = zero
          c1pd = 0.0_8
        else
          c1pd = cdpd + capd
          c1p = cdp + cap
        end if
        c10d = c1md + c1pd
        c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dwd(i, j, k, idvt) = dwd(i, j, k, idvt) + c1md*w(i, j, k-1, itu1&
&         ) + c1m*wd(i, j, k-1, itu1) - c10d*w(i, j, k, itu1) - c10*wd(i&
&         , j, k, itu1) + c1pd*w(i, j, k+1, itu1) + c1p*wd(i, j, k+1, &
&         itu1)
        dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j, k-1, itu1) -&
&         c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
        b1 = -c1m
        c1 = c10
        d1 = -c1p
! update the central jacobian. for nonboundary cells this
! is simply c1. for boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! the boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
        if (k .eq. 2) then
          if (bmtk1(i, j, itu1, itu1) .lt. zero) then
            max1 = zero
          else
            max1 = bmtk1(i, j, itu1, itu1)
          end if
          qq(i, j, k) = qq(i, j, k) + c1 - b1*max1
        else if (k .eq. kl) then
          if (bmtk2(i, j, itu1, itu1) .lt. zero) then
            max2 = zero
          else
            max2 = bmtk2(i, j, itu1, itu1)
          end if
          qq(i, j, k) = qq(i, j, k) + c1 - d1*max2
        else
          qq(i, j, k) = qq(i, j, k) + c1
        end if
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in j-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
        volid = -(one*vold(i, j, k)/vol(i, j, k)**2)
        voli = one/vol(i, j, k)
        volmid = -(two*(vold(i, j, k)+vold(i, j-1, k))/(vol(i, j, k)+vol&
&         (i, j-1, k))**2)
        volmi = two/(vol(i, j, k)+vol(i, j-1, k))
        volpid = -(two*(vold(i, j, k)+vold(i, j+1, k))/(vol(i, j, k)+vol&
&         (i, j+1, k))**2)
        volpi = two/(vol(i, j, k)+vol(i, j+1, k))
        xmd = sjd(i, j-1, k, 1)*volmi + sj(i, j-1, k, 1)*volmid
        xm = sj(i, j-1, k, 1)*volmi
        ymd = sjd(i, j-1, k, 2)*volmi + sj(i, j-1, k, 2)*volmid
        ym = sj(i, j-1, k, 2)*volmi
        zmd = sjd(i, j-1, k, 3)*volmi + sj(i, j-1, k, 3)*volmid
        zm = sj(i, j-1, k, 3)*volmi
        xpd = sjd(i, j, k, 1)*volpi + sj(i, j, k, 1)*volpid
        xp = sj(i, j, k, 1)*volpi
        ypd = sjd(i, j, k, 2)*volpi + sj(i, j, k, 2)*volpid
        yp = sj(i, j, k, 2)*volpi
        zpd = sjd(i, j, k, 3)*volpi + sj(i, j, k, 3)*volpid
        zp = sj(i, j, k, 3)*volpi
        xad = half*((sjd(i, j, k, 1)+sjd(i, j-1, k, 1))*voli+(sj(i, j, k&
&         , 1)+sj(i, j-1, k, 1))*volid)
        xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
        yad = half*((sjd(i, j, k, 2)+sjd(i, j-1, k, 2))*voli+(sj(i, j, k&
&         , 2)+sj(i, j-1, k, 2))*volid)
        ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
        zad = half*((sjd(i, j, k, 3)+sjd(i, j-1, k, 3))*voli+(sj(i, j, k&
&         , 3)+sj(i, j-1, k, 3))*volid)
        za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
        ttmd = xmd*xa + xm*xad + ymd*ya + ym*yad + zmd*za + zm*zad
        ttm = xm*xa + ym*ya + zm*za
        ttpd = xpd*xa + xp*xad + ypd*ya + yp*yad + zpd*za + zp*zad
        ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. make sure that
! these coefficients are nonnegative.
        cnudd = -(rsacb2*cb3inv*wd(i, j, k, itu1))
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        camd = ttmd*cnud + ttm*cnudd
        cam = ttm*cnud
        capd = ttpd*cnud + ttp*cnudd
        cap = ttp*cnud
        nutmd = half*(wd(i, j-1, k, itu1)+wd(i, j, k, itu1))
        nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
        nutpd = half*(wd(i, j+1, k, itu1)+wd(i, j, k, itu1))
        nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
        nud = (rlvd(i, j, k)*w(i, j, k, irho)-rlv(i, j, k)*wd(i, j, k, &
&         irho))/w(i, j, k, irho)**2
        nu = rlv(i, j, k)/w(i, j, k, irho)
        numd = half*((rlvd(i, j-1, k)*w(i, j-1, k, irho)-rlv(i, j-1, k)*&
&         wd(i, j-1, k, irho))/w(i, j-1, k, irho)**2+nud)
        num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
        nupd = half*((rlvd(i, j+1, k)*w(i, j+1, k, irho)-rlv(i, j+1, k)*&
&         wd(i, j+1, k, irho))/w(i, j+1, k, irho)**2+nud)
        nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
        cdmd = cb3inv*((numd+(one+rsacb2)*nutmd)*ttm+(num+(one+rsacb2)*&
&         nutm)*ttmd)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdpd = cb3inv*((nupd+(one+rsacb2)*nutpd)*ttp+(nup+(one+rsacb2)*&
&         nutp)*ttpd)
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        if (cdm + cam .lt. zero) then
          c1m = zero
          c1md = 0.0_8
        else
          c1md = cdmd + camd
          c1m = cdm + cam
        end if
        if (cdp + cap .lt. zero) then
          c1p = zero
          c1pd = 0.0_8
        else
          c1pd = cdpd + capd
          c1p = cdp + cap
        end if
        c10d = c1md + c1pd
        c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dwd(i, j, k, idvt) = dwd(i, j, k, idvt) + c1md*w(i, j-1, k, itu1&
&         ) + c1m*wd(i, j-1, k, itu1) - c10d*w(i, j, k, itu1) - c10*wd(i&
&         , j, k, itu1) + c1pd*w(i, j+1, k, itu1) + c1p*wd(i, j+1, k, &
&         itu1)
        dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i, j-1, k, itu1) -&
&         c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
        b1 = -c1m
        c1 = c10
        d1 = -c1p
! update the central jacobian. for nonboundary cells this
! is simply c1. for boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! the boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
        if (j .eq. 2) then
          if (bmtj1(i, k, itu1, itu1) .lt. zero) then
            max3 = zero
          else
            max3 = bmtj1(i, k, itu1, itu1)
          end if
          qq(i, j, k) = qq(i, j, k) + c1 - b1*max3
        else if (j .eq. jl) then
          if (bmtj2(i, k, itu1, itu1) .lt. zero) then
            max4 = zero
          else
            max4 = bmtj2(i, k, itu1, itu1)
          end if
          qq(i, j, k) = qq(i, j, k) + c1 - d1*max4
        else
          qq(i, j, k) = qq(i, j, k) + c1
        end if
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * viscous terms in i-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
        volid = -(one*vold(i, j, k)/vol(i, j, k)**2)
        voli = one/vol(i, j, k)
        volmid = -(two*(vold(i, j, k)+vold(i-1, j, k))/(vol(i, j, k)+vol&
&         (i-1, j, k))**2)
        volmi = two/(vol(i, j, k)+vol(i-1, j, k))
        volpid = -(two*(vold(i, j, k)+vold(i+1, j, k))/(vol(i, j, k)+vol&
&         (i+1, j, k))**2)
        volpi = two/(vol(i, j, k)+vol(i+1, j, k))
        xmd = sid(i-1, j, k, 1)*volmi + si(i-1, j, k, 1)*volmid
        xm = si(i-1, j, k, 1)*volmi
        ymd = sid(i-1, j, k, 2)*volmi + si(i-1, j, k, 2)*volmid
        ym = si(i-1, j, k, 2)*volmi
        zmd = sid(i-1, j, k, 3)*volmi + si(i-1, j, k, 3)*volmid
        zm = si(i-1, j, k, 3)*volmi
        xpd = sid(i, j, k, 1)*volpi + si(i, j, k, 1)*volpid
        xp = si(i, j, k, 1)*volpi
        ypd = sid(i, j, k, 2)*volpi + si(i, j, k, 2)*volpid
        yp = si(i, j, k, 2)*volpi
        zpd = sid(i, j, k, 3)*volpi + si(i, j, k, 3)*volpid
        zp = si(i, j, k, 3)*volpi
        xad = half*((sid(i, j, k, 1)+sid(i-1, j, k, 1))*voli+(si(i, j, k&
&         , 1)+si(i-1, j, k, 1))*volid)
        xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
        yad = half*((sid(i, j, k, 2)+sid(i-1, j, k, 2))*voli+(si(i, j, k&
&         , 2)+si(i-1, j, k, 2))*volid)
        ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
        zad = half*((sid(i, j, k, 3)+sid(i-1, j, k, 3))*voli+(si(i, j, k&
&         , 3)+si(i-1, j, k, 3))*volid)
        za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
        ttmd = xmd*xa + xm*xad + ymd*ya + ym*yad + zmd*za + zm*zad
        ttm = xm*xa + ym*ya + zm*za
        ttpd = xpd*xa + xp*xad + ypd*ya + yp*yad + zpd*za + zp*zad
        ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric can be taken into account.
! compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. make sure that
! these coefficients are nonnegative.
        cnudd = -(rsacb2*cb3inv*wd(i, j, k, itu1))
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        camd = ttmd*cnud + ttm*cnudd
        cam = ttm*cnud
        capd = ttpd*cnud + ttp*cnudd
        cap = ttp*cnud
        nutmd = half*(wd(i-1, j, k, itu1)+wd(i, j, k, itu1))
        nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
        nutpd = half*(wd(i+1, j, k, itu1)+wd(i, j, k, itu1))
        nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
        nud = (rlvd(i, j, k)*w(i, j, k, irho)-rlv(i, j, k)*wd(i, j, k, &
&         irho))/w(i, j, k, irho)**2
        nu = rlv(i, j, k)/w(i, j, k, irho)
        numd = half*((rlvd(i-1, j, k)*w(i-1, j, k, irho)-rlv(i-1, j, k)*&
&         wd(i-1, j, k, irho))/w(i-1, j, k, irho)**2+nud)
        num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
        nupd = half*((rlvd(i+1, j, k)*w(i+1, j, k, irho)-rlv(i+1, j, k)*&
&         wd(i+1, j, k, irho))/w(i+1, j, k, irho)**2+nud)
        nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
        cdmd = cb3inv*((numd+(one+rsacb2)*nutmd)*ttm+(num+(one+rsacb2)*&
&         nutm)*ttmd)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdpd = cb3inv*((nupd+(one+rsacb2)*nutpd)*ttp+(nup+(one+rsacb2)*&
&         nutp)*ttpd)
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        if (cdm + cam .lt. zero) then
          c1m = zero
          c1md = 0.0_8
        else
          c1md = cdmd + camd
          c1m = cdm + cam
        end if
        if (cdp + cap .lt. zero) then
          c1p = zero
          c1pd = 0.0_8
        else
          c1pd = cdpd + capd
          c1p = cdp + cap
        end if
        c10d = c1md + c1pd
        c10 = c1m + c1p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dwd(i, j, k, idvt) = dwd(i, j, k, idvt) + c1md*w(i-1, j, k, itu1&
&         ) + c1m*wd(i-1, j, k, itu1) - c10d*w(i, j, k, itu1) - c10*wd(i&
&         , j, k, itu1) + c1pd*w(i+1, j, k, itu1) + c1p*wd(i+1, j, k, &
&         itu1)
        dw(i, j, k, idvt) = dw(i, j, k, idvt) + c1m*w(i-1, j, k, itu1) -&
&         c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
        b1 = -c1m
        c1 = c10
        d1 = -c1p
! update the central jacobian. for nonboundary cells this
! is simply c1. for boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! the boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
        if (i .eq. 2) then
          if (bmti1(j, k, itu1, itu1) .lt. zero) then
            max5 = zero
          else
            max5 = bmti1(j, k, itu1, itu1)
          end if
          qq(i, j, k) = qq(i, j, k) + c1 - b1*max5
        else if (i .eq. il) then
          if (bmti2(j, k, itu1, itu1) .lt. zero) then
            max6 = zero
          else
            max6 = bmti2(j, k, itu1, itu1)
          end if
          qq(i, j, k) = qq(i, j, k) + c1 - d1*max6
        else
          qq(i, j, k) = qq(i, j, k) + c1
        end if
      end do
    end do
  end do
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
  do k=2,kl
    do j=2,jl
      do i=2,il
        rblank = real(iblank(i, j, k), realtype)
        dwd(i, j, k, itu1) = -(rblank*(vold(i, j, k)*dw(i, j, k, idvt)+&
&         vol(i, j, k)*dwd(i, j, k, idvt)))
        dw(i, j, k, itu1) = -(vol(i, j, k)*dw(i, j, k, idvt)*rblank)
      end do
    end do
  end do
! initialize the wall function flags to .false.
  flagi2 = .false.
  flagil = .false.
  flagj2 = .false.
  flagjl = .false.
  flagk2 = .false.
  flagkl = .false.
! modify the rhs of the 1st internal cell, if wall functions
! are used; their value is determined by the table.
! return if only the residual must be computed.
  if (resonly) return
end subroutine sasolve_d

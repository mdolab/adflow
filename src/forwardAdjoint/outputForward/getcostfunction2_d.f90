   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of getcostfunction2 in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: funcvalues
   !   with respect to varying inputs: machgrid lengthref machcoef
   !                dragdirection liftdirection pointref gammainf
   !                pinf rhoinfdim pinfdim pref moment force cavitation
   !                sepsensor
   SUBROUTINE GETCOSTFUNCTION2_D(force, forced, moment, momentd, sepsensor&
   & , sepsensord, cavitation, cavitationd, alpha, beta, liftindex)
   ! Compute the value of the actual objective function based on the
   ! (summed) forces and moments and any other "extra" design
   ! variables. The index of the objective is determined by 'iDV'. This
   ! function is intended to be AD'ed in reverse mode. 
   USE INPUTTIMESPECTRAL
   USE COSTFUNCTIONS
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   USE INPUTTSSTABDERIV
   IMPLICIT NONE
   ! Input 
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral), INTENT(IN) &
   & :: force, moment
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral), INTENT(IN) &
   & :: forced, momentd
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral), INTENT(IN) :: &
   & sepsensor, cavitation
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral), INTENT(IN) :: &
   & sepsensord, cavitationd
   REAL(kind=realtype), INTENT(IN) :: alpha, beta
   ! Working
   REAL(kind=realtype) :: fact, factmoment, scaledim, ovrnts
   REAL(kind=realtype) :: factd, factmomentd, scaledimd
   REAL(kind=realtype), DIMENSION(3) :: cf, cm
   REAL(kind=realtype), DIMENSION(3) :: cfd, cmd
   REAL(kind=realtype) :: elasticmomentx, elasticmomenty, elasticmomentz
   REAL(kind=realtype), DIMENSION(ntimeintervalsspectral, 8) :: basecoef
   REAL(kind=realtype), DIMENSION(8) :: coef0, dcdalpha, dcdalphadot, &
   & dcdq, dcdqdot
   REAL(kind=realtype), DIMENSION(8) :: coef0d, dcdalphad, dcdalphadotd
   REAL(kind=realtype) :: bendingmoment
   REAL(kind=realtype) :: bendingmomentd
   INTEGER(kind=inttype) :: sps
   ! Generate constants
   scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
   scaledim = pref/pinf
   factd = -(two*surfaceref*lref**2*((gammainfd*pinf+gammainf*pinfd)*&
   &   machcoef**2*scaledim+gammainf*pinf*(2*machcoef*machcoefd*scaledim+&
   &   machcoef**2*scaledimd))/(gammainf*pinf*machcoef**2*surfaceref*lref**&
   &   2*scaledim)**2)
   fact = two/(gammainf*pinf*machcoef**2*surfaceref*lref**2*scaledim)
   factmomentd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*&
   &   lref)**2
   factmoment = fact/(lengthref*lref)
   ovrnts = one/ntimeintervalsspectral
   ! Pre-compute TS stability info if required:
   IF (tsstability) THEN
   CALL COMPUTETSDERIVATIVES_D(force, forced, moment, momentd, &
   &                         liftindex, coef0, coef0d, dcdalpha, dcdalphad&
   &                         , dcdalphadot, dcdalphadotd, dcdq, dcdqdot)
   ELSE
   dcdalphadotd = 0.0_8
   coef0d = 0.0_8
   dcdalphad = 0.0_8
   END IF
   funcvalues = zero
   funcvaluesd = 0.0_8
   ! Now we just compute each cost function:
   DO sps=1,ntimeintervalsspectral
   funcvaluesd(costfuncforcex) = funcvaluesd(costfuncforcex) + ovrnts*&
   &     forced(1, sps)
   funcvalues(costfuncforcex) = funcvalues(costfuncforcex) + ovrnts*&
   &     force(1, sps)
   funcvaluesd(costfuncforcey) = funcvaluesd(costfuncforcey) + ovrnts*&
   &     forced(2, sps)
   funcvalues(costfuncforcey) = funcvalues(costfuncforcey) + ovrnts*&
   &     force(2, sps)
   funcvaluesd(costfuncforcez) = funcvaluesd(costfuncforcez) + ovrnts*&
   &     forced(3, sps)
   funcvalues(costfuncforcez) = funcvalues(costfuncforcez) + ovrnts*&
   &     force(3, sps)
   funcvaluesd(costfuncmomx) = funcvaluesd(costfuncmomx) + ovrnts*&
   &     momentd(1, sps)
   funcvalues(costfuncmomx) = funcvalues(costfuncmomx) + ovrnts*moment(&
   &     1, sps)
   funcvaluesd(costfuncmomy) = funcvaluesd(costfuncmomy) + ovrnts*&
   &     momentd(2, sps)
   funcvalues(costfuncmomy) = funcvalues(costfuncmomy) + ovrnts*moment(&
   &     2, sps)
   funcvaluesd(costfuncmomz) = funcvaluesd(costfuncmomz) + ovrnts*&
   &     momentd(3, sps)
   funcvalues(costfuncmomz) = funcvalues(costfuncmomz) + ovrnts*moment(&
   &     3, sps)
   funcvaluesd(costfuncsepsensor) = funcvaluesd(costfuncsepsensor) + &
   &     ovrnts*sepsensord(sps)
   funcvalues(costfuncsepsensor) = funcvalues(costfuncsepsensor) + &
   &     ovrnts*sepsensor(sps)
   funcvaluesd(costfunccavitation) = funcvaluesd(costfunccavitation) + &
   &     ovrnts*cavitationd(sps)
   funcvalues(costfunccavitation) = funcvalues(costfunccavitation) + &
   &     ovrnts*cavitation(sps)
   ! Bending moment calc
   cmd = factmomentd*moment(:, sps) + factmoment*momentd(:, sps)
   cm = factmoment*moment(:, sps)
   cfd = factd*force(:, sps) + fact*forced(:, sps)
   cf = fact*force(:, sps)
   CALL COMPUTEROOTBENDINGMOMENT_D(cf, cfd, cm, cmd, liftindex, &
   &                             bendingmoment, bendingmomentd)
   funcvaluesd(costfuncbendingcoef) = funcvaluesd(costfuncbendingcoef) &
   &     + ovrnts*bendingmomentd
   funcvalues(costfuncbendingcoef) = funcvalues(costfuncbendingcoef) + &
   &     ovrnts*bendingmoment
   END DO
   funcvaluesd(costfuncforcexcoef) = funcvaluesd(costfuncforcex)*fact + &
   &   funcvalues(costfuncforcex)*factd
   funcvalues(costfuncforcexcoef) = funcvalues(costfuncforcex)*fact
   funcvaluesd(costfuncforceycoef) = funcvaluesd(costfuncforcey)*fact + &
   &   funcvalues(costfuncforcey)*factd
   funcvalues(costfuncforceycoef) = funcvalues(costfuncforcey)*fact
   funcvaluesd(costfuncforcezcoef) = funcvaluesd(costfuncforcez)*fact + &
   &   funcvalues(costfuncforcez)*factd
   funcvalues(costfuncforcezcoef) = funcvalues(costfuncforcez)*fact
   funcvaluesd(costfuncmomxcoef) = funcvaluesd(costfuncmomx)*factmoment +&
   &   funcvalues(costfuncmomx)*factmomentd
   funcvalues(costfuncmomxcoef) = funcvalues(costfuncmomx)*factmoment
   funcvaluesd(costfuncmomycoef) = funcvaluesd(costfuncmomy)*factmoment +&
   &   funcvalues(costfuncmomy)*factmomentd
   funcvalues(costfuncmomycoef) = funcvalues(costfuncmomy)*factmoment
   funcvaluesd(costfuncmomzcoef) = funcvaluesd(costfuncmomz)*factmoment +&
   &   funcvalues(costfuncmomz)*factmomentd
   funcvalues(costfuncmomzcoef) = funcvalues(costfuncmomz)*factmoment
   funcvaluesd(costfunclift) = funcvaluesd(costfuncforcex)*liftdirection(&
   &   1) + funcvalues(costfuncforcex)*liftdirectiond(1) + funcvaluesd(&
   &   costfuncforcey)*liftdirection(2) + funcvalues(costfuncforcey)*&
   &   liftdirectiond(2) + funcvaluesd(costfuncforcez)*liftdirection(3) + &
   &   funcvalues(costfuncforcez)*liftdirectiond(3)
   funcvalues(costfunclift) = funcvalues(costfuncforcex)*liftdirection(1)&
   &   + funcvalues(costfuncforcey)*liftdirection(2) + funcvalues(&
   &   costfuncforcez)*liftdirection(3)
   funcvaluesd(costfuncdrag) = funcvaluesd(costfuncforcex)*dragdirection(&
   &   1) + funcvalues(costfuncforcex)*dragdirectiond(1) + funcvaluesd(&
   &   costfuncforcey)*dragdirection(2) + funcvalues(costfuncforcey)*&
   &   dragdirectiond(2) + funcvaluesd(costfuncforcez)*dragdirection(3) + &
   &   funcvalues(costfuncforcez)*dragdirectiond(3)
   funcvalues(costfuncdrag) = funcvalues(costfuncforcex)*dragdirection(1)&
   &   + funcvalues(costfuncforcey)*dragdirection(2) + funcvalues(&
   &   costfuncforcez)*dragdirection(3)
   funcvaluesd(costfuncliftcoef) = funcvaluesd(costfunclift)*fact + &
   &   funcvalues(costfunclift)*factd
   funcvalues(costfuncliftcoef) = funcvalues(costfunclift)*fact
   funcvaluesd(costfuncdragcoef) = funcvaluesd(costfuncdrag)*fact + &
   &   funcvalues(costfuncdrag)*factd
   funcvalues(costfuncdragcoef) = funcvalues(costfuncdrag)*fact
   ! -------------------- Time Spectral Objectives ------------------
   funcvaluesd(costfunccl0) = coef0d(1)
   funcvalues(costfunccl0) = coef0(1)
   funcvaluesd(costfunccd0) = coef0d(2)
   funcvalues(costfunccd0) = coef0(2)
   funcvaluesd(costfunccm0) = coef0d(8)
   funcvalues(costfunccm0) = coef0(8)
   funcvaluesd(costfuncclalpha) = dcdalphad(1)
   funcvalues(costfuncclalpha) = dcdalpha(1)
   funcvaluesd(costfunccdalpha) = dcdalphad(2)
   funcvalues(costfunccdalpha) = dcdalpha(2)
   funcvaluesd(costfunccmzalpha) = dcdalphad(8)
   funcvalues(costfunccmzalpha) = dcdalpha(8)
   funcvaluesd(costfuncclalphadot) = dcdalphadotd(1)
   funcvalues(costfuncclalphadot) = dcdalphadot(1)
   funcvaluesd(costfunccdalphadot) = dcdalphadotd(2)
   funcvalues(costfunccdalphadot) = dcdalphadot(2)
   funcvaluesd(costfunccmzalphadot) = dcdalphadotd(8)
   funcvalues(costfunccmzalphadot) = dcdalphadot(8)
   funcvaluesd(costfuncclq) = 0.0_8
   funcvalues(costfuncclq) = dcdq(1)
   funcvaluesd(costfunccdq) = 0.0_8
   funcvalues(costfunccdq) = dcdq(2)
   funcvaluesd(costfunccmzq) = 0.0_8
   funcvalues(costfunccmzq) = dcdq(8)
   funcvaluesd(costfuncclqdot) = 0.0_8
   funcvalues(costfuncclqdot) = dcdqdot(1)
   funcvaluesd(costfunccdqdot) = 0.0_8
   funcvalues(costfunccdqdot) = dcdqdot(2)
   funcvaluesd(costfunccmzqdot) = 0.0_8
   funcvalues(costfunccmzqdot) = dcdqdot(8)
   END SUBROUTINE GETCOSTFUNCTION2_D

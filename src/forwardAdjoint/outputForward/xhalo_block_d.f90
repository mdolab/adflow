   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of xhalo_block in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *x
   !   with respect to varying inputs: *x
   !   Plus diff mem management of: x:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          xhalo.f90                                       *
   !      * Author:        Edwin van der Weide,C.A.(Sandy) Mader            *
   !      * Starting date: 02-23-2003                                      *
   !      * Last modified: 08-12-2009                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE XHALO_BLOCK_D()
   !
   !      ******************************************************************
   !      *                                                                *
   !      * xhalo determines the coordinates of the nodal halo's.          *
   !      * First it sets all halo coordinates by simple extrapolation,    *
   !      * then the symmetry planes are treated (also the unit normal of  *
   !      * symmetry planes are determined) and finally an exchange is     *
   !      * made for the internal halo's.                                  *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_D
   USE BCTYPES
   USE COMMUNICATION
   USE INPUTTIMESPECTRAL
   IMPLICIT NONE
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: mm, i, j, k
   INTEGER(kind=inttype) :: ibeg, iend, jbeg, jend, iimax, jjmax
   LOGICAL :: err
   REAL(kind=realtype) :: length, dot
   REAL(kind=realtype) :: dotd
   LOGICAL :: imininternal, jmininternal, kmininternal
   LOGICAL :: imaxinternal, jmaxinternal, kmaxinternal
   REAL(kind=realtype), DIMENSION(3) :: v1, v2, norm
   REAL(kind=realtype), DIMENSION(3) :: v1d
   INTRINSIC SQRT
   REAL(kind=realtype) :: arg1
   !
   !          **************************************************************
   !          *                                                            *
   !          * Extrapolation of the coordinates. First extrapolation in   *
   !          * i-direction, without halo's, followed by extrapolation in  *
   !          * j-direction, with i-halo's and finally extrapolation in    *
   !          * k-direction, with both i- and j-halo's. In this way also   *
   !          * the indirect halo's get a value, albeit a bit arbitrary.   *
   !          *                                                            *
   !          **************************************************************
   !
   imininternal = .false.
   jmininternal = .false.
   kmininternal = .false.
   imaxinternal = .false.
   jmaxinternal = .false.
   kmaxinternal = .false.
   ! Loop over all the subfaces to determine which ones do NOT need to be extrapolated.
   loopsubface:DO mm=1,nsubface
   IF (bctype(mm) .EQ. b2bmatch) THEN
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   imininternal = .true.
   CASE (imax) 
   imaxinternal = .true.
   CASE (jmin) 
   jmininternal = .true.
   CASE (jmax) 
   jmaxinternal = .true.
   CASE (kmin) 
   kmininternal = .true.
   CASE (kmax) 
   kmaxinternal = .true.
   END SELECT
   END IF
   END DO loopsubface
   ! Re-loop back over and see if any subface that is NOT B2BMatch is
   ! on the same logical face as a Block2Block. We cannot deal with
   ! properly so will print an error and quit
   err = .false.
   loopsubface2:DO mm=1,nsubface
   IF (bctype(mm) .NE. b2bmatch) THEN
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   IF (imininternal) err = .true.
   CASE (imax) 
   IF (imaxinternal) err = .true.
   CASE (jmin) 
   IF (jmininternal) err = .true.
   CASE (jmax) 
   IF (jmaxinternal) err = .true.
   CASE (kmin) 
   IF (kmininternal) err = .true.
   CASE (kmax) 
   IF (kmaxinternal) err = .true.
   END SELECT
   END IF
   END DO loopsubface2
   IF (err) THEN
   PRINT*, &
   &   'Detected a block-to-block boundary condition on the same face'
   PRINT*, 'as another boundary condition. This is not supported.'
   STOP
   ELSE
   ! Extrapolation in i-direction.
   DO k=1,kl
   DO j=1,jl
   IF (.NOT.imininternal) THEN
   xd(0, j, k, 1) = two*xd(1, j, k, 1) - xd(2, j, k, 1)
   x(0, j, k, 1) = two*x(1, j, k, 1) - x(2, j, k, 1)
   xd(0, j, k, 2) = two*xd(1, j, k, 2) - xd(2, j, k, 2)
   x(0, j, k, 2) = two*x(1, j, k, 2) - x(2, j, k, 2)
   xd(0, j, k, 3) = two*xd(1, j, k, 3) - xd(2, j, k, 3)
   x(0, j, k, 3) = two*x(1, j, k, 3) - x(2, j, k, 3)
   END IF
   IF (.NOT.imaxinternal) THEN
   xd(ie, j, k, 1) = two*xd(il, j, k, 1) - xd(nx, j, k, 1)
   x(ie, j, k, 1) = two*x(il, j, k, 1) - x(nx, j, k, 1)
   xd(ie, j, k, 2) = two*xd(il, j, k, 2) - xd(nx, j, k, 2)
   x(ie, j, k, 2) = two*x(il, j, k, 2) - x(nx, j, k, 2)
   xd(ie, j, k, 3) = two*xd(il, j, k, 3) - xd(nx, j, k, 3)
   x(ie, j, k, 3) = two*x(il, j, k, 3) - x(nx, j, k, 3)
   END IF
   END DO
   END DO
   ! Extrapolation in j-direction.
   DO k=1,kl
   DO i=0,ie
   IF (.NOT.jmininternal) THEN
   xd(i, 0, k, 1) = two*xd(i, 1, k, 1) - xd(i, 2, k, 1)
   x(i, 0, k, 1) = two*x(i, 1, k, 1) - x(i, 2, k, 1)
   xd(i, 0, k, 2) = two*xd(i, 1, k, 2) - xd(i, 2, k, 2)
   x(i, 0, k, 2) = two*x(i, 1, k, 2) - x(i, 2, k, 2)
   xd(i, 0, k, 3) = two*xd(i, 1, k, 3) - xd(i, 2, k, 3)
   x(i, 0, k, 3) = two*x(i, 1, k, 3) - x(i, 2, k, 3)
   END IF
   IF (.NOT.jmaxinternal) THEN
   xd(i, je, k, 1) = two*xd(i, jl, k, 1) - xd(i, ny, k, 1)
   x(i, je, k, 1) = two*x(i, jl, k, 1) - x(i, ny, k, 1)
   xd(i, je, k, 2) = two*xd(i, jl, k, 2) - xd(i, ny, k, 2)
   x(i, je, k, 2) = two*x(i, jl, k, 2) - x(i, ny, k, 2)
   xd(i, je, k, 3) = two*xd(i, jl, k, 3) - xd(i, ny, k, 3)
   x(i, je, k, 3) = two*x(i, jl, k, 3) - x(i, ny, k, 3)
   END IF
   END DO
   END DO
   ! Extrapolation in k-direction.
   DO j=0,je
   DO i=0,ie
   IF (.NOT.kmininternal) THEN
   xd(i, j, 0, 1) = two*xd(i, j, 1, 1) - xd(i, j, 2, 1)
   x(i, j, 0, 1) = two*x(i, j, 1, 1) - x(i, j, 2, 1)
   xd(i, j, 0, 2) = two*xd(i, j, 1, 2) - xd(i, j, 2, 2)
   x(i, j, 0, 2) = two*x(i, j, 1, 2) - x(i, j, 2, 2)
   xd(i, j, 0, 3) = two*xd(i, j, 1, 3) - xd(i, j, 2, 3)
   x(i, j, 0, 3) = two*x(i, j, 1, 3) - x(i, j, 2, 3)
   END IF
   IF (.NOT.kmaxinternal) THEN
   xd(i, j, ke, 1) = two*xd(i, j, kl, 1) - xd(i, j, nz, 1)
   x(i, j, ke, 1) = two*x(i, j, kl, 1) - x(i, j, nz, 1)
   xd(i, j, ke, 2) = two*xd(i, j, kl, 2) - xd(i, j, nz, 2)
   x(i, j, ke, 2) = two*x(i, j, kl, 2) - x(i, j, nz, 2)
   xd(i, j, ke, 3) = two*xd(i, j, kl, 3) - xd(i, j, nz, 3)
   x(i, j, ke, 3) = two*x(i, j, kl, 3) - x(i, j, nz, 3)
   END IF
   END DO
   END DO
   v1d = 0.0_8
   !
   !          **************************************************************
   !          *                                                            *
   !          * Mirror the halo coordinates adjacent to the symmetry       *
   !          * planes                                                     *
   !          *                                                            *
   !          **************************************************************
   !
   ! Loop over boundary subfaces.
   loopbocos:DO mm=1,nbocos
   ! The actual correction of the coordinates only takes
   ! place for symmetry planes.
   IF (bctype(mm) .EQ. symm) THEN
   ! Set some variables, depending on the block face on
   ! which the subface is located.
   norm(1) = bcdata(mm)%symnorm(1)
   norm(2) = bcdata(mm)%symnorm(2)
   norm(3) = bcdata(mm)%symnorm(3)
   arg1 = norm(1)**2 + norm(2)**2 + norm(3)**2
   length = SQRT(arg1)
   ! Compute the unit normal of the subface.
   norm(1) = norm(1)/length
   norm(2) = norm(2)/length
   norm(3) = norm(3)/length
   ! See xhalo_block for comments for below:
   IF (length .GT. eps) THEN
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   ibeg = jnbeg(mm)
   iend = jnend(mm)
   iimax = jl
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   DO j=jbeg,jend
   DO i=ibeg,iend
   v1d(1) = xd(1, i, j, 1) - xd(2, i, j, 1)
   v1(1) = x(1, i, j, 1) - x(2, i, j, 1)
   v1d(2) = xd(1, i, j, 2) - xd(2, i, j, 2)
   v1(2) = x(1, i, j, 2) - x(2, i, j, 2)
   v1d(3) = xd(1, i, j, 3) - xd(2, i, j, 3)
   v1(3) = x(1, i, j, 3) - x(2, i, j, 3)
   dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
   &                 )
   dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
   xd(0, i, j, 1) = xd(2, i, j, 1) + norm(1)*dotd
   x(0, i, j, 1) = x(2, i, j, 1) + dot*norm(1)
   xd(0, i, j, 2) = xd(2, i, j, 2) + norm(2)*dotd
   x(0, i, j, 2) = x(2, i, j, 2) + dot*norm(2)
   xd(0, i, j, 3) = xd(2, i, j, 3) + norm(3)*dotd
   x(0, i, j, 3) = x(2, i, j, 3) + dot*norm(3)
   END DO
   END DO
   CASE (imax) 
   ibeg = jnbeg(mm)
   iend = jnend(mm)
   iimax = jl
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   DO j=jbeg,jend
   DO i=ibeg,iend
   v1d(1) = xd(il, i, j, 1) - xd(nx, i, j, 1)
   v1(1) = x(il, i, j, 1) - x(nx, i, j, 1)
   v1d(2) = xd(il, i, j, 2) - xd(nx, i, j, 2)
   v1(2) = x(il, i, j, 2) - x(nx, i, j, 2)
   v1d(3) = xd(il, i, j, 3) - xd(nx, i, j, 3)
   v1(3) = x(il, i, j, 3) - x(nx, i, j, 3)
   dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
   &                 )
   dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
   xd(ie, i, j, 1) = xd(nx, i, j, 1) + norm(1)*dotd
   x(ie, i, j, 1) = x(nx, i, j, 1) + dot*norm(1)
   xd(ie, i, j, 2) = xd(nx, i, j, 2) + norm(2)*dotd
   x(ie, i, j, 2) = x(nx, i, j, 2) + dot*norm(2)
   xd(ie, i, j, 3) = xd(nx, i, j, 3) + norm(3)*dotd
   x(ie, i, j, 3) = x(nx, i, j, 3) + dot*norm(3)
   END DO
   END DO
   CASE (jmin) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   DO j=jbeg,jend
   DO i=ibeg,iend
   v1d(1) = xd(i, 1, j, 1) - xd(i, 2, j, 1)
   v1(1) = x(i, 1, j, 1) - x(i, 2, j, 1)
   v1d(2) = xd(i, 1, j, 2) - xd(i, 2, j, 2)
   v1(2) = x(i, 1, j, 2) - x(i, 2, j, 2)
   v1d(3) = xd(i, 1, j, 3) - xd(i, 2, j, 3)
   v1(3) = x(i, 1, j, 3) - x(i, 2, j, 3)
   dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
   &                 )
   dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
   xd(i, 0, j, 1) = xd(i, 2, j, 1) + norm(1)*dotd
   x(i, 0, j, 1) = x(i, 2, j, 1) + dot*norm(1)
   xd(i, 0, j, 2) = xd(i, 2, j, 2) + norm(2)*dotd
   x(i, 0, j, 2) = x(i, 2, j, 2) + dot*norm(2)
   xd(i, 0, j, 3) = xd(i, 2, j, 3) + norm(3)*dotd
   x(i, 0, j, 3) = x(i, 2, j, 3) + dot*norm(3)
   END DO
   END DO
   CASE (jmax) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = knbeg(mm)
   jend = knend(mm)
   jjmax = kl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   DO j=jbeg,jend
   DO i=ibeg,iend
   v1d(1) = xd(i, jl, j, 1) - xd(i, ny, j, 1)
   v1(1) = x(i, jl, j, 1) - x(i, ny, j, 1)
   v1d(2) = xd(i, jl, j, 2) - xd(i, ny, j, 2)
   v1(2) = x(i, jl, j, 2) - x(i, ny, j, 2)
   v1d(3) = xd(i, jl, j, 3) - xd(i, ny, j, 3)
   v1(3) = x(i, jl, j, 3) - x(i, ny, j, 3)
   dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
   &                 )
   dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
   xd(i, je, j, 1) = xd(i, ny, j, 1) + norm(1)*dotd
   x(i, je, j, 1) = x(i, ny, j, 1) + dot*norm(1)
   xd(i, je, j, 2) = xd(i, ny, j, 2) + norm(2)*dotd
   x(i, je, j, 2) = x(i, ny, j, 2) + dot*norm(2)
   xd(i, je, j, 3) = xd(i, ny, j, 3) + norm(3)*dotd
   x(i, je, j, 3) = x(i, ny, j, 3) + dot*norm(3)
   END DO
   END DO
   CASE (kmin) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = jnbeg(mm)
   jend = jnend(mm)
   jjmax = jl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   DO j=jbeg,jend
   DO i=ibeg,iend
   v1d(1) = xd(i, j, 1, 1) - xd(i, j, 2, 1)
   v1(1) = x(i, j, 1, 1) - x(i, j, 2, 1)
   v1d(2) = xd(i, j, 1, 2) - xd(i, j, 2, 2)
   v1(2) = x(i, j, 1, 2) - x(i, j, 2, 2)
   v1d(3) = xd(i, j, 1, 3) - xd(i, j, 2, 3)
   v1(3) = x(i, j, 1, 3) - x(i, j, 2, 3)
   dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
   &                 )
   dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
   xd(i, j, 0, 1) = xd(i, j, 2, 1) + norm(1)*dotd
   x(i, j, 0, 1) = x(i, j, 2, 1) + dot*norm(1)
   xd(i, j, 0, 2) = xd(i, j, 2, 2) + norm(2)*dotd
   x(i, j, 0, 2) = x(i, j, 2, 2) + dot*norm(2)
   xd(i, j, 0, 3) = xd(i, j, 2, 3) + norm(3)*dotd
   x(i, j, 0, 3) = x(i, j, 2, 3) + dot*norm(3)
   END DO
   END DO
   CASE (kmax) 
   ibeg = inbeg(mm)
   iend = inend(mm)
   iimax = il
   jbeg = jnbeg(mm)
   jend = jnend(mm)
   jjmax = jl
   IF (ibeg .EQ. 1) ibeg = 0
   IF (iend .EQ. iimax) iend = iimax + 1
   IF (jbeg .EQ. 1) jbeg = 0
   IF (jend .EQ. jjmax) jend = jjmax + 1
   DO j=jbeg,jend
   DO i=ibeg,iend
   v1d(1) = xd(i, j, kl, 1) - xd(i, j, nz, 1)
   v1(1) = x(i, j, kl, 1) - x(i, j, nz, 1)
   v1d(2) = xd(i, j, kl, 2) - xd(i, j, nz, 2)
   v1(2) = x(i, j, kl, 2) - x(i, j, nz, 2)
   v1d(3) = xd(i, j, kl, 3) - xd(i, j, nz, 3)
   v1(3) = x(i, j, kl, 3) - x(i, j, nz, 3)
   dotd = two*(norm(1)*v1d(1)+norm(2)*v1d(2)+norm(3)*v1d(3)&
   &                 )
   dot = two*(v1(1)*norm(1)+v1(2)*norm(2)+v1(3)*norm(3))
   xd(i, j, ke, 1) = xd(i, j, nz, 1) + norm(1)*dotd
   x(i, j, ke, 1) = x(i, j, nz, 1) + dot*norm(1)
   xd(i, j, ke, 2) = xd(i, j, nz, 2) + norm(2)*dotd
   x(i, j, ke, 2) = x(i, j, nz, 2) + dot*norm(2)
   xd(i, j, ke, 3) = xd(i, j, nz, 3) + norm(3)*dotd
   x(i, j, ke, 3) = x(i, j, nz, 3) + dot*norm(3)
   END DO
   END DO
   END SELECT
   END IF
   END IF
   END DO loopbocos
   END IF
   END SUBROUTINE XHALO_BLOCK_D

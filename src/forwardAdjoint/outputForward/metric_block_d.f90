   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of metric_block in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *vol *si *sj *sk *(*bcdata.norm)
   !   with respect to varying inputs: *x
   !   Plus diff mem management of: x:in vol:in si:in sj:in sk:in
   !                bcdata:in *bcdata.norm:in
   SUBROUTINE METRIC_BLOCK_D()
   ! This is COPY of metric.f90. It was necessary to copy this file
   ! since there is debugging stuff in the original that is not
   ! necessary for AD.
   USE BCTYPES
   USE BLOCKPOINTERS
   USE CGNSGRID
   USE COMMUNICATION
   USE INPUTTIMESPECTRAL
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   IMPLICIT NONE
   !
   !      Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: thresvolume=1.e-2_realType
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, k, n, m, l
   INTEGER(kind=inttype) :: mm
   REAL(kind=realtype) :: fact, mult
   REAL(kind=realtype) :: factd
   REAL(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
   REAL(kind=realtype) :: xpd, ypd, zpd, vp1d, vp2d, vp3d, vp4d, vp5d, &
   & vp6d
   REAL(kind=realtype), DIMENSION(3) :: v1, v2
   REAL(kind=realtype), DIMENSION(3) :: v1d, v2d
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssd
   INTERFACE 
   SUBROUTINE SETSSMETRIC(nn, ss)
   USE BCTYPES
   USE BLOCKPOINTERS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
   END SUBROUTINE SETSSMETRIC
   SUBROUTINE RESETSSMETRIC(nn, ss)
   USE BCTYPES
   USE BLOCKPOINTERS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
   END SUBROUTINE RESETSSMETRIC
   END INTERFACE
      INTERFACE 
   SUBROUTINE SETSSMETRIC_D(nn, ss, ssd)
   USE BCTYPES
   USE BLOCKPOINTERS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssd
   END SUBROUTINE SETSSMETRIC_D
   END INTERFACE
      LOGICAL :: checkk, checkj, checki, checkall
   INTRINSIC ABS
   INTRINSIC SQRT
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   INTEGER :: ii1
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Compute the volumes. The hexahedron is split into 6 pyramids
   ! whose volumes are computed. The volume is positive for a
   ! right handed block.
   ! Initialize the volumes to zero. The reasons is that the second
   ! level halo's must be initialized to zero and for convenience
   ! all the volumes are set to zero.
   vold = 0.0_8
   vol = zero
   vold = 0.0_8
   vp1d = 0.0_8
   vp2d = 0.0_8
   vp3d = 0.0_8
   vp4d = 0.0_8
   vp5d = 0.0_8
   vp6d = 0.0_8
   DO k=1,ke
   n = k - 1
   checkk = .true.
   IF (k .EQ. 1 .OR. k .EQ. ke) checkk = .false.
   DO j=1,je
   m = j - 1
   checkj = .true.
   IF (j .EQ. 1 .OR. j .EQ. je) checkj = .false.
   DO i=1,ie
   l = i - 1
   checki = .true.
   IF (i .EQ. 1 .OR. i .EQ. ie) checki = .false.
   ! Determine whether or not the voluem must be checked for
   ! quality. Only owned volumes are checked, not halo's.
   checkall = .false.
   IF (checkk .AND. checkj .AND. checki) checkall = .true.
   ! Compute the coordinates of the center of gravity.
   xpd = eighth*(xd(i, j, k, 1)+xd(i, m, k, 1)+xd(i, m, n, 1)+xd(i&
   &         , j, n, 1)+xd(l, j, k, 1)+xd(l, m, k, 1)+xd(l, m, n, 1)+xd(l, &
   &         j, n, 1))
   xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j, n&
   &         , 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n, 1))
   ypd = eighth*(xd(i, j, k, 2)+xd(i, m, k, 2)+xd(i, m, n, 2)+xd(i&
   &         , j, n, 2)+xd(l, j, k, 2)+xd(l, m, k, 2)+xd(l, m, n, 2)+xd(l, &
   &         j, n, 2))
   yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j, n&
   &         , 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n, 2))
   zpd = eighth*(xd(i, j, k, 3)+xd(i, m, k, 3)+xd(i, m, n, 3)+xd(i&
   &         , j, n, 3)+xd(l, j, k, 3)+xd(l, m, k, 3)+xd(l, m, n, 3)+xd(l, &
   &         j, n, 3))
   zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j, n&
   &         , 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n, 3))
   ! Compute the volumes of the 6 sub pyramids. The
   ! arguments of volpym must be such that for a (regular)
   ! right handed hexahedron all volumes are positive.
   CALL VOLPYM_D(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd(i&
   &               , j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, j, n, 1)&
   &               , xd(i, j, n, 1), x(i, j, n, 2), xd(i, j, n, 2), x(i, j&
   &               , n, 3), xd(i, j, n, 3), x(i, m, n, 1), xd(i, m, n, 1), &
   &               x(i, m, n, 2), xd(i, m, n, 2), x(i, m, n, 3), xd(i, m, n&
   &               , 3), x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i&
   &               , m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), vp1, vp1d)
   CALL VOLPYM_D(x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l&
   &               , j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), x(l, m, k, 1)&
   &               , xd(l, m, k, 1), x(l, m, k, 2), xd(l, m, k, 2), x(l, m&
   &               , k, 3), xd(l, m, k, 3), x(l, m, n, 1), xd(l, m, n, 1), &
   &               x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), xd(l, m, n&
   &               , 3), x(l, j, n, 1), xd(l, j, n, 1), x(l, j, n, 2), xd(l&
   &               , j, n, 2), x(l, j, n, 3), xd(l, j, n, 3), vp2, vp2d)
   CALL VOLPYM_D(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd(i&
   &               , j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(l, j, k, 1)&
   &               , xd(l, j, k, 1), x(l, j, k, 2), xd(l, j, k, 2), x(l, j&
   &               , k, 3), xd(l, j, k, 3), x(l, j, n, 1), xd(l, j, n, 1), &
   &               x(l, j, n, 2), xd(l, j, n, 2), x(l, j, n, 3), xd(l, j, n&
   &               , 3), x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i&
   &               , j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), vp3, vp3d)
   CALL VOLPYM_D(x(i, m, k, 1), xd(i, m, k, 1), x(i, m, k, 2), xd(i&
   &               , m, k, 2), x(i, m, k, 3), xd(i, m, k, 3), x(i, m, n, 1)&
   &               , xd(i, m, n, 1), x(i, m, n, 2), xd(i, m, n, 2), x(i, m&
   &               , n, 3), xd(i, m, n, 3), x(l, m, n, 1), xd(l, m, n, 1), &
   &               x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), xd(l, m, n&
   &               , 3), x(l, m, k, 1), xd(l, m, k, 1), x(l, m, k, 2), xd(l&
   &               , m, k, 2), x(l, m, k, 3), xd(l, m, k, 3), vp4, vp4d)
   CALL VOLPYM_D(x(i, j, k, 1), xd(i, j, k, 1), x(i, j, k, 2), xd(i&
   &               , j, k, 2), x(i, j, k, 3), xd(i, j, k, 3), x(i, m, k, 1)&
   &               , xd(i, m, k, 1), x(i, m, k, 2), xd(i, m, k, 2), x(i, m&
   &               , k, 3), xd(i, m, k, 3), x(l, m, k, 1), xd(l, m, k, 1), &
   &               x(l, m, k, 2), xd(l, m, k, 2), x(l, m, k, 3), xd(l, m, k&
   &               , 3), x(l, j, k, 1), xd(l, j, k, 1), x(l, j, k, 2), xd(l&
   &               , j, k, 2), x(l, j, k, 3), xd(l, j, k, 3), vp5, vp5d)
   CALL VOLPYM_D(x(i, j, n, 1), xd(i, j, n, 1), x(i, j, n, 2), xd(i&
   &               , j, n, 2), x(i, j, n, 3), xd(i, j, n, 3), x(l, j, n, 1)&
   &               , xd(l, j, n, 1), x(l, j, n, 2), xd(l, j, n, 2), x(l, j&
   &               , n, 3), xd(l, j, n, 3), x(l, m, n, 1), xd(l, m, n, 1), &
   &               x(l, m, n, 2), xd(l, m, n, 2), x(l, m, n, 3), xd(l, m, n&
   &               , 3), x(i, m, n, 1), xd(i, m, n, 1), x(i, m, n, 2), xd(i&
   &               , m, n, 2), x(i, m, n, 3), xd(i, m, n, 3), vp6, vp6d)
   ! Set the volume to 1/6 of the sum of the volumes of the
   ! pyramid. Remember that volpym computes 6 times the
   ! volume.
   vold(i, j, k) = sixth*(vp1d+vp2d+vp3d+vp4d+vp5d+vp6d)
   vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
   IF (vol(i, j, k) .GE. 0.) THEN
   vol(i, j, k) = vol(i, j, k)
   ELSE
   vold(i, j, k) = -vold(i, j, k)
   vol(i, j, k) = -vol(i, j, k)
   END IF
   END DO
   END DO
   END DO
   ! Some additional safety stuff for halo volumes.
   DO k=2,kl
   DO j=2,jl
   IF (vol(1, j, k) .LE. eps) THEN
   vold(1, j, k) = vold(2, j, k)
   vol(1, j, k) = vol(2, j, k)
   END IF
   IF (vol(ie, j, k) .LE. eps) THEN
   vold(ie, j, k) = vold(il, j, k)
   vol(ie, j, k) = vol(il, j, k)
   END IF
   END DO
   END DO
   DO k=2,kl
   DO i=1,ie
   IF (vol(i, 1, k) .LE. eps) THEN
   vold(i, 1, k) = vold(i, 2, k)
   vol(i, 1, k) = vol(i, 2, k)
   END IF
   IF (vol(i, je, k) .LE. eps) THEN
   vold(i, je, k) = vold(i, jl, k)
   vol(i, je, k) = vol(i, jl, k)
   END IF
   END DO
   END DO
   DO j=1,je
   DO i=1,ie
   IF (vol(i, j, 1) .LE. eps) THEN
   vold(i, j, 1) = vold(i, j, 2)
   vol(i, j, 1) = vol(i, j, 2)
   END IF
   IF (vol(i, j, ke) .LE. eps) THEN
   vold(i, j, ke) = vold(i, j, kl)
   vol(i, j, ke) = vol(i, j, kl)
   END IF
   END DO
   END DO
   ! Set the factor in the surface normals computation. For a
   ! left handed block this factor is negative, such that the
   ! normals still point in the direction of increasing index.
   ! The formulae used later on assume a right handed block
   ! and fact is used to correct this for a left handed block,
   ! as well as the scaling factor of 0.5
   IF (righthanded) THEN
   fact = half
   sid = 0.0_8
   v1d = 0.0_8
   v2d = 0.0_8
   ELSE
   fact = -half
   sid = 0.0_8
   v1d = 0.0_8
   v2d = 0.0_8
   END IF
   ! Check if both positive and negative volumes occur. If so,
   ! the block is bad and the counter nBlockBad is updated.
   !
   !          **************************************************************
   !          *                                                            *
   !          * Computation of the face normals in i-, j- and k-direction. *
   !          * Formula's are valid for a right handed block; for a left   *
   !          * handed block the correct orientation is obtained via fact. *
   !          * The normals point in the direction of increasing index.    *
   !          * The absolute value of fact is 0.5, because the cross       *
   !          * product of the two diagonals is twice the normal vector.   *
   !          *                                                            *
   !          * Note that also the normals of the first level halo cells   *
   !          * are computed. These are needed for the viscous fluxes.     *
   !          *                                                            *
   !          **************************************************************
   !
   ! Projected areas of cell faces in the i direction.
   DO k=1,ke
   n = k - 1
   DO j=1,je
   m = j - 1
   DO i=0,ie
   ! Determine the two diagonal vectors of the face.
   v1d(1) = xd(i, j, n, 1) - xd(i, m, k, 1)
   v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
   v1d(2) = xd(i, j, n, 2) - xd(i, m, k, 2)
   v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
   v1d(3) = xd(i, j, n, 3) - xd(i, m, k, 3)
   v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
   v2d(1) = xd(i, j, k, 1) - xd(i, m, n, 1)
   v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
   v2d(2) = xd(i, j, k, 2) - xd(i, m, n, 2)
   v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
   v2d(3) = xd(i, j, k, 3) - xd(i, m, n, 3)
   v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   sid(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-&
   &         v1(3)*v2d(2))
   si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   sid(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-&
   &         v1(1)*v2d(3))
   si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   sid(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-&
   &         v1(2)*v2d(1))
   si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   sjd = 0.0_8
   ! Projected areas of cell faces in the j direction.
   DO k=1,ke
   n = k - 1
   DO j=0,je
   DO i=1,ie
   l = i - 1
   ! Determine the two diagonal vectors of the face.
   v1d(1) = xd(i, j, n, 1) - xd(l, j, k, 1)
   v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
   v1d(2) = xd(i, j, n, 2) - xd(l, j, k, 2)
   v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
   v1d(3) = xd(i, j, n, 3) - xd(l, j, k, 3)
   v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
   v2d(1) = xd(l, j, n, 1) - xd(i, j, k, 1)
   v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
   v2d(2) = xd(l, j, n, 2) - xd(i, j, k, 2)
   v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
   v2d(3) = xd(l, j, n, 3) - xd(i, j, k, 3)
   v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   sjd(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-&
   &         v1(3)*v2d(2))
   sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   sjd(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-&
   &         v1(1)*v2d(3))
   sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   sjd(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-&
   &         v1(2)*v2d(1))
   sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   skd = 0.0_8
   ! Projected areas of cell faces in the k direction.
   DO k=0,ke
   DO j=1,je
   m = j - 1
   DO i=1,ie
   l = i - 1
   ! Determine the two diagonal vectors of the face.
   v1d(1) = xd(i, j, k, 1) - xd(l, m, k, 1)
   v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
   v1d(2) = xd(i, j, k, 2) - xd(l, m, k, 2)
   v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
   v1d(3) = xd(i, j, k, 3) - xd(l, m, k, 3)
   v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
   v2d(1) = xd(l, j, k, 1) - xd(i, m, k, 1)
   v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
   v2d(2) = xd(l, j, k, 2) - xd(i, m, k, 2)
   v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
   v2d(3) = xd(l, j, k, 3) - xd(i, m, k, 3)
   v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
   ! The face normal, which is the cross product of the two
   ! diagonal vectors times fact; remember that fact is
   ! either -0.5 or 0.5.
   skd(i, j, k, 1) = fact*(v1d(2)*v2(3)+v1(2)*v2d(3)-v1d(3)*v2(2)-&
   &         v1(3)*v2d(2))
   sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
   skd(i, j, k, 2) = fact*(v1d(3)*v2(1)+v1(3)*v2d(1)-v1d(1)*v2(3)-&
   &         v1(1)*v2d(3))
   sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
   skd(i, j, k, 3) = fact*(v1d(1)*v2(2)+v1(1)*v2d(2)-v1d(2)*v2(1)-&
   &         v1(2)*v2d(1))
   sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
   END DO
   END DO
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%norm = 0.0_8
   END DO
   !
   !          **************************************************************
   !          *                                                            *
   !          * The unit normals on the boundary faces. These always point *
   !          * out of the domain, so a multiplication by -1 is needed for *
   !          * the iMin, jMin and kMin boundaries.                        *
   !          *                                                            *
   !          **************************************************************
   !
   ! Loop over the boundary subfaces of this block.
   bocoloop:DO mm=1,nbocos
   ! Determine the block face on which this subface is located
   ! and set ss and mult accordingly.
   CALL SETSSMETRIC_D(mm, ss, ssd)
   SELECT CASE  (bcfaceid(mm)) 
   CASE (imin) 
   mult = -one
   CASE (imax) 
   mult = one
   CASE (jmin) 
   mult = -one
   CASE (jmax) 
   mult = one
   CASE (kmin) 
   mult = -one
   CASE (kmax) 
   mult = one
   END SELECT
   ! Loop over the boundary faces of the subface.
   DO j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
   DO i=bcdata(mm)%icbeg,bcdata(mm)%icend
   ! Compute the inverse of the length of the normal vector
   ! and possibly correct for inward pointing.
   xpd = ssd(i, j, 1)
   xp = ss(i, j, 1)
   ypd = ssd(i, j, 2)
   yp = ss(i, j, 2)
   zpd = ssd(i, j, 3)
   zp = ss(i, j, 3)
   arg1d = xpd*xp + xp*xpd + ypd*yp + yp*ypd + zpd*zp + zp*zpd
   arg1 = xp*xp + yp*yp + zp*zp
   IF (arg1 .EQ. 0.0_8) THEN
   factd = 0.0_8
   ELSE
   factd = arg1d/(2.0*SQRT(arg1))
   END IF
   fact = SQRT(arg1)
   IF (fact .GT. zero) THEN
   factd = -(mult*factd/fact**2)
   fact = mult/fact
   END IF
   ! Compute the unit normal.
   bcdatad(mm)%norm(i, j, 1) = factd*xp + fact*xpd
   bcdata(mm)%norm(i, j, 1) = fact*xp
   bcdatad(mm)%norm(i, j, 2) = factd*yp + fact*ypd
   bcdata(mm)%norm(i, j, 2) = fact*yp
   bcdatad(mm)%norm(i, j, 3) = factd*zp + fact*zpd
   bcdata(mm)%norm(i, j, 3) = fact*zp
   END DO
   END DO
   CALL RESETSSMETRIC(mm, ss)
   END DO bocoloop
      CONTAINS
   !  Differentiation of volpym in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: volume
   !   with respect to varying inputs: xp yp zp xa xb xc xd ya yb
   !                yc yd za zb zc zd
   !        ================================================================
   SUBROUTINE VOLPYM_D(xa, xad, ya, yad, za, zad, xb, xbd, yb, ybd, zb, &
   &   zbd, xc, xcd, yc, ycd, zc, zcd, xd, xdd, yd, ydd, zd, zdd, volume, &
   &   volumed)
   !
   !        ****************************************************************
   !        *                                                              *
   !        * volpym computes 6 times the volume of a pyramid. Node p,     *
   !        * whose coordinates are set in the subroutine metric itself,   *
   !        * is the top node and a-b-c-d is the quadrilateral surface.    *
   !        * It is assumed that the cross product vCa * vDb points in     *
   !        * the direction of the top node. Here vCa is the diagonal      *
   !        * running from node c to node a and vDb the diagonal from      *
   !        * node d to node b.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   USE PRECISION
   IMPLICIT NONE
   !
   !        Function type.
   !
   REAL(kind=realtype) :: volume
   REAL(kind=realtype) :: volumed
   !
   !        Function arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: xa, ya, za, xb, yb, zb
   REAL(kind=realtype), INTENT(IN) :: xad, yad, zad, xbd, ybd, zbd
   REAL(kind=realtype), INTENT(IN) :: xc, yc, zc, xd, yd, zd
   REAL(kind=realtype), INTENT(IN) :: xcd, ycd, zcd, xdd, ydd, zdd
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   volumed = (xpd-fourth*(xad+xbd+xcd+xdd))*((ya-yc)*(zb-zd)-(za-zc)*(&
   &     yb-yd)) + (xp-fourth*(xa+xb+xc+xd))*((yad-ycd)*(zb-zd)+(ya-yc)*(&
   &     zbd-zdd)-(zad-zcd)*(yb-yd)-(za-zc)*(ybd-ydd)) + (ypd-fourth*(yad+&
   &     ybd+ycd+ydd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd)) + (yp-fourth*(ya+&
   &     yb+yc+yd))*((zad-zcd)*(xb-xd)+(za-zc)*(xbd-xdd)-(xad-xcd)*(zb-zd)-&
   &     (xa-xc)*(zbd-zdd)) + (zpd-fourth*(zad+zbd+zcd+zdd))*((xa-xc)*(yb-&
   &     yd)-(ya-yc)*(xb-xd)) + (zp-fourth*(za+zb+zc+zd))*((xad-xcd)*(yb-yd&
   &     )+(xa-xc)*(ybd-ydd)-(yad-ycd)*(xb-xd)-(ya-yc)*(xbd-xdd))
   volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))&
   &     + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd)) + (&
   &     zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
   END SUBROUTINE VOLPYM_D
   !        ================================================================
   SUBROUTINE VOLPYM(xa, ya, za, xb, yb, zb, xc, yc, zc, xd, yd, zd, &
   &   volume)
   !
   !        ****************************************************************
   !        *                                                              *
   !        * volpym computes 6 times the volume of a pyramid. Node p,     *
   !        * whose coordinates are set in the subroutine metric itself,   *
   !        * is the top node and a-b-c-d is the quadrilateral surface.    *
   !        * It is assumed that the cross product vCa * vDb points in     *
   !        * the direction of the top node. Here vCa is the diagonal      *
   !        * running from node c to node a and vDb the diagonal from      *
   !        * node d to node b.                                            *
   !        *                                                              *
   !        ****************************************************************
   !
   USE PRECISION
   IMPLICIT NONE
   !
   !        Function type.
   !
   REAL(kind=realtype) :: volume
   !
   !        Function arguments.
   !
   REAL(kind=realtype), INTENT(IN) :: xa, ya, za, xb, yb, zb
   REAL(kind=realtype), INTENT(IN) :: xc, yc, zc, xd, yd, zd
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   volume = (xp-fourth*(xa+xb+xc+xd))*((ya-yc)*(zb-zd)-(za-zc)*(yb-yd))&
   &     + (yp-fourth*(ya+yb+yc+yd))*((za-zc)*(xb-xd)-(xa-xc)*(zb-zd)) + (&
   &     zp-fourth*(za+zb+zc+zd))*((xa-xc)*(yb-yd)-(ya-yc)*(xb-xd))
   END SUBROUTINE VOLPYM
   END SUBROUTINE METRIC_BLOCK_D

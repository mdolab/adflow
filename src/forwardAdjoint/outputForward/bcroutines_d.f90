!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
!      ******************************************************************
!      *                                                                *
!      * File:          BCRoutines.F90                                   *
!      * Author:        Gaetan K. W. Kenway                             *
!      * Starting date: 01-23-2015                                      *
!      * Last modified: 01-23-2015                                      *
!      *                                                                *
!      ******************************************************************
!
!      ******************************************************************
!      *                                                                *
!      * This module contains data structures *and* routines used       *
!      * for applying *all* boundary conditions for Navier Stokes part  *
!      * of the code. The reason for using a module to contain the      *
!      * routines is that due to the use of pointers, it eliminates the *
!      * need for using interfaces. All former bc*.f90 routines are now *
!      * included in this module.                                       *
!      *                                                                *
!      ******************************************************************
!
MODULE BCROUTINES_D
  USE CONSTANTS
  IMPLICIT NONE
  SAVE 
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww0, ww1, ww2, ww3
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww0d, ww1d, ww2d, &
       & ww3d
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp0, pp1, pp2, pp3
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp0d, pp1d, pp2d, &
       & pp3d
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv0, rlv1, rlv2, &
       & rlv3
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv0d, rlv1d, rlv2d, &
       & rlv3d
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev0, rev1, rev2, &
       & rev3
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev0d, rev1d, rev2d, &
       & rev3d
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: gamma0, gamma1, &
       & gamma2, gamma3
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssi, ssj, ssk
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssid, ssjd, sskd
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ssd
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: xline
  INTEGER(kind=inttype) :: isize, jsize
CONTAINS
  !  Differentiation of applyallbc_block2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: *rev *bvtj1 *bvtj2 *p *w *rlv
  !                *bvtk1 *bvtk2 *bvti1 *bvti2 *rev0 *rev1 *pp0 *pp1
  !                *rlv0 *rlv1 *ww0 *ww1
  !   with respect to varying inputs: gammainf winf pinfcorr rgas
  !                *rev *p *s *w *rlv *si *sj *sk *(*bcdata.norm)
  !                *(*bcdata.rface) *(*bcdata.uslip) *rev0 *rev1
  !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
  !                *rlv3 *ss *ssi *ssj *ssk *ww0 *ww1 *ww2 *ww3
  !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in p:in
  !                w:in rlv:in x:in bvtk1:in bvtk2:in si:in sj:in
  !                sk:in bvti1:in bvti2:in bcdata:in *bcdata.norm:in
  !                *bcdata.rface:in *bcdata.uslip:in rev0:in-out
  !                rev1:in-out rev2:in-out rev3:in-out pp0:in-out
  !                pp1:in-out pp2:in-out pp3:in-out rlv0:in-out rlv1:in-out
  !                rlv2:in-out rlv3:in-out ss:in-out ssi:in-out ssj:in-out
  !                ssk:in-out ww0:in-out ww1:in-out ww2:in-out ww3:in-out
  SUBROUTINE APPLYALLBC_BLOCK2_D(secondhalo)
    ! Apply BC's for a single block
    USE BLOCKPOINTERS
    USE FLOWVARREFSTATE
    USE INPUTDISCRETIZATION
    USE INPUTTIMESPECTRAL
    USE ITERATION
    USE BCTYPES
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo
    ! Local variables.
    LOGICAL :: correctfork
    INTEGER(kind=inttype) :: nn
    !
    ! Determine whether or not the total energy must be corrected
    ! for the presence of the turbulent kinetic energy.
    IF (kpresent) THEN
       IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
          correctfork = .true.
       ELSE
          correctfork = .false.
       END IF
    ELSE
       correctfork = .false.
    END IF
    ! Apply all the boundary conditions. The order is important!  Only
    ! some of them have been AD'ed
    ! ------------------------------------
    !  Symmetry Boundary Condition 
    ! ------------------------------------
    DO nn=1,nbocos
       IF (bctype(nn) .EQ. symm) THEN
          CALL SETBCPOINTERS2_D(nn)
          CALL BCSYMM2_D(nn, secondhalo)
       END IF
    END DO
    bvtj1d = 0.0_8
    bvtj2d = 0.0_8
    bvtk1d = 0.0_8
    bvtk2d = 0.0_8
    bvti1d = 0.0_8
    bvti2d = 0.0_8
    ! ------------------------------------
    !  Adibatic Wall Boundary Condition 
    ! ------------------------------------
    DO nn=1,nviscbocos
       IF (bctype(nn) .EQ. nswalladiabatic) THEN
          CALL SETBCPOINTERS2_D(nn)
          CALL BCNSWALLADIABATIC2_D(nn, secondhalo, correctfork)
       END IF
    END DO
    ! ------------------------------------
    !  Isotermal Wall Boundary Condition 
    ! ------------------------------------
    DO nn=1,nviscbocos
       IF (bctype(nn) .EQ. nswallisothermal) THEN
          CALL SETBCPOINTERS2_D(nn)
          CALL BCNSWALLISOTHERMAL2_D(nn, secondhalo, correctfork)
       END IF
    END DO
    ! ------------------------------------
    !  Farfield Boundary Condition 
    ! ------------------------------------
    IF (precond .EQ. turkel .OR. precond .EQ. choimerkle) CALL &
         &     TERMINATE('applyAllBC', &
         &      'Farfield Turkel and Coid/Merkle preconditioners not implemented'&
         &           )
    DO nn=1,nbocos
       IF (bctype(nn) .EQ. farfield) THEN
          CALL SETBCPOINTERS2_D(nn)
          CALL BCFARFIELD2_D(nn, secondhalo, correctfork)
       END IF
    END DO
    ! ------------------------------------
    !  Euler Wall Boundary Condition 
    ! ------------------------------------
    DO nn=1,nbocos
       IF (bctype(nn) .EQ. eulerwall) THEN
          CALL SETBCPOINTERS2_D(nn)
          CALL BCEULERWALL2_D(nn, secondhalo, correctfork)
       END IF
    END DO
  END SUBROUTINE APPLYALLBC_BLOCK2_D
  SUBROUTINE APPLYALLBC_BLOCK2(secondhalo)
    ! Apply BC's for a single block
    USE BLOCKPOINTERS
    USE FLOWVARREFSTATE
    USE INPUTDISCRETIZATION
    USE INPUTTIMESPECTRAL
    USE ITERATION
    USE BCTYPES
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo
    ! Local variables.
    LOGICAL :: correctfork
    INTEGER(kind=inttype) :: nn
    !
    ! Determine whether or not the total energy must be corrected
    ! for the presence of the turbulent kinetic energy.
    IF (kpresent) THEN
       IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
          correctfork = .true.
       ELSE
          correctfork = .false.
       END IF
    ELSE
       correctfork = .false.
    END IF
    ! Apply all the boundary conditions. The order is important!  Only
    ! some of them have been AD'ed
    ! ------------------------------------
    !  Symmetry Boundary Condition 
    ! ------------------------------------
    DO nn=1,nbocos
       IF (bctype(nn) .EQ. symm) THEN
          CALL SETBCPOINTERS2(nn)
          CALL BCSYMM2(nn, secondhalo)
       END IF
    END DO
    ! ------------------------------------
    !  Adibatic Wall Boundary Condition 
    ! ------------------------------------
    DO nn=1,nviscbocos
       IF (bctype(nn) .EQ. nswalladiabatic) THEN
          CALL SETBCPOINTERS2(nn)
          CALL BCNSWALLADIABATIC2(nn, secondhalo, correctfork)
       END IF
    END DO
    ! ------------------------------------
    !  Isotermal Wall Boundary Condition 
    ! ------------------------------------
    DO nn=1,nviscbocos
       IF (bctype(nn) .EQ. nswallisothermal) THEN
          CALL SETBCPOINTERS2(nn)
          CALL BCNSWALLISOTHERMAL2(nn, secondhalo, correctfork)
       END IF
    END DO
    ! ------------------------------------
    !  Farfield Boundary Condition 
    ! ------------------------------------
    IF (precond .EQ. turkel .OR. precond .EQ. choimerkle) CALL &
         &     TERMINATE('applyAllBC', &
         &      'Farfield Turkel and Coid/Merkle preconditioners not implemented'&
         &           )
    DO nn=1,nbocos
       IF (bctype(nn) .EQ. farfield) THEN
          CALL SETBCPOINTERS2(nn)
          CALL BCFARFIELD2(nn, secondhalo, correctfork)
       END IF
    END DO
    ! ------------------------------------
    !  Euler Wall Boundary Condition 
    ! ------------------------------------
    DO nn=1,nbocos
       IF (bctype(nn) .EQ. eulerwall) THEN
          CALL SETBCPOINTERS2(nn)
          CALL BCEULERWALL2(nn, secondhalo, correctfork)
       END IF
    END DO
  END SUBROUTINE APPLYALLBC_BLOCK2
  !  Differentiation of bcsymm2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
  !                *rlv1 *ww0 *ww1
  !   with respect to varying inputs: *(*bcdata.norm) *rev0 *rev1
  !                *rev2 *rev3 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2
  !                *rlv3 *ww0 *ww1 *ww2 *ww3
  !   Plus diff mem management of: bcdata:in *bcdata.norm:in rev0:in
  !                rev1:in rev2:in rev3:in pp0:in pp1:in pp2:in pp3:in
  !                rlv0:in rlv1:in rlv2:in rlv3:in ww0:in ww1:in
  !                ww2:in ww3:in
  ! ===================================================================
  !   Actual implementation of each of the boundary condition routines
  ! ===================================================================
  SUBROUTINE BCSYMM2_D(nn, secondhalo)
    !
    ! ******************************************************************
    ! *                                                                *
    ! * bcSymm applies the symmetry boundary conditions to a block.    *
    ! * It is assumed that the pointers in blockPointers are already   *
    ! * set to the correct block on the correct grid level.            *
    ! *                                                                *
    ! * In case also the second halo must be set the loop over the     *
    ! * boundary subfaces is executed twice. This is the only correct  *
    ! * way in case the block contains only 1 cell between two         *
    ! * symmetry planes, i.e. a 2D problem.                            *
    ! *                                                                *
    ! ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables.
    INTEGER(kind=inttype) :: i, j, l, ii
    REAL(kind=realtype) :: vn, nnx, nny, nnz
    REAL(kind=realtype) :: vnd
    INTRINSIC MOD
    ! Loop over the generic subface to set the state in the
    ! 1-st level halos 
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Determine twice the normal velocity component,
       ! which must be substracted from the donor velocity
       ! to obtain the halo velocity.
       vnd = two*(ww2d(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivx)&
            &       *bcdatad(nn)%norm(i, j, 1)+ww2d(i, j, ivy)*bcdata(nn)%norm(i, j&
            &       , 2)+ww2(i, j, ivy)*bcdatad(nn)%norm(i, j, 2)+ww2d(i, j, ivz)*&
            &       bcdata(nn)%norm(i, j, 3)+ww2(i, j, ivz)*bcdatad(nn)%norm(i, j, 3&
            &       ))
       vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
            &       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
            &       )
       ! Determine the flow variables in the halo cell.
       ww1d(i, j, irho) = ww2d(i, j, irho)
       ww1(i, j, irho) = ww2(i, j, irho)
       ww1d(i, j, ivx) = ww2d(i, j, ivx) - vnd*bcdata(nn)%norm(i, j, 1) -&
            &       vn*bcdatad(nn)%norm(i, j, 1)
       ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
       ww1d(i, j, ivy) = ww2d(i, j, ivy) - vnd*bcdata(nn)%norm(i, j, 2) -&
            &       vn*bcdatad(nn)%norm(i, j, 2)
       ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
       ww1d(i, j, ivz) = ww2d(i, j, ivz) - vnd*bcdata(nn)%norm(i, j, 3) -&
            &       vn*bcdatad(nn)%norm(i, j, 3)
       ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
       ww1d(i, j, irhoe) = ww2d(i, j, irhoe)
       ww1(i, j, irhoe) = ww2(i, j, irhoe)
       ! Simply copy the turbulent variables.
       DO l=nt1mg,nt2mg
          ww1d(i, j, l) = ww2d(i, j, l)
          ww1(i, j, l) = ww2(i, j, l)
       END DO
       ! Set the pressure and gamma and possibly the
       ! laminar and eddy viscosity in the halo.
       gamma1(i, j) = gamma2(i, j)
       pp1d(i, j) = pp2d(i, j)
       pp1(i, j) = pp2(i, j)
       IF (viscous) THEN
          rlv1d(i, j) = rlv2d(i, j)
          rlv1(i, j) = rlv2(i, j)
       END IF
       IF (eddymodel) THEN
          rev1d(i, j) = rev2d(i, j)
          rev1(i, j) = rev2(i, j)
       END IF
    END DO
    IF (secondhalo) THEN
       ! If we need the second halo, do everything again, but using ww0,
       ! ww3 etc instead of ww2 and ww1. 
       DO ii=0,isize*jsize-1
          i = MOD(ii, isize) + 1
          j = ii/isize + 1
          vnd = two*(ww3d(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, &
               &         ivx)*bcdatad(nn)%norm(i, j, 1)+ww3d(i, j, ivy)*bcdata(nn)%norm&
               &         (i, j, 2)+ww3(i, j, ivy)*bcdatad(nn)%norm(i, j, 2)+ww3d(i, j, &
               &         ivz)*bcdata(nn)%norm(i, j, 3)+ww3(i, j, ivz)*bcdatad(nn)%norm(&
               &         i, j, 3))
          vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
               &         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
               &         , 3))
          ! Determine the flow variables in the halo cell.
          ww0d(i, j, irho) = ww3d(i, j, irho)
          ww0(i, j, irho) = ww3(i, j, irho)
          ww0d(i, j, ivx) = ww3d(i, j, ivx) - vnd*bcdata(nn)%norm(i, j, 1)&
               &         - vn*bcdatad(nn)%norm(i, j, 1)
          ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
          ww0d(i, j, ivy) = ww3d(i, j, ivy) - vnd*bcdata(nn)%norm(i, j, 2)&
               &         - vn*bcdatad(nn)%norm(i, j, 2)
          ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
          ww0d(i, j, ivz) = ww3d(i, j, ivz) - vnd*bcdata(nn)%norm(i, j, 3)&
               &         - vn*bcdatad(nn)%norm(i, j, 3)
          ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
          ww0d(i, j, irhoe) = ww3d(i, j, irhoe)
          ww0(i, j, irhoe) = ww3(i, j, irhoe)
          DO l=nt1mg,nt2mg
             ww0d(i, j, l) = ww3d(i, j, l)
             ww0(i, j, l) = ww3(i, j, l)
          END DO
          ! Set the pressure and gamma and possibly the
          ! laminar and eddy viscosity in the halo.
          gamma0(i, j) = gamma3(i, j)
          pp0d(i, j) = pp3d(i, j)
          pp0(i, j) = pp3(i, j)
          IF (viscous) THEN
             rlv0d(i, j) = rlv3d(i, j)
             rlv0(i, j) = rlv3(i, j)
          END IF
          IF (eddymodel) THEN
             rev0d(i, j) = rev3d(i, j)
             rev0(i, j) = rev3(i, j)
          END IF
       END DO
    END IF
  END SUBROUTINE BCSYMM2_D
  ! ===================================================================
  !   Actual implementation of each of the boundary condition routines
  ! ===================================================================
  SUBROUTINE BCSYMM2(nn, secondhalo)
    !
    ! ******************************************************************
    ! *                                                                *
    ! * bcSymm applies the symmetry boundary conditions to a block.    *
    ! * It is assumed that the pointers in blockPointers are already   *
    ! * set to the correct block on the correct grid level.            *
    ! *                                                                *
    ! * In case also the second halo must be set the loop over the     *
    ! * boundary subfaces is executed twice. This is the only correct  *
    ! * way in case the block contains only 1 cell between two         *
    ! * symmetry planes, i.e. a 2D problem.                            *
    ! *                                                                *
    ! ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables.
    INTEGER(kind=inttype) :: i, j, l, ii
    REAL(kind=realtype) :: vn, nnx, nny, nnz
    INTRINSIC MOD
    ! Loop over the generic subface to set the state in the
    ! 1-st level halos 
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Determine twice the normal velocity component,
       ! which must be substracted from the donor velocity
       ! to obtain the halo velocity.
       vn = two*(ww2(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww2(i, j, ivy)*&
            &       bcdata(nn)%norm(i, j, 2)+ww2(i, j, ivz)*bcdata(nn)%norm(i, j, 3)&
            &       )
       ! Determine the flow variables in the halo cell.
       ww1(i, j, irho) = ww2(i, j, irho)
       ww1(i, j, ivx) = ww2(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
       ww1(i, j, ivy) = ww2(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
       ww1(i, j, ivz) = ww2(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
       ww1(i, j, irhoe) = ww2(i, j, irhoe)
       ! Simply copy the turbulent variables.
       DO l=nt1mg,nt2mg
          ww1(i, j, l) = ww2(i, j, l)
       END DO
       ! Set the pressure and gamma and possibly the
       ! laminar and eddy viscosity in the halo.
       gamma1(i, j) = gamma2(i, j)
       pp1(i, j) = pp2(i, j)
       IF (viscous) rlv1(i, j) = rlv2(i, j)
       IF (eddymodel) rev1(i, j) = rev2(i, j)
    END DO
    IF (secondhalo) THEN
       ! If we need the second halo, do everything again, but using ww0,
       ! ww3 etc instead of ww2 and ww1. 
       DO ii=0,isize*jsize-1
          i = MOD(ii, isize) + 1
          j = ii/isize + 1
          vn = two*(ww3(i, j, ivx)*bcdata(nn)%norm(i, j, 1)+ww3(i, j, ivy)&
               &         *bcdata(nn)%norm(i, j, 2)+ww3(i, j, ivz)*bcdata(nn)%norm(i, j&
               &         , 3))
          ! Determine the flow variables in the halo cell.
          ww0(i, j, irho) = ww3(i, j, irho)
          ww0(i, j, ivx) = ww3(i, j, ivx) - vn*bcdata(nn)%norm(i, j, 1)
          ww0(i, j, ivy) = ww3(i, j, ivy) - vn*bcdata(nn)%norm(i, j, 2)
          ww0(i, j, ivz) = ww3(i, j, ivz) - vn*bcdata(nn)%norm(i, j, 3)
          ww0(i, j, irhoe) = ww3(i, j, irhoe)
          DO l=nt1mg,nt2mg
             ww0(i, j, l) = ww3(i, j, l)
          END DO
          ! Set the pressure and gamma and possibly the
          ! laminar and eddy viscosity in the halo.
          gamma0(i, j) = gamma3(i, j)
          pp0(i, j) = pp3(i, j)
          IF (viscous) rlv0(i, j) = rlv3(i, j)
          IF (eddymodel) rev0(i, j) = rev3(i, j)
       END DO
    END IF
  END SUBROUTINE BCSYMM2
  !  Differentiation of bcnswalladiabatic2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: *rev *bvtj1 *bvtj2 *w *bvtk1
  !                *bvtk2 *bvti1 *bvti2 *rev0 *rev1 *pp0 *pp1 *rlv0
  !                *rlv1 *ww0 *ww1
  !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *w *rlv
  !                *bvtk1 *bvtk2 *bvti1 *bvti2 *(*bcdata.uslip) *rev0
  !                *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2 *ww0
  !                *ww1 *ww2
  !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
  !                rlv:in bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
  !                *bcdata.uslip:in rev0:in rev1:in rev2:in pp0:in
  !                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
  !                ww2:in
  SUBROUTINE BCNSWALLADIABATIC2_D(nn, secondhalo, correctfork)
    !
    !      ******************************************************************
    !      *                                                                *
    !      * bcNSWallAdiabatic applies the viscous adiabatic wall           *
    !      * boundary condition the pointers already defined.               *
    !      *                                                                *
    !      ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    INTEGER(kind=inttype), INTENT(IN) :: nn
    INTEGER(kind=inttype) :: i, j, ii
    REAL(kind=realtype) :: rhok
    REAL(kind=realtype) :: rhokd
    INTRINSIC MOD
    ! Apply the BCWall In case the turbulent transport equations are solved
    ! together with the mean flow equations, aplly the viscous
    ! wall boundary conditions for the turbulent variables.
    ! No need to extrapolate the secondary halo's, because this
    ! is done in extrapolate2ndHalo.
    IF (turbcoupled) CALL TURBBCNSWALL_D(.false.)
    ! Initialize rhok to zero. This will be overwritten if a
    ! correction for k must be applied.
    rhok = zero
    rhokd = 0.0_8
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Set the value of rhok if a correcton must be applied.
       ! It probably does not matter too much, because k is very
       ! small near the wall.
       IF (correctfork) THEN
          rhokd = ww2d(i, j, irho)*ww2(i, j, itu1) + ww2(i, j, irho)*ww2d(&
               &         i, j, itu1)
          rhok = ww2(i, j, irho)*ww2(i, j, itu1)
       END IF
       ! Determine the variables in the halo. As the spacing
       ! is very small a constant pressure boundary condition
       ! (except for the k correction) is okay. Take the slip
       ! velocity into account.
       ww1d(i, j, irho) = ww2d(i, j, irho)
       ww1(i, j, irho) = ww2(i, j, irho)
       ww1d(i, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - ww2d(i, j, ivx)
       ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
       ww1d(i, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - ww2d(i, j, ivy)
       ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
       ww1d(i, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - ww2d(i, j, ivz)
       ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
       pp1d(i, j) = pp2d(i, j) - four*third*rhokd
       pp1(i, j) = pp2(i, j) - four*third*rhok
       ! Set the viscosities. There is no need to test for a
       ! viscous problem of course. The eddy viscosity is
       ! set to the negative value, as it should be zero on
       ! the wall.
       rlv1d(i, j) = rlv2d(i, j)
       rlv1(i, j) = rlv2(i, j)
       IF (eddymodel) THEN
          rev1d(i, j) = -rev2d(i, j)
          rev1(i, j) = -rev2(i, j)
       END IF
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2_D(ww1, ww1d, pp1, pp1d, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_D(correctfork)
  END SUBROUTINE BCNSWALLADIABATIC2_D
  SUBROUTINE BCNSWALLADIABATIC2(nn, secondhalo, correctfork)
    !
    !      ******************************************************************
    !      *                                                                *
    !      * bcNSWallAdiabatic applies the viscous adiabatic wall           *
    !      * boundary condition the pointers already defined.               *
    !      *                                                                *
    !      ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    INTEGER(kind=inttype), INTENT(IN) :: nn
    INTEGER(kind=inttype) :: i, j, ii
    REAL(kind=realtype) :: rhok
    INTRINSIC MOD
    ! Apply the BCWall In case the turbulent transport equations are solved
    ! together with the mean flow equations, aplly the viscous
    ! wall boundary conditions for the turbulent variables.
    ! No need to extrapolate the secondary halo's, because this
    ! is done in extrapolate2ndHalo.
    IF (turbcoupled) CALL TURBBCNSWALL(.false.)
    ! Initialize rhok to zero. This will be overwritten if a
    ! correction for k must be applied.
    rhok = zero
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Set the value of rhok if a correcton must be applied.
       ! It probably does not matter too much, because k is very
       ! small near the wall.
       IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
       ! Determine the variables in the halo. As the spacing
       ! is very small a constant pressure boundary condition
       ! (except for the k correction) is okay. Take the slip
       ! velocity into account.
       ww1(i, j, irho) = ww2(i, j, irho)
       ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
       ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
       ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
       pp1(i, j) = pp2(i, j) - four*third*rhok
       ! Set the viscosities. There is no need to test for a
       ! viscous problem of course. The eddy viscosity is
       ! set to the negative value, as it should be zero on
       ! the wall.
       rlv1(i, j) = rlv2(i, j)
       IF (eddymodel) rev1(i, j) = -rev2(i, j)
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2(ww1, pp1, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
  END SUBROUTINE BCNSWALLADIABATIC2
  !  Differentiation of bcnswallisothermal2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: *rev *bvtj1 *bvtj2 *w *bvtk1
  !                *bvtk2 *bvti1 *bvti2 *rev0 *rev1 *pp0 *pp1 *rlv0
  !                *rlv1 *ww0 *ww1
  !   with respect to varying inputs: rgas *rev *bvtj1 *bvtj2 *w
  !                *rlv *bvtk1 *bvtk2 *bvti1 *bvti2 *(*bcdata.uslip)
  !                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
  !                *ww0 *ww1 *ww2
  !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in w:in
  !                rlv:in bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
  !                *bcdata.uslip:in rev0:in rev1:in rev2:in pp0:in
  !                pp1:in pp2:in rlv0:in rlv1:in rlv2:in ww0:in ww1:in
  !                ww2:in
  SUBROUTINE BCNSWALLISOTHERMAL2_D(nn, secondhalo, correctfork)
    !
    ! ******************************************************************
    ! *                                                                *
    ! * bcNSWallAdiabatic applies the viscous isothermal wall          *
    ! * boundary condition to a block. It is assumed that the          *
    ! * BCPointers are already set                                     *
    ! *                                                                *
    ! ******************************************************************
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables.
    INTEGER(kind=inttype) :: i, j, ii
    REAL(kind=realtype) :: rhok, t2, t1
    REAL(kind=realtype) :: rhokd, t2d, t1d
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    ! In case the turbulent transport equations are solved
    ! together with the mean flow equations, aplly the viscous
    ! wall boundary conditions for the turbulent variables.
    ! No need to extrapolate the secondary halo's, because this
    ! is done in extrapolate2ndHalo.
    IF (turbcoupled) CALL TURBBCNSWALL_D(.false.)
    ! Initialize rhok to zero. This will be overwritten if a
    ! correction for k must be applied.
    rhok = zero
    rhokd = 0.0_8
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Set the value of rhok if a correcton must be applied.
       ! It probably does not matter too much, because k is very
       ! small near the wall.
       IF (correctfork) THEN
          rhokd = ww2d(i, j, irho)*ww2(i, j, itu1) + ww2(i, j, irho)*ww2d(&
               &         i, j, itu1)
          rhok = ww2(i, j, irho)*ww2(i, j, itu1)
       END IF
       ! Compute the temperature in the internal cell and in the
       ! halo cell such that the average is the wall temperature.
       t2d = (pp2d(i, j)*rgas*ww2(i, j, irho)-pp2(i, j)*(rgasd*ww2(i, j, &
            &       irho)+rgas*ww2d(i, j, irho)))/(rgas*ww2(i, j, irho))**2
       t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
       t1d = -t2d
       t1 = two*bcdata(nn)%tns_wall(i, j) - t2
       IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
          t1 = t1
       ELSE
          t1 = half*bcdata(nn)%tns_wall(i, j)
          t1d = 0.0_8
       END IF
       IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
          t1 = t1
       ELSE
          t1 = two*bcdata(nn)%tns_wall(i, j)
          t1d = 0.0_8
       END IF
       ! Determine the variables in the halo. As the spacing
       ! is very small a constant pressure boundary condition
       ! (except for the k correction) is okay. Take the slip
       ! velocity into account.
       pp1d(i, j) = pp2d(i, j) - four*third*rhokd
       pp1(i, j) = pp2(i, j) - four*third*rhok
       ww1d(i, j, irho) = (pp1d(i, j)*rgas*t1-pp1(i, j)*(rgasd*t1+rgas*&
            &       t1d))/(rgas*t1)**2
       ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
       ww1d(i, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - ww2d(i, j, ivx)
       ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
       ww1d(i, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - ww2d(i, j, ivy)
       ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
       ww1d(i, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - ww2d(i, j, ivz)
       ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
       ! Set the viscosities. There is no need to test for a
       ! viscous problem of course. The eddy viscosity is
       ! set to the negative value, as it should be zero on
       ! the wall.
       rlv1d(i, j) = rlv2d(i, j)
       rlv1(i, j) = rlv2(i, j)
       IF (eddymodel) THEN
          rev1d(i, j) = -rev2d(i, j)
          rev1(i, j) = -rev2(i, j)
       END IF
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2_D(ww1, ww1d, pp1, pp1d, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_D(correctfork)
  END SUBROUTINE BCNSWALLISOTHERMAL2_D
  SUBROUTINE BCNSWALLISOTHERMAL2(nn, secondhalo, correctfork)
    !
    ! ******************************************************************
    ! *                                                                *
    ! * bcNSWallAdiabatic applies the viscous isothermal wall          *
    ! * boundary condition to a block. It is assumed that the          *
    ! * BCPointers are already set                                     *
    ! *                                                                *
    ! ******************************************************************
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables.
    INTEGER(kind=inttype) :: i, j, ii
    REAL(kind=realtype) :: rhok, t2, t1
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    ! In case the turbulent transport equations are solved
    ! together with the mean flow equations, aplly the viscous
    ! wall boundary conditions for the turbulent variables.
    ! No need to extrapolate the secondary halo's, because this
    ! is done in extrapolate2ndHalo.
    IF (turbcoupled) CALL TURBBCNSWALL(.false.)
    ! Initialize rhok to zero. This will be overwritten if a
    ! correction for k must be applied.
    rhok = zero
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Set the value of rhok if a correcton must be applied.
       ! It probably does not matter too much, because k is very
       ! small near the wall.
       IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
       ! Compute the temperature in the internal cell and in the
       ! halo cell such that the average is the wall temperature.
       t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
       t1 = two*bcdata(nn)%tns_wall(i, j) - t2
       IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
          t1 = t1
       ELSE
          t1 = half*bcdata(nn)%tns_wall(i, j)
       END IF
       IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
          t1 = t1
       ELSE
          t1 = two*bcdata(nn)%tns_wall(i, j)
       END IF
       ! Determine the variables in the halo. As the spacing
       ! is very small a constant pressure boundary condition
       ! (except for the k correction) is okay. Take the slip
       ! velocity into account.
       pp1(i, j) = pp2(i, j) - four*third*rhok
       ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
       ww1(i, j, ivx) = -ww2(i, j, ivx) + two*bcdata(nn)%uslip(i, j, 1)
       ww1(i, j, ivy) = -ww2(i, j, ivy) + two*bcdata(nn)%uslip(i, j, 2)
       ww1(i, j, ivz) = -ww2(i, j, ivz) + two*bcdata(nn)%uslip(i, j, 3)
       ! Set the viscosities. There is no need to test for a
       ! viscous problem of course. The eddy viscosity is
       ! set to the negative value, as it should be zero on
       ! the wall.
       rlv1(i, j) = rlv2(i, j)
       IF (eddymodel) rev1(i, j) = -rev2(i, j)
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2(ww1, pp1, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
  END SUBROUTINE BCNSWALLISOTHERMAL2
  !  Differentiation of bceulerwall2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
  !                *rlv1 *ww0 *ww1
  !   with respect to varying inputs: *(*bcdata.norm) *(*bcdata.rface)
  !                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1
  !                *rlv2 *ss *ssi *ssj *ssk *ww0 *ww1 *ww2
  !   Plus diff mem management of: bcdata:in *bcdata.norm:in *bcdata.rface:in
  !                rev0:in rev1:in rev2:in pp0:in pp1:in pp2:in pp3:in
  !                rlv0:in rlv1:in rlv2:in ss:in ssi:in ssj:in ssk:in
  !                ww0:in ww1:in ww2:in
  SUBROUTINE BCEULERWALL2_D(nn, secondhalo, correctfork)
    !
    ! ******************************************************************
    ! *                                                                *
    ! * bcEulerWall applies the inviscid wall boundary condition to    *
    ! * a block. It is assumed that the bcpointers are                 *
    ! * already set to the correct block on the correct grid level.    *
    ! *                                                                *
    ! ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE INPUTDISCRETIZATION
    USE INPUTPHYSICS
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables.
    INTEGER(kind=inttype) :: j, k, l, ii
    INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
    INTEGER(kind=inttype) :: walltreatment
    REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    REAL(kind=realtype) :: sixad, siyad, sizad, sjxad, sjyad, sjzad
    REAL(kind=realtype) :: skxa, skya, skza, a1, b1
    REAL(kind=realtype) :: skxad, skyad, skzad
    REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    REAL(kind=realtype) :: rxjd, ryjd, rzjd, rxkd, rykd, rzkd
    REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    REAL(kind=realtype) :: dpjd, dpkd, rid, rjd, rkd, qjd, qkd, vnd
    REAL(kind=realtype) :: uux, uuy, uuz
    REAL(kind=realtype) :: uuxd, uuyd, uuzd
    REAL(kind=realtype), DIMENSION(isize, jsize) :: grad
    REAL(kind=realtype), DIMENSION(isize, jsize) :: gradd
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(kind=realtype) :: DIM
    REAL(kind=realtype) :: DIM_D
    INTEGER(kind=inttype) :: max2
    INTEGER(kind=inttype) :: max1
    ! Make sure that on the coarser grids the constant pressure
    ! boundary condition is used.
    walltreatment = wallbctreatment
    IF (currentlevel .GT. groundlevel) walltreatment = constantpressure
    ! **************************************************************
    ! *                                                            *
    ! * Determine the boundary condition treatment and compute the *
    ! * undivided pressure gradient accordingly. This gradient is  *
    ! * temporarily stored in the halo pressure.                   *
    ! *                                                            *
    ! **************************************************************
    !
    SELECT CASE  (walltreatment) 
    CASE (constantpressure) 
       ! Constant pressure. Set the gradient to zero.
       grad = zero
       gradd = 0.0_8
    CASE (linextrapolpressure) 
       gradd = 0.0_8
       ! Linear extrapolation. 
       DO ii=0,isize*jsize-1
          j = MOD(ii, isize) + 1
          k = ii/isize + 1
          gradd(j, k) = pp3d(j, k) - pp2d(j, k)
          grad(j, k) = pp3(j, k) - pp2(j, k)
       END DO
    CASE (normalmomentum) 
       gradd = 0.0_8
       ! Pressure gradient is computed using the normal momentum
       ! equation. First set a couple of additional variables for
       ! the normals, depending on the block face. Note that the
       ! construction 1: should not be used in these pointers,
       ! because element 0 is needed. Consequently there will be
       ! an offset of 1 for these normals. This is commented in
       ! the code. For moving faces also the grid velocity of
       ! the 1st cell center from the wall is needed.
       DO ii=0,isize*jsize-1
          j = MOD(ii, isize) + 1
          k = ii/isize + 1
          ! Store the indices k+1, k-1 a bit easier and make
          ! sure that they do not exceed the range of the arrays.
          km1 = k - 1
          IF (1 .LT. km1) THEN
             km1 = km1
          ELSE
             km1 = 1
          END IF
          kp1 = k + 1
          IF (jsize .GT. kp1) THEN
             kp1 = kp1
          ELSE
             kp1 = jsize
          END IF
          IF (1_intType .LT. kp1 - km1) THEN
             max1 = kp1 - km1
          ELSE
             max1 = 1_intType
          END IF
          ! Compute the scaling factor for the central difference
          ! in the k-direction.
          b1 = one/max1
          ! The indices j+1 and j-1. Make sure that they
          ! do not exceed the range of the arrays.
          jm1 = j - 1
          IF (1 .LT. jm1) THEN
             jm1 = jm1
          ELSE
             jm1 = 1
          END IF
          jp1 = j + 1
          IF (isize .GT. jp1) THEN
             jp1 = jp1
          ELSE
             jp1 = isize
          END IF
          IF (1_intType .LT. jp1 - jm1) THEN
             max2 = jp1 - jm1
          ELSE
             max2 = 1_intType
          END IF
          ! Compute the scaling factor for the central
          ! difference in the j-direction.
          a1 = one/max2
          ! Compute (twice) the average normal in the generic i,
          ! j and k-direction. Note that in j and k-direction
          ! the average in the original indices should be taken
          ! using j-1 and j (and k-1 and k). However due to the
          ! usage of pointers ssj and ssk there is an offset in
          ! the indices of 1 and therefore now the correct
          ! average is obtained with the indices j and j+1
          ! (k and k+1).
          sixad = two*ssid(j, k, 1)
          sixa = two*ssi(j, k, 1)
          siyad = two*ssid(j, k, 2)
          siya = two*ssi(j, k, 2)
          sizad = two*ssid(j, k, 3)
          siza = two*ssi(j, k, 3)
          sjxad = ssjd(j, k, 1) + ssjd(j+1, k, 1)
          sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
          sjyad = ssjd(j, k, 2) + ssjd(j+1, k, 2)
          sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
          sjzad = ssjd(j, k, 3) + ssjd(j+1, k, 3)
          sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
          skxad = sskd(j, k, 1) + sskd(j, k+1, 1)
          skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
          skyad = sskd(j, k, 2) + sskd(j, k+1, 2)
          skya = ssk(j, k, 2) + ssk(j, k+1, 2)
          skzad = sskd(j, k, 3) + sskd(j, k+1, 3)
          skza = ssk(j, k, 3) + ssk(j, k+1, 3)
          ! Compute the difference of the normal vector and
          ! pressure in j and k-direction. As the indices are
          ! restricted to the 1st halo-layer, the computation
          ! of the internal halo values is not consistent;
          ! however this is not really a problem, because these
          ! values are overwritten in the communication pattern.
          rxjd = a1*(bcdatad(nn)%norm(jp1, k, 1)-bcdatad(nn)%norm(jm1, k, &
               &         1))
          rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
          ryjd = a1*(bcdatad(nn)%norm(jp1, k, 2)-bcdatad(nn)%norm(jm1, k, &
               &         2))
          ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
          rzjd = a1*(bcdatad(nn)%norm(jp1, k, 3)-bcdatad(nn)%norm(jm1, k, &
               &         3))
          rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
          dpjd = a1*(pp2d(jp1, k)-pp2d(jm1, k))
          dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
          rxkd = b1*(bcdatad(nn)%norm(j, kp1, 1)-bcdatad(nn)%norm(j, km1, &
               &         1))
          rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
          rykd = b1*(bcdatad(nn)%norm(j, kp1, 2)-bcdatad(nn)%norm(j, km1, &
               &         2))
          ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
          rzkd = b1*(bcdatad(nn)%norm(j, kp1, 3)-bcdatad(nn)%norm(j, km1, &
               &         3))
          rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
          dpkd = b1*(pp2d(j, kp1)-pp2d(j, km1))
          dpk = b1*(pp2(j, kp1)-pp2(j, km1))
          ! Compute the dot product between the unit vector
          ! and the normal vectors in i, j and k-direction.
          rid = bcdatad(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 1)*&
               &         sixad + bcdatad(nn)%norm(j, k, 2)*siya + bcdata(nn)%norm(j, k&
               &         , 2)*siyad + bcdatad(nn)%norm(j, k, 3)*siza + bcdata(nn)%norm(&
               &         j, k, 3)*sizad
          ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
               &         siya + bcdata(nn)%norm(j, k, 3)*siza
          rjd = bcdatad(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 1)*&
               &         sjxad + bcdatad(nn)%norm(j, k, 2)*sjya + bcdata(nn)%norm(j, k&
               &         , 2)*sjyad + bcdatad(nn)%norm(j, k, 3)*sjza + bcdata(nn)%norm(&
               &         j, k, 3)*sjzad
          rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
               &         sjya + bcdata(nn)%norm(j, k, 3)*sjza
          rkd = bcdatad(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 1)*&
               &         skxad + bcdatad(nn)%norm(j, k, 2)*skya + bcdata(nn)%norm(j, k&
               &         , 2)*skyad + bcdatad(nn)%norm(j, k, 3)*skza + bcdata(nn)%norm(&
               &         j, k, 3)*skzad
          rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
               &         skya + bcdata(nn)%norm(j, k, 3)*skza
          ! Store the velocity components in uux, uuy and uuz and
          ! subtract the mesh velocity if the face is moving.
          uuxd = ww2d(j, k, ivx)
          uux = ww2(j, k, ivx)
          uuyd = ww2d(j, k, ivy)
          uuy = ww2(j, k, ivy)
          uuzd = ww2d(j, k, ivz)
          uuz = ww2(j, k, ivz)
          IF (addgridvelocities) THEN
             uuxd = uuxd - ssd(j, k, 1)
             uux = uux - ss(j, k, 1)
             uuyd = uuyd - ssd(j, k, 2)
             uuy = uuy - ss(j, k, 2)
             uuzd = uuzd - ssd(j, k, 3)
             uuz = uuz - ss(j, k, 3)
          END IF
          ! Compute the velocity components in j and
          ! k-direction.
          qjd = uuxd*sjxa + uux*sjxad + uuyd*sjya + uuy*sjyad + uuzd*sjza &
               &         + uuz*sjzad
          qj = uux*sjxa + uuy*sjya + uuz*sjza
          qkd = uuxd*skxa + uux*skxad + uuyd*skya + uuy*skyad + uuzd*skza &
               &         + uuz*skzad
          qk = uux*skxa + uuy*skya + uuz*skza
          ! Compute the pressure gradient, which is stored
          ! in pp1. I'm not entirely sure whether this
          ! formulation is correct for moving meshes. It could
          ! be that an additional term is needed there.
          gradd(j, k) = (((qjd*(uux*rxj+uuy*ryj+uuz*rzj)+qj*(uuxd*rxj+uux*&
               &         rxjd+uuyd*ryj+uuy*ryjd+uuzd*rzj+uuz*rzjd)+qkd*(uux*rxk+uuy*ryk&
               &         +uuz*rzk)+qk*(uuxd*rxk+uux*rxkd+uuyd*ryk+uuy*rykd+uuzd*rzk+uuz&
               &         *rzkd))*ww2(j, k, irho)+(qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*&
               &         rxk+uuy*ryk+uuz*rzk))*ww2d(j, k, irho)-rjd*dpj-rj*dpjd-rkd*dpk&
               &         -rk*dpkd)*ri-((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*&
               &         ryk+uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)*rid)/ri**2
          grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
               &         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
       END DO
    CASE DEFAULT
       gradd = 0.0_8
    END SELECT
    ! Determine the state in the halo cell. Again loop over
    ! the cell range for this subface.
    DO ii=0,isize*jsize-1
       j = MOD(ii, isize) + 1
       k = ii/isize + 1
       ! Compute the pressure density and velocity in the
       ! halo cell. Note that rface is the grid velocity
       ! component in the direction of norm, i.e. outward
       ! pointing.
       pp1d(j, k) = DIM_D(pp2(j, k), pp2d(j, k), grad(j, k), gradd(j, k)&
            &       , pp1(j, k))
       vnd = two*(bcdatad(nn)%rface(j, k)-ww2d(j, k, ivx)*bcdata(nn)%norm&
            &       (j, k, 1)-ww2(j, k, ivx)*bcdatad(nn)%norm(j, k, 1)-ww2d(j, k, &
            &       ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivy)*bcdatad(nn)%norm(j&
            &       , k, 2)-ww2d(j, k, ivz)*bcdata(nn)%norm(j, k, 3)-ww2(j, k, ivz)*&
            &       bcdatad(nn)%norm(j, k, 3))
       vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
            &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
            &       bcdata(nn)%norm(j, k, 3))
       ww1d(j, k, irho) = ww2d(j, k, irho)
       ww1(j, k, irho) = ww2(j, k, irho)
       ww1d(j, k, ivx) = ww2d(j, k, ivx) + vnd*bcdata(nn)%norm(j, k, 1) +&
            &       vn*bcdatad(nn)%norm(j, k, 1)
       ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
       ww1d(j, k, ivy) = ww2d(j, k, ivy) + vnd*bcdata(nn)%norm(j, k, 2) +&
            &       vn*bcdatad(nn)%norm(j, k, 2)
       ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
       ww1d(j, k, ivz) = ww2d(j, k, ivz) + vnd*bcdata(nn)%norm(j, k, 3) +&
            &       vn*bcdatad(nn)%norm(j, k, 3)
       ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
       ! Just copy the turbulent variables.
       DO l=nt1mg,nt2mg
          ww1d(j, k, l) = ww2d(j, k, l)
          ww1(j, k, l) = ww2(j, k, l)
       END DO
       ! The laminar and eddy viscosity, if present.
       IF (viscous) THEN
          rlv1d(j, k) = rlv2d(j, k)
          rlv1(j, k) = rlv2(j, k)
       END IF
       IF (eddymodel) THEN
          rev1d(j, k) = rev2d(j, k)
          rev1(j, k) = rev2(j, k)
       END IF
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2_D(ww1, ww1d, pp1, pp1d, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_D(correctfork)
  END SUBROUTINE BCEULERWALL2_D
  SUBROUTINE BCEULERWALL2(nn, secondhalo, correctfork)
    !
    ! ******************************************************************
    ! *                                                                *
    ! * bcEulerWall applies the inviscid wall boundary condition to    *
    ! * a block. It is assumed that the bcpointers are                 *
    ! * already set to the correct block on the correct grid level.    *
    ! *                                                                *
    ! ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE INPUTDISCRETIZATION
    USE INPUTPHYSICS
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables.
    INTEGER(kind=inttype) :: j, k, l, ii
    INTEGER(kind=inttype) :: jm1, jp1, km1, kp1
    INTEGER(kind=inttype) :: walltreatment
    REAL(kind=realtype) :: sixa, siya, siza, sjxa, sjya, sjza
    REAL(kind=realtype) :: skxa, skya, skza, a1, b1
    REAL(kind=realtype) :: rxj, ryj, rzj, rxk, ryk, rzk
    REAL(kind=realtype) :: dpj, dpk, ri, rj, rk, qj, qk, vn
    REAL(kind=realtype) :: uux, uuy, uuz
    REAL(kind=realtype), DIMENSION(isize, jsize) :: grad
    INTRINSIC MOD
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(kind=realtype) :: DIM
    INTEGER(kind=inttype) :: max2
    INTEGER(kind=inttype) :: max1
    ! Make sure that on the coarser grids the constant pressure
    ! boundary condition is used.
    walltreatment = wallbctreatment
    IF (currentlevel .GT. groundlevel) walltreatment = constantpressure
    ! **************************************************************
    ! *                                                            *
    ! * Determine the boundary condition treatment and compute the *
    ! * undivided pressure gradient accordingly. This gradient is  *
    ! * temporarily stored in the halo pressure.                   *
    ! *                                                            *
    ! **************************************************************
    !
    SELECT CASE  (walltreatment) 
    CASE (constantpressure) 
       ! Constant pressure. Set the gradient to zero.
       grad = zero
    CASE (linextrapolpressure) 
       ! Linear extrapolation. 
       DO ii=0,isize*jsize-1
          j = MOD(ii, isize) + 1
          k = ii/isize + 1
          grad(j, k) = pp3(j, k) - pp2(j, k)
       END DO
    CASE (normalmomentum) 
       ! Pressure gradient is computed using the normal momentum
       ! equation. First set a couple of additional variables for
       ! the normals, depending on the block face. Note that the
       ! construction 1: should not be used in these pointers,
       ! because element 0 is needed. Consequently there will be
       ! an offset of 1 for these normals. This is commented in
       ! the code. For moving faces also the grid velocity of
       ! the 1st cell center from the wall is needed.
       DO ii=0,isize*jsize-1
          j = MOD(ii, isize) + 1
          k = ii/isize + 1
          ! Store the indices k+1, k-1 a bit easier and make
          ! sure that they do not exceed the range of the arrays.
          km1 = k - 1
          IF (1 .LT. km1) THEN
             km1 = km1
          ELSE
             km1 = 1
          END IF
          kp1 = k + 1
          IF (jsize .GT. kp1) THEN
             kp1 = kp1
          ELSE
             kp1 = jsize
          END IF
          IF (1_intType .LT. kp1 - km1) THEN
             max1 = kp1 - km1
          ELSE
             max1 = 1_intType
          END IF
          ! Compute the scaling factor for the central difference
          ! in the k-direction.
          b1 = one/max1
          ! The indices j+1 and j-1. Make sure that they
          ! do not exceed the range of the arrays.
          jm1 = j - 1
          IF (1 .LT. jm1) THEN
             jm1 = jm1
          ELSE
             jm1 = 1
          END IF
          jp1 = j + 1
          IF (isize .GT. jp1) THEN
             jp1 = jp1
          ELSE
             jp1 = isize
          END IF
          IF (1_intType .LT. jp1 - jm1) THEN
             max2 = jp1 - jm1
          ELSE
             max2 = 1_intType
          END IF
          ! Compute the scaling factor for the central
          ! difference in the j-direction.
          a1 = one/max2
          ! Compute (twice) the average normal in the generic i,
          ! j and k-direction. Note that in j and k-direction
          ! the average in the original indices should be taken
          ! using j-1 and j (and k-1 and k). However due to the
          ! usage of pointers ssj and ssk there is an offset in
          ! the indices of 1 and therefore now the correct
          ! average is obtained with the indices j and j+1
          ! (k and k+1).
          sixa = two*ssi(j, k, 1)
          siya = two*ssi(j, k, 2)
          siza = two*ssi(j, k, 3)
          sjxa = ssj(j, k, 1) + ssj(j+1, k, 1)
          sjya = ssj(j, k, 2) + ssj(j+1, k, 2)
          sjza = ssj(j, k, 3) + ssj(j+1, k, 3)
          skxa = ssk(j, k, 1) + ssk(j, k+1, 1)
          skya = ssk(j, k, 2) + ssk(j, k+1, 2)
          skza = ssk(j, k, 3) + ssk(j, k+1, 3)
          ! Compute the difference of the normal vector and
          ! pressure in j and k-direction. As the indices are
          ! restricted to the 1st halo-layer, the computation
          ! of the internal halo values is not consistent;
          ! however this is not really a problem, because these
          ! values are overwritten in the communication pattern.
          rxj = a1*(bcdata(nn)%norm(jp1, k, 1)-bcdata(nn)%norm(jm1, k, 1))
          ryj = a1*(bcdata(nn)%norm(jp1, k, 2)-bcdata(nn)%norm(jm1, k, 2))
          rzj = a1*(bcdata(nn)%norm(jp1, k, 3)-bcdata(nn)%norm(jm1, k, 3))
          dpj = a1*(pp2(jp1, k)-pp2(jm1, k))
          rxk = b1*(bcdata(nn)%norm(j, kp1, 1)-bcdata(nn)%norm(j, km1, 1))
          ryk = b1*(bcdata(nn)%norm(j, kp1, 2)-bcdata(nn)%norm(j, km1, 2))
          rzk = b1*(bcdata(nn)%norm(j, kp1, 3)-bcdata(nn)%norm(j, km1, 3))
          dpk = b1*(pp2(j, kp1)-pp2(j, km1))
          ! Compute the dot product between the unit vector
          ! and the normal vectors in i, j and k-direction.
          ri = bcdata(nn)%norm(j, k, 1)*sixa + bcdata(nn)%norm(j, k, 2)*&
               &         siya + bcdata(nn)%norm(j, k, 3)*siza
          rj = bcdata(nn)%norm(j, k, 1)*sjxa + bcdata(nn)%norm(j, k, 2)*&
               &         sjya + bcdata(nn)%norm(j, k, 3)*sjza
          rk = bcdata(nn)%norm(j, k, 1)*skxa + bcdata(nn)%norm(j, k, 2)*&
               &         skya + bcdata(nn)%norm(j, k, 3)*skza
          ! Store the velocity components in uux, uuy and uuz and
          ! subtract the mesh velocity if the face is moving.
          uux = ww2(j, k, ivx)
          uuy = ww2(j, k, ivy)
          uuz = ww2(j, k, ivz)
          IF (addgridvelocities) THEN
             uux = uux - ss(j, k, 1)
             uuy = uuy - ss(j, k, 2)
             uuz = uuz - ss(j, k, 3)
          END IF
          ! Compute the velocity components in j and
          ! k-direction.
          qj = uux*sjxa + uuy*sjya + uuz*sjza
          qk = uux*skxa + uuy*skya + uuz*skza
          ! Compute the pressure gradient, which is stored
          ! in pp1. I'm not entirely sure whether this
          ! formulation is correct for moving meshes. It could
          ! be that an additional term is needed there.
          grad(j, k) = ((qj*(uux*rxj+uuy*ryj+uuz*rzj)+qk*(uux*rxk+uuy*ryk+&
               &         uuz*rzk))*ww2(j, k, irho)-rj*dpj-rk*dpk)/ri
       END DO
    END SELECT
    ! Determine the state in the halo cell. Again loop over
    ! the cell range for this subface.
    DO ii=0,isize*jsize-1
       j = MOD(ii, isize) + 1
       k = ii/isize + 1
       ! Compute the pressure density and velocity in the
       ! halo cell. Note that rface is the grid velocity
       ! component in the direction of norm, i.e. outward
       ! pointing.
       pp1(j, k) = DIM(pp2(j, k), grad(j, k))
       vn = two*(bcdata(nn)%rface(j, k)-ww2(j, k, ivx)*bcdata(nn)%norm(j&
            &       , k, 1)-ww2(j, k, ivy)*bcdata(nn)%norm(j, k, 2)-ww2(j, k, ivz)*&
            &       bcdata(nn)%norm(j, k, 3))
       ww1(j, k, irho) = ww2(j, k, irho)
       ww1(j, k, ivx) = ww2(j, k, ivx) + vn*bcdata(nn)%norm(j, k, 1)
       ww1(j, k, ivy) = ww2(j, k, ivy) + vn*bcdata(nn)%norm(j, k, 2)
       ww1(j, k, ivz) = ww2(j, k, ivz) + vn*bcdata(nn)%norm(j, k, 3)
       ! Just copy the turbulent variables.
       DO l=nt1mg,nt2mg
          ww1(j, k, l) = ww2(j, k, l)
       END DO
       ! The laminar and eddy viscosity, if present.
       IF (viscous) rlv1(j, k) = rlv2(j, k)
       IF (eddymodel) rev1(j, k) = rev2(j, k)
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2(ww1, pp1, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
  END SUBROUTINE BCEULERWALL2
  !  Differentiation of bcfarfield2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: *rev0 *rev1 *pp0 *pp1 *rlv0
  !                *rlv1 *ww0 *ww1
  !   with respect to varying inputs: gammainf winf pinfcorr *(*bcdata.norm)
  !                *rev0 *rev1 *rev2 *pp0 *pp1 *pp2 *rlv0 *rlv1 *rlv2
  !                *ww0 *ww1 *ww2
  !   Plus diff mem management of: bcdata:in *bcdata.norm:in *bcdata.rface:in
  !                rev0:in rev1:in rev2:in pp0:in pp1:in pp2:in rlv0:in
  !                rlv1:in rlv2:in ww0:in ww1:in ww2:in
  SUBROUTINE BCFARFIELD2_D(nn, secondhalo, correctfork)
    !      ******************************************************************
    !      *                                                                *
    !      * bcFarfield applies the farfield boundary condition to a block. *
    !      * It is assumed that the BCPointers are already set              *
    !      *                                                                *
    !      ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE INPUTPHYSICS
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    ! Local variables.
    INTEGER(kind=inttype) :: nn, i, j, k, l, ii
    REAL(kind=realtype) :: nnx, nny, nnz
    REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
    REAL(kind=realtype) :: gm1d, ovgm1d, ac1d, ac2d
    REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    REAL(kind=realtype) :: r0d, u0d, v0d, w0d, qn0d, c0d, s0d
    REAL(kind=realtype) :: re, ue, ve, we, qne, ce
    REAL(kind=realtype) :: red, ued, ved, wed, qned, ced
    REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    REAL(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
    INTRINSIC SQRT
    INTRINSIC MOD
    REAL(kind=realtype) :: arg1
    REAL(kind=realtype) :: arg1d
    REAL(kind=realtype) :: pwr1
    REAL(kind=realtype) :: pwr1d
    REAL(kind=realtype) :: pwx1
    REAL(kind=realtype) :: pwx1d
    ! Some constants needed to compute the riemann inVariants.
    gm1d = gammainfd
    gm1 = gammainf - one
    ovgm1d = -(one*gm1d/gm1**2)
    ovgm1 = one/gm1
    ! Compute the three velocity components, the speed of sound and
    ! the entropy of the free stream.
    r0d = -(one*winfd(irho)/winf(irho)**2)
    r0 = one/winf(irho)
    u0d = winfd(ivx)
    u0 = winf(ivx)
    v0d = winfd(ivy)
    v0 = winf(ivy)
    w0d = winfd(ivz)
    w0 = winf(ivz)
    arg1d = (gammainfd*pinfcorr+gammainf*pinfcorrd)*r0 + gammainf*&
         &     pinfcorr*r0d
    arg1 = gammainf*pinfcorr*r0
    IF (arg1 .EQ. 0.0_8) THEN
       c0d = 0.0_8
    ELSE
       c0d = arg1d/(2.0*SQRT(arg1))
    END IF
    c0 = SQRT(arg1)
    IF (winf(irho) .GT. 0.0_8) THEN
       pwr1d = winf(irho)**gammainf*(LOG(winf(irho))*gammainfd+gammainf*&
            &       winfd(irho)/winf(irho))
    ELSE IF (winf(irho) .EQ. 0.0_8) THEN
       IF (gammainf .EQ. 1.0) THEN
          pwr1d = winfd(irho)
       ELSE
          pwr1d = 0.0_8
       END IF
    ELSE IF (gammainf .EQ. INT(gammainf)) THEN
       pwr1d = gammainf*winf(irho)**(gammainf-1)*winfd(irho)
    ELSE
       pwr1d = 0.0_8
    END IF
    pwr1 = winf(irho)**gammainf
    s0d = (pwr1d*pinfcorr-pwr1*pinfcorrd)/pinfcorr**2
    s0 = pwr1/pinfcorr
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Compute the normal velocity of the free stream and
       ! substract the normal velocity of the mesh.
       qn0d = u0d*bcdata(nn)%norm(i, j, 1) + u0*bcdatad(nn)%norm(i, j, 1)&
            &       + v0d*bcdata(nn)%norm(i, j, 2) + v0*bcdatad(nn)%norm(i, j, 2) + &
            &       w0d*bcdata(nn)%norm(i, j, 3) + w0*bcdatad(nn)%norm(i, j, 3)
       qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
            &       w0*bcdata(nn)%norm(i, j, 3)
       vn0 = qn0 - bcdata(nn)%rface(i, j)
       ! Compute the three velocity components, the normal
       ! velocity and the speed of sound of the current state
       ! in the internal cell.
       red = -(one*ww2d(i, j, irho)/ww2(i, j, irho)**2)
       re = one/ww2(i, j, irho)
       ued = ww2d(i, j, ivx)
       ue = ww2(i, j, ivx)
       ved = ww2d(i, j, ivy)
       ve = ww2(i, j, ivy)
       wed = ww2d(i, j, ivz)
       we = ww2(i, j, ivz)
       qned = ued*bcdata(nn)%norm(i, j, 1) + ue*bcdatad(nn)%norm(i, j, 1)&
            &       + ved*bcdata(nn)%norm(i, j, 2) + ve*bcdatad(nn)%norm(i, j, 2) + &
            &       wed*bcdata(nn)%norm(i, j, 3) + we*bcdatad(nn)%norm(i, j, 3)
       qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
            &       we*bcdata(nn)%norm(i, j, 3)
       arg1d = gamma2(i, j)*(pp2d(i, j)*re+pp2(i, j)*red)
       arg1 = gamma2(i, j)*pp2(i, j)*re
       IF (arg1 .EQ. 0.0_8) THEN
          ced = 0.0_8
       ELSE
          ced = arg1d/(2.0*SQRT(arg1))
       END IF
       ce = SQRT(arg1)
       ! Compute the new values of the riemann inVariants in
       ! the halo cell. Either the value in the internal cell
       ! is taken (positive sign of the corresponding
       ! eigenvalue) or the free stream value is taken
       ! (otherwise).
       IF (vn0 .GT. -c0) THEN
          ! Outflow or subsonic inflow.
          ac1d = qned + two*(ovgm1d*ce+ovgm1*ced)
          ac1 = qne + two*ovgm1*ce
       ELSE
          ! Supersonic inflow.
          ac1d = qn0d + two*(ovgm1d*c0+ovgm1*c0d)
          ac1 = qn0 + two*ovgm1*c0
       END IF
       IF (vn0 .GT. c0) THEN
          ! Supersonic outflow.
          ac2d = qned - two*(ovgm1d*ce+ovgm1*ced)
          ac2 = qne - two*ovgm1*ce
       ELSE
          ! Inflow or subsonic outflow.
          ac2d = qn0d - two*(ovgm1d*c0+ovgm1*c0d)
          ac2 = qn0 - two*ovgm1*c0
       END IF
       qnfd = half*(ac1d+ac2d)
       qnf = half*(ac1+ac2)
       cfd = fourth*((ac1d-ac2d)*gm1+(ac1-ac2)*gm1d)
       cf = fourth*(ac1-ac2)*gm1
       IF (vn0 .GT. zero) THEN
          ! Outflow.
          ufd = ued + (qnfd-qned)*bcdata(nn)%norm(i, j, 1) + (qnf-qne)*&
               &         bcdatad(nn)%norm(i, j, 1)
          uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
          vfd = ved + (qnfd-qned)*bcdata(nn)%norm(i, j, 2) + (qnf-qne)*&
               &         bcdatad(nn)%norm(i, j, 2)
          vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
          wfd = wed + (qnfd-qned)*bcdata(nn)%norm(i, j, 3) + (qnf-qne)*&
               &         bcdatad(nn)%norm(i, j, 3)
          wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
          IF (ww2(i, j, irho) .GT. 0.0_8 .OR. (ww2(i, j, irho) .LT. 0.0_8 &
               &           .AND. gamma2(i, j) .EQ. INT(gamma2(i, j)))) THEN
             pwr1d = gamma2(i, j)*ww2(i, j, irho)**(gamma2(i, j)-1)*ww2d(i&
                  &           , j, irho)
          ELSE IF (ww2(i, j, irho) .EQ. 0.0_8 .AND. gamma2(i, j) .EQ. 1.0&
               &       ) THEN
             pwr1d = ww2d(i, j, irho)
          ELSE
             pwr1d = 0.0_8
          END IF
          pwr1 = ww2(i, j, irho)**gamma2(i, j)
          sfd = (pwr1d*pp2(i, j)-pwr1*pp2d(i, j))/pp2(i, j)**2
          sf = pwr1/pp2(i, j)
          DO l=nt1mg,nt2mg
             ww1d(i, j, l) = ww2d(i, j, l)
             ww1(i, j, l) = ww2(i, j, l)
          END DO
       ELSE
          ! Inflow
          ufd = u0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 1) + (qnf-qn0)*&
               &         bcdatad(nn)%norm(i, j, 1)
          uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
          vfd = v0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 2) + (qnf-qn0)*&
               &         bcdatad(nn)%norm(i, j, 2)
          vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
          wfd = w0d + (qnfd-qn0d)*bcdata(nn)%norm(i, j, 3) + (qnf-qn0)*&
               &         bcdatad(nn)%norm(i, j, 3)
          wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
          sfd = s0d
          sf = s0
          DO l=nt1mg,nt2mg
             ww1d(i, j, l) = winfd(l)
             ww1(i, j, l) = winf(l)
          END DO
       END IF
       ! Compute the density, velocity and pressure in the
       ! halo cell.
       ccd = (cfd*cf+cf*cfd)/gamma2(i, j)
       cc = cf*cf/gamma2(i, j)
       qq = uf*uf + vf*vf + wf*wf
       pwx1d = sfd*cc + sf*ccd
       pwx1 = sf*cc
       IF (pwx1 .GT. 0.0_8) THEN
          ww1d(i, j, irho) = pwx1**ovgm1*(LOG(pwx1)*ovgm1d+ovgm1*pwx1d/&
               &         pwx1)
       ELSE IF (pwx1 .EQ. 0.0_8) THEN
          IF (ovgm1 .EQ. 1.0) THEN
             ww1d(i, j, irho) = pwx1d
          ELSE
             ww1d(i, j, irho) = 0.0_8
          END IF
       ELSE IF (ovgm1 .EQ. INT(ovgm1)) THEN
          ww1d(i, j, irho) = ovgm1*pwx1**(ovgm1-1)*pwx1d
       ELSE
          ww1d(i, j, irho) = 0.0_8
       END IF
       ww1(i, j, irho) = pwx1**ovgm1
       ww1d(i, j, ivx) = ufd
       ww1(i, j, ivx) = uf
       ww1d(i, j, ivy) = vfd
       ww1(i, j, ivy) = vf
       ww1d(i, j, ivz) = wfd
       ww1(i, j, ivz) = wf
       pp1d(i, j) = ww1d(i, j, irho)*cc + ww1(i, j, irho)*ccd
       pp1(i, j) = ww1(i, j, irho)*cc
       ! Simply set the laminar and eddy viscosity to
       ! the value in the donor cell. Their values do
       ! not matter too much in the far field.
       IF (viscous) THEN
          rlv1d(i, j) = rlv2d(i, j)
          rlv1(i, j) = rlv2(i, j)
       END IF
       IF (eddymodel) THEN
          rev1d(i, j) = rev2d(i, j)
          rev1(i, j) = rev2(i, j)
       END IF
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2_D(ww1, ww1d, pp1, pp1d, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2_D(correctfork)
  END SUBROUTINE BCFARFIELD2_D
  SUBROUTINE BCFARFIELD2(nn, secondhalo, correctfork)
    !      ******************************************************************
    !      *                                                                *
    !      * bcFarfield applies the farfield boundary condition to a block. *
    !      * It is assumed that the BCPointers are already set              *
    !      *                                                                *
    !      ******************************************************************
    !
    USE BLOCKPOINTERS
    USE BCTYPES
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE INPUTPHYSICS
    USE ITERATION
    IMPLICIT NONE
    ! Subroutine arguments.
    LOGICAL, INTENT(IN) :: secondhalo, correctfork
    ! Local variables.
    INTEGER(kind=inttype) :: nn, i, j, k, l, ii
    REAL(kind=realtype) :: nnx, nny, nnz
    REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
    REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
    REAL(kind=realtype) :: re, ue, ve, we, qne, ce
    REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
    INTRINSIC SQRT
    INTRINSIC MOD
    REAL(kind=realtype) :: arg1
    REAL(kind=realtype) :: pwr1
    REAL(kind=realtype) :: pwx1
    ! Some constants needed to compute the riemann inVariants.
    gm1 = gammainf - one
    ovgm1 = one/gm1
    ! Compute the three velocity components, the speed of sound and
    ! the entropy of the free stream.
    r0 = one/winf(irho)
    u0 = winf(ivx)
    v0 = winf(ivy)
    w0 = winf(ivz)
    arg1 = gammainf*pinfcorr*r0
    c0 = SQRT(arg1)
    pwr1 = winf(irho)**gammainf
    s0 = pwr1/pinfcorr
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Compute the normal velocity of the free stream and
       ! substract the normal velocity of the mesh.
       qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2) + &
            &       w0*bcdata(nn)%norm(i, j, 3)
       vn0 = qn0 - bcdata(nn)%rface(i, j)
       ! Compute the three velocity components, the normal
       ! velocity and the speed of sound of the current state
       ! in the internal cell.
       re = one/ww2(i, j, irho)
       ue = ww2(i, j, ivx)
       ve = ww2(i, j, ivy)
       we = ww2(i, j, ivz)
       qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2) + &
            &       we*bcdata(nn)%norm(i, j, 3)
       arg1 = gamma2(i, j)*pp2(i, j)*re
       ce = SQRT(arg1)
       ! Compute the new values of the riemann inVariants in
       ! the halo cell. Either the value in the internal cell
       ! is taken (positive sign of the corresponding
       ! eigenvalue) or the free stream value is taken
       ! (otherwise).
       IF (vn0 .GT. -c0) THEN
          ! Outflow or subsonic inflow.
          ac1 = qne + two*ovgm1*ce
       ELSE
          ! Supersonic inflow.
          ac1 = qn0 + two*ovgm1*c0
       END IF
       IF (vn0 .GT. c0) THEN
          ! Supersonic outflow.
          ac2 = qne - two*ovgm1*ce
       ELSE
          ! Inflow or subsonic outflow.
          ac2 = qn0 - two*ovgm1*c0
       END IF
       qnf = half*(ac1+ac2)
       cf = fourth*(ac1-ac2)*gm1
       IF (vn0 .GT. zero) THEN
          ! Outflow.
          uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
          vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
          wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
          pwr1 = ww2(i, j, irho)**gamma2(i, j)
          sf = pwr1/pp2(i, j)
          DO l=nt1mg,nt2mg
             ww1(i, j, l) = ww2(i, j, l)
          END DO
       ELSE
          ! Inflow
          uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
          vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
          wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
          sf = s0
          DO l=nt1mg,nt2mg
             ww1(i, j, l) = winf(l)
          END DO
       END IF
       ! Compute the density, velocity and pressure in the
       ! halo cell.
       cc = cf*cf/gamma2(i, j)
       qq = uf*uf + vf*vf + wf*wf
       pwx1 = sf*cc
       ww1(i, j, irho) = pwx1**ovgm1
       ww1(i, j, ivx) = uf
       ww1(i, j, ivy) = vf
       ww1(i, j, ivz) = wf
       pp1(i, j) = ww1(i, j, irho)*cc
       ! Simply set the laminar and eddy viscosity to
       ! the value in the donor cell. Their values do
       ! not matter too much in the far field.
       IF (viscous) rlv1(i, j) = rlv2(i, j)
       IF (eddymodel) rev1(i, j) = rev2(i, j)
    END DO
    ! Compute the energy for these halo's.
    CALL COMPUTEETOT2(ww1, pp1, correctfork)
    ! Extrapolate the state vectors in case a second halo
    ! is needed.
    IF (secondhalo) CALL EXTRAPOLATE2NDHALO2(correctfork)
  END SUBROUTINE BCFARFIELD2
  !  Differentiation of extrapolate2ndhalo2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: *rev0 *pp0 *rlv0 *ww0
  !   with respect to varying inputs: *rev0 *rev1 *pp0 *pp1 *pp2
  !                *rlv0 *rlv1 *ww0 *ww1 *ww2
  !   Plus diff mem management of: rev0:in rev1:in pp0:in pp1:in
  !                pp2:in rlv0:in rlv1:in ww0:in ww1:in ww2:in
  SUBROUTINE EXTRAPOLATE2NDHALO2_D(correctfork)
    !
    !      ******************************************************************
    !      *                                                                *
    !      * extrapolate2ndHalo determines the states of the second layer   *
    !      * halo cells for the given subface of the block. It is assumed   *
    !      * that the appropriate BCPointers are already set
    !      *                                                                *
    !      ******************************************************************
    !
    USE BCTYPES
    USE BLOCKPOINTERS
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    USE INPUTPHYSICS
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: correctfork
    REAL(kind=realtype), PARAMETER :: factor=0.5_realType
    INTEGER(kind=inttype) :: i, j, l, ii
    INTRINSIC MOD
    INTRINSIC MAX
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Extrapolate the density, momentum and pressure.
       ! Make sure that a certain threshold is kept.
       ww0d(i, j, irho) = two*ww1d(i, j, irho) - ww2d(i, j, irho)
       ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
       IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
          ww0(i, j, irho) = ww0(i, j, irho)
       ELSE
          ww0d(i, j, irho) = factor*ww1d(i, j, irho)
          ww0(i, j, irho) = factor*ww1(i, j, irho)
       END IF
       ww0d(i, j, ivx) = two*ww1d(i, j, ivx) - ww2d(i, j, ivx)
       ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
       ww0d(i, j, ivy) = two*ww1d(i, j, ivy) - ww2d(i, j, ivy)
       ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
       ww0d(i, j, ivz) = two*ww1d(i, j, ivz) - ww2d(i, j, ivz)
       ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
       IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
          pp0d(i, j) = two*pp1d(i, j) - pp2d(i, j)
          pp0(i, j) = two*pp1(i, j) - pp2(i, j)
       ELSE
          pp0d(i, j) = factor*pp1d(i, j)
          pp0(i, j) = factor*pp1(i, j)
       END IF
       ! Extrapolate the turbulent variables. Use constant
       ! extrapolation.
       DO l=nt1mg,nt2mg
          ww0d(i, j, l) = ww1d(i, j, l)
          ww0(i, j, l) = ww1(i, j, l)
       END DO
       ! The laminar and eddy viscosity, if present. These values
       ! are simply taken constant. Their values do not matter.
       IF (viscous) THEN
          rlv0d(i, j) = rlv1d(i, j)
          rlv0(i, j) = rlv1(i, j)
       END IF
       IF (eddymodel) THEN
          rev0d(i, j) = rev1d(i, j)
          rev0(i, j) = rev1(i, j)
       END IF
    END DO
    ! Compute the energy for this halo range.
    CALL COMPUTEETOT2_D(ww0, ww0d, pp0, pp0d, correctfork)
  END SUBROUTINE EXTRAPOLATE2NDHALO2_D
  !  Differentiation of computeetot2 in forward (tangent) mode (with options i4 dr8 r8):
  !   variations   of useful results: ww
  !   with respect to varying inputs: ww pp
  SUBROUTINE COMPUTEETOT2_D(ww, wwd, pp, ppd, correctfork)
    ! Simplified total energy computation for boundary conditions.
    ! Only implements the constant cpModel
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE INPUTPHYSICS
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(:, :) :: pp
    REAL(kind=realtype), DIMENSION(:, :) :: ppd
    REAL(kind=realtype), DIMENSION(:, :, :) :: ww
    REAL(kind=realtype), DIMENSION(:, :, :) :: wwd
    LOGICAL :: correctfork
    INTEGER(kind=inttype) :: ii, i, j
    REAL(kind=realtype) :: ovgm1, factk
    INTRINSIC MOD
    SELECT CASE  (cpmodel) 
    CASE (cpconstant) 
       ! Constant cp and thus constant gamma.
       ! Abbreviate 1/(gamma -1) a bit easier.
       ovgm1 = one/(gammaconstant-one)
       factk = ovgm1*(five*third-gammaconstant)
       ! Loop over the given array and compute the energy, possibly
       ! correcting for K
       DO ii=0,isize*jsize-1
          i = MOD(ii, isize) + 1
          j = ii/isize + 1
          IF (.NOT.correctfork) THEN
             wwd(i, j, irhoe) = ovgm1*ppd(i, j) + half*(wwd(i, j, irho)*(ww&
                  &           (i, j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)+ww(i, j, &
                  &           irho)*(2*ww(i, j, ivx)*wwd(i, j, ivx)+2*ww(i, j, ivy)*wwd(i&
                  &           , j, ivy)+2*ww(i, j, ivz)*wwd(i, j, ivz)))
             ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
                  &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
          ELSE
             wwd(i, j, irhoe) = ovgm1*ppd(i, j) + half*(wwd(i, j, irho)*(ww&
                  &           (i, j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)+ww(i, j, &
                  &           irho)*(2*ww(i, j, ivx)*wwd(i, j, ivx)+2*ww(i, j, ivy)*wwd(i&
                  &           , j, ivy)+2*ww(i, j, ivz)*wwd(i, j, ivz))) - factk*(wwd(i, j&
                  &           , irho)*ww(i, j, itu1)+ww(i, j, irho)*wwd(i, j, itu1))
             ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
                  &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
                  &           j, irho)*ww(i, j, itu1)
          END IF
       END DO
    CASE (cptempcurvefits) 
       CALL TERMINATE('BCRoutines', &
            &                 'CPTempCurveFits not implemented yet.')
    END SELECT
  END SUBROUTINE COMPUTEETOT2_D
  SUBROUTINE EXTRAPOLATE2NDHALO2(correctfork)
    !
    !      ******************************************************************
    !      *                                                                *
    !      * extrapolate2ndHalo determines the states of the second layer   *
    !      * halo cells for the given subface of the block. It is assumed   *
    !      * that the appropriate BCPointers are already set
    !      *                                                                *
    !      ******************************************************************
    !
    USE BCTYPES
    USE BLOCKPOINTERS
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE ITERATION
    USE INPUTPHYSICS
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: correctfork
    REAL(kind=realtype), PARAMETER :: factor=0.5_realType
    INTEGER(kind=inttype) :: i, j, l, ii
    INTRINSIC MOD
    INTRINSIC MAX
    ! Loop over the generic subface to set the state in the
    ! halo cells.
    DO ii=0,isize*jsize-1
       i = MOD(ii, isize) + 1
       j = ii/isize + 1
       ! Extrapolate the density, momentum and pressure.
       ! Make sure that a certain threshold is kept.
       ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
       IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
          ww0(i, j, irho) = ww0(i, j, irho)
       ELSE
          ww0(i, j, irho) = factor*ww1(i, j, irho)
       END IF
       ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
       ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
       ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
       IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
          pp0(i, j) = two*pp1(i, j) - pp2(i, j)
       ELSE
          pp0(i, j) = factor*pp1(i, j)
       END IF
       ! Extrapolate the turbulent variables. Use constant
       ! extrapolation.
       DO l=nt1mg,nt2mg
          ww0(i, j, l) = ww1(i, j, l)
       END DO
       ! The laminar and eddy viscosity, if present. These values
       ! are simply taken constant. Their values do not matter.
       IF (viscous) rlv0(i, j) = rlv1(i, j)
       IF (eddymodel) rev0(i, j) = rev1(i, j)
    END DO
    ! Compute the energy for this halo range.
    CALL COMPUTEETOT2(ww0, pp0, correctfork)
  END SUBROUTINE EXTRAPOLATE2NDHALO2
  SUBROUTINE COMPUTEETOT2(ww, pp, correctfork)
    ! Simplified total energy computation for boundary conditions.
    ! Only implements the constant cpModel
    USE CONSTANTS
    USE FLOWVARREFSTATE
    USE INPUTPHYSICS
    IMPLICIT NONE
    REAL(kind=realtype), DIMENSION(:, :) :: pp
    REAL(kind=realtype), DIMENSION(:, :, :) :: ww
    LOGICAL :: correctfork
    INTEGER(kind=inttype) :: ii, i, j
    REAL(kind=realtype) :: ovgm1, factk
    INTRINSIC MOD
    SELECT CASE  (cpmodel) 
    CASE (cpconstant) 
       ! Constant cp and thus constant gamma.
       ! Abbreviate 1/(gamma -1) a bit easier.
       ovgm1 = one/(gammaconstant-one)
       factk = ovgm1*(five*third-gammaconstant)
       ! Loop over the given array and compute the energy, possibly
       ! correcting for K
       DO ii=0,isize*jsize-1
          i = MOD(ii, isize) + 1
          j = ii/isize + 1
          IF (.NOT.correctfork) THEN
             ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
                  &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2)
          ELSE
             ww(i, j, irhoe) = ovgm1*pp(i, j) + half*ww(i, j, irho)*(ww(i, &
                  &           j, ivx)**2+ww(i, j, ivy)**2+ww(i, j, ivz)**2) - factk*ww(i, &
                  &           j, irho)*ww(i, j, itu1)
          END IF
       END DO
    CASE (cptempcurvefits) 
       CALL TERMINATE('BCRoutines', &
            &                 'CPTempCurveFits not implemented yet.')
    END SELECT
  END SUBROUTINE COMPUTEETOT2
  !  Differentiation of setbcpointers2 in forward (tangent) mode (with options i4 dr8 r8):
  !   Plus diff mem management of: rev:in p:in s:in w:in rlv:in x:in
  !                si:in sj:in sk:in bcdata:in rev0:in-out rev1:in-out
  !                rev2:in-out rev3:in-out pp0:in-out pp1:in-out
  !                pp2:in-out pp3:in-out rlv0:in-out rlv1:in-out
  !                rlv2:in-out rlv3:in-out ss:in-out ssi:in-out ssj:in-out
  !                ssk:in-out ww0:in-out ww1:in-out ww2:in-out ww3:in-out
  SUBROUTINE SETBCPOINTERS2_D(nn)
    !
    !      ******************************************************************
    !      *                                                                *
    !      * setBCPointers sets the pointers needed for the boundary        *
    !      * condition treatment on a general face, such that the boundary  *
    !      * routines are only implemented once instead of 6 times.         *
    !      *                                                                *
    !      ******************************************************************
    !
    USE BCTYPES
    USE BLOCKPOINTERS
    USE FLOWVARREFSTATE
    IMPLICIT NONE
    ! Subroutine arguments.
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables
    INTEGER(kind=inttype) :: istart, iend, jstart, jend
    ! Determine the sizes of each face and point to just the range we
    ! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
    ! Set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
    ! Determine the face id on which the subface is located and set
    ! the pointers accordinly.
    SELECT CASE  (bcfaceid(nn)) 
    CASE (imin) 
       !===============================================================
       ww3d => wd(3, istart:iend, jstart:jend, :)
       ww3 => w(3, istart:iend, jstart:jend, :)
       ww2d => wd(2, istart:iend, jstart:jend, :)
       ww2 => w(2, istart:iend, jstart:jend, :)
       ww1d => wd(1, istart:iend, jstart:jend, :)
       ww1 => w(1, istart:iend, jstart:jend, :)
       ww0d => wd(0, istart:iend, jstart:jend, :)
       ww0 => w(0, istart:iend, jstart:jend, :)
       pp3d => pd(3, istart:iend, jstart:jend)
       pp3 => p(3, istart:iend, jstart:jend)
       pp2d => pd(2, istart:iend, jstart:jend)
       pp2 => p(2, istart:iend, jstart:jend)
       pp1d => pd(1, istart:iend, jstart:jend)
       pp1 => p(1, istart:iend, jstart:jend)
       pp0d => pd(0, istart:iend, jstart:jend)
       pp0 => p(0, istart:iend, jstart:jend)
       rlv3d => rlvd(3, istart:iend, jstart:jend)
       rlv3 => rlv(3, istart:iend, jstart:jend)
       rlv2d => rlvd(2, istart:iend, jstart:jend)
       rlv2 => rlv(2, istart:iend, jstart:jend)
       rlv1d => rlvd(1, istart:iend, jstart:jend)
       rlv1 => rlv(1, istart:iend, jstart:jend)
       rlv0d => rlvd(0, istart:iend, jstart:jend)
       rlv0 => rlv(0, istart:iend, jstart:jend)
       rev3d => revd(3, istart:iend, jstart:jend)
       rev3 => rev(3, istart:iend, jstart:jend)
       rev2d => revd(2, istart:iend, jstart:jend)
       rev2 => rev(2, istart:iend, jstart:jend)
       rev1d => revd(1, istart:iend, jstart:jend)
       rev1 => rev(1, istart:iend, jstart:jend)
       rev0d => revd(0, istart:iend, jstart:jend)
       rev0 => rev(0, istart:iend, jstart:jend)
       gamma3 => gamma(3, istart:iend, jstart:jend)
       gamma2 => gamma(2, istart:iend, jstart:jend)
       gamma1 => gamma(1, istart:iend, jstart:jend)
       gamma0 => gamma(0, istart:iend, jstart:jend)
    CASE (imax) 
       !===============================================================
       ww3d => wd(nx, istart:iend, jstart:jend, :)
       ww3 => w(nx, istart:iend, jstart:jend, :)
       ww2d => wd(il, istart:iend, jstart:jend, :)
       ww2 => w(il, istart:iend, jstart:jend, :)
       ww1d => wd(ie, istart:iend, jstart:jend, :)
       ww1 => w(ie, istart:iend, jstart:jend, :)
       ww0d => wd(ib, istart:iend, jstart:jend, :)
       ww0 => w(ib, istart:iend, jstart:jend, :)
       pp3d => pd(nx, istart:iend, jstart:jend)
       pp3 => p(nx, istart:iend, jstart:jend)
       pp2d => pd(il, istart:iend, jstart:jend)
       pp2 => p(il, istart:iend, jstart:jend)
       pp1d => pd(ie, istart:iend, jstart:jend)
       pp1 => p(ie, istart:iend, jstart:jend)
       pp0d => pd(ib, istart:iend, jstart:jend)
       pp0 => p(ib, istart:iend, jstart:jend)
       rlv3d => rlvd(nx, istart:iend, jstart:jend)
       rlv3 => rlv(nx, istart:iend, jstart:jend)
       rlv2d => rlvd(il, istart:iend, jstart:jend)
       rlv2 => rlv(il, istart:iend, jstart:jend)
       rlv1d => rlvd(ie, istart:iend, jstart:jend)
       rlv1 => rlv(ie, istart:iend, jstart:jend)
       rlv0d => rlvd(ib, istart:iend, jstart:jend)
       rlv0 => rlv(ib, istart:iend, jstart:jend)
       rev3d => revd(nx, istart:iend, jstart:jend)
       rev3 => rev(nx, istart:iend, jstart:jend)
       rev2d => revd(il, istart:iend, jstart:jend)
       rev2 => rev(il, istart:iend, jstart:jend)
       rev1d => revd(ie, istart:iend, jstart:jend)
       rev1 => rev(ie, istart:iend, jstart:jend)
       rev0d => revd(ib, istart:iend, jstart:jend)
       rev0 => rev(ib, istart:iend, jstart:jend)
       gamma3 => gamma(nx, istart:iend, jstart:jend)
       gamma2 => gamma(il, istart:iend, jstart:jend)
       gamma1 => gamma(ie, istart:iend, jstart:jend)
       gamma0 => gamma(ib, istart:iend, jstart:jend)
    CASE (jmin) 
       !===============================================================
       ww3d => wd(istart:iend, 3, jstart:jend, :)
       ww3 => w(istart:iend, 3, jstart:jend, :)
       ww2d => wd(istart:iend, 2, jstart:jend, :)
       ww2 => w(istart:iend, 2, jstart:jend, :)
       ww1d => wd(istart:iend, 1, jstart:jend, :)
       ww1 => w(istart:iend, 1, jstart:jend, :)
       ww0d => wd(istart:iend, 0, jstart:jend, :)
       ww0 => w(istart:iend, 0, jstart:jend, :)
       pp3d => pd(istart:iend, 3, jstart:jend)
       pp3 => p(istart:iend, 3, jstart:jend)
       pp2d => pd(istart:iend, 2, jstart:jend)
       pp2 => p(istart:iend, 2, jstart:jend)
       pp1d => pd(istart:iend, 1, jstart:jend)
       pp1 => p(istart:iend, 1, jstart:jend)
       pp0d => pd(istart:iend, 0, jstart:jend)
       pp0 => p(istart:iend, 0, jstart:jend)
       rlv3d => rlvd(istart:iend, 3, jstart:jend)
       rlv3 => rlv(istart:iend, 3, jstart:jend)
       rlv2d => rlvd(istart:iend, 2, jstart:jend)
       rlv2 => rlv(istart:iend, 2, jstart:jend)
       rlv1d => rlvd(istart:iend, 1, jstart:jend)
       rlv1 => rlv(istart:iend, 1, jstart:jend)
       rlv0d => rlvd(istart:iend, 0, jstart:jend)
       rlv0 => rlv(istart:iend, 0, jstart:jend)
       rev3d => revd(istart:iend, 3, jstart:jend)
       rev3 => rev(istart:iend, 3, jstart:jend)
       rev2d => revd(istart:iend, 2, jstart:jend)
       rev2 => rev(istart:iend, 2, jstart:jend)
       rev1d => revd(istart:iend, 1, jstart:jend)
       rev1 => rev(istart:iend, 1, jstart:jend)
       rev0d => revd(istart:iend, 0, jstart:jend)
       rev0 => rev(istart:iend, 0, jstart:jend)
       gamma3 => gamma(istart:iend, 3, jstart:jend)
       gamma2 => gamma(istart:iend, 2, jstart:jend)
       gamma1 => gamma(istart:iend, 1, jstart:jend)
       gamma0 => gamma(istart:iend, 0, jstart:jend)
    CASE (jmax) 
       !===============================================================
       ww3d => wd(istart:iend, ny, jstart:jend, :)
       ww3 => w(istart:iend, ny, jstart:jend, :)
       ww2d => wd(istart:iend, jl, jstart:jend, :)
       ww2 => w(istart:iend, jl, jstart:jend, :)
       ww1d => wd(istart:iend, je, jstart:jend, :)
       ww1 => w(istart:iend, je, jstart:jend, :)
       ww0d => wd(istart:iend, jb, jstart:jend, :)
       ww0 => w(istart:iend, jb, jstart:jend, :)
       pp3d => pd(istart:iend, ny, jstart:jend)
       pp3 => p(istart:iend, ny, jstart:jend)
       pp2d => pd(istart:iend, jl, jstart:jend)
       pp2 => p(istart:iend, jl, jstart:jend)
       pp1d => pd(istart:iend, je, jstart:jend)
       pp1 => p(istart:iend, je, jstart:jend)
       pp0d => pd(istart:iend, jb, jstart:jend)
       pp0 => p(istart:iend, jb, jstart:jend)
       rlv3d => rlvd(istart:iend, ny, jstart:jend)
       rlv3 => rlv(istart:iend, ny, jstart:jend)
       rlv2d => rlvd(istart:iend, jl, jstart:jend)
       rlv2 => rlv(istart:iend, jl, jstart:jend)
       rlv1d => rlvd(istart:iend, je, jstart:jend)
       rlv1 => rlv(istart:iend, je, jstart:jend)
       rlv0d => rlvd(istart:iend, jb, jstart:jend)
       rlv0 => rlv(istart:iend, jb, jstart:jend)
       rev3d => revd(istart:iend, ny, jstart:jend)
       rev3 => rev(istart:iend, ny, jstart:jend)
       rev2d => revd(istart:iend, jl, jstart:jend)
       rev2 => rev(istart:iend, jl, jstart:jend)
       rev1d => revd(istart:iend, je, jstart:jend)
       rev1 => rev(istart:iend, je, jstart:jend)
       rev0d => revd(istart:iend, jb, jstart:jend)
       rev0 => rev(istart:iend, jb, jstart:jend)
       gamma3 => gamma(istart:iend, ny, jstart:jend)
       gamma2 => gamma(istart:iend, jl, jstart:jend)
       gamma1 => gamma(istart:iend, je, jstart:jend)
       gamma0 => gamma(istart:iend, jb, jstart:jend)
    CASE (kmin) 
       !===============================================================
       ww3d => wd(istart:iend, jstart:jend, 3, :)
       ww3 => w(istart:iend, jstart:jend, 3, :)
       ww2d => wd(istart:iend, jstart:jend, 2, :)
       ww2 => w(istart:iend, jstart:jend, 2, :)
       ww1d => wd(istart:iend, jstart:jend, 1, :)
       ww1 => w(istart:iend, jstart:jend, 1, :)
       ww0d => wd(istart:iend, jstart:jend, 0, :)
       ww0 => w(istart:iend, jstart:jend, 0, :)
       pp3d => pd(istart:iend, jstart:jend, 3)
       pp3 => p(istart:iend, jstart:jend, 3)
       pp2d => pd(istart:iend, jstart:jend, 2)
       pp2 => p(istart:iend, jstart:jend, 2)
       pp1d => pd(istart:iend, jstart:jend, 1)
       pp1 => p(istart:iend, jstart:jend, 1)
       pp0d => pd(istart:iend, jstart:jend, 0)
       pp0 => p(istart:iend, jstart:jend, 0)
       rlv3d => rlvd(istart:iend, jstart:jend, 3)
       rlv3 => rlv(istart:iend, jstart:jend, 3)
       rlv2d => rlvd(istart:iend, jstart:jend, 2)
       rlv2 => rlv(istart:iend, jstart:jend, 2)
       rlv1d => rlvd(istart:iend, jstart:jend, 1)
       rlv1 => rlv(istart:iend, jstart:jend, 1)
       rlv0d => rlvd(istart:iend, jstart:jend, 0)
       rlv0 => rlv(istart:iend, jstart:jend, 0)
       rev3d => revd(istart:iend, jstart:jend, 3)
       rev3 => rev(istart:iend, jstart:jend, 3)
       rev2d => revd(istart:iend, jstart:jend, 2)
       rev2 => rev(istart:iend, jstart:jend, 2)
       rev1d => revd(istart:iend, jstart:jend, 1)
       rev1 => rev(istart:iend, jstart:jend, 1)
       rev0d => revd(istart:iend, jstart:jend, 0)
       rev0 => rev(istart:iend, jstart:jend, 0)
       gamma3 => gamma(istart:iend, jstart:jend, 3)
       gamma2 => gamma(istart:iend, jstart:jend, 2)
       gamma1 => gamma(istart:iend, jstart:jend, 1)
       gamma0 => gamma(istart:iend, jstart:jend, 0)
    CASE (kmax) 
       !===============================================================
       ww3d => wd(istart:iend, jstart:jend, nz, :)
       ww3 => w(istart:iend, jstart:jend, nz, :)
       ww2d => wd(istart:iend, jstart:jend, kl, :)
       ww2 => w(istart:iend, jstart:jend, kl, :)
       ww1d => wd(istart:iend, jstart:jend, ke, :)
       ww1 => w(istart:iend, jstart:jend, ke, :)
       ww0d => wd(istart:iend, jstart:jend, kb, :)
       ww0 => w(istart:iend, jstart:jend, kb, :)
       pp3d => pd(istart:iend, jstart:jend, nz)
       pp3 => p(istart:iend, jstart:jend, nz)
       pp2d => pd(istart:iend, jstart:jend, kl)
       pp2 => p(istart:iend, jstart:jend, kl)
       pp1d => pd(istart:iend, jstart:jend, ke)
       pp1 => p(istart:iend, jstart:jend, ke)
       pp0d => pd(istart:iend, jstart:jend, kb)
       pp0 => p(istart:iend, jstart:jend, kb)
       rlv3d => rlvd(istart:iend, jstart:jend, nz)
       rlv3 => rlv(istart:iend, jstart:jend, nz)
       rlv2d => rlvd(istart:iend, jstart:jend, kl)
       rlv2 => rlv(istart:iend, jstart:jend, kl)
       rlv1d => rlvd(istart:iend, jstart:jend, ke)
       rlv1 => rlv(istart:iend, jstart:jend, ke)
       rlv0d => rlvd(istart:iend, jstart:jend, kb)
       rlv0 => rlv(istart:iend, jstart:jend, kb)
       rev3d => revd(istart:iend, jstart:jend, nz)
       rev3 => rev(istart:iend, jstart:jend, nz)
       rev2d => revd(istart:iend, jstart:jend, kl)
       rev2 => rev(istart:iend, jstart:jend, kl)
       rev1d => revd(istart:iend, jstart:jend, ke)
       rev1 => rev(istart:iend, jstart:jend, ke)
       rev0d => revd(istart:iend, jstart:jend, kb)
       rev0 => rev(istart:iend, jstart:jend, kb)
       gamma3 => gamma(istart:iend, jstart:jend, nz)
       gamma2 => gamma(istart:iend, jstart:jend, kl)
       gamma1 => gamma(istart:iend, jstart:jend, ke)
       gamma0 => gamma(istart:iend, jstart:jend, kb)
    END SELECT
    SELECT CASE  (bcfaceid(nn)) 
    CASE (imin) 
       ssid => sid(1, :, :, :)
       ssi => si(1, :, :, :)
       ssjd => sjd(2, :, :, :)
       ssj => sj(2, :, :, :)
       sskd => skd(2, :, :, :)
       ssk => sk(2, :, :, :)
       ssd => sd(2, :, :, :)
       ss => s(2, :, :, :)
    CASE (imax) 
       ssid => sid(il, :, :, :)
       ssi => si(il, :, :, :)
       ssjd => sjd(il, :, :, :)
       ssj => sj(il, :, :, :)
       sskd => skd(il, :, :, :)
       ssk => sk(il, :, :, :)
       ssd => sd(il, :, :, :)
       ss => s(il, :, :, :)
    CASE (jmin) 
       ssid => sjd(:, 1, :, :)
       ssi => sj(:, 1, :, :)
       ssjd => sid(:, 2, :, :)
       ssj => si(:, 2, :, :)
       sskd => skd(:, 2, :, :)
       ssk => sk(:, 2, :, :)
       ssd => sd(:, 2, :, :)
       ss => s(:, 2, :, :)
    CASE (jmax) 
       ssid => sjd(:, jl, :, :)
       ssi => sj(:, jl, :, :)
       ssjd => sid(:, jl, :, :)
       ssj => si(:, jl, :, :)
       sskd => skd(:, jl, :, :)
       ssk => sk(:, jl, :, :)
       ssd => sd(:, jl, :, :)
       ss => s(:, jl, :, :)
    CASE (kmin) 
       ssid => skd(:, :, 1, :)
       ssi => sk(:, :, 1, :)
       ssjd => sid(:, :, 2, :)
       ssj => si(:, :, 2, :)
       sskd => sjd(:, :, 2, :)
       ssk => sj(:, :, 2, :)
       ssd => sd(:, :, 2, :)
       ss => s(:, :, 2, :)
    CASE (kmax) 
       ssid => skd(:, :, kl, :)
       ssi => sk(:, :, kl, :)
       ssjd => sid(:, :, kl, :)
       ssj => si(:, :, kl, :)
       sskd => sjd(:, :, kl, :)
       ssk => sj(:, :, kl, :)
       ssd => sd(:, :, kl, :)
       ss => s(:, :, kl, :)
    END SELECT
    SELECT CASE  (bcfaceid(nn)) 
    CASE (imin) 
       xline => x(1, :, :, :)
    CASE (imax) 
       xline => x(il, :, :, :)
    CASE (jmin) 
       xline => x(:, 1, :, :)
    CASE (jmax) 
       xline => x(:, jl, :, :)
    CASE (kmin) 
       xline => x(:, :, 1, :)
    CASE (kmax) 
       xline => x(:, :, kl, :)
    END SELECT
  END SUBROUTINE SETBCPOINTERS2_D
  SUBROUTINE SETBCPOINTERS2(nn)
    !
    !      ******************************************************************
    !      *                                                                *
    !      * setBCPointers sets the pointers needed for the boundary        *
    !      * condition treatment on a general face, such that the boundary  *
    !      * routines are only implemented once instead of 6 times.         *
    !      *                                                                *
    !      ******************************************************************
    !
    USE BCTYPES
    USE BLOCKPOINTERS
    USE FLOWVARREFSTATE
    IMPLICIT NONE
    ! Subroutine arguments.
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables
    INTEGER(kind=inttype) :: istart, iend, jstart, jend
    ! Determine the sizes of each face and point to just the range we
    ! need on each face. 
    istart = bcdata(nn)%icbeg
    iend = bcdata(nn)%icend
    jstart = bcdata(nn)%jcbeg
    jend = bcdata(nn)%jcend
    ! Set the size of the subface
    isize = iend - istart + 1
    jsize = jend - jstart + 1
    ! Determine the face id on which the subface is located and set
    ! the pointers accordinly.
    SELECT CASE  (bcfaceid(nn)) 
    CASE (imin) 
       !===============================================================
       ww3 => w(3, istart:iend, jstart:jend, :)
       ww2 => w(2, istart:iend, jstart:jend, :)
       ww1 => w(1, istart:iend, jstart:jend, :)
       ww0 => w(0, istart:iend, jstart:jend, :)
       pp3 => p(3, istart:iend, jstart:jend)
       pp2 => p(2, istart:iend, jstart:jend)
       pp1 => p(1, istart:iend, jstart:jend)
       pp0 => p(0, istart:iend, jstart:jend)
       rlv3 => rlv(3, istart:iend, jstart:jend)
       rlv2 => rlv(2, istart:iend, jstart:jend)
       rlv1 => rlv(1, istart:iend, jstart:jend)
       rlv0 => rlv(0, istart:iend, jstart:jend)
       rev3 => rev(3, istart:iend, jstart:jend)
       rev2 => rev(2, istart:iend, jstart:jend)
       rev1 => rev(1, istart:iend, jstart:jend)
       rev0 => rev(0, istart:iend, jstart:jend)
       gamma3 => gamma(3, istart:iend, jstart:jend)
       gamma2 => gamma(2, istart:iend, jstart:jend)
       gamma1 => gamma(1, istart:iend, jstart:jend)
       gamma0 => gamma(0, istart:iend, jstart:jend)
    CASE (imax) 
       !===============================================================
       ww3 => w(nx, istart:iend, jstart:jend, :)
       ww2 => w(il, istart:iend, jstart:jend, :)
       ww1 => w(ie, istart:iend, jstart:jend, :)
       ww0 => w(ib, istart:iend, jstart:jend, :)
       pp3 => p(nx, istart:iend, jstart:jend)
       pp2 => p(il, istart:iend, jstart:jend)
       pp1 => p(ie, istart:iend, jstart:jend)
       pp0 => p(ib, istart:iend, jstart:jend)
       rlv3 => rlv(nx, istart:iend, jstart:jend)
       rlv2 => rlv(il, istart:iend, jstart:jend)
       rlv1 => rlv(ie, istart:iend, jstart:jend)
       rlv0 => rlv(ib, istart:iend, jstart:jend)
       rev3 => rev(nx, istart:iend, jstart:jend)
       rev2 => rev(il, istart:iend, jstart:jend)
       rev1 => rev(ie, istart:iend, jstart:jend)
       rev0 => rev(ib, istart:iend, jstart:jend)
       gamma3 => gamma(nx, istart:iend, jstart:jend)
       gamma2 => gamma(il, istart:iend, jstart:jend)
       gamma1 => gamma(ie, istart:iend, jstart:jend)
       gamma0 => gamma(ib, istart:iend, jstart:jend)
    CASE (jmin) 
       !===============================================================
       ww3 => w(istart:iend, 3, jstart:jend, :)
       ww2 => w(istart:iend, 2, jstart:jend, :)
       ww1 => w(istart:iend, 1, jstart:jend, :)
       ww0 => w(istart:iend, 0, jstart:jend, :)
       pp3 => p(istart:iend, 3, jstart:jend)
       pp2 => p(istart:iend, 2, jstart:jend)
       pp1 => p(istart:iend, 1, jstart:jend)
       pp0 => p(istart:iend, 0, jstart:jend)
       rlv3 => rlv(istart:iend, 3, jstart:jend)
       rlv2 => rlv(istart:iend, 2, jstart:jend)
       rlv1 => rlv(istart:iend, 1, jstart:jend)
       rlv0 => rlv(istart:iend, 0, jstart:jend)
       rev3 => rev(istart:iend, 3, jstart:jend)
       rev2 => rev(istart:iend, 2, jstart:jend)
       rev1 => rev(istart:iend, 1, jstart:jend)
       rev0 => rev(istart:iend, 0, jstart:jend)
       gamma3 => gamma(istart:iend, 3, jstart:jend)
       gamma2 => gamma(istart:iend, 2, jstart:jend)
       gamma1 => gamma(istart:iend, 1, jstart:jend)
       gamma0 => gamma(istart:iend, 0, jstart:jend)
    CASE (jmax) 
       !===============================================================
       ww3 => w(istart:iend, ny, jstart:jend, :)
       ww2 => w(istart:iend, jl, jstart:jend, :)
       ww1 => w(istart:iend, je, jstart:jend, :)
       ww0 => w(istart:iend, jb, jstart:jend, :)
       pp3 => p(istart:iend, ny, jstart:jend)
       pp2 => p(istart:iend, jl, jstart:jend)
       pp1 => p(istart:iend, je, jstart:jend)
       pp0 => p(istart:iend, jb, jstart:jend)
       rlv3 => rlv(istart:iend, ny, jstart:jend)
       rlv2 => rlv(istart:iend, jl, jstart:jend)
       rlv1 => rlv(istart:iend, je, jstart:jend)
       rlv0 => rlv(istart:iend, jb, jstart:jend)
       rev3 => rev(istart:iend, ny, jstart:jend)
       rev2 => rev(istart:iend, jl, jstart:jend)
       rev1 => rev(istart:iend, je, jstart:jend)
       rev0 => rev(istart:iend, jb, jstart:jend)
       gamma3 => gamma(istart:iend, ny, jstart:jend)
       gamma2 => gamma(istart:iend, jl, jstart:jend)
       gamma1 => gamma(istart:iend, je, jstart:jend)
       gamma0 => gamma(istart:iend, jb, jstart:jend)
    CASE (kmin) 
       !===============================================================
       ww3 => w(istart:iend, jstart:jend, 3, :)
       ww2 => w(istart:iend, jstart:jend, 2, :)
       ww1 => w(istart:iend, jstart:jend, 1, :)
       ww0 => w(istart:iend, jstart:jend, 0, :)
       pp3 => p(istart:iend, jstart:jend, 3)
       pp2 => p(istart:iend, jstart:jend, 2)
       pp1 => p(istart:iend, jstart:jend, 1)
       pp0 => p(istart:iend, jstart:jend, 0)
       rlv3 => rlv(istart:iend, jstart:jend, 3)
       rlv2 => rlv(istart:iend, jstart:jend, 2)
       rlv1 => rlv(istart:iend, jstart:jend, 1)
       rlv0 => rlv(istart:iend, jstart:jend, 0)
       rev3 => rev(istart:iend, jstart:jend, 3)
       rev2 => rev(istart:iend, jstart:jend, 2)
       rev1 => rev(istart:iend, jstart:jend, 1)
       rev0 => rev(istart:iend, jstart:jend, 0)
       gamma3 => gamma(istart:iend, jstart:jend, 3)
       gamma2 => gamma(istart:iend, jstart:jend, 2)
       gamma1 => gamma(istart:iend, jstart:jend, 1)
       gamma0 => gamma(istart:iend, jstart:jend, 0)
    CASE (kmax) 
       !===============================================================
       ww3 => w(istart:iend, jstart:jend, nz, :)
       ww2 => w(istart:iend, jstart:jend, kl, :)
       ww1 => w(istart:iend, jstart:jend, ke, :)
       ww0 => w(istart:iend, jstart:jend, kb, :)
       pp3 => p(istart:iend, jstart:jend, nz)
       pp2 => p(istart:iend, jstart:jend, kl)
       pp1 => p(istart:iend, jstart:jend, ke)
       pp0 => p(istart:iend, jstart:jend, kb)
       rlv3 => rlv(istart:iend, jstart:jend, nz)
       rlv2 => rlv(istart:iend, jstart:jend, kl)
       rlv1 => rlv(istart:iend, jstart:jend, ke)
       rlv0 => rlv(istart:iend, jstart:jend, kb)
       rev3 => rev(istart:iend, jstart:jend, nz)
       rev2 => rev(istart:iend, jstart:jend, kl)
       rev1 => rev(istart:iend, jstart:jend, ke)
       rev0 => rev(istart:iend, jstart:jend, kb)
       gamma3 => gamma(istart:iend, jstart:jend, nz)
       gamma2 => gamma(istart:iend, jstart:jend, kl)
       gamma1 => gamma(istart:iend, jstart:jend, ke)
       gamma0 => gamma(istart:iend, jstart:jend, kb)
    END SELECT
    SELECT CASE  (bcfaceid(nn)) 
    CASE (imin) 
       ssi => si(1, :, :, :)
       ssj => sj(2, :, :, :)
       ssk => sk(2, :, :, :)
       ss => s(2, :, :, :)
    CASE (imax) 
       ssi => si(il, :, :, :)
       ssj => sj(il, :, :, :)
       ssk => sk(il, :, :, :)
       ss => s(il, :, :, :)
    CASE (jmin) 
       ssi => sj(:, 1, :, :)
       ssj => si(:, 2, :, :)
       ssk => sk(:, 2, :, :)
       ss => s(:, 2, :, :)
    CASE (jmax) 
       ssi => sj(:, jl, :, :)
       ssj => si(:, jl, :, :)
       ssk => sk(:, jl, :, :)
       ss => s(:, jl, :, :)
    CASE (kmin) 
       ssi => sk(:, :, 1, :)
       ssj => si(:, :, 2, :)
       ssk => sj(:, :, 2, :)
       ss => s(:, :, 2, :)
    CASE (kmax) 
       ssi => sk(:, :, kl, :)
       ssj => si(:, :, kl, :)
       ssk => sj(:, :, kl, :)
       ss => s(:, :, kl, :)
    END SELECT
    SELECT CASE  (bcfaceid(nn)) 
    CASE (imin) 
       xline => x(1, :, :, :)
    CASE (imax) 
       xline => x(il, :, :, :)
    CASE (jmin) 
       xline => x(:, 1, :, :)
    CASE (jmax) 
       xline => x(:, jl, :, :)
    CASE (kmin) 
       xline => x(:, :, 1, :)
    CASE (kmax) 
       xline => x(:, :, kl, :)
    END SELECT
  END SUBROUTINE SETBCPOINTERS2
  SUBROUTINE RESETBCPOINTERS2(nn)
    !
    !      ******************************************************************
    !      *                                                                *
    !      * resetBCPointers nullifyies the boundary pointers. For reverse  *
    !      * mode AD it copies the values back in to the respective arrays  *
    !      *                                                                *
    !      ******************************************************************
    !
    USE BCTYPES
    USE BLOCKPOINTERS
    USE FLOWVARREFSTATE
    IMPLICIT NONE
    ! Subroutine arguments.
    INTEGER(kind=inttype), INTENT(IN) :: nn
    ! Local variables
    INTEGER(kind=inttype) :: istart, iend, jstart, jend
    ! Determine the face id on which the subface is located and set
    ! the pointers accordinly.
    NULLIFY(ww0, ww1, ww2, ww3)
    NULLIFY(pp0, pp1, pp2, pp3)
    NULLIFY(rlv0, rlv1, rlv2, rlv3)
    NULLIFY(rev0, rev1, rev2, rev3)
    NULLIFY(gamma0, gamma1, gamma2, gamma3)
    NULLIFY(ssi, ssj, ssk, ss)
    NULLIFY(xline)
  END SUBROUTINE RESETBCPOINTERS2
END MODULE BCROUTINES_D

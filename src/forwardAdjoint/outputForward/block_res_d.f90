   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of block_res in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: pref *(flowdoms.x) *(flowdoms.w)
   !                *(flowdoms.dw) *(*bcdata.fp) *(*bcdata.fv) *(*bcdata.m)
   !                *(*bcdata.oarea) *(*bcdata.sepsensor) *(*bcdata.cavitation)
   !                *rev0 *rev1 *pp0 *pp1 *rlv0 *rlv1 *ww0 *ww1 funcvalues
   !                moment force cavitation sepsensor
   !   with respect to varying inputs: pref *(flowdoms.x) *(flowdoms.w)
   !                mach tempfreestream reynolds machgrid lengthref
   !                machcoef pointref *xx *rev0 *rev1 *rev2 *rev3
   !                *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ss
   !                *ssi *ssj *ssk *ww0 *ww1 *ww2 *ww3 alpha beta
   !   RW status of diff variables: mudim:(loc) gammainf:(loc) pinf:(loc)
   !                timeref:(loc) rhoinf:(loc) muref:(loc) rhoinfdim:(loc)
   !                tref:(loc) winf:(loc) muinf:(loc) uinf:(loc) pinfcorr:(loc)
   !                rgas:(loc) pinfdim:(loc) pref:in-out rhoref:(loc)
   !                *(flowdoms.x):in-out *(flowdoms.vol):(loc) *(flowdoms.w):in-out
   !                *(flowdoms.dw):out *rev:(loc) *aa:(loc) *bvtj1:(loc)
   !                *bvtj2:(loc) *wx:(loc) *wy:(loc) *wz:(loc) *p:(loc)
   !                *sfacei:(loc) *sfacej:(loc) *s:(loc) *sfacek:(loc)
   !                *rlv:(loc) *qx:(loc) *qy:(loc) *qz:(loc) *bvtk1:(loc)
   !                *bvtk2:(loc) *ux:(loc) *uy:(loc) *uz:(loc) *si:(loc)
   !                *sj:(loc) *sk:(loc) *bvti1:(loc) *bvti2:(loc)
   !                *vx:(loc) *vy:(loc) *vz:(loc) *fw:(loc) *(*viscsubface.tau):(loc)
   !                *(*bcdata.norm):(loc) *(*bcdata.rface):(loc) *(*bcdata.fp):out
   !                *(*bcdata.fv):out *(*bcdata.m):out *(*bcdata.oarea):out
   !                *(*bcdata.sepsensor):out *(*bcdata.cavitation):out
   !                *(*bcdata.uslip):(loc) *radi:(loc) *radj:(loc)
   !                *radk:(loc) mach:in tempfreestream:in reynolds:in
   !                veldirfreestream:(loc) machgrid:in lengthref:in
   !                machcoef:in dragdirection:(loc) liftdirection:(loc)
   !                pointref:in *xx:in *rev0:in-out *rev1:in-out *rev2:in
   !                *rev3:in *pp0:in-out *pp1:in-out *pp2:in *pp3:in
   !                *rlv0:in-out *rlv1:in-out *rlv2:in *rlv3:in *ss:in
   !                *ssi:in *ssj:in *ssk:in *ww0:in-out *ww1:in-out
   !                *ww2:in *ww3:in funcvalues:out moment:out alpha:in
   !                force:out beta:in cavitation:out sepsensor:out
   !   Plus diff mem management of: flowdoms.x:in flowdoms.vol:in
   !                flowdoms.w:in flowdoms.dw:in rev:in aa:in bvtj1:in
   !                bvtj2:in wx:in wy:in wz:in p:in sfacei:in sfacej:in
   !                s:in sfacek:in rlv:in qx:in qy:in qz:in bvtk1:in
   !                bvtk2:in ux:in uy:in uz:in si:in sj:in sk:in bvti1:in
   !                bvti2:in vx:in vy:in vz:in fw:in viscsubface:in
   !                *viscsubface.tau:in bcdata:in *bcdata.norm:in
   !                *bcdata.rface:in *bcdata.fp:in *bcdata.fv:in *bcdata.m:in
   !                *bcdata.oarea:in *bcdata.sepsensor:in *bcdata.cavitation:in
   !                *bcdata.uslip:in radi:in radj:in radk:in xx:in-out
   !                rev0:in-out rev1:in-out rev2:in-out rev3:in-out
   !                pp0:in-out pp1:in-out pp2:in-out pp3:in-out rlv0:in-out
   !                rlv1:in-out rlv2:in-out rlv3:in-out ss:in-out
   !                ssi:in-out ssj:in-out ssk:in-out ww0:in-out ww1:in-out
   !                ww2:in-out ww3:in-out
   ! This is a super-combined function that combines the original
   ! functionality of: 
   ! Pressure Computation
   ! timeStep
   ! applyAllBCs
   ! initRes
   ! residual 
   ! The real difference between this and the original modules is that it
   ! it only operates on a single block at a time and as such the nominal
   ! block/sps loop is outside the calculation. This routine is suitable
   ! for forward mode AD with Tapenade
   SUBROUTINE BLOCK_RES_D(nn, sps, usespatial, alpha, alphad, beta, betad, &
   & liftindex, force, forced, moment, momentd, sepsensor, sepsensord, &
   & cavitation, cavitationd)
   USE BCROUTINES_D
   USE BLOCKPOINTERS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE INPUTITERATION
   USE INPUTTIMESPECTRAL
   USE SECTION
   USE MONITOR
   USE ITERATION
   USE INPUTADJOINT
   USE DIFFSIZES
   USE COSTFUNCTIONS
   USE WALLDISTANCEDATA
   USE INPUTDISCRETIZATION
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   IMPLICIT NONE
   ! Input Arguments:
   INTEGER(kind=inttype), INTENT(IN) :: nn, sps
   LOGICAL, INTENT(IN) :: usespatial
   REAL(kind=realtype), INTENT(IN) :: alpha, beta
   REAL(kind=realtype), INTENT(IN) :: alphad, betad
   INTEGER(kind=inttype), INTENT(IN) :: liftindex
   ! Output Variables
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral) :: force, &
   & moment
   REAL(kind=realtype), DIMENSION(3, ntimeintervalsspectral) :: forced, &
   & momentd
   REAL(kind=realtype) :: sepsensor, cavitation
   REAL(kind=realtype) :: sepsensord, cavitationd
   ! Working Variables
   REAL(kind=realtype) :: gm1, v2, fact, tmp
   REAL(kind=realtype) :: factd, tmpd
   INTEGER(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj
   INTEGER(kind=inttype) :: nstate
   REAL(kind=realtype), DIMENSION(nsections) :: t
   LOGICAL :: useoldcoor
   REAL(kind=realtype), DIMENSION(3) :: cfp, cfv, cmp, cmv
   REAL(kind=realtype), DIMENSION(3) :: cfpd, cfvd, cmpd, cmvd
   REAL(kind=realtype) :: yplusmax, scaledim
   REAL(kind=realtype) :: scaledimd
   INTRINSIC REAL
   INTEGER :: ii3
   INTEGER :: ii2
   INTEGER :: ii1
   useoldcoor = .false.
   ! Setup number of state variable based on turbulence assumption
   IF (frozenturbulence) THEN
   nstate = nwf
   ELSE
   nstate = nw
   END IF
   ! Set pointers to input/output variables
   wd => flowdomsd(nn, currentlevel, sps)%w
   w => flowdoms(nn, currentlevel, sps)%w
   dwd => flowdomsd(nn, 1, sps)%dw
   dw => flowdoms(nn, 1, sps)%dw
   xd => flowdomsd(nn, currentlevel, sps)%x
   x => flowdoms(nn, currentlevel, sps)%x
   vold => flowdomsd(nn, currentlevel, sps)%vol
   vol => flowdoms(nn, currentlevel, sps)%vol
   ! ------------------------------------------------
   !        Additional 'Extra' Components
   ! ------------------------------------------------ 
   CALL ADJUSTINFLOWANGLE_D(alpha, alphad, beta, betad, liftindex)
   CALL REFERENCESTATE_D()
   CALL SETFLOWINFINITYSTATE_D()
   ! ------------------------------------------------
   !        Additional Spatial Components
   ! ------------------------------------------------
   IF (usespatial) THEN
   CALL XHALO_BLOCK_D()
   CALL METRIC_BLOCK_D()
   ! -------------------------------------
   ! These functions are required for TS
   ! --------------------------------------
   t = timeunsteadyrestart
   IF (equationmode .EQ. timespectral) THEN
   DO mm=1,nsections
   t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/REAL(&
   &         ntimeintervalsspectral, realtype)
   END DO
   END IF
   CALL GRIDVELOCITIESFINELEVEL_BLOCK_D(useoldcoor, t, sps)
   ! Required for TS
   CALL NORMALVELOCITIES_BLOCK_D(sps)
   ! Required for TS
   CALL SLIPVELOCITIESFINELEVEL_BLOCK_D(useoldcoor, t, sps)
   ELSE
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   flowdomsd(ii3, ii2, ii1)%vol = 0.0_8
   END DO
   END DO
   END DO
   sfaceid = 0.0_8
   sfacejd = 0.0_8
   sd = 0.0_8
   sfacekd = 0.0_8
   sid = 0.0_8
   sjd = 0.0_8
   skd = 0.0_8
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%norm = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%rface = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%uslip = 0.0_8
   END DO
   END IF
   ! ------------------------------------------------
   !        Normal Residual Computation
   ! ------------------------------------------------
   ! Compute the pressures
   CALL COMPUTEPRESSURESIMPLE_D()
   ! Compute Laminar/eddy viscosity if required
   CALL COMPUTELAMVISCOSITY_D()
   CALL COMPUTEEDDYVISCOSITY_D()
   CALL APPLYALLBC_BLOCK_D(.true.)
   IF (equations .EQ. ransequations) THEN
   bvti2d = 0.0_8
   bvti1d = 0.0_8
   bvtk2d = 0.0_8
   bvtk1d = 0.0_8
   bvtj2d = 0.0_8
   bvtj1d = 0.0_8
   CALL APPLYALLTURBBCTHISBLOCK_D(.true.)
   END IF
   ! Compute skin_friction Velocity (only for wall Functions)
   ! #ifndef TAPENADE_REVERSE
   !   call computeUtau_block
   ! #endif
   ! Compute time step and spectral radius
   CALL TIMESTEP_BLOCK_D(.false.)
   spectralloop0:DO sps2=1,ntimeintervalsspectral
   flowdomsd(nn, 1, sps2)%dw(:, :, :, :) = 0.0_8
   flowdoms(nn, 1, sps2)%dw(:, :, :, :) = zero
   END DO spectralloop0
   ! -------------------------------
   ! Compute turbulence residual for RANS equations
   IF (equations .EQ. ransequations) THEN
   ! ! Initialize only the Turblent Variables
   ! call unsteadyTurbSpectral_block(itu1, itu1, nn, sps)
   SELECT CASE  (turbmodel) 
   CASE (spalartallmaras) 
   CALL SA_BLOCK_D(.true.)
   CASE DEFAULT
   CALL TERMINATE('turbResidual', &
   &                 'Only SA turbulence adjoint implemented')
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
   END DO
   END DO
   END DO
   END SELECT
   ELSE
   DO ii1=1,ntimeintervalsspectral
   DO ii2=1,1
   DO ii3=nn,nn
   flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
   END DO
   END DO
   END DO
   END IF
   ! -------------------------------  
   ! Next initialize residual for flow variables. The is the only place
   ! where there is an n^2 dependance. There are issues with
   ! initRes. So only the necesary timespectral code has been copied
   ! here. See initres for more information and comments.
   ! sps here is the on-spectral instance
   IF (ntimeintervalsspectral .EQ. 1) THEN
   dwd(:, :, :, 1:nwf) = 0.0_8
   dw(:, :, :, 1:nwf) = zero
   ELSE
   ! Zero dw on all spectral instances
   spectralloop1:DO sps2=1,ntimeintervalsspectral
   flowdomsd(nn, 1, sps2)%dw(:, :, :, 1:nwf) = 0.0_8
   flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
   END DO spectralloop1
   spectralloop2:DO sps2=1,ntimeintervalsspectral
   jj = sectionid
   timeloopfine:DO mm=1,ntimeintervalsspectral
   ii = 3*(mm-1)
   varloopfine:DO l=1,nwf
   IF ((l .EQ. ivx .OR. l .EQ. ivy) .OR. l .EQ. ivz) THEN
   IF (l .EQ. ivx) ll = 3*sps2 - 2
   IF (l .EQ. ivy) ll = 3*sps2 - 1
   IF (l .EQ. ivz) ll = 3*sps2
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   tmpd = dvector(jj, ll, ii+1)*flowdomsd(nn, 1, mm)%w(i&
   &                   , j, k, ivx) + dvector(jj, ll, ii+2)*flowdomsd(nn, 1&
   &                   , mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
   &                   flowdomsd(nn, 1, mm)%w(i, j, k, ivz)
   tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i, j&
   &                   , k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, 1, mm&
   &                   )%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*flowdoms(&
   &                   nn, 1, mm)%w(i, j, k, ivz)
   flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
   &                   1, sps2)%dw(i, j, k, l) + (tmpd*flowdoms(nn, 1, mm)%&
   &                   vol(i, j, k)+tmp*flowdomsd(nn, 1, mm)%vol(i, j, k))*&
   &                   flowdoms(nn, 1, mm)%w(i, j, k, irho) + tmp*flowdoms(&
   &                   nn, 1, mm)%vol(i, j, k)*flowdomsd(nn, 1, mm)%w(i, j&
   &                   , k, irho)
   flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
   &                   , sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%vol&
   &                   (i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
   END DO
   END DO
   END DO
   ELSE
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   ! This is: dw = dw + dscalar*vol*w
   flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
   &                   1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*(&
   &                   flowdomsd(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm&
   &                   )%w(i, j, k, l)+flowdoms(nn, 1, mm)%vol(i, j, k)*&
   &                   flowdomsd(nn, 1, mm)%w(i, j, k, l))
   flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
   &                   , sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
   &                   flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm)&
   &                   %w(i, j, k, l)
   END DO
   END DO
   END DO
   END IF
   END DO varloopfine
   END DO timeloopfine
   END DO spectralloop2
   END IF
   !  Actual residual calc
   CALL RESIDUAL_BLOCK_D()
   ! Divide through by the reference volume
   DO sps2=1,ntimeintervalsspectral
   DO l=1,nwf
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = (flowdomsd(nn, 1, &
   &             sps2)%dw(i, j, k, l)*flowdoms(nn, currentlevel, sps2)%vol(&
   &             i, j, k)-flowdoms(nn, 1, sps2)%dw(i, j, k, l)*flowdomsd(nn&
   &             , currentlevel, sps2)%vol(i, j, k))/flowdoms(nn, &
   &             currentlevel, sps2)%vol(i, j, k)**2
   flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, sps2)&
   &             %dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%vol(i, j&
   &             , k)
   END DO
   END DO
   END DO
   END DO
   ! Treat the turblent residual with the scaling factor on the
   ! residual
   DO l=nt1,nstate
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = turbresscale*(&
   &             flowdomsd(nn, 1, sps2)%dw(i, j, k, l)*flowdoms(nn, &
   &             currentlevel, sps2)%vol(i, j, k)-flowdoms(nn, 1, sps2)%dw(&
   &             i, j, k, l)*flowdomsd(nn, currentlevel, sps2)%vol(i, j, k)&
   &             )/flowdoms(nn, currentlevel, sps2)%vol(i, j, k)**2
   flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, sps2)&
   &             %dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%vol(i, j&
   &             , k)*turbresscale
   END DO
   END DO
   END DO
   END DO
   END DO
   CALL FORCESANDMOMENTS_D(cfp, cfpd, cfv, cfvd, cmp, cmpd, cmv, cmvd, &
   &                   yplusmax, sepsensor, sepsensord, cavitation, &
   &                   cavitationd)
   ! Convert back to actual forces. Note that even though we use
   ! MachCoef, Lref, and surfaceRef here, they are NOT differented,
   ! since F doesn't actually depend on them. Ideally we would just get
   ! the raw forces and moment form forcesAndMoments. 
   force = zero
   moment = zero
   scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
   scaledim = pref/pinf
   factd = -(two*surfaceref*lref**2*(((gammainfd*pinf+gammainf*pinfd)*&
   &   scaledim+gammainf*pinf*scaledimd)*machcoef**2+gammainf*pinf*scaledim&
   &   *(machcoefd*machcoef+machcoef*machcoefd))/(gammainf*pinf*machcoef*&
   &   machcoef*surfaceref*lref*lref*scaledim)**2)
   fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
   &   scaledim)
   forced = 0.0_8
   DO sps2=1,ntimeintervalsspectral
   forced(:, sps2) = ((cfpd+cfvd)*fact-(cfp+cfv)*factd)/fact**2
   force(:, sps2) = (cfp+cfv)/fact
   END DO
   factd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*lref)**&
   &   2
   fact = fact/(lengthref*lref)
   momentd = 0.0_8
   DO sps2=1,ntimeintervalsspectral
   momentd(:, sps2) = ((cmpd+cmvd)*fact-(cmp+cmv)*factd)/fact**2
   moment(:, sps2) = (cmp+cmv)/fact
   END DO
   CALL GETCOSTFUNCTION2_D(force, forced, moment, momentd, sepsensor, &
   &                   sepsensord, cavitation, cavitationd, alpha, beta, &
   &                   liftindex)
   END SUBROUTINE BLOCK_RES_D

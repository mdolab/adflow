!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of block_res in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: pref *(flowdoms.w) *(flowdoms.dw)
!                *(*bcdata.f) *rev0 *rev1 *pp0 *pp1 *rlv0 *rlv1
!                *ww0 *ww1 funcvalues moment force cavitation sepsensor
!   with respect to varying inputs: pref *(flowdoms.x) *(flowdoms.w)
!                mach tempfreestream reynolds machgrid lengthref
!                machcoef pointref *xx *rev0 *rev1 *rev2 *rev3
!                *pp0 *pp1 *pp2 *pp3 *rlv0 *rlv1 *rlv2 *rlv3 *ss
!                *ssi *ssj *ssk *ww0 *ww1 *ww2 *ww3 alpha beta
!   rw status of diff variables: mudim:(loc) gammainf:(loc) pinf:(loc)
!                timeref:(loc) rhoinf:(loc) muref:(loc) rhoinfdim:(loc)
!                tref:(loc) winf:(loc) muinf:(loc) uinf:(loc) pinfcorr:(loc)
!                rgas:(loc) pinfdim:(loc) pref:in-out rhoref:(loc)
!                *(flowdoms.x):in *(flowdoms.vol):(loc) *(flowdoms.w):in-out
!                *(flowdoms.dw):out *rev:(loc) *aa:(loc) *bvtj1:(loc)
!                *bvtj2:(loc) *wx:(loc) *wy:(loc) *wz:(loc) *p:(loc)
!                *sfacei:(loc) *sfacej:(loc) *s:(loc) *sfacek:(loc)
!                *rlv:(loc) *qx:(loc) *qy:(loc) *qz:(loc) *scratch:(loc)
!                *bvtk1:(loc) *bvtk2:(loc) *ux:(loc) *uy:(loc)
!                *uz:(loc) *si:(loc) *sj:(loc) *sk:(loc) *bvti1:(loc)
!                *bvti2:(loc) *vx:(loc) *vy:(loc) *vz:(loc) *fw:(loc)
!                *(*viscsubface.tau):(loc) *(*bcdata.norm):(loc)
!                *(*bcdata.rface):(loc) *(*bcdata.f):out *(*bcdata.dualarea):(loc)
!                *(*bcdata.uslip):(loc) *radi:(loc) *radj:(loc)
!                *radk:(loc) mach:in tempfreestream:in reynolds:in
!                veldirfreestream:(loc) machgrid:in lengthref:in
!                machcoef:in dragdirection:(loc) liftdirection:(loc)
!                pointref:in *xx:in *rev0:in-out *rev1:in-out *rev2:in
!                *rev3:in *pp0:in-out *pp1:in-out *pp2:in *pp3:in
!                *rlv0:in-out *rlv1:in-out *rlv2:in *rlv3:in *ss:in
!                *ssi:in *ssj:in *ssk:in *ww0:in-out *ww1:in-out
!                *ww2:in *ww3:in funcvalues:out moment:out alpha:in
!                force:out beta:in cavitation:out sepsensor:out
!   plus diff mem management of: flowdoms.x:in flowdoms.vol:in
!                flowdoms.w:in flowdoms.dw:in rev:in aa:in bvtj1:in
!                bvtj2:in wx:in wy:in wz:in p:in sfacei:in sfacej:in
!                s:in sfacek:in rlv:in qx:in qy:in qz:in scratch:in
!                bvtk1:in bvtk2:in ux:in uy:in uz:in si:in sj:in
!                sk:in bvti1:in bvti2:in vx:in vy:in vz:in fw:in
!                viscsubface:in *viscsubface.tau:in bcdata:in *bcdata.norm:in
!                *bcdata.rface:in *bcdata.f:in *bcdata.dualarea:in
!                *bcdata.uslip:in radi:in radj:in radk:in xx:in-out
!                rev0:in-out rev1:in-out rev2:in-out rev3:in-out
!                pp0:in-out pp1:in-out pp2:in-out pp3:in-out rlv0:in-out
!                rlv1:in-out rlv2:in-out rlv3:in-out ss:in-out
!                ssi:in-out ssj:in-out ssk:in-out ww0:in-out ww1:in-out
!                ww2:in-out ww3:in-out
! this is a super-combined function that combines the original
! functionality of: 
! pressure computation
! timestep
! applyallbcs
! initres
! residual 
! the real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the nominal
! block/sps loop is outside the calculation. this routine is suitable
! for forward mode ad with tapenade
subroutine block_res_d(nn, sps, usespatial, alpha, alphad, beta, betad, &
& liftindex, force, forced, moment, momentd, sepsensor, sepsensord, &
& cavitation, cavitationd, frozenturb)
  use bcroutines_d
  use blockpointers
  use flowvarrefstate
  use inputphysics
  use inputiteration
  use inputtimespectral
  use section
  use monitor
  use iteration
  use diffsizes
  use costfunctions
  use walldistancedata
  use inputdiscretization
  use samodule_d
  use diffsizes
!  hint: isize1ofdrfbcdata should be the size of dimension 1 of array *bcdata
  implicit none
! input arguments:
  integer(kind=inttype), intent(in) :: nn, sps
  logical, intent(in) :: usespatial, frozenturb
  real(kind=realtype), intent(in) :: alpha, beta
  real(kind=realtype), intent(in) :: alphad, betad
  integer(kind=inttype), intent(in) :: liftindex
! output variables
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: force, &
& moment
  real(kind=realtype), dimension(3, ntimeintervalsspectral) :: forced, &
& momentd
  real(kind=realtype) :: sepsensor, cavitation
  real(kind=realtype) :: sepsensord, cavitationd
! working variables
  real(kind=realtype) :: gm1, v2, fact, tmp
  real(kind=realtype) :: factd, tmpd
  integer(kind=inttype) :: i, j, k, sps2, mm, l, ii, ll, jj
  integer(kind=inttype) :: nstate
  real(kind=realtype), dimension(nsections) :: t
  logical :: useoldcoor
  real(kind=realtype), dimension(3) :: cfp, cfv, cmp, cmv
  real(kind=realtype), dimension(3) :: cfpd, cfvd, cmpd, cmvd
  real(kind=realtype) :: yplusmax, scaledim
  real(kind=realtype) :: scaledimd
  intrinsic real
  integer :: ii3
  integer :: ii2
  integer :: ii1
  useoldcoor = .false.
! setup number of state variable based on turbulence assumption
  if (frozenturb) then
    nstate = nwf
  else
    nstate = nw
  end if
! set pointers to input/output variables
  wd => flowdomsd(nn, currentlevel, sps)%w
  w => flowdoms(nn, currentlevel, sps)%w
  dwd => flowdomsd(nn, 1, sps)%dw
  dw => flowdoms(nn, 1, sps)%dw
  xd => flowdomsd(nn, currentlevel, sps)%x
  x => flowdoms(nn, currentlevel, sps)%x
  vold => flowdomsd(nn, currentlevel, sps)%vol
  vol => flowdoms(nn, currentlevel, sps)%vol
! ------------------------------------------------
!        additional 'extra' components
! ------------------------------------------------ 
  call adjustinflowangle_d(alpha, alphad, beta, betad, liftindex)
  call referencestate_d()
  call setflowinfinitystate_d()
! ------------------------------------------------
!        additional spatial components
! ------------------------------------------------
  if (usespatial) then
    call volume_block_d()
    call metric_block_d()
    call boundarynormals_d()
! -------------------------------------
! these functions are required for ts
! --------------------------------------
    t = timeunsteadyrestart
    if (equationmode .eq. timespectral) then
      do mm=1,nsections
        t(mm) = t(mm) + (sps-1)*sections(mm)%timeperiod/real(&
&         ntimeintervalsspectral, realtype)
      end do
    end if
    call gridvelocitiesfinelevel_block_d(useoldcoor, t, sps)
! required for ts
    call normalvelocities_block_d(sps)
! required for ts
    call slipvelocitiesfinelevel_block_d(useoldcoor, t, sps)
  else
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          flowdomsd(ii3, ii2, ii1)%vol = 0.0_8
        end do
      end do
    end do
    sfaceid = 0.0_8
    sfacejd = 0.0_8
    sd = 0.0_8
    sfacekd = 0.0_8
    sid = 0.0_8
    sjd = 0.0_8
    skd = 0.0_8
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%norm = 0.0_8
    end do
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%rface = 0.0_8
    end do
    do ii1=1,isize1ofdrfbcdata
      bcdatad(ii1)%uslip = 0.0_8
    end do
  end if
! ------------------------------------------------
!        normal residual computation
! ------------------------------------------------
! compute the pressures
  call computepressuresimple_d()
! compute laminar/eddy viscosity if required
  call computelamviscosity_d()
  call computeeddyviscosity_d()
  call applyallbc_block_d(.true.)
  if (equations .eq. ransequations) then
    call bcturbtreatment_d()
    call applyallturbbcthisblock_d(.true.)
  end if
! compute skin_friction velocity (only for wall functions)
! #ifndef tapenade_reverse
!   call computeutau_block
! #endif
! compute time step and spectral radius
  call timestep_block_d(.false.)
spectralloop0:do sps2=1,ntimeintervalsspectral
    flowdomsd(nn, 1, sps2)%dw(:, :, :, :) = 0.0_8
    flowdoms(nn, 1, sps2)%dw(:, :, :, :) = zero
  end do spectralloop0
! -------------------------------
! compute turbulence residual for rans equations
  if (equations .eq. ransequations) then
! ! initialize only the turblent variables
! call unsteadyturbspectral_block(itu1, itu1, nn, sps)
    select case  (turbmodel) 
    case (spalartallmaras) 
      call sa_block_d(.true.)
    case default
      call terminate('turbresidual', &
&                 'only sa turbulence adjoint implemented')
      do ii1=1,ntimeintervalsspectral
        do ii2=1,1
          do ii3=nn,nn
            flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
          end do
        end do
      end do
    end select
  else
    do ii1=1,ntimeintervalsspectral
      do ii2=1,1
        do ii3=nn,nn
          flowdomsd(ii3, ii2, ii1)%dw = 0.0_8
        end do
      end do
    end do
  end if
! -------------------------------  
! next initialize residual for flow variables. the is the only place
! where there is an n^2 dependance. there are issues with
! initres. so only the necesary timespectral code has been copied
! here. see initres for more information and comments.
! sps here is the on-spectral instance
  if (ntimeintervalsspectral .eq. 1) then
    dwd(:, :, :, 1:nwf) = 0.0_8
    dw(:, :, :, 1:nwf) = zero
  else
! zero dw on all spectral instances
spectralloop1:do sps2=1,ntimeintervalsspectral
      flowdomsd(nn, 1, sps2)%dw(:, :, :, 1:nwf) = 0.0_8
      flowdoms(nn, 1, sps2)%dw(:, :, :, 1:nwf) = zero
    end do spectralloop1
spectralloop2:do sps2=1,ntimeintervalsspectral
      jj = sectionid
timeloopfine:do mm=1,ntimeintervalsspectral
        ii = 3*(mm-1)
varloopfine:do l=1,nwf
          if ((l .eq. ivx .or. l .eq. ivy) .or. l .eq. ivz) then
            if (l .eq. ivx) ll = 3*sps2 - 2
            if (l .eq. ivy) ll = 3*sps2 - 1
            if (l .eq. ivz) ll = 3*sps2
            do k=2,kl
              do j=2,jl
                do i=2,il
                  tmpd = dvector(jj, ll, ii+1)*flowdomsd(nn, 1, mm)%w(i&
&                   , j, k, ivx) + dvector(jj, ll, ii+2)*flowdomsd(nn, 1&
&                   , mm)%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*&
&                   flowdomsd(nn, 1, mm)%w(i, j, k, ivz)
                  tmp = dvector(jj, ll, ii+1)*flowdoms(nn, 1, mm)%w(i, j&
&                   , k, ivx) + dvector(jj, ll, ii+2)*flowdoms(nn, 1, mm&
&                   )%w(i, j, k, ivy) + dvector(jj, ll, ii+3)*flowdoms(&
&                   nn, 1, mm)%w(i, j, k, ivz)
                  flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
&                   1, sps2)%dw(i, j, k, l) + (tmpd*flowdoms(nn, 1, mm)%&
&                   vol(i, j, k)+tmp*flowdomsd(nn, 1, mm)%vol(i, j, k))*&
&                   flowdoms(nn, 1, mm)%w(i, j, k, irho) + tmp*flowdoms(&
&                   nn, 1, mm)%vol(i, j, k)*flowdomsd(nn, 1, mm)%w(i, j&
&                   , k, irho)
                  flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
&                   , sps2)%dw(i, j, k, l) + tmp*flowdoms(nn, 1, mm)%vol&
&                   (i, j, k)*flowdoms(nn, 1, mm)%w(i, j, k, irho)
                end do
              end do
            end do
          else
            do k=2,kl
              do j=2,jl
                do i=2,il
! this is: dw = dw + dscalar*vol*w
                  flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = flowdomsd(nn, &
&                   1, sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*(&
&                   flowdomsd(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm&
&                   )%w(i, j, k, l)+flowdoms(nn, 1, mm)%vol(i, j, k)*&
&                   flowdomsd(nn, 1, mm)%w(i, j, k, l))
                  flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1&
&                   , sps2)%dw(i, j, k, l) + dscalar(jj, sps2, mm)*&
&                   flowdoms(nn, 1, mm)%vol(i, j, k)*flowdoms(nn, 1, mm)&
&                   %w(i, j, k, l)
                end do
              end do
            end do
          end if
        end do varloopfine
      end do timeloopfine
    end do spectralloop2
  end if
!  actual residual calc
  call residual_block_d()
! divide through by the reference volume
  do sps2=1,ntimeintervalsspectral
    do l=1,nwf
      do k=2,kl
        do j=2,jl
          do i=2,il
            flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = (flowdomsd(nn, 1, &
&             sps2)%dw(i, j, k, l)*flowdoms(nn, currentlevel, sps2)%vol(&
&             i, j, k)-flowdoms(nn, 1, sps2)%dw(i, j, k, l)*flowdomsd(nn&
&             , currentlevel, sps2)%vol(i, j, k))/flowdoms(nn, &
&             currentlevel, sps2)%vol(i, j, k)**2
            flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, sps2)&
&             %dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%vol(i, j&
&             , k)
          end do
        end do
      end do
    end do
! treat the turblent residual with the scaling factor on the
! residual
    do l=nt1,nstate
      do k=2,kl
        do j=2,jl
          do i=2,il
            flowdomsd(nn, 1, sps2)%dw(i, j, k, l) = turbresscale*(&
&             flowdomsd(nn, 1, sps2)%dw(i, j, k, l)*flowdoms(nn, &
&             currentlevel, sps2)%vol(i, j, k)-flowdoms(nn, 1, sps2)%dw(&
&             i, j, k, l)*flowdomsd(nn, currentlevel, sps2)%vol(i, j, k)&
&             )/flowdoms(nn, currentlevel, sps2)%vol(i, j, k)**2
            flowdoms(nn, 1, sps2)%dw(i, j, k, l) = flowdoms(nn, 1, sps2)&
&             %dw(i, j, k, l)/flowdoms(nn, currentlevel, sps2)%vol(i, j&
&             , k)*turbresscale
          end do
        end do
      end do
    end do
  end do
  call forcesandmoments_d(cfp, cfpd, cfv, cfvd, cmp, cmpd, cmv, cmvd, &
&                   yplusmax, sepsensor, sepsensord, cavitation, &
&                   cavitationd)
! convert back to actual forces. note that even though we use
! machcoef, lref, and surfaceref here, they are not differented,
! since f doesn't actually depend on them. ideally we would just get
! the raw forces and moment form forcesandmoments. 
  force = zero
  moment = zero
  scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
  scaledim = pref/pinf
  factd = -(two*surfaceref*lref**2*(((gammainfd*pinf+gammainf*pinfd)*&
&   scaledim+gammainf*pinf*scaledimd)*machcoef**2+gammainf*pinf*scaledim&
&   *(machcoefd*machcoef+machcoef*machcoefd))/(gammainf*pinf*machcoef*&
&   machcoef*surfaceref*lref*lref*scaledim)**2)
  fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
&   scaledim)
  forced = 0.0_8
  do sps2=1,ntimeintervalsspectral
    forced(:, sps2) = ((cfpd+cfvd)*fact-(cfp+cfv)*factd)/fact**2
    force(:, sps2) = (cfp+cfv)/fact
  end do
  factd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*lref)**&
&   2
  fact = fact/(lengthref*lref)
  momentd = 0.0_8
  do sps2=1,ntimeintervalsspectral
    momentd(:, sps2) = ((cmpd+cmvd)*fact-(cmp+cmv)*factd)/fact**2
    moment(:, sps2) = (cmp+cmv)/fact
  end do
  call getcostfunction2_d(force, forced, moment, momentd, sepsensor, &
&                   sepsensord, cavitation, cavitationd, alpha, beta, &
&                   liftindex)
end subroutine block_res_d

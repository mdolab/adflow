!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of turbadvection in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *sfacei *sfacej *sfacek *dw
!                *w *vol *si *sj *sk
!   plus diff mem management of: sfacei:in sfacej:in sfacek:in
!                dw:in w:in vol:in si:in sj:in sk:in
!
!      ******************************************************************
!      *                                                                *
!      * file:          turbadvection.f90                               *
!      * author:        georgi kalitzin, edwin van der weide            *
!      * starting date: 09-01-2003                                      *
!      * last modified: 04-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
subroutine turbadvection_d(madv, nadv, offset, qq)
!
!      ******************************************************************
!      *                                                                *
!      * turbadvection discretizes the advection part of the turbulent  *
!      * transport equations. as the advection part is the same for all *
!      * models, this generic routine can be used. both the             *
!      * discretization and the central jacobian are computed in this   *
!      * subroutine. the former can either be 1st or 2nd order          *
!      * accurate; the latter is always based on the 1st order upwind   *
!      * discretization. when the discretization must be second order   *
!      * accurate, the fully upwind (kappa = -1) scheme in combination  *
!      * with the minmod limiter is used.                               *
!      *                                                                *
!      * only nadv equations are treated, while the actual system has   *
!      * size madv. the reason is that some equations for some          *
!      * turbulence equations do not have an advection part, e.g. the   *
!      * f equation in the v2-f model. the argument offset indicates    *
!      * the offset in the w vector where this subsystem starts. as a   *
!      * consequence it is assumed that the indices of the current      *
!      * subsystem are contiguous, e.g. if a 2*2 system is solved the   *
!      * last index in w is offset+1 and offset+2 respectively.         *
!      *                                                                *
!      ******************************************************************
!
  use blockpointers
  use turbmod
  implicit none
!
!      subroutine arguments.
!
  integer(kind=inttype), intent(in) :: nadv, madv, offset
  real(kind=realtype), dimension(2:il, 2:jl, 2:kl, madv, madv), intent(&
& inout) :: qq
!
!      local variables.
!
  integer(kind=inttype) :: i, j, k, ii, jj, kk, iii
  real(kind=realtype) :: qs, voli, xa, ya, za
  real(kind=realtype) :: qsd, volid, xad, yad, zad
  real(kind=realtype) :: uu, dwt, dwtm1, dwtp1, dwti, dwtj, dwtk
  real(kind=realtype) :: uud, dwtd, dwtm1d, dwtp1d, dwtid, dwtjd, dwtkd
  real(kind=realtype), dimension(madv) :: impl
  intrinsic abs
  intrinsic max
  real(kind=realtype) :: abs23
  real(kind=realtype) :: abs22
  real(kind=realtype) :: abs21
  real(kind=realtype) :: abs20
  real(kind=realtype) :: abs19
  real(kind=realtype) :: abs18
  real(kind=realtype) :: abs17
  real(kind=realtype) :: abs16
  real(kind=realtype) :: abs15
  real(kind=realtype) :: abs14
  real(kind=realtype) :: abs13
  real(kind=realtype) :: abs12
  real(kind=realtype) :: abs11
  real(kind=realtype) :: abs10
  real(kind=realtype) :: abs9
  real(kind=realtype) :: abs8
  real(kind=realtype) :: abs7
  real(kind=realtype) :: abs6
  real(kind=realtype) :: abs5
  real(kind=realtype) :: abs4
  real(kind=realtype) :: abs3
  real(kind=realtype) :: abs2
  real(kind=realtype) :: abs1
  real(kind=realtype) :: abs0
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! initialize the grid velocity to zero. this value will be used
! if the block is not moving.
  qs = zero
  qsd = 0.0_8
!
!      ******************************************************************
!      *                                                                *
!      * upwind discretization of the convective term in k (zeta)       *
!      * direction. either the 1st order upwind or the second order     *
!      * fully upwind interpolation scheme, kappa = -1, is used in      *
!      * combination with the minmod limiter.                           *
!      * the possible grid velocity must be taken into account.         *
!      *                                                                *
!      ******************************************************************
!
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the grid velocity if present.
! it is taken as the average of k and k-1,
        volid = -(half*vold(i, j, k)/vol(i, j, k)**2)
        voli = half/vol(i, j, k)
        if (addgridvelocities) then
          qsd = (sfacekd(i, j, k)+sfacekd(i, j, k-1))*voli + (sfacek(i, &
&           j, k)+sfacek(i, j, k-1))*volid
          qs = (sfacek(i, j, k)+sfacek(i, j, k-1))*voli
        end if
! compute the normal velocity, where the normal direction
! is taken as the average of faces k and k-1.
        xad = (skd(i, j, k, 1)+skd(i, j, k-1, 1))*voli + (sk(i, j, k, 1)&
&         +sk(i, j, k-1, 1))*volid
        xa = (sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
        yad = (skd(i, j, k, 2)+skd(i, j, k-1, 2))*voli + (sk(i, j, k, 2)&
&         +sk(i, j, k-1, 2))*volid
        ya = (sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
        zad = (skd(i, j, k, 3)+skd(i, j, k-1, 3))*voli + (sk(i, j, k, 3)&
&         +sk(i, j, k-1, 3))*volid
        za = (sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
        uud = xad*w(i, j, k, ivx) + xa*wd(i, j, k, ivx) + yad*w(i, j, k&
&         , ivy) + ya*wd(i, j, k, ivy) + zad*w(i, j, k, ivz) + za*wd(i, &
&         j, k, ivz) - qsd
        uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, ivz&
&         ) - qs
! determine the situation we are having here, i.e. positive
! or negative normal velocity.
        if (uu .gt. zero) then
! velocity has a component in positive k-direction.
! loop over the number of advection equations.
          do ii=1,nadv
! set the value of jj such that it corresponds to the
! turbulent entry in w.
            jj = ii + offset
! check whether a first or a second order discretization
! must be used.
            if (secondord) then
! second order; store the three differences for the
! discretization of the derivative in k-direction.
              dwtm1d = wd(i, j, k-1, jj) - wd(i, j, k-2, jj)
              dwtm1 = w(i, j, k-1, jj) - w(i, j, k-2, jj)
              dwtd = wd(i, j, k, jj) - wd(i, j, k-1, jj)
              dwt = w(i, j, k, jj) - w(i, j, k-1, jj)
              dwtp1d = wd(i, j, k+1, jj) - wd(i, j, k, jj)
              dwtp1 = w(i, j, k+1, jj) - w(i, j, k, jj)
! construct the derivative in this cell center. this
! is the first order upwind derivative with two
! nonlinear corrections.
              dwtkd = dwtd
              dwtk = dwt
              if (dwt*dwtp1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs0 = dwt
                else
                  abs0 = -dwt
                end if
                if (dwtp1 .ge. 0.) then
                  abs12 = dwtp1
                else
                  abs12 = -dwtp1
                end if
                if (abs0 .lt. abs12) then
                  dwtkd = dwtkd + half*dwtd
                  dwtk = dwtk + half*dwt
                else
                  dwtkd = dwtkd + half*dwtp1d
                  dwtk = dwtk + half*dwtp1
                end if
              end if
              if (dwt*dwtm1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs1 = dwt
                else
                  abs1 = -dwt
                end if
                if (dwtm1 .ge. 0.) then
                  abs13 = dwtm1
                else
                  abs13 = -dwtm1
                end if
                if (abs1 .lt. abs13) then
                  dwtkd = dwtkd - half*dwtd
                  dwtk = dwtk - half*dwt
                else
                  dwtkd = dwtkd - half*dwtm1d
                  dwtk = dwtk - half*dwtm1
                end if
              end if
            else
! 1st order upwind scheme.
              dwtkd = wd(i, j, k, jj) - wd(i, j, k-1, jj)
              dwtk = w(i, j, k, jj) - w(i, j, k-1, jj)
            end if
! update the residual. the convective term must be
! substracted, because it appears on the other side of
! the equation as the source and viscous terms.
            dwd(i, j, k, idvt+ii-1) = dwd(i, j, k, idvt+ii-1) - uud*dwtk&
&             - uu*dwtkd
            dw(i, j, k, idvt+ii-1) = dw(i, j, k, idvt+ii-1) - uu*dwtk
! update the central jacobian. first the term which is
! always present, i.e. uu.
            qq(i, j, k, ii, ii) = qq(i, j, k, ii, ii) + uu
! for boundary cells k == 2, the implicit treatment must
! be taken into account. note that the implicit part
! is only based on the 1st order discretization.
! to improve stability the diagonal term is only taken
! into account when it improves stability, i.e. when
! it is positive.
            if (k .eq. 2) then
              do kk=1,madv
                impl(kk) = bmtk1(i, j, jj, kk+offset)
              end do
              if (impl(ii) .lt. zero) then
                impl(ii) = zero
              else
                impl(ii) = impl(ii)
              end if
              do kk=1,madv
                qq(i, j, k, ii, kk) = qq(i, j, k, ii, kk) + uu*impl(kk)
              end do
            end if
          end do
        else
! velocity has a component in negative k-direction.
! loop over the number of advection equations
          do ii=1,nadv
! set the value of jj such that it corresponds to the
! turbulent entry in w.
            jj = ii + offset
! check whether a first or a second order discretization
! must be used.
            if (secondord) then
! store the three differences for the discretization of
! the derivative in k-direction.
              dwtm1d = wd(i, j, k, jj) - wd(i, j, k-1, jj)
              dwtm1 = w(i, j, k, jj) - w(i, j, k-1, jj)
              dwtd = wd(i, j, k+1, jj) - wd(i, j, k, jj)
              dwt = w(i, j, k+1, jj) - w(i, j, k, jj)
              dwtp1d = wd(i, j, k+2, jj) - wd(i, j, k+1, jj)
              dwtp1 = w(i, j, k+2, jj) - w(i, j, k+1, jj)
! construct the derivative in this cell center. this is
! the first order upwind derivative with two nonlinear
! corrections.
              dwtkd = dwtd
              dwtk = dwt
              if (dwt*dwtp1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs2 = dwt
                else
                  abs2 = -dwt
                end if
                if (dwtp1 .ge. 0.) then
                  abs14 = dwtp1
                else
                  abs14 = -dwtp1
                end if
                if (abs2 .lt. abs14) then
                  dwtkd = dwtkd - half*dwtd
                  dwtk = dwtk - half*dwt
                else
                  dwtkd = dwtkd - half*dwtp1d
                  dwtk = dwtk - half*dwtp1
                end if
              end if
              if (dwt*dwtm1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs3 = dwt
                else
                  abs3 = -dwt
                end if
                if (dwtm1 .ge. 0.) then
                  abs15 = dwtm1
                else
                  abs15 = -dwtm1
                end if
                if (abs3 .lt. abs15) then
                  dwtkd = dwtkd + half*dwtd
                  dwtk = dwtk + half*dwt
                else
                  dwtkd = dwtkd + half*dwtm1d
                  dwtk = dwtk + half*dwtm1
                end if
              end if
            else
! 1st order upwind scheme.
              dwtkd = wd(i, j, k+1, jj) - wd(i, j, k, jj)
              dwtk = w(i, j, k+1, jj) - w(i, j, k, jj)
            end if
! update the residual. the convective term must be
! substracted, because it appears on the other side
! of the equation as the source and viscous terms.
            dwd(i, j, k, idvt+ii-1) = dwd(i, j, k, idvt+ii-1) - uud*dwtk&
&             - uu*dwtkd
            dw(i, j, k, idvt+ii-1) = dw(i, j, k, idvt+ii-1) - uu*dwtk
! update the central jacobian. first the term which is
! always present, i.e. -uu.
            qq(i, j, k, ii, ii) = qq(i, j, k, ii, ii) - uu
! for boundary cells k == kl, the implicit treatment must
! be taken into account. note that the implicit part
! is only based on the 1st order discretization.
! to improve stability the diagonal term is only taken
! into account when it improves stability, i.e. when
! it is positive.
            if (k .eq. kl) then
              do kk=1,madv
                impl(kk) = bmtk2(i, j, jj, kk+offset)
              end do
              if (impl(ii) .lt. zero) then
                impl(ii) = zero
              else
                impl(ii) = impl(ii)
              end if
              do kk=1,madv
                qq(i, j, k, ii, kk) = qq(i, j, k, ii, kk) - uu*impl(kk)
              end do
            end if
          end do
        end if
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * upwind discretization of the convective term in j (eta)        *
!      * direction. either the 1st order upwind or the second order     *
!      * fully upwind interpolation scheme, kappa = -1, is used in      *
!      * combination with the minmod limiter.                           *
!      * the possible grid velocity must be taken into account.         *
!      *                                                                *
!      ******************************************************************
!
  qs = zero
  qsd = 0.0_8
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the grid velocity if present.
! it is taken as the average of j and j-1,
        volid = -(half*vold(i, j, k)/vol(i, j, k)**2)
        voli = half/vol(i, j, k)
        if (addgridvelocities) then
          qsd = (sfacejd(i, j, k)+sfacejd(i, j-1, k))*voli + (sfacej(i, &
&           j, k)+sfacej(i, j-1, k))*volid
          qs = (sfacej(i, j, k)+sfacej(i, j-1, k))*voli
        end if
! compute the normal velocity, where the normal direction
! is taken as the average of faces j and j-1.
        xad = (sjd(i, j, k, 1)+sjd(i, j-1, k, 1))*voli + (sj(i, j, k, 1)&
&         +sj(i, j-1, k, 1))*volid
        xa = (sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
        yad = (sjd(i, j, k, 2)+sjd(i, j-1, k, 2))*voli + (sj(i, j, k, 2)&
&         +sj(i, j-1, k, 2))*volid
        ya = (sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
        zad = (sjd(i, j, k, 3)+sjd(i, j-1, k, 3))*voli + (sj(i, j, k, 3)&
&         +sj(i, j-1, k, 3))*volid
        za = (sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
        uud = xad*w(i, j, k, ivx) + xa*wd(i, j, k, ivx) + yad*w(i, j, k&
&         , ivy) + ya*wd(i, j, k, ivy) + zad*w(i, j, k, ivz) + za*wd(i, &
&         j, k, ivz) - qsd
        uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, ivz&
&         ) - qs
! determine the situation we are having here, i.e. positive
! or negative normal velocity.
        if (uu .gt. zero) then
! velocity has a component in positive j-direction.
! loop over the number of advection equations.
          do ii=1,nadv
! set the value of jj such that it corresponds to the
! turbulent entry in w.
            jj = ii + offset
! check whether a first or a second order discretization
! must be used.
            if (secondord) then
! second order; store the three differences for the
! discretization of the derivative in j-direction.
              dwtm1d = wd(i, j-1, k, jj) - wd(i, j-2, k, jj)
              dwtm1 = w(i, j-1, k, jj) - w(i, j-2, k, jj)
              dwtd = wd(i, j, k, jj) - wd(i, j-1, k, jj)
              dwt = w(i, j, k, jj) - w(i, j-1, k, jj)
              dwtp1d = wd(i, j+1, k, jj) - wd(i, j, k, jj)
              dwtp1 = w(i, j+1, k, jj) - w(i, j, k, jj)
! construct the derivative in this cell center. this is
! the first order upwind derivative with two nonlinear
! corrections.
              dwtjd = dwtd
              dwtj = dwt
              if (dwt*dwtp1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs4 = dwt
                else
                  abs4 = -dwt
                end if
                if (dwtp1 .ge. 0.) then
                  abs16 = dwtp1
                else
                  abs16 = -dwtp1
                end if
                if (abs4 .lt. abs16) then
                  dwtjd = dwtjd + half*dwtd
                  dwtj = dwtj + half*dwt
                else
                  dwtjd = dwtjd + half*dwtp1d
                  dwtj = dwtj + half*dwtp1
                end if
              end if
              if (dwt*dwtm1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs5 = dwt
                else
                  abs5 = -dwt
                end if
                if (dwtm1 .ge. 0.) then
                  abs17 = dwtm1
                else
                  abs17 = -dwtm1
                end if
                if (abs5 .lt. abs17) then
                  dwtjd = dwtjd - half*dwtd
                  dwtj = dwtj - half*dwt
                else
                  dwtjd = dwtjd - half*dwtm1d
                  dwtj = dwtj - half*dwtm1
                end if
              end if
            else
! 1st order upwind scheme.
              dwtjd = wd(i, j, k, jj) - wd(i, j-1, k, jj)
              dwtj = w(i, j, k, jj) - w(i, j-1, k, jj)
            end if
! update the residual. the convective term must be
! substracted, because it appears on the other side of
! the equation as the source and viscous terms.
            dwd(i, j, k, idvt+ii-1) = dwd(i, j, k, idvt+ii-1) - uud*dwtj&
&             - uu*dwtjd
            dw(i, j, k, idvt+ii-1) = dw(i, j, k, idvt+ii-1) - uu*dwtj
! update the central jacobian. first the term which is
! always present, i.e. uu.
            qq(i, j, k, ii, ii) = qq(i, j, k, ii, ii) + uu
! for boundary cells j == 2, the implicit treatment must
! be taken into account. note that the implicit part
! is only based on the 1st order discretization.
! to improve stability the diagonal term is only taken
! into account when it improves stability, i.e. when
! it is positive.
            if (j .eq. 2) then
              do kk=1,madv
                impl(kk) = bmtj1(i, k, jj, kk+offset)
              end do
              if (impl(ii) .lt. zero) then
                impl(ii) = zero
              else
                impl(ii) = impl(ii)
              end if
              do kk=1,madv
                qq(i, j, k, ii, kk) = qq(i, j, k, ii, kk) + uu*impl(kk)
              end do
            end if
          end do
        else
! velocity has a component in negative j-direction.
! loop over the number of advection equations.
          do ii=1,nadv
! set the value of jj such that it corresponds to the
! turbulent entry in w.
            jj = ii + offset
! check whether a first or a second order discretization
! must be used.
            if (secondord) then
! store the three differences for the discretization of
! the derivative in j-direction.
              dwtm1d = wd(i, j, k, jj) - wd(i, j-1, k, jj)
              dwtm1 = w(i, j, k, jj) - w(i, j-1, k, jj)
              dwtd = wd(i, j+1, k, jj) - wd(i, j, k, jj)
              dwt = w(i, j+1, k, jj) - w(i, j, k, jj)
              dwtp1d = wd(i, j+2, k, jj) - wd(i, j+1, k, jj)
              dwtp1 = w(i, j+2, k, jj) - w(i, j+1, k, jj)
! construct the derivative in this cell center. this is
! the first order upwind derivative with two nonlinear
! corrections.
              dwtjd = dwtd
              dwtj = dwt
              if (dwt*dwtp1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs6 = dwt
                else
                  abs6 = -dwt
                end if
                if (dwtp1 .ge. 0.) then
                  abs18 = dwtp1
                else
                  abs18 = -dwtp1
                end if
                if (abs6 .lt. abs18) then
                  dwtjd = dwtjd - half*dwtd
                  dwtj = dwtj - half*dwt
                else
                  dwtjd = dwtjd - half*dwtp1d
                  dwtj = dwtj - half*dwtp1
                end if
              end if
              if (dwt*dwtm1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs7 = dwt
                else
                  abs7 = -dwt
                end if
                if (dwtm1 .ge. 0.) then
                  abs19 = dwtm1
                else
                  abs19 = -dwtm1
                end if
                if (abs7 .lt. abs19) then
                  dwtjd = dwtjd + half*dwtd
                  dwtj = dwtj + half*dwt
                else
                  dwtjd = dwtjd + half*dwtm1d
                  dwtj = dwtj + half*dwtm1
                end if
              end if
            else
! 1st order upwind scheme.
              dwtjd = wd(i, j+1, k, jj) - wd(i, j, k, jj)
              dwtj = w(i, j+1, k, jj) - w(i, j, k, jj)
            end if
! update the residual. the convective term must be
! substracted, because it appears on the other side
! of the equation as the source and viscous terms.
            dwd(i, j, k, idvt+ii-1) = dwd(i, j, k, idvt+ii-1) - uud*dwtj&
&             - uu*dwtjd
            dw(i, j, k, idvt+ii-1) = dw(i, j, k, idvt+ii-1) - uu*dwtj
! update the central jacobian. first the term which is
! always present, i.e. -uu.
            qq(i, j, k, ii, ii) = qq(i, j, k, ii, ii) - uu
! for boundary cells j == jl, the implicit treatment must
! be taken into account. note that the implicit part
! is only based on the 1st order discretization.
! to improve stability the diagonal term is only taken
! into account when it improves stability, i.e. when
! it is positive.
            if (j .eq. jl) then
              do kk=1,madv
                impl(kk) = bmtj2(i, k, jj, kk+offset)
              end do
              if (impl(ii) .lt. zero) then
                impl(ii) = zero
              else
                impl(ii) = impl(ii)
              end if
              do kk=1,madv
                qq(i, j, k, ii, kk) = qq(i, j, k, ii, kk) - uu*impl(kk)
              end do
            end if
          end do
        end if
      end do
    end do
  end do
!
!      ******************************************************************
!      *                                                                *
!      * upwind discretization of the convective term in i (xi)         *
!      * direction. either the 1st order upwind or the second order     *
!      * fully upwind interpolation scheme, kappa = -1, is used in      *
!      * combination with the minmod limiter.                           *
!      * the possible grid velocity must be taken into account.         *
!      *                                                                *
!      ******************************************************************
!
  qs = zero
  qsd = 0.0_8
  do k=2,kl
    do j=2,jl
      do i=2,il
! compute the grid velocity if present.
! it is taken as the average of i and i-1,
        volid = -(half*vold(i, j, k)/vol(i, j, k)**2)
        voli = half/vol(i, j, k)
        if (addgridvelocities) then
          qsd = (sfaceid(i, j, k)+sfaceid(i-1, j, k))*voli + (sfacei(i, &
&           j, k)+sfacei(i-1, j, k))*volid
          qs = (sfacei(i, j, k)+sfacei(i-1, j, k))*voli
        end if
! compute the normal velocity, where the normal direction
! is taken as the average of faces i and i-1.
        xad = (sid(i, j, k, 1)+sid(i-1, j, k, 1))*voli + (si(i, j, k, 1)&
&         +si(i-1, j, k, 1))*volid
        xa = (si(i, j, k, 1)+si(i-1, j, k, 1))*voli
        yad = (sid(i, j, k, 2)+sid(i-1, j, k, 2))*voli + (si(i, j, k, 2)&
&         +si(i-1, j, k, 2))*volid
        ya = (si(i, j, k, 2)+si(i-1, j, k, 2))*voli
        zad = (sid(i, j, k, 3)+sid(i-1, j, k, 3))*voli + (si(i, j, k, 3)&
&         +si(i-1, j, k, 3))*volid
        za = (si(i, j, k, 3)+si(i-1, j, k, 3))*voli
        uud = xad*w(i, j, k, ivx) + xa*wd(i, j, k, ivx) + yad*w(i, j, k&
&         , ivy) + ya*wd(i, j, k, ivy) + zad*w(i, j, k, ivz) + za*wd(i, &
&         j, k, ivz) - qsd
        uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, ivz&
&         ) - qs
! determine the situation we are having here, i.e. positive
! or negative normal velocity.
        if (uu .gt. zero) then
! velocity has a component in positive i-direction.
! loop over the number of advection equations.
          do ii=1,nadv
! set the value of jj such that it corresponds to the
! turbulent entry in w.
            jj = ii + offset
! check whether a first or a second order discretization
! must be used.
            if (secondord) then
! second order; store the three differences for the
! discretization of the derivative in i-direction.
              dwtm1d = wd(i-1, j, k, jj) - wd(i-2, j, k, jj)
              dwtm1 = w(i-1, j, k, jj) - w(i-2, j, k, jj)
              dwtd = wd(i, j, k, jj) - wd(i-1, j, k, jj)
              dwt = w(i, j, k, jj) - w(i-1, j, k, jj)
              dwtp1d = wd(i+1, j, k, jj) - wd(i, j, k, jj)
              dwtp1 = w(i+1, j, k, jj) - w(i, j, k, jj)
! construct the derivative in this cell center. this is
! the first order upwind derivative with two nonlinear
! corrections.
              dwtid = dwtd
              dwti = dwt
              if (dwt*dwtp1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs8 = dwt
                else
                  abs8 = -dwt
                end if
                if (dwtp1 .ge. 0.) then
                  abs20 = dwtp1
                else
                  abs20 = -dwtp1
                end if
                if (abs8 .lt. abs20) then
                  dwtid = dwtid + half*dwtd
                  dwti = dwti + half*dwt
                else
                  dwtid = dwtid + half*dwtp1d
                  dwti = dwti + half*dwtp1
                end if
              end if
              if (dwt*dwtm1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs9 = dwt
                else
                  abs9 = -dwt
                end if
                if (dwtm1 .ge. 0.) then
                  abs21 = dwtm1
                else
                  abs21 = -dwtm1
                end if
                if (abs9 .lt. abs21) then
                  dwtid = dwtid - half*dwtd
                  dwti = dwti - half*dwt
                else
                  dwtid = dwtid - half*dwtm1d
                  dwti = dwti - half*dwtm1
                end if
              end if
            else
! 1st order upwind scheme.
              dwtid = wd(i, j, k, jj) - wd(i-1, j, k, jj)
              dwti = w(i, j, k, jj) - w(i-1, j, k, jj)
            end if
! update the residual. the convective term must be
! substracted, because it appears on the other side of
! the equation as the source and viscous terms.
            dwd(i, j, k, idvt+ii-1) = dwd(i, j, k, idvt+ii-1) - uud*dwti&
&             - uu*dwtid
            dw(i, j, k, idvt+ii-1) = dw(i, j, k, idvt+ii-1) - uu*dwti
! update the central jacobian. first the term which is
! always present, i.e. uu.
            qq(i, j, k, ii, ii) = qq(i, j, k, ii, ii) + uu
! for boundary cells i == 2, the implicit treatment must
! be taken into account. note that the implicit part
! is only based on the 1st order discretization.
! to improve stability the diagonal term is only taken
! into account when it improves stability, i.e. when
! it is positive.
            if (i .eq. 2) then
              do kk=1,madv
                impl(kk) = bmti1(j, k, jj, kk+offset)
              end do
              if (impl(ii) .lt. zero) then
                impl(ii) = zero
              else
                impl(ii) = impl(ii)
              end if
              do kk=1,madv
                qq(i, j, k, ii, kk) = qq(i, j, k, ii, kk) + uu*impl(kk)
              end do
            end if
          end do
        else
! velocity has a component in negative i-direction.
! loop over the number of advection equations.
          do ii=1,nadv
! set the value of jj such that it corresponds to the
! turbulent entry in w.
            jj = ii + offset
! check whether a first or a second order discretization
! must be used.
            if (secondord) then
! second order; store the three differences for the
! discretization of the derivative in i-direction.
              dwtm1d = wd(i, j, k, jj) - wd(i-1, j, k, jj)
              dwtm1 = w(i, j, k, jj) - w(i-1, j, k, jj)
              dwtd = wd(i+1, j, k, jj) - wd(i, j, k, jj)
              dwt = w(i+1, j, k, jj) - w(i, j, k, jj)
              dwtp1d = wd(i+2, j, k, jj) - wd(i+1, j, k, jj)
              dwtp1 = w(i+2, j, k, jj) - w(i+1, j, k, jj)
! construct the derivative in this cell center. this is
! the first order upwind derivative with two nonlinear
! corrections.
              dwtid = dwtd
              dwti = dwt
              if (dwt*dwtp1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs10 = dwt
                else
                  abs10 = -dwt
                end if
                if (dwtp1 .ge. 0.) then
                  abs22 = dwtp1
                else
                  abs22 = -dwtp1
                end if
                if (abs10 .lt. abs22) then
                  dwtid = dwtid - half*dwtd
                  dwti = dwti - half*dwt
                else
                  dwtid = dwtid - half*dwtp1d
                  dwti = dwti - half*dwtp1
                end if
              end if
              if (dwt*dwtm1 .gt. zero) then
                if (dwt .ge. 0.) then
                  abs11 = dwt
                else
                  abs11 = -dwt
                end if
                if (dwtm1 .ge. 0.) then
                  abs23 = dwtm1
                else
                  abs23 = -dwtm1
                end if
                if (abs11 .lt. abs23) then
                  dwtid = dwtid + half*dwtd
                  dwti = dwti + half*dwt
                else
                  dwtid = dwtid + half*dwtm1d
                  dwti = dwti + half*dwtm1
                end if
              end if
            else
! 1st order upwind scheme.
              dwtid = wd(i+1, j, k, jj) - wd(i, j, k, jj)
              dwti = w(i+1, j, k, jj) - w(i, j, k, jj)
            end if
! update the residual. the convective term must be
! substracted, because it appears on the other side
! of the equation as the source and viscous terms.
            dwd(i, j, k, idvt+ii-1) = dwd(i, j, k, idvt+ii-1) - uud*dwti&
&             - uu*dwtid
            dw(i, j, k, idvt+ii-1) = dw(i, j, k, idvt+ii-1) - uu*dwti
! update the central jacobian. first the term which is
! always present, i.e. -uu.
            qq(i, j, k, ii, ii) = qq(i, j, k, ii, ii) - uu
! for boundary cells i == il, the implicit treatment must
! be taken into account. note that the implicit part
! is only based on the 1st order discretization.
! to improve stability the diagonal term is only taken
! into account when it improves stability, i.e. when
! it is positive.
            if (i .eq. il) then
              do kk=1,madv
                impl(kk) = bmti2(j, k, jj, kk+offset)
              end do
              if (impl(ii) .lt. zero) then
                impl(ii) = zero
              else
                impl(ii) = impl(ii)
              end if
              do kk=1,madv
                qq(i, j, k, ii, kk) = qq(i, j, k, ii, kk) - uu*impl(kk)
              end do
            end if
          end do
        end if
      end do
    end do
  end do
end subroutine turbadvection_d

   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcfarfield in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *rev *p *gamma *w *rlv
   !   with respect to varying inputs: *rev *p *gamma *w *rlv *(*bcdata.norm)
   !   Plus diff mem management of: rev:in p:in gamma:in w:in rlv:in
   !                bcdata:in *bcdata.norm:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcFarfield.f90                                  *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-10-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCFARFIELD_D(secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcFarfield applies the farfield boundary condition to a block. *
   !      * It is assumed that the pointers in blockPointers are already   *
   !      * set to the correct block on the correct grid level.            *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_D
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE ITERATION
   IMPLICIT NONE
   !close (UNIT=unitx)
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j, k, l
   REAL(kind=realtype) :: nnx, nny, nnz
   REAL(kind=realtype) :: gm1, ovgm1, ac1, ac2
   REAL(kind=realtype) :: ac1d, ac2d
   REAL(kind=realtype) :: r0, u0, v0, w0, qn0, vn0, c0, s0
   REAL(kind=realtype) :: qn0d
   REAL(kind=realtype) :: re, ue, ve, we, qne, ce
   REAL(kind=realtype) :: red, ued, ved, wed, qned, ced
   REAL(kind=realtype) :: qnf, cf, uf, vf, wf, sf, cc, qq
   REAL(kind=realtype) :: qnfd, cfd, ufd, vfd, wfd, sfd, ccd
   ! Variables Added for forward AD
   REAL(kind=realtype) :: rho, sf2
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1d, ww2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1d, pp2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: gamma1, gamma2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: gamma1d, gamma2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1d, rlv2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1d, rev2d
   INTERFACE 
   SUBROUTINE SETBCPOINTERS(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
   &       rev1, rev2, offset)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn, offset
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   END SUBROUTINE SETBCPOINTERS
   SUBROUTINE RESETBCPOINTERS(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
   &       rev1, rev2, offset)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn, offset
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   END SUBROUTINE RESETBCPOINTERS
   SUBROUTINE SETGAMMA(nn, gamma1, gamma2)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: gamma1, gamma2
   END SUBROUTINE SETGAMMA
   SUBROUTINE RESETGAMMA(nn, gamma1, gamma2)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: gamma1, gamma2
   END SUBROUTINE RESETGAMMA
   END INTERFACE
      INTERFACE 
   SUBROUTINE SETBCPOINTERS_D(nn, ww1, ww1d, ww2, ww2d, pp1, pp1d, &
   &       pp2, pp2d, rlv1, rlv1d, rlv2, rlv2d, rev1, rev1d, rev2, rev2d, &
   &       offset)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn, offset
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1d, ww2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1d, pp2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1d, rlv2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1d, rev2d
   END SUBROUTINE SETBCPOINTERS_D
   SUBROUTINE SETGAMMA_D(nn, gamma1, gamma1d, gamma2, gamma2d)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: gamma1, gamma2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: gamma1d, &
   &       gamma2d
   END SUBROUTINE SETGAMMA_D
   END INTERFACE
      INTRINSIC SQRT
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   REAL(kind=realtype) :: pwr1
   REAL(kind=realtype) :: pwr1d
   REAL(kind=realtype) :: pwx1
   REAL(kind=realtype) :: pwx1d
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Some constants needed to compute the riemann inVariants.
   gm1 = gammainf - one
   ovgm1 = one/gm1
   ! Compute the three velocity components, the speed of sound and
   ! the entropy of the free stream.
   r0 = one/winf(irho)
   u0 = winf(ivx)
   v0 = winf(ivy)
   w0 = winf(ivz)
   arg1 = gammainf*pinfcorr*r0
   c0 = SQRT(arg1)
   pwr1 = winf(irho)**gammainf
   s0 = pwr1/pinfcorr
   ! Loop over the boundary condition subfaces of this block.
   bocos:DO nn=1,nbocos
   ! Check for farfield boundary conditions.
   IF (bctype(nn) .EQ. farfield) THEN
   ! Nullify the pointers and set them to the correct subface.
   ! They are nullified first, because some compilers require
   ! that.
   !nullify(ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, rev2)
   CALL SETBCPOINTERS_D(nn, ww1, ww1d, ww2, ww2d, pp1, pp1d, pp2, &
   &                    pp2d, rlv1, rlv1d, rlv2, rlv2d, rev1, rev1d, rev2, &
   &                    rev2d, 0)
   ! Set the additional pointer for gamma2.
   CALL SETGAMMA_D(nn, gamma1, gamma1d, gamma2, gamma2d)
   ! Loop over the generic subface to set the state in the
   ! halo cells.
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   ! Store the three components of the unit normal a
   ! bit easier.
   ! replace with actual BCData - Peter Lyu 
   !nnx = BCData(nn)%norm(i,j,1)
   !nny = BCData(nn)%norm(i,j,2)
   !nnz = BCData(nn)%norm(i,j,3)
   ! Compute the normal velocity of the free stream and
   ! substract the normal velocity of the mesh.
   qn0d = u0*bcdatad(nn)%norm(i, j, 1) + v0*bcdatad(nn)%norm(i, j&
   &           , 2) + w0*bcdatad(nn)%norm(i, j, 3)
   qn0 = u0*bcdata(nn)%norm(i, j, 1) + v0*bcdata(nn)%norm(i, j, 2&
   &           ) + w0*bcdata(nn)%norm(i, j, 3)
   vn0 = qn0 - bcdata(nn)%rface(i, j)
   ! Compute the three velocity components, the normal
   ! velocity and the speed of sound of the current state
   ! in the internal cell.
   red = -(one*ww2d(i, j, irho)/ww2(i, j, irho)**2)
   re = one/ww2(i, j, irho)
   ued = ww2d(i, j, ivx)
   ue = ww2(i, j, ivx)
   ved = ww2d(i, j, ivy)
   ve = ww2(i, j, ivy)
   wed = ww2d(i, j, ivz)
   we = ww2(i, j, ivz)
   qned = ued*bcdata(nn)%norm(i, j, 1) + ue*bcdatad(nn)%norm(i, j&
   &           , 1) + ved*bcdata(nn)%norm(i, j, 2) + ve*bcdatad(nn)%norm(i&
   &           , j, 2) + wed*bcdata(nn)%norm(i, j, 3) + we*bcdatad(nn)%norm&
   &           (i, j, 3)
   qne = ue*bcdata(nn)%norm(i, j, 1) + ve*bcdata(nn)%norm(i, j, 2&
   &           ) + we*bcdata(nn)%norm(i, j, 3)
   arg1d = (gamma2d(i, j)*re+gamma2(i, j)*red)*pp2(i, j) + gamma2&
   &           (i, j)*re*pp2d(i, j)
   arg1 = gamma2(i, j)*pp2(i, j)*re
   IF (arg1 .EQ. 0.0_8) THEN
   ced = 0.0_8
   ELSE
   ced = arg1d/(2.0*SQRT(arg1))
   END IF
   ce = SQRT(arg1)
   ! Compute the new values of the riemann inVariants in
   ! the halo cell. Either the value in the internal cell
   ! is taken (positive sign of the corresponding
   ! eigenvalue) or the free stream value is taken
   ! (otherwise).
   IF (vn0 .GT. -c0) THEN
   ! Outflow or subsonic inflow.
   ac1d = qned + two*ovgm1*ced
   ac1 = qne + two*ovgm1*ce
   ELSE
   ! Supersonic inflow.
   ac1d = qn0d
   ac1 = qn0 + two*ovgm1*c0
   END IF
   IF (vn0 .GT. c0) THEN
   ! Supersonic outflow.
   ac2d = qned - two*ovgm1*ced
   ac2 = qne - two*ovgm1*ce
   ELSE
   ! Inflow or subsonic outflow.
   ac2d = qn0d
   ac2 = qn0 - two*ovgm1*c0
   END IF
   qnfd = half*(ac1d+ac2d)
   qnf = half*(ac1+ac2)
   cfd = fourth*gm1*(ac1d-ac2d)
   cf = fourth*(ac1-ac2)*gm1
   IF (vn0 .GT. zero) THEN
   ! Outflow.
   ufd = ued + (qnfd-qned)*bcdata(nn)%norm(i, j, 1) + (qnf-qne)&
   &             *bcdatad(nn)%norm(i, j, 1)
   uf = ue + (qnf-qne)*bcdata(nn)%norm(i, j, 1)
   vfd = ved + (qnfd-qned)*bcdata(nn)%norm(i, j, 2) + (qnf-qne)&
   &             *bcdatad(nn)%norm(i, j, 2)
   vf = ve + (qnf-qne)*bcdata(nn)%norm(i, j, 2)
   wfd = wed + (qnfd-qned)*bcdata(nn)%norm(i, j, 3) + (qnf-qne)&
   &             *bcdatad(nn)%norm(i, j, 3)
   wf = we + (qnf-qne)*bcdata(nn)%norm(i, j, 3)
   !Intermediate rho variable added to fix AD bug,ww2
   ! was not getting picked up here. Tapenade 3.6 Does
   ! this properly and this is not required:
   ! rho = ww2(i,j,irho) 
   ! sf = rho**gamma2(i,j)/pp2(i,j) 
   IF (ww2(i, j, irho) .GT. 0.0_8) THEN
   pwr1d = ww2(i, j, irho)**gamma2(i, j)*(LOG(ww2(i, j, irho)&
   &               )*gamma2d(i, j)+gamma2(i, j)*ww2d(i, j, irho)/ww2(i, j, &
   &               irho))
   ELSE IF (ww2(i, j, irho) .EQ. 0.0_8) THEN
   IF (gamma2(i, j) .EQ. 1.0) THEN
   pwr1d = ww2d(i, j, irho)
   ELSE
   pwr1d = 0.0_8
   END IF
   ELSE IF (gamma2(i, j) .EQ. INT(gamma2(i, j))) THEN
   pwr1d = gamma2(i, j)*ww2(i, j, irho)**(gamma2(i, j)-1)*&
   &               ww2d(i, j, irho)
   ELSE
   pwr1d = 0.0_8
   END IF
   pwr1 = ww2(i, j, irho)**gamma2(i, j)
   sfd = (pwr1d*pp2(i, j)-pwr1*pp2d(i, j))/pp2(i, j)**2
   sf = pwr1/pp2(i, j)
   DO l=nt1mg,nt2mg
   ww1d(i, j, l) = ww2d(i, j, l)
   ww1(i, j, l) = ww2(i, j, l)
   END DO
   ELSE
   ! Inflow
   ufd = (qnfd-qn0d)*bcdata(nn)%norm(i, j, 1) + (qnf-qn0)*&
   &             bcdatad(nn)%norm(i, j, 1)
   uf = u0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 1)
   vfd = (qnfd-qn0d)*bcdata(nn)%norm(i, j, 2) + (qnf-qn0)*&
   &             bcdatad(nn)%norm(i, j, 2)
   vf = v0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 2)
   wfd = (qnfd-qn0d)*bcdata(nn)%norm(i, j, 3) + (qnf-qn0)*&
   &             bcdatad(nn)%norm(i, j, 3)
   wf = w0 + (qnf-qn0)*bcdata(nn)%norm(i, j, 3)
   sf = s0
   DO l=nt1mg,nt2mg
   ww1d(i, j, l) = 0.0_8
   ww1(i, j, l) = winf(l)
   END DO
   sfd = 0.0_8
   END IF
   ! Compute the density, velocity and pressure in the
   ! halo cell.
   ccd = ((cfd*cf+cf*cfd)*gamma2(i, j)-cf**2*gamma2d(i, j))/&
   &           gamma2(i, j)**2
   cc = cf*cf/gamma2(i, j)
   qq = uf*uf + vf*vf + wf*wf
   pwx1d = sfd*cc + sf*ccd
   pwx1 = sf*cc
   IF (pwx1 .GT. 0.0_8 .OR. (pwx1 .LT. 0.0_8 .AND. ovgm1 .EQ. INT&
   &             (ovgm1))) THEN
   ww1d(i, j, irho) = ovgm1*pwx1**(ovgm1-1)*pwx1d
   ELSE IF (pwx1 .EQ. 0.0_8 .AND. ovgm1 .EQ. 1.0) THEN
   ww1d(i, j, irho) = pwx1d
   ELSE
   ww1d(i, j, irho) = 0.0_8
   END IF
   ww1(i, j, irho) = pwx1**ovgm1
   ww1d(i, j, ivx) = ufd
   ww1(i, j, ivx) = uf
   ww1d(i, j, ivy) = vfd
   ww1(i, j, ivy) = vf
   ww1d(i, j, ivz) = wfd
   ww1(i, j, ivz) = wf
   pp1d(i, j) = ww1d(i, j, irho)*cc + ww1(i, j, irho)*ccd
   pp1(i, j) = ww1(i, j, irho)*cc
   ! Simply set the laminar and eddy viscosity to
   ! the value in the donor cell. Their values do
   ! not matter too much in the far field.
   IF (viscous) THEN
   rlv1d(i, j) = rlv2d(i, j)
   rlv1(i, j) = rlv2(i, j)
   END IF
   IF (eddymodel) THEN
   rev1d(i, j) = rev2d(i, j)
   rev1(i, j) = rev2(i, j)
   END IF
   END DO
   END DO
   CALL RESETGAMMA(nn, gamma1, gamma2)
   ! deallocation all pointer
   CALL RESETBCPOINTERS(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, &
   &                       rev2, 0)
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT_D(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                  kcbeg(nn), kcend(nn), correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO_D(nn, correctfork)
   END IF
   END DO bocos
   END SUBROUTINE BCFARFIELD_D

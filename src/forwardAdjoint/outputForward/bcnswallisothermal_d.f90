   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcnswallisothermal in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *rev *bvtj1 *bvtj2 *p *gamma
   !                *w *rlv *bvtk1 *bvtk2 *bvti1 *bvti2
   !   with respect to varying inputs: *rev *bvtj1 *bvtj2 *p *gamma
   !                *w *rlv *bvtk1 *bvtk2 *bvti1 *bvti2 *(*bcdata.uslip)
   !                tref rgas
   !   Plus diff mem management of: rev:in bvtj1:in bvtj2:in p:in
   !                gamma:in w:in rlv:in bvtk1:in bvtk2:in bvti1:in
   !                bvti2:in bcdata:in *bcdata.uslip:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcNSWallIsothermal.f90                          *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-10-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCNSWALLISOTHERMAL_D(secondhalo, correctfork)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcNSWallAdiabatic applies the viscous isothermal wall          *
   !      * boundary condition to a block. It is assumed that the pointers *
   !      * in blockPointers are already set to the correct block on the   *
   !      * correct grid level.                                            *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE CONSTANTS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: secondhalo, correctfork
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j
   REAL(kind=realtype) :: rhok, t2, t1
   REAL(kind=realtype) :: rhokd, t2d, t1d
   INTRINSIC MAX
   INTRINSIC MIN
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! In case the turbulent transport equations are solved
   ! together with the mean flow equations, aplly the viscous
   ! wall boundary conditions for the turbulent variables.
   ! No need to extrapolate the secondary halo's, because this
   ! is done in extrapolate2ndHalo.
   ! We turn off the turbulence BCwall for now. This needs
   ! to be added and correct the pointers to use full turbulence.
   ! It should be okay for frozen turbulence assumption.
   IF (turbcoupled) CALL TURBBCNSWALL_D(.false.)
   ! Loop over the viscous subfaces of this block. Note that
   ! these are numbered first.
   bocos:DO nn=1,nviscbocos
   ! Check for isothermal viscous wall boundary conditions.
   IF (bctype(nn) .EQ. nswallisothermal) THEN
   ! Initialize rhok to zero. This will be overwritten if a
   ! correction for k must be applied.
   rhok = zero
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   rhokd = 0.0_8
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   ! Set the value of rhok if a correcton must be applied.
   ! It probably does not matter too much, because k is very
   ! small near the wall.
   IF (correctfork) THEN
   rhokd = wd(1, i, j, irho)*w(2, i, j, itu1) + w(1, i, j, &
   &               irho)*wd(2, i, j, itu1)
   rhok = w(1, i, j, irho)*w(2, i, j, itu1)
   END IF
   ! Compute the temperature in the internal cell and in the
   ! halo cell such that the average is the wall temperature.
   t2d = (pd(2, i, j)*rgas*w(2, i, j, irho)-p(2, i, j)*(rgasd*w&
   &             (2, i, j, irho)+rgas*wd(2, i, j, irho)))/(rgas*w(2, i, j, &
   &             irho))**2
   t2 = p(2, i, j)/(rgas*w(2, i, j, irho))
   t1d = -t2d
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   ! Determine the variables in the halo. As the spacing
   ! is very small a constant pressure boundary condition
   ! (except for the k correction) is okay. Take the slip
   ! velocity into account.
   pd(1, i, j) = pd(2, i, j) - four*third*rhokd
   p(1, i, j) = p(2, i, j) - four*third*rhok
   wd(1, i, j, irho) = (pd(1, i, j)*rgas*t1-p(1, i, j)*(rgasd*&
   &             t1+rgas*t1d))/(rgas*t1)**2
   w(1, i, j, irho) = p(1, i, j)/(rgas*t1)
   wd(1, i, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - wd(2, i&
   &             , j, ivx)
   w(1, i, j, ivx) = -w(2, i, j, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   wd(1, i, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - wd(2, i&
   &             , j, ivy)
   w(1, i, j, ivy) = -w(2, i, j, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   wd(1, i, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - wd(2, i&
   &             , j, ivz)
   w(1, i, j, ivz) = -w(2, i, j, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   ! Set the viscosities. There is no need to test for a
   ! viscous problem of course. The eddy viscosity is
   ! set to the negative value, as it should be zero on
   ! the wall.
   rlvd(1, i, j) = rlvd(2, i, j)
   rlv(1, i, j) = rlv(2, i, j)
   IF (eddymodel) THEN
   revd(1, i, j) = -revd(2, i, j)
   rev(1, i, j) = -rev(2, i, j)
   END IF
   END DO
   END DO
   CASE (imax) 
   rhokd = 0.0_8
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (correctfork) THEN
   rhokd = wd(il, i, j, irho)*w(il, i, j, itu1) + w(il, i, j&
   &               , irho)*wd(il, i, j, itu1)
   rhok = w(il, i, j, irho)*w(il, i, j, itu1)
   END IF
   t2d = (pd(il, i, j)*rgas*w(il, i, j, irho)-p(il, i, j)*(&
   &             rgasd*w(il, i, j, irho)+rgas*wd(il, i, j, irho)))/(rgas*w(&
   &             il, i, j, irho))**2
   t2 = p(il, i, j)/(rgas*w(il, i, j, irho))
   t1d = -t2d
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   pd(ie, i, j) = pd(il, i, j) - four*third*rhokd
   p(ie, i, j) = p(il, i, j) - four*third*rhok
   wd(ie, i, j, irho) = (pd(ie, i, j)*rgas*t1-p(ie, i, j)*(&
   &             rgasd*t1+rgas*t1d))/(rgas*t1)**2
   w(ie, i, j, irho) = p(ie, i, j)/(rgas*t1)
   wd(ie, i, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - wd(il, &
   &             i, j, ivx)
   w(ie, i, j, ivx) = -w(il, i, j, ivx) + two*bcdata(nn)%uslip(&
   &             i, j, 1)
   wd(ie, i, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - wd(il, &
   &             i, j, ivy)
   w(ie, i, j, ivy) = -w(il, i, j, ivy) + two*bcdata(nn)%uslip(&
   &             i, j, 2)
   wd(ie, i, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - wd(il, &
   &             i, j, ivz)
   w(ie, i, j, ivz) = -w(il, i, j, ivz) + two*bcdata(nn)%uslip(&
   &             i, j, 3)
   rlvd(ie, i, j) = rlvd(il, i, j)
   rlv(ie, i, j) = rlv(il, i, j)
   IF (eddymodel) THEN
   revd(ie, i, j) = -revd(il, i, j)
   rev(ie, i, j) = -rev(il, i, j)
   END IF
   END DO
   END DO
   CASE (jmin) 
   rhokd = 0.0_8
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (correctfork) THEN
   rhokd = wd(i, 2, j, irho)*w(i, 2, j, itu1) + w(i, 2, j, &
   &               irho)*wd(i, 2, j, itu1)
   rhok = w(i, 2, j, irho)*w(i, 2, j, itu1)
   END IF
   t2d = (pd(i, 2, j)*rgas*w(i, 2, j, irho)-p(i, 2, j)*(rgasd*w&
   &             (i, 2, j, irho)+rgas*wd(i, 2, j, irho)))/(rgas*w(i, 2, j, &
   &             irho))**2
   t2 = p(i, 2, j)/(rgas*w(i, 2, j, irho))
   t1d = -t2d
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   pd(i, 1, j) = pd(i, 2, j) - four*third*rhokd
   p(i, 1, j) = p(i, 2, j) - four*third*rhok
   wd(i, 1, j, irho) = (pd(i, 1, j)*rgas*t1-p(i, 1, j)*(rgasd*&
   &             t1+rgas*t1d))/(rgas*t1)**2
   w(i, 1, j, irho) = p(i, 1, j)/(rgas*t1)
   wd(i, 1, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - wd(i, 2&
   &             , j, ivx)
   w(i, 1, j, ivx) = -w(i, 2, j, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   wd(i, 1, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - wd(i, 2&
   &             , j, ivy)
   w(i, 1, j, ivy) = -w(i, 2, j, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   wd(i, 1, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - wd(i, 2&
   &             , j, ivz)
   w(i, 1, j, ivz) = -w(i, 2, j, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   rlvd(i, 1, j) = rlvd(i, 2, j)
   rlv(i, 1, j) = rlv(i, 2, j)
   IF (eddymodel) THEN
   revd(i, 1, j) = -revd(i, 2, j)
   rev(i, 1, j) = -rev(i, 2, j)
   END IF
   END DO
   END DO
   CASE (jmax) 
   rhokd = 0.0_8
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (correctfork) THEN
   rhokd = wd(i, jl, j, irho)*w(i, jl, j, itu1) + w(i, jl, j&
   &               , irho)*wd(i, jl, j, itu1)
   rhok = w(i, jl, j, irho)*w(i, jl, j, itu1)
   END IF
   t2d = (pd(i, jl, j)*rgas*w(i, jl, j, irho)-p(i, jl, j)*(&
   &             rgasd*w(i, jl, j, irho)+rgas*wd(i, jl, j, irho)))/(rgas*w(&
   &             i, jl, j, irho))**2
   t2 = p(i, jl, j)/(rgas*w(i, jl, j, irho))
   t1d = -t2d
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   pd(i, je, j) = pd(i, jl, j) - four*third*rhokd
   p(i, je, j) = p(i, jl, j) - four*third*rhok
   wd(i, je, j, irho) = (pd(i, je, j)*rgas*t1-p(i, je, j)*(&
   &             rgasd*t1+rgas*t1d))/(rgas*t1)**2
   w(i, je, j, irho) = p(i, je, j)/(rgas*t1)
   wd(i, je, j, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - wd(i, &
   &             jl, j, ivx)
   w(i, je, j, ivx) = -w(i, jl, j, ivx) + two*bcdata(nn)%uslip(&
   &             i, j, 1)
   wd(i, je, j, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - wd(i, &
   &             jl, j, ivy)
   w(i, je, j, ivy) = -w(i, jl, j, ivy) + two*bcdata(nn)%uslip(&
   &             i, j, 2)
   wd(i, je, j, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - wd(i, &
   &             jl, j, ivz)
   w(i, je, j, ivz) = -w(i, jl, j, ivz) + two*bcdata(nn)%uslip(&
   &             i, j, 3)
   rlvd(i, je, j) = rlvd(i, jl, j)
   rlv(i, je, j) = rlv(i, jl, j)
   IF (eddymodel) THEN
   revd(i, je, j) = -revd(i, jl, j)
   rev(i, je, j) = -rev(i, jl, j)
   END IF
   END DO
   END DO
   CASE (kmin) 
   rhokd = 0.0_8
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (correctfork) THEN
   rhokd = wd(i, j, 2, irho)*w(i, j, 2, itu1) + w(i, j, 2, &
   &               irho)*wd(i, j, 2, itu1)
   rhok = w(i, j, 2, irho)*w(i, j, 2, itu1)
   END IF
   t2d = (pd(i, j, 2)*rgas*w(i, j, 2, irho)-p(i, j, 2)*(rgasd*w&
   &             (i, j, 2, irho)+rgas*wd(i, j, 2, irho)))/(rgas*w(i, j, 2, &
   &             irho))**2
   t2 = p(i, j, 2)/(rgas*w(i, j, 2, irho))
   t1d = -t2d
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   pd(i, j, 1) = pd(i, j, 2) - four*third*rhokd
   p(i, j, 1) = p(i, j, 2) - four*third*rhok
   wd(i, j, 1, irho) = (pd(i, j, 1)*rgas*t1-p(i, j, 1)*(rgasd*&
   &             t1+rgas*t1d))/(rgas*t1)**2
   w(i, j, 1, irho) = p(i, j, 1)/(rgas*t1)
   wd(i, j, 1, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - wd(i, j&
   &             , 2, ivx)
   w(i, j, 1, ivx) = -w(i, j, 2, ivx) + two*bcdata(nn)%uslip(i&
   &             , j, 1)
   wd(i, j, 1, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - wd(i, j&
   &             , 2, ivy)
   w(i, j, 1, ivy) = -w(i, j, 2, ivy) + two*bcdata(nn)%uslip(i&
   &             , j, 2)
   wd(i, j, 1, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - wd(i, j&
   &             , 2, ivz)
   w(i, j, 1, ivz) = -w(i, j, 2, ivz) + two*bcdata(nn)%uslip(i&
   &             , j, 3)
   rlvd(i, j, 1) = rlvd(i, j, 2)
   rlv(i, j, 1) = rlv(i, j, 2)
   IF (eddymodel) THEN
   revd(i, j, 1) = -revd(i, j, 2)
   rev(i, j, 1) = -rev(i, j, 2)
   END IF
   END DO
   END DO
   CASE (kmax) 
   rhokd = 0.0_8
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (correctfork) THEN
   rhokd = wd(i, j, kl, irho)*w(i, j, kl, itu1) + w(i, j, kl&
   &               , irho)*wd(i, j, kl, itu1)
   rhok = w(i, j, kl, irho)*w(i, j, kl, itu1)
   END IF
   t2d = (pd(i, j, kl)*rgas*w(i, j, kl, irho)-p(i, j, kl)*(&
   &             rgasd*w(i, j, kl, irho)+rgas*wd(i, j, kl, irho)))/(rgas*w(&
   &             i, j, kl, irho))**2
   t2 = p(i, j, kl)/(rgas*w(i, j, kl, irho))
   t1d = -t2d
   t1 = two*bcdata(nn)%tns_wall(i, j) - t2
   IF (half*bcdata(nn)%tns_wall(i, j) .LT. t1) THEN
   t1 = t1
   ELSE
   t1 = half*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   IF (two*bcdata(nn)%tns_wall(i, j) .GT. t1) THEN
   t1 = t1
   ELSE
   t1 = two*bcdata(nn)%tns_wall(i, j)
   t1d = 0.0_8
   END IF
   pd(i, j, ke) = pd(i, j, kl) - four*third*rhokd
   p(i, j, ke) = p(i, j, kl) - four*third*rhok
   wd(i, j, ke, irho) = (pd(i, j, ke)*rgas*t1-p(i, j, ke)*(&
   &             rgasd*t1+rgas*t1d))/(rgas*t1)**2
   w(i, j, ke, irho) = p(i, j, ke)/(rgas*t1)
   wd(i, j, ke, ivx) = two*bcdatad(nn)%uslip(i, j, 1) - wd(i, j&
   &             , kl, ivx)
   w(i, j, ke, ivx) = -w(i, j, kl, ivx) + two*bcdata(nn)%uslip(&
   &             i, j, 1)
   wd(i, j, ke, ivy) = two*bcdatad(nn)%uslip(i, j, 2) - wd(i, j&
   &             , kl, ivy)
   w(i, j, ke, ivy) = -w(i, j, kl, ivy) + two*bcdata(nn)%uslip(&
   &             i, j, 2)
   wd(i, j, ke, ivz) = two*bcdatad(nn)%uslip(i, j, 3) - wd(i, j&
   &             , kl, ivz)
   w(i, j, ke, ivz) = -w(i, j, kl, ivz) + two*bcdata(nn)%uslip(&
   &             i, j, 3)
   rlvd(i, j, ke) = rlvd(i, j, kl)
   rlv(i, j, ke) = rlv(i, j, kl)
   IF (eddymodel) THEN
   revd(i, j, ke) = -revd(i, j, kl)
   rev(i, j, ke) = -rev(i, j, kl)
   END IF
   END DO
   END DO
   END SELECT
   ! Compute the energy for these halo's.
   CALL COMPUTEETOT_D(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
   &                  kcbeg(nn), kcend(nn), correctfork)
   ! Extrapolate the state vectors in case a second halo
   ! is needed.
   IF (secondhalo) CALL EXTRAPOLATE2NDHALO_D(nn, correctfork)
   END IF
   END DO bocos
   END SUBROUTINE BCNSWALLISOTHERMAL_D

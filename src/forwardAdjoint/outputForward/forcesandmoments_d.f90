   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of forcesandmoments in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *(*bcdata.fp) *(*bcdata.fv)
   !                *(*bcdata.m) cfp cfv cmp cmv
   !   with respect to varying inputs: *p *x *(*viscsubface.tau)
   !   Plus diff mem management of: viscsubface:in *viscsubface.tau:in
   !                bcdata:in *bcdata.fp:in *bcdata.fv:in *bcdata.m:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          forcesAndMoments.f90                            *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 04-01-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE FORCESANDMOMENTS_D(cfp, cfpd, cfv, cfvd, cmp, cmpd, cmv, cmvd&
   & , yplusmax, sepsensor)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * forcesAndMoments computes the contribution of the block        *
   !      * given by the pointers in blockPointers to the force and        *
   !      * moment coefficients of the geometry. A distinction is made     *
   !      * between the inviscid and viscous parts. In case the maximum    *
   !      * yplus value must be monitored (only possible for rans), this   *
   !      * value is also computed. The separation sensor is also computed *
   !      * here.                                                          *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_D
   USE BCTYPES
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   IMPLICIT NONE
   !
   !      Subroutine arguments
   !
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cfp, cfv
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cfpd, cfvd
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cmp, cmv
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cmpd, cmvd
   REAL(kind=realtype), INTENT(OUT) :: yplusmax, sepsensor
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j
   REAL(kind=realtype) :: pm1, fx, fy, fz, fn
   REAL(kind=realtype) :: pm1d, fxd, fyd, fzd
   REAL(kind=realtype) :: xc, yc, zc
   REAL(kind=realtype) :: xcd, ycd, zcd
   REAL(kind=realtype) :: fact, rho, mul, yplus, dwall
   REAL(kind=realtype) :: scaledim, v(3), sensor
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxd, tauyyd, tauzzd
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyd, tauxzd, tauyzd
   REAL(kind=realtype), DIMENSION(3) :: refpoint
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp2, pp1
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp2d, pp1d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rho2, rho1
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv2, rlv1
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss, xx
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: xxd
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   INTERFACE 
   SUBROUTINE SETBCPOINTERS(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
   &       rev1, rev2, offset)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn, offset
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   END SUBROUTINE SETBCPOINTERS
   SUBROUTINE RESETBCPOINTERS(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
   &       rev1, rev2, offset)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn, offset
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   END SUBROUTINE RESETBCPOINTERS
   SUBROUTINE SETXXSSRHODD2WALL(nn, xx, ss, rho1, rho2, dd2wall)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rho2, rho1
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss, xx
   END SUBROUTINE SETXXSSRHODD2WALL
   SUBROUTINE RESETXXSSRHODD2WALL(nn, xx, ss, rho1, rho2, dd2wall)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rho2, rho1
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss, xx
   END SUBROUTINE RESETXXSSRHODD2WALL
   END INTERFACE
      INTERFACE 
   SUBROUTINE SETBCPOINTERS_D(nn, ww1, ww1d, ww2, ww2d, pp1, pp1d, &
   &       pp2, pp2d, rlv1, rlv1d, rlv2, rlv2d, rev1, rev1d, rev2, rev2d, &
   &       offset)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn, offset
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1d, ww2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1d, pp2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1d, rlv2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1d, rev2d
   END SUBROUTINE SETBCPOINTERS_D
   SUBROUTINE SETXXSSRHODD2WALL_D(nn, xx, xxd, ss, rho1, rho2, &
   &       dd2wall)
   USE BCTYPES
   USE BLOCKPOINTERS_D
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   IMPLICIT NONE
   INTEGER(kind=inttype), INTENT(IN) :: nn
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rho2, rho1
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss, xx
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: xxd
   END SUBROUTINE SETXXSSRHODD2WALL_D
   END INTERFACE
      REAL(kind=realtype) :: mx, my, mz, qa
   REAL(kind=realtype) :: mxd, myd, mzd
   LOGICAL :: viscoussubface
   INTRINSIC SQRT
   INTRINSIC EXP
   INTRINSIC MAX
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: arg2
   REAL(kind=realtype) :: result2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1d
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww2d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev2d
   INTEGER :: ii1
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1d
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1d
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Set the actual scaling factor such that ACTUAL forces are computed
   scaledim = pref/pinf
   ! Determine the reference point for the moment computation in
   ! meters.
   refpoint(1) = lref*pointref(1)
   refpoint(2) = lref*pointref(2)
   refpoint(3) = lref*pointref(3)
   ! Initialize the force and moment coefficients to 0 as well as
   ! yplusMax.
   cfp(1) = zero
   cfp(2) = zero
   cfp(3) = zero
   cfv(1) = zero
   cfv(2) = zero
   cfv(3) = zero
   cmp(1) = zero
   cmp(2) = zero
   cmp(3) = zero
   cmv(1) = zero
   cmv(2) = zero
   cmv(3) = zero
   yplusmax = zero
   sepsensor = zero
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%fp = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%fv = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%m = 0.0_8
   END DO
   cfpd = 0.0_8
   cfvd = 0.0_8
   cmpd = 0.0_8
   cmvd = 0.0_8
   ! Loop over the boundary subfaces of this block.
   bocos:DO nn=1,nbocos
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Integrate the inviscid contribution over the solid walls,    *
   !        * either inviscid or viscous. The integration is done with     *
   !        * cp. For closed contours this is equal to the integration     *
   !        * of p; for open contours this is not the case anymore.        *
   !        * Question is whether a force for an open contour is           *
   !        * meaningful anyway.                                           *
   !        *                                                              *
   !        ****************************************************************
   !
   IF ((bctype(nn) .EQ. eulerwall .OR. bctype(nn) .EQ. nswalladiabatic)&
   &       .OR. bctype(nn) .EQ. nswallisothermal) THEN
   ! Subface is a wall. Check if it is a viscous wall.
   viscoussubface = .true.
   IF (bctype(nn) .EQ. eulerwall) viscoussubface = .false.
   ! Set a bunch of pointers depending on the face id to make
   ! a generic treatment possible. The routine setBcPointers
   ! is not used, because quite a few other ones are needed.
   CALL SETBCPOINTERS_D(nn, ww1, ww1d, ww2, ww2d, pp1, pp1d, pp2, &
   &                    pp2d, rlv1, rlv1d, rlv2, rlv2d, rev1, rev1d, rev2, &
   &                    rev2d, 0)
   CALL SETXXSSRHODD2WALL_D(nn, xx, xxd, ss, rho1, rho2, dd2wall)
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   fact = -one
   CASE (imax) 
   !===========================================================
   fact = one
   CASE (jmin) 
   !===========================================================
   fact = -one
   CASE (jmax) 
   !===========================================================
   fact = one
   CASE (kmin) 
   !===========================================================
   fact = -one
   CASE (kmax) 
   !===========================================================
   fact = one
   END SELECT
   ! Loop over the quadrilateral faces of the subface. Note
   ! that the nodal range of BCData must be used and not the
   ! cell range, because the latter may include the halo's in i
   ! and j-direction. The offset +1 is there, because inBeg and
   ! jnBeg refer to nodal ranges and not to cell ranges.
   bcdata(nn)%oarea(:, :) = zero
   DO j=bcdata(nn)%jnbeg+1,bcdata(nn)%jnend
   DO i=bcdata(nn)%inbeg+1,bcdata(nn)%inend
   ! Compute the average pressure minus 1 and the coordinates
   ! of the centroid of the face relative from from the
   ! moment reference point. Due to the usage of pointers for
   ! the coordinates, whose original array starts at 0, an
   ! offset of 1 must be used. The pressure is multipled by
   ! fact to account for the possibility of an inward or
   ! outward pointing normal.
   pm1d = fact*scaledim*half*(pp2d(i, j)+pp1d(i, j))
   pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*scaledim
   xcd = fourth*(xxd(i, j, 1)+xxd(i+1, j, 1)+xxd(i, j+1, 1)+xxd(i&
   &           +1, j+1, 1))
   xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j&
   &           +1, 1)) - refpoint(1)
   ycd = fourth*(xxd(i, j, 2)+xxd(i+1, j, 2)+xxd(i, j+1, 2)+xxd(i&
   &           +1, j+1, 2))
   yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j&
   &           +1, 2)) - refpoint(2)
   zcd = fourth*(xxd(i, j, 3)+xxd(i+1, j, 3)+xxd(i, j+1, 3)+xxd(i&
   &           +1, j+1, 3))
   zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j&
   &           +1, 3)) - refpoint(3)
   ! Compute the force components.
   fxd = ss(i, j, 1)*pm1d
   fx = pm1*ss(i, j, 1)
   fyd = ss(i, j, 2)*pm1d
   fy = pm1*ss(i, j, 2)
   fzd = ss(i, j, 3)*pm1d
   fz = pm1*ss(i, j, 3)
   ! Store Force data on face
   bcdatad(nn)%fp(i, j, 1) = fxd
   bcdata(nn)%fp(i, j, 1) = fx
   bcdatad(nn)%fp(i, j, 2) = fyd
   bcdata(nn)%fp(i, j, 2) = fy
   bcdatad(nn)%fp(i, j, 3) = fzd
   bcdata(nn)%fp(i, j, 3) = fz
   ! Scatter a quarter of the area to each node:
   arg1 = ss(i, j, 1)**2 + ss(i, j, 2)**2 + ss(i, j, 3)**2
   result1 = SQRT(arg1)
   qa = fourth*result1
   bcdata(nn)%oarea(i-1, j-1) = bcdata(nn)%oarea(i-1, j-1) + qa
   bcdata(nn)%oarea(i, j-1) = bcdata(nn)%oarea(i, j-1) + qa
   bcdata(nn)%oarea(i-1, j) = bcdata(nn)%oarea(i-1, j) + qa
   bcdata(nn)%oarea(i, j) = bcdata(nn)%oarea(i, j) + qa
   ! Get normalized surface velocity:
   v(1) = ww2(i, j, ivx)
   v(2) = ww2(i, j, ivy)
   v(3) = ww2(i, j, ivz)
   arg1 = v(1)**2 + v(2)**2 + v(3)**2
   result1 = SQRT(arg1)
   v = v/(result1+1e-16)
   ! Dot product with free stream
   sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v&
   &           (3)*veldirfreestream(3))
   !Now run through a smooth heaviside function:
   sensor = one/(one+EXP(-(2*10*sensor)))
   ! And integrate over the area of this cell and save:
   sensor = sensor*four*qa
   sepsensor = sepsensor + sensor
   bcdata(nn)%sepsensor(i, j) = sensor
   ! Update the inviscid force and moment coefficients.
   cfpd(1) = cfpd(1) + fxd
   cfp(1) = cfp(1) + fx
   cfpd(2) = cfpd(2) + fyd
   cfp(2) = cfp(2) + fy
   cfpd(3) = cfpd(3) + fzd
   cfp(3) = cfp(3) + fz
   mxd = ycd*fz + yc*fzd - zcd*fy - zc*fyd
   mx = yc*fz - zc*fy
   myd = zcd*fx + zc*fxd - xcd*fz - xc*fzd
   my = zc*fx - xc*fz
   mzd = xcd*fy + xc*fyd - ycd*fx - yc*fxd
   mz = xc*fy - yc*fx
   cmpd(1) = cmpd(1) + mxd
   cmp(1) = cmp(1) + mx
   cmpd(2) = cmpd(2) + myd
   cmp(2) = cmp(2) + my
   cmpd(3) = cmpd(3) + mzd
   cmp(3) = cmp(3) + mz
   ! Store Moment data on face
   bcdatad(nn)%m(i, j, 1) = mxd
   bcdata(nn)%m(i, j, 1) = mx
   bcdatad(nn)%m(i, j, 2) = myd
   bcdata(nn)%m(i, j, 2) = my
   bcdatad(nn)%m(i, j, 3) = mzd
   bcdata(nn)%m(i, j, 3) = mz
   END DO
   END DO
   !
   !          **************************************************************
   !          *                                                            *
   !          * Integration of the viscous forces.                         *
   !          * Only for viscous boundaries.                               *
   !          *                                                            *
   !          **************************************************************
   !
   IF (viscoussubface) THEN
   ! Initialize dwall for the laminar case and set the pointer
   ! for the unit normals.
   dwall = zero
   ! Replace norm with BCData norm - Peter Lyu
   !norm => BCData(nn)%norm
   ! Loop over the quadrilateral faces of the subface and
   ! compute the viscous contribution to the force and
   ! moment and update the maximum value of y+.
   !DEC$ NOVECTOR
   DO j=bcdata(nn)%jnbeg+1,bcdata(nn)%jnend
   !DEC$ NOVECTOR
   DO i=bcdata(nn)%inbeg+1,bcdata(nn)%inend
   ! Store the viscous stress tensor a bit easier.
   tauxxd = viscsubfaced(nn)%tau(i, j, 1)
   tauxx = viscsubface(nn)%tau(i, j, 1)
   tauyyd = viscsubfaced(nn)%tau(i, j, 2)
   tauyy = viscsubface(nn)%tau(i, j, 2)
   tauzzd = viscsubfaced(nn)%tau(i, j, 3)
   tauzz = viscsubface(nn)%tau(i, j, 3)
   tauxyd = viscsubfaced(nn)%tau(i, j, 4)
   tauxy = viscsubface(nn)%tau(i, j, 4)
   tauxzd = viscsubfaced(nn)%tau(i, j, 5)
   tauxz = viscsubface(nn)%tau(i, j, 5)
   tauyzd = viscsubfaced(nn)%tau(i, j, 6)
   tauyz = viscsubface(nn)%tau(i, j, 6)
   ! Compute the viscous force on the face. A minus sign
   ! is now present, due to the definition of this force.
   fxd = -(fact*scaledim*(ss(i, j, 1)*tauxxd+ss(i, j, 2)*tauxyd&
   &             +ss(i, j, 3)*tauxzd))
   fx = -(fact*(tauxx*ss(i, j, 1)+tauxy*ss(i, j, 2)+tauxz*ss(i&
   &             , j, 3))*scaledim)
   fyd = -(fact*scaledim*(ss(i, j, 1)*tauxyd+ss(i, j, 2)*tauyyd&
   &             +ss(i, j, 3)*tauyzd))
   fy = -(fact*(tauxy*ss(i, j, 1)+tauyy*ss(i, j, 2)+tauyz*ss(i&
   &             , j, 3))*scaledim)
   fzd = -(fact*scaledim*(ss(i, j, 1)*tauxzd+ss(i, j, 2)*tauyzd&
   &             +ss(i, j, 3)*tauzzd))
   fz = -(fact*(tauxz*ss(i, j, 1)+tauyz*ss(i, j, 2)+tauzz*ss(i&
   &             , j, 3))*scaledim)
   ! Compute the coordinates of the centroid of the face
   ! relative from the moment reference point. Due to the
   ! usage of pointers for xx and offset of 1 is present,
   ! because x originally starts at 0.
   xcd = fourth*(xxd(i, j, 1)+xxd(i+1, j, 1)+xxd(i, j+1, 1)+xxd&
   &             (i+1, j+1, 1))
   xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1&
   &             , j+1, 1)) - refpoint(1)
   ycd = fourth*(xxd(i, j, 2)+xxd(i+1, j, 2)+xxd(i, j+1, 2)+xxd&
   &             (i+1, j+1, 2))
   yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1&
   &             , j+1, 2)) - refpoint(2)
   zcd = fourth*(xxd(i, j, 3)+xxd(i+1, j, 3)+xxd(i, j+1, 3)+xxd&
   &             (i+1, j+1, 3))
   zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1&
   &             , j+1, 3)) - refpoint(3)
   ! Update the viscous force and moment coefficients.
   cfvd(1) = cfvd(1) + fxd
   cfv(1) = cfv(1) + fx
   cfvd(2) = cfvd(2) + fyd
   cfv(2) = cfv(2) + fy
   cfvd(3) = cfvd(3) + fzd
   cfv(3) = cfv(3) + fz
   ! Store Force data on face
   bcdatad(nn)%fv(i, j, 1) = fxd
   bcdata(nn)%fv(i, j, 1) = fx
   bcdatad(nn)%fv(i, j, 2) = fyd
   bcdata(nn)%fv(i, j, 2) = fy
   bcdatad(nn)%fv(i, j, 3) = fzd
   bcdata(nn)%fv(i, j, 3) = fz
   mxd = ycd*fz + yc*fzd - zcd*fy - zc*fyd
   mx = yc*fz - zc*fy
   myd = zcd*fx + zc*fxd - xcd*fz - xc*fzd
   my = zc*fx - xc*fz
   mzd = xcd*fy + xc*fyd - ycd*fx - yc*fxd
   mz = xc*fy - yc*fx
   cmvd(1) = cmvd(1) + mxd
   cmv(1) = cmv(1) + mx
   cmvd(2) = cmvd(2) + myd
   cmv(2) = cmv(2) + my
   cmvd(3) = cmvd(3) + mzd
   cmv(3) = cmv(3) + mz
   ! Store Moment data on face
   bcdatad(nn)%m(i, j, 1) = bcdatad(nn)%m(i, j, 1) + mxd
   bcdata(nn)%m(i, j, 1) = bcdata(nn)%m(i, j, 1) + mx
   bcdatad(nn)%m(i, j, 2) = bcdatad(nn)%m(i, j, 2) + myd
   bcdata(nn)%m(i, j, 2) = bcdata(nn)%m(i, j, 2) + my
   bcdatad(nn)%m(i, j, 3) = bcdatad(nn)%m(i, j, 3) + mzd
   bcdata(nn)%m(i, j, 3) = bcdata(nn)%m(i, j, 3) + mz
   ! Compute the tangential component of the stress tensor,
   ! which is needed to monitor y+. The result is stored
   ! in fx, fy, fz, although it is not really a force.
   ! As later on only the magnitude of the tangential
   ! component is important, there is no need to take the
   ! sign into account (it should be a minus sign).
   fx = tauxx*bcdata(nn)%norm(i, j, 1) + tauxy*bcdata(nn)%norm(&
   &             i, j, 2) + tauxz*bcdata(nn)%norm(i, j, 3)
   fy = tauxy*bcdata(nn)%norm(i, j, 1) + tauyy*bcdata(nn)%norm(&
   &             i, j, 2) + tauyz*bcdata(nn)%norm(i, j, 3)
   fz = tauxz*bcdata(nn)%norm(i, j, 1) + tauyz*bcdata(nn)%norm(&
   &             i, j, 2) + tauzz*bcdata(nn)%norm(i, j, 3)
   fn = fx*bcdata(nn)%norm(i, j, 1) + fy*bcdata(nn)%norm(i, j, &
   &             2) + fz*bcdata(nn)%norm(i, j, 3)
   fx = fx - fn*bcdata(nn)%norm(i, j, 1)
   fy = fy - fn*bcdata(nn)%norm(i, j, 2)
   fz = fz - fn*bcdata(nn)%norm(i, j, 3)
   ! Compute the local value of y+. Due to the usage
   ! of pointers there is on offset of -1 in dd2Wall..
   IF (equations .EQ. ransequations) dwall = dd2wall(i-1, j-1)
   rho = half*(rho2(i, j)+rho1(i, j))
   mul = half*(rlv2(i, j)+rlv1(i, j))
   arg1 = fx*fx + fy*fy + fz*fz
   result1 = SQRT(arg1)
   arg2 = rho*result1
   result2 = SQRT(arg2)
   yplus = result2*dwall/mul
   IF (yplusmax .LT. yplus) THEN
   yplusmax = yplus
   ELSE
   yplusmax = yplusmax
   END IF
   END DO
   END DO
   ELSE
   ! Zero the viscous force contribution
   bcdatad(nn)%fv = 0.0_8
   bcdata(nn)%fv = zero
   END IF
   ! We have to inverse the nodal areas
   DO j=bcdata(nn)%jnbeg,bcdata(nn)%jnend
   DO i=bcdata(nn)%inbeg,bcdata(nn)%inend
   bcdata(nn)%oarea(i, j) = one/bcdata(nn)%oarea(i, j)
   END DO
   END DO
   CALL RESETBCPOINTERS(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, &
   &                       rev2, 0)
   CALL RESETXXSSRHODD2WALL(nn, xx, ss, rho1, rho2, dd2wall)
   END IF
   END DO bocos
   ! Currently the coefficients only contain the surface integral
   ! of the pressure tensor. These values must be scaled to
   ! obtain the correct coefficients.
   fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
   &   scaledim)
   cfpd(1) = fact*cfpd(1)
   cfp(1) = cfp(1)*fact
   cfpd(2) = fact*cfpd(2)
   cfp(2) = cfp(2)*fact
   cfpd(3) = fact*cfpd(3)
   cfp(3) = cfp(3)*fact
   cfvd(1) = fact*cfvd(1)
   cfv(1) = cfv(1)*fact
   cfvd(2) = fact*cfvd(2)
   cfv(2) = cfv(2)*fact
   cfvd(3) = fact*cfvd(3)
   cfv(3) = cfv(3)*fact
   fact = fact/(lengthref*lref)
   cmpd(1) = fact*cmpd(1)
   cmp(1) = cmp(1)*fact
   cmpd(2) = fact*cmpd(2)
   cmp(2) = cmp(2)*fact
   cmpd(3) = fact*cmpd(3)
   cmp(3) = cmp(3)*fact
   cmvd(1) = fact*cmvd(1)
   cmv(1) = cmv(1)*fact
   cmvd(2) = fact*cmvd(2)
   cmv(2) = cmv(2)*fact
   cmvd(3) = fact*cmvd(3)
   cmv(3) = cmv(3)*fact
   END SUBROUTINE FORCESANDMOMENTS_D

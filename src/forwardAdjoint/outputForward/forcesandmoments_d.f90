   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of forcesandmoments in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *(*bcdata.fp) *(*bcdata.fv)
   !                *(*bcdata.m) *(*bcdata.oarea) *(*bcdata.sepsensor)
   !                *(*bcdata.cavitation) cfp cfv cmp cmv cavitation
   !                sepsensor
   !   with respect to varying inputs: gammainf pinf pref *p *w *x
   !                *si *sj *sk *(*viscsubface.tau) veldirfreestream
   !                lengthref machcoef pointref *xx *pp1 *pp2 *ssi
   !                *ww2
   !   Plus diff mem management of: viscsubface:in *viscsubface.tau:in
   !                bcdata:in *bcdata.fp:in *bcdata.fv:in *bcdata.m:in
   !                *bcdata.oarea:in *bcdata.sepsensor:in *bcdata.cavitation:in
   !                xx:in-out rev0:out rev1:out rev2:out rev3:out
   !                pp0:out pp1:in-out pp2:in-out pp3:out rlv0:out
   !                rlv1:out rlv2:out rlv3:out ss:out ssi:in-out ssj:out
   !                ssk:out ww0:out ww1:in-out ww2:in-out ww3:out
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          forcesAndMoments.f90                            *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 04-01-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE FORCESANDMOMENTS_D(cfp, cfpd, cfv, cfvd, cmp, cmpd, cmv, cmvd&
   & , yplusmax, sepsensor, sepsensord, cavitation, cavitationd)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * forcesAndMoments computes the contribution of the block        *
   !      * given by the pointers in blockPointers to the force and        *
   !      * moment coefficients of the geometry. A distinction is made     *
   !      * between the inviscid and viscous parts. In case the maximum    *
   !      * yplus value must be monitored (only possible for rans), this   *
   !      * value is also computed. The separation sensor and the cavita-  *
   !      * tion sensor is also computed                                   *
   !      * here.                                                          *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS
   USE BCTYPES
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE BCROUTINES_D
   USE DIFFSIZES
   !  Hint: ISIZE1OFDrfbcdata should be the size of dimension 1 of array *bcdata
   IMPLICIT NONE
   !
   !      Subroutine arguments
   !
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cfp, cfv
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cfpd, cfvd
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cmp, cmv
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cmpd, cmvd
   REAL(kind=realtype), INTENT(OUT) :: yplusmax, sepsensor, cavitation
   REAL(kind=realtype), INTENT(OUT) :: sepsensord, cavitationd
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: nn, i, j, ii
   REAL(kind=realtype) :: pm1, fx, fy, fz, fn, sigma
   REAL(kind=realtype) :: pm1d, fxd, fyd, fzd
   REAL(kind=realtype) :: xc, yc, zc
   REAL(kind=realtype) :: xcd, ycd, zcd
   REAL(kind=realtype) :: fact, rho, mul, yplus, dwall
   REAL(kind=realtype) :: factd
   REAL(kind=realtype) :: scaledim, v(3), sensor, sensor1, cp, tmp, &
   & plocal
   REAL(kind=realtype) :: scaledimd, vd(3), sensord, sensor1d, cpd, tmpd&
   & , plocald
   REAL(kind=realtype) :: tauxx, tauyy, tauzz
   REAL(kind=realtype) :: tauxxd, tauyyd, tauzzd
   REAL(kind=realtype) :: tauxy, tauxz, tauyz
   REAL(kind=realtype) :: tauxyd, tauxzd, tauyzd
   REAL(kind=realtype), DIMENSION(3) :: refpoint
   REAL(kind=realtype), DIMENSION(3) :: refpointd
   REAL(kind=realtype) :: mx, my, mz, qa
   REAL(kind=realtype) :: mxd, myd, mzd, qad
   LOGICAL :: viscoussubface
   INTRINSIC MOD
   INTRINSIC SQRT
   INTRINSIC EXP
   INTRINSIC MAX
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: result1d
   REAL(kind=realtype) :: arg2
   REAL(kind=realtype) :: result2
   INTEGER :: ii1
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Set the actual scaling factor such that ACTUAL forces are computed
   scaledimd = (prefd*pinf-pref*pinfd)/pinf**2
   scaledim = pref/pinf
   ! Determine the reference point for the moment computation in
   ! meters.
   refpointd = 0.0_8
   refpointd(1) = lref*pointrefd(1)
   refpoint(1) = lref*pointref(1)
   refpointd(2) = lref*pointrefd(2)
   refpoint(2) = lref*pointref(2)
   refpointd(3) = lref*pointrefd(3)
   refpoint(3) = lref*pointref(3)
   ! Initialize the force and moment coefficients to 0 as well as
   ! yplusMax.
   cfp(1) = zero
   cfp(2) = zero
   cfp(3) = zero
   cfv(1) = zero
   cfv(2) = zero
   cfv(3) = zero
   cmp(1) = zero
   cmp(2) = zero
   cmp(3) = zero
   cmv(1) = zero
   cmv(2) = zero
   cmv(3) = zero
   yplusmax = zero
   sepsensor = zero
   cavitation = zero
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%fp = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%fv = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%m = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%oarea = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%sepsensor = 0.0_8
   END DO
   DO ii1=1,ISIZE1OFDrfbcdata
   bcdatad(ii1)%cavitation = 0.0_8
   END DO
   cfpd = 0.0_8
   cfvd = 0.0_8
   cmpd = 0.0_8
   cmvd = 0.0_8
   cavitationd = 0.0_8
   sepsensord = 0.0_8
   vd = 0.0_8
   ! Loop over the boundary subfaces of this block.
   bocos:DO nn=1,nbocos
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Integrate the inviscid contribution over the solid walls,    *
   !        * either inviscid or viscous. The integration is done with     *
   !        * cp. For closed contours this is equal to the integration     *
   !        * of p; for open contours this is not the case anymore.        *
   !        * Question is whether a force for an open contour is           *
   !        * meaningful anyway.                                           *
   !        *                                                              *
   !        ****************************************************************
   !
   IF ((bctype(nn) .EQ. eulerwall .OR. bctype(nn) .EQ. nswalladiabatic)&
   &       .OR. bctype(nn) .EQ. nswallisothermal) THEN
   ! Subface is a wall. Check if it is a viscous wall.
   viscoussubface = .true.
   IF (bctype(nn) .EQ. eulerwall) viscoussubface = .false.
   ! Set a bunch of pointers depending on the face id to make
   ! a generic treatment possible. The routine setBcPointers
   ! is not used, because quite a few other ones are needed.
   CALL SETBCPOINTERS_D(nn, .true.)
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   fact = -one
   CASE (imax) 
   fact = one
   CASE (jmin) 
   fact = -one
   CASE (jmax) 
   fact = one
   CASE (kmin) 
   fact = -one
   CASE (kmax) 
   fact = one
   END SELECT
   ! Loop over the quadrilateral faces of the subface. Note
   ! that the nodal range of BCData must be used and not the
   ! cell range, because the latter may include the halo's in i
   ! and j-direction. The offset +1 is there, because inBeg and
   ! jnBeg refer to nodal ranges and not to cell ranges.
   bcdatad(nn)%oarea(:, :) = 0.0_8
   bcdata(nn)%oarea(:, :) = zero
   DO ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
   &         bcdata(nn)%inbeg)-1
   i = MOD(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn)%&
   &         inbeg + 1
   j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%jnbeg + &
   &         1
   ! Compute the average pressure minus 1 and the coordinates
   ! of the centroid of the face relative from from the
   ! moment reference point. Due to the usage of pointers for
   ! the coordinates, whose original array starts at 0, an
   ! offset of 1 must be used. The pressure is multipled by
   ! fact to account for the possibility of an inward or
   ! outward pointing normal.
   pm1d = fact*((half*(pp2d(i, j)+pp1d(i, j))-pinfd)*scaledim+(half&
   &         *(pp2(i, j)+pp1(i, j))-pinf)*scaledimd)
   pm1 = fact*(half*(pp2(i, j)+pp1(i, j))-pinf)*scaledim
   xcd = fourth*(xxd(i, j, 1)+xxd(i+1, j, 1)+xxd(i, j+1, 1)+xxd(i+1&
   &         , j+1, 1)) - refpointd(1)
   xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j+1&
   &         , 1)) - refpoint(1)
   ycd = fourth*(xxd(i, j, 2)+xxd(i+1, j, 2)+xxd(i, j+1, 2)+xxd(i+1&
   &         , j+1, 2)) - refpointd(2)
   yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j+1&
   &         , 2)) - refpoint(2)
   zcd = fourth*(xxd(i, j, 3)+xxd(i+1, j, 3)+xxd(i, j+1, 3)+xxd(i+1&
   &         , j+1, 3)) - refpointd(3)
   zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j+1&
   &         , 3)) - refpoint(3)
   ! Compute the force components.
   fxd = pm1d*ssi(i, j, 1) + pm1*ssid(i, j, 1)
   fx = pm1*ssi(i, j, 1)
   fyd = pm1d*ssi(i, j, 2) + pm1*ssid(i, j, 2)
   fy = pm1*ssi(i, j, 2)
   fzd = pm1d*ssi(i, j, 3) + pm1*ssid(i, j, 3)
   fz = pm1*ssi(i, j, 3)
   ! Store Force data on face
   bcdatad(nn)%fp(i, j, 1) = fxd
   bcdata(nn)%fp(i, j, 1) = fx
   bcdatad(nn)%fp(i, j, 2) = fyd
   bcdata(nn)%fp(i, j, 2) = fy
   bcdatad(nn)%fp(i, j, 3) = fzd
   bcdata(nn)%fp(i, j, 3) = fz
   ! Scatter a quarter of the area to each node:
   arg1d = 2*ssi(i, j, 1)*ssid(i, j, 1) + 2*ssi(i, j, 2)*ssid(i, j&
   &         , 2) + 2*ssi(i, j, 3)*ssid(i, j, 3)
   arg1 = ssi(i, j, 1)**2 + ssi(i, j, 2)**2 + ssi(i, j, 3)**2
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   qad = fourth*result1d
   qa = fourth*result1
   bcdatad(nn)%oarea(i-1, j-1) = bcdatad(nn)%oarea(i-1, j-1) + qad
   bcdata(nn)%oarea(i-1, j-1) = bcdata(nn)%oarea(i-1, j-1) + qa
   bcdatad(nn)%oarea(i, j-1) = bcdatad(nn)%oarea(i, j-1) + qad
   bcdata(nn)%oarea(i, j-1) = bcdata(nn)%oarea(i, j-1) + qa
   bcdatad(nn)%oarea(i-1, j) = bcdatad(nn)%oarea(i-1, j) + qad
   bcdata(nn)%oarea(i-1, j) = bcdata(nn)%oarea(i-1, j) + qa
   bcdatad(nn)%oarea(i, j) = bcdatad(nn)%oarea(i, j) + qad
   bcdata(nn)%oarea(i, j) = bcdata(nn)%oarea(i, j) + qa
   ! Get normalized surface velocity:
   vd(1) = ww2d(i, j, ivx)
   v(1) = ww2(i, j, ivx)
   vd(2) = ww2d(i, j, ivy)
   v(2) = ww2(i, j, ivy)
   vd(3) = ww2d(i, j, ivz)
   v(3) = ww2(i, j, ivz)
   arg1d = 2*v(1)*vd(1) + 2*v(2)*vd(2) + 2*v(3)*vd(3)
   arg1 = v(1)**2 + v(2)**2 + v(3)**2
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   vd = (vd*(result1+1e-16)-v*result1d)/(result1+1e-16)**2
   v = v/(result1+1e-16)
   ! Dot product with free stream
   sensord = -(vd(1)*veldirfreestream(1)+v(1)*veldirfreestreamd(1)+&
   &         vd(2)*veldirfreestream(2)+v(2)*veldirfreestreamd(2)+vd(3)*&
   &         veldirfreestream(3)+v(3)*veldirfreestreamd(3))
   sensor = -(v(1)*veldirfreestream(1)+v(2)*veldirfreestream(2)+v(3&
   &         )*veldirfreestream(3))
   !Now run through a smooth heaviside function:
   sensord = -((-(one*2*10*sensord*EXP(-(2*10*sensor))))/(one+EXP(-&
   &         (2*10*sensor)))**2)
   sensor = one/(one+EXP(-(2*10*sensor)))
   ! And integrate over the area of this cell and save:
   sensord = four*(sensord*qa+sensor*qad)
   sensor = sensor*four*qa
   sepsensord = sepsensord + sensord
   sepsensor = sepsensor + sensor
   bcdatad(nn)%sepsensor(i, j) = sensord
   bcdata(nn)%sepsensor(i, j) = sensor
   plocald = pp2d(i, j)
   plocal = pp2(i, j)
   tmpd = -(two*((gammainfd*pinf+gammainf*pinfd)*machcoef**2+&
   &         gammainf*pinf*(machcoefd*machcoef+machcoef*machcoefd))/(&
   &         gammainf*pinf*machcoef*machcoef)**2)
   tmp = two/(gammainf*pinf*machcoef*machcoef)
   cpd = tmpd*(plocal-pinf) + tmp*(plocald-pinfd)
   cp = tmp*(plocal-pinf)
   sigma = 1.4
   sensor1d = -cpd
   sensor1 = -cp - sigma
   !IF (sense >= 0) THEN
   !Sensor = 1
   !ELSE 
   !Sensor = 0
   !END IF
   sensor1d = -((-(one*2*10*sensor1d*EXP(-(2*10*sensor1))))/(one+&
   &         EXP(-(2*10*sensor1)))**2)
   sensor1 = one/(one+EXP(-(2*10*sensor1)))
   sensor1d = four*(sensor1d*qa+sensor1*qad)
   sensor1 = sensor1*four*qa
   cavitationd = cavitationd + sensor1d
   cavitation = cavitation + sensor1
   bcdatad(nn)%cavitation(i, j) = sensor1d
   bcdata(nn)%cavitation(i, j) = sensor1
   ! Update the inviscid force and moment coefficients.
   cfpd(1) = cfpd(1) + fxd
   cfp(1) = cfp(1) + fx
   cfpd(2) = cfpd(2) + fyd
   cfp(2) = cfp(2) + fy
   cfpd(3) = cfpd(3) + fzd
   cfp(3) = cfp(3) + fz
   mxd = ycd*fz + yc*fzd - zcd*fy - zc*fyd
   mx = yc*fz - zc*fy
   myd = zcd*fx + zc*fxd - xcd*fz - xc*fzd
   my = zc*fx - xc*fz
   mzd = xcd*fy + xc*fyd - ycd*fx - yc*fxd
   mz = xc*fy - yc*fx
   cmpd(1) = cmpd(1) + mxd
   cmp(1) = cmp(1) + mx
   cmpd(2) = cmpd(2) + myd
   cmp(2) = cmp(2) + my
   cmpd(3) = cmpd(3) + mzd
   cmp(3) = cmp(3) + mz
   ! Store Moment data on face
   bcdatad(nn)%m(i, j, 1) = mxd
   bcdata(nn)%m(i, j, 1) = mx
   bcdatad(nn)%m(i, j, 2) = myd
   bcdata(nn)%m(i, j, 2) = my
   bcdatad(nn)%m(i, j, 3) = mzd
   bcdata(nn)%m(i, j, 3) = mz
   END DO
   !
   !          **************************************************************
   !          *                                                            *
   !          * Integration of the viscous forces.                         *
   !          * Only for viscous boundaries.                               *
   !          *                                                            *
   !          **************************************************************
   !
   IF (viscoussubface) THEN
   ! Initialize dwall for the laminar case and set the pointer
   ! for the unit normals.
   dwall = zero
   ! Replace norm with BCData norm - Peter Lyu
   !norm => BCData(nn)%norm
   ! Loop over the quadrilateral faces of the subface and
   ! compute the viscous contribution to the force and
   ! moment and update the maximum value of y+.
   DO ii=0,(bcdata(nn)%jnend-bcdata(nn)%jnbeg)*(bcdata(nn)%inend-&
   &           bcdata(nn)%inbeg)-1
   i = MOD(ii, bcdata(nn)%inend - bcdata(nn)%inbeg) + bcdata(nn)%&
   &           inbeg + 1
   j = ii/(bcdata(nn)%inend-bcdata(nn)%inbeg) + bcdata(nn)%jnbeg &
   &           + 1
   ! Store the viscous stress tensor a bit easier.
   tauxxd = viscsubfaced(nn)%tau(i, j, 1)
   tauxx = viscsubface(nn)%tau(i, j, 1)
   tauyyd = viscsubfaced(nn)%tau(i, j, 2)
   tauyy = viscsubface(nn)%tau(i, j, 2)
   tauzzd = viscsubfaced(nn)%tau(i, j, 3)
   tauzz = viscsubface(nn)%tau(i, j, 3)
   tauxyd = viscsubfaced(nn)%tau(i, j, 4)
   tauxy = viscsubface(nn)%tau(i, j, 4)
   tauxzd = viscsubfaced(nn)%tau(i, j, 5)
   tauxz = viscsubface(nn)%tau(i, j, 5)
   tauyzd = viscsubfaced(nn)%tau(i, j, 6)
   tauyz = viscsubface(nn)%tau(i, j, 6)
   ! Compute the viscous force on the face. A minus sign
   ! is now present, due to the definition of this force.
   fxd = -(fact*((tauxxd*ssi(i, j, 1)+tauxx*ssid(i, j, 1)+tauxyd*&
   &           ssi(i, j, 2)+tauxy*ssid(i, j, 2)+tauxzd*ssi(i, j, 3)+tauxz*&
   &           ssid(i, j, 3))*scaledim+(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, &
   &           2)+tauxz*ssi(i, j, 3))*scaledimd))
   fx = -(fact*(tauxx*ssi(i, j, 1)+tauxy*ssi(i, j, 2)+tauxz*ssi(i&
   &           , j, 3))*scaledim)
   fyd = -(fact*((tauxyd*ssi(i, j, 1)+tauxy*ssid(i, j, 1)+tauyyd*&
   &           ssi(i, j, 2)+tauyy*ssid(i, j, 2)+tauyzd*ssi(i, j, 3)+tauyz*&
   &           ssid(i, j, 3))*scaledim+(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, &
   &           2)+tauyz*ssi(i, j, 3))*scaledimd))
   fy = -(fact*(tauxy*ssi(i, j, 1)+tauyy*ssi(i, j, 2)+tauyz*ssi(i&
   &           , j, 3))*scaledim)
   fzd = -(fact*((tauxzd*ssi(i, j, 1)+tauxz*ssid(i, j, 1)+tauyzd*&
   &           ssi(i, j, 2)+tauyz*ssid(i, j, 2)+tauzzd*ssi(i, j, 3)+tauzz*&
   &           ssid(i, j, 3))*scaledim+(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, &
   &           2)+tauzz*ssi(i, j, 3))*scaledimd))
   fz = -(fact*(tauxz*ssi(i, j, 1)+tauyz*ssi(i, j, 2)+tauzz*ssi(i&
   &           , j, 3))*scaledim)
   ! Compute the coordinates of the centroid of the face
   ! relative from the moment reference point. Due to the
   ! usage of pointers for xx and offset of 1 is present,
   ! because x originally starts at 0.
   xcd = fourth*(xxd(i, j, 1)+xxd(i+1, j, 1)+xxd(i, j+1, 1)+xxd(i&
   &           +1, j+1, 1)) - refpointd(1)
   xc = fourth*(xx(i, j, 1)+xx(i+1, j, 1)+xx(i, j+1, 1)+xx(i+1, j&
   &           +1, 1)) - refpoint(1)
   ycd = fourth*(xxd(i, j, 2)+xxd(i+1, j, 2)+xxd(i, j+1, 2)+xxd(i&
   &           +1, j+1, 2)) - refpointd(2)
   yc = fourth*(xx(i, j, 2)+xx(i+1, j, 2)+xx(i, j+1, 2)+xx(i+1, j&
   &           +1, 2)) - refpoint(2)
   zcd = fourth*(xxd(i, j, 3)+xxd(i+1, j, 3)+xxd(i, j+1, 3)+xxd(i&
   &           +1, j+1, 3)) - refpointd(3)
   zc = fourth*(xx(i, j, 3)+xx(i+1, j, 3)+xx(i, j+1, 3)+xx(i+1, j&
   &           +1, 3)) - refpoint(3)
   ! Update the viscous force and moment coefficients.
   cfvd(1) = cfvd(1) + fxd
   cfv(1) = cfv(1) + fx
   cfvd(2) = cfvd(2) + fyd
   cfv(2) = cfv(2) + fy
   cfvd(3) = cfvd(3) + fzd
   cfv(3) = cfv(3) + fz
   ! Store Force data on face
   bcdatad(nn)%fv(i, j, 1) = fxd
   bcdata(nn)%fv(i, j, 1) = fx
   bcdatad(nn)%fv(i, j, 2) = fyd
   bcdata(nn)%fv(i, j, 2) = fy
   bcdatad(nn)%fv(i, j, 3) = fzd
   bcdata(nn)%fv(i, j, 3) = fz
   mxd = ycd*fz + yc*fzd - zcd*fy - zc*fyd
   mx = yc*fz - zc*fy
   myd = zcd*fx + zc*fxd - xcd*fz - xc*fzd
   my = zc*fx - xc*fz
   mzd = xcd*fy + xc*fyd - ycd*fx - yc*fxd
   mz = xc*fy - yc*fx
   cmvd(1) = cmvd(1) + mxd
   cmv(1) = cmv(1) + mx
   cmvd(2) = cmvd(2) + myd
   cmv(2) = cmv(2) + my
   cmvd(3) = cmvd(3) + mzd
   cmv(3) = cmv(3) + mz
   ! Store Moment data on face
   bcdatad(nn)%m(i, j, 1) = bcdatad(nn)%m(i, j, 1) + mxd
   bcdata(nn)%m(i, j, 1) = bcdata(nn)%m(i, j, 1) + mx
   bcdatad(nn)%m(i, j, 2) = bcdatad(nn)%m(i, j, 2) + myd
   bcdata(nn)%m(i, j, 2) = bcdata(nn)%m(i, j, 2) + my
   bcdatad(nn)%m(i, j, 3) = bcdatad(nn)%m(i, j, 3) + mzd
   bcdata(nn)%m(i, j, 3) = bcdata(nn)%m(i, j, 3) + mz
   ! Compute the tangential component of the stress tensor,
   ! which is needed to monitor y+. The result is stored
   ! in fx, fy, fz, although it is not really a force.
   ! As later on only the magnitude of the tangential
   ! component is important, there is no need to take the
   ! sign into account (it should be a minus sign).
   fx = tauxx*bcdata(nn)%norm(i, j, 1) + tauxy*bcdata(nn)%norm(i&
   &           , j, 2) + tauxz*bcdata(nn)%norm(i, j, 3)
   fy = tauxy*bcdata(nn)%norm(i, j, 1) + tauyy*bcdata(nn)%norm(i&
   &           , j, 2) + tauyz*bcdata(nn)%norm(i, j, 3)
   fz = tauxz*bcdata(nn)%norm(i, j, 1) + tauyz*bcdata(nn)%norm(i&
   &           , j, 2) + tauzz*bcdata(nn)%norm(i, j, 3)
   fn = fx*bcdata(nn)%norm(i, j, 1) + fy*bcdata(nn)%norm(i, j, 2)&
   &           + fz*bcdata(nn)%norm(i, j, 3)
   fx = fx - fn*bcdata(nn)%norm(i, j, 1)
   fy = fy - fn*bcdata(nn)%norm(i, j, 2)
   fz = fz - fn*bcdata(nn)%norm(i, j, 3)
   ! Compute the local value of y+. Due to the usage
   ! of pointers there is on offset of -1 in dd2Wall..
   IF (equations .EQ. ransequations) THEN
   dwall = dd2wall(i-1, j-1)
   rho = half*(ww2(i, j, irho)+ww1(i, j, irho))
   mul = half*(rlv2(i, j)+rlv1(i, j))
   arg1 = fx*fx + fy*fy + fz*fz
   result1 = SQRT(arg1)
   arg2 = rho*result1
   result2 = SQRT(arg2)
   yplus = result2*dwall/mul
   IF (yplusmax .LT. yplus) THEN
   yplusmax = yplus
   ELSE
   yplusmax = yplusmax
   END IF
   END IF
   END DO
   ELSE
   ! Zero the viscous force contribution
   bcdatad(nn)%fv = 0.0_8
   bcdata(nn)%fv = zero
   END IF
   ! We have to inverse the nodal areas
   DO j=bcdata(nn)%jnbeg,bcdata(nn)%jnend
   DO i=bcdata(nn)%inbeg,bcdata(nn)%inend
   bcdatad(nn)%oarea(i, j) = -(one*bcdatad(nn)%oarea(i, j)/bcdata&
   &           (nn)%oarea(i, j)**2)
   bcdata(nn)%oarea(i, j) = one/bcdata(nn)%oarea(i, j)
   END DO
   END DO
   CALL RESETBCPOINTERS(nn, .true.)
   END IF
   END DO bocos
   ! Currently the coefficients only contain the surface integral
   ! of the pressure tensor. These values must be scaled to
   ! obtain the correct coefficients.
   factd = -(two*surfaceref*lref**2*(((gammainfd*pinf+gammainf*pinfd)*&
   &   scaledim+gammainf*pinf*scaledimd)*machcoef**2+gammainf*pinf*scaledim&
   &   *(machcoefd*machcoef+machcoef*machcoefd))/(gammainf*pinf*machcoef*&
   &   machcoef*surfaceref*lref*lref*scaledim)**2)
   fact = two/(gammainf*pinf*machcoef*machcoef*surfaceref*lref*lref*&
   &   scaledim)
   cfpd(1) = cfpd(1)*fact + cfp(1)*factd
   cfp(1) = cfp(1)*fact
   cfpd(2) = cfpd(2)*fact + cfp(2)*factd
   cfp(2) = cfp(2)*fact
   cfpd(3) = cfpd(3)*fact + cfp(3)*factd
   cfp(3) = cfp(3)*fact
   cfvd(1) = cfvd(1)*fact + cfv(1)*factd
   cfv(1) = cfv(1)*fact
   cfvd(2) = cfvd(2)*fact + cfv(2)*factd
   cfv(2) = cfv(2)*fact
   cfvd(3) = cfvd(3)*fact + cfv(3)*factd
   cfv(3) = cfv(3)*fact
   factd = (factd*lengthref*lref-fact*lref*lengthrefd)/(lengthref*lref)**&
   &   2
   fact = fact/(lengthref*lref)
   cmpd(1) = cmpd(1)*fact + cmp(1)*factd
   cmp(1) = cmp(1)*fact
   cmpd(2) = cmpd(2)*fact + cmp(2)*factd
   cmp(2) = cmp(2)*fact
   cmpd(3) = cmpd(3)*fact + cmp(3)*factd
   cmp(3) = cmp(3)*fact
   cmvd(1) = cmvd(1)*fact + cmv(1)*factd
   cmv(1) = cmv(1)*fact
   cmvd(2) = cmvd(2)*fact + cmv(2)*factd
   cmv(2) = cmv(2)*fact
   cmvd(3) = cmvd(3)*fact + cmv(3)*factd
   cmv(3) = cmv(3)*fact
   END SUBROUTINE FORCESANDMOMENTS_D

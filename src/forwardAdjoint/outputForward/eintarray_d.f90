!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
!  differentiation of eintarray in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: eint
!   with respect to varying inputs: tref rgas k p eint rho
!      ==================================================================
subroutine eintarray_d(rho, rhod, p, pd, k, kd, eint, eintd, correctfork&
& , kk)
!
!      ******************************************************************
!      *                                                                *
!      * eintarray computes the internal energy per unit mass from the  *
!      * given density and pressure (and possibly turbulent energy) for *
!      * the given kk elements of the arrays.                           *
!      * for a calorically and thermally perfect gas the well-known     *
!      * expression is used; for only a thermally perfect gas, cp is a  *
!      * function of temperature, curve fits are used and a more        *
!      * complex expression is obtained.                                *
!      *                                                                *
!      ******************************************************************
!
  use constants
  use cpcurvefits
  use flowvarrefstate
  use inputphysics
  implicit none
  integer(kind=inttype), intent(in) :: kk
!
!      subroutine arguments.
!
  real(kind=realtype), dimension(kk), intent(in) :: rho, p, k
  real(kind=realtype), dimension(kk), intent(in) :: rhod, pd, kd
  real(kind=realtype), dimension(kk), intent(out) :: eint
  real(kind=realtype), dimension(kk), intent(out) :: eintd
  logical, intent(in) :: correctfork
!
!      local parameter.
!
  real(kind=realtype), parameter :: twothird=two*third
!
!      local variables.
!
  integer(kind=inttype) :: i, nn, mm, ii, start
  real(kind=realtype) :: ovgm1, factk, pp, t, t2, scale
  real(kind=realtype) :: ppd, td, t2d, scaled
  intrinsic log
!
!      ******************************************************************
!      *                                                                *
!      * begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! determine the cp model used in the computation.
  select case  (cpmodel) 
  case (cpconstant) 
! abbreviate 1/(gamma -1) a bit easier.
    ovgm1 = one/(gammaconstant-one)
! loop over the number of elements of the array and compute
! the total energy.
    do i=1,kk
      eintd(i) = (ovgm1*pd(i)*rho(i)-ovgm1*p(i)*rhod(i))/rho(i)**2
      eint(i) = ovgm1*p(i)/rho(i)
    end do
! second step. correct the energy in case a turbulent kinetic
! energy is present.
    if (correctfork) then
      factk = ovgm1*(five*third-gammaconstant)
      do i=1,kk
        eintd(i) = eintd(i) - factk*kd(i)
        eint(i) = eint(i) - factk*k(i)
      end do
    end if
  case (cptempcurvefits) 
!        ================================================================
! cp as function of the temperature is given via curve fits.
! store a scale factor to compute the nondimensional
! internal energy.
    scaled = (rgasd*tref-rgas*trefd)/tref**2
    scale = rgas/tref
! loop over the number of elements of the array
    do i=1,kk
! compute the dimensional temperature.
      ppd = pd(i)
      pp = p(i)
      if (correctfork) then
        ppd = ppd - twothird*(rhod(i)*k(i)+rho(i)*kd(i))
        pp = pp - twothird*rho(i)*k(i)
      end if
      td = ((trefd*pp+tref*ppd)*rgas*rho(i)-tref*pp*(rgasd*rho(i)+rgas*&
&       rhod(i)))/(rgas*rho(i))**2
      t = tref*pp/(rgas*rho(i))
! determine the case we are having here.
      if (t .le. cptrange(0)) then
! temperature is less than the smallest temperature
! in the curve fits. use extrapolation using
! constant cv.
        eintd(i) = scaled*(cpeint(0)+cv0*(t-cptrange(0))) + scale*cv0*td
        eint(i) = scale*(cpeint(0)+cv0*(t-cptrange(0)))
      else if (t .ge. cptrange(cpnparts)) then
! temperature is larger than the largest temperature
! in the curve fits. use extrapolation using
! constant cv.
        eintd(i) = scaled*(cpeint(cpnparts)+cvn*(t-cptrange(cpnparts))) &
&         + scale*cvn*td
        eint(i) = scale*(cpeint(cpnparts)+cvn*(t-cptrange(cpnparts)))
      else
! temperature is in the curve fit range.
! first find the valid range.
        ii = cpnparts
        start = 1
interval:do 
! next guess for the interval.
          nn = start + ii/2
! determine the situation we are having here.
          if (t .gt. cptrange(nn)) then
! temperature is larger than the upper boundary of
! the current interval. update the lower boundary.
            start = nn + 1
            ii = ii - 1
          else if (t .ge. cptrange(nn-1)) then
            goto 100
          end if
! this is the correct range. exit the do-loop.
! modify ii for the next branch to search.
          ii = ii/2
        end do interval
! nn contains the correct curve fit interval.
! integrate cv to compute eint.
 100    eintd(i) = -td
        eint(i) = cptempfit(nn)%eint0 - t
        do ii=1,cptempfit(nn)%nterm
          if (cptempfit(nn)%exponents(ii) .eq. -1) then
            eintd(i) = eintd(i) + cptempfit(nn)%constants(ii)*td/t
            eint(i) = eint(i) + cptempfit(nn)%constants(ii)*log(t)
          else
            mm = cptempfit(nn)%exponents(ii) + 1
            if (t .gt. 0.0_8 .or. (t .lt. 0.0_8 .and. mm .eq. int(mm))) &
&           then
              t2d = mm*t**(mm-1)*td
            else if (t .eq. 0.0_8 .and. mm .eq. 1.0) then
              t2d = td
            else
              t2d = 0.0_8
            end if
            t2 = t**mm
            eintd(i) = eintd(i) + cptempfit(nn)%constants(ii)*t2d/mm
            eint(i) = eint(i) + cptempfit(nn)%constants(ii)*t2/mm
          end if
        end do
        eintd(i) = scaled*eint(i) + scale*eintd(i)
        eint(i) = scale*eint(i)
      end if
! add the turbulent energy if needed.
      if (correctfork) then
        eintd(i) = eintd(i) + kd(i)
        eint(i) = eint(i) + k(i)
      end if
    end do
  end select
end subroutine eintarray_d

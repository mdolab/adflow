   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          monitor.f90                                     *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-25-2003                                      *
   !      * Last modified: 10-29-2007                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   MODULE MONITOR_D
   !
   !      ******************************************************************
   !      *                                                                *
   !      * This module contains the variables to be monitored during the  *
   !      * convergence as well as the arrays to store the convergence.    *
   !      * The latter are only allocated by processor 0.                  *
   !      * The default variables to be monitored depend on the governing  *
   !      * equations to be solved.                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   USE CONSTANTS
   IMPLICIT NONE
   SAVE 
   !
   !      Parameters for the format to write the convergence to stdout.
   !
   INTEGER, PARAMETER :: fieldwidth=12
   INTEGER, PARAMETER :: decimalwidth=5
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Variables to compute the convergence info.                     *
   !      *                                                                *
   !      ******************************************************************
   !
   ! nMonSum: Number of monitoring variables for which the sum over
   !          all processors must be taken. Note that this is an
   !          integer, because of MPI.
   ! nMonMax: Number of monitoring variables for which the maximum
   !          over all processors must be taken. Note that this is
   !          an integer, because of MPI.
   ! nMon:    The sum of nmonSum and nmonMax
   INTEGER :: nmonsum, nmonmax, nmon
   ! monLoc(nMon):  Array for the local summation/maximum of the
   !                monitoring variables.
   ! monGlob(nMon): Idem, but for the global summation/maximum.
   ! monRef(nMon):  Idem, but for the reference values needed
   !                for an unsteady computation.
   ! MassFluxL, G   Massflux out of bcOutflowSubsonic  (eran-msf)
   REAL(kind=realtype), DIMENSION(:), ALLOCATABLE :: monloc
   REAL(kind=realtype), DIMENSION(:), ALLOCATABLE :: monglob
   REAL(kind=realtype), DIMENSION(:), ALLOCATABLE :: monref
   ! eran-msf
   REAL(kind=realtype) :: massfluxl, massfluxg
   ! monNames(nMon): The names of the variables to be monitored.
   CHARACTER(len=maxcgnsnamelen), DIMENSION(:), ALLOCATABLE :: monnames
   ! monMachOrHMax: Whether or not the maximum value of the Mach
   !                number and total enthalpy difference must be
   !                monitored and thus computed.
   ! showCPU:       Whether or not the CPU time must be shown
   !                in the output to screen.
   LOGICAL :: monmachorhmax
   LOGICAL :: showcpu
   !eran-CBD
   LOGICAL :: gencbdout
   !eran-CBD
   LOGICAL :: componentsbreakdown
   ! monMassSliding:  Whether or not to monitor the mass flow of
   !                  the sliding interfaces.
   ! monMassFamilies: Whether or not the mass flow of at least
   !                  one family must be monitored.
   LOGICAL :: monmasssliding
   LOGICAL :: monmassfamilies
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Variables to store the convergence info.                       *
   !      *                                                                *
   !      ******************************************************************
   !
   ! nIterOld: Number of iterations done by a previous computation,
   !           i.e. before the restart. This value is 0 when started
   !           from scratch. NiterOld is an integer, because of
   !           cgns.
   ! nIterCur: Current number of iterations. Also niterCur is an
   !           integer, because of cgns.
   INTEGER :: niterold, nitercur
   ! convArray(0:nIterMax,nsps,nmon): 3D array to store the
   !                                  convergence histories.
   REAL(kind=cgnsrealtype), DIMENSION(:, :, :), ALLOCATABLE :: convarray
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Variables to store the time accurate history.                  *
   !      * Only allocated for a time accurate computation.                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! nTimeStepsRestart:   Number of time steps taken in an earlier
   !                      unsteady computation from which a restart
   !                      is performed.
   ! timeStepUnsteady:    The current unsteady time step number;
   !                      restart is not taken into account.
   ! timeUnsteady:        Amount of physical time of the current
   !                      simulation; only relevant in unsteady mode.
   ! timeUnsteadyRestart: Amount of physical time from a previous
   !                      simulation from which a restart is
   !                      performed.
   INTEGER(kind=inttype) :: ntimestepsrestart, timestepunsteady
   REAL(kind=realtype) :: timeunsteady, timeunsteadyrestart
   ! timeArray(nTimeMax):          Array to store the values of the
   !                               time at every time step.
   ! timeDataArray(nTimeMax,nMon): 2D array to store the variables
   !                               to be monitored at every time
   !                               step. No need to store a spectral
   !                               index here.
   REAL(kind=cgnsrealtype), DIMENSION(:), ALLOCATABLE :: timearray
   REAL(kind=cgnsrealtype), DIMENSION(:, :), ALLOCATABLE :: timedataarray
   ! writeGrid:    Whether or not a grid file must be written.
   ! writeVolume:  Idem for a volume solution file.
   ! writeSurface: Idem for a surface solution file.
   LOGICAL :: writegrid, writevolume, writesurface
   ! coeffConvCheck: Whether or not to use the coefficients for the
   !                 convergence check in steady,Time-spectral
   LOGICAL :: coeffconvcheck
   ! convergenceQuality: information about quality of convergence 
   ! as the program exits. Set by routine convergenceInfo:
   !
   !  convergenceQuality = 0   No convergence 
   !  convergenceQuality = 2   Coefficient-convergence X100
   !  convergenceQuality = 4   Coefficient-convergence X10
   !  convergenceQuality = 6   Coefficient-convergence X1
   !  convergenceQuality = 10  residue convergence
   ! eran-coeffConv
   INTEGER :: convergencequality
   END MODULE MONITOR_D

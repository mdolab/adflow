   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of bcturbwall in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *bvtj1 *bvtj2 *bvtk1 *bvtk2
   !                *bvti1 *bvti2
   !   with respect to varying inputs: *bvtj1 *bvtj2 *w *rlv *bvtk1
   !                *bvtk2 *bvti1 *bvti2
   !   Plus diff mem management of: bvtj1:in bvtj2:in w:in rlv:in
   !                bvtk1:in bvtk2:in bvti1:in bvti2:in bcdata:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          bcTurbWall.F90                                  *
   !      * Author:        Georgi Kalitzin, Edwin van der Weide            *
   !      * Starting date: 06-26-2003                                      *
   !      * Last modified: 06-12-2005                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE BCTURBWALL_D(nn)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * bcTurbWall applies the implicit treatment of the viscous       *
   !      * wall boundary condition for the turbulence model used to the   *
   !      * given subface nn.                                              *
   !      * It is assumed that the pointers in blockPointers are           *
   !      * already set to the correct block.                              *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_D
   USE BCTYPES
   USE FLOWVARREFSTATE
   USE INPUTPHYSICS
   USE CONSTANTS
   USE PARAMTURB
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   INTEGER(kind=inttype), INTENT(IN) :: nn
   !
   !      Local variables.
   !
   INTEGER(kind=inttype) :: i, j, ii, jj, iimax, jjmax
   REAL(kind=realtype) :: tmpd, tmpe, tmpf, nu
   REAL(kind=realtype) :: nud
   REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: bmt
   REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: bvt, ww2
   REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv2, dd2wall
   INTRINSIC MIN
   INTRINSIC MAX
   INTEGER(kind=inttype) :: y12
   INTEGER(kind=inttype) :: y11
   INTEGER(kind=inttype) :: y10
   INTEGER(kind=inttype) :: y9
   INTEGER(kind=inttype) :: y8
   INTEGER(kind=inttype) :: y7
   INTEGER(kind=inttype) :: y6
   INTEGER(kind=inttype) :: y5
   INTEGER(kind=inttype) :: y4
   INTEGER(kind=inttype) :: y3
   INTEGER(kind=inttype) :: y2
   INTEGER(kind=inttype) :: y1
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Determine the turbulence model used and loop over the faces
   ! of the subface and set the values of bmt and bvt for an
   ! implicit treatment.
   SELECT CASE  (turbmodel) 
   CASE (spalartallmaras, spalartallmarasedwards) 
   ! Spalart-allmaras type of model. Value at the wall is zero,
   ! so simply negate the internal value.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmti1(i, j, itu1, itu1) = one
   END DO
   END DO
   CASE (imax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmti2(i, j, itu1, itu1) = one
   END DO
   END DO
   CASE (jmin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtj1(i, j, itu1, itu1) = one
   END DO
   END DO
   CASE (jmax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtj2(i, j, itu1, itu1) = one
   END DO
   END DO
   CASE (kmin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtk1(i, j, itu1, itu1) = one
   END DO
   END DO
   CASE (kmax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtk2(i, j, itu1, itu1) = one
   END DO
   END DO
   END SELECT
   CASE (komegawilcox, komegamodified, mentersst) 
   !        ================================================================
   ! K-omega type of models. K is zero on the wall and thus the
   ! halo value is the negative of the first internal cell.
   ! For omega the situation is a bit more complicated.
   ! Theoretically omega is infinity, but it is set to a large
   ! value, see menter's paper. The halo value is constructed
   ! such that the wall value is correct. Make sure that i and j
   ! are limited to physical dimensions of the face for the wall
   ! distance. Due to the usage of the dd2Wall pointer and the
   ! fact that the original d2Wall array starts at 2, there is
   ! an offset of -1 present in dd2Wall.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   iimax = jl
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y1 = jjmax
   ELSE
   y1 = j
   END IF
   IF (2 .LT. y1) THEN
   jj = y1
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y2 = iimax
   ELSE
   y2 = i
   END IF
   IF (2 .LT. y2) THEN
   ii = y2
   ELSE
   ii = 2
   END IF
   nud = (rlvd(2, i, j)*w(2, i, j, irho)-rlv(2, i, j)*wd(2, i, j&
   &           , irho))/w(2, i, j, irho)**2
   nu = rlv(2, i, j)/w(2, i, j, irho)
   tmpd = one/(rkwbeta1*d2wall(2, ii, jj)**2)
   bmti1(i, j, itu1, itu1) = one
   bmti1(i, j, itu2, itu2) = one
   bvti1d(i, j, itu2) = two*60.0_realType*tmpd*nud
   bvti1(i, j, itu2) = two*60.0_realType*nu*tmpd
   END DO
   END DO
   CASE (imax) 
   iimax = jl
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y3 = jjmax
   ELSE
   y3 = j
   END IF
   IF (2 .LT. y3) THEN
   jj = y3
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y4 = iimax
   ELSE
   y4 = i
   END IF
   IF (2 .LT. y4) THEN
   ii = y4
   ELSE
   ii = 2
   END IF
   nud = (rlvd(jl, i, j)*w(il, i, j, irho)-rlv(jl, i, j)*wd(il, i&
   &           , j, irho))/w(il, i, j, irho)**2
   nu = rlv(jl, i, j)/w(il, i, j, irho)
   tmpd = one/(rkwbeta1*d2wall(il, ii, jj)**2)
   bmti2(i, j, itu1, itu1) = one
   bmti2(i, j, itu2, itu2) = one
   bvti2d(i, j, itu2) = two*60.0_realType*tmpd*nud
   bvti2(i, j, itu2) = two*60.0_realType*nu*tmpd
   END DO
   END DO
   CASE (jmin) 
   iimax = il
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y5 = jjmax
   ELSE
   y5 = j
   END IF
   IF (2 .LT. y5) THEN
   jj = y5
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y6 = iimax
   ELSE
   y6 = i
   END IF
   IF (2 .LT. y6) THEN
   ii = y6
   ELSE
   ii = 2
   END IF
   nud = (rlvd(i, 2, j)*w(i, 2, j, irho)-rlv(i, 2, j)*wd(i, 2, j&
   &           , irho))/w(i, 2, j, irho)**2
   nu = rlv(i, 2, j)/w(i, 2, j, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, 2, jj)**2)
   bmtj1(i, j, itu1, itu1) = one
   bmtj1(i, j, itu2, itu2) = one
   bvtj1d(i, j, itu2) = two*60.0_realType*tmpd*nud
   bvtj1(i, j, itu2) = two*60.0_realType*nu*tmpd
   END DO
   END DO
   CASE (jmax) 
   iimax = il
   jjmax = kl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y7 = jjmax
   ELSE
   y7 = j
   END IF
   IF (2 .LT. y7) THEN
   jj = y7
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y8 = iimax
   ELSE
   y8 = i
   END IF
   IF (2 .LT. y8) THEN
   ii = y8
   ELSE
   ii = 2
   END IF
   nud = (rlvd(i, jl, j)*w(i, jl, j, irho)-rlv(i, jl, j)*wd(i, jl&
   &           , j, irho))/w(i, jl, j, irho)**2
   nu = rlv(i, jl, j)/w(i, jl, j, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, jl, jj)**2)
   bmtj2(i, j, itu1, itu1) = one
   bmtj2(i, j, itu2, itu2) = one
   bvtj2d(i, j, itu2) = two*60.0_realType*tmpd*nud
   bvtj2(i, j, itu2) = two*60.0_realType*nu*tmpd
   END DO
   END DO
   CASE (kmin) 
   iimax = il
   jjmax = jl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y9 = jjmax
   ELSE
   y9 = j
   END IF
   IF (2 .LT. y9) THEN
   jj = y9
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y10 = iimax
   ELSE
   y10 = i
   END IF
   IF (2 .LT. y10) THEN
   ii = y10
   ELSE
   ii = 2
   END IF
   nud = (rlvd(i, j, 2)*w(i, j, 2, irho)-rlv(i, j, 2)*wd(i, j, 2&
   &           , irho))/w(i, j, 2, irho)**2
   nu = rlv(i, j, 2)/w(i, j, 2, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, jj, 2)**2)
   bmtk1(i, j, itu1, itu1) = one
   bmtk1(i, j, itu2, itu2) = one
   bvtk1d(i, j, itu2) = two*60.0_realType*tmpd*nud
   bvtk1(i, j, itu2) = two*60.0_realType*nu*tmpd
   END DO
   END DO
   CASE (kmax) 
   iimax = il
   jjmax = jl
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   IF (j .GT. jjmax) THEN
   y11 = jjmax
   ELSE
   y11 = j
   END IF
   IF (2 .LT. y11) THEN
   jj = y11
   ELSE
   jj = 2
   END IF
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   IF (i .GT. iimax) THEN
   y12 = iimax
   ELSE
   y12 = i
   END IF
   IF (2 .LT. y12) THEN
   ii = y12
   ELSE
   ii = 2
   END IF
   nud = (rlvd(i, j, kl)*w(i, j, kl, irho)-rlv(i, j, kl)*wd(i, j&
   &           , kl, irho))/w(i, j, kl, irho)**2
   nu = rlv(i, j, kl)/w(i, j, kl, irho)
   tmpd = one/(rkwbeta1*d2wall(ii, jj, kl)**2)
   bmtk2(i, j, itu1, itu1) = one
   bmtk2(i, j, itu2, itu2) = one
   bvtk2d(i, j, itu2) = two*60.0_realType*tmpd*nud
   bvtk2(i, j, itu2) = two*60.0_realType*nu*tmpd
   END DO
   END DO
   END SELECT
   CASE (ktau) 
   !        ================================================================
   ! K-tau model. Both k and tau are zero at the wall, so the
   ! negative value of the internal cell is taken for the halo.
   SELECT CASE  (bcfaceid(nn)) 
   CASE (imin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmti1(i, j, itu1, itu1) = one
   bmti1(i, j, itu2, itu2) = one
   END DO
   END DO
   CASE (imax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmti2(i, j, itu1, itu1) = one
   bmti2(i, j, itu2, itu2) = one
   END DO
   END DO
   CASE (jmin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtj1(i, j, itu1, itu1) = one
   bmtj1(i, j, itu2, itu2) = one
   END DO
   END DO
   CASE (jmax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtj2(i, j, itu1, itu1) = one
   bmtj2(i, j, itu2, itu2) = one
   END DO
   END DO
   CASE (kmin) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtk1(i, j, itu1, itu1) = one
   bmtk1(i, j, itu2, itu2) = one
   END DO
   END DO
   CASE (kmax) 
   DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
   DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
   bmtk2(i, j, itu1, itu1) = one
   bmtk2(i, j, itu2, itu2) = one
   END DO
   END DO
   END SELECT
   CASE DEFAULT
   !        ================================================================
   CALL TERMINATE('bcTurbWall', &
   &               'Turbulence model not implemented yet')
   END SELECT
   END SUBROUTINE BCTURBWALL_D

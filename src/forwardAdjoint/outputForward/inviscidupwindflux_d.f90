   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of inviscidupwindflux in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: *fw
   !   with respect to varying inputs: *p *gamma *w *si *sj *sk
   !   Plus diff mem management of: p:in gamma:in w:in si:in sj:in
   !                sk:in fw:in
   !
   !      ******************************************************************
   !      *                                                                *
   !      * File:          inviscidUpwindFlux.f90                          *
   !      * Author:        Edwin van der Weide                             *
   !      * Starting date: 03-25-2003                                      *
   !      * Last modified: 10-29-2007                                      *
   !      *                                                                *
   !      ******************************************************************
   !
   SUBROUTINE INVISCIDUPWINDFLUX_D(finegrid)
   !
   !      ******************************************************************
   !      *                                                                *
   !      * inviscidUpwindFlux computes the artificial dissipation part of *
   !      * the Euler fluxes by means of an approximate solution of the 1D *
   !      * Riemann problem on the face. For first order schemes,          *
   !      * fineGrid == .false., the states in the cells are assumed to    *
   !      * be constant; for the second order schemes on the fine grid a   *
   !      * nonlinear reconstruction of the left and right state is done   *
   !      * for which several options exist.                               *
   !      * It is assumed that the pointers in blockPointers already       *
   !      * point to the correct block.                                    *
   !      *                                                                *
   !      ******************************************************************
   !
   USE BLOCKPOINTERS_D
   USE CGNSGRID
   USE CONSTANTS
   USE INPUTDISCRETIZATION
   USE INPUTPHYSICS
   USE FLOWVARREFSTATE
   USE ITERATION
   IMPLICIT NONE
   !
   !      Subroutine arguments.
   !
   LOGICAL, INTENT(IN) :: finegrid
   !
   !      Local variables.
   !
   INTEGER(kind=portype) :: por
   INTEGER(kind=inttype) :: nwint
   INTEGER(kind=inttype) :: i, j, k, ind
   INTEGER(kind=inttype) :: limused, riemannused
   REAL(kind=realtype) :: sx, sy, sz, omk, opk, sfil, gammaface
   REAL(kind=realtype) :: sxd, syd, szd, gammafaced
   REAL(kind=realtype) :: factminmod, sface
   REAL(kind=realtype), DIMENSION(nw) :: left, right
   REAL(kind=realtype), DIMENSION(nw) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(nw) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(nw) :: du1d, du2d, du3d
   REAL(kind=realtype), DIMENSION(nwf) :: flux
   REAL(kind=realtype), DIMENSION(nwf) :: fluxd
   LOGICAL :: firstorderk, correctfork, rotationalperiodic
   INTRINSIC ABS
   INTRINSIC ASSOCIATED
   INTRINSIC MAX
   REAL(kind=realtype) :: abs0
   REAL(kind=realtype) :: max1
   IF (rfil .GE. 0.) THEN
   abs0 = rfil
   ELSE
   abs0 = -rfil
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Begin execution                                                *
   !      *                                                                *
   !      ******************************************************************
   !
   ! Check if rFil == 0. If so, the dissipative flux needs not to
   ! be computed.
   IF (abs0 .LT. thresholdreal) THEN
   fwd = 0.0_8
   RETURN
   ELSE
   ! Check if the formulation for rotational periodic problems
   ! must be used.
   IF (ASSOCIATED(rotmatrixi)) THEN
   rotationalperiodic = .true.
   ELSE
   rotationalperiodic = .false.
   END IF
   ! Initialize the dissipative residual to a certain times,
   ! possibly zero, the previously stored value. Owned cells
   ! only, because the halo values do not matter.
   sfil = one - rfil
   DO k=2,kl
   DO j=2,jl
   DO i=2,il
   fwd(i, j, k, irho) = 0.0_8
   fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
   fwd(i, j, k, imx) = 0.0_8
   fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
   fwd(i, j, k, imy) = 0.0_8
   fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
   fwd(i, j, k, imz) = 0.0_8
   fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
   fwd(i, j, k, irhoe) = 0.0_8
   fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
   END DO
   END DO
   END DO
   ! Determine whether or not the total energy must be corrected
   ! for the presence of the turbulent kinetic energy.
   IF (kpresent) THEN
   IF (currentlevel .EQ. groundlevel .OR. turbcoupled) THEN
   correctfork = .true.
   ELSE
   correctfork = .false.
   END IF
   ELSE
   correctfork = .false.
   END IF
   IF (1.e-10_realType .LT. one - kappacoef) THEN
   max1 = one - kappacoef
   ELSE
   max1 = 1.e-10_realType
   END IF
   ! Compute the factor used in the minmod limiter.
   factminmod = (three-kappacoef)/max1
   ! Determine the limiter scheme to be used. On the fine grid the
   ! user specified scheme is used; on the coarse grid a first order
   ! scheme is computed.
   limused = firstorder
   IF (finegrid) limused = limiter
   ! Lumped diss is true for doing approx PC
   IF (lumpeddiss) limused = firstorder
   ! Determine the riemann solver which must be used.
   riemannused = riemanncoarse
   IF (finegrid) riemannused = riemann
   ! Store 1-kappa and 1+kappa a bit easier and multiply it by 0.25.
   omk = fourth*(one-kappacoef)
   opk = fourth*(one+kappacoef)
   ! Initialize sFace to zero. This value will be used if the
   ! block is not moving.
   sface = zero
   ! Set the number of variables to be interpolated depending
   ! whether or not a k-equation is present. If a k-equation is
   ! present also set the logical firstOrderK. This indicates
   ! whether or not only a first order approximation is to be used
   ! for the turbulent kinetic energy.
   IF (correctfork) THEN
   IF (orderturb .EQ. firstorder) THEN
   nwint = nwf
   firstorderk = .true.
   ELSE
   nwint = itu1
   firstorderk = .false.
   END IF
   ELSE
   nwint = nwf
   firstorderk = .false.
   END IF
   !
   !      ******************************************************************
   !      *                                                                *
   !      * Flux computation. A distinction is made between first and      *
   !      * second order schemes to avoid the overhead for the first order *
   !      * scheme.                                                        *
   !      *                                                                *
   !      ******************************************************************
   !
   IF (limused .EQ. firstorder) THEN
   fwd = 0.0_8
   fluxd = 0.0_8
   leftd = 0.0_8
   rightd = 0.0_8
   !
   !        ****************************************************************
   !        *                                                              *
   !        * First order reconstruction. The states in the cells are      *
   !        * constant. The left and right states are constructed easily.  *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   DO k=2,kl
   DO j=2,jl
   DO i=1,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sxd = sid(i, j, k, 1)
   sx = si(i, j, k, 1)
   syd = sid(i, j, k, 2)
   sy = si(i, j, k, 2)
   szd = sid(i, j, k, 3)
   sz = si(i, j, k, 3)
   por = pori(i, j, k)
   IF (addgridvelocities) sface = sfacei(i, j, k)
   ! Determine the left and right state.
   leftd(irho) = wd(i, j, k, irho)
   left(irho) = w(i, j, k, irho)
   leftd(ivx) = wd(i, j, k, ivx)
   left(ivx) = w(i, j, k, ivx)
   leftd(ivy) = wd(i, j, k, ivy)
   left(ivy) = w(i, j, k, ivy)
   leftd(ivz) = wd(i, j, k, ivz)
   left(ivz) = w(i, j, k, ivz)
   leftd(irhoe) = pd(i, j, k)
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   leftd(itu1) = wd(i, j, k, itu1)
   left(itu1) = w(i, j, k, itu1)
   END IF
   rightd(irho) = wd(i+1, j, k, irho)
   right(irho) = w(i+1, j, k, irho)
   rightd(ivx) = wd(i+1, j, k, ivx)
   right(ivx) = w(i+1, j, k, ivx)
   rightd(ivy) = wd(i+1, j, k, ivy)
   right(ivy) = w(i+1, j, k, ivy)
   rightd(ivz) = wd(i+1, j, k, ivz)
   right(ivz) = w(i+1, j, k, ivz)
   rightd(irhoe) = pd(i+1, j, k)
   right(irhoe) = p(i+1, j, k)
   IF (correctfork) THEN
   rightd(itu1) = wd(i+1, j, k, itu1)
   right(itu1) = w(i+1, j, k, itu1)
   END IF
   ! Compute the value of gamma on the face. Take an
   ! arithmetic average of the two states.
   gammafaced = half*(gammad(i, j, k)+gammad(i+1, j, k))
   gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
   ! Compute the dissipative flux across the interface.
   CALL RIEMANNFLUX_D(left, leftd, right, rightd, flux, fluxd)
   ! And scatter it to the left and right.
   fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
   fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
   fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
   fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
   fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
   fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
   fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
   fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
   fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) - fluxd(irho)
   fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
   fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) - fluxd(imx)
   fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
   fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) - fluxd(imy)
   fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
   fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) - fluxd(imz)
   fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
   fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) - fluxd(irhoe)
   fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in j-direction.
   DO k=2,kl
   DO j=1,jl
   DO i=2,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sxd = sjd(i, j, k, 1)
   sx = sj(i, j, k, 1)
   syd = sjd(i, j, k, 2)
   sy = sj(i, j, k, 2)
   szd = sjd(i, j, k, 3)
   sz = sj(i, j, k, 3)
   por = porj(i, j, k)
   IF (addgridvelocities) sface = sfacej(i, j, k)
   ! Determine the left and right state.
   leftd(irho) = wd(i, j, k, irho)
   left(irho) = w(i, j, k, irho)
   leftd(ivx) = wd(i, j, k, ivx)
   left(ivx) = w(i, j, k, ivx)
   leftd(ivy) = wd(i, j, k, ivy)
   left(ivy) = w(i, j, k, ivy)
   leftd(ivz) = wd(i, j, k, ivz)
   left(ivz) = w(i, j, k, ivz)
   leftd(irhoe) = pd(i, j, k)
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   leftd(itu1) = wd(i, j, k, itu1)
   left(itu1) = w(i, j, k, itu1)
   END IF
   rightd(irho) = wd(i, j+1, k, irho)
   right(irho) = w(i, j+1, k, irho)
   rightd(ivx) = wd(i, j+1, k, ivx)
   right(ivx) = w(i, j+1, k, ivx)
   rightd(ivy) = wd(i, j+1, k, ivy)
   right(ivy) = w(i, j+1, k, ivy)
   rightd(ivz) = wd(i, j+1, k, ivz)
   right(ivz) = w(i, j+1, k, ivz)
   rightd(irhoe) = pd(i, j+1, k)
   right(irhoe) = p(i, j+1, k)
   IF (correctfork) THEN
   rightd(itu1) = wd(i, j+1, k, itu1)
   right(itu1) = w(i, j+1, k, itu1)
   END IF
   ! Compute the value of gamma on the face. Take an
   ! arithmetic average of the two states.
   gammafaced = half*(gammad(i, j, k)+gammad(i, j+1, k))
   gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
   ! Compute the dissipative flux across the interface.
   CALL RIEMANNFLUX_D(left, leftd, right, rightd, flux, fluxd)
   ! And scatter it to the left and right.
   fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
   fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
   fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
   fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
   fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
   fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
   fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
   fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
   fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) - fluxd(irho)
   fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
   fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) - fluxd(imx)
   fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
   fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) - fluxd(imy)
   fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
   fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) - fluxd(imz)
   fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
   fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) - fluxd(irhoe)
   fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in k-direction.
   DO k=1,kl
   DO j=2,jl
   DO i=2,il
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sxd = skd(i, j, k, 1)
   sx = sk(i, j, k, 1)
   syd = skd(i, j, k, 2)
   sy = sk(i, j, k, 2)
   szd = skd(i, j, k, 3)
   sz = sk(i, j, k, 3)
   por = pork(i, j, k)
   IF (addgridvelocities) sface = sfacek(i, j, k)
   ! Determine the left and right state.
   leftd(irho) = wd(i, j, k, irho)
   left(irho) = w(i, j, k, irho)
   leftd(ivx) = wd(i, j, k, ivx)
   left(ivx) = w(i, j, k, ivx)
   leftd(ivy) = wd(i, j, k, ivy)
   left(ivy) = w(i, j, k, ivy)
   leftd(ivz) = wd(i, j, k, ivz)
   left(ivz) = w(i, j, k, ivz)
   leftd(irhoe) = pd(i, j, k)
   left(irhoe) = p(i, j, k)
   IF (correctfork) THEN
   leftd(itu1) = wd(i, j, k, itu1)
   left(itu1) = w(i, j, k, itu1)
   END IF
   rightd(irho) = wd(i, j, k+1, irho)
   right(irho) = w(i, j, k+1, irho)
   rightd(ivx) = wd(i, j, k+1, ivx)
   right(ivx) = w(i, j, k+1, ivx)
   rightd(ivy) = wd(i, j, k+1, ivy)
   right(ivy) = w(i, j, k+1, ivy)
   rightd(ivz) = wd(i, j, k+1, ivz)
   right(ivz) = w(i, j, k+1, ivz)
   rightd(irhoe) = pd(i, j, k+1)
   right(irhoe) = p(i, j, k+1)
   IF (correctfork) THEN
   rightd(itu1) = wd(i, j, k+1, itu1)
   right(itu1) = w(i, j, k+1, itu1)
   END IF
   ! Compute the value of gamma on the face. Take an
   ! arithmetic average of the two states.
   gammafaced = half*(gammad(i, j, k)+gammad(i, j, k+1))
   gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
   ! Compute the dissipative flux across the interface.
   CALL RIEMANNFLUX_D(left, leftd, right, rightd, flux, fluxd)
   ! And scatter it the left and right.
   fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
   fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
   fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
   fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
   fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
   fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
   fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
   fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
   fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) - fluxd(irho)
   fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
   fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) - fluxd(imx)
   fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
   fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) - fluxd(imy)
   fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
   fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) - fluxd(imz)
   fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
   fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) - fluxd(irhoe)
   fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
   END DO
   END DO
   END DO
   ELSE
   fwd = 0.0_8
   fluxd = 0.0_8
   leftd = 0.0_8
   rightd = 0.0_8
   du1d = 0.0_8
   du2d = 0.0_8
   du3d = 0.0_8
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   !      ==================================================================
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Second order reconstruction of the left and right state.     *
   !        * The three differences used in the, possibly nonlinear,       *
   !        * interpolation are constructed here; the actual left and      *
   !        * right states, or at least the differences from the first     *
   !        * order interpolation, are computed in the subroutine          *
   !        * leftRightState.                                              *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Fluxes in the i-direction.
   DO k=2,kl
   DO j=2,jl
   DO i=1,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1d(irho) = wd(i, j, k, irho) - wd(i-1, j, k, irho)
   du1(irho) = w(i, j, k, irho) - w(i-1, j, k, irho)
   du2d(irho) = wd(i+1, j, k, irho) - wd(i, j, k, irho)
   du2(irho) = w(i+1, j, k, irho) - w(i, j, k, irho)
   du3d(irho) = wd(i+2, j, k, irho) - wd(i+1, j, k, irho)
   du3(irho) = w(i+2, j, k, irho) - w(i+1, j, k, irho)
   du1d(ivx) = wd(i, j, k, ivx) - wd(i-1, j, k, ivx)
   du1(ivx) = w(i, j, k, ivx) - w(i-1, j, k, ivx)
   du2d(ivx) = wd(i+1, j, k, ivx) - wd(i, j, k, ivx)
   du2(ivx) = w(i+1, j, k, ivx) - w(i, j, k, ivx)
   du3d(ivx) = wd(i+2, j, k, ivx) - wd(i+1, j, k, ivx)
   du3(ivx) = w(i+2, j, k, ivx) - w(i+1, j, k, ivx)
   du1d(ivy) = wd(i, j, k, ivy) - wd(i-1, j, k, ivy)
   du1(ivy) = w(i, j, k, ivy) - w(i-1, j, k, ivy)
   du2d(ivy) = wd(i+1, j, k, ivy) - wd(i, j, k, ivy)
   du2(ivy) = w(i+1, j, k, ivy) - w(i, j, k, ivy)
   du3d(ivy) = wd(i+2, j, k, ivy) - wd(i+1, j, k, ivy)
   du3(ivy) = w(i+2, j, k, ivy) - w(i+1, j, k, ivy)
   du1d(ivz) = wd(i, j, k, ivz) - wd(i-1, j, k, ivz)
   du1(ivz) = w(i, j, k, ivz) - w(i-1, j, k, ivz)
   du2d(ivz) = wd(i+1, j, k, ivz) - wd(i, j, k, ivz)
   du2(ivz) = w(i+1, j, k, ivz) - w(i, j, k, ivz)
   du3d(ivz) = wd(i+2, j, k, ivz) - wd(i+1, j, k, ivz)
   du3(ivz) = w(i+2, j, k, ivz) - w(i+1, j, k, ivz)
   du1d(irhoe) = pd(i, j, k) - pd(i-1, j, k)
   du1(irhoe) = p(i, j, k) - p(i-1, j, k)
   du2d(irhoe) = pd(i+1, j, k) - pd(i, j, k)
   du2(irhoe) = p(i+1, j, k) - p(i, j, k)
   du3d(irhoe) = pd(i+2, j, k) - pd(i+1, j, k)
   du3(irhoe) = p(i+2, j, k) - p(i+1, j, k)
   IF (correctfork) THEN
   du1d(itu1) = wd(i, j, k, itu1) - wd(i-1, j, k, itu1)
   du1(itu1) = w(i, j, k, itu1) - w(i-1, j, k, itu1)
   du2d(itu1) = wd(i+1, j, k, itu1) - wd(i, j, k, itu1)
   du2(itu1) = w(i+1, j, k, itu1) - w(i, j, k, itu1)
   du3d(itu1) = wd(i+2, j, k, itu1) - wd(i+1, j, k, itu1)
   du3(itu1) = w(i+2, j, k, itu1) - w(i+1, j, k, itu1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATE_D(du1, du1d, du2, du2d, du3, du3d, &
   &                           rotmatrixi, left, leftd, right, rightd)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   leftd(irho) = leftd(irho) + wd(i, j, k, irho)
   left(irho) = left(irho) + w(i, j, k, irho)
   leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
   left(irhoe) = left(irhoe) + p(i, j, k)
   rightd(irho) = rightd(irho) + wd(i+1, j, k, irho)
   right(irho) = right(irho) + w(i+1, j, k, irho)
   rightd(ivx) = rightd(ivx) + wd(i+1, j, k, ivx)
   right(ivx) = right(ivx) + w(i+1, j, k, ivx)
   rightd(ivy) = rightd(ivy) + wd(i+1, j, k, ivy)
   right(ivy) = right(ivy) + w(i+1, j, k, ivy)
   rightd(ivz) = rightd(ivz) + wd(i+1, j, k, ivz)
   right(ivz) = right(ivz) + w(i+1, j, k, ivz)
   rightd(irhoe) = rightd(irhoe) + pd(i+1, j, k)
   right(irhoe) = right(irhoe) + p(i+1, j, k)
   IF (correctfork) THEN
   leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   rightd(itu1) = rightd(itu1) + wd(i+1, j, k, itu1)
   right(itu1) = right(itu1) + w(i+1, j, k, itu1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sxd = sid(i, j, k, 1)
   sx = si(i, j, k, 1)
   syd = sid(i, j, k, 2)
   sy = si(i, j, k, 2)
   szd = sid(i, j, k, 3)
   sz = si(i, j, k, 3)
   por = pori(i, j, k)
   IF (addgridvelocities) sface = sfacei(i, j, k)
   ! Compute the value of gamma on the face. Take an
   ! arithmetic average of the two states.
   gammafaced = half*(gammad(i, j, k)+gammad(i+1, j, k))
   gammaface = half*(gamma(i, j, k)+gamma(i+1, j, k))
   ! Compute the dissipative flux across the interface.
   CALL RIEMANNFLUX_D(left, leftd, right, rightd, flux, fluxd)
   ! And scatter it to the left and right.
   fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
   fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
   fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
   fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
   fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
   fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
   fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
   fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
   fwd(i+1, j, k, irho) = fwd(i+1, j, k, irho) - fluxd(irho)
   fw(i+1, j, k, irho) = fw(i+1, j, k, irho) - flux(irho)
   fwd(i+1, j, k, imx) = fwd(i+1, j, k, imx) - fluxd(imx)
   fw(i+1, j, k, imx) = fw(i+1, j, k, imx) - flux(imx)
   fwd(i+1, j, k, imy) = fwd(i+1, j, k, imy) - fluxd(imy)
   fw(i+1, j, k, imy) = fw(i+1, j, k, imy) - flux(imy)
   fwd(i+1, j, k, imz) = fwd(i+1, j, k, imz) - fluxd(imz)
   fw(i+1, j, k, imz) = fw(i+1, j, k, imz) - flux(imz)
   fwd(i+1, j, k, irhoe) = fwd(i+1, j, k, irhoe) - fluxd(irhoe)
   fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) - flux(irhoe)
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in the j-direction.
   DO k=2,kl
   DO j=1,jl
   DO i=2,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1d(irho) = wd(i, j, k, irho) - wd(i, j-1, k, irho)
   du1(irho) = w(i, j, k, irho) - w(i, j-1, k, irho)
   du2d(irho) = wd(i, j+1, k, irho) - wd(i, j, k, irho)
   du2(irho) = w(i, j+1, k, irho) - w(i, j, k, irho)
   du3d(irho) = wd(i, j+2, k, irho) - wd(i, j+1, k, irho)
   du3(irho) = w(i, j+2, k, irho) - w(i, j+1, k, irho)
   du1d(ivx) = wd(i, j, k, ivx) - wd(i, j-1, k, ivx)
   du1(ivx) = w(i, j, k, ivx) - w(i, j-1, k, ivx)
   du2d(ivx) = wd(i, j+1, k, ivx) - wd(i, j, k, ivx)
   du2(ivx) = w(i, j+1, k, ivx) - w(i, j, k, ivx)
   du3d(ivx) = wd(i, j+2, k, ivx) - wd(i, j+1, k, ivx)
   du3(ivx) = w(i, j+2, k, ivx) - w(i, j+1, k, ivx)
   du1d(ivy) = wd(i, j, k, ivy) - wd(i, j-1, k, ivy)
   du1(ivy) = w(i, j, k, ivy) - w(i, j-1, k, ivy)
   du2d(ivy) = wd(i, j+1, k, ivy) - wd(i, j, k, ivy)
   du2(ivy) = w(i, j+1, k, ivy) - w(i, j, k, ivy)
   du3d(ivy) = wd(i, j+2, k, ivy) - wd(i, j+1, k, ivy)
   du3(ivy) = w(i, j+2, k, ivy) - w(i, j+1, k, ivy)
   du1d(ivz) = wd(i, j, k, ivz) - wd(i, j-1, k, ivz)
   du1(ivz) = w(i, j, k, ivz) - w(i, j-1, k, ivz)
   du2d(ivz) = wd(i, j+1, k, ivz) - wd(i, j, k, ivz)
   du2(ivz) = w(i, j+1, k, ivz) - w(i, j, k, ivz)
   du3d(ivz) = wd(i, j+2, k, ivz) - wd(i, j+1, k, ivz)
   du3(ivz) = w(i, j+2, k, ivz) - w(i, j+1, k, ivz)
   du1d(irhoe) = pd(i, j, k) - pd(i, j-1, k)
   du1(irhoe) = p(i, j, k) - p(i, j-1, k)
   du2d(irhoe) = pd(i, j+1, k) - pd(i, j, k)
   du2(irhoe) = p(i, j+1, k) - p(i, j, k)
   du3d(irhoe) = pd(i, j+2, k) - pd(i, j+1, k)
   du3(irhoe) = p(i, j+2, k) - p(i, j+1, k)
   IF (correctfork) THEN
   du1d(itu1) = wd(i, j, k, itu1) - wd(i, j-1, k, itu1)
   du1(itu1) = w(i, j, k, itu1) - w(i, j-1, k, itu1)
   du2d(itu1) = wd(i, j+1, k, itu1) - wd(i, j, k, itu1)
   du2(itu1) = w(i, j+1, k, itu1) - w(i, j, k, itu1)
   du3d(itu1) = wd(i, j+2, k, itu1) - wd(i, j+1, k, itu1)
   du3(itu1) = w(i, j+2, k, itu1) - w(i, j+1, k, itu1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATE_D(du1, du1d, du2, du2d, du3, du3d, &
   &                           rotmatrixj, left, leftd, right, rightd)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   leftd(irho) = leftd(irho) + wd(i, j, k, irho)
   left(irho) = left(irho) + w(i, j, k, irho)
   leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
   left(irhoe) = left(irhoe) + p(i, j, k)
   rightd(irho) = rightd(irho) + wd(i, j+1, k, irho)
   right(irho) = right(irho) + w(i, j+1, k, irho)
   rightd(ivx) = rightd(ivx) + wd(i, j+1, k, ivx)
   right(ivx) = right(ivx) + w(i, j+1, k, ivx)
   rightd(ivy) = rightd(ivy) + wd(i, j+1, k, ivy)
   right(ivy) = right(ivy) + w(i, j+1, k, ivy)
   rightd(ivz) = rightd(ivz) + wd(i, j+1, k, ivz)
   right(ivz) = right(ivz) + w(i, j+1, k, ivz)
   rightd(irhoe) = rightd(irhoe) + pd(i, j+1, k)
   right(irhoe) = right(irhoe) + p(i, j+1, k)
   IF (correctfork) THEN
   leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   rightd(itu1) = rightd(itu1) + wd(i, j+1, k, itu1)
   right(itu1) = right(itu1) + w(i, j+1, k, itu1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sxd = sjd(i, j, k, 1)
   sx = sj(i, j, k, 1)
   syd = sjd(i, j, k, 2)
   sy = sj(i, j, k, 2)
   szd = sjd(i, j, k, 3)
   sz = sj(i, j, k, 3)
   por = porj(i, j, k)
   IF (addgridvelocities) sface = sfacej(i, j, k)
   ! Compute the value of gamma on the face. Take an
   ! arithmetic average of the two states.
   gammafaced = half*(gammad(i, j, k)+gammad(i, j+1, k))
   gammaface = half*(gamma(i, j, k)+gamma(i, j+1, k))
   ! Compute the dissipative flux across the interface.
   CALL RIEMANNFLUX_D(left, leftd, right, rightd, flux, fluxd)
   ! And scatter it to the left and right.
   fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
   fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
   fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
   fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
   fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
   fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
   fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
   fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
   fwd(i, j+1, k, irho) = fwd(i, j+1, k, irho) - fluxd(irho)
   fw(i, j+1, k, irho) = fw(i, j+1, k, irho) - flux(irho)
   fwd(i, j+1, k, imx) = fwd(i, j+1, k, imx) - fluxd(imx)
   fw(i, j+1, k, imx) = fw(i, j+1, k, imx) - flux(imx)
   fwd(i, j+1, k, imy) = fwd(i, j+1, k, imy) - fluxd(imy)
   fw(i, j+1, k, imy) = fw(i, j+1, k, imy) - flux(imy)
   fwd(i, j+1, k, imz) = fwd(i, j+1, k, imz) - fluxd(imz)
   fw(i, j+1, k, imz) = fw(i, j+1, k, imz) - flux(imz)
   fwd(i, j+1, k, irhoe) = fwd(i, j+1, k, irhoe) - fluxd(irhoe)
   fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) - flux(irhoe)
   END DO
   END DO
   END DO
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   ! Fluxes in the k-direction.
   DO k=1,kl
   DO j=2,jl
   DO i=2,il
   ! Store the three differences used in the interpolation
   ! in du1, du2, du3.
   du1d(irho) = wd(i, j, k, irho) - wd(i, j, k-1, irho)
   du1(irho) = w(i, j, k, irho) - w(i, j, k-1, irho)
   du2d(irho) = wd(i, j, k+1, irho) - wd(i, j, k, irho)
   du2(irho) = w(i, j, k+1, irho) - w(i, j, k, irho)
   du3d(irho) = wd(i, j, k+2, irho) - wd(i, j, k+1, irho)
   du3(irho) = w(i, j, k+2, irho) - w(i, j, k+1, irho)
   du1d(ivx) = wd(i, j, k, ivx) - wd(i, j, k-1, ivx)
   du1(ivx) = w(i, j, k, ivx) - w(i, j, k-1, ivx)
   du2d(ivx) = wd(i, j, k+1, ivx) - wd(i, j, k, ivx)
   du2(ivx) = w(i, j, k+1, ivx) - w(i, j, k, ivx)
   du3d(ivx) = wd(i, j, k+2, ivx) - wd(i, j, k+1, ivx)
   du3(ivx) = w(i, j, k+2, ivx) - w(i, j, k+1, ivx)
   du1d(ivy) = wd(i, j, k, ivy) - wd(i, j, k-1, ivy)
   du1(ivy) = w(i, j, k, ivy) - w(i, j, k-1, ivy)
   du2d(ivy) = wd(i, j, k+1, ivy) - wd(i, j, k, ivy)
   du2(ivy) = w(i, j, k+1, ivy) - w(i, j, k, ivy)
   du3d(ivy) = wd(i, j, k+2, ivy) - wd(i, j, k+1, ivy)
   du3(ivy) = w(i, j, k+2, ivy) - w(i, j, k+1, ivy)
   du1d(ivz) = wd(i, j, k, ivz) - wd(i, j, k-1, ivz)
   du1(ivz) = w(i, j, k, ivz) - w(i, j, k-1, ivz)
   du2d(ivz) = wd(i, j, k+1, ivz) - wd(i, j, k, ivz)
   du2(ivz) = w(i, j, k+1, ivz) - w(i, j, k, ivz)
   du3d(ivz) = wd(i, j, k+2, ivz) - wd(i, j, k+1, ivz)
   du3(ivz) = w(i, j, k+2, ivz) - w(i, j, k+1, ivz)
   du1d(irhoe) = pd(i, j, k) - pd(i, j, k-1)
   du1(irhoe) = p(i, j, k) - p(i, j, k-1)
   du2d(irhoe) = pd(i, j, k+1) - pd(i, j, k)
   du2(irhoe) = p(i, j, k+1) - p(i, j, k)
   du3d(irhoe) = pd(i, j, k+2) - pd(i, j, k+1)
   du3(irhoe) = p(i, j, k+2) - p(i, j, k+1)
   IF (correctfork) THEN
   du1d(itu1) = wd(i, j, k, itu1) - wd(i, j, k-1, itu1)
   du1(itu1) = w(i, j, k, itu1) - w(i, j, k-1, itu1)
   du2d(itu1) = wd(i, j, k+1, itu1) - wd(i, j, k, itu1)
   du2(itu1) = w(i, j, k+1, itu1) - w(i, j, k, itu1)
   du3d(itu1) = wd(i, j, k+2, itu1) - wd(i, j, k+1, itu1)
   du3(itu1) = w(i, j, k+2, itu1) - w(i, j, k+1, itu1)
   END IF
   ! Compute the differences from the first order scheme.
   CALL LEFTRIGHTSTATE_D(du1, du1d, du2, du2d, du3, du3d, &
   &                           rotmatrixk, left, leftd, right, rightd)
   ! Add the first order part to the currently stored
   ! differences, such that the correct state vector
   ! is stored.
   leftd(irho) = leftd(irho) + wd(i, j, k, irho)
   left(irho) = left(irho) + w(i, j, k, irho)
   leftd(ivx) = leftd(ivx) + wd(i, j, k, ivx)
   left(ivx) = left(ivx) + w(i, j, k, ivx)
   leftd(ivy) = leftd(ivy) + wd(i, j, k, ivy)
   left(ivy) = left(ivy) + w(i, j, k, ivy)
   leftd(ivz) = leftd(ivz) + wd(i, j, k, ivz)
   left(ivz) = left(ivz) + w(i, j, k, ivz)
   leftd(irhoe) = leftd(irhoe) + pd(i, j, k)
   left(irhoe) = left(irhoe) + p(i, j, k)
   rightd(irho) = rightd(irho) + wd(i, j, k+1, irho)
   right(irho) = right(irho) + w(i, j, k+1, irho)
   rightd(ivx) = rightd(ivx) + wd(i, j, k+1, ivx)
   right(ivx) = right(ivx) + w(i, j, k+1, ivx)
   rightd(ivy) = rightd(ivy) + wd(i, j, k+1, ivy)
   right(ivy) = right(ivy) + w(i, j, k+1, ivy)
   rightd(ivz) = rightd(ivz) + wd(i, j, k+1, ivz)
   right(ivz) = right(ivz) + w(i, j, k+1, ivz)
   rightd(irhoe) = rightd(irhoe) + pd(i, j, k+1)
   right(irhoe) = right(irhoe) + p(i, j, k+1)
   IF (correctfork) THEN
   leftd(itu1) = leftd(itu1) + wd(i, j, k, itu1)
   left(itu1) = left(itu1) + w(i, j, k, itu1)
   rightd(itu1) = rightd(itu1) + wd(i, j, k+1, itu1)
   right(itu1) = right(itu1) + w(i, j, k+1, itu1)
   END IF
   ! Store the normal vector, the porosity and the
   ! mesh velocity if present.
   sxd = skd(i, j, k, 1)
   sx = sk(i, j, k, 1)
   syd = skd(i, j, k, 2)
   sy = sk(i, j, k, 2)
   szd = skd(i, j, k, 3)
   sz = sk(i, j, k, 3)
   por = pork(i, j, k)
   IF (addgridvelocities) sface = sfacek(i, j, k)
   ! Compute the value of gamma on the face. Take an
   ! arithmetic average of the two states.
   gammafaced = half*(gammad(i, j, k)+gammad(i, j, k+1))
   gammaface = half*(gamma(i, j, k)+gamma(i, j, k+1))
   ! Compute the dissipative flux across the interface.
   CALL RIEMANNFLUX_D(left, leftd, right, rightd, flux, fluxd)
   ! And scatter it to the left and right.
   fwd(i, j, k, irho) = fwd(i, j, k, irho) + fluxd(irho)
   fw(i, j, k, irho) = fw(i, j, k, irho) + flux(irho)
   fwd(i, j, k, imx) = fwd(i, j, k, imx) + fluxd(imx)
   fw(i, j, k, imx) = fw(i, j, k, imx) + flux(imx)
   fwd(i, j, k, imy) = fwd(i, j, k, imy) + fluxd(imy)
   fw(i, j, k, imy) = fw(i, j, k, imy) + flux(imy)
   fwd(i, j, k, imz) = fwd(i, j, k, imz) + fluxd(imz)
   fw(i, j, k, imz) = fw(i, j, k, imz) + flux(imz)
   fwd(i, j, k, irhoe) = fwd(i, j, k, irhoe) + fluxd(irhoe)
   fw(i, j, k, irhoe) = fw(i, j, k, irhoe) + flux(irhoe)
   fwd(i, j, k+1, irho) = fwd(i, j, k+1, irho) - fluxd(irho)
   fw(i, j, k+1, irho) = fw(i, j, k+1, irho) - flux(irho)
   fwd(i, j, k+1, imx) = fwd(i, j, k+1, imx) - fluxd(imx)
   fw(i, j, k+1, imx) = fw(i, j, k+1, imx) - flux(imx)
   fwd(i, j, k+1, imy) = fwd(i, j, k+1, imy) - fluxd(imy)
   fw(i, j, k+1, imy) = fw(i, j, k+1, imy) - flux(imy)
   fwd(i, j, k+1, imz) = fwd(i, j, k+1, imz) - fluxd(imz)
   fw(i, j, k+1, imz) = fw(i, j, k+1, imz) - flux(imz)
   fwd(i, j, k+1, irhoe) = fwd(i, j, k+1, irhoe) - fluxd(irhoe)
   fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) - flux(irhoe)
   END DO
   END DO
   END DO
   END IF
   END IF
      CONTAINS
   !  Differentiation of leftrightstate in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: left right du1 du2 du3
   !   with respect to varying inputs: left right du1 du2 du3
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATE_D(du1, du1d, du2, du2d, du3, du3d, rotmatrix&
   &   , left, leftd, right, rightd)
   IMPLICIT NONE
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1d, du2d, du3d
   REAL(kind=realtype), DIMENSION(:), INTENT(OUT) :: left, right
   REAL(kind=realtype), DIMENSION(:), INTENT(OUT) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(:, :, :, :, :), POINTER :: rotmatrix
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
   REAL(kind=realtype) :: rl1d, rl2d, rr1d, rr2d, tmpd, dvxd, dvyd, &
   &   dvzd
   REAL(kind=realtype), DIMENSION(3, 3) :: rot
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC SIGN
   INTRINSIC MIN
   REAL(kind=realtype) :: x6d
   REAL(kind=realtype) :: y4d
   REAL(kind=realtype) :: max2d
   REAL(kind=realtype) :: max5d
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x5d
   REAL(kind=realtype) :: y3d
   REAL(kind=realtype) :: max4d
   REAL(kind=realtype) :: max7d
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: x4d
   REAL(kind=realtype) :: y2d
   REAL(kind=realtype) :: max3d
   REAL(kind=realtype) :: max7
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max6d
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: x3d
   REAL(kind=realtype) :: y1
   REAL(kind=realtype) :: y1d
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Check if the velocity components should be transformed to
   ! the cylindrical frame.
   IF (rotationalperiodic) THEN
   ! Store the rotation matrix a bit easier. Note that the i,j,k
   ! come from the main subroutine.
   rot(1, 1) = rotmatrix(i, j, k, 1, 1)
   rot(1, 2) = rotmatrix(i, j, k, 1, 2)
   rot(1, 3) = rotmatrix(i, j, k, 1, 3)
   rot(2, 1) = rotmatrix(i, j, k, 2, 1)
   rot(2, 2) = rotmatrix(i, j, k, 2, 2)
   rot(2, 3) = rotmatrix(i, j, k, 2, 3)
   rot(3, 1) = rotmatrix(i, j, k, 3, 1)
   rot(3, 2) = rotmatrix(i, j, k, 3, 2)
   rot(3, 3) = rotmatrix(i, j, k, 3, 3)
   ! Apply the transformation to the velocity components
   ! of du1, du2 and du3.
   dvxd = du1d(ivx)
   dvx = du1(ivx)
   dvyd = du1d(ivy)
   dvy = du1(ivy)
   dvzd = du1d(ivz)
   dvz = du1(ivz)
   du1d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
   du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du1d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
   du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du1d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
   du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvxd = du2d(ivx)
   dvx = du2(ivx)
   dvyd = du2d(ivy)
   dvy = du2(ivy)
   dvzd = du2d(ivz)
   dvz = du2(ivz)
   du2d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
   du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du2d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
   du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du2d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
   du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvxd = du3d(ivx)
   dvx = du3(ivx)
   dvyd = du3d(ivy)
   dvy = du3(ivy)
   dvzd = du3d(ivz)
   dvz = du3(ivz)
   du3d(ivx) = rot(1, 1)*dvxd + rot(1, 2)*dvyd + rot(1, 3)*dvzd
   du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du3d(ivy) = rot(2, 1)*dvxd + rot(2, 2)*dvyd + rot(2, 3)*dvzd
   du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du3d(ivz) = rot(3, 1)*dvxd + rot(3, 2)*dvyd + rot(3, 3)*dvzd
   du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   END IF
   ! Determine the limiter used.
   SELECT CASE  (limused) 
   CASE (nolimiter) 
   ! Linear interpolation; no limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   leftd(l) = omk*du1d(l) + opk*du2d(l)
   left(l) = omk*du1(l) + opk*du2(l)
   rightd(l) = -(omk*du3d(l)) - opk*du2d(l)
   right(l) = -(omk*du3(l)) - opk*du2(l)
   END DO
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1d = du2d(l)
   x1 = du2(l)
   ELSE
   x1d = -du2d(l)
   x1 = -du2(l)
   END IF
   IF (x1 .LT. epslim) THEN
   max2 = epslim
   max2d = 0.0_8
   ELSE
   max2d = x1d
   max2 = x1
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmpd = -(one*max2d*SIGN(1.d0, max2*du2(l))/SIGN(max2, du2(l))**2&
   &         )
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3d = du1d(l)
   x3 = du1(l)
   ELSE
   x3d = -du1d(l)
   x3 = -du1(l)
   END IF
   IF (x3 .LT. epslim) THEN
   max4 = epslim
   max4d = 0.0_8
   ELSE
   max4d = x3d
   max4 = x3
   END IF
   y1d = (du2d(l)*SIGN(max4, du1(l))-du2(l)*max4d*SIGN(1.d0, max4*&
   &         du1(l)))/SIGN(max4, du1(l))**2
   y1 = du2(l)/SIGN(max4, du1(l))
   IF (zero .LT. y1) THEN
   rl1d = y1d
   rl1 = y1
   ELSE
   rl1 = zero
   rl1d = 0.0_8
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2d = du1d(l)*tmp + du1(l)*tmpd
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   rl2d = 0.0_8
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1d = du3d(l)*tmp + du3(l)*tmpd
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   rr1d = 0.0_8
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4d = du3d(l)
   x4 = du3(l)
   ELSE
   x4d = -du3d(l)
   x4 = -du3(l)
   END IF
   IF (x4 .LT. epslim) THEN
   max5 = epslim
   max5d = 0.0_8
   ELSE
   max5d = x4d
   max5 = x4
   END IF
   y2d = (du2d(l)*SIGN(max5, du3(l))-du2(l)*max5d*SIGN(1.d0, max5*&
   &         du3(l)))/SIGN(max5, du3(l))**2
   y2 = du2(l)/SIGN(max5, du3(l))
   IF (zero .LT. y2) THEN
   rr2d = y2d
   rr2 = y2
   ELSE
   rr2 = zero
   rr2d = 0.0_8
   END IF
   ! Compute the corresponding limiter values.
   rl1d = ((rl1d*(rl1+one)+rl1*rl1d)*(rl1*rl1+one)-rl1*(rl1+one)*(&
   &         rl1d*rl1+rl1*rl1d))/(rl1*rl1+one)**2
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   rl2d = ((rl2d*(rl2+one)+rl2*rl2d)*(rl2*rl2+one)-rl2*(rl2+one)*(&
   &         rl2d*rl2+rl2*rl2d))/(rl2*rl2+one)**2
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   rr1d = ((rr1d*(rr1+one)+rr1*rr1d)*(rr1*rr1+one)-rr1*(rr1+one)*(&
   &         rr1d*rr1+rr1*rr1d))/(rr1*rr1+one)**2
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   rr2d = ((rr2d*(rr2+one)+rr2*rr2d)*(rr2*rr2+one)-rr2*(rr2+one)*(&
   &         rr2d*rr2+rr2*rr2d))/(rr2*rr2+one)**2
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+rl2*&
   &         du2d(l))
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l)+&
   &         rr2*du3d(l))
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2d = du2d(l)
   x2 = du2(l)
   ELSE
   x2d = -du2d(l)
   x2 = -du2(l)
   END IF
   IF (x2 .LT. epslim) THEN
   max3 = epslim
   max3d = 0.0_8
   ELSE
   max3d = x2d
   max3 = x2
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmpd = -(one*max3d*SIGN(1.d0, max3*du2(l))/SIGN(max3, du2(l))**2&
   &         )
   tmp = one/SIGN(max3, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5d = du1d(l)
   x5 = du1(l)
   ELSE
   x5d = -du1d(l)
   x5 = -du1(l)
   END IF
   IF (x5 .LT. epslim) THEN
   max6 = epslim
   max6d = 0.0_8
   ELSE
   max6d = x5d
   max6 = x5
   END IF
   y3d = (du2d(l)*SIGN(max6, du1(l))-du2(l)*max6d*SIGN(1.d0, max6*&
   &         du1(l)))/SIGN(max6, du1(l))**2
   y3 = du2(l)/SIGN(max6, du1(l))
   IF (zero .LT. y3) THEN
   rl1d = y3d
   rl1 = y3
   ELSE
   rl1 = zero
   rl1d = 0.0_8
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2d = du1d(l)*tmp + du1(l)*tmpd
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   rl2d = 0.0_8
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1d = du3d(l)*tmp + du3(l)*tmpd
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   rr1d = 0.0_8
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6d = du3d(l)
   x6 = du3(l)
   ELSE
   x6d = -du3d(l)
   x6 = -du3(l)
   END IF
   IF (x6 .LT. epslim) THEN
   max7 = epslim
   max7d = 0.0_8
   ELSE
   max7d = x6d
   max7 = x6
   END IF
   y4d = (du2d(l)*SIGN(max7, du3(l))-du2(l)*max7d*SIGN(1.d0, max7*&
   &         du3(l)))/SIGN(max7, du3(l))**2
   y4 = du2(l)/SIGN(max7, du3(l))
   IF (zero .LT. y4) THEN
   rr2d = y4d
   rr2 = y4
   ELSE
   rr2 = zero
   rr2d = 0.0_8
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1d = factminmod*rl1d
   rl1 = factminmod*rl1
   ELSE
   rl1 = one
   rl1d = 0.0_8
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2d = factminmod*rl2d
   rl2 = factminmod*rl2
   ELSE
   rl2 = one
   rl2d = 0.0_8
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1d = factminmod*rr1d
   rr1 = factminmod*rr1
   ELSE
   rr1 = one
   rr1d = 0.0_8
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2d = factminmod*rr2d
   rr2 = factminmod*rr2
   ELSE
   rr2 = one
   rr2d = 0.0_8
   END IF
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   leftd(l) = omk*(rl1d*du1(l)+rl1*du1d(l)) + opk*(rl2d*du2(l)+rl2*&
   &         du2d(l))
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   rightd(l) = -(opk*(rr1d*du2(l)+rr1*du2d(l))) - omk*(rr2d*du3(l)+&
   &         rr2*du3d(l))
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   leftd(itu1) = 0.0_8
   left(itu1) = zero
   rightd(itu1) = 0.0_8
   right(itu1) = zero
   END IF
   ! For rotational periodic problems transform the velocity
   ! differences back to Cartesian again. Note that now the
   ! transpose of the rotation matrix must be used.
   IF (rotationalperiodic) THEN
   ! Left state.
   dvxd = leftd(ivx)
   dvx = left(ivx)
   dvyd = leftd(ivy)
   dvy = left(ivy)
   dvzd = leftd(ivz)
   dvz = left(ivz)
   leftd(ivx) = rot(1, 1)*dvxd + rot(2, 1)*dvyd + rot(3, 1)*dvzd
   left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   leftd(ivy) = rot(1, 2)*dvxd + rot(2, 2)*dvyd + rot(3, 2)*dvzd
   left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   leftd(ivz) = rot(1, 3)*dvxd + rot(2, 3)*dvyd + rot(3, 3)*dvzd
   left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   ! Right state.
   dvxd = rightd(ivx)
   dvx = right(ivx)
   dvyd = rightd(ivy)
   dvy = right(ivy)
   dvzd = rightd(ivz)
   dvz = right(ivz)
   rightd(ivx) = rot(1, 1)*dvxd + rot(2, 1)*dvyd + rot(3, 1)*dvzd
   right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   rightd(ivy) = rot(1, 2)*dvxd + rot(2, 2)*dvyd + rot(3, 2)*dvzd
   right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   rightd(ivz) = rot(1, 3)*dvxd + rot(2, 3)*dvyd + rot(3, 3)*dvzd
   right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   END IF
   END SUBROUTINE LEFTRIGHTSTATE_D
   ! Store the density flux in the mass flow of the
   ! appropriate sliding mesh interface.
   !      ==================================================================
   SUBROUTINE LEFTRIGHTSTATE(du1, du2, du3, rotmatrix, left, right)
   IMPLICIT NONE
   !
   !        Local parameter.
   !
   REAL(kind=realtype), PARAMETER :: epslim=1.e-10_realType
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(:), INTENT(INOUT) :: du1, du2, du3
   REAL(kind=realtype), DIMENSION(:), INTENT(OUT) :: left, right
   REAL(kind=realtype), DIMENSION(:, :, :, :, :), POINTER :: rotmatrix
   !
   !        Local variables.
   !
   INTEGER(kind=inttype) :: l
   REAL(kind=realtype) :: rl1, rl2, rr1, rr2, tmp, dvx, dvy, dvz
   REAL(kind=realtype), DIMENSION(3, 3) :: rot
   INTRINSIC ABS
   INTRINSIC MAX
   INTRINSIC SIGN
   INTRINSIC MIN
   REAL(kind=realtype) :: x6
   REAL(kind=realtype) :: x5
   REAL(kind=realtype) :: x4
   REAL(kind=realtype) :: x3
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: max7
   REAL(kind=realtype) :: max6
   REAL(kind=realtype) :: max5
   REAL(kind=realtype) :: max4
   REAL(kind=realtype) :: max3
   REAL(kind=realtype) :: max2
   REAL(kind=realtype) :: y4
   REAL(kind=realtype) :: y3
   REAL(kind=realtype) :: y2
   REAL(kind=realtype) :: y1
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Check if the velocity components should be transformed to
   ! the cylindrical frame.
   IF (rotationalperiodic) THEN
   ! Store the rotation matrix a bit easier. Note that the i,j,k
   ! come from the main subroutine.
   rot(1, 1) = rotmatrix(i, j, k, 1, 1)
   rot(1, 2) = rotmatrix(i, j, k, 1, 2)
   rot(1, 3) = rotmatrix(i, j, k, 1, 3)
   rot(2, 1) = rotmatrix(i, j, k, 2, 1)
   rot(2, 2) = rotmatrix(i, j, k, 2, 2)
   rot(2, 3) = rotmatrix(i, j, k, 2, 3)
   rot(3, 1) = rotmatrix(i, j, k, 3, 1)
   rot(3, 2) = rotmatrix(i, j, k, 3, 2)
   rot(3, 3) = rotmatrix(i, j, k, 3, 3)
   ! Apply the transformation to the velocity components
   ! of du1, du2 and du3.
   dvx = du1(ivx)
   dvy = du1(ivy)
   dvz = du1(ivz)
   du1(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du1(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du1(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du2(ivx)
   dvy = du2(ivy)
   dvz = du2(ivz)
   du2(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du2(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du2(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   dvx = du3(ivx)
   dvy = du3(ivy)
   dvz = du3(ivz)
   du3(ivx) = rot(1, 1)*dvx + rot(1, 2)*dvy + rot(1, 3)*dvz
   du3(ivy) = rot(2, 1)*dvx + rot(2, 2)*dvy + rot(2, 3)*dvz
   du3(ivz) = rot(3, 1)*dvx + rot(3, 2)*dvy + rot(3, 3)*dvz
   END IF
   ! Determine the limiter used.
   SELECT CASE  (limused) 
   CASE (nolimiter) 
   ! Linear interpolation; no limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   left(l) = omk*du1(l) + opk*du2(l)
   right(l) = -(omk*du3(l)) - opk*du2(l)
   END DO
   CASE (vanalbeda) 
   !          ==============================================================
   ! Nonlinear interpolation using the van albeda limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x1 = du2(l)
   ELSE
   x1 = -du2(l)
   END IF
   IF (x1 .LT. epslim) THEN
   max2 = epslim
   ELSE
   max2 = x1
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max2, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x3 = du1(l)
   ELSE
   x3 = -du1(l)
   END IF
   IF (x3 .LT. epslim) THEN
   max4 = epslim
   ELSE
   max4 = x3
   END IF
   y1 = du2(l)/SIGN(max4, du1(l))
   IF (zero .LT. y1) THEN
   rl1 = y1
   ELSE
   rl1 = zero
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   END IF
   IF (du3(l) .GE. 0.) THEN
   x4 = du3(l)
   ELSE
   x4 = -du3(l)
   END IF
   IF (x4 .LT. epslim) THEN
   max5 = epslim
   ELSE
   max5 = x4
   END IF
   y2 = du2(l)/SIGN(max5, du3(l))
   IF (zero .LT. y2) THEN
   rr2 = y2
   ELSE
   rr2 = zero
   END IF
   ! Compute the corresponding limiter values.
   rl1 = rl1*(rl1+one)/(rl1*rl1+one)
   rl2 = rl2*(rl2+one)/(rl2*rl2+one)
   rr1 = rr1*(rr1+one)/(rr1*rr1+one)
   rr2 = rr2*(rr2+one)/(rr2*rr2+one)
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   CASE (minmod) 
   !          ==============================================================
   ! Nonlinear interpolation using the minmod limiter.
   ! Loop over the number of variables to be interpolated.
   DO l=1,nwint
   IF (du2(l) .GE. 0.) THEN
   x2 = du2(l)
   ELSE
   x2 = -du2(l)
   END IF
   IF (x2 .LT. epslim) THEN
   max3 = epslim
   ELSE
   max3 = x2
   END IF
   ! Compute the limiter argument rl1, rl2, rr1 and rr2.
   ! Note the cut off to 0.0.
   tmp = one/SIGN(max3, du2(l))
   IF (du1(l) .GE. 0.) THEN
   x5 = du1(l)
   ELSE
   x5 = -du1(l)
   END IF
   IF (x5 .LT. epslim) THEN
   max6 = epslim
   ELSE
   max6 = x5
   END IF
   y3 = du2(l)/SIGN(max6, du1(l))
   IF (zero .LT. y3) THEN
   rl1 = y3
   ELSE
   rl1 = zero
   END IF
   IF (zero .LT. du1(l)*tmp) THEN
   rl2 = du1(l)*tmp
   ELSE
   rl2 = zero
   END IF
   IF (zero .LT. du3(l)*tmp) THEN
   rr1 = du3(l)*tmp
   ELSE
   rr1 = zero
   END IF
   IF (du3(l) .GE. 0.) THEN
   x6 = du3(l)
   ELSE
   x6 = -du3(l)
   END IF
   IF (x6 .LT. epslim) THEN
   max7 = epslim
   ELSE
   max7 = x6
   END IF
   y4 = du2(l)/SIGN(max7, du3(l))
   IF (zero .LT. y4) THEN
   rr2 = y4
   ELSE
   rr2 = zero
   END IF
   IF (one .GT. factminmod*rl1) THEN
   rl1 = factminmod*rl1
   ELSE
   rl1 = one
   END IF
   IF (one .GT. factminmod*rl2) THEN
   rl2 = factminmod*rl2
   ELSE
   rl2 = one
   END IF
   IF (one .GT. factminmod*rr1) THEN
   rr1 = factminmod*rr1
   ELSE
   rr1 = one
   END IF
   IF (one .GT. factminmod*rr2) THEN
   rr2 = factminmod*rr2
   ELSE
   rr2 = one
   END IF
   ! Compute the nonlinear corrections to the first order
   ! scheme.
   left(l) = omk*rl1*du1(l) + opk*rl2*du2(l)
   right(l) = -(opk*rr1*du2(l)) - omk*rr2*du3(l)
   END DO
   END SELECT
   ! In case only a first order scheme must be used for the
   ! turbulent transport equations, set the correction for the
   ! turbulent kinetic energy to 0.
   IF (firstorderk) THEN
   left(itu1) = zero
   right(itu1) = zero
   END IF
   ! For rotational periodic problems transform the velocity
   ! differences back to Cartesian again. Note that now the
   ! transpose of the rotation matrix must be used.
   IF (rotationalperiodic) THEN
   ! Left state.
   dvx = left(ivx)
   dvy = left(ivy)
   dvz = left(ivz)
   left(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   left(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   left(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   ! Right state.
   dvx = right(ivx)
   dvy = right(ivy)
   dvz = right(ivz)
   right(ivx) = rot(1, 1)*dvx + rot(2, 1)*dvy + rot(3, 1)*dvz
   right(ivy) = rot(1, 2)*dvx + rot(2, 2)*dvy + rot(3, 2)*dvz
   right(ivz) = rot(1, 3)*dvx + rot(2, 3)*dvy + rot(3, 3)*dvz
   END IF
   END SUBROUTINE LEFTRIGHTSTATE
   !  Differentiation of riemannflux in forward (tangent) mode (with options i4 dr8 r8):
   !   variations   of useful results: flux
   !   with respect to varying inputs: gammaface sx sy sz flux left
   !                right
   !        ================================================================
   SUBROUTINE RIEMANNFLUX_D(left, leftd, right, rightd, flux, fluxd)
   IMPLICIT NONE
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: leftd, rightd
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: flux
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: fluxd
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: rfaced
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: etld, etrd, z1ld, z1rd, tmpd
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: drd, drud, drvd, drwd, dred, drkd
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: uavgd, vavgd, wavgd, havgd, kavgd
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: alphaavgd, a2avgd, aavgd, unavgd
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: ovaavgd, ova2avgd, aread, etad
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: gm1d, gm53d
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: lam1d, lam2d, lam3d
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype) :: abv1d, abv2d, abv3d, abv4d, abv5d, abv6d, &
   &   abv7d
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: rhotmpd, utmpd, vtmpd, wtmpd
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   REAL(kind=realtype), DIMENSION(2) :: ptmpd, ktmpd, etmpd
   INTRINSIC SQRT
   INTRINSIC MAX
   INTRINSIC ABS
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1d
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: result1d
   REAL(kind=realtype) :: arg2
   REAL(kind=realtype) :: arg2d
   REAL(kind=realtype) :: result2
   REAL(kind=realtype) :: result2d
   REAL(kind=realtype) :: abs1d
   REAL(kind=realtype) :: max2d
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x2d
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: x1d
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs2d
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: max2
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Abbreviate some expressions in which gamma occurs.
   gm1d = gammafaced
   gm1 = gammaface - one
   gm53d = gammafaced
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   IF (left(irho) .EQ. 0.0_8) THEN
   z1ld = 0.0_8
   ELSE
   z1ld = leftd(irho)/(2.0*SQRT(left(irho)))
   END IF
   z1l = SQRT(left(irho))
   IF (right(irho) .EQ. 0.0_8) THEN
   z1rd = 0.0_8
   ELSE
   z1rd = rightd(irho)/(2.0*SQRT(right(irho)))
   END IF
   z1r = SQRT(right(irho))
   tmpd = -(one*(z1ld+z1rd)/(z1l+z1r)**2)
   tmp = one/(z1l+z1r)
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmpd = 0.0_8
   ktmpd(1) = leftd(itu1)
   ktmp(1) = left(itu1)
   ktmpd(2) = rightd(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drkd = rightd(irho)*right(itu1) + right(irho)*rightd(itu1) - &
   &           leftd(irho)*left(itu1) - left(irho)*leftd(itu1)
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavgd = tmpd*(z1l*left(itu1)+z1r*right(itu1)) + tmp*(z1ld*left&
   &           (itu1)+z1l*leftd(itu1)+z1rd*right(itu1)+z1r*rightd(itu1))
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   ELSE
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   ktmpd = 0.0_8
   kavgd = 0.0_8
   drkd = 0.0_8
   END IF
   ! Compute the total energy of the left and right state.
   rhotmpd = 0.0_8
   rhotmpd(1) = leftd(irho)
   rhotmp(1) = left(irho)
   rhotmpd(2) = rightd(irho)
   rhotmp(2) = right(irho)
   utmpd = 0.0_8
   utmpd(1) = leftd(ivx)
   utmp(1) = left(ivx)
   utmpd(2) = rightd(ivx)
   utmp(2) = right(ivx)
   vtmpd = 0.0_8
   vtmpd(1) = leftd(ivy)
   vtmp(1) = left(ivy)
   vtmpd(2) = rightd(ivy)
   vtmp(2) = right(ivy)
   wtmpd = 0.0_8
   wtmpd(1) = leftd(ivz)
   wtmp(1) = left(ivz)
   wtmpd(2) = rightd(ivz)
   wtmp(2) = right(ivz)
   ptmpd = 0.0_8
   ptmpd(1) = leftd(irhoe)
   ptmp(1) = left(irhoe)
   ptmpd(2) = rightd(irhoe)
   ptmp(2) = right(irhoe)
   CALL ETOTARRAY_D(rhotmp, rhotmpd, utmp, utmpd, vtmp, vtmpd, wtmp&
   &                  , wtmpd, ptmp, ptmpd, ktmp, ktmpd, etmp, etmpd, &
   &                  correctfork, 2)
   etld = etmpd(1)
   etl = etmp(1)
   etrd = etmpd(2)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   drd = rightd(irho) - leftd(irho)
   dr = right(irho) - left(irho)
   drud = rightd(irho)*right(ivx) + right(irho)*rightd(ivx) - leftd&
   &         (irho)*left(ivx) - left(irho)*leftd(ivx)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drvd = rightd(irho)*right(ivy) + right(irho)*rightd(ivy) - leftd&
   &         (irho)*left(ivy) - left(irho)*leftd(ivy)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drwd = rightd(irho)*right(ivz) + right(irho)*rightd(ivz) - leftd&
   &         (irho)*left(ivz) - left(irho)*leftd(ivz)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dred = etrd - etld
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   ravg = fourth*(z1r+z1l)**2
   uavgd = tmpd*(z1l*left(ivx)+z1r*right(ivx)) + tmp*(z1ld*left(ivx&
   &         )+z1l*leftd(ivx)+z1rd*right(ivx)+z1r*rightd(ivx))
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavgd = tmpd*(z1l*left(ivy)+z1r*right(ivy)) + tmp*(z1ld*left(ivy&
   &         )+z1l*leftd(ivy)+z1rd*right(ivy)+z1r*rightd(ivy))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavgd = tmpd*(z1l*left(ivz)+z1r*right(ivz)) + tmp*(z1ld*left(ivz&
   &         )+z1l*leftd(ivz)+z1rd*right(ivz)+z1r*rightd(ivz))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havgd = tmpd*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r) + &
   &         tmp*(((etld+leftd(irhoe))*z1l-(etl+left(irhoe))*z1ld)/z1l**2+(&
   &         (etrd+rightd(irhoe))*z1r-(etr+right(irhoe))*z1rd)/z1r**2)
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   arg1d = 2*sx*sxd + 2*sy*syd + 2*sz*szd
   arg1 = sx**2 + sy**2 + sz**2
   IF (arg1 .EQ. 0.0_8) THEN
   aread = 0.0_8
   ELSE
   aread = arg1d/(2.0*SQRT(arg1))
   END IF
   area = SQRT(arg1)
   IF (1.e-25_realType .LT. area) THEN
   max2d = aread
   max2 = area
   ELSE
   max2 = 1.e-25_realType
   max2d = 0.0_8
   END IF
   tmpd = -(one*max2d/max2**2)
   tmp = one/max2
   sxd = sxd*tmp + sx*tmpd
   sx = sx*tmp
   syd = syd*tmp + sy*tmpd
   sy = sy*tmp
   szd = szd*tmp + sz*tmpd
   sz = sz*tmp
   rfaced = sface*tmpd
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavgd = half*(2*uavg*uavgd+2*vavg*vavgd+2*wavg*wavgd)
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avgd = gm1d*(havg-alphaavg) + gm1*(havgd-alphaavgd) - gm53d*&
   &           kavg - gm53*kavgd
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   ELSE
   a2avgd = -(gm1d*(havg-alphaavg)+gm1*(havgd-alphaavgd)-gm53d*&
   &           kavg-gm53*kavgd)
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   END IF
   IF (a2avg .EQ. 0.0_8) THEN
   aavgd = 0.0_8
   ELSE
   aavgd = a2avgd/(2.0*SQRT(a2avg))
   END IF
   aavg = SQRT(a2avg)
   unavgd = uavgd*sx + uavg*sxd + vavgd*sy + vavg*syd + wavgd*sz + &
   &         wavg*szd
   unavg = uavg*sx + vavg*sy + wavg*sz
   ovaavgd = -(one*aavgd/aavg**2)
   ovaavg = one/aavg
   ova2avgd = -(one*a2avgd/a2avg**2)
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) THEN
   unavgd = rfaced
   unavg = rface
   END IF
   x1d = (leftd(ivx)-rightd(ivx))*sx + (left(ivx)-right(ivx))*sxd +&
   &         (leftd(ivy)-rightd(ivy))*sy + (left(ivy)-right(ivy))*syd + (&
   &         leftd(ivz)-rightd(ivz))*sz + (left(ivz)-right(ivz))*szd
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
   &         left(ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1d = x1d
   abs1 = x1
   ELSE
   abs1d = -x1d
   abs1 = -x1
   END IF
   arg1d = ((gammafaced*left(irhoe)+gammaface*leftd(irhoe))*left(&
   &         irho)-gammaface*left(irhoe)*leftd(irho))/left(irho)**2
   arg1 = gammaface*left(irhoe)/left(irho)
   IF (arg1 .EQ. 0.0_8) THEN
   result1d = 0.0_8
   ELSE
   result1d = arg1d/(2.0*SQRT(arg1))
   END IF
   result1 = SQRT(arg1)
   arg2d = ((gammafaced*right(irhoe)+gammaface*rightd(irhoe))*right&
   &         (irho)-gammaface*right(irhoe)*rightd(irho))/right(irho)**2
   arg2 = gammaface*right(irhoe)/right(irho)
   IF (arg2 .EQ. 0.0_8) THEN
   result2d = 0.0_8
   ELSE
   result2d = arg2d/(2.0*SQRT(arg2))
   END IF
   result2 = SQRT(arg2)
   x2d = result1d - result2d
   x2 = result1 - result2
   IF (x2 .GE. 0.) THEN
   abs2d = x2d
   abs2 = x2
   ELSE
   abs2d = -x2d
   abs2 = -x2
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   etad = half*(abs1d+abs2d)
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1d = unavgd - rfaced + aavgd
   lam1 = unavg - rface + aavg
   ELSE
   lam1d = -(unavgd-rfaced+aavgd)
   lam1 = -(unavg-rface+aavg)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2d = unavgd - rfaced - aavgd
   lam2 = unavg - rface - aavg
   ELSE
   lam2d = -(unavgd-rfaced-aavgd)
   lam2 = -(unavg-rface-aavg)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3d = unavgd - rfaced
   lam3 = unavg - rface
   ELSE
   lam3d = -(unavgd-rfaced)
   lam3 = -(unavg-rface)
   END IF
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) THEN
   lam1d = etad + (fourth*(lam1d*lam1+lam1*lam1d)*eta-fourth*lam1&
   &           **2*etad)/eta**2
   lam1 = eta + fourth*lam1*lam1/eta
   END IF
   IF (lam2 .LT. tmp) THEN
   lam2d = etad + (fourth*(lam2d*lam2+lam2*lam2d)*eta-fourth*lam2&
   &           **2*etad)/eta**2
   lam2 = eta + fourth*lam2*lam2/eta
   END IF
   IF (lam3 .LT. tmp) THEN
   lam3d = etad + (fourth*(lam3d*lam3+lam3*lam3d)*eta-fourth*lam3&
   &           **2*etad)/eta**2
   lam3 = eta + fourth*lam3*lam3/eta
   END IF
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   lam1d = lam1d*area + lam1*aread
   lam1 = lam1*area
   lam2d = lam2d*area + lam2*aread
   lam2 = lam2*area
   lam3d = lam3d*area + lam3*aread
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1d = half*(lam1d+lam2d)
   abv1 = half*(lam1+lam2)
   abv2d = half*(lam1d-lam2d)
   abv2 = half*(lam1-lam2)
   abv3d = abv1d - lam3d
   abv3 = abv1 - lam3
   abv4d = gm1d*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) + gm1*&
   &         (alphaavgd*dr+alphaavg*drd-uavgd*dru-uavg*drud-vavgd*drv-vavg*&
   &         drvd-wavgd*drw-wavg*drwd+dred) - gm53d*drk - gm53*drkd
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
   &         drk
   abv5d = sxd*dru + sx*drud + syd*drv + sy*drvd + szd*drw + sz*&
   &         drwd - unavgd*dr - unavg*drd
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6d = (abv3d*abv4+abv3*abv4d)*ova2avg + abv3*abv4*ova2avgd + (&
   &         abv2d*abv5+abv2*abv5d)*ovaavg + abv2*abv5*ovaavgd
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7d = (abv2d*abv4+abv2*abv4d)*ovaavg + abv2*abv4*ovaavgd + &
   &         abv3d*abv5 + abv3*abv5d
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   fluxd(irho) = -(porflux*(lam3d*dr+lam3*drd+abv6d))
   flux(irho) = -(porflux*(lam3*dr+abv6))
   fluxd(imx) = -(porflux*(lam3d*dru+lam3*drud+uavgd*abv6+uavg*&
   &         abv6d+sxd*abv7+sx*abv7d))
   flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
   fluxd(imy) = -(porflux*(lam3d*drv+lam3*drvd+vavgd*abv6+vavg*&
   &         abv6d+syd*abv7+sy*abv7d))
   flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
   fluxd(imz) = -(porflux*(lam3d*drw+lam3*drwd+wavgd*abv6+wavg*&
   &         abv6d+szd*abv7+sz*abv7d))
   flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
   fluxd(irhoe) = -(porflux*(lam3d*dre+lam3*dred+havgd*abv6+havg*&
   &         abv6d+unavgd*abv7+unavg*abv7d))
   flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
   CASE (turkel) 
   !          tmp = max(lam1,lam2,lam3)
   !          flux(irho)  = -porFlux*(tmp*dr)
   !          flux(imx)   = -porFlux*(tmp*dru)
   !          flux(imy)   = -porFlux*(tmp*drv)
   !          flux(imz)   = -porFlux*(tmp*drw)
   !          flux(irhoE) = -porFlux*(tmp*drE)
   CALL TERMINATE('riemannFlux', &
   &                   'Turkel preconditioner not implemented yet')
   CASE (choimerkle) 
   CALL TERMINATE('riemannFlux', &
   &                   'choi merkle preconditioner not implemented yet')
   END SELECT
   CASE (vanleer) 
   CALL TERMINATE('riemannFlux', &
   &                 'van leer fvs not implemented yet')
   CASE (ausmdv) 
   CALL TERMINATE('riemannFlux', 'ausmdv fvs not implemented yet')
   END SELECT
   END SUBROUTINE RIEMANNFLUX_D
   !        ================================================================
   SUBROUTINE RIEMANNFLUX(left, right, flux)
   IMPLICIT NONE
   !
   !        Subroutine arguments.
   !
   REAL(kind=realtype), DIMENSION(*), INTENT(IN) :: left, right
   REAL(kind=realtype), DIMENSION(*), INTENT(OUT) :: flux
   !
   !        Local variables.
   !
   REAL(kind=realtype) :: porflux, rface
   REAL(kind=realtype) :: etl, etr, z1l, z1r, tmp
   REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk
   REAL(kind=realtype) :: ravg, uavg, vavg, wavg, havg, kavg
   REAL(kind=realtype) :: alphaavg, a2avg, aavg, unavg
   REAL(kind=realtype) :: ovaavg, ova2avg, area, eta
   REAL(kind=realtype) :: gm1, gm53
   REAL(kind=realtype) :: lam1, lam2, lam3
   REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
   REAL(kind=realtype), DIMENSION(2) :: rhotmp, utmp, vtmp, wtmp
   REAL(kind=realtype), DIMENSION(2) :: ptmp, ktmp, etmp
   INTRINSIC SQRT
   INTRINSIC MAX
   INTRINSIC ABS
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: result1
   REAL(kind=realtype) :: arg2
   REAL(kind=realtype) :: result2
   REAL(kind=realtype) :: x2
   REAL(kind=realtype) :: x1
   REAL(kind=realtype) :: abs2
   REAL(kind=realtype) :: abs1
   REAL(kind=realtype) :: max2
   !
   !        ****************************************************************
   !        *                                                              *
   !        * Begin execution.                                             *
   !        *                                                              *
   !        ****************************************************************
   !
   ! Set the porosity for the flux. The default value, 0.5*rFil, is
   ! a scaling factor where an rFil != 1 is taken into account.
   porflux = half*rfil
   IF (por .EQ. noflux .OR. por .EQ. boundflux) porflux = zero
   ! Abbreviate some expressions in which gamma occurs.
   gm1 = gammaface - one
   gm53 = gammaface - five*third
   ! Determine which riemann solver must be solved.
   SELECT CASE  (riemannused) 
   CASE (roe) 
   ! Determine the preconditioner used.
   SELECT CASE  (precond) 
   CASE (noprecond) 
   ! No preconditioner used. Use the Roe scheme of the
   ! standard equations.
   ! Compute the square root of the left and right densities
   ! and the inverse of the sum.
   z1l = SQRT(left(irho))
   z1r = SQRT(right(irho))
   tmp = one/(z1l+z1r)
   ! Compute some variables depending whether or not a
   ! k-equation is present.
   IF (correctfork) THEN
   ! Store the left and right kinetic energy in ktmp,
   ! which is needed to compute the total energy.
   ktmp(1) = left(itu1)
   ktmp(2) = right(itu1)
   ! Store the difference of the turbulent kinetic energy
   ! per unit volume, i.e. the conserved variable.
   drk = right(irho)*right(itu1) - left(irho)*left(itu1)
   ! Compute the average turbulent energy per unit mass
   ! using Roe averages.
   kavg = tmp*(z1l*left(itu1)+z1r*right(itu1))
   ELSE
   ! Set the difference of the turbulent kinetic energy
   ! per unit volume and the averaged kinetic energy per
   ! unit mass to zero.
   drk = 0.0
   kavg = 0.0
   END IF
   ! Compute the total energy of the left and right state.
   rhotmp(1) = left(irho)
   rhotmp(2) = right(irho)
   utmp(1) = left(ivx)
   utmp(2) = right(ivx)
   vtmp(1) = left(ivy)
   vtmp(2) = right(ivy)
   wtmp(1) = left(ivz)
   wtmp(2) = right(ivz)
   ptmp(1) = left(irhoe)
   ptmp(2) = right(irhoe)
   CALL ETOTARRAY(rhotmp, utmp, vtmp, wtmp, ptmp, ktmp, etmp, &
   &                   correctfork, 2)
   etl = etmp(1)
   etr = etmp(2)
   ! Compute the difference of the conservative mean
   ! flow variables.
   dr = right(irho) - left(irho)
   dru = right(irho)*right(ivx) - left(irho)*left(ivx)
   drv = right(irho)*right(ivy) - left(irho)*left(ivy)
   drw = right(irho)*right(ivz) - left(irho)*left(ivz)
   dre = etr - etl
   ! Compute the Roe average variables, which can be
   ! computed directly from the average Roe vector.
   ravg = fourth*(z1r+z1l)**2
   uavg = tmp*(z1l*left(ivx)+z1r*right(ivx))
   vavg = tmp*(z1l*left(ivy)+z1r*right(ivy))
   wavg = tmp*(z1l*left(ivz)+z1r*right(ivz))
   havg = tmp*((etl+left(irhoe))/z1l+(etr+right(irhoe))/z1r)
   ! Compute the unit vector and store the area of the
   ! normal. Also compute the unit normal velocity of the face.
   arg1 = sx**2 + sy**2 + sz**2
   area = SQRT(arg1)
   IF (1.e-25_realType .LT. area) THEN
   max2 = area
   ELSE
   max2 = 1.e-25_realType
   END IF
   tmp = one/max2
   sx = sx*tmp
   sy = sy*tmp
   sz = sz*tmp
   rface = sface*tmp
   ! Compute some dependent variables at the Roe
   ! average state.
   alphaavg = half*(uavg**2+vavg**2+wavg**2)
   IF (gm1*(havg-alphaavg) - gm53*kavg .GE. 0.) THEN
   a2avg = gm1*(havg-alphaavg) - gm53*kavg
   ELSE
   a2avg = -(gm1*(havg-alphaavg)-gm53*kavg)
   END IF
   aavg = SQRT(a2avg)
   unavg = uavg*sx + vavg*sy + wavg*sz
   ovaavg = one/aavg
   ova2avg = one/a2avg
   ! Set for a boundary the normal velocity to rFace, the
   ! normal velocity of the boundary.
   IF (por .EQ. boundflux) unavg = rface
   x1 = (left(ivx)-right(ivx))*sx + (left(ivy)-right(ivy))*sy + (&
   &         left(ivz)-right(ivz))*sz
   IF (x1 .GE. 0.) THEN
   abs1 = x1
   ELSE
   abs1 = -x1
   END IF
   arg1 = gammaface*left(irhoe)/left(irho)
   result1 = SQRT(arg1)
   arg2 = gammaface*right(irhoe)/right(irho)
   result2 = SQRT(arg2)
   x2 = result1 - result2
   IF (x2 .GE. 0.) THEN
   abs2 = x2
   ELSE
   abs2 = -x2
   END IF
   ! Compute the coefficient eta for the entropy correction.
   ! At the moment a 1D entropy correction is used, which
   ! removes expansion shocks. Although it also reduces the
   ! carbuncle phenomenon, it does not remove it completely.
   ! In other to do that a multi-dimensional entropy fix is
   ! needed, see Sanders et. al, JCP, vol. 145, 1998,
   ! pp. 511 - 537. Although relatively easy to implement,
   ! an efficient implementation requires the storage of
   ! all the left and right states, which is rather
   ! expensive in terms of memory.
   eta = half*(abs1+abs2)
   IF (unavg - rface + aavg .GE. 0.) THEN
   lam1 = unavg - rface + aavg
   ELSE
   lam1 = -(unavg-rface+aavg)
   END IF
   IF (unavg - rface - aavg .GE. 0.) THEN
   lam2 = unavg - rface - aavg
   ELSE
   lam2 = -(unavg-rface-aavg)
   END IF
   IF (unavg - rface .GE. 0.) THEN
   lam3 = unavg - rface
   ELSE
   lam3 = -(unavg-rface)
   END IF
   ! Apply the entropy correction to the eigenvalues.
   tmp = two*eta
   IF (lam1 .LT. tmp) lam1 = eta + fourth*lam1*lam1/eta
   IF (lam2 .LT. tmp) lam2 = eta + fourth*lam2*lam2/eta
   IF (lam3 .LT. tmp) lam3 = eta + fourth*lam3*lam3/eta
   ! Multiply the eigenvalues by the area to obtain
   ! the correct values for the dissipation term.
   lam1 = lam1*area
   lam2 = lam2*area
   lam3 = lam3*area
   ! Some abbreviations, which occur quite often in the
   ! dissipation terms.
   abv1 = half*(lam1+lam2)
   abv2 = half*(lam1-lam2)
   abv3 = abv1 - lam3
   abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53*&
   &         drk
   abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
   abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
   abv7 = abv2*abv4*ovaavg + abv3*abv5
   ! Compute the dissipation term, -|a| (wr - wl), which is
   ! multiplied by porFlux. Note that porFlux is either
   ! 0.0 or 0.5*rFil.
   flux(irho) = -(porflux*(lam3*dr+abv6))
   flux(imx) = -(porflux*(lam3*dru+uavg*abv6+sx*abv7))
   flux(imy) = -(porflux*(lam3*drv+vavg*abv6+sy*abv7))
   flux(imz) = -(porflux*(lam3*drw+wavg*abv6+sz*abv7))
   flux(irhoe) = -(porflux*(lam3*dre+havg*abv6+unavg*abv7))
   CASE (turkel) 
   !          tmp = max(lam1,lam2,lam3)
   !          flux(irho)  = -porFlux*(tmp*dr)
   !          flux(imx)   = -porFlux*(tmp*dru)
   !          flux(imy)   = -porFlux*(tmp*drv)
   !          flux(imz)   = -porFlux*(tmp*drw)
   !          flux(irhoE) = -porFlux*(tmp*drE)
   CALL TERMINATE('riemannFlux', &
   &                   'Turkel preconditioner not implemented yet')
   CASE (choimerkle) 
   CALL TERMINATE('riemannFlux', &
   &                   'choi merkle preconditioner not implemented yet')
   END SELECT
   CASE (vanleer) 
   CALL TERMINATE('riemannFlux', &
   &                 'van leer fvs not implemented yet')
   CASE (ausmdv) 
   CALL TERMINATE('riemannFlux', 'ausmdv fvs not implemented yet')
   END SELECT
   END SUBROUTINE RIEMANNFLUX
   END SUBROUTINE INVISCIDUPWINDFLUX_D

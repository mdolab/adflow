!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          inviscidDissFluxMatrix.f90                      *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-25-2003                                      *
!      * Last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INVISCIDDISSFLUXMATRIX_CD()
  USE INPUTPHYSICS_SPATIAL_D
  USE ITERATION_SPATIAL_D
  USE CGNSGRID_SPATIAL_D
  USE INPUTDISCRETIZATION_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * inviscidDissFluxMatrix computes the matrix artificial          *
!      * dissipation term. Instead of the spectral radius, as used in   *
!      * the scalar dissipation scheme, the absolute value of the flux  *
!      * jacobian is used. This leads to a less diffusive and           *
!      * consequently more accurate scheme. It is assumed that the      *
!      * pointers in blockPointers already point to the correct block.  *
!      *                                                                *
!      ******************************************************************
!
!
!      Local parameters.
!
  REAL(kind=realtype), PARAMETER :: dpmax=0.25_realType
  REAL(kind=realtype), PARAMETER :: epsacoustic=0.25_realType
  REAL(kind=realtype), PARAMETER :: epsshear=0.025_realType
  REAL(kind=realtype), PARAMETER :: omega=0.5_realType
  REAL(kind=realtype), PARAMETER :: oneminomega=one-omega
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, k, ind
  REAL(kind=realtype) :: plim, sface
  REAL(kind=realtype) :: sfil, fis2, fis4
  REAL(kind=realtype) :: gammaavg, gm1, ovgm1, gm53
  REAL(kind=realtype) :: ppor, rrad, dis2, dis4
  REAL(kind=realtype) :: dp1, dp2, ddw, tmp, fs
  REAL(kind=realtype) :: dr, dru, drv, drw, dre, drk, sx, sy, sz
  REAL(kind=realtype) :: uavg, vavg, wavg, a2avg, aavg, havg
  REAL(kind=realtype) :: alphaavg, unavg, ovaavg, ova2avg
  REAL(kind=realtype) :: kavg, lam1, lam2, lam3, area
  REAL(kind=realtype) :: abv1, abv2, abv3, abv4, abv5, abv6, abv7
  LOGICAL :: correctfork
  REAL(kind=realtype) :: DIM_CD
  REAL(kind=realtype) :: arg1
  REAL(kind=realtype) :: min3
  REAL(kind=realtype) :: min2
  REAL(kind=realtype) :: min1
  INTRINSIC MAX
  REAL(kind=realtype) :: x6
  REAL(kind=realtype) :: x5
  REAL(kind=realtype) :: x4
  REAL(kind=realtype) :: x3
  INTRINSIC ABS
  REAL(kind=realtype) :: x2
  REAL(kind=realtype) :: x1
  REAL(kind=realtype) :: abs12
  REAL(kind=realtype) :: abs11
  REAL(kind=realtype) :: abs10
  REAL(kind=realtype) :: abs9
  REAL(kind=realtype) :: abs8
  REAL(kind=realtype) :: abs7
  REAL(kind=realtype) :: abs6
  REAL(kind=realtype) :: abs5
  REAL(kind=realtype) :: abs4
  REAL(kind=realtype) :: abs3
  REAL(kind=realtype) :: abs2
  REAL(kind=realtype) :: abs1
  INTRINSIC MIN
  INTRINSIC SQRT
  REAL(realType) :: max3
  REAL(realType) :: max2
  REAL(realType) :: max1
  REAL(kind=realtype) :: y3
  REAL(kind=realtype) :: y2
  REAL(kind=realtype) :: y1
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Check if rFil == 0. If so, the dissipative flux needs not to
! be computed.
  IF (rfil .EQ. zero) THEN
    RETURN
  ELSE
! Set the value of plim. To be fully consistent this must have
! the dimension of a pressure. Therefore a fraction of pInfCorr
! is used.
    plim = 0.001_realType*pinfcorr
! Determine whether or not the total energy must be corrected
! for the presence of the turbulent kinetic energy.
    IF (kpresent) THEN
      IF (currentlevel .EQ. groundlevel .OR. turbcoupled) THEN
        correctfork = .true.
      ELSE
        correctfork = .false.
      END IF
    ELSE
      correctfork = .false.
    END IF
! Initialize sface to zero. This value will be used if the
! block is not moving.
    sface = zero
! Set a couple of constants for the scheme.
    fis2 = rfil*vis2
    fis4 = rfil*vis4
    sfil = one - rfil
! Initialize the dissipative residual to a certain times,
! possibly zero, the previously stored value. Owned cells
! only, because the halo values do not matter.
    DO k=2,kl
      DO j=2,jl
        DO i=2,il
          fw(i, j, k, irho) = sfil*fw(i, j, k, irho)
          fw(i, j, k, imx) = sfil*fw(i, j, k, imx)
          fw(i, j, k, imy) = sfil*fw(i, j, k, imy)
          fw(i, j, k, imz) = sfil*fw(i, j, k, imz)
          fw(i, j, k, irhoe) = sfil*fw(i, j, k, irhoe)
        END DO
      END DO
    END DO
!
!      ******************************************************************
!      *                                                                *
!      * Dissipative fluxes in the i-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    DO k=2,kl
      DO j=2,jl
        IF (p(2, j, k) - p(1, j, k) .GE. 0.) THEN
          abs1 = p(2, j, k) - p(1, j, k)
        ELSE
          abs1 = -(p(2, j, k)-p(1, j, k))
        END IF
        IF (p(1, j, k) - p(0, j, k) .GE. 0.) THEN
          abs7 = p(1, j, k) - p(0, j, k)
        ELSE
          abs7 = -(p(1, j, k)-p(0, j, k))
        END IF
        x1 = (p(2, j, k)-two*p(1, j, k)+p(0, j, k))/(omega*(p(2, j, k)+&
&          two*p(1, j, k)+p(0, j, k))+oneminomega*(abs1+abs7)+plim)
        IF (x1 .GE. 0.) THEN
          dp1 = x1
        ELSE
          dp1 = -x1
        END IF
! Loop in i-direction.
        DO i=1,il
          IF (p(i+2, j, k) - p(i+1, j, k) .GE. 0.) THEN
            abs2 = p(i+2, j, k) - p(i+1, j, k)
          ELSE
            abs2 = -(p(i+2, j, k)-p(i+1, j, k))
          END IF
          IF (p(i+1, j, k) - p(i, j, k) .GE. 0.) THEN
            abs8 = p(i+1, j, k) - p(i, j, k)
          ELSE
            abs8 = -(p(i+1, j, k)-p(i, j, k))
          END IF
          x2 = (p(i+2, j, k)-two*p(i+1, j, k)+p(i, j, k))/(omega*(p(i+2&
&            , j, k)+two*p(i+1, j, k)+p(i, j, k))+oneminomega*(abs2+abs8)&
&            +plim)
          IF (x2 .GE. 0.) THEN
            dp2 = x2
          ELSE
            dp2 = -x2
          END IF
! Compute the dissipation coefficients for this face.
          ppor = zero
          IF (pori(i, j, k) .EQ. normalflux) ppor = one
          IF (dp1 .LT. dp2) THEN
            y1 = dp2
          ELSE
            y1 = dp1
          END IF
          IF (dpmax .GT. y1) THEN
            min1 = y1
          ELSE
            min1 = dpmax
          END IF
          dis2 = ppor*fis2*min1
          dis4 = DIM_CD(ppor*fis4, dis2)
! Construct the vector of the first and third differences
! multiplied by the appropriate constants.
          ddw = w(i+1, j, k, irho) - w(i, j, k, irho)
          dr = dis2*ddw - dis4*(w(i+2, j, k, irho)-w(i-1, j, k, irho)-&
&            three*ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivx) - w(i, j, k, irho)*&
&            w(i, j, k, ivx)
          dru = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivx)-w(&
&            i-1, j, k, irho)*w(i-1, j, k, ivx)-three*ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivy) - w(i, j, k, irho)*&
&            w(i, j, k, ivy)
          drv = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivy)-w(&
&            i-1, j, k, irho)*w(i-1, j, k, ivy)-three*ddw)
          ddw = w(i+1, j, k, irho)*w(i+1, j, k, ivz) - w(i, j, k, irho)*&
&            w(i, j, k, ivz)
          drw = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, ivz)-w(&
&            i-1, j, k, irho)*w(i-1, j, k, ivz)-three*ddw)
          ddw = w(i+1, j, k, irhoe) - w(i, j, k, irhoe)
          dre = dis2*ddw - dis4*(w(i+2, j, k, irhoe)-w(i-1, j, k, irhoe)&
&            -three*ddw)
! In case a k-equation is present, compute the difference
! of rhok and store the average value of k. If not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          IF (correctfork) THEN
            ddw = w(i+1, j, k, irho)*w(i+1, j, k, itu1) - w(i, j, k, &
&              irho)*w(i, j, k, itu1)
            drk = dis2*ddw - dis4*(w(i+2, j, k, irho)*w(i+2, j, k, itu1)&
&              -w(i-1, j, k, irho)*w(i-1, j, k, itu1)-three*ddw)
            kavg = half*(w(i, j, k, itu1)+w(i+1, j, k, itu1))
          ELSE
            drk = zero
            kavg = zero
          END IF
! Compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i+1, j, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! Compute the average state at the interface.
          uavg = half*(w(i+1, j, k, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i+1, j, k, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i+1, j, k, ivz)+w(i, j, k, ivz))
          a2avg = half*(gamma(i+1, j, k)*p(i+1, j, k)/w(i+1, j, k, irho)&
&            +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          sx = si(i, j, k, 1)
          sy = si(i, j, k, 2)
          sz = si(i, j, k, 3)
          arg1 = sx**2 + sy**2 + sz**2
          area = SQRT(arg1)
          IF (1.e-25_realType .LT. area) THEN
            max1 = area
          ELSE
            max1 = 1.e-25_realType
          END IF
          tmp = one/max1
          sx = sx*tmp
          sy = sy*tmp
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          aavg = SQRT(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! The mesh velocity if the face is moving. It must be
! divided by the area to obtain a true velocity.
          IF (addgridvelocities) sface = sfacei(i, j, k)*tmp
          IF (unavg - sface + aavg .GE. 0.) THEN
            lam1 = unavg - sface + aavg
          ELSE
            lam1 = -(unavg-sface+aavg)
          END IF
          IF (unavg - sface - aavg .GE. 0.) THEN
            lam2 = unavg - sface - aavg
          ELSE
            lam2 = -(unavg-sface-aavg)
          END IF
          IF (unavg - sface .GE. 0.) THEN
            lam3 = unavg - sface
          ELSE
            lam3 = -(unavg-sface)
          END IF
          rrad = lam3 + aavg
          IF (lam1 .LT. epsacoustic*rrad) THEN
            lam1 = epsacoustic*rrad
          ELSE
            lam1 = lam1
          END IF
          IF (lam2 .LT. epsacoustic*rrad) THEN
            lam2 = epsacoustic*rrad
          ELSE
            lam2 = lam2
          END IF
          IF (lam3 .LT. epsshear*rrad) THEN
            lam3 = epsshear*rrad
          ELSE
            lam3 = lam3
          END IF
! Multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1 = lam1*area
          lam2 = lam2*area
          lam3 = lam3*area
! Some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&            *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! Compute and scatter the dissipative flux.
! Density.
          fs = lam3*dr + abv6
          fw(i+1, j, k, irho) = fw(i+1, j, k, irho) + fs
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
          ind = indfamilyi(i, j, k)
          massflowfamilydiss(ind, spectralsol) = massflowfamilydiss(ind&
&            , spectralsol) - factfamilyi(i, j, k)*fs
! X-momentum.
          fs = lam3*dru + uavg*abv6 + sx*abv7
          fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fs
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! Y-momentum.
          fs = lam3*drv + vavg*abv6 + sy*abv7
          fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fs
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! Z-momentum.
          fs = lam3*drw + wavg*abv6 + sz*abv7
          fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fs
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! Energy.
          fs = lam3*dre + havg*abv6 + unavg*abv7
          fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + fs
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! Set dp1 to dp2 for the next face.
          dp1 = dp2
        END DO
      END DO
    END DO
!
!      ******************************************************************
!      *                                                                *
!      * Dissipative fluxes in the j-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    DO k=2,kl
      DO i=2,il
        IF (p(i, 2, k) - p(i, 1, k) .GE. 0.) THEN
          abs3 = p(i, 2, k) - p(i, 1, k)
        ELSE
          abs3 = -(p(i, 2, k)-p(i, 1, k))
        END IF
        IF (p(i, 1, k) - p(i, 0, k) .GE. 0.) THEN
          abs9 = p(i, 1, k) - p(i, 0, k)
        ELSE
          abs9 = -(p(i, 1, k)-p(i, 0, k))
        END IF
        x3 = (p(i, 2, k)-two*p(i, 1, k)+p(i, 0, k))/(omega*(p(i, 2, k)+&
&          two*p(i, 1, k)+p(i, 0, k))+oneminomega*(abs3+abs9)+plim)
        IF (x3 .GE. 0.) THEN
          dp1 = x3
        ELSE
          dp1 = -x3
        END IF
! Loop in j-direction.
        DO j=1,jl
          IF (p(i, j+2, k) - p(i, j+1, k) .GE. 0.) THEN
            abs4 = p(i, j+2, k) - p(i, j+1, k)
          ELSE
            abs4 = -(p(i, j+2, k)-p(i, j+1, k))
          END IF
          IF (p(i, j+1, k) - p(i, j, k) .GE. 0.) THEN
            abs10 = p(i, j+1, k) - p(i, j, k)
          ELSE
            abs10 = -(p(i, j+1, k)-p(i, j, k))
          END IF
          x4 = (p(i, j+2, k)-two*p(i, j+1, k)+p(i, j, k))/(omega*(p(i, j&
&            +2, k)+two*p(i, j+1, k)+p(i, j, k))+oneminomega*(abs4+abs10)&
&            +plim)
          IF (x4 .GE. 0.) THEN
            dp2 = x4
          ELSE
            dp2 = -x4
          END IF
! Compute the dissipation coefficients for this face.
          ppor = zero
          IF (porj(i, j, k) .EQ. normalflux) ppor = one
          IF (dp1 .LT. dp2) THEN
            y2 = dp2
          ELSE
            y2 = dp1
          END IF
          IF (dpmax .GT. y2) THEN
            min2 = y2
          ELSE
            min2 = dpmax
          END IF
          dis2 = ppor*fis2*min2
          dis4 = DIM_CD(ppor*fis4, dis2)
! Construct the vector of the first and third differences
! multiplied by the appropriate constants.
          ddw = w(i, j+1, k, irho) - w(i, j, k, irho)
          dr = dis2*ddw - dis4*(w(i, j+2, k, irho)-w(i, j-1, k, irho)-&
&            three*ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivx) - w(i, j, k, irho)*&
&            w(i, j, k, ivx)
          dru = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivx)-w(&
&            i, j-1, k, irho)*w(i, j-1, k, ivx)-three*ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivy) - w(i, j, k, irho)*&
&            w(i, j, k, ivy)
          drv = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivy)-w(&
&            i, j-1, k, irho)*w(i, j-1, k, ivy)-three*ddw)
          ddw = w(i, j+1, k, irho)*w(i, j+1, k, ivz) - w(i, j, k, irho)*&
&            w(i, j, k, ivz)
          drw = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, ivz)-w(&
&            i, j-1, k, irho)*w(i, j-1, k, ivz)-three*ddw)
          ddw = w(i, j+1, k, irhoe) - w(i, j, k, irhoe)
          dre = dis2*ddw - dis4*(w(i, j+2, k, irhoe)-w(i, j-1, k, irhoe)&
&            -three*ddw)
! In case a k-equation is present, compute the difference
! of rhok and store the average value of k. If not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          IF (correctfork) THEN
            ddw = w(i, j+1, k, irho)*w(i, j+1, k, itu1) - w(i, j, k, &
&              irho)*w(i, j, k, itu1)
            drk = dis2*ddw - dis4*(w(i, j+2, k, irho)*w(i, j+2, k, itu1)&
&              -w(i, j-1, k, irho)*w(i, j-1, k, itu1)-three*ddw)
            kavg = half*(w(i, j, k, itu1)+w(i, j+1, k, itu1))
          ELSE
            drk = zero
            kavg = zero
          END IF
! Compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j+1, k)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! Compute the average state at the interface.
          uavg = half*(w(i, j+1, k, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i, j+1, k, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i, j+1, k, ivz)+w(i, j, k, ivz))
          a2avg = half*(gamma(i, j+1, k)*p(i, j+1, k)/w(i, j+1, k, irho)&
&            +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          sx = sj(i, j, k, 1)
          sy = sj(i, j, k, 2)
          sz = sj(i, j, k, 3)
          arg1 = sx**2 + sy**2 + sz**2
          area = SQRT(arg1)
          IF (1.e-25_realType .LT. area) THEN
            max2 = area
          ELSE
            max2 = 1.e-25_realType
          END IF
          tmp = one/max2
          sx = sx*tmp
          sy = sy*tmp
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          aavg = SQRT(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! The mesh velocity if the face is moving. It must be
! divided by the area to obtain a true velocity.
          IF (addgridvelocities) sface = sfacej(i, j, k)*tmp
          IF (unavg - sface + aavg .GE. 0.) THEN
            lam1 = unavg - sface + aavg
          ELSE
            lam1 = -(unavg-sface+aavg)
          END IF
          IF (unavg - sface - aavg .GE. 0.) THEN
            lam2 = unavg - sface - aavg
          ELSE
            lam2 = -(unavg-sface-aavg)
          END IF
          IF (unavg - sface .GE. 0.) THEN
            lam3 = unavg - sface
          ELSE
            lam3 = -(unavg-sface)
          END IF
          rrad = lam3 + aavg
          IF (lam1 .LT. epsacoustic*rrad) THEN
            lam1 = epsacoustic*rrad
          ELSE
            lam1 = lam1
          END IF
          IF (lam2 .LT. epsacoustic*rrad) THEN
            lam2 = epsacoustic*rrad
          ELSE
            lam2 = lam2
          END IF
          IF (lam3 .LT. epsshear*rrad) THEN
            lam3 = epsshear*rrad
          ELSE
            lam3 = lam3
          END IF
! Multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1 = lam1*area
          lam2 = lam2*area
          lam3 = lam3*area
! Some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&            *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! Compute and scatter the dissipative flux.
! Density.
          fs = lam3*dr + abv6
          fw(i, j+1, k, irho) = fw(i, j+1, k, irho) + fs
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
          ind = indfamilyj(i, j, k)
          massflowfamilydiss(ind, spectralsol) = massflowfamilydiss(ind&
&            , spectralsol) - factfamilyj(i, j, k)*fs
! X-momentum.
          fs = lam3*dru + uavg*abv6 + sx*abv7
          fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fs
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! Y-momentum.
          fs = lam3*drv + vavg*abv6 + sy*abv7
          fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fs
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! Z-momentum.
          fs = lam3*drw + wavg*abv6 + sz*abv7
          fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fs
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! Energy.
          fs = lam3*dre + havg*abv6 + unavg*abv7
          fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + fs
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! Set dp1 to dp2 for the next face.
          dp1 = dp2
        END DO
      END DO
    END DO
!
!      ******************************************************************
!      *                                                                *
!      * Dissipative fluxes in the k-direction.                         *
!      *                                                                *
!      ******************************************************************
!
    DO j=2,jl
      DO i=2,il
        IF (p(i, j, 2) - p(i, j, 1) .GE. 0.) THEN
          abs5 = p(i, j, 2) - p(i, j, 1)
        ELSE
          abs5 = -(p(i, j, 2)-p(i, j, 1))
        END IF
        IF (p(i, j, 1) - p(i, j, 0) .GE. 0.) THEN
          abs11 = p(i, j, 1) - p(i, j, 0)
        ELSE
          abs11 = -(p(i, j, 1)-p(i, j, 0))
        END IF
        x5 = (p(i, j, 2)-two*p(i, j, 1)+p(i, j, 0))/(omega*(p(i, j, 2)+&
&          two*p(i, j, 1)+p(i, j, 0))+oneminomega*(abs5+abs11)+plim)
        IF (x5 .GE. 0.) THEN
          dp1 = x5
        ELSE
          dp1 = -x5
        END IF
! Loop in k-direction.
        DO k=1,kl
          IF (p(i, j, k+2) - p(i, j, k+1) .GE. 0.) THEN
            abs6 = p(i, j, k+2) - p(i, j, k+1)
          ELSE
            abs6 = -(p(i, j, k+2)-p(i, j, k+1))
          END IF
          IF (p(i, j, k+1) - p(i, j, k) .GE. 0.) THEN
            abs12 = p(i, j, k+1) - p(i, j, k)
          ELSE
            abs12 = -(p(i, j, k+1)-p(i, j, k))
          END IF
          x6 = (p(i, j, k+2)-two*p(i, j, k+1)+p(i, j, k))/(omega*(p(i, j&
&            , k+2)+two*p(i, j, k+1)+p(i, j, k))+oneminomega*(abs6+abs12)&
&            +plim)
          IF (x6 .GE. 0.) THEN
            dp2 = x6
          ELSE
            dp2 = -x6
          END IF
! Compute the dissipation coefficients for this face.
          ppor = zero
          IF (pork(i, j, k) .EQ. normalflux) ppor = one
          IF (dp1 .LT. dp2) THEN
            y3 = dp2
          ELSE
            y3 = dp1
          END IF
          IF (dpmax .GT. y3) THEN
            min3 = y3
          ELSE
            min3 = dpmax
          END IF
          dis2 = ppor*fis2*min3
          dis4 = DIM_CD(ppor*fis4, dis2)
! Construct the vector of the first and third differences
! multiplied by the appropriate constants.
          ddw = w(i, j, k+1, irho) - w(i, j, k, irho)
          dr = dis2*ddw - dis4*(w(i, j, k+2, irho)-w(i, j, k-1, irho)-&
&            three*ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivx) - w(i, j, k, irho)*&
&            w(i, j, k, ivx)
          dru = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivx)-w(&
&            i, j, k-1, irho)*w(i, j, k-1, ivx)-three*ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivy) - w(i, j, k, irho)*&
&            w(i, j, k, ivy)
          drv = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivy)-w(&
&            i, j, k-1, irho)*w(i, j, k-1, ivy)-three*ddw)
          ddw = w(i, j, k+1, irho)*w(i, j, k+1, ivz) - w(i, j, k, irho)*&
&            w(i, j, k, ivz)
          drw = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, ivz)-w(&
&            i, j, k-1, irho)*w(i, j, k-1, ivz)-three*ddw)
          ddw = w(i, j, k+1, irhoe) - w(i, j, k, irhoe)
          dre = dis2*ddw - dis4*(w(i, j, k+2, irhoe)-w(i, j, k-1, irhoe)&
&            -three*ddw)
! In case a k-equation is present, compute the difference
! of rhok and store the average value of k. If not present,
! set both these values to zero, such that later on no
! decision needs to be made anymore.
          IF (correctfork) THEN
            ddw = w(i, j, k+1, irho)*w(i, j, k+1, itu1) - w(i, j, k, &
&              irho)*w(i, j, k, itu1)
            drk = dis2*ddw - dis4*(w(i, j, k+2, irho)*w(i, j, k+2, itu1)&
&              -w(i, j, k-1, irho)*w(i, j, k-1, itu1)-three*ddw)
            kavg = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
          ELSE
            drk = zero
            kavg = zero
          END IF
! Compute the average value of gamma and compute some
! expressions in which it occurs.
          gammaavg = half*(gamma(i, j, k+1)+gamma(i, j, k))
          gm1 = gammaavg - one
          ovgm1 = one/gm1
          gm53 = gammaavg - five*third
! Compute the average state at the interface.
          uavg = half*(w(i, j, k+1, ivx)+w(i, j, k, ivx))
          vavg = half*(w(i, j, k+1, ivy)+w(i, j, k, ivy))
          wavg = half*(w(i, j, k+1, ivz)+w(i, j, k, ivz))
          a2avg = half*(gamma(i, j, k+1)*p(i, j, k+1)/w(i, j, k+1, irho)&
&            +gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho))
          sx = sk(i, j, k, 1)
          sy = sk(i, j, k, 2)
          sz = sk(i, j, k, 3)
          arg1 = sx**2 + sy**2 + sz**2
          area = SQRT(arg1)
          IF (1.e-25_realType .LT. area) THEN
            max3 = area
          ELSE
            max3 = 1.e-25_realType
          END IF
          tmp = one/max3
          sx = sx*tmp
          sy = sy*tmp
          sz = sz*tmp
          alphaavg = half*(uavg**2+vavg**2+wavg**2)
          havg = alphaavg + ovgm1*(a2avg-gm53*kavg)
          aavg = SQRT(a2avg)
          unavg = uavg*sx + vavg*sy + wavg*sz
          ovaavg = one/aavg
          ova2avg = one/a2avg
! The mesh velocity if the face is moving. It must be
! divided by the area to obtain a true velocity.
          IF (addgridvelocities) sface = sfacek(i, j, k)*tmp
          IF (unavg - sface + aavg .GE. 0.) THEN
            lam1 = unavg - sface + aavg
          ELSE
            lam1 = -(unavg-sface+aavg)
          END IF
          IF (unavg - sface - aavg .GE. 0.) THEN
            lam2 = unavg - sface - aavg
          ELSE
            lam2 = -(unavg-sface-aavg)
          END IF
          IF (unavg - sface .GE. 0.) THEN
            lam3 = unavg - sface
          ELSE
            lam3 = -(unavg-sface)
          END IF
          rrad = lam3 + aavg
          IF (lam1 .LT. epsacoustic*rrad) THEN
            lam1 = epsacoustic*rrad
          ELSE
            lam1 = lam1
          END IF
          IF (lam2 .LT. epsacoustic*rrad) THEN
            lam2 = epsacoustic*rrad
          ELSE
            lam2 = lam2
          END IF
          IF (lam3 .LT. epsshear*rrad) THEN
            lam3 = epsshear*rrad
          ELSE
            lam3 = lam3
          END IF
! Multiply the eigenvalues by the area to obtain
! the correct values for the dissipation term.
          lam1 = lam1*area
          lam2 = lam2*area
          lam3 = lam3*area
! Some abbreviations, which occur quite often in the
! dissipation terms.
          abv1 = half*(lam1+lam2)
          abv2 = half*(lam1-lam2)
          abv3 = abv1 - lam3
          abv4 = gm1*(alphaavg*dr-uavg*dru-vavg*drv-wavg*drw+dre) - gm53&
&            *drk
          abv5 = sx*dru + sy*drv + sz*drw - unavg*dr
          abv6 = abv3*abv4*ova2avg + abv2*abv5*ovaavg
          abv7 = abv2*abv4*ovaavg + abv3*abv5
! Compute and scatter the dissipative flux.
! Density.
          fs = lam3*dr + abv6
          fw(i, j, k+1, irho) = fw(i, j, k+1, irho) + fs
          fw(i, j, k, irho) = fw(i, j, k, irho) - fs
          ind = indfamilyk(i, j, k)
          massflowfamilydiss(ind, spectralsol) = massflowfamilydiss(ind&
&            , spectralsol) - factfamilyk(i, j, k)*fs
! X-momentum.
          fs = lam3*dru + uavg*abv6 + sx*abv7
          fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fs
          fw(i, j, k, imx) = fw(i, j, k, imx) - fs
! Y-momentum.
          fs = lam3*drv + vavg*abv6 + sy*abv7
          fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fs
          fw(i, j, k, imy) = fw(i, j, k, imy) - fs
! Z-momentum.
          fs = lam3*drw + wavg*abv6 + sz*abv7
          fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fs
          fw(i, j, k, imz) = fw(i, j, k, imz) - fs
! Energy.
          fs = lam3*dre + havg*abv6 + unavg*abv7
          fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + fs
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - fs
! Set dp1 to dp2 for the next face.
          dp1 = dp2
        END DO
      END DO
    END DO
  END IF
END SUBROUTINE INVISCIDDISSFLUXMATRIX_CD

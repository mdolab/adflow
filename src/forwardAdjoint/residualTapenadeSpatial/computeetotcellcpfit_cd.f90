!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!      ==================================================================
SUBROUTINE COMPUTEETOTCELLCPFIT_CD(i, j, k, scale, correctfork)
  USE CPCURVEFITS_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * ComputeEtotCellCpfit will compute the total energy for the     *
!      * given cell of the block given by the current pointers with the *
!      * cp temperature curve fit model.                                *
!      *                                                                *
!      ******************************************************************
!
!
!      Local parameter.
!
  REAL(kind=realtype), PARAMETER :: twothird=two*third
!
!      Subroutine arguments.
!
  INTEGER(kind=inttype), INTENT(IN) :: i, j, k
  REAL(kind=realtype), INTENT(IN) :: scale
  LOGICAL, INTENT(IN) :: correctfork
!
!      Local variables.
!
  INTEGER(kind=inttype) :: nn, mm, ii, start
  REAL(kind=realtype) :: pp, t, t2, cv, eint
  INTRINSIC LOG
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Compute the dimensional temperature.
  pp = p(i, j, k)
  IF (correctfork) pp = pp - twothird*w(i, j, k, irho)*w(i, j, k, itu1)
  t = tref*pp/(rgas*w(i, j, k, irho))
! Determine the case we are having here.
  IF (t .LE. cptrange(0)) THEN
! Temperature is less than the smallest temperature
! in the curve fits. Use extrapolation using
! constant cv.
    eint = scale*(cpeint(0)+cv0*(t-cptrange(0)))
    gamma(i, j, k) = (cv0+one)/cv0
  ELSE IF (t .GE. cptrange(cpnparts)) THEN
! Temperature is larger than the largest temperature
! in the curve fits. Use extrapolation using
! constant cv.
    eint = scale*(cpeint(cpnparts)+cvn*(t-cptrange(cpnparts)))
    gamma(i, j, k) = (cvn+one)/cvn
  ELSE
! Temperature is in the curve fit range.
! First find the valid range.
    ii = cpnparts
    start = 1
interval:DO 
! Next guess for the interval.
      nn = start + ii/2
! Determine the situation we are having here.
      IF (t .GT. cptrange(nn)) THEN
! Temperature is larger than the upper boundary of
! the current interval. Update the lower boundary.
        start = nn + 1
        ii = ii - 1
      ELSE IF (t .GE. cptrange(nn-1)) THEN
! Nn contains the correct curve fit interval.
! Integrate cv to compute eint.
        eint = cptempfit(nn)%eint0 - t
        cv = -one
        DO ii=1,cptempfit(nn)%nterm
          t2 = t**cptempfit(nn)%exponents(ii)
          cv = cv + cptempfit(nn)%constants(ii)*t2
          IF (cptempfit(nn)%exponents(ii) .EQ. -1_intType) THEN
            eint = eint + cptempfit(nn)%constants(ii)*LOG(t)
          ELSE
            mm = cptempfit(nn)%exponents(ii) + 1
            t2 = t*t2
            eint = eint + cptempfit(nn)%constants(ii)*t2/mm
          END IF
        END DO
        eint = scale*eint
        gamma(i, j, k) = (cv+one)/cv
        GOTO 100
      END IF
! This is the correct range. Exit the do-loop.
! Modify ii for the next branch to search.
      ii = ii/2
    END DO interval
  END IF
! Compute the total energy per unit volume.
 100 w(i, j, k, irhoe) = w(i, j, k, irho)*(eint+half*(w(i, j, k, ivx)**2&
&    +w(i, j, k, ivy)**2+w(i, j, k, ivz)**2))
  IF (correctfork) w(i, j, k, irhoe) = w(i, j, k, irhoe) + w(i, j, k, &
&      irho)*w(i, j, k, itu1)
END SUBROUTINE COMPUTEETOTCELLCPFIT_CD

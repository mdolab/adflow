!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          cgnsGrid.f90                                    *
!      * Author:        Edwin van der Weide, Steve Repsher,             *
!      *                Seonghyeon Hahn                                 *
!      * Starting date: 12-17-2002                                      *
!      * Last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
MODULE CGNSGRID_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * This module contains the derived data type for storing the     *
!      * information of the original cgns grid file. Information stored *
!      * is number of blocks, block sizes, zone names, etc. this info   *
!      * is needed again when the solution is written to file. Remember *
!      * that the original blocks may be split to obtain a better       *
!      * load balance. Note that this info is stored on all processors. *
!      *                                                                *
!      * Apart from the derived data type for the cgns blocks, this     *
!      * module also contains the name of the base and the physical     *
!      * dimensions of the problem.                                     *
!      *                                                                *
!      ******************************************************************
!
  SAVE 
! The units in which the data is specified.
! The name of the array.
! Number of dimensions for which the data is specified.
! Number of data points of every dimensions. upper limit is
! three, although for BC data the maximum is usually 2.
! The actual data. Assumed is that only floating point data
! is prescribed and not integer or character data. Note that
! dataArr is a 1D array even if the data is multi-dimensional.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived datatype to store the actual     *
!      * data of the boundary conditions.                               *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSBCDATAARRAY
      INTEGER :: mass, len, time, temp, angle
      CHARACTER(len=maxcgnsnamelen) :: arrayname
      INTEGER :: ndimensions
      INTEGER(kind=inttype), DIMENSION(3) :: datadim
      REAL(kind=realtype), DIMENSION(:), POINTER :: dataarr
  END TYPE CGNSBCDATAARRAY
! Name of the dataset.
! Boundary condition type.
! The number of Dirichlet arrays in the data set.
! The number of Neumann arrays in the data set.
! The Dirichlet arrays.
!type(cgnsBCDataArray), pointer, dimension(:) :: dirichletArrays
! The Neumann arrays.
!type(cgnsBCDataArray), pointer, dimension(:) :: neumannArrays
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived datatype to store the prescribed *
!      * boundary data for a boundary subface.                          *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSBCDATASETTYPE
      CHARACTER(len=maxcgnsnamelen) :: datasetname
      INTEGER :: bctype
      INTEGER(kind=inttype) :: ndirichletarrays
      INTEGER(kind=inttype) :: nneumannarrays
  END TYPE CGNSBCDATASETTYPE
! Name of the interface.
! Name of the zone/block interfacing with the current zone/block.
! Zone/block ID of the zone/block interfacing with the current
! zone/block.
! Range of points of this subface.
! Range of points for the donor block.
! Short hand notation defining the relative orientation of the
! two zones.
! Whether or not the subface is a periodic boundary.
! The center of rotation for a periodic boundary.
! The rotation angles for a periodic boundary.
! The translation vector for a periodic boundary.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type to store cgns 1 to 1   *
!      * block to block, i.e. continuous grid lines across block        *
!      * boundaries, connectivities.                                    *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNS1TO1CONNTYPE
      CHARACTER(len=maxcgnsnamelen) :: connectname
      CHARACTER(len=maxcgnsnamelen) :: donorname
      INTEGER(kind=inttype) :: donorblock
      INTEGER(kind=inttype) :: ibeg, jbeg, kbeg
      INTEGER(kind=inttype) :: iend, jend, kend
      INTEGER(kind=inttype) :: dibeg, djbeg, dkbeg
      INTEGER(kind=inttype) :: diend, djend, dkend
      INTEGER(kind=inttype) :: l1, l2, l3
      LOGICAL :: periodic
      REAL(kind=realtype), DIMENSION(3) :: rotationcenter
      REAL(kind=realtype), DIMENSION(3) :: rotationangles
      REAL(kind=realtype), DIMENSION(3) :: translation
  END TYPE CGNS1TO1CONNTYPE
! Number of donor blocks. It is possible that the subface
! abuts multiple donor blocks.
! Names of the interfaces. Dimension [nDonorBlocks].
! Names of the zone/block interfacing with the current
! zone/block. Dimension [nDonorBlocks].
! Zone/block IDs of the zones/blocks interfacing with the
! current zone/block. Dimension [nDonorBlocks].
! Range of points of this subface.
! Block face IDs of the donor blocks, which abut this subface.
! Dimension [nDonorBlocks].
! Whether or not the subface is a periodic boundary.
! The center of rotation for a periodic boundary.
! The rotation angles for a periodic boundary.
! The translation vector for a periodic boundary.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type to store cgns          *
!      * non-matching abutting block to block connectivities.           *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSNONMATCHABUTTINGCONNTYPE
      INTEGER(kind=inttype) :: ndonorblocks
      CHARACTER(len=maxcgnsnamelen), DIMENSION(:), POINTER :: &
&      connectnames
      CHARACTER(len=maxcgnsnamelen), DIMENSION(:), POINTER :: donornames
      INTEGER(kind=inttype), DIMENSION(:), POINTER :: donorblocks
      INTEGER(kind=inttype) :: ibeg, jbeg, kbeg
      INTEGER(kind=inttype) :: iend, jend, kend
      INTEGER(kind=inttype), DIMENSION(:), POINTER :: donorfaceids
      LOGICAL :: periodic
      REAL(kind=realtype), DIMENSION(3) :: rotationcenter
      REAL(kind=realtype), DIMENSION(3) :: rotationangles
      REAL(kind=realtype), DIMENSION(3) :: translation
  END TYPE CGNSNONMATCHABUTTINGCONNTYPE
! Name of the interface.
! Name of the zone/block interfacing with the current zone/block.
! Zone/block id of the zone/block interfacing with the current
! zone/block.
! Number of points to be interpolated (should equal the
! number of points in the donor list.
! Indices for this block to be interpolated.
! [dimension(3,npnts)]
! Indices for donor block that provide information.
! [dimension(3,npnts)]
! Interpolation weights for the donor stencil
! [dimension(3,npnts)]
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type to store cgns overset  *
!      * connectivity (i.e. overlapping grids to be handled via the     *
!      * chimera approach).                                             *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSOVERSETCONNTYPE
      CHARACTER(len=maxcgnsnamelen) :: connectname
      CHARACTER(len=maxcgnsnamelen) :: donorname
      INTEGER(kind=inttype) :: donorblock
      INTEGER(kind=inttype) :: npnts
      INTEGER(kind=inttype), DIMENSION(:, :), POINTER :: ibndry
      INTEGER(kind=inttype), DIMENSION(:, :), POINTER :: idonor
      REAL(kind=realtype), DIMENSION(:, :), POINTER :: interp
  END TYPE CGNSOVERSETCONNTYPE
! Name of the interface.
! Number of points in this hole set.
! Indices for the hole points.
! [dimension(3,npnts)]
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type to store cgns overset  *
!      * holes. (these points are grouped together and ignored when     *
!      * calculating residuals).                                        *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSHOLESTYPE
      CHARACTER(len=maxcgnsnamelen) :: holename
      INTEGER(kind=inttype) :: npnts
      INTEGER(kind=inttype), DIMENSION(:, :), POINTER :: indices
  END TYPE CGNSHOLESTYPE
! Name of the boundary condition.
! CGNS and internal boundary condition type.
! Name of the CGNS user defined data node if the CGNS
! boundary condition is UserDefined.
! The way the boundary condition faces are specified; either
! a point range or an individual set of points.
! Number of points in the boundary condition set defining this
! boundary region. For a point range this is 2.
! Index vector indicating the computational coordinate
! direction of the boundary condition patch normal.
! A flag indicating whether or not boundary normals are defined.
! normalListFlag == 0: normals are not defined.
! normalListFlag == 1: normals are defined.
! Data type used for the definition of the normals. Admissible
! types are realSingle and realDouble.
! Corresponding family number. If the face does not belong to
! a family this value is 0.
! The number of the sliding mesh interface of which this
! boco is part. 0 means that this family is not part of a
! sliding mesh interface. This value can be positive and
! negative in order to distinguish between the two sides of the
! interface. The absolute value is the actual ID of the
! interface.
! Number of boundary condition datasets for the current
! boundary condition.
! The actual boundary condition data sets.
!type(cgnsBCDatasetType), pointer, dimension(:) :: dataSet
! Whether or not I actually allocated the memory for data_set.
! It is possible that data_set points to corresponding entry
! of a family.
! The rotation center and rotation rate of the boundary face.
! It is possible that this differs from the rotation rate of
! the corresponding block, e.g. for a casing in a
! turbomachinery problem.
! Range of points of this subface.
! Whether or not this subface is an actual face. Some mesh
! generators (such as ICEM CFD hexa) include edges and points
! as boundary conditions. These should not be considered by
! the flow solver. in those cases, actual_face is .false.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type to store cgns block    *
!      * boundary conditions.                                           *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSBOCOTYPE
      CHARACTER(len=maxcgnsnamelen) :: boconame
      INTEGER :: bctypecgns
      INTEGER(kind=inttype) :: bctype
      CHARACTER(len=maxcgnsnamelen) :: userdefinedname
      INTEGER :: ptsettype
      INTEGER(kind=inttype) :: npnts
      INTEGER :: normalindex
      INTEGER :: normallistflag
      INTEGER :: normaldatatype
      INTEGER(kind=inttype) :: familyid
      INTEGER(kind=inttype) :: slidingid
      INTEGER(kind=inttype) :: ndataset
      LOGICAL :: datasetallocated
      REAL(kind=realtype), DIMENSION(3) :: rotcenter, rotrate
      INTEGER(kind=inttype) :: ibeg, jbeg, kbeg
      INTEGER(kind=inttype) :: iend, jend, kend
      LOGICAL :: actualface
  END TYPE CGNSBOCOTYPE
!
!        ****************************************************************
!        *                                                              *
!        * Information read from the cgns file.                         *
!        *                                                              *
!        ****************************************************************
!
! The type of the zone. Should be structured. Note that this
! is an integer and not integer(kind=intType).
! Zone name for this block.
! The number or subblocks and the processor ID's on which they
! are stored. Due to the possibility of splitting the block
! during runtime, multiple processors could store a part of
! the block.
! The local block ID's of the subblocks.
! The corresponding nodal ranges of the subblocks.
! The units in which the grid is specified.
! Whether or not grid units are specified.
! The conversion factor to meters for this block.
! Corresponding family number. If the block does not belong to
! a family this value is 0.
! Nodal block dimensions.
! Cell block dimensions.
! Total number of 1 to 1 block to block connectivities, i.e.
! continous grid lines, for this block. Also the number of
! 1 to 1 connectivities stored in general connectivity nodes
! is incorporated in n1to1.
! Number of 1 to 1 block to block connectivities stored in
! general connectivities.
! Array of 1 to 1 block to block connectivities.
!type(cgns1to1ConnType), pointer, dimension(:) :: conn1to1
! Number of non-matching abutting block to block
! connectivities.
! Array of non-matching abutting block to block connectivities.
!type(cgnsNonMatchAbuttingConnType), pointer, dimension(:) :: &
!                                          connNonMatchAbutting
! Number of overset block to block connectivities, and the
! total number of overset boundary cells.
! Array of overset block to block connectivities.
!type(cgnsOversetConnType), pointer, dimension(:) :: connOver
! Number of overset hole sets for this block.
! Array of overset hole sets.
!type(cgnsHolesType), pointer, dimension(:) :: hole
! Number of boundary conditions for this block.
! Array of boundary conditions.
!type(cgnsBocoType), pointer, dimension(:) :: bocoInfo
! Whether or not a rotating frame is specified.
! The corresponding rotation center and rotation rate.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type to store the data of a *
!      * cgns block.                                                    *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSBLOCKINFOTYPE
      INTEGER :: zonetype
      CHARACTER(len=maxcgnsnamelen) :: zonename
      INTEGER :: nsubblocks
      INTEGER, DIMENSION(:), POINTER :: procstored
      INTEGER, DIMENSION(:), POINTER :: localblockid
      INTEGER, DIMENSION(:), POINTER :: ibegor, jbegor, kbegor
      INTEGER, DIMENSION(:), POINTER :: iendor, jendor, kendor
      INTEGER :: mass, len, time, temp, angle
      LOGICAL :: gridunitsspecified
      REAL(kind=realtype) :: lref
      INTEGER(kind=inttype) :: familyid
      INTEGER(kind=inttype) :: il, jl, kl
      INTEGER(kind=inttype) :: nx, ny, nz
      INTEGER(kind=inttype) :: n1to1
      INTEGER(kind=inttype) :: n1to1general
      INTEGER(kind=inttype) :: nnonmatchabutting
      INTEGER(kind=inttype) :: noverset, ncellsoverset
      INTEGER(kind=inttype) :: nholes
      INTEGER(kind=inttype) :: nbocos
      LOGICAL :: rotatingframespecified
      REAL(kind=realtype), DIMENSION(3) :: rotcenter, rotrate
  END TYPE CGNSBLOCKINFOTYPE
! Name of the family.
! Type of the boundary condition and family BC name.
! Name of the CGNS user defined data node if the CGNS
! boundary condition is UserDefined.
! The number of the sliding mesh interface of which this
! family is part. 0 means that this family is not part of a
! sliding mesh interface. This value can be positive and
! negative in order to distinguish between the two sides of the
! interface. The absolute value is the actual ID of the
! interface.
! The number of the bleed flow region of which this family is
! part. 0 means that this family does not belong to a bleed
! flow region. There is no need to distinguish between an
! inflow and an outflow bleed, because they have different
! boundary conditions.
! Whether or not the mass flow must be monitored for this family.
! Number of boundary condition datasets for this family.
! The actual boundary condition data sets.
!type(cgnsBCDatasetType), pointer, dimension(:) :: dataSet
! Whether or not a rotating frame is specified.
! The corresponding rotation center and rotation rate.
!
!      ******************************************************************
!      *                                                                *
!      * The definition of the derived data type to store the data of a *
!      * cgns family.                                                   *
!      *                                                                *
!      ******************************************************************
!
  TYPE CGNSFAMILYTYPE
      CHARACTER(len=maxcgnsnamelen) :: familyname
      INTEGER :: bctypecgns
      INTEGER(kind=inttype) :: bctype
      CHARACTER(len=maxcgnsnamelen) :: bcname
      CHARACTER(len=maxcgnsnamelen) :: userdefinedname
      INTEGER(kind=inttype) :: slidingid
      INTEGER(kind=inttype) :: bleedregionid
      LOGICAL :: monitormassflow
      INTEGER(kind=inttype) :: ndataset
      LOGICAL :: rotatingframespecified
      REAL(kind=realtype), DIMENSION(3) :: rotcenter, rotrate
  END TYPE CGNSFAMILYTYPE
!
!      ******************************************************************
!      *                                                                *
!      * Definition of the variables stored in this module.             *
!      *                                                                *
!      ******************************************************************
!
! Dimensions of the cell and of the physical dimensions.
! Both should be 3 for this code. Note that these are integers
! and not integers(kind=intType).
  INTEGER :: cgnscelldim, cgnsphysdim
! Number of blocks (zones) in the cgns grid.
  INTEGER(kind=inttype) :: cgnsndom
! Array of cgns blocks.
  TYPE(CGNSBLOCKINFOTYPE), DIMENSION(:), ALLOCATABLE :: cgnsdoms
  TYPE(CGNSBLOCKINFOTYPE), DIMENSION(:), ALLOCATABLE :: cgnsdomsd
! Number of families in the cgns grid.
  INTEGER(kind=inttype) :: cgnsnfamilies
! Array of families.
!type(cgnsFamilyType), allocatable, dimension(:) :: cgnsFamilies
! Number of sliding mesh interfaces in the grid.
  INTEGER(kind=inttype) :: cgnsnsliding
! The corresponding family ID's of the sliding interfaces.
  INTEGER(kind=inttype), DIMENSION(:, :), ALLOCATABLE :: famidssliding
! Number of domain interfaces, i.e. interfaces with other CFD
! codes, in the grid.
  INTEGER(kind=inttype) :: cgnsndomaininterfaces
! The family and BC ID's of the domain interfaces.
  INTEGER(kind=inttype), DIMENSION(:), ALLOCATABLE :: &
&  famidsdomaininterfaces
  INTEGER(kind=inttype), DIMENSION(:, :), ALLOCATABLE :: &
&  bcidsdomaininterfaces
! Name of the cgns base.
  CHARACTER(len=maxcgnsnamelen) :: cgnsbasename
! Whether or not there are overset grids present.
  LOGICAL :: oversetpresent
! massFlowFamilyInv(:,:):  Array to store the local contributions
!                          from the central part of the flux to
!                          the mass flow of a family and the
!                          sliding mesh interfaces. Dimension is
!                          (0:nn,nTimeIntervalsSpectral, where
!                          nn is the number of families for which
!                          the mass flow must be monitored plus
!                          2*cgnsNSliding (if the mass flow through
!                          the sliding interfaces must be monitored).
!                          The reason for 2*cgnsNSliding is that each
!                          side of a sliding interface is monitored.
!                          The first index starts at 0 to store
!                          all the faces that are not on a
!                          sliding interface.
! massFlowFamilyDiss(:,:): Idem for the dissipative part.
  REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: massflowfamilyinv
  REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: &
&  massflowfamilyinvd
  REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: &
&  massflowfamilydiss
  REAL(kind=realtype), DIMENSION(:, :), ALLOCATABLE :: &
&  massflowfamilydissd
END MODULE CGNSGRID_SPATIAL_D

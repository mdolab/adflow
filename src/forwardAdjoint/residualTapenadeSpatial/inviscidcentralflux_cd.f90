!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          inviscidCentralFlux.f90                         *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-24-2003                                      *
!      * Last modified: 10-29-2007                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE INVISCIDCENTRALFLUX_CD()
  USE INPUTPHYSICS_SPATIAL_D
  USE CGNSGRID_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!write(14,40),i,j,k,dw(i,j,k,imx)
!
!      ******************************************************************
!      *                                                                *
!      * inviscidCentralFlux computes the Euler fluxes using a central  *
!      * discretization for a given block. Therefore it is assumed that *
!      * the pointers in block pointer already point to the correct     *
!      * block on the correct multigrid level.                          *
!      *                                                                *
!      ******************************************************************
!
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, k, ind
  REAL(kind=realtype) :: qsp, qsm, rqsp, rqsm, porvel, porflux
  REAL(kind=realtype) :: pa, fs, sface, vnp, vnm
  REAL(kind=realtype) :: wx, wy, wz, rvol
  sface = zero
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the i-direction.                           *
!      *                                                                *
!      ******************************************************************
!
  DO k=2,kl
    DO j=2,jl
      DO i=1,il
! Set the dot product of the grid velocity and the
! normal in i-direction for a moving face.
        IF (addgridvelocities) sface = sfacei(i, j, k)
! Compute the normal velocities of the left and right state.
        vnp = w(i+1, j, k, ivx)*si(i, j, k, 1) + w(i+1, j, k, ivy)*si(i&
&          , j, k, 2) + w(i+1, j, k, ivz)*si(i, j, k, 3)
        vnm = w(i, j, k, ivx)*si(i, j, k, 1) + w(i, j, k, ivy)*si(i, j, &
&          k, 2) + w(i, j, k, ivz)*si(i, j, k, 3)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
        porvel = one
        porflux = half
        IF (pori(i, j, k) .EQ. noflux) porflux = zero
        IF (pori(i, j, k) .EQ. boundflux) THEN
          porvel = zero
          vnp = sface
          vnm = sface
        END IF
! Incorporate porFlux in porVel.
        porvel = porvel*porflux
! Compute the normal velocities relative to the grid for
! the face as well as the mass fluxes.
        qsp = (vnp-sface)*porvel
        qsm = (vnm-sface)*porvel
        rqsp = qsp*w(i+1, j, k, irho)
        rqsm = qsm*w(i, j, k, irho)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
        pa = porflux*(p(i+1, j, k)+p(i, j, k))
! Compute the fluxes and scatter them to the cells
! i,j,k and i+1,j,k. Store the density flux in the
! mass flow of the appropriate sliding mesh interface.
        fs = rqsp + rqsm
        dw(i+1, j, k, irho) = dw(i+1, j, k, irho) - fs
        dw(i, j, k, irho) = dw(i, j, k, irho) + fs
        ind = indfamilyi(i, j, k)
        massflowfamilyinv(ind, spectralsol) = massflowfamilyinv(ind, &
&          spectralsol) + factfamilyi(i, j, k)*fs
        fs = rqsp*w(i+1, j, k, ivx) + rqsm*w(i, j, k, ivx) + pa*si(i, j&
&          , k, 1)
        dw(i+1, j, k, imx) = dw(i+1, j, k, imx) - fs
        dw(i, j, k, imx) = dw(i, j, k, imx) + fs
        fs = rqsp*w(i+1, j, k, ivy) + rqsm*w(i, j, k, ivy) + pa*si(i, j&
&          , k, 2)
        dw(i+1, j, k, imy) = dw(i+1, j, k, imy) - fs
        dw(i, j, k, imy) = dw(i, j, k, imy) + fs
        fs = rqsp*w(i+1, j, k, ivz) + rqsm*w(i, j, k, ivz) + pa*si(i, j&
&          , k, 3)
        dw(i+1, j, k, imz) = dw(i+1, j, k, imz) - fs
        dw(i, j, k, imz) = dw(i, j, k, imz) + fs
        fs = qsp*w(i+1, j, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&          vnp*p(i+1, j, k)+vnm*p(i, j, k))
        dw(i+1, j, k, irhoe) = dw(i+1, j, k, irhoe) - fs
        dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
      END DO
    END DO
  END DO
!write(14,40),i,j,k,dw(i,j,k,irhoE)
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the j-direction.                           *
!      *                                                                *
!      ******************************************************************
!
  DO k=2,kl
    DO j=1,jl
      DO i=2,il
! Set the dot product of the grid velocity and the
! normal in j-direction for a moving face.
        IF (addgridvelocities) sface = sfacej(i, j, k)
! Compute the normal velocities of the left and right state.
        vnp = w(i, j+1, k, ivx)*sj(i, j, k, 1) + w(i, j+1, k, ivy)*sj(i&
&          , j, k, 2) + w(i, j+1, k, ivz)*sj(i, j, k, 3)
        vnm = w(i, j, k, ivx)*sj(i, j, k, 1) + w(i, j, k, ivy)*sj(i, j, &
&          k, 2) + w(i, j, k, ivz)*sj(i, j, k, 3)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
        porvel = one
        porflux = half
        IF (porj(i, j, k) .EQ. noflux) porflux = zero
        IF (porj(i, j, k) .EQ. boundflux) THEN
          porvel = zero
          vnp = sface
          vnm = sface
        END IF
! Incorporate porFlux in porVel.
        porvel = porvel*porflux
! Compute the normal velocities for the face as well as the
! mass fluxes.
        qsp = (vnp-sface)*porvel
        qsm = (vnm-sface)*porvel
        rqsp = qsp*w(i, j+1, k, irho)
        rqsm = qsm*w(i, j, k, irho)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
        pa = porflux*(p(i, j+1, k)+p(i, j, k))
! Compute the fluxes and scatter them to the cells
! i,j,k and i,j+1,k. Store the density flux in the
! mass flow of the appropriate sliding mesh interface.
        fs = rqsp + rqsm
        dw(i, j+1, k, irho) = dw(i, j+1, k, irho) - fs
        dw(i, j, k, irho) = dw(i, j, k, irho) + fs
        ind = indfamilyj(i, j, k)
        massflowfamilyinv(ind, spectralsol) = massflowfamilyinv(ind, &
&          spectralsol) + factfamilyj(i, j, k)*fs
        fs = rqsp*w(i, j+1, k, ivx) + rqsm*w(i, j, k, ivx) + pa*sj(i, j&
&          , k, 1)
        dw(i, j+1, k, imx) = dw(i, j+1, k, imx) - fs
        dw(i, j, k, imx) = dw(i, j, k, imx) + fs
        fs = rqsp*w(i, j+1, k, ivy) + rqsm*w(i, j, k, ivy) + pa*sj(i, j&
&          , k, 2)
        dw(i, j+1, k, imy) = dw(i, j+1, k, imy) - fs
        dw(i, j, k, imy) = dw(i, j, k, imy) + fs
        fs = rqsp*w(i, j+1, k, ivz) + rqsm*w(i, j, k, ivz) + pa*sj(i, j&
&          , k, 3)
        dw(i, j+1, k, imz) = dw(i, j+1, k, imz) - fs
        dw(i, j, k, imz) = dw(i, j, k, imz) + fs
        fs = qsp*w(i, j+1, k, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&          vnp*p(i, j+1, k)+vnm*p(i, j, k))
        dw(i, j+1, k, irhoe) = dw(i, j+1, k, irhoe) - fs
        dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
      END DO
    END DO
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Advective fluxes in the k-direction.                           *
!      *                                                                *
!      ******************************************************************
!
  DO k=1,kl
    DO j=2,jl
      DO i=2,il
! Set the dot product of the grid velocity and the
! normal in k-direction for a moving face.
        IF (addgridvelocities) sface = sfacek(i, j, k)
! Compute the normal velocities of the left and right state.
        vnp = w(i, j, k+1, ivx)*sk(i, j, k, 1) + w(i, j, k+1, ivy)*sk(i&
&          , j, k, 2) + w(i, j, k+1, ivz)*sk(i, j, k, 3)
        vnm = w(i, j, k, ivx)*sk(i, j, k, 1) + w(i, j, k, ivy)*sk(i, j, &
&          k, 2) + w(i, j, k, ivz)*sk(i, j, k, 3)
! Set the values of the porosities for this face.
! porVel defines the porosity w.r.t. velocity;
! porFlux defines the porosity w.r.t. the entire flux.
! The latter is only zero for a discontinuous block
! block boundary that must be treated conservatively.
! The default value of porFlux is 0.5, such that the
! correct central flux is scattered to both cells.
! In case of a boundFlux the normal velocity is set
! to sFace.
        porvel = one
        porflux = half
        IF (pork(i, j, k) .EQ. noflux) porflux = zero
        IF (pork(i, j, k) .EQ. boundflux) THEN
          porvel = zero
          vnp = sface
          vnm = sface
        END IF
! Incorporate porFlux in porVel.
        porvel = porvel*porflux
! Compute the normal velocities for the face as well as the
! mass fluxes.
        qsp = (vnp-sface)*porvel
        qsm = (vnm-sface)*porvel
        rqsp = qsp*w(i, j, k+1, irho)
        rqsm = qsm*w(i, j, k, irho)
! Compute the sum of the pressure multiplied by porFlux.
! For the default value of porFlux, 0.5, this leads to
! the average pressure.
        pa = porflux*(p(i, j, k+1)+p(i, j, k))
! Compute the fluxes and scatter them to the cells
! i,j,k and i,j,k+1. Store the density flux in the
! mass flow of the appropriate sliding mesh interface.
        fs = rqsp + rqsm
        dw(i, j, k+1, irho) = dw(i, j, k+1, irho) - fs
        dw(i, j, k, irho) = dw(i, j, k, irho) + fs
        ind = indfamilyk(i, j, k)
        massflowfamilyinv(ind, spectralsol) = massflowfamilyinv(ind, &
&          spectralsol) + factfamilyk(i, j, k)*fs
        fs = rqsp*w(i, j, k+1, ivx) + rqsm*w(i, j, k, ivx) + pa*sk(i, j&
&          , k, 1)
        dw(i, j, k+1, imx) = dw(i, j, k+1, imx) - fs
        dw(i, j, k, imx) = dw(i, j, k, imx) + fs
        fs = rqsp*w(i, j, k+1, ivy) + rqsm*w(i, j, k, ivy) + pa*sk(i, j&
&          , k, 2)
        dw(i, j, k+1, imy) = dw(i, j, k+1, imy) - fs
        dw(i, j, k, imy) = dw(i, j, k, imy) + fs
        fs = rqsp*w(i, j, k+1, ivz) + rqsm*w(i, j, k, ivz) + pa*sk(i, j&
&          , k, 3)
        dw(i, j, k+1, imz) = dw(i, j, k+1, imz) - fs
        dw(i, j, k, imz) = dw(i, j, k, imz) + fs
        fs = qsp*w(i, j, k+1, irhoe) + qsm*w(i, j, k, irhoe) + porflux*(&
&          vnp*p(i, j, k+1)+vnm*p(i, j, k))
        dw(i, j, k+1, irhoe) = dw(i, j, k+1, irhoe) - fs
        dw(i, j, k, irhoe) = dw(i, j, k, irhoe) + fs
      END DO
    END DO
  END DO
!write(14,40),i,j,k,dw(i,j,k,irhoE)
! Add the rotational source terms for a moving block in a
! steady state computation. These source terms account for the
! centrifugal acceleration and the coriolis term. However, as
! the the equations are solved in the inertial frame and not
! in the moving frame, the form is different than what you
! normally find in a text book.
  IF (blockismoving .AND. equationmode .EQ. steady) THEN
! Compute the three nonDimensional angular velocities.
    wx = timeref*cgnsdoms(nbkglobal)%rotrate(1)
    wy = timeref*cgnsdoms(nbkglobal)%rotrate(2)
    wz = timeref*cgnsdoms(nbkglobal)%rotrate(3)
! Loop over the internal cells of this block to compute the
! rotational terms for the momentum equations.
    DO k=2,kl
      DO j=2,jl
        DO i=2,il
          rvol = w(i, j, k, irho)*vol(i, j, k)
          dw(i, j, k, imx) = dw(i, j, k, imx) + rvol*(wy*w(i, j, k, ivz)&
&            -wz*w(i, j, k, ivy))
          dw(i, j, k, imy) = dw(i, j, k, imy) + rvol*(wz*w(i, j, k, ivx)&
&            -wx*w(i, j, k, ivz))
          dw(i, j, k, imz) = dw(i, j, k, imz) + rvol*(wx*w(i, j, k, ivy)&
&            -wy*w(i, j, k, ivx))
        END DO
      END DO
    END DO
  END IF
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Initialize sFace to zero. This value will be used if the
! block is not moving.
 40 FORMAT(1x,i4,i4,i4,e20.6)
END SUBROUTINE INVISCIDCENTRALFLUX_CD

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
! This is a super-combined function that combines the original
! functionality of: 
! Pressure Computation
! timeStep
! applyAllBCs
! initRes
! residual 
! The real difference between this and the original modules is that it
! it only operates on a single block at a time and as such the
! block/sps loop is outside the calculation. This routine is suitable
! for forward mode AD with Tapenade
SUBROUTINE BLOCK_RES_SPATIAL_CD(nn, sps)
  USE INPUTPHYSICS_SPATIAL_D
  USE ITERATION_SPATIAL_D
  USE INPUTTIMESPECTRAL_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!,x_peturb)
! i/j/kl/b/e, i/j/k/Min/MaxBoundaryStencil
! nw
  REAL(kind=realtype) :: gm1, v2
  INTEGER(kind=inttype) :: nn, sps, i, j, k, sps2, mm, l
  LOGICAL :: correctfork
  INTRINSIC MAX
!  logical :: x_peturb(0:ie,0:je,0:ke,3)
  CALL SETPOINTERSOFFTSINSTANCE_CD(nn, sps, sps)
! Do the spatial things first:
  CALL XHALO_BLOCK_CD(1)
!,x_peturb)
  CALL METRIC_BLOCK_CD(nn, 1, sps)
! call gridVelocities(useOldCoor, t, sps) ! Required for TS
! call normalVelocitiesAllLevels(sps) ! Required for TS
! Compute the pressures
  gm1 = gammaconstant - one
  correctfork = .false.
! Compute P 
  DO k=0,kb
    DO j=0,jb
      DO i=0,ib
        v2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
&          2
        p(i, j, k) = gm1*(w(i, j, k, irhoe)-half*w(i, j, k, irho)*v2)
        IF (p(i, j, k) .LT. 1.e-4_realType*pinfcorr) THEN
          p(i, j, k) = 1.e-4_realType*pinfcorr
        ELSE
          p(i, j, k) = p(i, j, k)
        END IF
      END DO
    END DO
  END DO
!call computeEtot(0,ib,0,jb,0,kb,correctForK)
!  Apply all BC's
  CALL APPLYALLBC_BLOCK_CD(.true.)
! Compute skin_friction Velocity
  CALL COMPUTEUTAU_BLOCK_CD()
! Compute time step and spectral radius
  CALL TIMESTEP_BLOCK_CD(.false.)
!   if( equations == RANSEquations ) then
!      call initres_block(nt1MG, nMGVar,nn,sps) ! Initialize only the Turblent Variables
!      call turbResidual_block
!   endif
  SELECT CASE  (equationmode) 
  CASE (steady) 
    dw = 0.0
  CASE (timespectral) 
    DO sps2=1,ntimeintervalsspectral
      CALL SETPOINTERSOFFTSINSTANCE_CD(nn, sps2, sps2)
      dw = 0.0
      DO mm=1,ntimeintervalsspectral
        CALL SETPOINTERSOFFTSINSTANCE_CD(nn, sps2, mm)
        CALL INITRES_BLOCK_TS_CD(1, nwf, nn, sps2, mm)
      END DO
    END DO
  END SELECT
! Rest the pointers the the "on time instance"
  CALL SETPOINTERSOFFTSINSTANCE_CD(nn, sps, sps)
! Actual residual calc
  CALL RESIDUAL_BLOCK_CD()
! Divide through by the volume
  DO sps2=1,ntimeintervalsspectral
    CALL SETPOINTERSOFFTSINSTANCE_CD(nn, sps2, sps2)
    DO l=1,nw
      DO k=2,kl
        DO j=2,jl
          DO i=2,il
            dw(i, j, k, l) = dw(i, j, k, l)/vol(i, j, k)
          END DO
        END DO
      END DO
    END DO
  END DO
END SUBROUTINE BLOCK_RES_SPATIAL_CD

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          utauWF.f90                                      *
!      * Author:        Georgi Kalitzin, Edwin van der Weide            *
!      * Starting date: 10-01-2003                                      *
!      * Last modified: 06-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE UTAUWF_CD(rfilv)
  USE BCTYPES_SPATIAL_D
  USE INPUTPHYSICS_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * utauWF substitutes the wall shear stress with values from a    *
!      * look-up table, if desired.                                     *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine argument.
!
  REAL(kind=realtype), INTENT(IN) :: rfilv
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, nn
  REAL(kind=realtype) :: fact
  REAL(kind=realtype) :: tauxx, tauyy, tauzz
  REAL(kind=realtype) :: tauxy, tauxz, tauyz
  REAL(kind=realtype) :: rbar, ubar, vbar, wbar, vx, vy, vz
  REAL(kind=realtype) :: fmx, fmy, fmz, frhoe
  REAL(kind=realtype) :: veln, velnx, velny, velnz, tx, ty, tz
  REAL(kind=realtype) :: veltx, velty, veltz, veltmag
  REAL(kind=realtype) :: txnx, txny, txnz, tynx, tyny, tynz
  REAL(kind=realtype) :: tznx, tzny, tznz
  REAL(kind=realtype) :: tautn, tauwall, utau, re
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss, rres
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: norm
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv2, dd2wall2
!
!      Function definition.
!
  REAL(kind=realtype) :: CURVEUPRE_CD
  REAL(kind=realtype) :: arg1
  INTRINSIC MAX
  REAL(kind=realtype) :: x1
  INTRINSIC SQRT
  REAL(kind=realtype) :: max1
  REAL(kind=realtype) :: y1
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Return immediately if no wall functions must be used.
  IF (.NOT.wallfunctions) THEN
    RETURN
  ELSE
! Loop over the viscous subfaces of this block.
viscsubfaces:DO nn=1,nviscbocos
! Set a bunch of variables depending on the face id to make
! a generic treatment possible.
      SELECT CASE  (bcfaceid(nn)) 
      CASE (imin) 
        fact = -one
        ss => si(1, :, :, :)
        rres => fw(2, 1:, 1:, :)
        ww2 => w(2, 1:, 1:, :)
        ww1 => w(1, 1:, 1:, :)
        dd2wall2 => d2wall(2, :, :)
        rrlv2 => rlv(2, 1:, 1:)
      CASE (imax) 
!===========================================================
        fact = one
        ss => si(il, :, :, :)
        rres => fw(il, 1:, 1:, :)
        ww2 => w(il, 1:, 1:, :)
        ww1 => w(ie, 1:, 1:, :)
        dd2wall2 => d2wall(il, :, :)
        rrlv2 => rlv(il, 1:, 1:)
      CASE (jmin) 
!===========================================================
        fact = -one
        ss => sj(:, 1, :, :)
        rres => fw(1:, 2, 1:, :)
        ww2 => w(1:, 2, 1:, :)
        ww1 => w(1:, 1, 1:, :)
        dd2wall2 => d2wall(:, 2, :)
        rrlv2 => rlv(1:, 2, 1:)
      CASE (jmax) 
!===========================================================
        fact = one
        ss => sj(:, jl, :, :)
        rres => fw(1:, jl, 1:, :)
        ww2 => w(1:, jl, 1:, :)
        ww1 => w(1:, je, 1:, :)
        dd2wall2 => d2wall(:, jl, :)
        rrlv2 => rlv(1:, jl, 1:)
      CASE (kmin) 
!===========================================================
        fact = -one
        ss => sk(:, :, 1, :)
        rres => fw(1:, 1:, 2, :)
        ww2 => w(1:, 1:, 2, :)
        ww1 => w(1:, 1:, 1, :)
        dd2wall2 => d2wall(:, :, 2)
        rrlv2 => rlv(1:, 1:, 2)
      CASE (kmax) 
!===========================================================
        fact = one
        ss => sk(:, :, kl, :)
        rres => fw(1:, 1:, kl, :)
        ww2 => w(1:, 1:, kl, :)
        ww1 => w(1:, 1:, ke, :)
        dd2wall2 => d2wall(:, :, kl)
        rrlv2 => rlv(1:, 1:, kl)
      END SELECT
! Set the pointer for the unit outward normals.
      norm => bcdata(nn)%norm
! Loop over the quadrilateral faces of the subface. Note
! that the nodal range of BCData must be used and not the
! cell range, because the latter may include the halo's in i
! and j-direction. The offset +1 is there, because inBeg and
! jnBeg refer to nodal ranges and not to cell ranges.
      DO j=bcdata(nn)%jnbeg+1,bcdata(nn)%jnend
        DO i=bcdata(nn)%inbeg+1,bcdata(nn)%inend
! Store the viscous stress tensor a bit easier.
          tauxx = viscsubface(nn)%tau(i, j, 1)
          tauyy = viscsubface(nn)%tau(i, j, 2)
          tauzz = viscsubface(nn)%tau(i, j, 3)
          tauxy = viscsubface(nn)%tau(i, j, 4)
          tauxz = viscsubface(nn)%tau(i, j, 5)
          tauyz = viscsubface(nn)%tau(i, j, 6)
! Compute the velocities at the wall face; these are only
! non-zero for moving a block. Also compute the density,
! which is needed to compute the wall shear stress via
! wall functions.
          rbar = half*(ww2(i, j, irho)+ww1(i, j, irho))
          ubar = half*(ww2(i, j, ivx)+ww1(i, j, ivx))
          vbar = half*(ww2(i, j, ivy)+ww1(i, j, ivy))
          wbar = half*(ww2(i, j, ivz)+ww1(i, j, ivz))
! Compute the velocity difference between the internal cell
! and the wall.
          vx = ww2(i, j, ivx) - ubar
          vy = ww2(i, j, ivy) - vbar
          vz = ww2(i, j, ivz) - wbar
! Compute the normal velocity of the internal cell.
          veln = vx*norm(i, j, 1) + vy*norm(i, j, 2) + vz*norm(i, j, 3)
          velnx = veln*norm(i, j, 1)
          velny = veln*norm(i, j, 2)
          velnz = veln*norm(i, j, 3)
! Compute the tangential velocity, its magnitude and its
! unit vector of the internal cell.
          veltx = vx - velnx
          velty = vy - velny
          veltz = vz - velnz
          arg1 = veltx**2 + velty**2 + veltz**2
          y1 = SQRT(arg1)
          IF (eps .LT. y1) THEN
            veltmag = y1
          ELSE
            veltmag = eps
          END IF
          tx = veltx/veltmag
          ty = velty/veltmag
          tz = veltz/veltmag
! Compute some coefficients needed for the transformation
! between the cartesian frame and the frame defined by the
! tangential direction (tx,ty,tz) and the normal direction.
! The minus sign is present, because for this transformation
! the normal direction should be inward pointing and norm
! is outward pointing.
          txnx = -(tx*norm(i, j, 1))
          txny = -(tx*norm(i, j, 2))
          txnz = -(tx*norm(i, j, 3))
          tynx = -(ty*norm(i, j, 1))
          tyny = -(ty*norm(i, j, 2))
          tynz = -(ty*norm(i, j, 3))
          tznx = -(tz*norm(i, j, 1))
          tzny = -(tz*norm(i, j, 2))
          tznz = -(tz*norm(i, j, 3))
! Compute the tn component of the wall shear stress
! tensor. Normally this is the only nonzero shear
! stress component in the t-n frame.
          tautn = tauxx*txnx + tauyy*tyny + tauzz*tznz + tauxy*(txny+&
&            tynx) + tauxz*(txnz+tznx) + tauyz*(tynz+tzny)
! Compute the Reynolds number using the velocity, density,
! laminar viscosity and wall distance. Note that an offset
! of -1 must be used in dd2Wall2, because the original array
! d2Wall starts at 2.
          re = ww2(i, j, irho)*veltmag*dd2wall2(i-1, j-1)/rrlv2(i, j)
          x1 = CURVEUPRE_CD(re)
          IF (x1 .LT. eps) THEN
            max1 = eps
          ELSE
            max1 = x1
          END IF
! Determine the friction velocity from the table and
! compute the wall shear stress from it.
          utau = veltmag/max1
          tauwall = rbar*utau*utau
! Compute the correction to the wall shear stress tautn and
! transform this correction back to the cartesian frame.
! Take rFilv into account, such that the correction to the
! stress tensor is computed correctly.
          tautn = rfilv*tauwall - tautn
          tauxx = two*tautn*txnx
          tauyy = two*tautn*tyny
          tauzz = two*tautn*tznz
          tauxy = tautn*(txny+tynx)
          tauxz = tautn*(txnz+tznx)
          tauyz = tautn*(tynz+tzny)
! Compute the correction to the viscous flux at the wall.
          fmx = tauxx*ss(i, j, 1) + tauxy*ss(i, j, 2) + tauxz*ss(i, j, 3&
&            )
          fmy = tauxy*ss(i, j, 1) + tauyy*ss(i, j, 2) + tauyz*ss(i, j, 3&
&            )
          fmz = tauxz*ss(i, j, 1) + tauyz*ss(i, j, 2) + tauzz*ss(i, j, 3&
&            )
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*ss(i, j, 1) + (ubar&
&            *tauxy+vbar*tauyy+wbar*tauyz)*ss(i, j, 2) + (ubar*tauxz+vbar&
&            *tauyz+wbar*tauzz)*ss(i, j, 3)
! Add them to the residual. Note that now the factor rFilv
! is already taken into account via tau. Fact is present to
! take inward/outward pointing normals into account
          rres(i, j, imx) = rres(i, j, imx) - fact*fmx
          rres(i, j, imy) = rres(i, j, imy) - fact*fmy
          rres(i, j, imz) = rres(i, j, imz) - fact*fmz
          rres(i, j, irhoe) = rres(i, j, irhoe) - fact*frhoe
! Store the friction velocity for later use.
          viscsubface(nn)%utau(i, j) = utau
! Also add the correction to the wall stress tensor.
          viscsubface(nn)%tau(i, j, 1) = viscsubface(nn)%tau(i, j, 1) + &
&            tauxx
          viscsubface(nn)%tau(i, j, 2) = viscsubface(nn)%tau(i, j, 2) + &
&            tauyy
          viscsubface(nn)%tau(i, j, 3) = viscsubface(nn)%tau(i, j, 3) + &
&            tauzz
          viscsubface(nn)%tau(i, j, 4) = viscsubface(nn)%tau(i, j, 4) + &
&            tauxy
          viscsubface(nn)%tau(i, j, 5) = viscsubface(nn)%tau(i, j, 5) + &
&            tauxz
          viscsubface(nn)%tau(i, j, 6) = viscsubface(nn)%tau(i, j, 6) + &
&            tauyz
        END DO
      END DO
    END DO viscsubfaces
  END IF
END SUBROUTINE UTAUWF_CD

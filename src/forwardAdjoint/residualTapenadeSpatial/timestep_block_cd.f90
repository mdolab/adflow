!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          timeStep.f90                                    *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-17-2003                                      *
!      * Last modified: 06-28-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE TIMESTEP_BLOCK_CD(onlyradii)
  USE INPUTITERATION_SPATIAL_D
  USE SECTION_SPATIAL_D
  USE INPUTPHYSICS_SPATIAL_D
  USE ITERATION_SPATIAL_D
  USE INPUTDISCRETIZATION_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE INPUTTIMESPECTRAL_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * timeStep computes the time step, or more precisely the time    *
!      * step divided by the volume per unit CFL, in the owned cells.   *
!      * However, for the artificial dissipation schemes, the spectral  *
!      * radIi in the halo's are needed. Therefore the loop is taken    *
!      * over the the first level of halo cells. The spectral radIi are *
!      * stored and possibly modified for high aspect ratio cells.      *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine argument.
!
  LOGICAL, INTENT(IN) :: onlyradii
!
!      Local parameters.
!
  REAL(kind=realtype), PARAMETER :: b=2.0_realType
!
!      Local variables.
!
  INTEGER(kind=inttype) :: sps, nn, i, j, k
  REAL(kind=realtype) :: plim, rlim, clim2
  REAL(kind=realtype) :: ux, uy, uz, cc2, qs, sx, sy, sz, rmu
  REAL(kind=realtype) :: ri, rj, rk, rij, rjk, rki
  REAL(kind=realtype) :: vsi, vsj, vsk, rfl, dpi, dpj, dpk
  REAL(kind=realtype) :: sface, tmp
  LOGICAL :: radiineeded
  REAL(kind=realtype) :: arg1
  REAL(kind=realtype) :: result1
  REAL(kind=realtype) :: pwx1
  INTRINSIC MAX
  INTRINSIC ABS
  REAL(kind=realtype) :: abs6
  REAL(kind=realtype) :: abs5
  REAL(kind=realtype) :: abs4
  REAL(kind=realtype) :: abs3
  REAL(kind=realtype) :: abs2
  REAL(kind=realtype) :: abs1
  INTRINSIC SQRT
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Determine whether or not the spectral radii are needed for the
! flux computation.
  radiineeded = radiineededcoarse
  IF (currentlevel .LE. groundlevel) radiineeded = radiineededfine
! Return immediately if only the spectral radii must be computed
! and these are not needed for the flux computation.
  IF (onlyradii .AND. (.NOT.radiineeded)) THEN
    RETURN
  ELSE
! Set the value of plim. To be fully consistent this must have
! the dimension of a pressure. Therefore a fraction of pInfCorr
! is used. Idem for rlim; compute clim2 as well.
    plim = 0.001_realType*pinfcorr
    rlim = 0.001_realType*rhoinf
    clim2 = 0.000001_realType*gammainf*pinfcorr/rhoinf
! Loop over the number of spectral solutions and local blocks.
! Initialize sFace to zero. This value will be used if the
! block is not moving.
    sface = zero
!
!          **************************************************************
!          *                                                            *
!          * Inviscid contribution, depending on the preconditioner.    *
!          * Compute the cell centered values of the spectral radii.    *
!          *                                                            *
!          **************************************************************
!
    SELECT CASE  (precond) 
    CASE (noprecond) 
! No preconditioner. Simply the standard spectral radius.
! Loop over the cells, including the first level halo.
      DO k=1,ke
        DO j=1,je
          DO i=1,ie
! Compute the velocities and speed of sound squared.
            ux = w(i, j, k, ivx)
            uy = w(i, j, k, ivy)
            uz = w(i, j, k, ivz)
            cc2 = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
!cc2 = max(cc2,clim2)
! Set the dot product of the grid velocity and the
! normal in i-direction for a moving face. To avoid
! a number of multiplications by 0.5 simply the sum
! is taken.
            IF (addgridvelocities) sface = sfacei(i-1, j, k) + sfacei(i&
&                , j, k)
! Spectral radius in i-direction.
            sx = si(i-1, j, k, 1) + si(i, j, k, 1)
            sy = si(i-1, j, k, 2) + si(i, j, k, 2)
            sz = si(i-1, j, k, 3) + si(i, j, k, 3)
            qs = ux*sx + uy*sy + uz*sz - sface
            IF (qs .GE. 0.) THEN
              abs1 = qs
            ELSE
              abs1 = -qs
            END IF
            arg1 = cc2*(sx**2+sy**2+sz**2)
            result1 = SQRT(arg1)
            radi(i, j, k) = half*(abs1+result1)
! The grid velocity in j-direction.
            IF (addgridvelocities) sface = sfacej(i, j-1, k) + sfacej(i&
&                , j, k)
! Spectral radius in j-direction.
            sx = sj(i, j-1, k, 1) + sj(i, j, k, 1)
            sy = sj(i, j-1, k, 2) + sj(i, j, k, 2)
            sz = sj(i, j-1, k, 3) + sj(i, j, k, 3)
            qs = ux*sx + uy*sy + uz*sz - sface
            IF (qs .GE. 0.) THEN
              abs2 = qs
            ELSE
              abs2 = -qs
            END IF
            arg1 = cc2*(sx**2+sy**2+sz**2)
            result1 = SQRT(arg1)
            radj(i, j, k) = half*(abs2+result1)
! The grid velocity in k-direction.
            IF (addgridvelocities) sface = sfacek(i, j, k-1) + sfacek(i&
&                , j, k)
! Spectral radius in k-direction.
            sx = sk(i, j, k-1, 1) + sk(i, j, k, 1)
            sy = sk(i, j, k-1, 2) + sk(i, j, k, 2)
            sz = sk(i, j, k-1, 3) + sk(i, j, k, 3)
            qs = ux*sx + uy*sy + uz*sz - sface
            IF (qs .GE. 0.) THEN
              abs3 = qs
            ELSE
              abs3 = -qs
            END IF
            arg1 = cc2*(sx**2+sy**2+sz**2)
            result1 = SQRT(arg1)
            radk(i, j, k) = half*(abs3+result1)
! Compute the inviscid contribution to the time step.
            dtl(i, j, k) = radi(i, j, k) + radj(i, j, k) + radk(i, j, k)
          END DO
        END DO
      END DO
    CASE (turkel) 
      CALL TERMINATE_CD('timeStep', &
&                  'Turkel preconditioner not implemented yet')
    CASE (choimerkle) 
      CALL TERMINATE_CD('timeStep', &
&                  'choi merkle preconditioner not implemented yet')
    END SELECT
!
!          **************************************************************
!          *                                                            *
!          * Adapt the spectral radii if directional scaling must be    *
!          * applied.                                                   *
!          *                                                            *
!          **************************************************************
!
    IF (dirscaling .AND. currentlevel .LE. groundlevel) THEN
! if( dirScaling ) then
      DO k=1,ke
        DO j=1,je
          DO i=1,ie
            IF (radi(i, j, k) .LT. eps) THEN
              ri = eps
            ELSE
              ri = radi(i, j, k)
            END IF
            IF (radj(i, j, k) .LT. eps) THEN
              rj = eps
            ELSE
              rj = radj(i, j, k)
            END IF
            IF (radk(i, j, k) .LT. eps) THEN
              rk = eps
            ELSE
              rk = radk(i, j, k)
            END IF
! Compute the scaling in the three coordinate
! directions.
            pwx1 = ri/rj
            rij = pwx1**adis
            pwx1 = rj/rk
            rjk = pwx1**adis
            pwx1 = rk/ri
            rki = pwx1**adis
! Create the scaled versions of the aspect ratios.
! Note that the multiplication is done with radi, radJ
! and radK, such that the influence of the clipping
! is negligible.
!   radi(i,j,k) = third*radi(i,j,k)*(one + one/rij + rki)
!   radJ(i,j,k) = third*radJ(i,j,k)*(one + one/rjk + rij)
!   radK(i,j,k) = third*radK(i,j,k)*(one + one/rki + rjk)
            radi(i, j, k) = radi(i, j, k)*(one+one/rij+rki)
            radj(i, j, k) = radj(i, j, k)*(one+one/rjk+rij)
            radk(i, j, k) = radk(i, j, k)*(one+one/rki+rjk)
          END DO
        END DO
      END DO
    END IF
! The rest of this file can be skipped if only the spectral
! radii need to be computed.
    IF (.NOT.onlyradii) THEN
! The viscous contribution, if needed.
      IF (viscous) THEN
! Loop over the owned cell centers.
        DO k=2,kl
          DO j=2,jl
            DO i=2,il
! Compute the effective viscosity coefficient. The
! factor 0.5 is a combination of two things. In the
! standard central discretization of a second
! derivative there is a factor 2 multiplying the
! central node. However in the code below not the
! average but the sum of the left and the right face
! is taken and squared. This leads to a factor 4.
! Combining both effects leads to 0.5. Furthermore,
! it is divided by the volume and density to obtain
! the correct dimensions and multiplied by the
! non-dimensional factor factVis.
              rmu = rlv(i, j, k)
              IF (eddymodel) rmu = rmu + rev(i, j, k)
              rmu = half*rmu/(w(i, j, k, irho)*vol(i, j, k))
! Add the viscous contribution in i-direction to the
! (inverse) of the time step.
              sx = si(i, j, k, 1) + si(i-1, j, k, 1)
              sy = si(i, j, k, 2) + si(i-1, j, k, 2)
              sz = si(i, j, k, 3) + si(i-1, j, k, 3)
              vsi = rmu*(sx*sx+sy*sy+sz*sz)
              dtl(i, j, k) = dtl(i, j, k) + vsi
! Add the viscous contribution in j-direction to the
! (inverse) of the time step.
              sx = sj(i, j, k, 1) + sj(i, j-1, k, 1)
              sy = sj(i, j, k, 2) + sj(i, j-1, k, 2)
              sz = sj(i, j, k, 3) + sj(i, j-1, k, 3)
              vsj = rmu*(sx*sx+sy*sy+sz*sz)
              dtl(i, j, k) = dtl(i, j, k) + vsj
! Add the viscous contribution in k-direction to the
! (inverse) of the time step.
              sx = sk(i, j, k, 1) + sk(i, j, k-1, 1)
              sy = sk(i, j, k, 2) + sk(i, j, k-1, 2)
              sz = sk(i, j, k, 3) + sk(i, j, k-1, 3)
              vsk = rmu*(sx*sx+sy*sy+sz*sz)
              dtl(i, j, k) = dtl(i, j, k) + vsk
            END DO
          END DO
        END DO
      END IF
! For the spectral mode an additional term term must be
! taken into account, which corresponds to the contribution
! of the highest frequency.
      IF (equationmode .EQ. timespectral) THEN
        tmp = ntimeintervalsspectral*pi*timeref/sections(sectionid)%&
&          timeperiod
! Loop over the owned cell centers and add the term.
        DO k=2,kl
          DO j=2,jl
            DO i=2,il
              dtl(i, j, k) = dtl(i, j, k) + tmp*vol(i, j, k)
            END DO
          END DO
        END DO
      END IF
! Currently the inverse of dt/vol is stored in dtl. Invert
! this value such that the time step per unit cfl number is
! stored and correct in cases of high gradients.
      DO k=2,kl
        DO j=2,jl
          DO i=2,il
            IF (p(i+1, j, k) - two*p(i, j, k) + p(i-1, j, k) .GE. 0.) &
&            THEN
              abs4 = p(i+1, j, k) - two*p(i, j, k) + p(i-1, j, k)
            ELSE
              abs4 = -(p(i+1, j, k)-two*p(i, j, k)+p(i-1, j, k))
            END IF
            dpi = abs4/(p(i+1, j, k)+two*p(i, j, k)+p(i-1, j, k)+plim)
            IF (p(i, j+1, k) - two*p(i, j, k) + p(i, j-1, k) .GE. 0.) &
&            THEN
              abs5 = p(i, j+1, k) - two*p(i, j, k) + p(i, j-1, k)
            ELSE
              abs5 = -(p(i, j+1, k)-two*p(i, j, k)+p(i, j-1, k))
            END IF
            dpj = abs5/(p(i, j+1, k)+two*p(i, j, k)+p(i, j-1, k)+plim)
            IF (p(i, j, k+1) - two*p(i, j, k) + p(i, j, k-1) .GE. 0.) &
&            THEN
              abs6 = p(i, j, k+1) - two*p(i, j, k) + p(i, j, k-1)
            ELSE
              abs6 = -(p(i, j, k+1)-two*p(i, j, k)+p(i, j, k-1))
            END IF
            dpk = abs6/(p(i, j, k+1)+two*p(i, j, k)+p(i, j, k-1)+plim)
            rfl = one/(one+b*(dpi+dpj+dpk))
            dtl(i, j, k) = rfl/dtl(i, j, k)
          END DO
        END DO
      END DO
    END IF
  END IF
END SUBROUTINE TIMESTEP_BLOCK_CD

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          extrapolate2ndHalo.f90                          *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-10-2003                                      *
!      * Last modified: 06-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE EXTRAPOLATE2NDHALO_CD(nn, correctfork)
  USE BCTYPES_SPATIAL_D
  USE INPUTPHYSICS_SPATIAL_D
  USE ITERATION_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * extrapolate2ndHalo determines the states of the second layer   *
!      * halo cells for the given subface of the block. It is assumed   *
!      * that the pointers in blockPointers are already set to the      *
!      * correct block on the correct grid level.                       *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
  INTEGER(kind=inttype), INTENT(IN) :: nn
  LOGICAL, INTENT(IN) :: correctfork
!
!      Local parameter.
!
  REAL(kind=realtype), PARAMETER :: factor=0.5_realType
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, l, idim, ddim
  INTEGER(kind=inttype), DIMENSION(3, 2) :: crange
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww0, ww1, ww2
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp0, pp1, pp2
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv0, rlv1
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev0, rev1
  INTRINSIC MAX
  INTERFACE 
      SUBROUTINE SETBCPOINTERS_CD0(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
&        rev1, rev2, offset)
        USE BLOCKPOINTERS_SPATIAL_D
        INTEGER(kind=inttype), INTENT(IN) :: nn, offset
        REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
        REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
        REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
        REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
      END SUBROUTINE SETBCPOINTERS_CD0
  END INTERFACE

!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Nullify the pointers and set them to the correct subface.
! They are nullified first, because some compilers require that.
! Note that rlv0 and rev0 are used here as dummies.
!nullify(ww1, ww2, pp1, pp2, rlv1, rlv0, rev1, rev0)
  CALL SETBCPOINTERS_CD0(nn, ww1, ww2, pp1, pp2, rlv1, rlv0, rev1, rev0&
&                   , 0_intType)
! Set a couple of additional variables needed for the
! extrapolation. This depends on the block face on which the
! subface is located.
  SELECT CASE  (bcfaceid(nn)) 
  CASE (imin) 
    ww0 => w(0, 1:, 1:, :)
    pp0 => p(0, 1:, 1:)
    IF (viscous) THEN
      rlv0 => rlv(0, 1:, 1:)
    END IF
    IF (eddymodel) THEN
      rev0 => rev(0, 1:, 1:)
    END IF
    idim = 1
    ddim = 0
  CASE (imax) 
    ww0 => w(ib, 1:, 1:, :)
    pp0 => p(ib, 1:, 1:)
    IF (viscous) THEN
      rlv0 => rlv(ib, 1:, 1:)
    END IF
    IF (eddymodel) THEN
      rev0 => rev(ib, 1:, 1:)
    END IF
    idim = 1
    ddim = ib
  CASE (jmin) 
    ww0 => w(1:, 0, 1:, :)
    pp0 => p(1:, 0, 1:)
    IF (viscous) THEN
      rlv0 => rlv(1:, 0, 1:)
    END IF
    IF (eddymodel) THEN
      rev0 => rev(1:, 0, 1:)
    END IF
    idim = 2
    ddim = 0
  CASE (jmax) 
    ww0 => w(1:, jb, 1:, :)
    pp0 => p(1:, jb, 1:)
    IF (viscous) THEN
      rlv0 => rlv(1:, jb, 1:)
    END IF
    IF (eddymodel) THEN
      rev0 => rev(1:, jb, 1:)
    END IF
    idim = 2
    ddim = jb
  CASE (kmin) 
    ww0 => w(1:, 1:, 0, :)
    pp0 => p(1:, 1:, 0)
    IF (viscous) THEN
      rlv0 => rlv(1:, 1:, 0)
    END IF
    IF (eddymodel) THEN
      rev0 => rev(1:, 1:, 0)
    END IF
    idim = 3
    ddim = 0
  CASE (kmax) 
    ww0 => w(1:, 1:, kb, :)
    pp0 => p(1:, 1:, kb)
    IF (viscous) THEN
      rlv0 => rlv(1:, 1:, kb)
    END IF
    IF (eddymodel) THEN
      rev0 => rev(1:, 1:, kb)
    END IF
    idim = 3
    ddim = kb
  END SELECT
! Loop over the generic subface to set the state in the halo's.
  DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
    DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
! Extrapolate the density, momentum and pressure.
! Make sure that a certain threshold is kept.
      ww0(i, j, irho) = two*ww1(i, j, irho) - ww2(i, j, irho)
      IF (factor*ww1(i, j, irho) .LT. ww0(i, j, irho)) THEN
        ww0(i, j, irho) = ww0(i, j, irho)
      ELSE
        ww0(i, j, irho) = factor*ww1(i, j, irho)
      END IF
      ww0(i, j, ivx) = two*ww1(i, j, ivx) - ww2(i, j, ivx)
      ww0(i, j, ivy) = two*ww1(i, j, ivy) - ww2(i, j, ivy)
      ww0(i, j, ivz) = two*ww1(i, j, ivz) - ww2(i, j, ivz)
      IF (factor*pp1(i, j) .LT. two*pp1(i, j) - pp2(i, j)) THEN
        pp0(i, j) = two*pp1(i, j) - pp2(i, j)
      ELSE
        pp0(i, j) = factor*pp1(i, j)
      END IF
! Extrapolate the turbulent variables. Use constant
! extrapolation.
      DO l=nt1mg,nt2mg
        ww0(i, j, l) = ww1(i, j, l)
      END DO
! The laminar and eddy viscosity, if present. These values
! are simply taken constant. Their values do not matter.
      IF (viscous) rlv0(i, j) = rlv1(i, j)
      IF (eddymodel) rev0(i, j) = rev1(i, j)
    END DO
  END DO
! Set the range for the halo cells for the energy computation.
  crange(1, 1) = icbeg(nn)
  crange(1, 2) = icend(nn)
  crange(2, 1) = jcbeg(nn)
  crange(2, 2) = jcend(nn)
  crange(3, 1) = kcbeg(nn)
  crange(3, 2) = kcend(nn)
  crange(idim, 1) = ddim
  crange(idim, 2) = ddim
! Compute the energy for this halo range.
  CALL COMPUTEETOT_CD(crange(1, 1), crange(1, 2), crange(2, 1), crange(2&
&                , 2), crange(3, 1), crange(3, 2), correctfork)
END SUBROUTINE EXTRAPOLATE2NDHALO_CD

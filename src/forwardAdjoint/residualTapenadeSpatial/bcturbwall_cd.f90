!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          bcTurbWall.F90                                  *
!      * Author:        Georgi Kalitzin, Edwin van der Weide            *
!      * Starting date: 06-26-2003                                      *
!      * Last modified: 06-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE BCTURBWALL_CD(nn)
  USE BCTYPES_SPATIAL_D
  USE INPUTPHYSICS_SPATIAL_D
  USE PARAMTURB_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * bcTurbWall applies the implicit treatment of the viscous       *
!      * wall boundary condition for the turbulence model used to the   *
!      * given subface nn.                                              *
!      * It is assumed that the pointers in blockPointers are           *
!      * already set to the correct block.                              *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
  INTEGER(kind=inttype), INTENT(IN) :: nn
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, ii, jj, iimax, jjmax
  REAL(kind=realtype) :: tmpd, tmpe, tmpf, nu
  REAL(kind=realtype), DIMENSION(:, :, :, :), POINTER :: bmt
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: bvt, ww2
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv2, dd2wall
  INTRINSIC MAX
  INTRINSIC ABS
  REAL(kind=realtype) :: abs1
  INTRINSIC MIN
  REAL(intType) :: y4
  REAL(intType) :: y3
  REAL(intType) :: y2
  REAL(intType) :: y1
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Set some variables depending on the block face on which the
! subface is located. Needed for a general treatment.
  SELECT CASE  (bcfaceid(nn)) 
  CASE (imin) 
    iimax = jl
    jjmax = kl
    bmt => bmti1
    bvt => bvti1
    ww2 => w(2, 1:, 1:, :)
    rlv2 => rlv(2, 1:, 1:)
    dd2wall => d2wall(2, :, :)
  CASE (imax) 
    iimax = jl
    jjmax = kl
    bmt => bmti2
    bvt => bvti2
    ww2 => w(il, 1:, 1:, :)
    rlv2 => rlv(il, 1:, 1:)
    dd2wall => d2wall(il, :, :)
  CASE (jmin) 
    iimax = il
    jjmax = kl
    bmt => bmtj1
    bvt => bvtj1
    ww2 => w(1:, 2, 1:, :)
    rlv2 => rlv(1:, 2, 1:)
    dd2wall => d2wall(:, 2, :)
  CASE (jmax) 
    iimax = il
    jjmax = kl
    bmt => bmtj2
    bvt => bvtj2
    ww2 => w(1:, jl, 1:, :)
    rlv2 => rlv(1:, jl, 1:)
    dd2wall => d2wall(:, jl, :)
  CASE (kmin) 
    iimax = il
    jjmax = jl
    bmt => bmtk1
    bvt => bvtk1
    ww2 => w(1:, 1:, 2, :)
    rlv2 => rlv(1:, 1:, 2)
    dd2wall => d2wall(:, :, 2)
  CASE (kmax) 
    iimax = il
    jjmax = jl
    bmt => bmtk2
    bvt => bvtk2
    ww2 => w(1:, 1:, kl, :)
    rlv2 => rlv(1:, 1:, kl)
    dd2wall => d2wall(:, :, kl)
  END SELECT
! Determine the turbulence model used and loop over the faces
! of the subface and set the values of bmt and bvt for an
! implicit treatment.
  SELECT CASE  (turbmodel) 
  CASE (spalartallmaras, spalartallmarasedwards) 
! Spalart-allmaras type of model. Value at the wall is zero,
! so simply negate the internal value.
    DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
        bmt(i, j, itu1, itu1) = one
      END DO
    END DO
  CASE (komegawilcox, komegamodified, mentersst) 
!        ================================================================
! K-omega type of models. K is zero on the wall and thus the
! halo value is the negative of the first internal cell.
! For omega the situation is a bit more complicated.
! Theoretically omega is infinity, but it is set to a large
! value, see menter's paper. The halo value is constructed
! such that the wall value is correct. Make sure that i and j
! are limited to physical dimensions of the face for the wall
! distance. Due to the usage of the dd2Wall pointer and the
! fact that the original d2Wall array starts at 2, there is
! an offset of -1 present in dd2Wall.
    DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      IF (j .GT. jjmax) THEN
        y1 = jjmax
      ELSE
        y1 = j
      END IF
      IF (2_intType .LT. y1) THEN
        jj = y1
      ELSE
        jj = 2_intType
      END IF
      DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
        IF (i .GT. iimax) THEN
          y2 = iimax
        ELSE
          y2 = i
        END IF
        IF (2_intType .LT. y2) THEN
          ii = y2
        ELSE
          ii = 2_intType
        END IF
        nu = rlv2(i, j)/ww2(i, j, irho)
        tmpd = one/(rkwbeta1*dd2wall(ii-1, jj-1)**2)
        bmt(i, j, itu1, itu1) = one
        bmt(i, j, itu2, itu2) = one
        bvt(i, j, itu2) = two*60.0_realType*nu*tmpd
      END DO
    END DO
  CASE (ktau) 
!        ================================================================
! K-tau model. Both k and tau are zero at the wall, so the
! negative value of the internal cell is taken for the halo.
    DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
        bmt(i, j, itu1, itu1) = one
        bmt(i, j, itu2, itu2) = one
      END DO
    END DO
  CASE (v2f) 
!        ================================================================
! V2f turbulence model. Same story for the wall distance as
! for k-omega. For this model there is a coupling between the
! equations via the boundary conditions.
    DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
      IF (j .GT. jjmax) THEN
        y3 = jjmax
      ELSE
        y3 = j
      END IF
      IF (2_intType .LT. y3) THEN
        jj = y3
      ELSE
        jj = 2_intType
      END IF
      DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
        IF (i .GT. iimax) THEN
          y4 = iimax
        ELSE
          y4 = i
        END IF
        IF (2_intType .LT. y4) THEN
          ii = y4
        ELSE
          ii = 2_intType
        END IF
        nu = rlv2(i, j)/ww2(i, j, irho)
        tmpd = one/dd2wall(ii-1, jj-1)**2
        tmpe = two*nu*tmpd
        IF (tmpe*ww2(i, j, itu1) .GE. 0.) THEN
          abs1 = tmpe*ww2(i, j, itu1)
        ELSE
          abs1 = -(tmpe*ww2(i, j, itu1))
        END IF
        tmpf = -(20.0_realType*(nu*tmpd)**2/abs1)
        IF (rvfn .EQ. 6) tmpf = zero
        bmt(i, j, itu1, itu1) = one
        bmt(i, j, itu2, itu2) = one
        bmt(i, j, itu3, itu3) = one
        bmt(i, j, itu4, itu4) = one
        bmt(i, j, itu2, itu1) = -(two*tmpe)
        bmt(i, j, itu4, itu3) = -(two*tmpf)
      END DO
    END DO
  CASE DEFAULT
    CALL TERMINATE_CD('bcTurbWall', &
&                'Turbulence model not implemented yet')
  END SELECT
END SUBROUTINE BCTURBWALL_CD

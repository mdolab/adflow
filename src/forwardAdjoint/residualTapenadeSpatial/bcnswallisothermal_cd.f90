!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          bcNSWallIsothermal.f90                          *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-10-2003                                      *
!      * Last modified: 06-12-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE BCNSWALLISOTHERMAL_CD(secondhalo, correctfork)
  USE BCTYPES_SPATIAL_D
  USE ITERATION_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * bcNSWallAdiabatic applies the viscous isothermal wall          *
!      * boundary condition to a block. It is assumed that the pointers *
!      * in blockPointers are already set to the correct block on the   *
!      * correct grid level.                                            *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
  LOGICAL, INTENT(IN) :: secondhalo, correctfork
!
!      Local variables.
!
  INTEGER(kind=inttype) :: nn, i, j
  REAL(kind=realtype) :: rhok, t2, t1
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: uslip
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: tns_wall
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
  INTRINSIC MAX
  INTRINSIC MIN
  INTERFACE 
      SUBROUTINE SETBCPOINTERS_CD1(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, &
&        rev1, rev2, offset)
        USE BLOCKPOINTERS_SPATIAL_D
        INTEGER(kind=inttype), INTENT(IN) :: nn, offset
        REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww1, ww2
        REAL(kind=realtype), DIMENSION(:, :), POINTER :: pp1, pp2
        REAL(kind=realtype), DIMENSION(:, :), POINTER :: rlv1, rlv2
        REAL(kind=realtype), DIMENSION(:, :), POINTER :: rev1, rev2
      END SUBROUTINE SETBCPOINTERS_CD1
  END INTERFACE

!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! In case the turbulent transport equations are solved
! together with the mean flow equations, aplly the viscous
! wall boundary conditions for the turbulent variables.
! No need to extrapolate the secondary halo's, because this
! is done in extrapolate2ndHalo.
  IF (turbcoupled) CALL TURBBCNSWALL_CD(.false.)
! Loop over the viscous subfaces of this block. Note that
! these are numbered first.
bocos:DO nn=1,nviscbocos
! Check for isothermal viscous wall boundary conditions.
    IF (bctype(nn) .EQ. nswallisothermal) THEN
! Set the pointers for uSlip and TNSWall to make
! the code more readable.
      uslip => bcdata(nn)%uslip
      tns_wall => bcdata(nn)%tns_wall
! Nullify the pointers and set them to the correct subface.
! They are nullified first, because some compilers require
! that.
!nullify(ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, rev2)
      CALL SETBCPOINTERS_CD1(nn, ww1, ww2, pp1, pp2, rlv1, rlv2, rev1, &
&                       rev2, 0_intType)
! Initialize rhok to zero. This will be overwritten if a
! correction for k must be applied.
      rhok = zero
! Loop over the generic subface to set the state in the
! halo cells.
      DO j=bcdata(nn)%jcbeg,bcdata(nn)%jcend
        DO i=bcdata(nn)%icbeg,bcdata(nn)%icend
! Set the value of rhok if a correcton must be applied.
! It probably does not matter too much, because k is very
! small near the wall.
          IF (correctfork) rhok = ww2(i, j, irho)*ww2(i, j, itu1)
! Compute the temperature in the internal cell and in the
! halo cell such that the average is the wall temperature.
          t2 = pp2(i, j)/(rgas*ww2(i, j, irho))
          t1 = two*tns_wall(i, j) - t2
          IF (half*tns_wall(i, j) .LT. t1) THEN
            t1 = t1
          ELSE
            t1 = half*tns_wall(i, j)
          END IF
          IF (two*tns_wall(i, j) .GT. t1) THEN
            t1 = t1
          ELSE
            t1 = two*tns_wall(i, j)
          END IF
! Determine the variables in the halo. As the spacing
! is very small a constant pressure boundary condition
! (except for the k correction) is okay. Take the slip
! velocity into account.
          pp1(i, j) = pp2(i, j) - four*third*rhok
          ww1(i, j, irho) = pp1(i, j)/(rgas*t1)
          ww1(i, j, ivx) = -ww2(i, j, ivx) + two*uslip(i, j, 1)
          ww1(i, j, ivy) = -ww2(i, j, ivy) + two*uslip(i, j, 2)
          ww1(i, j, ivz) = -ww2(i, j, ivz) + two*uslip(i, j, 3)
! Set the viscosities. There is no need to test for a
! viscous problem of course. The eddy viscosity is
! set to the negative value, as it should be zero on
! the wall.
          rlv1(i, j) = rlv2(i, j)
          IF (eddymodel) rev1(i, j) = -rev2(i, j)
        END DO
      END DO
! Compute the energy for these halo's.
      CALL COMPUTEETOT_CD(icbeg(nn), icend(nn), jcbeg(nn), jcend(nn), &
&                    kcbeg(nn), kcend(nn), correctfork)
! Extrapolate the state vectors in case a second halo
! is needed.
      IF (secondhalo) CALL EXTRAPOLATE2NDHALO_CD(nn, correctfork)
    END IF
  END DO bocos
END SUBROUTINE BCNSWALLISOTHERMAL_CD

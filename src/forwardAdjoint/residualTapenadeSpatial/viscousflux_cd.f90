!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          viscousFlux.f90                                 *
!      * Author:        Edwin van der Weide                             *
!      * Starting date: 03-21-2003                                      *
!      * Last modified: 04-18-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE VISCOUSFLUX_CD()
  USE INPUTPHYSICS_SPATIAL_D
  USE ITERATION_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  USE FLOWVARREFSTATE_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * viscousFlux computes the viscous fluxes using a central        *
!      * difference scheme for a block.                                 *
!      * It is assumed that the pointers in block pointer already point *
!      * to the correct block.                                          *
!      *                                                                *
!      ******************************************************************
!
!
!      Local parameter.
!
  REAL(kind=realtype), PARAMETER :: twothird=two*third
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, k, nn
  INTEGER(kind=inttype) :: k1, k2, kk
  REAL(kind=realtype) :: rfilv, por, mul, mue, mut, heatcoef
  REAL(kind=realtype) :: gm1, factlamheat, factturbheat
  REAL(kind=realtype) :: u_x, u_y, u_z, v_x, v_y, v_z, w_x, w_y, w_z
  REAL(kind=realtype) :: q_x, q_y, q_z, ubar, vbar, wbar
  REAL(kind=realtype) :: corr, ssx, ssy, ssz, ss, fracdiv
  REAL(kind=realtype) :: tauxx, tauyy, tauzz
  REAL(kind=realtype) :: tauxy, tauxz, tauyz
  REAL(kind=realtype) :: fmx, fmy, fmz, frhoe
  REAL(kind=realtype), DIMENSION(il, jl, 2) :: ux, uy, uz
  REAL(kind=realtype), DIMENSION(il, jl, 2) :: vx, vy, vz
  REAL(kind=realtype), DIMENSION(il, jl, 2) :: wx, wy, wz
  REAL(kind=realtype), DIMENSION(il, jl, 2) :: qx, qy, qz
  LOGICAL :: correctfork, storewalltensor
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
! 
  INTEGER :: unitvf=1011, ierror
  REAL(kind=realtype) :: arg1
  REAL(kind=realtype) :: result1
  INTRINSIC SQRT
  OPEN(unit=unitvf, file='verifyvf.out', status='replace', action=&
& 'write', iostat=ierror) 
  IF (ierror .NE. 0) CALL TERMINATE_CD('verifyvf', &
&                                 'Something wrong when ', 'calling open'&
&                                )
  PRINT*, 'ierror:', ierror
! Set rFilv to rFil to indicate that this is the viscous part.
! If rFilv == 0 the viscous residuals need not to be computed
! and a return can be made.
  rfilv = rfil
  IF (rfilv .EQ. zero) THEN
    RETURN
  ELSE
! Determine whether or not the pressure must be corrected
! for the presence of the turbulent kinetic energy.
    IF (kpresent) THEN
      IF (currentlevel .LE. groundlevel .OR. turbcoupled) THEN
        correctfork = .true.
      ELSE
        correctfork = .false.
      END IF
    ELSE
      correctfork = .false.
    END IF
! Determine whether or not the wall stress tensor and wall heat
! flux must be stored for viscous walls.
    storewalltensor = .false.
    IF (wallfunctions) THEN
      storewalltensor = .true.
    ELSE IF (rkstage .EQ. 0 .AND. currentlevel .EQ. groundlevel) THEN
      storewalltensor = .true.
    END IF
! Store the speed of sound squared instead of the pressure.
! To be 100 percent correct, substract 2/3*rho*k (if present)
! from the pressure to obtain the true presssure. First layer of
! halo's, because that's what is needed by the viscous stencil.
    DO k=1,ke
      DO j=1,je
        DO i=1,ie
          IF (correctfork) p(i, j, k) = p(i, j, k) - twothird*w(i, j, k&
&              , irho)*w(i, j, k, itu1)
          p(i, j, k) = gamma(i, j, k)*p(i, j, k)/w(i, j, k, irho)
        END DO
      END DO
    END DO
! Compute the nodal gradients for the nodes in the plane k = 1.
    k = 1
    k1 = 1
    k2 = 2
    CALL NODALGRADIENTS(ux, uy, uz, vx, vy, vz, wx, wy, wz, qx, qy, qz)
! Compute the viscous fluxes for the faces k == 1 and update
! the residuals for the cells k == 2.
    mue = zero
    DO j=2,jl
      DO i=2,il
! Set the value of the porosity. If not zero, it is set
! to average the eddy-viscosity and to take the factor
! rFilv into account.
        por = half*rfilv
        IF (pork(i, j, 1) .EQ. noflux) por = zero
! Compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. Compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
        mul = por*(rlv(i, j, 1)+rlv(i, j, 2))
        IF (eddymodel) mue = por*(rev(i, j, 1)+rev(i, j, 2))
        mut = mul + mue
        gm1 = half*(gamma(i, j, 1)+gamma(i, j, 2)) - one
        factlamheat = one/(prandtl*gm1)
        factturbheat = one/(prandtlturb*gm1)
        heatcoef = mul*factlamheat + mue*factturbheat
! Compute the gradients at the face by averaging the four
! nodal values.
        u_x = fourth*(ux(i-1, j-1, k1)+ux(i, j-1, k1)+ux(i-1, j, k1)+ux(&
&          i, j, k1))
        u_y = fourth*(uy(i-1, j-1, k1)+uy(i, j-1, k1)+uy(i-1, j, k1)+uy(&
&          i, j, k1))
        u_z = fourth*(uz(i-1, j-1, k1)+uz(i, j-1, k1)+uz(i-1, j, k1)+uz(&
&          i, j, k1))
        v_x = fourth*(vx(i-1, j-1, k1)+vx(i, j-1, k1)+vx(i-1, j, k1)+vx(&
&          i, j, k1))
        v_y = fourth*(vy(i-1, j-1, k1)+vy(i, j-1, k1)+vy(i-1, j, k1)+vy(&
&          i, j, k1))
        v_z = fourth*(vz(i-1, j-1, k1)+vz(i, j-1, k1)+vz(i-1, j, k1)+vz(&
&          i, j, k1))
        w_x = fourth*(wx(i-1, j-1, k1)+wx(i, j-1, k1)+wx(i-1, j, k1)+wx(&
&          i, j, k1))
        w_y = fourth*(wy(i-1, j-1, k1)+wy(i, j-1, k1)+wy(i-1, j, k1)+wy(&
&          i, j, k1))
        w_z = fourth*(wz(i-1, j-1, k1)+wz(i, j-1, k1)+wz(i-1, j, k1)+wz(&
&          i, j, k1))
        q_x = fourth*(qx(i-1, j-1, k1)+qx(i, j-1, k1)+qx(i-1, j, k1)+qx(&
&          i, j, k1))
        q_y = fourth*(qy(i-1, j-1, k1)+qy(i, j-1, k1)+qy(i-1, j, k1)+qy(&
&          i, j, k1))
        q_z = fourth*(qz(i-1, j-1, k1)+qz(i, j-1, k1)+qz(i-1, j, k1)+qz(&
&          i, j, k1))
! The gradients in the normal direction are corrected, such
! that no averaging takes places here.
! First determine the vector in the direction from the
! cell center k to cell center k+1.
        ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j, &
&          k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1, 1)+&
&          x(i, j, k+1, 1)-x(i, j, k-1, 1))
        ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j, &
&          k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1, 2)+&
&          x(i, j, k+1, 2)-x(i, j, k-1, 2))
        ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j, &
&          k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1, 3)+&
&          x(i, j, k+1, 3)-x(i, j, k-1, 3))
! Determine the length of this vector and create the
! unit normal.
        arg1 = ssx*ssx + ssy*ssy + ssz*ssz
        result1 = SQRT(arg1)
        ss = one/result1
        ssx = ss*ssx
        ssy = ss*ssy
        ssz = ss*ssz
! Correct the gradients.
        corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j, &
&          k, ivx))*ss
        u_x = u_x - corr*ssx
        u_y = u_y - corr*ssy
        u_z = u_z - corr*ssz
        corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j, &
&          k, ivy))*ss
        v_x = v_x - corr*ssx
        v_y = v_y - corr*ssy
        v_z = v_z - corr*ssz
        corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j, &
&          k, ivz))*ss
        w_x = w_x - corr*ssx
        w_y = w_y - corr*ssy
        w_z = w_z - corr*ssz
        corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j, k+1)-p(i, j, k))*&
&          ss
        q_x = q_x - corr*ssx
        q_y = q_y - corr*ssy
        q_z = q_z - corr*ssz
! Compute the stress tensor and the heat flux vector.
        fracdiv = twothird*(u_x+v_y+w_z)
        tauxx = mut*(two*u_x-fracdiv)
        tauyy = mut*(two*v_y-fracdiv)
        tauzz = mut*(two*w_z-fracdiv)
        tauxy = mut*(u_y+v_x)
        tauxz = mut*(u_z+w_x)
        tauyz = mut*(v_z+w_y)
        q_x = heatcoef*q_x
        q_y = heatcoef*q_y
        q_z = heatcoef*q_z
! Compute the average velocities for the face. Remember that
! the velocities are stored and not the momentum.
        ubar = half*(w(i, j, 1, ivx)+w(i, j, 2, ivx))
        vbar = half*(w(i, j, 1, ivy)+w(i, j, 2, ivy))
        wbar = half*(w(i, j, 1, ivz)+w(i, j, 2, ivz))
! Compute the viscous fluxes for this k-face.
        fmx = tauxx*sk(i, j, 1, 1) + tauxy*sk(i, j, 1, 2) + tauxz*sk(i, &
&          j, 1, 3)
        fmy = tauxy*sk(i, j, 1, 1) + tauyy*sk(i, j, 1, 2) + tauyz*sk(i, &
&          j, 1, 3)
        fmz = tauxz*sk(i, j, 1, 1) + tauyz*sk(i, j, 1, 2) + tauzz*sk(i, &
&          j, 1, 3)
        frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, 1, 1) + (&
&          ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, 1, 2) + (ubar*tauxz&
&          +vbar*tauyz+wbar*tauzz)*sk(i, j, 1, 3) - q_x*sk(i, j, 1, 1) - &
&          q_y*sk(i, j, 1, 2) - q_z*sk(i, j, 1, 3)
! Update the residuals of cell k == 2.
        fw(i, j, 2, imx) = fw(i, j, 2, imx) + fmx
        fw(i, j, 2, imy) = fw(i, j, 2, imy) + fmy
        fw(i, j, 2, imz) = fw(i, j, 2, imz) + fmz
        fw(i, j, 2, irhoe) = fw(i, j, 2, irhoe) + frhoe
! Store the stress tensor and the heat flux vector if this
! face is part of a viscous subface.
        IF (storewalltensor .AND. visckminpointer(i, j) .GT. 0) THEN
          nn = visckminpointer(i, j)
          viscsubface(nn)%tau(i, j, 1) = tauxx
          viscsubface(nn)%tau(i, j, 2) = tauyy
          viscsubface(nn)%tau(i, j, 3) = tauzz
          viscsubface(nn)%tau(i, j, 4) = tauxy
          viscsubface(nn)%tau(i, j, 5) = tauxz
          viscsubface(nn)%tau(i, j, 6) = tauyz
          viscsubface(nn)%q(i, j, 1) = q_x
          viscsubface(nn)%q(i, j, 2) = q_y
          viscsubface(nn)%q(i, j, 3) = q_z
        END IF
      END DO
    END DO
! Loop over the k-planes.
kloop:DO k=2,kl
! Switch the indices k1 and k2.
      kk = k1
      k1 = k2
      k2 = kk
! Compute the nodal gradients for the nodes in this k-plane.
! The results are stored in ux(:,:,k1), etc.
      CALL NODALGRADIENTS(ux, uy, uz, vx, vy, vz, wx, wy, wz, qx, qy, qz&
&                   )
!
!        ****************************************************************
!        *                                                              *
!        * Viscous fluxes in the k-direction.                           *
!        *                                                              *
!        ****************************************************************
!
      DO j=2,jl
        DO i=2,il
! Set the value of the porosity. If not zero, it is set
! to average the eddy-viscosity and to take the factor
! rFilv into account.
          por = half*rfilv
          IF (pork(i, j, k) .EQ. noflux) por = zero
! Compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. Compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j, k+1))
          IF (eddymodel) mue = por*(rev(i, j, k)+rev(i, j, k+1))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j, k+1)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! Compute the gradients at the face by averaging the four
! nodal values.
          u_x = fourth*(ux(i-1, j-1, k1)+ux(i, j-1, k1)+ux(i-1, j, k1)+&
&            ux(i, j, k1))
          u_y = fourth*(uy(i-1, j-1, k1)+uy(i, j-1, k1)+uy(i-1, j, k1)+&
&            uy(i, j, k1))
          u_z = fourth*(uz(i-1, j-1, k1)+uz(i, j-1, k1)+uz(i-1, j, k1)+&
&            uz(i, j, k1))
          v_x = fourth*(vx(i-1, j-1, k1)+vx(i, j-1, k1)+vx(i-1, j, k1)+&
&            vx(i, j, k1))
          v_y = fourth*(vy(i-1, j-1, k1)+vy(i, j-1, k1)+vy(i-1, j, k1)+&
&            vy(i, j, k1))
          v_z = fourth*(vz(i-1, j-1, k1)+vz(i, j-1, k1)+vz(i-1, j, k1)+&
&            vz(i, j, k1))
          w_x = fourth*(wx(i-1, j-1, k1)+wx(i, j-1, k1)+wx(i-1, j, k1)+&
&            wx(i, j, k1))
          w_y = fourth*(wy(i-1, j-1, k1)+wy(i, j-1, k1)+wy(i-1, j, k1)+&
&            wy(i, j, k1))
          w_z = fourth*(wz(i-1, j-1, k1)+wz(i, j-1, k1)+wz(i-1, j, k1)+&
&            wz(i, j, k1))
          q_x = fourth*(qx(i-1, j-1, k1)+qx(i, j-1, k1)+qx(i-1, j, k1)+&
&            qx(i, j, k1))
          q_y = fourth*(qy(i-1, j-1, k1)+qy(i, j-1, k1)+qy(i-1, j, k1)+&
&            qy(i, j, k1))
          q_z = fourth*(qz(i-1, j-1, k1)+qz(i, j-1, k1)+qz(i-1, j, k1)+&
&            qz(i, j, k1))
!!$             write(unitvf,*) i,j,k, u_x, u_y, u_z
! The gradients in the normal direction are corrected, such
! that no averaging takes places here.
! First determine the vector in the direction from the
! cell center k to cell center k+1.
          ssx = eighth*(x(i-1, j-1, k+1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&            , k+1, 1)-x(i-1, j, k-1, 1)+x(i, j-1, k+1, 1)-x(i, j-1, k-1&
&            , 1)+x(i, j, k+1, 1)-x(i, j, k-1, 1))
          ssy = eighth*(x(i-1, j-1, k+1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&            , k+1, 2)-x(i-1, j, k-1, 2)+x(i, j-1, k+1, 2)-x(i, j-1, k-1&
&            , 2)+x(i, j, k+1, 2)-x(i, j, k-1, 2))
          ssz = eighth*(x(i-1, j-1, k+1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&            , k+1, 3)-x(i-1, j, k-1, 3)+x(i, j-1, k+1, 3)-x(i, j-1, k-1&
&            , 3)+x(i, j, k+1, 3)-x(i, j, k-1, 3))
! Determine the length of this vector and create the
! unit normal.
          arg1 = ssx*ssx + ssy*ssy + ssz*ssz
          result1 = SQRT(arg1)
          ss = one/result1
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! Correct the gradients.
          corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j, k+1, ivx)-w(i, j&
&            , k, ivx))*ss
          u_x = u_x - corr*ssx
          u_y = u_y - corr*ssy
          u_z = u_z - corr*ssz
          corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j, k+1, ivy)-w(i, j&
&            , k, ivy))*ss
          v_x = v_x - corr*ssx
          v_y = v_y - corr*ssy
          v_z = v_z - corr*ssz
          corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j, k+1, ivz)-w(i, j&
&            , k, ivz))*ss
          w_x = w_x - corr*ssx
          w_y = w_y - corr*ssy
          w_z = w_z - corr*ssz
          corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j, k+1)-p(i, j, k))&
&            *ss
          q_x = q_x - corr*ssx
          q_y = q_y - corr*ssy
          q_z = q_z - corr*ssz
! Compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! Compute the average velocities for the face. Remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i, j, k+1, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i, j, k+1, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i, j, k+1, ivz))
! Compute the viscous fluxes for this k-face.
          fmx = tauxx*sk(i, j, k, 1) + tauxy*sk(i, j, k, 2) + tauxz*sk(i&
&            , j, k, 3)
          fmy = tauxy*sk(i, j, k, 1) + tauyy*sk(i, j, k, 2) + tauyz*sk(i&
&            , j, k, 3)
          fmz = tauxz*sk(i, j, k, 1) + tauyz*sk(i, j, k, 2) + tauzz*sk(i&
&            , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sk(i, j, k, 1) + (&
&            ubar*tauxy+vbar*tauyy+wbar*tauyz)*sk(i, j, k, 2) + (ubar*&
&            tauxz+vbar*tauyz+wbar*tauzz)*sk(i, j, k, 3) - q_x*sk(i, j, k&
&            , 1) - q_y*sk(i, j, k, 2) - q_z*sk(i, j, k, 3)
! Update the residuals of cell k and k+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i, j, k+1, imx) = fw(i, j, k+1, imx) + fmx
          fw(i, j, k+1, imy) = fw(i, j, k+1, imy) + fmy
          fw(i, j, k+1, imz) = fw(i, j, k+1, imz) + fmz
          fw(i, j, k+1, irhoe) = fw(i, j, k+1, irhoe) + frhoe
! Store the stress tensor and the heat flux vector if this
! face is part of a viscous subface.
          IF (k .EQ. kl .AND. storewalltensor .AND. visckmaxpointer(i, j&
&              ) .GT. 0) THEN
            nn = visckmaxpointer(i, j)
            viscsubface(nn)%tau(i, j, 1) = tauxx
            viscsubface(nn)%tau(i, j, 2) = tauyy
            viscsubface(nn)%tau(i, j, 3) = tauzz
            viscsubface(nn)%tau(i, j, 4) = tauxy
            viscsubface(nn)%tau(i, j, 5) = tauxz
            viscsubface(nn)%tau(i, j, 6) = tauyz
            viscsubface(nn)%q(i, j, 1) = q_x
            viscsubface(nn)%q(i, j, 2) = q_y
            viscsubface(nn)%q(i, j, 3) = q_z
          END IF
        END DO
      END DO
!
!        ****************************************************************
!        *                                                              *
!        * Viscous fluxes in the j-direction.                           *
!        *                                                              *
!        ****************************************************************
!
      DO j=1,jl
        DO i=2,il
! Set the value of the porosity. If not zero, it is set
! to average the eddy-viscosity and to take the factor
! rFilv into account.
          por = half*rfilv
          IF (porj(i, j, k) .EQ. noflux) por = zero
! Compute the laminar and (if present) the eddy viscosities
! multiplied by the porosity. Compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i, j+1, k))
          IF (eddymodel) mue = por*(rev(i, j, k)+rev(i, j+1, k))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i, j+1, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! Compute the gradients at the face by averaging the four
! nodal values.
          u_x = fourth*(ux(i-1, j, k1)+ux(i, j, k1)+ux(i-1, j, k2)+ux(i&
&            , j, k2))
          u_y = fourth*(uy(i-1, j, k1)+uy(i, j, k1)+uy(i-1, j, k2)+uy(i&
&            , j, k2))
          u_z = fourth*(uz(i-1, j, k1)+uz(i, j, k1)+uz(i-1, j, k2)+uz(i&
&            , j, k2))
          v_x = fourth*(vx(i-1, j, k1)+vx(i, j, k1)+vx(i-1, j, k2)+vx(i&
&            , j, k2))
          v_y = fourth*(vy(i-1, j, k1)+vy(i, j, k1)+vy(i-1, j, k2)+vy(i&
&            , j, k2))
          v_z = fourth*(vz(i-1, j, k1)+vz(i, j, k1)+vz(i-1, j, k2)+vz(i&
&            , j, k2))
          w_x = fourth*(wx(i-1, j, k1)+wx(i, j, k1)+wx(i-1, j, k2)+wx(i&
&            , j, k2))
          w_y = fourth*(wy(i-1, j, k1)+wy(i, j, k1)+wy(i-1, j, k2)+wy(i&
&            , j, k2))
          w_z = fourth*(wz(i-1, j, k1)+wz(i, j, k1)+wz(i-1, j, k2)+wz(i&
&            , j, k2))
          q_x = fourth*(qx(i-1, j, k1)+qx(i, j, k1)+qx(i-1, j, k2)+qx(i&
&            , j, k2))
          q_y = fourth*(qy(i-1, j, k1)+qy(i, j, k1)+qy(i-1, j, k2)+qy(i&
&            , j, k2))
          q_z = fourth*(qz(i-1, j, k1)+qz(i, j, k1)+qz(i-1, j, k2)+qz(i&
&            , j, k2))
! The gradients in the normal direction are corrected, such
! that no averaging takes places here.
! First determine the vector in the direction from the
! cell center j to cell center j+1.
          ssx = eighth*(x(i-1, j+1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i-1, j&
&            +1, k, 1)-x(i-1, j-1, k, 1)+x(i, j+1, k-1, 1)-x(i, j-1, k-1&
&            , 1)+x(i, j+1, k, 1)-x(i, j-1, k, 1))
          ssy = eighth*(x(i-1, j+1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i-1, j&
&            +1, k, 2)-x(i-1, j-1, k, 2)+x(i, j+1, k-1, 2)-x(i, j-1, k-1&
&            , 2)+x(i, j+1, k, 2)-x(i, j-1, k, 2))
          ssz = eighth*(x(i-1, j+1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i-1, j&
&            +1, k, 3)-x(i-1, j-1, k, 3)+x(i, j+1, k-1, 3)-x(i, j-1, k-1&
&            , 3)+x(i, j+1, k, 3)-x(i, j-1, k, 3))
! Determine the length of this vector and create the
! unit normal.
          arg1 = ssx*ssx + ssy*ssy + ssz*ssz
          result1 = SQRT(arg1)
          ss = one/result1
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! Correct the gradients.
          corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i, j+1, k, ivx)-w(i, j&
&            , k, ivx))*ss
          u_x = u_x - corr*ssx
          u_y = u_y - corr*ssy
          u_z = u_z - corr*ssz
          corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i, j+1, k, ivy)-w(i, j&
&            , k, ivy))*ss
          v_x = v_x - corr*ssx
          v_y = v_y - corr*ssy
          v_z = v_z - corr*ssz
          corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i, j+1, k, ivz)-w(i, j&
&            , k, ivz))*ss
          w_x = w_x - corr*ssx
          w_y = w_y - corr*ssy
          w_z = w_z - corr*ssz
          corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i, j+1, k)-p(i, j, k))&
&            *ss
          q_x = q_x - corr*ssx
          q_y = q_y - corr*ssy
          q_z = q_z - corr*ssz
! Compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! Compute the average velocities for the face. Remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i, j+1, k, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i, j+1, k, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i, j+1, k, ivz))
! Compute the viscous fluxes for this j-face.
          fmx = tauxx*sj(i, j, k, 1) + tauxy*sj(i, j, k, 2) + tauxz*sj(i&
&            , j, k, 3)
          fmy = tauxy*sj(i, j, k, 1) + tauyy*sj(i, j, k, 2) + tauyz*sj(i&
&            , j, k, 3)
          fmz = tauxz*sj(i, j, k, 1) + tauyz*sj(i, j, k, 2) + tauzz*sj(i&
&            , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*sj(i, j, k, 1) + (&
&            ubar*tauxy+vbar*tauyy+wbar*tauyz)*sj(i, j, k, 2) + (ubar*&
&            tauxz+vbar*tauyz+wbar*tauzz)*sj(i, j, k, 3) - q_x*sj(i, j, k&
&            , 1) - q_y*sj(i, j, k, 2) - q_z*sj(i, j, k, 3)
! Update the residuals of cell j and j+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i, j+1, k, imx) = fw(i, j+1, k, imx) + fmx
          fw(i, j+1, k, imy) = fw(i, j+1, k, imy) + fmy
          fw(i, j+1, k, imz) = fw(i, j+1, k, imz) + fmz
          fw(i, j+1, k, irhoe) = fw(i, j+1, k, irhoe) + frhoe
! Store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. Both the cases j == 1
! and j == jl must be tested.
          IF (j .EQ. 1 .AND. storewalltensor .AND. viscjminpointer(i, k)&
&              .GT. 0) THEN
            nn = viscjminpointer(i, k)
            viscsubface(nn)%tau(i, k, 1) = tauxx
            viscsubface(nn)%tau(i, k, 2) = tauyy
            viscsubface(nn)%tau(i, k, 3) = tauzz
            viscsubface(nn)%tau(i, k, 4) = tauxy
            viscsubface(nn)%tau(i, k, 5) = tauxz
            viscsubface(nn)%tau(i, k, 6) = tauyz
            viscsubface(nn)%q(i, k, 1) = q_x
            viscsubface(nn)%q(i, k, 2) = q_y
            viscsubface(nn)%q(i, k, 3) = q_z
          END IF
! And the j == jl case.
          IF (j .EQ. jl .AND. storewalltensor .AND. viscjmaxpointer(i, k&
&              ) .GT. 0) THEN
            nn = viscjmaxpointer(i, k)
            viscsubface(nn)%tau(i, k, 1) = tauxx
            viscsubface(nn)%tau(i, k, 2) = tauyy
            viscsubface(nn)%tau(i, k, 3) = tauzz
            viscsubface(nn)%tau(i, k, 4) = tauxy
            viscsubface(nn)%tau(i, k, 5) = tauxz
            viscsubface(nn)%tau(i, k, 6) = tauyz
            viscsubface(nn)%q(i, k, 1) = q_x
            viscsubface(nn)%q(i, k, 2) = q_y
            viscsubface(nn)%q(i, k, 3) = q_z
          END IF
        END DO
      END DO
!
!        ****************************************************************
!        *                                                              *
!        * Viscous fluxes in the i-direction.                           *
!        *                                                              *
!        ****************************************************************
!
      DO j=2,jl
        DO i=1,il
! Set the value of the porosity. If not zero, it is set
! to average the eddy-viscosity and to take the factor
! rFilv into account.
          por = half*rfilv
          IF (pori(i, j, k) .EQ. noflux) por = zero
! Compute the laminar and (if present) the eddy viscosities
! multiplied the porosity. Compute the factor in front of
! the gradients of the speed of sound squared for the heat
! flux.
          mul = por*(rlv(i, j, k)+rlv(i+1, j, k))
          IF (eddymodel) mue = por*(rev(i, j, k)+rev(i+1, j, k))
          mut = mul + mue
          gm1 = half*(gamma(i, j, k)+gamma(i+1, j, k)) - one
          factlamheat = one/(prandtl*gm1)
          factturbheat = one/(prandtlturb*gm1)
          heatcoef = mul*factlamheat + mue*factturbheat
! Compute the gradients at the face by averaging the four
! nodal values.
          u_x = fourth*(ux(i, j-1, k1)+ux(i, j, k1)+ux(i, j-1, k2)+ux(i&
&            , j, k2))
          u_y = fourth*(uy(i, j-1, k1)+uy(i, j, k1)+uy(i, j-1, k2)+uy(i&
&            , j, k2))
          u_z = fourth*(uz(i, j-1, k1)+uz(i, j, k1)+uz(i, j-1, k2)+uz(i&
&            , j, k2))
          v_x = fourth*(vx(i, j-1, k1)+vx(i, j, k1)+vx(i, j-1, k2)+vx(i&
&            , j, k2))
          v_y = fourth*(vy(i, j-1, k1)+vy(i, j, k1)+vy(i, j-1, k2)+vy(i&
&            , j, k2))
          v_z = fourth*(vz(i, j-1, k1)+vz(i, j, k1)+vz(i, j-1, k2)+vz(i&
&            , j, k2))
          w_x = fourth*(wx(i, j-1, k1)+wx(i, j, k1)+wx(i, j-1, k2)+wx(i&
&            , j, k2))
          w_y = fourth*(wy(i, j-1, k1)+wy(i, j, k1)+wy(i, j-1, k2)+wy(i&
&            , j, k2))
          w_z = fourth*(wz(i, j-1, k1)+wz(i, j, k1)+wz(i, j-1, k2)+wz(i&
&            , j, k2))
          q_x = fourth*(qx(i, j-1, k1)+qx(i, j, k1)+qx(i, j-1, k2)+qx(i&
&            , j, k2))
          q_y = fourth*(qy(i, j-1, k1)+qy(i, j, k1)+qy(i, j-1, k2)+qy(i&
&            , j, k2))
          q_z = fourth*(qz(i, j-1, k1)+qz(i, j, k1)+qz(i, j-1, k2)+qz(i&
&            , j, k2))
! The gradients in the normal direction are corrected, such
! that no averaging takes places here.
! First determine the vector in the direction from the
! cell center i to cell center i+1.
          ssx = eighth*(x(i+1, j-1, k-1, 1)-x(i-1, j-1, k-1, 1)+x(i+1, j&
&            -1, k, 1)-x(i-1, j-1, k, 1)+x(i+1, j, k-1, 1)-x(i-1, j, k-1&
&            , 1)+x(i+1, j, k, 1)-x(i-1, j, k, 1))
          ssy = eighth*(x(i+1, j-1, k-1, 2)-x(i-1, j-1, k-1, 2)+x(i+1, j&
&            -1, k, 2)-x(i-1, j-1, k, 2)+x(i+1, j, k-1, 2)-x(i-1, j, k-1&
&            , 2)+x(i+1, j, k, 2)-x(i-1, j, k, 2))
          ssz = eighth*(x(i+1, j-1, k-1, 3)-x(i-1, j-1, k-1, 3)+x(i+1, j&
&            -1, k, 3)-x(i-1, j-1, k, 3)+x(i+1, j, k-1, 3)-x(i-1, j, k-1&
&            , 3)+x(i+1, j, k, 3)-x(i-1, j, k, 3))
! Determine the length of this vector and create the
! unit normal.
          arg1 = ssx*ssx + ssy*ssy + ssz*ssz
          result1 = SQRT(arg1)
          ss = one/result1
          ssx = ss*ssx
          ssy = ss*ssy
          ssz = ss*ssz
! Correct the gradients.
          corr = u_x*ssx + u_y*ssy + u_z*ssz - (w(i+1, j, k, ivx)-w(i, j&
&            , k, ivx))*ss
          u_x = u_x - corr*ssx
          u_y = u_y - corr*ssy
          u_z = u_z - corr*ssz
          corr = v_x*ssx + v_y*ssy + v_z*ssz - (w(i+1, j, k, ivy)-w(i, j&
&            , k, ivy))*ss
          v_x = v_x - corr*ssx
          v_y = v_y - corr*ssy
          v_z = v_z - corr*ssz
          corr = w_x*ssx + w_y*ssy + w_z*ssz - (w(i+1, j, k, ivz)-w(i, j&
&            , k, ivz))*ss
          w_x = w_x - corr*ssx
          w_y = w_y - corr*ssy
          w_z = w_z - corr*ssz
          corr = q_x*ssx + q_y*ssy + q_z*ssz + (p(i+1, j, k)-p(i, j, k))&
&            *ss
          q_x = q_x - corr*ssx
          q_y = q_y - corr*ssy
          q_z = q_z - corr*ssz
! Compute the stress tensor and the heat flux vector.
          fracdiv = twothird*(u_x+v_y+w_z)
          tauxx = mut*(two*u_x-fracdiv)
          tauyy = mut*(two*v_y-fracdiv)
          tauzz = mut*(two*w_z-fracdiv)
          tauxy = mut*(u_y+v_x)
          tauxz = mut*(u_z+w_x)
          tauyz = mut*(v_z+w_y)
          q_x = heatcoef*q_x
          q_y = heatcoef*q_y
          q_z = heatcoef*q_z
! Compute the average velocities for the face. Remember that
! the velocities are stored and not the momentum.
          ubar = half*(w(i, j, k, ivx)+w(i+1, j, k, ivx))
          vbar = half*(w(i, j, k, ivy)+w(i+1, j, k, ivy))
          wbar = half*(w(i, j, k, ivz)+w(i+1, j, k, ivz))
! Compute the viscous fluxes for this i-face.
          fmx = tauxx*si(i, j, k, 1) + tauxy*si(i, j, k, 2) + tauxz*si(i&
&            , j, k, 3)
          fmy = tauxy*si(i, j, k, 1) + tauyy*si(i, j, k, 2) + tauyz*si(i&
&            , j, k, 3)
          fmz = tauxz*si(i, j, k, 1) + tauyz*si(i, j, k, 2) + tauzz*si(i&
&            , j, k, 3)
          frhoe = (ubar*tauxx+vbar*tauxy+wbar*tauxz)*si(i, j, k, 1) + (&
&            ubar*tauxy+vbar*tauyy+wbar*tauyz)*si(i, j, k, 2) + (ubar*&
&            tauxz+vbar*tauyz+wbar*tauzz)*si(i, j, k, 3) - q_x*si(i, j, k&
&            , 1) - q_y*si(i, j, k, 2) - q_z*si(i, j, k, 3)
! Update the residuals of cell i and i+1.
          fw(i, j, k, imx) = fw(i, j, k, imx) - fmx
          fw(i, j, k, imy) = fw(i, j, k, imy) - fmy
          fw(i, j, k, imz) = fw(i, j, k, imz) - fmz
          fw(i, j, k, irhoe) = fw(i, j, k, irhoe) - frhoe
          fw(i+1, j, k, imx) = fw(i+1, j, k, imx) + fmx
          fw(i+1, j, k, imy) = fw(i+1, j, k, imy) + fmy
          fw(i+1, j, k, imz) = fw(i+1, j, k, imz) + fmz
          fw(i+1, j, k, irhoe) = fw(i+1, j, k, irhoe) + frhoe
! Store the stress tensor and the heat flux vector if this
! face is part of a viscous subface. Both the cases i == 1
! and i == il must be tested.
          IF (i .EQ. 1 .AND. storewalltensor .AND. visciminpointer(j, k)&
&              .GT. 0) THEN
            nn = visciminpointer(j, k)
            viscsubface(nn)%tau(j, k, 1) = tauxx
            viscsubface(nn)%tau(j, k, 2) = tauyy
            viscsubface(nn)%tau(j, k, 3) = tauzz
            viscsubface(nn)%tau(j, k, 4) = tauxy
            viscsubface(nn)%tau(j, k, 5) = tauxz
            viscsubface(nn)%tau(j, k, 6) = tauyz
            viscsubface(nn)%q(j, k, 1) = q_x
            viscsubface(nn)%q(j, k, 2) = q_y
            viscsubface(nn)%q(j, k, 3) = q_z
          END IF
! And the i == il case.
          IF (i .EQ. il .AND. storewalltensor .AND. viscimaxpointer(j, k&
&              ) .GT. 0) THEN
            nn = viscimaxpointer(j, k)
            viscsubface(nn)%tau(j, k, 1) = tauxx
            viscsubface(nn)%tau(j, k, 2) = tauyy
            viscsubface(nn)%tau(j, k, 3) = tauzz
            viscsubface(nn)%tau(j, k, 4) = tauxy
            viscsubface(nn)%tau(j, k, 5) = tauxz
            viscsubface(nn)%tau(j, k, 6) = tauyz
            viscsubface(nn)%q(j, k, 1) = q_x
            viscsubface(nn)%q(j, k, 2) = q_y
            viscsubface(nn)%q(j, k, 3) = q_z
          END IF
        END DO
      END DO
    END DO kloop
! Restore the pressure in p. Again only the first layer of
! halo cells.
    DO k=1,ke
      DO j=1,je
        DO i=1,ie
          p(i, j, k) = w(i, j, k, irho)*p(i, j, k)/gamma(i, j, k)
        END DO
      END DO
    END DO
    IF (correctfork) THEN
      DO k=1,ke
        DO j=1,je
          DO i=1,ie
            p(i, j, k) = p(i, j, k) + twothird*w(i, j, k, irho)*w(i, j, &
&              k, itu1)
          END DO
        END DO
      END DO
    END IF
! Possibly correct the wall shear stress.
    CALL UTAUWF_CD(rfilv)
    CLOSE(unitvf) 
  END IF
END SUBROUTINE VISCOUSFLUX_CD

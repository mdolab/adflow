!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
SUBROUTINE METRIC_BLOCK_CD(nn, level, sps)
  USE BCTYPES_SPATIAL_D
  USE CGNSGRID_SPATIAL_D
  USE COMMUNICATION_SPATIAL_D
  USE INPUTTIMESPECTRAL_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * metric computes the face normals and the volume for the given  *
!      * grid level for all spectral solutions. First the volumes are   *
!      * computed assuming that the block is right handed. Then the     *
!      * number of positive and negative volumes are determined. If all *
!      * volumes are positive the block is indeed right handed; if all  *
!      * volumes are negative the block is left handed and both the     *
!      * volumes and the normals must be negated (for the normals this  *
!      * is done by the introduction of fact, which is either -0.5 or   *
!      * 0.5); if there are both positive and negative volumes the mesh *
!      * is not valid.                                                  *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
  INTEGER(kind=inttype), INTENT(IN) :: level
!
!      Local parameter.
!
  REAL(kind=realtype), PARAMETER :: thresvolume=1.e-2_realType
!
!      Local variables.
!
  INTEGER :: ierr
  INTEGER(kind=inttype) :: i, j, k, n, m, l
  INTEGER(kind=inttype) :: nn, mm, sps
  INTEGER(kind=inttype) :: nvolneg, nvolpos
  INTEGER(kind=inttype) :: nvolbad, nvolbadglobal
  INTEGER(kind=inttype) :: nblockbad, nblockbadglobal
  REAL(kind=realtype) :: fact, mult
  REAL(kind=realtype) :: xp, yp, zp, vp1, vp2, vp3, vp4, vp5, vp6
  REAL(kind=realtype), DIMENSION(3) :: v1, v2
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ss
  CHARACTER(len=10) :: integerstring
  LOGICAL :: checkk, checkj, checki, checkall
  LOGICAL :: badvolume
  REAL(kind=realtype) :: VOLPYM
  EXTERNAL FLOWDOMS
  TYPE(#UNKNOWNDERIVEDTYPE0#) :: result1
  REAL(kind=realtype) :: arg1
  TYPE(UNKNOWNDERIVEDTYPE0) :: FLOWDOMS
  INTRINSIC ABS
  INTRINSIC SQRT
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Compute the volumes. The hexahedron is split into 6 pyramids
! whose volumes are computed. The volume is positive for a
! right handed block.
! Initialize the volumes to zero. The reasons is that the second
! level halo's must be initialized to zero and for convenience
! all the volumes are set to zero.
  vol = zero
  DO k=1,ke
    n = k - 1
    checkk = .true.
    IF (k .EQ. 1 .OR. k .EQ. ke) checkk = .false.
    DO j=1,je
      m = j - 1
      checkj = .true.
      IF (j .EQ. 1 .OR. j .EQ. je) checkj = .false.
      DO i=1,ie
        l = i - 1
        checki = .true.
        IF (i .EQ. 1 .OR. i .EQ. ie) checki = .false.
! Determine whether or not the voluem must be checked for
! quality. Only owned volumes are checked, not halo's.
        checkall = .false.
        IF (checkk .AND. checkj .AND. checki) checkall = .true.
! Compute the coordinates of the center of gravity.
        xp = eighth*(x(i, j, k, 1)+x(i, m, k, 1)+x(i, m, n, 1)+x(i, j, n&
&          , 1)+x(l, j, k, 1)+x(l, m, k, 1)+x(l, m, n, 1)+x(l, j, n, 1))
        yp = eighth*(x(i, j, k, 2)+x(i, m, k, 2)+x(i, m, n, 2)+x(i, j, n&
&          , 2)+x(l, j, k, 2)+x(l, m, k, 2)+x(l, m, n, 2)+x(l, j, n, 2))
        zp = eighth*(x(i, j, k, 3)+x(i, m, k, 3)+x(i, m, n, 3)+x(i, j, n&
&          , 3)+x(l, j, k, 3)+x(l, m, k, 3)+x(l, m, n, 3)+x(l, j, n, 3))
! Compute the volumes of the 6 sub pyramids. The
! arguments of volpym must be such that for a (regular)
! right handed hexahedron all volumes are positive.
        vp1 = VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, j&
&          , n, 1), x(i, j, n, 2), x(i, j, n, 3), x(i, m, n, 1), x(i, m, &
&          n, 2), x(i, m, n, 3), x(i, m, k, 1), x(i, m, k, 2), x(i, m, k&
&          , 3))
        vp2 = VOLPYM(x(l, j, k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, m&
&          , k, 1), x(l, m, k, 2), x(l, m, k, 3), x(l, m, n, 1), x(l, m, &
&          n, 2), x(l, m, n, 3), x(l, j, n, 1), x(l, j, n, 2), x(l, j, n&
&          , 3))
        vp3 = VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(l, j&
&          , k, 1), x(l, j, k, 2), x(l, j, k, 3), x(l, j, n, 1), x(l, j, &
&          n, 2), x(l, j, n, 3), x(i, j, n, 1), x(i, j, n, 2), x(i, j, n&
&          , 3))
        vp4 = VOLPYM(x(i, m, k, 1), x(i, m, k, 2), x(i, m, k, 3), x(i, m&
&          , n, 1), x(i, m, n, 2), x(i, m, n, 3), x(l, m, n, 1), x(l, m, &
&          n, 2), x(l, m, n, 3), x(l, m, k, 1), x(l, m, k, 2), x(l, m, k&
&          , 3))
        vp5 = VOLPYM(x(i, j, k, 1), x(i, j, k, 2), x(i, j, k, 3), x(i, m&
&          , k, 1), x(i, m, k, 2), x(i, m, k, 3), x(l, m, k, 1), x(l, m, &
&          k, 2), x(l, m, k, 3), x(l, j, k, 1), x(l, j, k, 2), x(l, j, k&
&          , 3))
        vp6 = VOLPYM(x(i, j, n, 1), x(i, j, n, 2), x(i, j, n, 3), x(l, j&
&          , n, 1), x(l, j, n, 2), x(l, j, n, 3), x(l, m, n, 1), x(l, m, &
&          n, 2), x(l, m, n, 3), x(i, m, n, 1), x(i, m, n, 2), x(i, m, n&
&          , 3))
! Set the volume to 1/6 of the sum of the volumes of the
! pyramid. Remember that volpym computes 6 times the
! volume.
        vol(i, j, k) = sixth*(vp1+vp2+vp3+vp4+vp5+vp6)
        IF (vol(i, j, k) .GE. 0.) THEN
          vol(i, j, k) = vol(i, j, k)
        ELSE
          vol(i, j, k) = -vol(i, j, k)
        END IF
      END DO
    END DO
  END DO
! Some additional safety stuff for halo volumes.
  DO k=2,kl
    DO j=2,jl
      IF (vol(1, j, k) .LE. eps) vol(1, j, k) = vol(2, j, k)
      IF (vol(ie, j, k) .LE. eps) vol(ie, j, k) = vol(il, j, k)
    END DO
  END DO
  DO k=2,kl
    DO i=1,ie
      IF (vol(i, 1, k) .LE. eps) vol(i, 1, k) = vol(i, 2, k)
      IF (vol(i, je, k) .LE. eps) vol(i, je, k) = vol(i, jl, k)
    END DO
  END DO
  DO j=1,je
    DO i=1,ie
      IF (vol(i, j, 1) .LE. eps) vol(i, j, 1) = vol(i, j, 2)
      IF (vol(i, j, ke) .LE. eps) vol(i, j, ke) = vol(i, j, kl)
    END DO
  END DO
! Set the factor in the surface normals computation. For a
! left handed block this factor is negative, such that the
! normals still point in the direction of increasing index.
! The formulae used later on assume a right handed block
! and fact is used to correct this for a left handed block,
! as well as the scaling factor of 0.5
  result1 = FLOWDOMS(nn, level, sps)
  IF (result1%righthanded) THEN
    fact = half
  ELSE
    fact = -half
  END IF
! Check if both positive and negative volumes occur. If so,
! the block is bad and the counter nBlockBad is updated.
!
!          **************************************************************
!          *                                                            *
!          * Computation of the face normals in i-, j- and k-direction. *
!          * Formula's are valid for a right handed block; for a left   *
!          * handed block the correct orientation is obtained via fact. *
!          * The normals point in the direction of increasing index.    *
!          * The absolute value of fact is 0.5, because the cross       *
!          * product of the two diagonals is twice the normal vector.   *
!          *                                                            *
!          * Note that also the normals of the first level halo cells   *
!          * are computed. These are needed for the viscous fluxes.     *
!          *                                                            *
!          **************************************************************
!
! Projected areas of cell faces in the i direction.
  DO k=1,ke
    n = k - 1
    DO j=1,je
      m = j - 1
      DO i=0,ie
! Determine the two diagonal vectors of the face.
        v1(1) = x(i, j, n, 1) - x(i, m, k, 1)
        v1(2) = x(i, j, n, 2) - x(i, m, k, 2)
        v1(3) = x(i, j, n, 3) - x(i, m, k, 3)
        v2(1) = x(i, j, k, 1) - x(i, m, n, 1)
        v2(2) = x(i, j, k, 2) - x(i, m, n, 2)
        v2(3) = x(i, j, k, 3) - x(i, m, n, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        si(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        si(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        si(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
    END DO
  END DO
! Projected areas of cell faces in the j direction.
  DO k=1,ke
    n = k - 1
    DO j=0,je
      DO i=1,ie
        l = i - 1
! Determine the two diagonal vectors of the face.
        v1(1) = x(i, j, n, 1) - x(l, j, k, 1)
        v1(2) = x(i, j, n, 2) - x(l, j, k, 2)
        v1(3) = x(i, j, n, 3) - x(l, j, k, 3)
        v2(1) = x(l, j, n, 1) - x(i, j, k, 1)
        v2(2) = x(l, j, n, 2) - x(i, j, k, 2)
        v2(3) = x(l, j, n, 3) - x(i, j, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        sj(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        sj(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        sj(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
    END DO
  END DO
! Projected areas of cell faces in the k direction.
  DO k=0,ke
    DO j=1,je
      m = j - 1
      DO i=1,ie
        l = i - 1
! Determine the two diagonal vectors of the face.
        v1(1) = x(i, j, k, 1) - x(l, m, k, 1)
        v1(2) = x(i, j, k, 2) - x(l, m, k, 2)
        v1(3) = x(i, j, k, 3) - x(l, m, k, 3)
        v2(1) = x(l, j, k, 1) - x(i, m, k, 1)
        v2(2) = x(l, j, k, 2) - x(i, m, k, 2)
        v2(3) = x(l, j, k, 3) - x(i, m, k, 3)
! The face normal, which is the cross product of the two
! diagonal vectors times fact; remember that fact is
! either -0.5 or 0.5.
        sk(i, j, k, 1) = fact*(v1(2)*v2(3)-v1(3)*v2(2))
        sk(i, j, k, 2) = fact*(v1(3)*v2(1)-v1(1)*v2(3))
        sk(i, j, k, 3) = fact*(v1(1)*v2(2)-v1(2)*v2(1))
      END DO
    END DO
  END DO
!
!          **************************************************************
!          *                                                            *
!          * The unit normals on the boundary faces. These always point *
!          * out of the domain, so a multiplication by -1 is needed for *
!          * the iMin, jMin and kMin boundaries.                        *
!          *                                                            *
!          **************************************************************
!
! Loop over the boundary subfaces of this block.
bocoloop:DO mm=1,nbocos
! Determine the block face on which this subface is located
! and set ss and mult accordingly.
    SELECT CASE  (bcfaceid(mm)) 
    CASE (imin) 
      mult = -one
      ss => si(1, :, :, :)
    CASE (imax) 
      mult = one
      ss => si(il, :, :, :)
    CASE (jmin) 
      mult = -one
      ss => sj(:, 1, :, :)
    CASE (jmax) 
      mult = one
      ss => sj(:, jl, :, :)
    CASE (kmin) 
      mult = -one
      ss => sk(:, :, 1, :)
    CASE (kmax) 
      mult = one
      ss => sk(:, :, kl, :)
    END SELECT
! Loop over the boundary faces of the subface.
    DO j=bcdata(mm)%jcbeg,bcdata(mm)%jcend
      DO i=bcdata(mm)%icbeg,bcdata(mm)%icend
! Compute the inverse of the length of the normal vector
! and possibly correct for inward pointing.
        xp = ss(i, j, 1)
        yp = ss(i, j, 2)
        zp = ss(i, j, 3)
        arg1 = xp*xp + yp*yp + zp*zp
        fact = SQRT(arg1)
        IF (fact .GT. zero) fact = mult/fact
! Compute the unit normal.
        bcdata(mm)%norm(i, j, 1) = fact*xp
        bcdata(mm)%norm(i, j, 2) = fact*yp
        bcdata(mm)%norm(i, j, 3) = fact*zp
      END DO
    END DO
  END DO bocoloop
END SUBROUTINE METRIC_BLOCK_CD

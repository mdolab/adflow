!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!
!      ******************************************************************
!      *                                                                *
!      * File:          saSolve.f90                                     *
!      * Author:        Georgi Kalitzin, Edwin van der Weide,           *
!      *                Steve Repsher (blanking)                        *
!      * Starting date: 06-11-2003                                      *
!      * Last modified: 07-05-2005                                      *
!      *                                                                *
!      ******************************************************************
!
SUBROUTINE SASOLVE_CD(resonly)
  USE BCTYPES_SPATIAL_D
  USE INPUTITERATION_SPATIAL_D
  USE INPUTPHYSICS_SPATIAL_D
  USE PARAMTURB_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE TURBMOD_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  IMPLICIT NONE
!
!      ******************************************************************
!      *                                                                *
!      * saSolve solves the turbulent transport equation for the        *
!      * original Spalart-Allmaras model in a segregated manner using   *
!      * a diagonal dominant ADI-scheme.                                *
!      *                                                                *
!      ******************************************************************
!
!
!      Subroutine arguments.
!
  LOGICAL, INTENT(IN) :: resonly
!
!      Local parameters.
!
  REAL(kind=realtype), PARAMETER :: xminn=1.e-10_realType
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, k, nn
  REAL(kind=realtype) :: cv13, kar2inv, cw36, cb3inv
  REAL(kind=realtype) :: fv1, fv2, ft2
  REAL(kind=realtype) :: ss, sst, nu, dist2inv, chi, chi2, chi3
  REAL(kind=realtype) :: rr, gg, gg6, termfw, fwsa, term1, term2
  REAL(kind=realtype) :: dfv1, dfv2, dft2, drr, dgg, dfw
  REAL(kind=realtype) :: voli, volmi, volpi, xm, ym, zm, xp, yp, zp
  REAL(kind=realtype) :: xa, ya, za, ttm, ttp, cnud, cam, cap
  REAL(kind=realtype) :: nutm, nutp, num, nup, cdm, cdp
  REAL(kind=realtype) :: c1m, c1p, c10, b1, c1, d1, qs
  REAL(kind=realtype) :: uu, um, up, factor, f, tu1p, rblank
  REAL(kind=realtype), DIMENSION(2:il, 2:jl, 2:kl) :: qq
  REAL(kind=realtype) :: pwx1
  INTRINSIC EXP
  INTRINSIC MAX
  EXTERNAL UNSTEADYTURBTERM
  EXTERNAL TURBADVECTION
  INTRINSIC REAL
  EXTERNAL PRODKATOLAUNDER
  INTRINSIC MIN
  REAL(kind=realtype) :: max7
  REAL(kind=realtype) :: max6
  REAL(kind=realtype) :: max5
  INTRINSIC SQRT
  REAL(kind=realtype) :: max4
  REAL(kind=realtype) :: max3
  REAL(kind=realtype) :: max2
  REAL :: max1
  IF (kl .LT. il) THEN
    IF (il .LT. jl) THEN
      max1 = jl
    ELSE
      max1 = il
    END IF
  ELSE IF (kl .LT. jl) THEN
    max1 = jl
  ELSE
    max1 = kl
  END IF
  REAL(kind=realtype), DIMENSION(2:max1) :: bb, cc, dd, ff
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ddw, ww, ddvt
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
  LOGICAL, DIMENSION(2:jl, 2:kl), TARGET :: flagi2, flagil
  LOGICAL, DIMENSION(2:il, 2:kl), TARGET :: flagj2, flagjl
  LOGICAL, DIMENSION(2:il, 2:jl), TARGET :: flagk2, flagkl
  LOGICAL, DIMENSION(:, :), POINTER :: flag
  EXTERNAL PRODKATOLAUNDER
  EXTERNAL TURBADVECTION
  EXTERNAL UNSTEADYTURBTERM
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Set model constants
  cv13 = rsacv1**3
  kar2inv = one/rsak**2
  cw36 = rsacw3**6
  cb3inv = one/rsacb3
! Set the pointer for dvt in dw, such that the code is more
! readable. Also set the pointers for the production term
! and vorticity.
  dvt => dw(1:, 1:, 1:, idvt:)
  prod => dw(1:, 1:, 1:, iprod)
  vort => prod
!
!      ******************************************************************
!      *                                                                *
!      * Production term.                                               *
!      *                                                                *
!      ******************************************************************
!
  SELECT CASE  (turbprod) 
  CASE (strain) 
    CALL PRODSMAG2_CD()
  CASE (vorticity) 
    CALL PRODWMAG2_CD()
  CASE (katolaunder) 
    CALL PRODKATOLAUNDER()
  END SELECT
!
!      ******************************************************************
!      *                                                                *
!      * Source terms.                                                  *
!      *                                                                *
!      * Determine the source term and its derivative w.r.t. nuTilde    *
!      * for all internal cells of the block.                           *
!      *                                                                *
!      ******************************************************************
!
  DO k=2,kl
    DO j=2,jl
      DO i=2,il
! First take the square root of the production term to
! obtain the correct production term for spalart-allmaras.
        ss = SQRT(prod(i, j, k))
! Compute the laminar kinematic viscosity, the inverse of
! wall distance squared, the ratio chi (ratio of nuTilde
! and nu) and the functions fv1 and fv2. The latter corrects
! the production term near a viscous wall.
        nu = rlv(i, j, k)/w(i, j, k, irho)
        dist2inv = one/d2wall(i, j, k)**2
        chi = w(i, j, k, itu1)/nu
        chi2 = chi*chi
        chi3 = chi*chi2
        fv1 = chi3/(chi3+cv13)
        fv2 = one - chi/(one+chi*fv1)
! The function ft2, which is designed to keep a laminar
! solution laminar. When running in fully turbulent mode
! this function should be set to 0.0.
        ft2 = rsact3*EXP(-(rsact4*chi2))
! ft2 = zero
! Correct the production term to account for the influence
! of the wall. Make sure that this term remains positive
! (the function fv2 is negative between chi = 1 and 18.4,
! which can cause sst to go negative, which is undesirable).
        sst = ss + w(i, j, k, itu1)*fv2*kar2inv*dist2inv
        IF (sst .LT. xminn) THEN
          sst = xminn
        ELSE
          sst = sst
        END IF
! Compute the function fw. The argument rr is cut off at 10
! to avoid numerical problems. This is ok, because the
! asymptotical value of fw is then already reached.
        rr = w(i, j, k, itu1)*kar2inv*dist2inv/sst
        IF (rr .GT. 10.0_realType) THEN
          rr = 10.0_realType
        ELSE
          rr = rr
        END IF
        gg = rr + rsacw2*(rr**6-rr)
        gg6 = gg**6
        pwx1 = (one+cw36)/(gg6+cw36)
        termfw = pwx1**sixth
        fwsa = gg*termfw
! Compute the source term; some terms are saved for the
! linearization. The source term is stored in dvt.
        term1 = rsacb1*(one-ft2)*ss
        term2 = dist2inv*(kar2inv*rsacb1*((one-ft2)*fv2+ft2)-rsacw1*fwsa&
&          )
        dvt(i, j, k, 1) = (term1+term2*w(i, j, k, itu1))*w(i, j, k, itu1&
&          )
! Compute some derivatives w.r.t. nuTilde. These will occur
! in the left hand side, i.e. the matrix for the implicit
! treatment.
        dfv1 = three*chi2*cv13/(chi3+cv13)**2
        dfv2 = (chi2*dfv1-one)/(nu*(one+chi*fv1)**2)
        dft2 = -(two*rsact4*chi*ft2/nu)
        drr = (one-rr*(fv2+w(i, j, k, itu1)*dfv2))*kar2inv*dist2inv/sst
        dgg = (one-rsacw2+six*rsacw2*rr**5)*drr
        dfw = cw36/(gg6+cw36)*termfw*dgg
! Compute the source term jacobian. Note that the part
! containing term1 is treated explicitly. The reason is that
! implicit treatment of this part leads to a decrease of the
! diagonal dominance of the jacobian and it thus decreases
! the stability. You may want to play around and try to
! take this term into account in the jacobian.
! Note that -dsource/dnu is stored.
        qq(i, j, k) = -(two*term2*w(i, j, k, itu1)) - dist2inv*w(i, j, k&
&          , itu1)*w(i, j, k, itu1)*(rsacb1*kar2inv*(dfv2-ft2*dfv2-fv2*&
&          dft2+dft2)-rsacw1*dfw)
        IF (qq(i, j, k) .LT. zero) THEN
          qq(i, j, k) = zero
        ELSE
          qq(i, j, k) = qq(i, j, k)
        END IF
      END DO
    END DO
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Advection and unsteady terms.                                  *
!      *                                                                *
!      ******************************************************************
!
  nn = itu1 - 1
  CALL TURBADVECTION(1_intType, 1_intType, nn, qq)
  CALL UNSTEADYTURBTERM(1_intType, 1_intType, nn, qq)
!
!      ******************************************************************
!      *                                                                *
!      * Viscous terms in k-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  DO k=2,kl
    DO j=2,jl
      DO i=2,il
! Compute the metrics in zeta-direction, i.e. along the
! line k = constant.
        voli = one/vol(i, j, k)
        volmi = two/(vol(i, j, k)+vol(i, j, k-1))
        volpi = two/(vol(i, j, k)+vol(i, j, k+1))
        xm = sk(i, j, k-1, 1)*volmi
        ym = sk(i, j, k-1, 2)*volmi
        zm = sk(i, j, k-1, 3)*volmi
        xp = sk(i, j, k, 1)*volpi
        yp = sk(i, j, k, 2)*volpi
        zp = sk(i, j, k, 3)*volpi
        xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
        ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
        za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
        ttm = xm*xa + ym*ya + zm*za
        ttp = xp*xa + yp*ya + zp*za
! Computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! Furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! The second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! In this way the metric can be taken into account.
! Compute the diffusion coefficients multiplying the nodes
! k+1, k and k-1 in the second derivative. Make sure that
! these coefficients are nonnegative.
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        cam = ttm*cnud
        cap = ttp*cnud
        nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
        nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
        nu = rlv(i, j, k)/w(i, j, k, irho)
        num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
        nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        IF (cdm + cam .LT. zero) THEN
          c1m = zero
        ELSE
          c1m = cdm + cam
        END IF
        IF (cdp + cap .LT. zero) THEN
          c1p = zero
        ELSE
          c1p = cdp + cap
        END IF
        c10 = c1m + c1p
! Update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dvt(i, j, k, 1) = dvt(i, j, k, 1) + c1m*w(i, j, k-1, itu1) - c10&
&          *w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
        b1 = -c1m
        c1 = c10
        d1 = -c1p
! Update the central jacobian. For nonboundary cells this
! is simply c1. For boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! The boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
        IF (k .EQ. 2) THEN
          IF (bmtk1(i, j, itu1, itu1) .LT. zero) THEN
            max2 = zero
          ELSE
            max2 = bmtk1(i, j, itu1, itu1)
          END IF
          qq(i, j, k) = qq(i, j, k) + c1 - b1*max2
        ELSE IF (k .EQ. kl) THEN
          IF (bmtk2(i, j, itu1, itu1) .LT. zero) THEN
            max3 = zero
          ELSE
            max3 = bmtk2(i, j, itu1, itu1)
          END IF
          qq(i, j, k) = qq(i, j, k) + c1 - d1*max3
        ELSE
          qq(i, j, k) = qq(i, j, k) + c1
        END IF
      END DO
    END DO
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Viscous terms in j-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  DO k=2,kl
    DO j=2,jl
      DO i=2,il
! Compute the metrics in eta-direction, i.e. along the
! line j = constant.
        voli = one/vol(i, j, k)
        volmi = two/(vol(i, j, k)+vol(i, j-1, k))
        volpi = two/(vol(i, j, k)+vol(i, j+1, k))
        xm = sj(i, j-1, k, 1)*volmi
        ym = sj(i, j-1, k, 2)*volmi
        zm = sj(i, j-1, k, 3)*volmi
        xp = sj(i, j, k, 1)*volpi
        yp = sj(i, j, k, 2)*volpi
        zp = sj(i, j, k, 3)*volpi
        xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
        ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
        za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
        ttm = xm*xa + ym*ya + zm*za
        ttp = xp*xa + yp*ya + zp*za
! Computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! Furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! The second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! In this way the metric can be taken into account.
! Compute the diffusion coefficients multiplying the nodes
! j+1, j and j-1 in the second derivative. Make sure that
! these coefficients are nonnegative.
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        cam = ttm*cnud
        cap = ttp*cnud
        nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
        nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
        nu = rlv(i, j, k)/w(i, j, k, irho)
        num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
        nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        IF (cdm + cam .LT. zero) THEN
          c1m = zero
        ELSE
          c1m = cdm + cam
        END IF
        IF (cdp + cap .LT. zero) THEN
          c1p = zero
        ELSE
          c1p = cdp + cap
        END IF
        c10 = c1m + c1p
! Update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dvt(i, j, k, 1) = dvt(i, j, k, 1) + c1m*w(i, j-1, k, itu1) - c10&
&          *w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
        b1 = -c1m
        c1 = c10
        d1 = -c1p
! Update the central jacobian. For nonboundary cells this
! is simply c1. For boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! The boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
        IF (j .EQ. 2) THEN
          IF (bmtj1(i, k, itu1, itu1) .LT. zero) THEN
            max4 = zero
          ELSE
            max4 = bmtj1(i, k, itu1, itu1)
          END IF
          qq(i, j, k) = qq(i, j, k) + c1 - b1*max4
        ELSE IF (j .EQ. jl) THEN
          IF (bmtj2(i, k, itu1, itu1) .LT. zero) THEN
            max5 = zero
          ELSE
            max5 = bmtj2(i, k, itu1, itu1)
          END IF
          qq(i, j, k) = qq(i, j, k) + c1 - d1*max5
        ELSE
          qq(i, j, k) = qq(i, j, k) + c1
        END IF
      END DO
    END DO
  END DO
!
!      ******************************************************************
!      *                                                                *
!      * Viscous terms in i-direction.                                  *
!      *                                                                *
!      ******************************************************************
!
  DO k=2,kl
    DO j=2,jl
      DO i=2,il
! Compute the metrics in xi-direction, i.e. along the
! line i = constant.
        voli = one/vol(i, j, k)
        volmi = two/(vol(i, j, k)+vol(i-1, j, k))
        volpi = two/(vol(i, j, k)+vol(i+1, j, k))
        xm = si(i-1, j, k, 1)*volmi
        ym = si(i-1, j, k, 2)*volmi
        zm = si(i-1, j, k, 3)*volmi
        xp = si(i, j, k, 1)*volpi
        yp = si(i, j, k, 2)*volpi
        zp = si(i, j, k, 3)*volpi
        xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
        ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
        za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
        ttm = xm*xa + ym*ya + zm*za
        ttp = xp*xa + yp*ya + zp*za
! Computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! Furthermore, the grad(nu)**2 has been rewritten as
! div(nu grad(nu)) - nu div(grad nu) to enhance stability.
! The second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! In this way the metric can be taken into account.
! Compute the diffusion coefficients multiplying the nodes
! i+1, i and i-1 in the second derivative. Make sure that
! these coefficients are nonnegative.
        cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
        cam = ttm*cnud
        cap = ttp*cnud
        nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
        nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
        nu = rlv(i, j, k)/w(i, j, k, irho)
        num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
        nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
        cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
        cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
        IF (cdm + cam .LT. zero) THEN
          c1m = zero
        ELSE
          c1m = cdm + cam
        END IF
        IF (cdp + cap .LT. zero) THEN
          c1p = zero
        ELSE
          c1p = cdp + cap
        END IF
        c10 = c1m + c1p
! Update the residual for this cell and store the possible
! coefficients for the matrix in b1, c1 and d1.
        dvt(i, j, k, 1) = dvt(i, j, k, 1) + c1m*w(i-1, j, k, itu1) - c10&
&          *w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
        b1 = -c1m
        c1 = c10
        d1 = -c1p
! Update the central jacobian. For nonboundary cells this
! is simply c1. For boundary cells this is slightly more
! complicated, because the boundary conditions are treated
! implicitly and the off-diagonal terms b1 and d1 must be
! taken into account.
! The boundary conditions are only treated implicitly if
! the diagonal dominance of the matrix is increased.
        IF (i .EQ. 2) THEN
          IF (bmti1(j, k, itu1, itu1) .LT. zero) THEN
            max6 = zero
          ELSE
            max6 = bmti1(j, k, itu1, itu1)
          END IF
          qq(i, j, k) = qq(i, j, k) + c1 - b1*max6
        ELSE IF (i .EQ. il) THEN
          IF (bmti2(j, k, itu1, itu1) .LT. zero) THEN
            max7 = zero
          ELSE
            max7 = bmti2(j, k, itu1, itu1)
          END IF
          qq(i, j, k) = qq(i, j, k) + c1 - d1*max7
        ELSE
          qq(i, j, k) = qq(i, j, k) + c1
        END IF
      END DO
    END DO
  END DO
! Multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. The multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. Also multiply by iblank so that no updates occur
! in holes or the overset boundary.
  DO k=2,kl
    DO j=2,jl
      DO i=2,il
        rblank = REAL(iblank(i, j, k), realtype)
        dw(i, j, k, itu1) = -(vol(i, j, k)*dvt(i, j, k, 1)*rblank)
      END DO
    END DO
  END DO
! Initialize the wall function flags to .false.
  flagi2 = .false.
  flagil = .false.
  flagj2 = .false.
  flagjl = .false.
  flagk2 = .false.
  flagkl = .false.
! Modify the rhs of the 1st internal cell, if wall functions
! are used; their value is determined by the table.
  IF (wallfunctions) THEN
bocos:DO nn=1,nviscbocos
! Determine the block face on which the subface is located
! and set some variables. As flag points to the entire array
! flagI2, etc., its starting indices are the starting indices
! of its target and not 1.
      SELECT CASE  (bcfaceid(nn)) 
      CASE (imin) 
        flag => flagi2
        ddw => dw(2, 1:, 1:, 1:)
        ddvt => dvt(2, 1:, 1:, 1:)
        ww => w(2, 1:, 1:, 1:)
        rrlv => rlv(2, 1:, 1:)
        dd2wall => d2wall(2, :, :)
      CASE (imax) 
        flag => flagil
        ddw => dw(il, 1:, 1:, 1:)
        ddvt => dvt(il, 1:, 1:, 1:)
        ww => w(il, 1:, 1:, 1:)
        rrlv => rlv(il, 1:, 1:)
        dd2wall => d2wall(il, :, :)
      CASE (jmin) 
        flag => flagj2
        ddw => dw(1:, 2, 1:, 1:)
        ddvt => dvt(1:, 2, 1:, 1:)
        ww => w(1:, 2, 1:, 1:)
        rrlv => rlv(1:, 2, 1:)
        dd2wall => d2wall(:, 2, :)
      CASE (jmax) 
        flag => flagjl
        ddw => dw(1:, jl, 1:, 1:)
        ddvt => dvt(1:, jl, 1:, 1:)
        ww => w(1:, jl, 1:, 1:)
        rrlv => rlv(1:, jl, 1:)
        dd2wall => d2wall(:, jl, :)
      CASE (kmin) 
        flag => flagk2
        ddw => dw(1:, 1:, 2, 1:)
        ddvt => dvt(1:, 1:, 2, 1:)
        ww => w(1:, 1:, 2, 1:)
        rrlv => rlv(1:, 1:, 2)
        dd2wall => d2wall(:, :, 2)
      CASE (kmax) 
        flag => flagkl
        ddw => dw(1:, 1:, kl, :)
        ddvt => dvt(1:, 1:, kl, 1:)
        ww => w(1:, 1:, kl, 1:)
        rrlv => rlv(1:, 1:, kl)
        dd2wall => d2wall(:, :, kl)
      END SELECT
! Loop over the owned faces of this subface. Therefore the
! nodal range of BCData must be used. The offset of +1 is
! present, because the starting index of the cell range is
! 1 larger than the starting index of the nodal range.
      DO j=bcdata(nn)%jnbeg+1,bcdata(nn)%jnend
        DO i=bcdata(nn)%inbeg+1,bcdata(nn)%inend
! Set ddw to zero.
          ddw(i, j, itu1) = zero
! Enforce nu tilde in the 1st internal cell from the
! wall function table. There is an offset of -1 in the
! wall distance. Note that the offset compared to the
! current value must be stored, because dvt contains
! the update. Also note that the curve fits contain the
! non-dimensional value.
          yp = ww(i, j, irho)*dd2wall(i-1, j-1)*viscsubface(nn)%utau(i, &
&            j)/rrlv(i, j)
          CALL CURVETUPYP_CD(tu1p, yp, itu1, itu1)
          ddvt(i, j, 1) = tu1p*rrlv(i, j)/ww(i, j, irho) - ww(i, j, itu1&
&            )
! Set the wall flag to .true.
          flag(i, j) = .true.
        END DO
      END DO
    END DO bocos
  END IF
! Return if only the residual must be computed.
  IF (resonly) THEN
    RETURN
  ELSE
! For implicit relaxation take the local time step into account,
! where dt is the inverse of the central jacobian times the cfl
! number. The following system is solved:
! (I/dt + cc + bb + dd)*dw = rhs, in which I/dt = cc/cfl. As in
! the rest of the algorithm only the modified central jacobian is
! used, stored it now.
! Compute the factor multiplying the central jacobian, which
! is 1 + 1/cfl (implicit relaxation only).
    factor = one
    IF (turbrelax .EQ. turbrelaximplicit) factor = one + (one-alfaturb)/&
&        alfaturb
    DO k=2,kl
      DO j=2,jl
        DO i=2,il
          qq(i, j, k) = factor*qq(i, j, k)
! Set qq to 1 if the value is determined by the
! wall function table.
          IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
&              flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
&              .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
&              , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) qq(i, j, k) = &
&              one
        END DO
      END DO
    END DO
! Initialize the grid velocity to zero. This value will be used
! if the block is not moving.
    qs = zero
!
!      ******************************************************************
!      *                                                                *
!      * dd-ADI step in j-direction. There is no particular reason to   *
!      * start in j-direction, it just happened to be so. As we solve   *
!      * in j-direction, the j-loop is the innermost loop.              *
!      *                                                                *
!      ******************************************************************
!
    DO k=2,kl
      DO i=2,il
        DO j=2,jl
! More or less the same code is executed here as above when
! the residual was built. However, now the off-diagonal
! terms for the dd-ADI must be built and stored. This could
! have been done earlier, but then all the coefficients had
! to be stored. To save memory, they are recomputed.
! Consequently, see the j-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! Off-diagonal terms due to the diffusion terms
! in j-direction.
          nutm = half*(w(i, j-1, k, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i, j+1, k, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i, j-1, k)/w(i, j-1, k, irho)+nu)
          nup = half*(rlv(i, j+1, k)/w(i, j+1, k, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          IF (cdm + cam .LT. zero) THEN
            c1m = zero
          ELSE
            c1m = cdm + cam
          END IF
          IF (cdp + cap .LT. zero) THEN
            c1p = zero
          ELSE
            c1p = cdp + cap
          END IF
          bb(j) = -c1m
          dd(j) = -c1p
! Compute the grid velocity if present.
! It is taken as the average of j and j-1,
          IF (addgridvelocities) qs = half*(sfacej(i, j, k)+sfacej(i, j-&
&              1, k))*voli
! Off-diagonal terms due to the advection term in
! j-direction. First order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&            ivz) - qs
          um = zero
          up = zero
          IF (uu .LT. zero) um = uu
          IF (uu .GT. zero) up = uu
          bb(j) = bb(j) - up
          dd(j) = dd(j) + um
! Store the central jacobian and rhs in cc and ff.
! Multiply the off-diagonal terms and rhs by the iblank
! value so the update determined for iblank = 0 is zero.
          rblank = REAL(iblank(i, j, k), realtype)
          cc(j) = qq(i, j, k)
          ff(j) = dvt(i, j, k, 1)*rblank
          bb(j) = bb(j)*rblank
          dd(j) = dd(j)*rblank
! Set the off diagonal terms to zero if the wall is flagged.
          IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
&              flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
&              .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
&              , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) THEN
            bb(j) = zero
            dd(j) = zero
          END IF
        END DO
! Solve the tri-diagonal system in j-direction.
! First the backward sweep to eliMinate the upper diagonal dd.
        DO j=ny,2,-1
          f = dd(j)/cc(j+1)
          cc(j) = cc(j) - f*bb(j+1)
          ff(j) = ff(j) - f*ff(j+1)
        END DO
! The matrix is now in lower block bi-diagonal form.
! Perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        DO j=3,jl
          ff(j) = ff(j) - bb(j)*ff(j-1)
          ff(j) = ff(j)/cc(j)
        END DO
! Determine the new rhs for the next direction.
        DO j=2,jl
          dvt(i, j, k, 1) = ff(j)*qq(i, j, k)
        END DO
      END DO
    END DO
!
!      ******************************************************************
!      *                                                                *
!      * dd-ADI step in i-direction. As we solve in i-direction, the    *
!      * i-loop is the innermost loop.                                  *
!      *                                                                *
!      ******************************************************************
!
    DO k=2,kl
      DO j=2,jl
        DO i=2,il
! More or less the same code is executed here as above when
! the residual was built. However, now the off-diagonal
! terms for the dd-ADI must be built and stored. This could
! have been done earlier, but then all the coefficients had
! to be stored. To save memory, they are recomputed.
! Consequently, see the i-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! Off-diagonal terms due to the diffusion terms
! in i-direction.
          nutm = half*(w(i-1, j, k, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i+1, j, k, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i-1, j, k)/w(i-1, j, k, irho)+nu)
          nup = half*(rlv(i+1, j, k)/w(i+1, j, k, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          IF (cdm + cam .LT. zero) THEN
            c1m = zero
          ELSE
            c1m = cdm + cam
          END IF
          IF (cdp + cap .LT. zero) THEN
            c1p = zero
          ELSE
            c1p = cdp + cap
          END IF
          bb(i) = -c1m
          dd(i) = -c1p
! Compute the grid velocity if present.
! It is taken as the average of i and i-1,
          IF (addgridvelocities) qs = half*(sfacei(i, j, k)+sfacei(i-1, &
&              j, k))*voli
! Off-diagonal terms due to the advection term in
! i-direction. First order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&            ivz) - qs
          um = zero
          up = zero
          IF (uu .LT. zero) um = uu
          IF (uu .GT. zero) up = uu
          bb(i) = bb(i) - up
          dd(i) = dd(i) + um
! Store the central jacobian and rhs in cc and ff.
! Multiply the off-diagonal terms and rhs by the iblank
! value so the update determined for iblank = 0 is zero.
          rblank = REAL(iblank(i, j, k), realtype)
          cc(i) = qq(i, j, k)
          ff(i) = dvt(i, j, k, 1)*rblank
          bb(i) = bb(i)*rblank
          dd(i) = dd(i)*rblank
! Set the off diagonal terms to zero if the wall is flagged.
          IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
&              flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
&              .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
&              , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) THEN
            bb(i) = zero
            dd(i) = zero
          END IF
        END DO
! Solve the tri-diagonal system in i-direction.
! First the backward sweep to eliMinate the upper diagonal dd.
        DO i=nx,2,-1
          f = dd(i)/cc(i+1)
          cc(i) = cc(i) - f*bb(i+1)
          ff(i) = ff(i) - f*ff(i+1)
        END DO
! The matrix is now in lower block bi-diagonal form.
! Perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        DO i=3,il
          ff(i) = ff(i) - bb(i)*ff(i-1)
          ff(i) = ff(i)/cc(i)
        END DO
! Determine the new rhs for the next direction.
        DO i=2,il
          dvt(i, j, k, 1) = ff(i)*qq(i, j, k)
        END DO
      END DO
    END DO
!
!      ******************************************************************
!      *                                                                *
!      * dd-ADI step in k-direction. As we solve in k-direction, the    *
!      * k-loop is the innermost loop.                                  *
!      *                                                                *
!      ******************************************************************
!
    DO j=2,jl
      DO i=2,il
        DO k=2,kl
! More or less the same code is executed here as above when
! the residual was built. However, now the off-diagonal
! terms for the dd-ADI must be built and stored. This could
! have been done earlier, but then all the coefficients had
! to be stored. To save memory, they are recomputed.
! Consequently, see the k-loop to build the residual for
! the comments.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
          cnud = -(rsacb2*w(i, j, k, itu1)*cb3inv)
          cam = ttm*cnud
          cap = ttp*cnud
! Off-diagonal terms due to the diffusion terms
! in k-direction.
          nutm = half*(w(i, j, k-1, itu1)+w(i, j, k, itu1))
          nutp = half*(w(i, j, k+1, itu1)+w(i, j, k, itu1))
          nu = rlv(i, j, k)/w(i, j, k, irho)
          num = half*(rlv(i, j, k-1)/w(i, j, k-1, irho)+nu)
          nup = half*(rlv(i, j, k+1)/w(i, j, k+1, irho)+nu)
          cdm = (num+(one+rsacb2)*nutm)*ttm*cb3inv
          cdp = (nup+(one+rsacb2)*nutp)*ttp*cb3inv
          IF (cdm + cam .LT. zero) THEN
            c1m = zero
          ELSE
            c1m = cdm + cam
          END IF
          IF (cdp + cap .LT. zero) THEN
            c1p = zero
          ELSE
            c1p = cdp + cap
          END IF
          bb(k) = -c1m
          dd(k) = -c1p
! Compute the grid velocity if present.
! It is taken as the average of k and k-1,
          IF (addgridvelocities) qs = half*(sfacek(i, j, k)+sfacek(i, j&
&              , k-1))*voli
! Off-diagonal terms due to the advection term in
! k-direction. First order approximation.
          uu = xa*w(i, j, k, ivx) + ya*w(i, j, k, ivy) + za*w(i, j, k, &
&            ivz) - qs
          um = zero
          up = zero
          IF (uu .LT. zero) um = uu
          IF (uu .GT. zero) up = uu
          bb(k) = bb(k) - up
          dd(k) = dd(k) + um
! Store the central jacobian and rhs in cc and ff.
! Multiply the off-diagonal terms and rhs by the iblank
! value so the update determined for iblank = 0 is zero.
          rblank = REAL(iblank(i, j, k), realtype)
          cc(k) = qq(i, j, k)
          ff(k) = dvt(i, j, k, 1)*rblank
          bb(k) = bb(k)*rblank
          dd(k) = dd(k)*rblank
! Set the off diagonal terms to zero if the wall is flagged.
          IF ((((((i .EQ. 2 .AND. flagi2(j, k)) .OR. (i .EQ. il .AND. &
&              flagil(j, k))) .OR. (j .EQ. 2 .AND. flagj2(i, k))) .OR. (j&
&              .EQ. jl .AND. flagjl(i, k))) .OR. (k .EQ. 2 .AND. flagk2(i&
&              , j))) .OR. (k .EQ. kl .AND. flagkl(i, j))) THEN
            bb(k) = zero
            dd(k) = zero
          END IF
        END DO
! Solve the tri-diagonal system in k-direction.
! First the backward sweep to eliMinate the upper diagonal dd.
        DO k=nz,2,-1
          f = dd(k)/cc(k+1)
          cc(k) = cc(k) - f*bb(k+1)
          ff(k) = ff(k) - f*ff(k+1)
        END DO
! The matrix is now in lower block bi-diagonal form.
! Perform a forward sweep to compute the solution.
        ff(2) = ff(2)/cc(2)
        DO k=3,kl
          ff(k) = ff(k) - bb(k)*ff(k-1)
          ff(k) = ff(k)/cc(k)
        END DO
! Store the update in dvt.
        DO k=2,kl
          dvt(i, j, k, 1) = ff(k)
        END DO
      END DO
    END DO
!
!      ******************************************************************
!      *                                                                *
!      * Update the turbulent variables. For explicit relaxation the    *
!      * update must be relaxed; for implicit relaxation this has been  *
!      * done via the time step.                                        *
!      *                                                                *
!      ******************************************************************
!
    factor = one
    IF (turbrelax .EQ. turbrelaxexplicit) factor = alfaturb
    DO k=2,kl
      DO j=2,jl
        DO i=2,il
          w(i, j, k, itu1) = w(i, j, k, itu1) + factor*dvt(i, j, k, 1)
          IF (w(i, j, k, itu1) .LT. zero) THEN
            w(i, j, k, itu1) = zero
          ELSE
            w(i, j, k, itu1) = w(i, j, k, itu1)
          END IF
        END DO
      END DO
    END DO
  END IF
END SUBROUTINE SASOLVE_CD

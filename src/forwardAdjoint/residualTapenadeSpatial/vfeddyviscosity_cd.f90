!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3375) - 10 Feb 2010 15:08
!
!      ==================================================================
SUBROUTINE VFEDDYVISCOSITY_CD()
  USE BCTYPES_SPATIAL_D
  USE INPUTPHYSICS_SPATIAL_D
  USE PARAMTURB_SPATIAL_D
  USE CONSTANTS_SPATIAL_D
  USE TURBMOD_SPATIAL_D
  USE BLOCKPOINTERS_SPATIAL_D
  IMPLICIT NONE
! call curveTupYp(tup(itu5:itu5), yp, itu5, itu5)
! rrev(i,j) = tup(itu5)*rrlv(i,j)
!
!      ******************************************************************
!      *                                                                *
!      * vfEddyViscosity computes the eddy-viscosity according to the   *
!      * v2f turbulence model for the block given in blockPointers.     *
!      * This routine is for both the n=1 and n=6 version.              *
!      *                                                                *
!      ******************************************************************
!
!
!      Local variables.
!
  INTEGER(kind=inttype) :: i, j, k, nn
  REAL(kind=realtype) :: tke, tep, tkea, tepa, tepl, tv2, tv2a
  REAL(kind=realtype) :: yp, utau
  REAL(kind=realtype), DIMENSION(itu1:itu5) :: tup
  REAL(kind=realtype), DIMENSION(:, :, :), POINTER :: ww
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: rrlv, rrev
  REAL(kind=realtype), DIMENSION(:, :), POINTER :: dd2wall
  EXTERNAL VFSCALE
  INTRINSIC MAX
  INTRINSIC ABS
!
!      ******************************************************************
!      *                                                                *
!      * Begin execution                                                *
!      *                                                                *
!      ******************************************************************
!
! Compute time and length scale
  CALL VFSCALE()
! Loop over the cells of this block and compute the eddy viscosity.
! Do not include halo's.
  DO k=2,kl
    DO j=2,jl
      DO i=2,il
        tke = w(i, j, k, itu1)
        tep = w(i, j, k, itu2)
        tv2 = w(i, j, k, itu3)
        IF (tke .GE. 0.) THEN
          tkea = tke
        ELSE
          tkea = -tke
        END IF
        IF (tep .GE. 0.) THEN
          tepa = tep
        ELSE
          tepa = -tep
        END IF
        IF (tv2 .GE. 0.) THEN
          tv2a = tv2
        ELSE
          tv2a = -tv2
        END IF
        IF (tepa .LT. rvflimite) THEN
          tepl = rvflimite
        ELSE
          tepl = tepa
        END IF
        rev(i, j, k) = rvfcmu*w(i, j, k, irho)*tv2a/tepl*sct(i, j, k)
      END DO
    END DO
  END DO
! Modify the rhs of the 1st internal cell, if wall functions
! are used; their value is determined by the table.
  IF (wallfunctions) THEN
bocos:DO nn=1,nviscbocos
! Determine the block face on which the subface is located
! and set some variables. As flag points to the entire array
! flagI2, etc., its starting indices are the starting indices
! of its target and not 1.
      SELECT CASE  (bcfaceid(nn)) 
      CASE (imin) 
        ww => w(2, 1:, 1:, 1:)
        rrlv => rlv(2, 1:, 1:)
        dd2wall => d2wall(2, :, :)
        rrev => rev(2, 1:, 1:)
      CASE (imax) 
        ww => w(il, 1:, 1:, 1:)
        rrlv => rlv(il, 1:, 1:)
        dd2wall => d2wall(il, :, :)
        rrev => rev(il, 1:, 1:)
      CASE (jmin) 
        ww => w(1:, 2, 1:, 1:)
        rrlv => rlv(1:, 2, 1:)
        dd2wall => d2wall(:, 2, :)
        rrev => rev(1:, 2, 1:)
      CASE (jmax) 
        ww => w(1:, jl, 1:, 1:)
        rrlv => rlv(1:, jl, 1:)
        dd2wall => d2wall(:, jl, :)
        rrev => rev(1:, jl, 1:)
      CASE (kmin) 
        ww => w(1:, 1:, 2, 1:)
        rrlv => rlv(1:, 1:, 2)
        dd2wall => d2wall(:, :, 2)
        rrev => rev(1:, 1:, 2)
      CASE (kmax) 
        ww => w(1:, 1:, kl, 1:)
        rrlv => rlv(1:, 1:, kl)
        dd2wall => d2wall(:, :, kl)
        rrev => rev(1:, 1:, kl)
      END SELECT
! Loop over the owned faces of this subface. Therefore the
! nodal range of bcData must be used. The offset of +1 is
! present, because the starting index of the cell range is
! 1 larger than the starting index of the nodal range.
      DO j=bcdata(nn)%jnbeg+1,bcdata(nn)%jnend
        DO i=bcdata(nn)%inbeg+1,bcdata(nn)%inend
! Enforce k and epsilon in the 1st internal cell from
! the wall function table. There is an offset of -1 in
! the wall distance. Note that the offset compared to
! the current value must be stored. Also note that the
! curve fits contain the non-dimensional values.
          utau = viscsubface(nn)%utau(i, j)
          yp = ww(i, j, irho)*dd2wall(i-1, j-1)*utau/rrlv(i, j)
        END DO
      END DO
    END DO bocos
  END IF
END SUBROUTINE VFEDDYVISCOSITY_CD

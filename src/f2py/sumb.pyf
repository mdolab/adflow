!    -*- f90 -*-
python module solverunsteadyale__user__routines 
    interface solverunsteadyale_user_interface 
        subroutine alecallback_python(t) ! in :test:solverUnsteady_ALE.f90
          real(kind=realtype) :: t
        end subroutine alecallback_python
    end interface solverunsteadyale_user_interface
end python module solverunsteadyale__user__routines


#ifdef USE_COMPLEX
python module libsumb_cs ! in 
#else
python module libsumb
#endif
    interface  ! in :sumb

       ! ############################################################################
       ! SUmb Routines
       ! ############################################################################

       module utils
         subroutine writeintromessage 
         end subroutine writeintromessage

         subroutine getliftdirfromsymmetry(liftdir)
           integer(kind=inttype), intent(out) :: liftdir
         end subroutine getliftdirfromsymmetry

         subroutine allocconvarrays(nitertot)
           integer(kind=inttype) :: nitertot
         end subroutine allocconvarrays
         
         subroutine alloctimearrays(nitertot) 
           integer(kind=inttype) :: ntimetot
         end subroutine alloctimearrays

         subroutine pointreduce(pts,n,tol,uniquepts,link,nunique) ! in :test:utils.F90:utils
           real(kind=realtype) dimension(3,n),intent(in) :: pts
           integer(kind=inttype), optional,intent(in),check(shape(pts,1)==n),depend(pts) :: n=shape(pts,1)
           real(kind=realtype) intent(in) :: tol
           real(kind=realtype) dimension(3,n),intent(out),depend(n) :: uniquepts
           integer(kind=inttype) dimension(n),intent(out),depend(n) :: link
           integer(kind=inttype) intent(out) :: nunique
         end subroutine pointreduce

       end module utils

       module walldistance

         subroutine updatewalldistancealllevels 
         end subroutine updatewalldistancealllevels

       end module walldistance

       module initializeflow

         subroutine updatebcdataalllevels
         end subroutine updatebcdataalllevels

         subroutine initflow 
         end subroutine initflow
       
         subroutine initflowrestart
         end subroutine initflowrestart

         subroutine setuniformflow
         end subroutine setuniformflow

         subroutine allocrestartfiles(nfiles) 
           integer(kind=inttype) :: nfiles
         end subroutine allocrestartfiles

         subroutine setrestartfiles(filename,i)
           character*(*) intent(in) :: filename
           integer(kind=inttype) :: i
         end subroutine setrestartfiles

       end module initializeflow

       module bcdata
         subroutine setbcdata(bcdatanamesin,bcdatain,famlist, sps, nbcdatanamesin, nbcdatain, nfams)
            character, dimension(nbcdatanamesin,32), intent(in) :: bcdatanamesin
            real(kind=realtype) dimension(nbcdatain),intent(in) :: bcdatain
            integer(kind=inttype) dimension(nfams),intent(in) :: famlist
            integer(kind=inttype) intent(in) :: sps
            integer(kind=inttype), optional,intent(in),check(len(bcdatanamesin)>=nbcdatanamesin),depend(bcdatanamesin) :: nbcdatanamesin=len(bcdatanamesin)
            integer(kind=inttype), optional,intent(in),check(len(bcdatain)>=nbcdatain),depend(bcdatain) :: nbcdatain=len(bcdatain)
            integer(kind=inttype), optional,intent(in),check(len(famlist)>=nfams),depend(famlist) :: nfams=len(famlist)
         end subroutine setbcdata
       end module bcdata

       module flowutils

         subroutine updategamma
         end subroutine updategamma

         subroutine adjustinflowangle()
         end subroutine adjustinflowangle

       end module flowutils

       module inputparamroutines

         subroutine setdefaultvalues()
         end subroutine setdefaultvalues

         subroutine monitorvariables(variables) ! in :test:monitorVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine monitorvariables
         
         subroutine surfacevariables(variables) ! in :test:surfaceVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine surfacevariables
         
         subroutine volumevariables(variables) ! in :test:volumeVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine volumevariables
         
         subroutine isovariables(variables) ! in :test:volumeVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine isovariables
         
         subroutine initializeisosurfacevariables(values,nvalues) ! in :test:setIsoSurfaceValues.F90
           real(kind=realtype), dimension(nvalues),intent(in) :: values
           integer(kind=inttype), optional,intent(in),check(len(values)>=nvalues),depend(values) :: nvalues=len(values)
         end subroutine initializeisosurfacevariables
         
         subroutine setisosurfacevariable(variable,ivar) ! in :test:setIsoSurfaceValues.F90
           character*(*), intent(in) :: variable
           integer(kind=inttype), intent(in) :: ivar
         end subroutine setisosurfacevariable

         subroutine dummyreadparamfile ! in :sumb:../../inputParam/readParamFile.f90
         end subroutine dummyreadparamfile

       end module inputparamroutines

       module nksolver

         integer(kind=inttype) :: nk_innerpreconits
         integer(kind=inttype) :: nk_outerpreconits
         integer(kind=inttype) :: nk_jacobianlag
         logical :: usenksolver
         logical :: nk_adpc
         logical :: nk_useew
         logical :: nk_viscpc
         integer(kind=inttype) :: nk_ls
         integer(kind=inttype) :: nk_subspace
         integer(kind=inttype) :: nk_asmoverlap
         real(kind=realtype) :: nk_rtolinit
         integer(kind=inttype) :: nk_ilufill
         real(kind=realtype) :: nk_switchtol
         real(kind=realtype) :: nk_cfl0
         integer(kind=inttype) :: applypcsubspacesize
         logical :: freestreamresset

         subroutine getstates(states,ndimw)
           real(kind=realtype) dimension(ndimw),intent(out),depend(ndimw) :: states
           integer(kind=inttype) intent(in) :: ndimw
         end subroutine getstates

         subroutine setstates(states,ndimw)
           real(kind=realtype) dimension(ndimw),intent(in) :: states
           integer(kind=inttype) optional,intent(in),check(len(states)>=ndimw),depend(states) :: ndimw=len(states)
         end subroutine setstates

         subroutine getinfosize(isize)
           integer(kind=inttype) intent(out) :: isize
         end subroutine getinfosize
         
         subroutine setinfo(info,isize) 
           real(kind=realtype) dimension(isize),intent(in) :: info
           integer(kind=inttype) optional,intent(in),check(len(info)>=isize),depend(info) :: isize=len(info)
         end subroutine setinfo
         
         subroutine getinfo(info,isize) 
           real(kind=realtype) dimension(isize),intent(out),depend(isize) :: info
           integer(kind=inttype) intent(in) :: isize
         end subroutine getinfo
         
         subroutine getres(res,ndimw)
           real(kind=realtype) dimension(ndimw),intent(in,out) :: res
           integer(kind=inttype) optional,intent(in),check(len(res)>=ndimw),depend(res) :: ndimw=len(res)
         end subroutine getres
 
         subroutine applypc(in_vec,out_vec,ndof)
           real(kind=realtype) dimension(ndof),intent(in) :: in_vec
           real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
           integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
         end subroutine applypc
         
         subroutine applyadjointpc(in_vec,out_vec,ndof) 
           real(kind=realtype) dimension(ndof),intent(in) :: in_vec
           real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
           integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
         end subroutine applyadjointpc

         subroutine destroynksolver
         end subroutine destroynksolver

         subroutine getfreestreamresidual(rhores,totalrres) ! in :test:NKSolvers.F90:nksolver
           real(kind=realtype) intent(out) :: rhores
           real(kind=realtype) intent(out) :: totalrres
         end subroutine getfreestreamresidual
         
       end module nksolver

       module anksolver
         use constants
         integer(kind=inttype) :: ank_innerpreconits
         integer(kind=inttype) :: ank_jacobianlag
         logical :: useanksolver
         logical :: ank_useturbdadi
         integer(kind=inttype) :: ank_subspace
         integer(kind=inttype) :: ank_asmoverlap
         real(kind=realtype) :: ank_rtol
         integer(kind=inttype) :: ank_ilufill
         real(kind=realtype) :: ank_switchtol
         real(kind=realtype) :: ank_cfl0
       
         subroutine destroyanksolver
         end subroutine destroyanksolver
         
       end module anksolver
     
       module partitioning
         subroutine partitionandreadgrid(partitiononly)
           logical :: partitiononly
         end subroutine partitionandreadgrid

         subroutine checkpartitioning(np,load_inbalance,face_inbalance)
           integer(kind=inttype) intent(in) :: np
           real(kind=realtype) intent(out) :: load_inbalance
           real(kind=realtype) intent(out) :: face_inbalance
         end subroutine checkpartitioning
         
       end module partitioning

       module warping

         subroutine getcgnsmeshindices(ndof,indices)
           integer(kind=inttype) intent(in) :: ndof
           integer(kind=inttype) dimension(ndof),intent(out),depend(ndof) :: indices
         end subroutine getcgnsmeshindices
         
         subroutine setgrid(grid,ndof)
           real(kind=realtype) dimension(ndof),intent(in) :: grid
           integer(kind=inttype) optional,intent(in),check(len(grid)>=ndof),depend(grid) :: ndof=len(grid)
         end subroutine setgrid
         
         subroutine getgrid(grid,ndof) 
           real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: grid
           integer(kind=inttype) intent(in) :: ndof
         end subroutine getgrid

         subroutine getstateperturbation(randvec,nrand,randstate,nrandstate)
           real(kind=realtype) dimension(nrand),intent(in) :: randvec
           integer(kind=inttype), optional,intent(in),check(len(randvec)>=nrand),depend(randvec) :: nrand=len(randvec)
           real(kind=realtype) dimension(nrandstate),intent(out),depend(nrandstate) :: randstate
           integer(kind=inttype) intent(in) :: nrandstate
         end subroutine getstateperturbation

          subroutine getsurfaceperturbation(xrand,nrand,randsurface,nrandsurface) ! in :test:warping.F90:warping
           real(kind=realtype) dimension(nrand),intent(in) :: xrand
           integer(kind=inttype), optional,intent(in),check(len(xrand)>=nrand),depend(xrand) :: nrand=len(xrand)
           real(kind=realtype) dimension(3 * nrandsurface),intent(inout) :: randsurface
           integer(kind=inttype), optional,intent(in),check((len(randsurface))/(3)>=nrandsurface),depend(randsurface) :: nrandsurface=(len(randsurface))/(3)
         end subroutine getsurfaceperturbation
       end module warping
       
       module surfaceutils

         subroutine getsurfacesize(npts, ncells, famlist, n) 
           integer(kind=inttype) intent(out) :: npts
           integer(kind=inttype) intent(out) :: ncells
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine getsurfacesize
         
         subroutine getsurfaceconnectivity(conn,ncell) 
           integer(kind=inttype) dimension(4 * ncell),intent(inout) :: conn
           integer(kind=inttype) optional,intent(in),check((len(conn))/(4)>=ncell),depend(conn) :: ncell=(len(conn))/(4)
         end subroutine getsurfaceconnectivity
         
         subroutine getsurfacepoints(points,npts,sps_in) 
           integer(kind=inttype), intent(in) :: sps_in
           real(kind=realtype) dimension(3,npts),intent(inout) :: points
           integer(kind=inttype) optional,intent(in),check(shape(points,1)==npts),depend(points) :: npts=shape(points,1)
         end subroutine getsurfacepoints

         subroutine mapvector(vec1,n1,famlist1,nf1,vec2,n2,famlist2,nf2)
           real(kind=realtype) dimension(3,n1),intent(in) :: vec1
           integer(kind=inttype), optional,check(shape(vec1,1)==n1),depend(vec1) :: n1=shape(vec1,1)
           integer(kind=inttype) dimension(nf1),intent(in) :: famlist1
           integer(kind=inttype), optional,check(len(famlist1)>=nf1),depend(famlist1) :: nf1=len(famlist1)
           real(kind=realtype) dimension(3,n2),intent(inout) :: vec2
           integer(kind=inttype), optional,check(shape(vec2,1)==n2),depend(vec2) :: n2=shape(vec2,1)
           integer(kind=inttype) dimension(nf2),intent(in) :: famlist2
           integer(kind=inttype), optional,check(len(famlist2)>=nf2),depend(famlist2) :: nf2=len(famlist2)
         end subroutine mapvector

         subroutine setfamilyinfo(famlist,n) ! in :test:getForces.F90
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine setfamilyinfo
         
       end module surfaceutils

       module tecplotio
         subroutine addparaslice(slicename,pt,direction,famlist,n) ! in :test:liftDistribution.F90
           character*(*) intent(in) :: slicename
           real(kind=realtype) dimension(3),intent(in) :: pt
           real(kind=realtype) dimension(3),intent(in) :: direction
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine addparaslice

         subroutine addabsslice(slicename,pt,direction,famlist,n) ! in :test:liftDistribution.F90
           character*(*) intent(in) :: slicename
           real(kind=realtype) dimension(3),intent(in) :: pt
           real(kind=realtype) dimension(3),intent(in) :: direction
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine addabsslice
         
         subroutine addliftdistribution(nsegments,dir_vec,dir_ind, distname,famlist,n) ! in :test:liftDistribution.F90
           integer(kind=inttype) intent(in) :: nsegments
           real(kind=realtype) dimension(3), intent(in) :: dir_vec
           integer(kind=inttype), intent(in) :: dir_ind
           character*(*) intent(in) :: distname
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine addliftdistribution
         
         subroutine writetecplot(slicefile, writeslices, liftfile, writelift, surffile, writesurf)
           character*(*), intent(in) :: slicefile
           logical, intent(in) :: writeslices
           character*(*), intent(in) :: liftfile
           logical, intent(in) :: writelift
           character*(*), intent(in) :: surffile
           logical, intent(in) :: writesurf
         end subroutine writetecplot

         subroutine initializeliftdistributiondata
         end subroutine initializeliftdistributiondata
       end subroutine tecplotio

       module surfaceintegrations
         subroutine getsolution(sps) ! in :test:getSolution.f90
           integer(kind=inttype) :: sps
         end subroutine getsolution
       end module surfaceintegrations

       module solvers

         subroutine solver 
         end subroutine solver

         subroutine solverunsteady_ale(alecallback_python) ! in :test:solverUnsteady_ALE.F90
           use solverunsteadyale__user__routines
           external alecallback_python
         end subroutine solverunsteady_ale
         
       end module solvers
       
       module preprocessingapi
         subroutine preprocessing ! in :sumb:../../preprocessing/preprocessing.f90
         end subroutine preprocessing
         
         subroutine updatecoordinatesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
         end subroutine updatecoordinatesalllevels

         subroutine updatemetricsalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
         end subroutine updatemetricsalllevels
         
         subroutine updategridvelocitiesalllevels ! in :sumb:../../preprocessing/mdUpdateRoutines.f90
         end subroutine updategridvelocitiesalllevels
         
         subroutine updateperiodicinfoalllevels
         end subroutine updateperiodicinfoalllevels

         subroutine shiftcoorandvolumes ! in :sumb:../../preprocessing/shiftCoorAndVolumes.F90
         end subroutine shiftcoorandvolumes

         subroutine updatereferencepoint
         end subroutine updatereferencepoint

         subroutine updaterotationrate(rotcenter,rotrate,blocks,nblocks) ! in :test:updateRotationRate.f90
           real(kind=realtype) dimension(3),intent(in) :: rotcenter
           real(kind=realtype) dimension(3),intent(in) :: rotrate
           integer(kind=inttype) dimension(nblocks),intent(in) :: blocks
           integer(kind=inttype), optional,intent(in),check(len(blocks)>=nblocks),depend(blocks) :: nblocks=len(blocks)
         end subroutine updaterotationrate
       end module preprocessingapi

       module adjointapi
         
         subroutine setuppetscksp 
         end subroutine setuppetscksp
         
         subroutine setupallresidualmatricesfwd
         end subroutine setupallresidualmatricesfwd
         
         subroutine solveadjoint(rhs,psi,checksolution,nstate) ! in :test:solveADjointTransposePETSc.F90
           real(kind=realtype) dimension(nstate) :: rhs
           real(kind=realtype) dimension(nstate),depend(nstate) :: psi
           logical :: checksolution
           integer(kind=inttype), optional,check(len(rhs)>=nstate),depend(rhs) :: nstate=len(rhs)
         end subroutine solveadjoint
         
         subroutine solveadjointforrhs(invec,outvec,ndof,relativetolerance) ! in :test:matrixFreeRoutines.F90
           real(kind=realtype) dimension(ndof),intent(in) :: invec
           real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: outvec
           integer(kind=inttype), optional,intent(in),check(len(invec)>=ndof),depend(invec) :: ndof=len(invec)
           real(kind=realtype) intent(in) :: relativetolerance
         end subroutine solveadjointforrhs
         subroutine solvedirectforrhs(invec,outvec,ndof,relativetolerance) ! in :test:matrixFreeRoutines.F90
           real(kind=realtype) dimension(ndof),intent(in) :: invec
           real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: outvec
           integer(kind=inttype), optional,intent(in),check(len(invec)>=ndof),depend(invec) :: ndof=len(invec)
           real(kind=realtype) intent(in) :: relativetolerance
         end subroutine solvedirectforrhs
         
         subroutine saveadjointmatrix(filename)
           character*(*) intent(in) :: filename
         end subroutine saveadjointmatrix

         subroutine saveadjointpc(filename) 
           character*(*) intent(in) :: filename
         end subroutine saveadjointpc
        
         subroutine savecellcenters(filename) 
           character*(*) intent(in) :: filename
         end subroutine savecellcenters
         
         subroutine spectralprecscribedmotion(input,nin,dxv,nout)
           real(kind=realtype) dimension(nin),intent(in) :: input
           integer(kind=inttype), optional,intent(in),check(len(input)>=nin),depend(input) :: nin=len(input)
           real(kind=realtype) dimension(nout),intent(out),depend(nout) :: dxv
           integer(kind=inttype) intent(in) :: nout
         end subroutine spectralprecscribedmotion

         subroutine createpetscvars
         end subroutine createpetscvars

#ifndef USE_COMPLEX
            subroutine computematrixfreeproductfwd(xvdot,extradot,wdot,usespatial,usestate,dwdot,funcsdot,fdot,spatialsize,extrasize,statesize,costsize,fsize,ntime) ! in :test:adjointAPI.F90:adjointapi
                real(kind=realtype) dimension(spatialsize),intent(in) :: xvdot
                real(kind=realtype) dimension(extrasize),intent(in) :: extradot
                real(kind=realtype) dimension(statesize),intent(in) :: wdot
                logical intent(in) :: usespatial
                logical intent(in) :: usestate
                real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: dwdot
                real(kind=realtype) dimension(costsize),intent(out),depend(costsize) :: funcsdot
                real(kind=realtype) dimension(3,fsize,ntime),intent(out),depend(fsize,ntime) :: fdot
                integer(kind=inttype), optional,intent(in),check(len(xvdot)>=spatialsize),depend(xvdot) :: spatialsize=len(xvdot)
                integer(kind=inttype), optional,intent(in),check(len(extradot)>=extrasize),depend(extradot) :: extrasize=len(extradot)
                integer(kind=inttype), optional,intent(in),check(len(wdot)>=statesize),depend(wdot) :: statesize=len(wdot)
                integer(kind=inttype) intent(in) :: costsize
                integer(kind=inttype) intent(in) :: fsize
                integer(kind=inttype) intent(in) :: ntime
            end subroutine computematrixfreeproductfwd
            subroutine computematrixfreeproductbwd(dwbar,funcsbar,fbar,usespatial,usestate,xvbar,extrabar,wbar,spatialsize,extrasize,statesize,costsize,fsize,ntime) ! in :test:adjointAPI.F90:adjointapi
                real(kind=realtype) dimension(statesize),intent(in) :: dwbar
                real(kind=realtype) dimension(costsize),intent(in) :: funcsbar
                real(kind=realtype) dimension(3,fsize,ntime),intent(in) :: fbar
                logical intent(in) :: usespatial
                logical intent(in) :: usestate
                real(kind=realtype) dimension(spatialsize),intent(out),depend(spatialsize) :: xvbar
                real(kind=realtype) dimension(extrasize),intent(out),depend(extrasize) :: extrabar
                real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: wbar
                integer(kind=inttype) intent(in) :: spatialsize
                integer(kind=inttype) intent(in) :: extrasize
                integer(kind=inttype), optional,intent(in),check(len(dwbar)>=statesize),depend(dwbar) :: statesize=len(dwbar)
                integer(kind=inttype), optional,intent(in),check(len(funcsbar)>=costsize),depend(funcsbar) :: costsize=len(funcsbar)
                integer(kind=inttype), optional,intent(in),check(shape(fbar,1)==fsize),depend(fbar) :: fsize=shape(fbar,1)
                integer(kind=inttype), optional,intent(in),check(shape(fbar,2)==ntime),depend(fbar) :: ntime=shape(fbar,2)
            end subroutine computematrixfreeproductbwd
#endif
       end module adjointapi
       module adjointutils

         subroutine initializepetsc 
         end subroutine initializepetsc

         
         subroutine destroypetscvars
         end subroutine destroypetscvars
       end module adjointutils

! ================ bare subroutines =============

       subroutine writesol ! in :sumb:../../output/writeSol.f90
       end subroutine writesol

       subroutine getforces(forces,npts,sps_in) ! in :test:getForces.F90
         real(kind=realtype) dimension(3 * npts),intent(inout) :: forces
         integer(kind=inttype), optional,intent(in),check((len(forces))/(3)>=npts),depend(forces) :: npts=(len(forces))/(3)
         integer(kind=inttype) intent(in) :: sps_in
       end subroutine getforces

       subroutine getheatflux(hflux,npts,sps) ! in :test:getHeatFlux.f90
         real(kind=realtype) dimension(npts),intent(out),depend(npts) :: hflux
         integer(kind=inttype) intent(in) :: npts
         integer(kind=inttype) intent(in) :: sps
       end subroutine getheatflux

       subroutine settnswall(tnsw,npts,sps) ! in :test:setTNSWall.f90
         real(kind=realtype) dimension(npts),intent(in) :: tnsw
         integer(kind=inttype) optional,intent(in),check(len(tnsw)>=npts),depend(tnsw) :: npts=len(tnsw)
         integer(kind=inttype) intent(in) :: sps_in
       end subroutine settnswall

       subroutine getareas(areas,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: areas
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareas

       subroutine getareasensitivity(darea,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: darea
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareasensitivity

       
       ! ############################################################################
       ! SUmb Modules
       ! ############################################################################
       module constants ! in :sumb:../../modules/constants.F90
         use precision
         integer parameter,optional :: maxstringlen   = 256
         integer parameter,optional :: maxcgnsnamelen =  32
         integer(kind=inttype) parameter,optional :: eulerequations=1_inttype
         integer(kind=inttype) parameter,optional :: nsequations=2_inttype
         integer(kind=inttype) parameter,optional :: ransequations=3_inttype
         integer(kind=inttype) parameter,optional :: steady=1_inttype
         integer(kind=inttype) parameter,optional :: unsteady=2_inttype
         integer(kind=inttype) parameter,optional :: timespectral=3_inttype
         integer(kind=inttype) parameter,optional :: internalflow=1_inttype
         integer(kind=inttype) parameter,optional :: externalflow=2_inttype
         integer(kind=inttype) parameter,optional :: cpconstant=1_inttype
         integer(kind=inttype) parameter,optional :: cptempcurvefits=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmaras=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmarasedwards=3_inttype
         integer(kind=inttype) parameter,optional :: komegawilcox=4_inttype
         integer(kind=inttype) parameter,optional :: komegamodified=5_inttype
         integer(kind=inttype) parameter,optional :: ktau=6_inttype
         integer(kind=inttype) parameter,optional :: mentersst=7_inttype
         integer(kind=inttype) parameter,optional :: v2f=10_inttype
         integer(kind=inttype) parameter,optional :: strain=1_inttype
         integer(kind=inttype) parameter,optional :: vorticity=2_inttype
         integer(kind=inttype) parameter,optional :: katolaunder=3_inttype
         integer(kind=inttype) parameter,optional :: dissscalar=1_inttype
         integer(kind=inttype) parameter,optional :: dissmatrix=2_inttype
         integer(kind=inttype) parameter,optional :: disscusp=3_inttype
         integer(kind=inttype) parameter,optional :: upwind=9_inttype
         integer(kind=inttype) parameter,optional :: roe=1_inttype
         integer(kind=inttype) parameter,optional :: vanleer=2_inttype
         integer(kind=inttype) parameter,optional :: ausmdv=3_inttype
         integer(kind=inttype) parameter,optional :: nolimiter=2_inttype
         integer(kind=inttype) parameter,optional :: vanalbeda=3_inttype
         integer(kind=inttype) parameter,optional :: minmod=4_inttype
         integer(kind=inttype) parameter,optional :: noprecond=1_inttype
         integer(kind=inttype) parameter,optional :: turkel=2_inttype
         integer(kind=inttype) parameter,optional :: choimerkle=3_inttype
         integer(kind=inttype) parameter,optional :: constantpressure=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapolpressure=2_inttype
         integer(kind=inttype) parameter,optional :: quadextrapolpressure=3_inttype
         integer(kind=inttype) parameter,optional :: normalmomentum=4_inttype
         integer(kind=inttype) parameter,optional :: constantextrapol=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapol=2_inttype
         integer(kind=inttype) parameter,optional :: rungekutta=1_inttype
         integer(kind=inttype) parameter,optional :: dadi=2_inttype
         integer(kind=inttype) parameter,optional :: nllusgs=3_inttype
         integer(kind=inttype) parameter,optional :: nllusgsline=4_inttype
         integer(kind=inttype) parameter,optional :: segregated=1_inttype
         integer(kind=inttype) parameter,optional :: coupled=2_inttype
         integer(kind=inttype) parameter,optional :: gmres=1_inttype
         integer(kind=inttype) parameter,optional :: adi=2_inttype
         integer(kind=inttype) parameter,optional :: bcdirichlet0=0_inttype
         integer(kind=inttype) parameter,optional :: bcneumann0=1_inttype
         integer(kind=inttype) parameter,optional :: noresaveraging=0_inttype
         integer(kind=inttype) parameter,optional :: alwaysresaveraging=1_inttype
         integer(kind=inttype) parameter,optional :: alternateresaveraging=2_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxnotdefined=0_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxexplicit=1_inttype
         integer(kind=inttype) parameter,optional :: turbrelaximplicit=2_inttype
         integer(kind=inttype) parameter,optional :: precisionsingle=1
         integer(kind=inttype) parameter,optional :: precisiondouble=2
         integer(kind=inttype) parameter,optional :: bdf=1
         integer(kind=inttype) parameter,optional :: explicitrk=2
         integer(kind=inttype) parameter,optional :: implicitrk=3
         integer(kind=inttype) parameter,optional :: md=4
         integer(kind=inttype) :: nolinesearch=0
         integer(kind=inttype) :: cubiclinesearch=1
         integer(kind=inttype) :: nonmonotonelinesearch=2
       end module constants

       module communication ! in :sumb:../../modules/communication.f90
         use precision
         integer :: sumb_comm_world
         integer :: myid
         integer :: nproc
         integer allocatable,dimension(:) :: sendrequests
         integer allocatable,dimension(:) :: recvrequests
       end module communication

       module inputdiscretization ! in :sumb:../../modules/inputParam.f90
         use accuracy
         integer(kind=inttype) :: spacediscr
         integer(kind=inttype) :: spacediscrcoarse
         integer(kind=inttype) :: orderturb
         integer(kind=inttype) :: limiter
         integer(kind=inttype) :: riemann
         integer(kind=inttype) :: riemanncoarse
         integer(kind=inttype) :: precond
         integer(kind=inttype) :: eulerwallbctreatment
         integer(kind=inttype) :: viscwallbctreatment
         integer(kind=inttype) :: outflowtreatment
         real(kind=realtype) :: vis2
         real(kind=realtype) :: vis4
         real(kind=realtype) :: vis2coarse
         real(kind=realtype) :: adis
         real(kind=realtype) :: kappacoef
         logical :: vortexcorr
         logical :: dirscaling
         logical :: radiineededfine
         logical :: radiineededcoarse
         logical :: lumpeddiss
         real(kind=realtype) :: sigma
         logical :: useapproxwalldistance
         logical :: lowspeedpreconditioner
       end module inputdiscretization

       module cgnsgrid
         use constants
         integer(kind=inttype) :: cgnsndom
       end module cgnsgrid

       module inputio ! in :sumb:../../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: solfile
         character(len=maxstringlen) :: surfacesolfile
         character(len=maxstringlen) :: slicesolfile ! TEMPORARY
         character(len=maxstringlen) :: liftdistributionfile ! TEMPORARY
         character(len=maxstringlen) :: cpfile
         logical :: writecoormeter
         integer(kind=inttype) :: precisionsol
         integer(kind=inttype) :: precisiongrid
         character(len=maxstringlen) :: newgridfile
         character(len=maxstringlen) :: gridfile
         logical :: storeconvinneriter
         logical :: storerindlayer
         logical :: checkrestartsol
         logical :: autoparameterupdate
         logical :: writesymmetry
         logical :: writefarfield
         logical :: viscoussurfacevelocities
         logical optional :: firstwrite=.true.
         character(len=maxstringlen) :: paramfile
         character(len=maxstringlen) :: forcedvolumefile
         character(len=maxstringlen) :: forcedsurfacefile
         character(len=maxstringlen) :: forcedliftfile
         character(len=maxstringlen) :: forcedslicefile
       end module inputio

       module inputiteration ! in :sumb:../../modules/inputParam.f90
         use constants
         logical :: rkreset
         character(len=maxstringlen) :: mgdescription
         integer(kind=inttype) :: ncycles
         integer(kind=inttype) :: ncyclescoarse
         integer(kind=inttype) :: nsavevolume
         integer(kind=inttype) :: nsavesurface
         integer(kind=inttype) :: nsgstartup
         integer(kind=inttype) :: smoother
         integer(kind=inttype) :: nrkstages
         integer(kind=inttype) :: resaveraging
         real(kind=realtype) :: cfllimit
         integer(kind=inttype) :: turbtreatment
         integer(kind=inttype) :: nsubiterturb
         integer(kind=inttype) :: nsubiterations
         integer(kind=inttype) :: turbsmoother
         integer(kind=inttype) :: turbrelax
         integer(kind=inttype) :: mgboundcorr
         integer(kind=inttype) :: mgstartlevel
         integer(kind=inttype) :: nmgsteps
         integer(kind=inttype) :: nmglevels
         integer(kind=inttype) :: miniternum
         integer(kind=inttype) :: convcheckwindowsize
         integer(kind=inttype) allocatable,dimension(:) :: cyclestrategy
         real(kind=realtype) :: cfl
         real(kind=realtype) :: cflcoarse
         real(kind=realtype) :: fcoll
         real(kind=realtype) :: smoop
         real(kind=realtype) :: alfaturb
         real(kind=realtype) :: betaturb
         real(kind=realtype) :: l2conv
         real(kind=realtype) :: l2convcoarse
         real(kind=realtype) :: l2convrel
         real(kind=realtype) :: epscoefconv
         real(kind=realtype) allocatable,dimension(:) :: etark
         real(kind=realtype) allocatable,dimension(:) :: cdisrk
         real(kind=realtype), dimension(4) :: turbresscale
         logical :: freezeturbsource
         logical :: printiterations
         logical :: printwarnings
         real(kind=realtype) ::maxl2deviationfactor
       end module inputiteration

       module inputmotion ! in :sumb:../../modules/inputParam.f90
         use precision
         real(kind=realtype), dimension(3) :: rotpoint
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouryrot
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourxrot
         integer(kind=inttype) :: degreefourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouralpha
         real(kind=realtype) :: omegafourbeta
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourbeta
         integer(kind=inttype) :: degreepolbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourmach
         integer(kind=inttype) :: degreepolmach
         real(kind=realtype) :: omegafourmach
         integer(kind=inttype) :: degreepolalpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolmach
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourmach
         real(kind=realtype) allocatable,dimension(:) :: coefpolzrot
         logical :: gridmotionspecified
         real(kind=realtype) :: omegafourzrot
         integer(kind=inttype) :: degreefouryrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolyrot
         integer(kind=inttype) :: degreefourbeta
         real(kind=realtype) :: omegafouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourzrot
         integer(kind=inttype) :: degreepolzrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourzrot
         real(kind=realtype) :: omegafouryrot
         integer(kind=inttype) :: degreefourzrot
         integer(kind=inttype) :: degreefourmach
         integer(kind=inttype) :: degreefouralpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolalpha
         real(kind=realtype) :: omegafourxrot
         integer(kind=inttype) :: degreepolyrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouryrot
         integer(kind=inttype) :: degreepolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolbeta
       end module inputmotion
       
       module inputparallel ! in :sumb:../../modules/inputParam.f90
         real(kind=realtype) :: loadimbalance
         logical :: splitblocks
         integer(kind=inttype) :: loadbalanceiter
       end module inputparallel

       module inputphysics ! in :sumb:../../modules/inputParam.f90
         use precision

         integer(kind=inttype) :: equations
         integer(kind=inttype) :: equationmode
         integer(kind=inttype) :: flowtype
         integer(kind=inttype) :: turbmodel
         integer(kind=inttype) :: cpmodel
         integer(kind=inttype) :: turbprod
         integer(kind=inttype) :: rvfn
         logical :: rvfb
         logical :: useqcr
         logical :: userotationsa
         logical :: useft2sa
         logical :: wallfunctions
         real(kind=realtype) :: mach
         real(kind=realtype) :: machcoef
         real(kind=realtype) :: machgrid
         real(kind=realtype) :: reynolds
         real(kind=realtype) :: reynoldslength
         real(kind=realtype) :: gammaconstant
         real(kind=realtype) :: rgasdim
         real(kind=realtype) :: prandtl
         real(kind=realtype) :: prandtlturb
         real(kind=realtype) :: pklim
         real(kind=realtype) :: walloffset
         real(kind=realtype) :: eddyvisinfratio
         real(kind=realtype) :: turbintensityinf
         real(kind=realtype) :: surfaceref
         real(kind=realtype) :: lengthref
         real(kind=realtype) dimension(3) :: veldirfreestream
         real(kind=realtype) dimension(3) :: liftdirection
         real(kind=realtype) dimension(3) :: dragdirection
         real(kind=realtype) dimension(3) :: pointref
         real(kind=realtype) dimension(3) :: pointrefec
         logical :: forcesastractions
         real(kind=realtype) :: ssuthdim
         real(kind=realtype) :: musuthdim
         real(kind=realtype) :: tsuthdim
         real(kind=realtype) :: walldistcutoff
         real(kind=realtype) :: alpha
         real(kind=realtype) :: beta
         integer(kind=inttype) :: liftindex
       end module inputphysics

       module inputadjoint ! in :sumb:../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: adjointpcside
         character(len=maxstringlen) :: matrixordering
         character(len=maxstringlen) :: adjointsolvertype
         character(len=maxstringlen) :: localpctype
         character(len=maxstringlen) :: precondtype
         real(kind=realtype) :: adjabstol
         real(kind=realtype) :: adjdivtol
         real(kind=realtype) :: adjreltol
         real(kind=realtype) :: adjreltolrel
         integer(kind=inttype) :: overlap
         integer(kind=inttype) :: adjmonstep
         integer(kind=inttype) :: filllevel
         integer(kind=inttype) :: adjmaxiter
         integer(kind=inttype) :: adjrestart
         integer(kind=inttype) :: innerpreconits
         integer(kind=inttype) :: outerpreconits
         logical :: approxpc
         logical :: adpc
         logical :: viscpc
         logical :: frozenturbulence
         logical :: usediagtspc
         logical :: restartadjoint
         logical :: setmonitor
         logical :: printtiming
         logical :: firstrun
         logical :: verifystate
         logical :: verifyspatial
         logical :: verifyextra
         logical :: usematrixfreedrdw
         integer(kind=inttype) :: applyadjointpcsubspacesize
       end module inputadjoint

       module inputtimespectral ! in :sumb:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) :: ntimeintervalsspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: dscalar
         real(kind=realtype) allocatable,dimension(:,:,:) :: dvector
         real(kind=realtype) :: dtunsteadyrestartspectral
         logical :: writeunsteadyrestartspectral
         integer(kind=inttype) :: nunsteadysolspectral
         logical :: writeunsteadyvolspectral
         logical :: writeunsteadysurfspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: rotmatrixspectral
       end module inputtimespectral
              module inputoverset
         logical :: lowoversetmemory
         real(kind=realtype) :: nearwalldist
         real(kind=realtype) :: backgroundvolscale
         real(kind=realtype) :: oversetprojtol
         real(kind=realtype) :: overlapfactor
         logical :: debugzipper
       end module inputoverset

       module inputunsteady ! in :test:inputParam.f90
         use accuracy
         real(kind=realtype) :: deltat
         logical :: useale
         integer(kind=inttype) :: timeintegrationscheme
         logical :: updatewalldistanceunsteady
         integer(kind=inttype) :: timeaccuracy
         integer(kind=inttype) :: ntimestepsfine
         integer(kind=inttype) :: ntimestepscoarse
       end module inputunsteady

       module iteration ! in :sumb:../../modules/iteration.f90
         use precision
         integer(kind=inttype) :: groundlevel
         integer(kind=inttype) :: currentlevel
         integer(kind=inttype) :: rkstage
         integer(kind=inttype) :: nstepscycling
         integer(kind=inttype) allocatable,dimension(:) :: cycling
         integer(kind=inttype) :: itertot
         real(kind=realtype) :: rfil
         real(kind=realtype) :: t0solver
         logical :: converged
         logical :: exchangepressureearly
         logical :: standalonemode
         logical :: changing_grid
         logical :: deforming_grid
         logical :: changingoverset
         integer(kind=inttype) :: noldsolavail
         integer(kind=inttype) :: noldlevels
         real(kind=realtype) allocatable,dimension(:) :: coeftime
         logical :: timespectralgridsnotwritten
         logical, dimension(:), allocatable :: oldsolwritten       
         real(kind=realtype) :: totalr0
         real(kind=realtype) :: totalrstart
         real(kind=realtype) :: totalrfinal
       end module iteration

       module monitor ! in :sumb:../../modules/monitor.f90
         use constants
         integer :: nmonsum
         integer :: nmonmax
         integer :: nmon
         real(kind=realtype) allocatable,dimension(:) :: monloc
         real(kind=realtype) allocatable,dimension(:) :: monglob
         real(kind=realtype) allocatable,dimension(:) :: monref
         character(len=32) allocatable,dimension(:) :: monnames
         logical :: monmachorhmax
         logical :: showcpu
         logical :: monmasssliding
         logical :: monmassfamilies
         integer :: nitercur
         real(kind=realtype) allocatable,dimension(:,:,:) :: convarray
         integer(kind=inttype) :: ntimestepsrestart
         integer(kind=inttype) :: timestepunsteady
         real(kind=realtype) :: timeunsteady
         real(kind=realtype) :: timeunsteadyrestart
         real(kind=realtype) allocatable,dimension(:) :: timearray
         real(kind=realtype) allocatable,dimension(:,:) :: timedataarray
         logical :: writegrid
         logical :: writevolume
         logical :: writesurface
       end module monitor

       module block ! in :sumb:../../modules/block.f90
         use constants
         integer(kind=inttype) :: ndom
         integer(kind=inttype) allocatable,dimension(:) :: ncellglobal
       end module block

       module flowvarrefstate ! in :sumb:../../modules/flowVarRefState.f90
         use constants
         integer(kind=inttype) :: nw
         integer(kind=inttype) :: nwf
         integer(kind=inttype) :: nwt
         integer(kind=inttype) :: nt1
         integer(kind=inttype) :: nt2
         real(kind=realtype) :: pref
         real(kind=realtype) :: rhoref
         real(kind=realtype) :: tref
         real(kind=realtype) :: muref
         real(kind=realtype) :: timeref
         real(kind=realtype) :: lref
         logical :: lrefspecified
         real(kind=realtype) :: pinfdim
         real(kind=realtype) :: rhoinfdim
         real(kind=realtype) :: tinfdim
         real(kind=realtype) :: mudim
         real(kind=realtype) :: rhoinf
         real(kind=realtype) :: uinf
         real(kind=realtype) :: pinf
         real(kind=realtype) :: pinfcorr
         real(kind=realtype) :: rgas
         real(kind=realtype) :: muinf
         real(kind=realtype) :: gammainf
         real(kind=realtype) allocatable,dimension(:) :: winf
         logical :: kpresent
         logical :: eddymodel
         logical :: viscous
       end module flowvarrefstate

       module killsignals ! in :sumb:../../modules/killSignals.f90
         use precision
         logical :: frompython
         logical :: routinefailed
         logical :: fatalfail
         logical :: adjointfailed
       end module killsignals

       module costfunctions ! in :test:costFunctions.F90
          use constants
            integer(kind=inttype) :: ncostfunction
            integer(kind=inttype) parameter,optional :: costfunccdq=30
            integer(kind=inttype) parameter,optional :: costfuncforcezcoef=10
            integer(kind=inttype) parameter,optional :: costfuncmomzcoef=16
            integer(kind=inttype) parameter,optional :: costfunccm0=17
            integer(kind=inttype) parameter,optional :: costfuncforcex=5
            integer(kind=inttype) parameter,optional :: costfuncclq=25
            integer(kind=inttype) parameter,optional :: costfuncdrag=2
            integer(kind=inttype) parameter,optional :: costfunccl0=22
            integer(kind=inttype) parameter,optional :: costfunccmzqdot=21
            integer(kind=inttype) parameter,optional :: costfuncforcexcoef=8
            integer(kind=inttype) parameter,optional :: costfunccmzq=20
            integer(kind=inttype) parameter,optional :: costfunccmzalphadot=19
            integer(kind=inttype) parameter,optional :: costfunclift=1
            integer(kind=inttype) parameter,optional :: costfunccd0=27
            integer(kind=inttype) parameter,optional :: costfuncclqdot=26
            integer(kind=inttype) parameter,optional :: costfuncforcey=6
            integer(kind=inttype) parameter,optional :: costfuncforcez=7
            integer(kind=inttype) parameter,optional :: costfuncmomz=13
            integer(kind=inttype) parameter,optional :: costfunccdqdot=31
            integer(kind=inttype) parameter,optional :: costfuncmomx=11
            integer(kind=inttype) parameter,optional :: costfuncmomy=12
            integer(kind=inttype) parameter,optional :: costfunccdalphadot=29
            integer(kind=inttype) parameter,optional :: costfuncmomxcoef=14
            integer(kind=inttype) parameter,optional :: costfunccdalpha=28
            integer(kind=inttype) parameter,optional :: costfuncliftcoef=3
            integer(kind=inttype) parameter,optional :: costfunccmzalpha=18
            integer(kind=inttype) parameter,optional :: costfuncdragcoef=4
            integer(kind=inttype) parameter,optional :: costfuncclalphadot=24
            integer(kind=inttype) parameter,optional :: costfuncforceycoef=9
            integer(kind=inttype) parameter,optional :: costfuncclalpha=23
            integer(kind=inttype) parameter,optional :: costfuncmomycoef=15
            integer(kind=inttype) parameter,optional :: costfunccfy0=32	
            integer(kind=inttype) parameter,optional :: costfunccfyalpha=33 
            integer(kind=inttype) parameter,optional :: costfunccfyalphadot=34
            integer(kind=inttype) parameter,optional :: costfunccfyq=35
            integer(kind=inttype) parameter,optional :: costfunccfyqdot=36
            integer(kind=inttype) parameter,optional :: costfuncbendingcoef=37
            integer(kind=inttype) parameter,optional :: costfuncsepsensor=38
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgx=39
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgy=40
            integer(kind=inttype) parameter,optional :: costfuncsepsensoravgz=41
            integer(kind=inttype) parameter,optional :: costfunccavitation=42
            integer(kind=inttype) parameter,optional :: costfuncmdot=43
            integer(kind=inttype) parameter,optional :: costfuncmavgptot=44
            integer(kind=inttype) parameter,optional :: costfuncmavgttot=45
            integer(kind=inttype) parameter,optional :: costfuncmavgps=46
            real(kind=realtype) dimension(46) :: funcvalues
            real(kind=realtype) sepsensoroffset
            real(kind=realtype) sepsensorsharpness
       end module costfunctions
      
       module adjointvars ! in :test:ADjointVars.F90
         use constants
         use costfunctions
            integer(kind=inttype) dimension(20) :: ncellslocal
            integer(kind=inttype) dimension(20) :: nnodeslocal
            integer(kind=inttype), parameter,optional :: ialpha=1
            integer(kind=inttype), parameter,optional :: ibeta=2
            integer(kind=inttype), parameter,optional :: imach=3
            integer(kind=inttype), parameter,optional :: imachgrid=4
            integer(kind=inttype), parameter,optional :: irotx=5
            integer(kind=inttype), parameter,optional :: iroty=6
            integer(kind=inttype), parameter,optional :: irotz=7
            integer(kind=inttype), parameter,optional :: irotcenx=8
            integer(kind=inttype), parameter,optional :: irotceny=9
            integer(kind=inttype), parameter,optional :: irotcenz=10
            integer(kind=inttype), parameter,optional :: ipointrefx=11
            integer(kind=inttype), parameter,optional :: ipointrefy=12
            integer(kind=inttype), parameter,optional :: ipointrefz=13
            integer(kind=inttype), parameter,optional :: ipressure=14
            integer(kind=inttype), parameter,optional :: itemperature=15
            integer(kind=inttype), parameter,optional :: idensity=16
            integer(kind=inttype), parameter,optional :: ndesignextra=16
          end module adjointvars

       module adjointpetsc
         real(kind=realtype) :: adjresinit, adjresstart, adjresfinal
       end module adjointpetsc

       module inputtsstabderiv ! in :test:inputParam.f90
         logical :: usewindaxis
         logical :: tsrmode
         logical :: tsstability
         logical :: tsbetamode
         logical :: tsmachmode
         logical :: tsaltitudemode
         logical :: tspmode
         logical :: tsqmode
         logical :: tsalphamode
         logical :: tsalphafollowing 
       end module inputtsstabderiv

        module surfacefamilies ! in :test:inputParam.F90
          integer(kind=inttype), allocatable,dimension(:) :: famgroups
          character(len=32), dimension(:), allocatable :: famnames
          integer(kind=inttype), allocatable,dimension(:) :: famiswall
        end module surfacefamilies


    end interface 

#ifdef USE_COMPLEX
end python module libsumb_cs
#else
end python module libsumb
#endif



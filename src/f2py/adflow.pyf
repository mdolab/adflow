!    -*- f90 -*-
#ifdef USE_COMPLEX
python module libadflow_cs ! in
#else
python module libadflow
#endif
    interface  ! in :adflow

       ! ############################################################################
       ! ADflow Routines
       ! ############################################################################

       module utils
         subroutine writeintromessage
         end subroutine writeintromessage

         subroutine getliftdirfromsymmetry(liftdir)
           integer(kind=inttype), intent(out) :: liftdir
         end subroutine getliftdirfromsymmetry

         subroutine allocconvarrays(nitertot)
           integer(kind=inttype) :: nitertot
         end subroutine allocconvarrays

         subroutine alloctimearrays(nitertot)
           integer(kind=inttype) :: ntimetot
         end subroutine alloctimearrays

         subroutine unsteadyheader
         end subroutine unsteadyheader


         subroutine pointreduce(pts,n,tol,uniquepts,link,nunique) ! in :test:utils.F90:utils
           real(kind=realtype) dimension(3,n),intent(in) :: pts
           integer(kind=inttype), optional,intent(in),check(shape(pts,1)==n),depend(pts) :: n=shape(pts,1)
           real(kind=realtype) intent(in) :: tol
           real(kind=realtype) dimension(3,n),intent(out),depend(n) :: uniquepts
           integer(kind=inttype) dimension(n),intent(out),depend(n) :: link
           integer(kind=inttype) intent(out) :: nunique
         end subroutine pointreduce

         subroutine getcellcenters(level,n,xcen) ! in :test:utils.F90:utils
           integer(kind=inttype) intent(in) :: level
           integer(kind=inttype) intent(in) :: n
           real(kind=realtype) dimension(3,n),intent(out),depend(n) :: xcen
         end subroutine getcellcenters

         subroutine getcellcgnsblockids(level,n,cellid) ! in :test:utils.F90:utils
           integer(kind=inttype) intent(in) :: level
           integer(kind=inttype) intent(in) :: n
           real(kind=realtype) dimension(n),intent(out),depend(n) :: cellid
         end subroutine getcellcgnsblockids

         subroutine getncgnszones(nzones) ! in :test:utils.F90
           integer(kind=inttype) intent(out) :: nzones
         end subroutine getncgnszones
         subroutine getcgnszonename(i,zone) ! in :test:utils.F90
           integer(kind=inttype) intent(in) :: i
           character(32) intent(out) :: zone
         end subroutine getcgnszonename

         subroutine releasememorypart1
         end subroutine releasememorypart1

         subroutine releasememorypart2
         end subroutine releasememorypart2

       end module utils

       module walldistance

         subroutine updatewalldistancealllevels
         end subroutine updatewalldistancealllevels

       end module walldistance

       module initializeflow

         subroutine updatebcdataalllevels
         end subroutine updatebcdataalllevels

         subroutine initflow
         end subroutine initflow

         subroutine initflowrestart
         end subroutine initflowrestart

         subroutine setuniformflow
         end subroutine setuniformflow

         subroutine allocrestartfiles(nfiles)
           integer(kind=inttype) :: nfiles
         end subroutine allocrestartfiles

         subroutine setrestartfiles(filename,i)
           character*(*) intent(in) :: filename
           integer(kind=inttype) :: i
         end subroutine setrestartfiles

         subroutine infchangecorrection(oldwinf) ! in :test:solverUtils.F90:solverutils
           real(kind=realtype) dimension(5),intent(in) :: oldwinf
         end subroutine infchangecorrection

       end module initializeflow

       module bcdata
         subroutine setbcdata(bcdatanamesin,bcdatain,famlists,sps,nvar,nfammax) ! in :test:BCData.F90:bcdata
           character dimension(nvar,32),intent(in) :: bcdatanamesin
           real(kind=realtype) dimension(nvar),intent(in),depend(nvar) :: bcdatain
           integer(kind=inttype) dimension(nvar,nfammax),depend(nvar) :: famlists
           integer(kind=inttype) intent(in) :: sps
           integer(kind=inttype), optional,intent(in),check(shape(bcdatanamesin,0)==nvar),depend(bcdatanamesin) :: nvar=shape(bcdatanamesin,0)
           integer(kind=inttype), optional,intent(in),check(shape(famlists,1)==nfammax),depend(famlists) :: nfammax=shape(famlists,1)
         end subroutine setbcdata

       end module bcdata


       module agmg
         integer(kind=inttype) :: agmglevels
         integer(kind=inttype) :: agmgnsmooth

         subroutine setupagmg
         end subroutine setupagmg

         subroutine destroyagmg
         end subroutine destroyagmg

       end module agmg

       module flowutils

         subroutine updategamma
         end subroutine updategamma

         subroutine adjustinflowangle()
         end subroutine adjustinflowangle

       end module flowutils

       module inputparamroutines

         subroutine setdefaultvalues()
         end subroutine setdefaultvalues

         subroutine monitorvariables(variables) ! in :test:monitorVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine monitorvariables

         subroutine surfacevariables(variables) ! in :test:surfaceVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine surfacevariables

         subroutine volumevariables(variables) ! in :test:volumeVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine volumevariables

         subroutine isovariables(variables) ! in :test:volumeVariables.f90
           character*(*) intent(inout) :: variables
         end subroutine isovariables

         subroutine initializeisosurfacevariables(values,nvalues) ! in :test:setIsoSurfaceValues.F90
           real(kind=realtype), dimension(nvalues),intent(in) :: values
           integer(kind=inttype), optional,intent(in),check(len(values)>=nvalues),depend(values) :: nvalues=len(values)
         end subroutine initializeisosurfacevariables

         subroutine setisosurfacevariable(variable,ivar) ! in :test:setIsoSurfaceValues.F90
           character*(*), intent(in) :: variable
           integer(kind=inttype), intent(in) :: ivar
         end subroutine setisosurfacevariable

         subroutine dummyreadparamfile ! in :adflow:../../inputParam/readParamFile.f90
         end subroutine dummyreadparamfile

       end module inputparamroutines

       module nksolver

         integer(kind=inttype) :: nk_innerpreconits
         integer(kind=inttype) :: nk_outerpreconits
         integer(kind=inttype) :: nk_jacobianlag
         logical :: usenksolver
         logical :: nk_adpc
         logical :: nk_useew
         logical :: nk_viscpc
         integer(kind=inttype) :: nk_ls
         integer(kind=inttype) :: nk_subspace
         integer(kind=inttype) :: nk_asmoverlap
         real(kind=realtype) :: nk_rtolinit
         integer(kind=inttype) :: nk_ilufill
         real(kind=realtype) :: nk_switchtol
         real(kind=realtype) :: nk_cfl0
         real(kind=realtype) :: nk_fixedstep
         integer(kind=inttype) :: applypcsubspacesize
         logical :: freestreamresset

         subroutine getstates(states,ndimw)
           real(kind=realtype) dimension(ndimw),intent(out),depend(ndimw) :: states
           integer(kind=inttype) intent(in) :: ndimw
         end subroutine getstates

         subroutine setstates(states,ndimw)
           real(kind=realtype) dimension(ndimw),intent(in) :: states
           integer(kind=inttype) optional,intent(in),check(len(states)>=ndimw),depend(states) :: ndimw=len(states)
         end subroutine setstates

         subroutine getinfosize(isize)
           integer(kind=inttype) intent(out) :: isize
         end subroutine getinfosize

         subroutine setinfo(info,isize)
           real(kind=realtype) dimension(isize),intent(in) :: info
           integer(kind=inttype) optional,intent(in),check(len(info)>=isize),depend(info) :: isize=len(info)
         end subroutine setinfo

         subroutine getinfo(info,isize)
           real(kind=realtype) dimension(isize),intent(out),depend(isize) :: info
           integer(kind=inttype) intent(in) :: isize
         end subroutine getinfo

         subroutine getres(res,ndimw)
           real(kind=realtype) dimension(ndimw),intent(in,out) :: res
           integer(kind=inttype) optional,intent(in),check(len(res)>=ndimw),depend(res) :: ndimw=len(res)
         end subroutine getres

         subroutine applypc(in_vec,out_vec,ndof)
           real(kind=realtype) dimension(ndof),intent(in) :: in_vec
           real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
           integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
         end subroutine applypc

         subroutine applyadjointpc(in_vec,out_vec,ndof)
           real(kind=realtype) dimension(ndof),intent(in) :: in_vec
           real(kind=realtype) dimension(ndof),intent(in, out),depend(ndof) :: out_vec
           integer(kind=inttype) optional,check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
         end subroutine applyadjointpc

         subroutine destroynksolver
         end subroutine destroynksolver

         subroutine getfreestreamresidual(rhores,totalrres) ! in :test:NKSolvers.F90:nksolver
           real(kind=realtype) intent(out) :: rhores
           real(kind=realtype) intent(out) :: totalrres
         end subroutine getfreestreamresidual

       end module nksolver

       module anksolver
         use constants
         integer(kind=inttype) :: ank_innerpreconits
         integer(kind=inttype) :: ank_outerpreconits
         integer(kind=inttype) :: ank_jacobianlag
         logical :: useanksolver
         logical :: ank_useturbdadi
         integer(kind=inttype) :: ank_subspace
         integer(kind=inttype) :: ank_maxiter
         integer(kind=inttype) :: ank_asmoverlap
         real(kind=realtype) :: ank_rtol
         real(kind=realtype) :: ank_linresmax
         integer(kind=inttype) :: ank_ilufill
         real(kind=realtype) :: ank_switchtol
         real(kind=realtype) :: ank_cfl0
         real(kind=realtype) :: ank_cflmin0
         real(kind=realtype) :: ank_cfllimit
         real(kind=realtype) :: ank_cflfactor
         real(kind=realtype) :: ank_cflexponent
         real(kind=realtype) :: ank_cflcutback
         real(kind=realtype) :: ank_stepfactor
         real(kind=realtype) :: ank_stepmin
         real(kind=realtype) :: ank_constcflstep
         real(kind=realtype) :: ank_physlstol
         real(kind=realtype) :: ank_physlstolturb
         real(kind=realtype) :: ank_unstdylstol
         real(kind=realtype) :: ank_secondordswitchtol
         real(kind=realtype) :: ank_coupledswitchtol
         real(kind=realtype) :: ank_turbcflscale
         logical :: ank_usefullvisc
         real(kind=realtype) :: ank_pcupdatetol
         logical :: ank_adpc
         integer(kind=inttype) :: ank_nsubiterturb
         logical :: ank_turbdebug
         logical :: ank_usematrixfree
         subroutine destroyanksolver
         end subroutine destroyanksolver

       end module anksolver

       module partitioning
         subroutine partitionandreadgrid(partitiononly)
           logical :: partitiononly
         end subroutine partitionandreadgrid

         subroutine checkpartitioning(np,load_inbalance,face_inbalance)
           integer(kind=inttype) intent(in) :: np
           real(kind=realtype) intent(out) :: load_inbalance
           real(kind=realtype) intent(out) :: face_inbalance
         end subroutine checkpartitioning

       end module partitioning

       module warping

         subroutine getcgnsmeshindices(ndof,indices)
           integer(kind=inttype) intent(in) :: ndof
           integer(kind=inttype) dimension(ndof),intent(out),depend(ndof) :: indices
         end subroutine getcgnsmeshindices

         subroutine setgrid(grid,ndof)
           real(kind=realtype) dimension(ndof),intent(in) :: grid
           integer(kind=inttype) optional,intent(in),check(len(grid)>=ndof),depend(grid) :: ndof=len(grid)
         end subroutine setgrid

         subroutine getgrid(grid,ndof)
           real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: grid
           integer(kind=inttype) intent(in) :: ndof
         end subroutine getgrid

         subroutine getstateperturbation(randvec,nrand,randstate,nrandstate)
           real(kind=realtype) dimension(nrand),intent(in) :: randvec
           integer(kind=inttype), optional,intent(in),check(len(randvec)>=nrand),depend(randvec) :: nrand=len(randvec)
           real(kind=realtype) dimension(nrandstate),intent(out),depend(nrandstate) :: randstate
           integer(kind=inttype) intent(in) :: nrandstate
         end subroutine getstateperturbation

          subroutine getsurfaceperturbation(xrand,nrand,randsurface,nrandsurface, famlist,nfamlist,sps) ! in :test:warping.F90:warping
           real(kind=realtype) dimension(nrand),intent(in) :: xrand
           integer(kind=inttype), optional,intent(in),check(len(xrand)>=nrand),depend(xrand) :: nrand=len(xrand)
           real(kind=realtype) dimension(3 * nrandsurface),intent(inout) :: randsurface
           integer(kind=inttype), optional,intent(in),check((len(randsurface))/(3)>=nrandsurface),depend(randsurface) :: nrandsurface=(len(randsurface))/(3)
           integer(kind=inttype) dimension(nfamlist),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=nfamlist),depend(famlist) :: nfamlist=len(famlist)
           integer(kind=inttype) intent(in) :: sps
         end subroutine getsurfaceperturbation
       end module warping

       module surfaceutils
         subroutine getsurfacesize(size_bn,sizecell,famlist,n,includezipper) ! in :test:surfaceUtils.F90:surfaceutils
           integer(kind=inttype) intent(out) :: size_bn
           integer(kind=inttype) intent(out) :: sizecell
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
           logical intent(in) :: includezipper
         end subroutine getsurfacesize
         subroutine getsurfaceconnectivity(conn,cgnsblockid,ncell,famlist,nfamlist,includezipper) ! in :test:surfaceUtils.F90:surfaceutils
           integer(kind=inttype) dimension(4 * ncell),intent(inout) :: conn
           integer(kind=inttype) dimension(ncell),intent(inout) :: cgnsblockid
           integer(kind=inttype), optional,intent(in),check((len(conn))/(4)>=ncell),depend(conn) :: ncell=(len(conn))/(4)
           integer(kind=inttype) dimension(nfamlist),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=nfamlist),depend(famlist) :: nfamlist=len(famlist)
           logical intent(in) :: includezipper
         end subroutine getsurfaceconnectivity

         subroutine getsurfacepoints(points,npts,sps_in,famlist,nfamlist,includezipper) ! in :test:surfaceUtils.F90:surfaceutils
           real(kind=realtype) dimension(3,npts),intent(inout) :: points
           integer(kind=inttype), optional,intent(in),check(shape(points,1)==npts),depend(points) :: npts=shape(points,1)
           integer(kind=inttype) intent(in) :: sps_in
           integer(kind=inttype) dimension(nfamlist),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=nfamlist),depend(famlist) :: nfamlist=len(famlist)
           logical intent(in) :: includezipper
         end subroutine getsurfacepoints

         ! subroutine mapvector(vec1,n1,famlist1,nf1,vec2,n2,famlist2,nf2,includezipper) ! in :test:surfaceUtils.F90:surfaceutils
         !   real(kind=realtype) dimension(3,n1),intent(in) :: vec1
         !   integer(kind=inttype), optional,check(shape(vec1,1)==n1),depend(vec1) :: n1=shape(vec1,1)
         !   integer(kind=inttype) dimension(nf1),intent(in) :: famlist1
         !   integer(kind=inttype), optional,check(len(famlist1)>=nf1),depend(famlist1) :: nf1=len(famlist1)
         !   real(kind=realtype) dimension(3,n2),intent(inout) :: vec2
         !   integer(kind=inttype), optional,check(shape(vec2,1)==n2),depend(vec2) :: n2=shape(vec2,1)
         !   integer(kind=inttype) dimension(nf2),intent(in) :: famlist2
         !   integer(kind=inttype), optional,check(len(famlist2)>=nf2),depend(famlist2) :: nf2=len(famlist2)
         !   logical intent(in) :: includezipper
         ! end subroutine mapvector

         subroutine mapvector(vec1,n1,famlist1,nf1,vec2,n2,famlist2,nf2,includezipper,ndim) ! in ../utils/surfaceUtils.F90:surfaceutils
           use blockpointers, only: ndom,flowdoms
           use sorting, only: faminlist
           use surfacefamilies, only: bcfamgroups
           use constants
           use oversetdata, only: oversetpresent,zippermeshes,zippermesh
           real(kind=realtype) dimension(ndim,n1),intent(in) :: vec1
           integer(kind=inttype), optional,check(shape(vec1,1)==n1),depend(vec1) :: n1=shape(vec1,1)
           integer(kind=inttype) dimension(nf1),intent(in) :: famlist1
           integer(kind=inttype), optional,check(len(famlist1)>=nf1),depend(famlist1) :: nf1=len(famlist1)
           real(kind=realtype) dimension(ndim,n2),intent(inout),depend(ndim) :: vec2
           integer(kind=inttype), optional,check(shape(vec2,1)==n2),depend(vec2) :: n2=shape(vec2,1)
           integer(kind=inttype) dimension(nf2),intent(in) :: famlist2
           integer(kind=inttype), optional,check(len(famlist2)>=nf2),depend(famlist2) :: nf2=len(famlist2)
           logical intent(in) :: includezipper
           integer(kind=inttype), optional,check(shape(vec1,0)==ndim),depend(vec1) :: ndim=shape(vec1,0)
         end subroutine mapvector

         subroutine getwalllist(walllist,nwalllist,nfamtotal) ! in :test:surfaceUtils.F90:surfaceutils
           integer(kind=inttype) dimension(nfamtotal),intent(out),depend(nfamtotal) :: walllist
           integer(kind=inttype) intent(out) :: nwalllist
           integer(kind=inttype) intent(in) :: nfamtotal
         end subroutine getwalllist
       end module surfaceutils

       module tecplotio
         subroutine addparaslice(slicename,pt,direction,famlist,n) ! in :test:liftDistribution.F90
           character*(*) intent(in) :: slicename
           real(kind=realtype) dimension(3),intent(in) :: pt
           real(kind=realtype) dimension(3),intent(in) :: direction
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine addparaslice

         subroutine addabsslice(slicename,pt,direction,famlist,n) ! in :test:liftDistribution.F90
           character*(*) intent(in) :: slicename
           real(kind=realtype) dimension(3),intent(in) :: pt
           real(kind=realtype) dimension(3),intent(in) :: direction
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine addabsslice

         subroutine addliftdistribution(nsegments,dir_vec,dir_ind, distname,famlist,n) ! in :test:liftDistribution.F90
           integer(kind=inttype) intent(in) :: nsegments
           real(kind=realtype) dimension(3), intent(in) :: dir_vec
           integer(kind=inttype), intent(in) :: dir_ind
           character*(*) intent(in) :: distname
           integer(kind=inttype) dimension(n),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=n),depend(famlist) :: n=len(famlist)
         end subroutine addliftdistribution

         subroutine writetecplot(slicefile,writeslices,liftfile,writelift,surffile,writesurf,famlist,nfamlist) ! in :test:tecplotIO.F90:tecplotio
           character*(*) intent(in) :: slicefile
           logical intent(in) :: writeslices
           character*(*) intent(in) :: liftfile
           logical intent(in) :: writelift
           character*(*) intent(in) :: surffile
           logical intent(in) :: writesurf
           integer(kind=inttype) dimension(nfamlist),intent(in) :: famlist
           integer(kind=inttype), optional,intent(in),check(len(famlist)>=nfamlist),depend(famlist) :: nfamlist=len(famlist)
         end subroutine writetecplot

         subroutine initializeliftdistributiondata
         end subroutine initializeliftdistributiondata
       end subroutine tecplotio

       module surfaceintegrations
         subroutine getsolutionwrap(famlists,funcvalues,ncost,ngroups,nfammax) ! in :test:surfaceIntegrations.F90:surfaceintegrations
           integer(kind=inttype) dimension(ngroups,nfammax) :: famlists
           real(kind=realtype) dimension(ncost,ngroups),intent(out),depend(ncost,ngroups) :: funcvalues
           integer(kind=inttype) :: ncost
           integer(kind=inttype), optional,check(shape(famlists,0)==ngroups),depend(famlists) :: ngroups=shape(famlists,0)
           integer(kind=inttype), optional,check(shape(famlists,1)==nfammax),depend(famlists) :: nfammax=shape(famlists,1)
         end subroutine getsolutionwrap
       end module surfaceintegrations

       module usersurfaceintegrations
         subroutine addintegrationsurface(pts,conn,famname,famid,isinflow,npts,nconn) ! in :test:surfaceIntegrations.F90:surfaceintegrations
           real(kind=realtype) dimension(3,npts),intent(in) :: pts
           integer(kind=inttype) dimension(3,nconn),intent(in) :: conn
           character*maxstringlen :: famname
           integer(kind=inttype), intent(in) :: famid
           logical, intent(in) :: isinflow
           integer(kind=inttype), optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
           integer(kind=inttype), optional,intent(in),check(shape(conn,1)==nconn),depend(conn) :: nconn=shape(conn,1)
         end subroutine addintegrationsurface

         subroutine interpolateintegrationsurfaces
         end subroutine interpolateintegrationsurfaces

       end module usersurfaceintegrations

       module actuatorregion ! in :test:actuatorDiskRegion.F90
         subroutine addactuatorregion(pts,conn,axis1,axis2,famname,famid,thrust,torque,relaxstart,relaxend,npts,nconn) ! in :test:actuatorDiskRegion.F90:actuatorregion
           real(kind=realtype) dimension(3,npts),intent(in) :: pts
           integer(kind=inttype) dimension(4,nconn),intent(in) :: conn
           real(kind=realtype), dimension(3),intent(in) :: axis1
           real(kind=realtype), dimension(3),intent(in) :: axis2
           character*(*) :: famname
           integer(kind=inttype) intent(in) :: famid
           real(kind=realtype) :: thrust
           real(kind=realtype) :: torque
           real(kind=realtype) :: relaxstart
           real(kind=realtype) :: relaxend
           integer(kind=inttype), optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
           integer(kind=inttype), optional,intent(in),check(shape(conn,1)==nconn),depend(conn) :: nconn=shape(conn,1)
         end subroutine addactuatorregion

         subroutine writeactuatorregions(filename)
           character*(*) intent(in) :: filename
         end subroutine writeactuatorregions
       end module actuatorregion

       module solvers

         subroutine solver
         end subroutine solver

         subroutine solverunsteadyinit
         end subroutine solverunsteadyinit

         subroutine updateunsteadygeometry
         end subroutine updateunsteadygeometry

         subroutine solverunsteadystep
         end subroutine solverunsteadystep

       end module solvers

      module aleutils

         subroutine shiftlevelale
         end subroutine shiftlevelale

       end module aleutils

       module preprocessingapi
         subroutine preprocessing ! in :adflow:../../preprocessing/preprocessing.f90
         end subroutine preprocessing

         subroutine updatecoordinatesalllevels ! in :adflow:../../preprocessing/mdUpdateRoutines.f90
         end subroutine updatecoordinatesalllevels

         subroutine updatemetricsalllevels ! in :adflow:../../preprocessing/mdUpdateRoutines.f90
         end subroutine updatemetricsalllevels

         subroutine updategridvelocitiesalllevels ! in :adflow:../../preprocessing/mdUpdateRoutines.f90
         end subroutine updategridvelocitiesalllevels

         subroutine updateperiodicinfoalllevels
         end subroutine updateperiodicinfoalllevels

         subroutine shiftcoorandvolumes ! in :adflow:../../preprocessing/shiftCoorAndVolumes.F90
         end subroutine shiftcoorandvolumes

         subroutine updatereferencepoint
         end subroutine updatereferencepoint

         subroutine updaterotationrate(rotcenter,rotrate,blocks,nblocks) ! in :test:updateRotationRate.f90
           real(kind=realtype) dimension(3),intent(in) :: rotcenter
           real(kind=realtype) dimension(3),intent(in) :: rotrate
           integer(kind=inttype) dimension(nblocks),intent(in) :: blocks
           integer(kind=inttype), optional,intent(in),check(len(blocks)>=nblocks),depend(blocks) :: nblocks=len(blocks)
         end subroutine updaterotationrate

         subroutine preprocessingoverset(flag,n, closedfamlist, nfam) ! in :test:preprocessingAPI.F90:preprocessingapi
           integer(kind=inttype) dimension(n) :: flag
           integer(kind=inttype), optional,intent(in),check(len(flag)>=n),depend(flag) :: n=len(flag)
           integer(kind=inttype) dimension(nfam) :: closedfamlist
           integer(kind=inttype), optional,intent(in),check(len(closedfamlist)>=nfam),depend(closedfamlist) :: nfam=len(closedfamlist)
         end subroutine preprocessingoverset

       end module preprocessingapi

       module oversetapi
         subroutine updateoverset(flag, n, closedfamlist, nfam)
           integer(kind=inttype) dimension(n) :: flag
           integer(kind=inttype), optional,intent(in),check(len(flag)>=n),depend(flag) :: n=len(flag)
           integer(kind=inttype) dimension(nfam) :: closedfamlist
           integer(kind=inttype), optional,intent(in),check(len(closedfamlist)>=nfam),depend(closedfamlist) :: nfam=len(closedfamlist)
         end subroutine updateoverset
         subroutine writepartitionedmesh(filename)
           character*(*) intent(in) :: filename
         end subroutine writepartitionedmesh
         subroutine oversetcomm(level, firstime, coarselevel)
           integer(kind=inttype), intent(in) :: level
           logical, intent(in) :: firsttime
           logical, intent(in) :: coarselevel
         end subroutine oversetcomm
         subroutine setblockpriority(blkname, value, setvalue)
           character*(*) intent(in) :: blkname
           real(kind=realtype), intent(in) :: value
           logical, intent(out) :: setvalue
         end subroutine setblockpriority
       end module oversetapi

       module oversetutilities
         subroutine getoversetiblank(blklist,n) ! in :test:oversetUtilities.F90:oversetutilities
           integer(kind=inttype) dimension(n),intent(out),depend(n) :: blklist
           integer(kind=inttype) intent(in) :: n
         end subroutine getoversetiblank
       end module oversetutilities

       module adjointapi

         subroutine setuppetscksp
         end subroutine setuppetscksp

         subroutine setupallresidualmatricesfwd
         end subroutine setupallresidualmatricesfwd

         subroutine solveadjoint(rhs,psi,checksolution,nstate) ! in :test:solveADjointTransposePETSc.F90
           real(kind=realtype) dimension(nstate) :: rhs
           real(kind=realtype) dimension(nstate),depend(nstate) :: psi
           logical :: checksolution
           integer(kind=inttype), optional,check(len(rhs)>=nstate),depend(rhs) :: nstate=len(rhs)
         end subroutine solveadjoint

         subroutine solveadjointforrhs(invec,outvec,ndof,relativetolerance) ! in :test:matrixFreeRoutines.F90
           real(kind=realtype) dimension(ndof),intent(in) :: invec
           real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: outvec
           integer(kind=inttype), optional,intent(in),check(len(invec)>=ndof),depend(invec) :: ndof=len(invec)
           real(kind=realtype) intent(in) :: relativetolerance
         end subroutine solveadjointforrhs
         subroutine solvedirectforrhs(invec,outvec,ndof,relativetolerance) ! in :test:matrixFreeRoutines.F90
           real(kind=realtype) dimension(ndof),intent(in) :: invec
           real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: outvec
           integer(kind=inttype), optional,intent(in),check(len(invec)>=ndof),depend(invec) :: ndof=len(invec)
           real(kind=realtype) intent(in) :: relativetolerance
         end subroutine solvedirectforrhs

         subroutine saveadjointmatrix(filename)
           character*(*) intent(in) :: filename
         end subroutine saveadjointmatrix

         subroutine saveadjointpc(filename)
           character*(*) intent(in) :: filename
         end subroutine saveadjointpc

         subroutine saveadjointrhs(rhs,filename,nstate) ! in :test:solveADjointTransposePETSc.F90
           real(kind=realtype) dimension(nstate) :: rhs
           character*(*) intent(in) :: filename
           integer(kind=inttype), optional,check(len(rhs)>=nstate),depend(rhs) :: nstate=len(rhs)
         end subroutine solveadjoint


         subroutine savecellcenters(filename)
           character*(*) intent(in) :: filename
         end subroutine savecellcenters

         subroutine spectralprecscribedmotion(input,nin,dxv,nout)
           real(kind=realtype) dimension(nin),intent(in) :: input
           integer(kind=inttype), optional,intent(in),check(len(input)>=nin),depend(input) :: nin=len(input)
           real(kind=realtype) dimension(nout),intent(out),depend(nout) :: dxv
           integer(kind=inttype) intent(in) :: nout
         end subroutine spectralprecscribedmotion

         subroutine createpetscvars
         end subroutine createpetscvars

#ifndef USE_COMPLEX
            subroutine computematrixfreeproductfwd(xvdot,extradot,wdot,bcdatavaluesdot,usespatial,usestate,famlists,bcdatanames,bcdatavalues,bcdatafamlists,bcvarsempty,dwdot,funcsdot,fdot,costsize,fsize,ntime) ! in :test:adjointAPI.F90:adjointapi
                real(kind=realtype) dimension(:),intent(in) :: xvdot
                real(kind=realtype) dimension(:),intent(in) :: extradot
                real(kind=realtype) dimension(:),intent(in) :: wdot
                real(kind=realtype) dimension(:),intent(in) :: bcdatavaluesdot
                logical intent(in) :: usespatial
                logical intent(in) :: usestate
                integer(kind=inttype) dimension(:,:) :: famlists
                character dimension(:,:),intent(in) :: bcdatanames
                real(kind=realtype) dimension(:),intent(in) :: bcdatavalues
                integer(kind=inttype) dimension(:,:) :: bcdatafamlists
                logical intent(in) :: bcvarsempty
                real(kind=realtype) dimension(size(wdot)),intent(out),depend(wdot) :: dwdot
                real(kind=realtype) dimension(costsize, size(famlists,1)),intent(out),depend(famlists,costsize) :: funcsdot
                real(kind=realtype) dimension(3,fsize,ntime),intent(out),depend(fsize,ntime) :: fdot
                integer(kind=inttype) :: costsize
                integer(kind=inttype) :: fsize
                integer(kind=inttype) :: ntime
            end subroutine computematrixfreeproductfwd
           subroutine computematrixfreeproductbwd(dwbar,funcsbar,fbar,usespatial,usestate,xvbar,extrabar,wbar,spatialsize,extrasize,statesize,famlists,bcdatanames,bcdatavalues,bcdatavaluesbar,bcdatafamlists,bcvarsempty) ! in :test:adjointAPI.F90:adjointapi
                real(kind=realtype) dimension(:),intent(in) :: dwbar
                real(kind=realtype) dimension(:,:),intent(in) :: funcsbar
                real(kind=realtype) dimension(:,:,:) :: fbar
                logical intent(in) :: usespatial
                logical intent(in) :: usestate
                real(kind=realtype) dimension(spatialsize),intent(out),depend(spatialsize) :: xvbar
                real(kind=realtype) dimension(extrasize),intent(out),depend(extrasize) :: extrabar
                real(kind=realtype) dimension(statesize),intent(out),depend(statesize) :: wbar
                integer(kind=inttype) intent(in) :: spatialsize
                integer(kind=inttype) intent(in) :: extrasize
                integer(kind=inttype) intent(in) :: statesize
                integer(kind=inttype) dimension(:,:),intent(in) :: famlists
                character dimension(:,:),intent(in) :: bcdatanames
                real(kind=realtype) dimension(:),intent(in) :: bcdatavalues
                real(kind=realtype) dimension(size(bcdatavalues)),intent(out),depend(bcdatavalues) :: bcdatavaluesbar
                integer(kind=inttype) dimension(:,:) :: bcdatafamlists
                logical intent(in) :: bcvarsempty
            end subroutine computematrixfreeproductbwd
#endif
       end module adjointapi
       module adjointutils

         subroutine initializepetsc
         end subroutine initializepetsc

         subroutine destroypetscvars
         end subroutine destroypetscvars
       end module adjointutils

       module zippermesh
         subroutine createzippermesh(zipperfamlist,nzipfam) ! in :test:createZipperMesh.F90
           integer(kind=inttype) dimension(nzipfam),intent(in) :: zipperfamlist
           integer(kind=inttype), optional,intent(in),check(len(zipperfamlist)>=nzipfam),depend(zipperfamlist) :: nzipfam=len(zipperfamlist)
         end subroutine createzippermesh
         subroutine checkzipper(filename)
           character*(*) intent(in) :: filename
         end subroutine checkzipper
       end module zippermesh

       module oversetdata
         use constants
         real(kind=realtype) dimension(16) :: oversettimes
       end module oversetdata

! ================ bare subroutines =============

        subroutine writesol(famlist,nfamlist) ! in :test:writeSol.F90
            integer(kind=inttype) dimension(nfamlist),intent(in) :: famlist
            integer(kind=inttype), optional,intent(in),check(len(famlist)>=nfamlist),depend(famlist) :: nfamlist=len(famlist)
        end subroutine writesol

        subroutine getforces(forces,npts,sps) ! in :test:getForces.F90
          real(kind=realtype) dimension(3,npts),intent(inout) :: forces
          integer(kind=inttype), optional,intent(in),check(shape(forces,1)==npts),depend(forces) :: npts=shape(forces,1)
          integer(kind=inttype) intent(in) :: sps
        end subroutine getforces

       subroutine getheatflux(hflux,npts,sps_in) ! in :test:getForces.F90
         real(kind=realtype) dimension(npts),intent(inout) :: hflux
         integer(kind=inttype), optional,intent(in),depend(hflux) :: npts=len(hflux)
         integer(kind=inttype) intent(in) :: sps_in
       end subroutine getheatflux

       subroutine settnswall(tnsw,npts,sps_in) ! in :test:getForces.F90
         real(kind=realtype) dimension(npts),intent(in) :: tnsw
         integer(kind=inttype) optional,intent(in),check(len(tnsw)>=npts),depend(tnsw) :: npts=len(tnsw)
         integer(kind=inttype) intent(in) :: sps_in
       end subroutine settnswall

       subroutine gettnswall(tnsw,npts,sps) ! in :test:getForces.F90
         real(kind=realtype) dimension(npts),intent(out),depend(npts) :: tnsw
         integer(kind=inttype) intent(in) :: npts
         integer(kind=inttype) intent(in) :: sps
       end subroutine gettnswall

       subroutine setcptargets(cptarget,npts,sps_in) ! in :test:setCpTarget.f90
         real(kind=realtype) dimension(npts),intent(in) :: cptarget
         integer(kind=inttype) optional,intent(in),check(len(cptarget)>=npts),depend(cptarget) :: npts=len(cptarget)
         integer(kind=inttype) intent(in) :: sps_in
       end subroutine setcptargets

       subroutine getcptargets(cptarget,npts,sps) ! in :test:getForces.F90
         real(kind=realtype) dimension(npts),intent(out),depend(npts) :: cptarget
         integer(kind=inttype) intent(in) :: npts
         integer(kind=inttype) intent(in) :: sps
       end subroutine getcptargets

       subroutine getareas(areas,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: areas
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareas

       subroutine getareasensitivity(darea,pts,npts,sps_in,axis) ! in :test:getAreas.f90
         real(kind=realtype) dimension(3,npts),intent(out),depend(npts) :: darea
         real(kind=realtype) dimension(3,npts),intent(in) :: pts
         integer(kind=inttype) optional,intent(in),check(shape(pts,1)==npts),depend(pts) :: npts=shape(pts,1)
         integer(kind=inttype) intent(in) :: sps_in
         real(kind=realtype) dimension(3),intent(in) :: axis
       end subroutine getareasensitivity


       ! ############################################################################
       ! ADflow Modules
       ! ############################################################################
       module constants ! in :adflow:../../modules/constants.F90
         use precision
         integer parameter,optional :: maxstringlen   = 256
         integer parameter,optional :: maxcgnsnamelen =  32
         integer(kind=inttype) parameter,optional :: eulerequations=1_inttype
         integer(kind=inttype) parameter,optional :: nsequations=2_inttype
         integer(kind=inttype) parameter,optional :: ransequations=3_inttype
         integer(kind=inttype) parameter,optional :: steady=1_inttype
         integer(kind=inttype) parameter,optional :: unsteady=2_inttype
         integer(kind=inttype) parameter,optional :: timespectral=3_inttype
         integer(kind=inttype) parameter,optional :: internalflow=1_inttype
         integer(kind=inttype) parameter,optional :: externalflow=2_inttype
         integer(kind=inttype) parameter,optional :: cpconstant=1_inttype
         integer(kind=inttype) parameter,optional :: cptempcurvefits=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmaras=2_inttype
         integer(kind=inttype) parameter,optional :: spalartallmarasedwards=3_inttype
         integer(kind=inttype) parameter,optional :: komegawilcox=4_inttype
         integer(kind=inttype) parameter,optional :: komegamodified=5_inttype
         integer(kind=inttype) parameter,optional :: ktau=6_inttype
         integer(kind=inttype) parameter,optional :: mentersst=7_inttype
         integer(kind=inttype) parameter,optional :: v2f=10_inttype
         integer(kind=inttype) parameter,optional :: strain=1_inttype
         integer(kind=inttype) parameter,optional :: vorticity=2_inttype
         integer(kind=inttype) parameter,optional :: katolaunder=3_inttype
         integer(kind=inttype) parameter,optional :: dissscalar=1_inttype
         integer(kind=inttype) parameter,optional :: dissmatrix=2_inttype
         integer(kind=inttype) parameter,optional :: disscusp=3_inttype
         integer(kind=inttype) parameter,optional :: upwind=9_inttype
         integer(kind=inttype) parameter,optional :: roe=1_inttype
         integer(kind=inttype) parameter,optional :: vanleer=2_inttype
         integer(kind=inttype) parameter,optional :: ausmdv=3_inttype
         integer(kind=inttype) parameter,optional :: nolimiter=2_inttype
         integer(kind=inttype) parameter,optional :: vanalbeda=3_inttype
         integer(kind=inttype) parameter,optional :: minmod=4_inttype
         integer(kind=inttype) parameter,optional :: noprecond=1_inttype
         integer(kind=inttype) parameter,optional :: turkel=2_inttype
         integer(kind=inttype) parameter,optional :: choimerkle=3_inttype
         integer(kind=inttype) parameter,optional :: constantpressure=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapolpressure=2_inttype
         integer(kind=inttype) parameter,optional :: quadextrapolpressure=3_inttype
         integer(kind=inttype) parameter,optional :: normalmomentum=4_inttype
         integer(kind=inttype) parameter,optional :: constantextrapol=1_inttype
         integer(kind=inttype) parameter,optional :: linextrapol=2_inttype
         integer(kind=inttype) parameter,optional :: rungekutta=1_inttype
         integer(kind=inttype) parameter,optional :: dadi=2_inttype
         integer(kind=inttype) parameter,optional :: nllusgs=3_inttype
         integer(kind=inttype) parameter,optional :: nllusgsline=4_inttype
         integer(kind=inttype) parameter,optional :: segregated=1_inttype
         integer(kind=inttype) parameter,optional :: coupled=2_inttype
         integer(kind=inttype) parameter,optional :: gmres=1_inttype
         integer(kind=inttype) parameter,optional :: adi=2_inttype
         integer(kind=inttype) parameter,optional :: bcdirichlet0=0_inttype
         integer(kind=inttype) parameter,optional :: bcneumann0=1_inttype
         integer(kind=inttype) parameter,optional :: noresaveraging=0_inttype
         integer(kind=inttype) parameter,optional :: alwaysresaveraging=1_inttype
         integer(kind=inttype) parameter,optional :: alternateresaveraging=2_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxnotdefined=0_inttype
         integer(kind=inttype) parameter,optional :: turbrelaxexplicit=1_inttype
         integer(kind=inttype) parameter,optional :: turbrelaximplicit=2_inttype
         integer(kind=inttype) parameter,optional :: precisionsingle=1
         integer(kind=inttype) parameter,optional :: precisiondouble=2
         integer(kind=inttype) parameter,optional :: bdf=1
         integer(kind=inttype) parameter,optional :: explicitrk=2
         integer(kind=inttype) parameter,optional :: implicitrk=3
         integer(kind=inttype) parameter,optional :: md=4
         integer(kind=inttype) :: nolinesearch=0_inttype
         integer(kind=inttype) :: cubiclinesearch=1_inttype
         integer(kind=inttype) :: nonmonotonelinesearch=2_inttype
         integer(kind=inttype) :: updatefrozen = 0_inttype
         integer(kind=inttype) :: updatefast = 1_inttype
         integer(kind=inttype) :: updatefull = 2_inttype

         ! Cost functions
         integer(kind=inttype) :: ncostfunction
         integer(kind=inttype) parameter,optional :: costfunccdq=30
         integer(kind=inttype) parameter,optional :: costfuncforcezcoef=10
         integer(kind=inttype) parameter,optional :: costfuncmomzcoef=16
         integer(kind=inttype) parameter,optional :: costfunccm0=17
         integer(kind=inttype) parameter,optional :: costfuncforcex=5
         integer(kind=inttype) parameter,optional :: costfuncclq=25
         integer(kind=inttype) parameter,optional :: costfuncdrag=2
         integer(kind=inttype) parameter,optional :: costfunccl0=22
         integer(kind=inttype) parameter,optional :: costfunccmzqdot=21
         integer(kind=inttype) parameter,optional :: costfuncforcexcoef=8
         integer(kind=inttype) parameter,optional :: costfunccmzq=20
         integer(kind=inttype) parameter,optional :: costfunccmzalphadot=19
         integer(kind=inttype) parameter,optional :: costfunclift=1
         integer(kind=inttype) parameter,optional :: costfunccd0=27
         integer(kind=inttype) parameter,optional :: costfuncclqdot=26
         integer(kind=inttype) parameter,optional :: costfuncforcey=6
         integer(kind=inttype) parameter,optional :: costfuncforcez=7
         integer(kind=inttype) parameter,optional :: costfuncmomz=13
         integer(kind=inttype) parameter,optional :: costfunccdqdot=31
         integer(kind=inttype) parameter,optional :: costfuncmomx=11
         integer(kind=inttype) parameter,optional :: costfuncmomy=12
         integer(kind=inttype) parameter,optional :: costfunccdalphadot=29
         integer(kind=inttype) parameter,optional :: costfuncmomxcoef=14
         integer(kind=inttype) parameter,optional :: costfunccdalpha=28
         integer(kind=inttype) parameter,optional :: costfuncliftcoef=3
         integer(kind=inttype) parameter,optional :: costfunccmzalpha=18
         integer(kind=inttype) parameter,optional :: costfuncdragcoef=4
         integer(kind=inttype) parameter,optional :: costfuncclalphadot=24
         integer(kind=inttype) parameter,optional :: costfuncforceycoef=9
         integer(kind=inttype) parameter,optional :: costfuncclalpha=23
         integer(kind=inttype) parameter,optional :: costfuncmomycoef=15
         integer(kind=inttype) parameter,optional :: costfunccfy0=32
         integer(kind=inttype) parameter,optional :: costfunccfyalpha=33
         integer(kind=inttype) parameter,optional :: costfunccfyalphadot=34
         integer(kind=inttype) parameter,optional :: costfunccfyq=35
         integer(kind=inttype) parameter,optional :: costfunccfyqdot=36
         integer(kind=inttype) parameter,optional :: costfuncbendingcoef=37
         integer(kind=inttype) parameter,optional :: costfuncsepsensor=38
         integer(kind=inttype) parameter,optional :: costfuncsepsensoravgx=39
         integer(kind=inttype) parameter,optional :: costfuncsepsensoravgy=40
         integer(kind=inttype) parameter,optional :: costfuncsepsensoravgz=41
         integer(kind=inttype) parameter,optional :: costfunccavitation=42
         integer(kind=inttype) parameter,optional :: costfuncmdot=43
         integer(kind=inttype) parameter,optional :: costfuncmavgptot=44
         integer(kind=inttype) parameter,optional :: costfuncmavgttot=45
         integer(kind=inttype) parameter,optional :: costfuncmavgrho=46
         integer(kind=inttype) parameter,optional :: costfuncmavgps=47
         integer(kind=inttype) parameter,optional :: costfuncmavgmn=48
         integer(kind=inttype) parameter,optional :: costfuncmavga=49
         integer(kind=inttype) parameter,optional :: costfuncarea=50
         integer(kind=inttype) parameter,optional :: costfuncaxismoment=51
         integer(kind=inttype) parameter,optional :: costfuncflowpower=52
         integer(kind=inttype) parameter,optional :: costfuncforcexpressure=53
         integer(kind=inttype) parameter,optional :: costfuncforceypressure=54
         integer(kind=inttype) parameter,optional :: costfuncforcezpressure=55
         integer(kind=inttype) parameter,optional :: costfuncforcexviscous=56
         integer(kind=inttype) parameter,optional :: costfuncforceyviscous=57
         integer(kind=inttype) parameter,optional :: costfuncforcezviscous=58
         integer(kind=inttype) parameter,optional :: costfuncforcexmomentum=59
         integer(kind=inttype) parameter,optional :: costfuncforceymomentum=60
         integer(kind=inttype) parameter,optional :: costfuncforcezmomentum=61
         integer(kind=inttype) parameter,optional :: costfuncdragpressure=62
         integer(kind=inttype) parameter,optional :: costfuncdragviscous=63
         integer(kind=inttype) parameter,optional :: costfuncdragmomentum=64
         integer(kind=inttype) parameter,optional :: costfuncliftpressure=65
         integer(kind=inttype) parameter,optional :: costfuncliftviscous=66
         integer(kind=inttype) parameter,optional :: costfuncliftmomentum=67
         integer(kind=inttype) parameter,optional :: costfuncforcexcoefpressure=68
         integer(kind=inttype) parameter,optional :: costfuncforcexcoefviscous=69
         integer(kind=inttype) parameter,optional :: costfuncforcexcoefmomentum=70
         integer(kind=inttype) parameter,optional :: costfuncforceycoefpressure=71
         integer(kind=inttype) parameter,optional :: costfuncforceycoefviscous=72
         integer(kind=inttype) parameter,optional :: costfuncforceycoefmomentum=73
         integer(kind=inttype) parameter,optional :: costfuncforcezcoefpressure=74
         integer(kind=inttype) parameter,optional :: costfuncforcezcoefviscous=75
         integer(kind=inttype) parameter,optional :: costfuncforcezcoefmomentum=76
         integer(kind=inttype) parameter,optional :: costfuncliftcoefpressure=77
         integer(kind=inttype) parameter,optional :: costfuncliftcoefviscous=78
         integer(kind=inttype) parameter,optional :: costfuncliftcoefmomentum=79
         integer(kind=inttype) parameter,optional :: costfuncdragcoefpressure=80
         integer(kind=inttype) parameter,optional :: costfuncdragcoefviscous=81
         integer(kind=inttype) parameter,optional :: costfuncdragcoefmomentum=82
         integer(kind=inttype) parameter,optional :: costfuncmavgvx=83
         integer(kind=inttype) parameter,optional :: costfuncmavgvy=84
         integer(kind=inttype) parameter,optional :: costfuncmavgvz=85
         integer(kind=inttype) parameter,optional :: costfunccperror2=86
         integer(kind=inttype) parameter,optional :: costfuncaavgptot=87
         integer(kind=inttype) parameter,optional :: costfuncaavgps=88
        end module constants

       module communication ! in :adflow:../../modules/communication.f90
         use precision
         integer :: adflow_comm_world
         integer :: myid
         integer :: nproc
         integer allocatable,dimension(:) :: sendrequests
         integer allocatable,dimension(:) :: recvrequests
       end module communication

       module inputdiscretization ! in :adflow:../../modules/inputParam.f90
         use accuracy
         integer(kind=inttype) :: spacediscr
         integer(kind=inttype) :: spacediscrcoarse
         integer(kind=inttype) :: orderturb
         integer(kind=inttype) :: limiter
         integer(kind=inttype) :: riemann
         integer(kind=inttype) :: riemanncoarse
         integer(kind=inttype) :: precond
         integer(kind=inttype) :: eulerwallbctreatment
         integer(kind=inttype) :: viscwallbctreatment
         integer(kind=inttype) :: outflowtreatment
         real(kind=realtype) :: vis2
         real(kind=realtype) :: vis4
         real(kind=realtype) :: vis2coarse
         real(kind=realtype) :: adis
         real(kind=realtype) :: kappacoef
         logical :: vortexcorr
         logical :: dirscaling
         logical :: radiineededfine
         logical :: radiineededcoarse
         logical :: lumpeddiss
         real(kind=realtype) :: sigma
         logical :: useapproxwalldistance
         logical :: lowspeedpreconditioner
         logical :: useblockettes
       end module inputdiscretization

       module cgnsgrid
         use constants
         integer(kind=inttype) :: cgnsndom
       end module cgnsgrid

       module inputio ! in :adflow:../../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: solfile
         character(len=maxstringlen) :: surfacesolfile
         character(len=maxstringlen) :: slicesolfile ! TEMPORARY
         character(len=maxstringlen) :: liftdistributionfile ! TEMPORARY
         character(len=maxstringlen) :: cpfile
         logical :: writecoormeter
         integer(kind=inttype) :: precisionsol
         integer(kind=inttype) :: precisiongrid
         integer(kind=inttype) :: precisionsurfsol
         integer(kind=inttype) :: precisionsurfgrid
         character(len=maxstringlen) :: newgridfile
         character(len=maxstringlen) :: gridfile
         logical :: storeconvinneriter
         logical :: storerindlayer
         logical :: checkrestartsol
         logical :: autoparameterupdate
         logical :: viscoussurfacevelocities
         logical optional :: firstwrite=.true.
         character(len=maxstringlen) :: paramfile
         character(len=maxstringlen) :: forcedvolumefile
         character(len=maxstringlen) :: forcedsurfacefile
         character(len=maxstringlen) :: forcedliftfile
         character(len=maxstringlen) :: forcedslicefile
       end module inputio

       module inputiteration ! in :adflow:../../modules/inputParam.f90
         use constants
         logical :: rkreset
         character(len=maxstringlen) :: mgdescription
         integer(kind=inttype) :: ncycles
         real(kind=realtype) :: timelimit
         integer(kind=inttype) :: ncyclescoarse
         integer(kind=inttype) :: nsavevolume
         integer(kind=inttype) :: nsavesurface
         integer(kind=inttype) :: nsgstartup
         integer(kind=inttype) :: smoother
         integer(kind=inttype) :: nrkstages
         integer(kind=inttype) :: resaveraging
         real(kind=realtype) :: cfllimit
         integer(kind=inttype) :: turbtreatment
         integer(kind=inttype) :: nsubiterturb
         integer(kind=inttype) :: nsubiterations
         integer(kind=inttype) :: turbsmoother
         integer(kind=inttype) :: turbrelax
         integer(kind=inttype) :: mgboundcorr
         integer(kind=inttype) :: mgstartlevel
         integer(kind=inttype) :: nmgsteps
         integer(kind=inttype) :: nmglevels
         integer(kind=inttype) :: miniternum
         integer(kind=inttype) :: convcheckwindowsize
         integer(kind=inttype) allocatable,dimension(:) :: cyclestrategy
         real(kind=realtype) :: cfl
         real(kind=realtype) :: cflcoarse
         real(kind=realtype) :: fcoll
         real(kind=realtype) :: smoop
         real(kind=realtype) :: alfaturb
         real(kind=realtype) :: betaturb
         real(kind=realtype) :: l2conv
         real(kind=realtype) :: l2convcoarse
         real(kind=realtype) :: l2convrel
         real(kind=realtype) :: epscoefconv
         real(kind=realtype) allocatable,dimension(:) :: etark
         real(kind=realtype) allocatable,dimension(:) :: cdisrk
         real(kind=realtype), dimension(4) :: turbresscale
         logical :: freezeturbsource
         logical :: printiterations
         logical :: printwarnings
         real(kind=realtype) ::maxl2deviationfactor
         logical :: uselinresmonitor
       end module inputiteration

       module inputmotion ! in :adflow:../../modules/inputParam.f90
         use precision
         real(kind=realtype), dimension(3) :: rotpoint
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouryrot
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourxrot
         integer(kind=inttype) :: degreefourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouralpha
         real(kind=realtype) :: omegafourbeta
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourbeta
         integer(kind=inttype) :: degreepolbeta
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourmach
         integer(kind=inttype) :: degreepolmach
         real(kind=realtype) :: omegafourmach
         integer(kind=inttype) :: degreepolalpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolmach
         real(kind=realtype) allocatable,dimension(:) :: coscoeffouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourmach
         real(kind=realtype) allocatable,dimension(:) :: coefpolzrot
         logical :: gridmotionspecified
         real(kind=realtype) :: omegafourzrot
         integer(kind=inttype) :: degreefouryrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolyrot
         integer(kind=inttype) :: degreefourbeta
         real(kind=realtype) :: omegafouralpha
         real(kind=realtype) allocatable,dimension(:) :: coscoeffourzrot
         integer(kind=inttype) :: degreepolzrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourzrot
         real(kind=realtype) :: omegafouryrot
         integer(kind=inttype) :: degreefourzrot
         integer(kind=inttype) :: degreefourmach
         integer(kind=inttype) :: degreefouralpha
         real(kind=realtype) allocatable,dimension(:) :: coefpolalpha
         real(kind=realtype) :: omegafourxrot
         integer(kind=inttype) :: degreepolyrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffourxrot
         real(kind=realtype) allocatable,dimension(:) :: sincoeffouryrot
         integer(kind=inttype) :: degreepolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolxrot
         real(kind=realtype) allocatable,dimension(:) :: coefpolbeta
       end module inputmotion

       module inputparallel ! in :adflow:../../modules/inputParam.f90
         real(kind=realtype) :: loadimbalance
         logical :: splitblocks
         integer(kind=inttype) :: loadbalanceiter
         integer(kind=inttype) :: partitionlikenproc
       end module inputparallel

       module inputphysics ! in :adflow:../../modules/inputParam.f90
         use precision

         integer(kind=inttype) :: equations
         integer(kind=inttype) :: equationmode
         integer(kind=inttype) :: flowtype
         integer(kind=inttype) :: turbmodel
         integer(kind=inttype) :: cpmodel
         integer(kind=inttype) :: turbprod
         integer(kind=inttype) :: rvfn
         logical :: rvfb
         logical :: useqcr
         logical :: userotationsa
         logical :: useft2sa
         logical :: wallfunctions
         real(kind=realtype) :: mach
         real(kind=realtype) :: machcoef
         real(kind=realtype) :: machgrid
         real(kind=realtype) :: reynolds
         real(kind=realtype) :: reynoldslength
         real(kind=realtype) :: gammaconstant
         real(kind=realtype) :: rgasdim
         real(kind=realtype) :: prandtl
         real(kind=realtype) :: prandtlturb
         real(kind=realtype) :: pklim
         real(kind=realtype) :: walloffset
         real(kind=realtype) :: eddyvisinfratio
         real(kind=realtype) :: turbintensityinf
         real(kind=realtype) :: surfaceref
         real(kind=realtype) :: lengthref
         real(kind=realtype) dimension(3) :: veldirfreestream
         real(kind=realtype) dimension(3) :: liftdirection
         real(kind=realtype) dimension(3) :: dragdirection
         real(kind=realtype) dimension(3) :: pointref
         real(kind=realtype) dimension(3) :: pointrefec
         real(kind=realtype) dimension(3,2) :: momentaxis
         logical :: forcesastractions
         real(kind=realtype) :: ssuthdim
         real(kind=realtype) :: musuthdim
         real(kind=realtype) :: tsuthdim
         real(kind=realtype) :: walldistcutoff
         real(kind=realtype) :: alpha
         real(kind=realtype) :: beta
         integer(kind=inttype) :: liftindex
         real(kind=realtype) :: cavitationnumber
       end module inputphysics

       module inputadjoint ! in :adflow:../modules/inputParam.f90
         use constants
         character(len=maxstringlen) :: adjointpcside
         character(len=maxstringlen) :: matrixordering
         character(len=maxstringlen) :: adjointsolvertype
         character(len=maxstringlen) :: localpctype
         character(len=maxstringlen) :: precondtype
         real(kind=realtype) :: adjabstol
         real(kind=realtype) :: adjdivtol
         real(kind=realtype) :: adjreltol
         real(kind=realtype) :: adjreltolrel
         integer(kind=inttype) :: overlap
         integer(kind=inttype) :: adjmonstep
         integer(kind=inttype) :: filllevel
         integer(kind=inttype) :: adjmaxiter
         integer(kind=inttype) :: adjrestart
         integer(kind=inttype) :: innerpreconits
         integer(kind=inttype) :: outerpreconits
         logical :: approxpc
         logical :: adpc
         logical :: viscpc
         logical :: frozenturbulence
         logical :: usediagtspc
         logical :: restartadjoint
         logical :: setmonitor
         logical :: printtiming
         logical :: firstrun
         logical :: verifystate
         logical :: verifyspatial
         logical :: verifyextra
         logical :: usematrixfreedrdw
         integer(kind=inttype) :: applyadjointpcsubspacesize
       end module inputadjoint

       module inputtimespectral ! in :adflow:../../modules/inputParam.f90
         use precision
         integer(kind=inttype) :: ntimeintervalsspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: dscalar
         real(kind=realtype) allocatable,dimension(:,:,:) :: dvector
         real(kind=realtype) :: dtunsteadyrestartspectral
         logical :: writeunsteadyrestartspectral
         integer(kind=inttype) :: nunsteadysolspectral
         logical :: writeunsteadyvolspectral
         logical :: writeunsteadysurfspectral
         real(kind=realtype) allocatable,dimension(:,:,:) :: rotmatrixspectral
       end module inputtimespectral
       module inputoverset
         logical :: useoversetloadbalance
         real(kind=realtype) :: nearwalldist
         real(kind=realtype) :: backgroundvolscale
         real(kind=realtype) :: oversetprojtol
         real(kind=realtype) :: overlapfactor
         integer(kind=inttype) :: oversetupdatemode
         integer(kind=inttype)::nrefine
         logical :: debugzipper
         logical :: usezippermesh
         logical :: useoversetwallscaling
         real(kind=realtype) :: selfzipcutoff
       end module inputoverset

       module inputunsteady ! in :test:inputParam.f90
         use accuracy
         real(kind=realtype) :: deltat
         logical :: useale
         integer(kind=inttype) :: timeintegrationscheme
         logical :: updatewalldistanceunsteady
         integer(kind=inttype) :: timeaccuracy
         integer(kind=inttype) :: ntimestepsfine
         integer(kind=inttype) :: ntimestepscoarse
       end module inputunsteady

       module iteration ! in :adflow:../../modules/iteration.f90
         use precision
         integer(kind=inttype) :: groundlevel
         integer(kind=inttype) :: currentlevel
         integer(kind=inttype) :: rkstage
         integer(kind=inttype) :: nstepscycling
         integer(kind=inttype) allocatable,dimension(:) :: cycling
         integer(kind=inttype) :: itertot
         real(kind=realtype) :: rfil
         real(kind=realtype) :: t0solver
         logical :: converged
         logical :: exchangepressureearly
         logical :: standalonemode
         logical :: changing_grid
         logical :: deforming_grid
         logical :: changingoverset
         integer(kind=inttype) :: noldsolavail
         integer(kind=inttype) :: noldlevels
         real(kind=realtype) allocatable,dimension(:) :: coeftime
         logical :: timespectralgridsnotwritten
         logical, dimension(:), allocatable :: oldsolwritten
         real(kind=realtype) :: totalr0
         real(kind=realtype) :: totalrstart
         real(kind=realtype) :: totalrfinal
       end module iteration

       module monitor ! in :adflow:../../modules/monitor.f90
         use constants
         integer :: nmonsum
         integer :: nmonmax
         integer :: nmon
         real(kind=realtype) allocatable,dimension(:) :: monloc
         real(kind=realtype) allocatable,dimension(:) :: monglob
         real(kind=realtype) allocatable,dimension(:) :: monref
         character(len=32) allocatable,dimension(:) :: monnames
         logical :: monmachorhmax
         logical :: showcpu
         logical :: monmasssliding
         logical :: monmassfamilies
         integer :: nitercur
         real(kind=realtype) allocatable,dimension(:,:,:) :: convarray
         integer(kind=inttype) :: ntimestepsrestart
         integer(kind=inttype) :: timestepunsteady
         real(kind=realtype) :: timeunsteady
         real(kind=realtype) :: timeunsteadyrestart
         real(kind=realtype) allocatable,dimension(:) :: timearray
         real(kind=realtype) allocatable,dimension(:,:) :: timedataarray
         logical :: writegrid
         logical :: writevolume
         logical :: writesurface
       end module monitor

       module block ! in :adflow:../../modules/block.f90
         use constants
         integer(kind=inttype) :: ndom
         integer(kind=inttype) allocatable,dimension(:) :: ncellglobal
       end module block

       module flowvarrefstate ! in :adflow:../../modules/flowVarRefState.f90
         use constants
         integer(kind=inttype) :: nw
         integer(kind=inttype) :: nwf
         integer(kind=inttype) :: nwt
         integer(kind=inttype) :: nt1
         integer(kind=inttype) :: nt2
         real(kind=realtype) :: pref
         real(kind=realtype) :: rhoref
         real(kind=realtype) :: tref
         real(kind=realtype) :: muref
         real(kind=realtype) :: timeref
         real(kind=realtype) :: lref
         logical :: lrefspecified
         real(kind=realtype) :: pinfdim
         real(kind=realtype) :: rhoinfdim
         real(kind=realtype) :: tinfdim
         real(kind=realtype) :: mudim
         real(kind=realtype) :: rhoinf
         real(kind=realtype) :: uinf
         real(kind=realtype) :: pinf
         real(kind=realtype) :: pinfcorr
         real(kind=realtype) :: rgas
         real(kind=realtype) :: muinf
         real(kind=realtype) :: gammainf
         real(kind=realtype) allocatable,dimension(:) :: winf
         logical :: kpresent
         logical :: eddymodel
         logical :: viscous
       end module flowvarrefstate

       module killsignals ! in :adflow:../../modules/killSignals.f90
         use precision
         logical :: frompython
         logical :: routinefailed
         logical :: fatalfail
         logical :: adjointfailed
       end module killsignals

       module inputcostfunctions ! in :test:costFunctions.F90
         use constants
         real(kind=realtype) sepsensoroffset
         real(kind=realtype) sepsensorsharpness
         logical::computecavitation
       end module inputcostfunctions

       module adjointvars ! in :test:ADjointVars.F90
         use constants
            integer(kind=inttype) dimension(20) :: ncellslocal
            integer(kind=inttype) dimension(20) :: nnodeslocal
            integer(kind=inttype), parameter,optional :: ialpha=1
            integer(kind=inttype), parameter,optional :: ibeta=2
            integer(kind=inttype), parameter,optional :: imach=3
            integer(kind=inttype), parameter,optional :: imachgrid=4
            integer(kind=inttype), parameter,optional :: irotx=5
            integer(kind=inttype), parameter,optional :: iroty=6
            integer(kind=inttype), parameter,optional :: irotz=7
            integer(kind=inttype), parameter,optional :: irotcenx=8
            integer(kind=inttype), parameter,optional :: irotceny=9
            integer(kind=inttype), parameter,optional :: irotcenz=10
            integer(kind=inttype), parameter,optional :: ipointrefx=11
            integer(kind=inttype), parameter,optional :: ipointrefy=12
            integer(kind=inttype), parameter,optional :: ipointrefz=13
            integer(kind=inttype), parameter,optional :: ipressure=14
            integer(kind=inttype), parameter,optional :: itemperature=15
            integer(kind=inttype), parameter,optional :: idensity=16
            integer(kind=inttype), parameter,optional :: iaxisx1=17
            integer(kind=inttype), parameter,optional :: iaxisx2=18
            integer(kind=inttype), parameter,optional :: iaxisy1=19
            integer(kind=inttype), parameter,optional :: iaxisy2=20
            integer(kind=inttype), parameter,optional :: iaxisz1=21
            integer(kind=inttype), parameter,optional :: iaxisz2=22
            integer(kind=inttype), parameter,optional :: ndesignextra=22
          end module adjointvars

       module adjointpetsc
         real(kind=realtype) :: adjresinit, adjresstart, adjresfinal
       end module adjointpetsc

       module inputtsstabderiv ! in :test:inputParam.f90
         logical :: usewindaxis
         logical :: tsrmode
         logical :: tsstability
         logical :: tsbetamode
         logical :: tsmachmode
         logical :: tsaltitudemode
         logical :: tspmode
         logical :: tsqmode
         logical :: tsalphamode
         logical :: tsalphafollowing
       end module inputtsstabderiv

        module surfacefamilies ! in :test:inputParam.F90
          subroutine getnfam(nfam) ! in :test:surfaceFamilies.F90:surfacefamilies
            integer(kind=inttype) intent(out) :: nfam
          end subroutine getnfam
          subroutine getfam(i,fam) ! in :test:surfaceFamilies.F90:surfacefamilies
            integer(kind=inttype) intent(in) :: i
            character(32) intent(out) :: fam
          end subroutine getfam
        end module surfacefamilies


    end interface

#ifdef USE_COMPLEX
end python module libadflow_cs
#else
end python module libadflow
#endif
